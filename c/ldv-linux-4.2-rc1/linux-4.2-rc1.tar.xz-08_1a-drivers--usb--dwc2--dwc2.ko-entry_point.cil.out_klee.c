extern void abort(void);
#include <assert.h>
void reach_error() { assert(0); }
/* Generated by CIL v. 1.5.1 */
/* print_CIL_Input is false */

typedef unsigned char __u8;
    klee_make_symbolic(&__u8, sizeof(char), "__u8");
typedef unsigned short __u16;
    klee_make_symbolic(&__u16, sizeof(short), "__u16");
typedef int __s32;
    klee_make_symbolic(&__s32, sizeof(int), "__s32");
typedef unsigned int __u32;
    klee_make_symbolic(&__u32, sizeof(int), "__u32");
typedef unsigned long long __u64;
    klee_make_symbolic(&__u64, sizeof(long), "__u64");
typedef signed char s8;
    klee_make_symbolic(&s8, sizeof(char), "s8");
typedef unsigned char u8;
    klee_make_symbolic(&u8, sizeof(char), "u8");
typedef unsigned short u16;
    klee_make_symbolic(&u16, sizeof(short), "u16");
typedef int s32;
    klee_make_symbolic(&s32, sizeof(int), "s32");
typedef unsigned int u32;
    klee_make_symbolic(&u32, sizeof(int), "u32");
typedef long long s64;
    klee_make_symbolic(&s64, sizeof(long), "s64");
typedef unsigned long long u64;
    klee_make_symbolic(&u64, sizeof(long), "u64");
typedef long __kernel_long_t;
    klee_make_symbolic(&__kernel_long_t, sizeof(long), "__kernel_long_t");
typedef unsigned long __kernel_ulong_t;
    klee_make_symbolic(&__kernel_ulong_t, sizeof(long), "__kernel_ulong_t");
typedef int __kernel_pid_t;
    klee_make_symbolic(&__kernel_pid_t, sizeof(int), "__kernel_pid_t");
typedef unsigned int __kernel_uid32_t;
    klee_make_symbolic(&__kernel_uid32_t, sizeof(int), "__kernel_uid32_t");
typedef unsigned int __kernel_gid32_t;
    klee_make_symbolic(&__kernel_gid32_t, sizeof(int), "__kernel_gid32_t");
typedef __kernel_ulong_t __kernel_size_t;
typedef __kernel_long_t __kernel_ssize_t;
typedef long long __kernel_loff_t;
    klee_make_symbolic(&__kernel_loff_t, sizeof(long), "__kernel_loff_t");
typedef __kernel_long_t __kernel_time_t;
typedef __kernel_long_t __kernel_clock_t;
typedef int __kernel_timer_t;
    klee_make_symbolic(&__kernel_timer_t, sizeof(int), "__kernel_timer_t");
typedef int __kernel_clockid_t;
    klee_make_symbolic(&__kernel_clockid_t, sizeof(int), "__kernel_clockid_t");
typedef __u16 __le16;
typedef __u32 __le32;
struct kernel_symbol {
   unsigned long value ;
    klee_make_symbolic(&value, sizeof(long), "value");
   char const   *name ;
};
struct module;
typedef __u32 __kernel_dev_t;
typedef __kernel_dev_t dev_t;
typedef unsigned short umode_t;
    klee_make_symbolic(&umode_t, sizeof(short), "umode_t");
typedef __kernel_pid_t pid_t;
typedef __kernel_clockid_t clockid_t;
typedef _Bool bool;
typedef __kernel_uid32_t uid_t;
typedef __kernel_gid32_t gid_t;
typedef __kernel_loff_t loff_t;
typedef __kernel_size_t size_t;
typedef __kernel_ssize_t ssize_t;
typedef __kernel_time_t time_t;
typedef __s32 int32_t;
typedef __u32 uint32_t;
typedef unsigned long sector_t;
    klee_make_symbolic(&sector_t, sizeof(long), "sector_t");
typedef unsigned long blkcnt_t;
    klee_make_symbolic(&blkcnt_t, sizeof(long), "blkcnt_t");
typedef u64 dma_addr_t;
typedef unsigned int gfp_t;
    klee_make_symbolic(&gfp_t, sizeof(int), "gfp_t");
typedef unsigned int fmode_t;
    klee_make_symbolic(&fmode_t, sizeof(int), "fmode_t");
typedef unsigned int oom_flags_t;
    klee_make_symbolic(&oom_flags_t, sizeof(int), "oom_flags_t");
struct __anonstruct_atomic_t_6 {
   int counter ;
    klee_make_symbolic(&counter, sizeof(int), "counter");
};
typedef struct __anonstruct_atomic_t_6 atomic_t;
struct __anonstruct_atomic64_t_7 {
   long counter ;
};
typedef struct __anonstruct_atomic64_t_7 atomic64_t;
struct list_head {
   struct list_head *next ;
   struct list_head *prev ;
};
struct hlist_node;
struct hlist_head {
   struct hlist_node *first ;
};
struct hlist_node {
   struct hlist_node *next ;
   struct hlist_node **pprev ;
};
struct callback_head {
   struct callback_head *next ;
   void (*func)(struct callback_head * ) ;
};
struct pt_regs {
   unsigned long r15 ;
    klee_make_symbolic(&r15, sizeof(long), "r15");
   unsigned long r14 ;
    klee_make_symbolic(&r14, sizeof(long), "r14");
   unsigned long r13 ;
    klee_make_symbolic(&r13, sizeof(long), "r13");
   unsigned long r12 ;
    klee_make_symbolic(&r12, sizeof(long), "r12");
   unsigned long bp ;
    klee_make_symbolic(&bp, sizeof(long), "bp");
   unsigned long bx ;
    klee_make_symbolic(&bx, sizeof(long), "bx");
   unsigned long r11 ;
    klee_make_symbolic(&r11, sizeof(long), "r11");
   unsigned long r10 ;
    klee_make_symbolic(&r10, sizeof(long), "r10");
   unsigned long r9 ;
    klee_make_symbolic(&r9, sizeof(long), "r9");
   unsigned long r8 ;
    klee_make_symbolic(&r8, sizeof(long), "r8");
   unsigned long ax ;
    klee_make_symbolic(&ax, sizeof(long), "ax");
   unsigned long cx ;
    klee_make_symbolic(&cx, sizeof(long), "cx");
   unsigned long dx ;
    klee_make_symbolic(&dx, sizeof(long), "dx");
   unsigned long si ;
    klee_make_symbolic(&si, sizeof(long), "si");
   unsigned long di ;
    klee_make_symbolic(&di, sizeof(long), "di");
   unsigned long orig_ax ;
    klee_make_symbolic(&orig_ax, sizeof(long), "orig_ax");
   unsigned long ip ;
    klee_make_symbolic(&ip, sizeof(long), "ip");
   unsigned long cs ;
    klee_make_symbolic(&cs, sizeof(long), "cs");
   unsigned long flags ;
    klee_make_symbolic(&flags, sizeof(long), "flags");
   unsigned long sp ;
    klee_make_symbolic(&sp, sizeof(long), "sp");
   unsigned long ss ;
    klee_make_symbolic(&ss, sizeof(long), "ss");
};
struct __anonstruct____missing_field_name_9 {
   unsigned int a ;
    klee_make_symbolic(&a, sizeof(int), "a");
   unsigned int b ;
    klee_make_symbolic(&b, sizeof(int), "b");
};
struct __anonstruct____missing_field_name_10 {
   u16 limit0 ;
   u16 base0 ;
   unsigned char base1 ;
    klee_make_symbolic(&base1, sizeof(char), "base1");
   unsigned char type : 4 ;
   unsigned char s : 1 ;
   unsigned char dpl : 2 ;
   unsigned char p : 1 ;
   unsigned char limit : 4 ;
   unsigned char avl : 1 ;
   unsigned char l : 1 ;
   unsigned char d : 1 ;
   unsigned char g : 1 ;
   unsigned char base2 ;
    klee_make_symbolic(&base2, sizeof(char), "base2");
};
union __anonunion____missing_field_name_8 {
   struct __anonstruct____missing_field_name_9 __annonCompField4 ;
   struct __anonstruct____missing_field_name_10 __annonCompField5 ;
};
struct desc_struct {
   union __anonunion____missing_field_name_8 __annonCompField6 ;
};
typedef unsigned long pteval_t;
    klee_make_symbolic(&pteval_t, sizeof(long), "pteval_t");
typedef unsigned long pgdval_t;
    klee_make_symbolic(&pgdval_t, sizeof(long), "pgdval_t");
typedef unsigned long pgprotval_t;
    klee_make_symbolic(&pgprotval_t, sizeof(long), "pgprotval_t");
struct __anonstruct_pte_t_11 {
   pteval_t pte ;
};
typedef struct __anonstruct_pte_t_11 pte_t;
struct pgprot {
   pgprotval_t pgprot ;
};
typedef struct pgprot pgprot_t;
struct __anonstruct_pgd_t_12 {
   pgdval_t pgd ;
};
typedef struct __anonstruct_pgd_t_12 pgd_t;
struct page;
typedef struct page *pgtable_t;
struct file;
struct seq_file;
struct thread_struct;
struct mm_struct;
struct task_struct;
struct cpumask;
struct qspinlock {
   atomic_t val ;
};
typedef struct qspinlock arch_spinlock_t;
struct qrwlock {
   atomic_t cnts ;
   arch_spinlock_t lock ;
};
typedef struct qrwlock arch_rwlock_t;
typedef void (*ctor_fn_t)(void);
struct _ddebug {
   char const   *modname ;
   char const   *function ;
   char const   *filename ;
   char const   *format ;
   unsigned int lineno : 18 ;
   unsigned char flags ;
};
struct device;
struct file_operations;
struct completion;
struct atomic_notifier_head;
struct bug_entry {
   int bug_addr_disp ;
    klee_make_symbolic(&bug_addr_disp, sizeof(int), "bug_addr_disp");
   int file_disp ;
    klee_make_symbolic(&file_disp, sizeof(int), "file_disp");
   unsigned short line ;
    klee_make_symbolic(&line, sizeof(short), "line");
   unsigned short flags ;
};
struct timespec;
struct compat_timespec;
struct __anonstruct_futex_16 {
   u32 *uaddr ;
   u32 val ;
   u32 flags ;
   u32 bitset ;
   u64 time ;
   u32 *uaddr2 ;
};
struct __anonstruct_nanosleep_17 {
   clockid_t clockid ;
   struct timespec *rmtp ;
   struct compat_timespec *compat_rmtp ;
   u64 expires ;
};
struct pollfd;
struct __anonstruct_poll_18 {
   struct pollfd *ufds ;
   int nfds ;
    klee_make_symbolic(&nfds, sizeof(int), "nfds");
   int has_timeout ;
    klee_make_symbolic(&has_timeout, sizeof(int), "has_timeout");
   unsigned long tv_sec ;
    klee_make_symbolic(&tv_sec, sizeof(long), "tv_sec");
   unsigned long tv_nsec ;
    klee_make_symbolic(&tv_nsec, sizeof(long), "tv_nsec");
};
union __anonunion____missing_field_name_15 {
   struct __anonstruct_futex_16 futex ;
   struct __anonstruct_nanosleep_17 nanosleep ;
   struct __anonstruct_poll_18 poll ;
};
struct restart_block {
   long (*fn)(struct restart_block * ) ;
   union __anonunion____missing_field_name_15 __annonCompField7 ;
};
struct kernel_vm86_regs {
   struct pt_regs pt ;
   unsigned short es ;
    klee_make_symbolic(&es, sizeof(short), "es");
   unsigned short __esh ;
    klee_make_symbolic(&__esh, sizeof(short), "__esh");
   unsigned short ds ;
    klee_make_symbolic(&ds, sizeof(short), "ds");
   unsigned short __dsh ;
    klee_make_symbolic(&__dsh, sizeof(short), "__dsh");
   unsigned short fs ;
    klee_make_symbolic(&fs, sizeof(short), "fs");
   unsigned short __fsh ;
    klee_make_symbolic(&__fsh, sizeof(short), "__fsh");
   unsigned short gs ;
    klee_make_symbolic(&gs, sizeof(short), "gs");
   unsigned short __gsh ;
    klee_make_symbolic(&__gsh, sizeof(short), "__gsh");
};
union __anonunion____missing_field_name_19 {
   struct pt_regs *regs ;
   struct kernel_vm86_regs *vm86 ;
};
struct math_emu_info {
   long ___orig_eip ;
    klee_make_symbolic(&___orig_eip, sizeof(long), "___orig_eip");
   union __anonunion____missing_field_name_19 __annonCompField8 ;
};
struct cpumask {
   unsigned long bits[128U] ;
};
typedef struct cpumask cpumask_t;
typedef struct cpumask *cpumask_var_t;
struct fregs_state {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20U] ;
   u32 status ;
};
struct __anonstruct____missing_field_name_29 {
   u64 rip ;
   u64 rdp ;
};
struct __anonstruct____missing_field_name_30 {
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
};
union __anonunion____missing_field_name_28 {
   struct __anonstruct____missing_field_name_29 __annonCompField12 ;
   struct __anonstruct____missing_field_name_30 __annonCompField13 ;
};
union __anonunion____missing_field_name_31 {
   u32 padding1[12U] ;
   u32 sw_reserved[12U] ;
};
struct fxregs_state {
   u16 cwd ;
   u16 swd ;
   u16 twd ;
   u16 fop ;
   union __anonunion____missing_field_name_28 __annonCompField14 ;
   u32 mxcsr ;
   u32 mxcsr_mask ;
   u32 st_space[32U] ;
   u32 xmm_space[64U] ;
   u32 padding[12U] ;
   union __anonunion____missing_field_name_31 __annonCompField15 ;
};
struct swregs_state {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20U] ;
   u8 ftop ;
   u8 changed ;
   u8 lookahead ;
   u8 no_update ;
   u8 rm ;
   u8 alimit ;
   struct math_emu_info *info ;
   u32 entry_eip ;
};
struct xstate_header {
   u64 xfeatures ;
   u64 xcomp_bv ;
   u64 reserved[6U] ;
};
struct xregs_state {
   struct fxregs_state i387 ;
   struct xstate_header header ;
   u8 __reserved[464U] ;
};
union fpregs_state {
   struct fregs_state fsave ;
   struct fxregs_state fxsave ;
   struct swregs_state soft ;
   struct xregs_state xsave ;
};
struct fpu {
   union fpregs_state state ;
   unsigned int last_cpu ;
    klee_make_symbolic(&last_cpu, sizeof(int), "last_cpu");
   unsigned char fpstate_active ;
    klee_make_symbolic(&fpstate_active, sizeof(char), "fpstate_active");
   unsigned char fpregs_active ;
    klee_make_symbolic(&fpregs_active, sizeof(char), "fpregs_active");
   unsigned char counter ;
};
struct seq_operations;
struct perf_event;
struct thread_struct {
   struct desc_struct tls_array[3U] ;
   unsigned long sp0 ;
    klee_make_symbolic(&sp0, sizeof(long), "sp0");
   unsigned long sp ;
   unsigned short es ;
   unsigned short ds ;
   unsigned short fsindex ;
    klee_make_symbolic(&fsindex, sizeof(short), "fsindex");
   unsigned short gsindex ;
    klee_make_symbolic(&gsindex, sizeof(short), "gsindex");
   unsigned long fs ;
   unsigned long gs ;
   struct fpu fpu ;
   struct perf_event *ptrace_bps[4U] ;
   unsigned long debugreg6 ;
    klee_make_symbolic(&debugreg6, sizeof(long), "debugreg6");
   unsigned long ptrace_dr7 ;
    klee_make_symbolic(&ptrace_dr7, sizeof(long), "ptrace_dr7");
   unsigned long cr2 ;
    klee_make_symbolic(&cr2, sizeof(long), "cr2");
   unsigned long trap_nr ;
    klee_make_symbolic(&trap_nr, sizeof(long), "trap_nr");
   unsigned long error_code ;
    klee_make_symbolic(&error_code, sizeof(long), "error_code");
   unsigned long *io_bitmap_ptr ;
   unsigned long iopl ;
    klee_make_symbolic(&iopl, sizeof(long), "iopl");
   unsigned int io_bitmap_max ;
    klee_make_symbolic(&io_bitmap_max, sizeof(int), "io_bitmap_max");
};
typedef atomic64_t atomic_long_t;
struct lockdep_map;
struct stack_trace {
   unsigned int nr_entries ;
    klee_make_symbolic(&nr_entries, sizeof(int), "nr_entries");
   unsigned int max_entries ;
    klee_make_symbolic(&max_entries, sizeof(int), "max_entries");
   unsigned long *entries ;
   int skip ;
    klee_make_symbolic(&skip, sizeof(int), "skip");
};
struct lockdep_subclass_key {
   char __one_byte ;
    klee_make_symbolic(&__one_byte, sizeof(char), "__one_byte");
};
struct lock_class_key {
   struct lockdep_subclass_key subkeys[8U] ;
};
struct lock_class {
   struct list_head hash_entry ;
   struct list_head lock_entry ;
   struct lockdep_subclass_key *key ;
   unsigned int subclass ;
    klee_make_symbolic(&subclass, sizeof(int), "subclass");
   unsigned int dep_gen_id ;
    klee_make_symbolic(&dep_gen_id, sizeof(int), "dep_gen_id");
   unsigned long usage_mask ;
    klee_make_symbolic(&usage_mask, sizeof(long), "usage_mask");
   struct stack_trace usage_traces[13U] ;
   struct list_head locks_after ;
   struct list_head locks_before ;
   unsigned int version ;
    klee_make_symbolic(&version, sizeof(int), "version");
   unsigned long ops ;
    klee_make_symbolic(&ops, sizeof(long), "ops");
   char const   *name ;
   int name_version ;
    klee_make_symbolic(&name_version, sizeof(int), "name_version");
   unsigned long contention_point[4U] ;
   unsigned long contending_point[4U] ;
};
struct lockdep_map {
   struct lock_class_key *key ;
   struct lock_class *class_cache[2U] ;
   char const   *name ;
   int cpu ;
    klee_make_symbolic(&cpu, sizeof(int), "cpu");
   unsigned long ip ;
};
struct held_lock {
   u64 prev_chain_key ;
   unsigned long acquire_ip ;
    klee_make_symbolic(&acquire_ip, sizeof(long), "acquire_ip");
   struct lockdep_map *instance ;
   struct lockdep_map *nest_lock ;
   u64 waittime_stamp ;
   u64 holdtime_stamp ;
   unsigned short class_idx : 13 ;
   unsigned char irq_context : 2 ;
   unsigned char trylock : 1 ;
   unsigned char read : 2 ;
   unsigned char check : 1 ;
   unsigned char hardirqs_off : 1 ;
   unsigned short references : 12 ;
   unsigned int pin_count ;
    klee_make_symbolic(&pin_count, sizeof(int), "pin_count");
};
struct raw_spinlock {
   arch_spinlock_t raw_lock ;
   unsigned int magic ;
    klee_make_symbolic(&magic, sizeof(int), "magic");
   unsigned int owner_cpu ;
    klee_make_symbolic(&owner_cpu, sizeof(int), "owner_cpu");
   void *owner ;
   struct lockdep_map dep_map ;
};
typedef struct raw_spinlock raw_spinlock_t;
struct __anonstruct____missing_field_name_35 {
   u8 __padding[24U] ;
   struct lockdep_map dep_map ;
};
union __anonunion____missing_field_name_34 {
   struct raw_spinlock rlock ;
   struct __anonstruct____missing_field_name_35 __annonCompField17 ;
};
struct spinlock {
   union __anonunion____missing_field_name_34 __annonCompField18 ;
};
typedef struct spinlock spinlock_t;
struct __anonstruct_rwlock_t_36 {
   arch_rwlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
   struct lockdep_map dep_map ;
};
typedef struct __anonstruct_rwlock_t_36 rwlock_t;
struct seqcount {
   unsigned int sequence ;
    klee_make_symbolic(&sequence, sizeof(int), "sequence");
   struct lockdep_map dep_map ;
};
typedef struct seqcount seqcount_t;
struct __anonstruct_seqlock_t_45 {
   struct seqcount seqcount ;
   spinlock_t lock ;
};
typedef struct __anonstruct_seqlock_t_45 seqlock_t;
struct timespec {
   __kernel_time_t tv_sec ;
   long tv_nsec ;
};
struct user_namespace;
struct __anonstruct_kuid_t_46 {
   uid_t val ;
};
typedef struct __anonstruct_kuid_t_46 kuid_t;
struct __anonstruct_kgid_t_47 {
   gid_t val ;
};
typedef struct __anonstruct_kgid_t_47 kgid_t;
struct kstat {
   u64 ino ;
   dev_t dev ;
   umode_t mode ;
   unsigned int nlink ;
    klee_make_symbolic(&nlink, sizeof(int), "nlink");
   kuid_t uid ;
   kgid_t gid ;
   dev_t rdev ;
   loff_t size ;
   struct timespec atime ;
   struct timespec mtime ;
   struct timespec ctime ;
   unsigned long blksize ;
    klee_make_symbolic(&blksize, sizeof(long), "blksize");
   unsigned long long blocks ;
    klee_make_symbolic(&blocks, sizeof(long), "blocks");
};
struct vm_area_struct;
struct __wait_queue_head {
   spinlock_t lock ;
   struct list_head task_list ;
};
typedef struct __wait_queue_head wait_queue_head_t;
struct __anonstruct_nodemask_t_48 {
   unsigned long bits[16U] ;
};
typedef struct __anonstruct_nodemask_t_48 nodemask_t;
struct optimistic_spin_queue {
   atomic_t tail ;
};
struct mutex {
   atomic_t count ;
   spinlock_t wait_lock ;
   struct list_head wait_list ;
   struct task_struct *owner ;
   void *magic ;
   struct lockdep_map dep_map ;
};
struct mutex_waiter {
   struct list_head list ;
   struct task_struct *task ;
   void *magic ;
};
struct rw_semaphore;
struct rw_semaphore {
   long count ;
    klee_make_symbolic(&count, sizeof(long), "count");
   struct list_head wait_list ;
   raw_spinlock_t wait_lock ;
   struct optimistic_spin_queue osq ;
   struct task_struct *owner ;
   struct lockdep_map dep_map ;
};
struct completion {
   unsigned int done ;
    klee_make_symbolic(&done, sizeof(int), "done");
   wait_queue_head_t wait ;
};
union ktime {
   s64 tv64 ;
};
typedef union ktime ktime_t;
struct notifier_block;
struct timer_list {
   struct hlist_node entry ;
   unsigned long expires ;
    klee_make_symbolic(&expires, sizeof(long), "expires");
   void (*function)(unsigned long  ) ;
   unsigned long data ;
    klee_make_symbolic(&data, sizeof(long), "data");
   u32 flags ;
   int slack ;
    klee_make_symbolic(&slack, sizeof(int), "slack");
   int start_pid ;
    klee_make_symbolic(&start_pid, sizeof(int), "start_pid");
   void *start_site ;
   char start_comm[16U] ;
   struct lockdep_map lockdep_map ;
};
struct hrtimer;
enum hrtimer_restart;
struct rb_node {
   unsigned long __rb_parent_color ;
    klee_make_symbolic(&__rb_parent_color, sizeof(long), "__rb_parent_color");
   struct rb_node *rb_right ;
   struct rb_node *rb_left ;
};
struct rb_root {
   struct rb_node *rb_node ;
};
struct nsproxy;
struct workqueue_struct;
struct work_struct;
struct work_struct {
   atomic_long_t data ;
   struct list_head entry ;
   void (*func)(struct work_struct * ) ;
   struct lockdep_map lockdep_map ;
};
struct delayed_work {
   struct work_struct work ;
   struct timer_list timer ;
   struct workqueue_struct *wq ;
   int cpu ;
};
struct notifier_block {
   int (*notifier_call)(struct notifier_block * , unsigned long  , void * ) ;
   struct notifier_block *next ;
   int priority ;
    klee_make_symbolic(&priority, sizeof(int), "priority");
};
struct atomic_notifier_head {
   spinlock_t lock ;
   struct notifier_block *head ;
};
struct pm_message {
   int event ;
    klee_make_symbolic(&event, sizeof(int), "event");
};
typedef struct pm_message pm_message_t;
struct dev_pm_ops {
   int (*prepare)(struct device * ) ;
   void (*complete)(struct device * ) ;
   int (*suspend)(struct device * ) ;
   int (*resume)(struct device * ) ;
   int (*freeze)(struct device * ) ;
   int (*thaw)(struct device * ) ;
   int (*poweroff)(struct device * ) ;
   int (*restore)(struct device * ) ;
   int (*suspend_late)(struct device * ) ;
   int (*resume_early)(struct device * ) ;
   int (*freeze_late)(struct device * ) ;
   int (*thaw_early)(struct device * ) ;
   int (*poweroff_late)(struct device * ) ;
   int (*restore_early)(struct device * ) ;
   int (*suspend_noirq)(struct device * ) ;
   int (*resume_noirq)(struct device * ) ;
   int (*freeze_noirq)(struct device * ) ;
   int (*thaw_noirq)(struct device * ) ;
   int (*poweroff_noirq)(struct device * ) ;
   int (*restore_noirq)(struct device * ) ;
   int (*runtime_suspend)(struct device * ) ;
   int (*runtime_resume)(struct device * ) ;
   int (*runtime_idle)(struct device * ) ;
};
enum rpm_status {
    RPM_ACTIVE = 0,
    RPM_RESUMING = 1,
    RPM_SUSPENDED = 2,
    RPM_SUSPENDING = 3
} ;
enum rpm_request {
    RPM_REQ_NONE = 0,
    RPM_REQ_IDLE = 1,
    RPM_REQ_SUSPEND = 2,
    RPM_REQ_AUTOSUSPEND = 3,
    RPM_REQ_RESUME = 4
} ;
struct wakeup_source;
struct wake_irq;
struct pm_subsys_data {
   spinlock_t lock ;
   unsigned int refcount ;
    klee_make_symbolic(&refcount, sizeof(int), "refcount");
   struct list_head clock_list ;
};
struct dev_pm_qos;
struct dev_pm_info {
   pm_message_t power_state ;
   unsigned char can_wakeup : 1 ;
   unsigned char async_suspend : 1 ;
   bool is_prepared ;
   bool is_suspended ;
   bool is_noirq_suspended ;
   bool is_late_suspended ;
   bool ignore_children ;
   bool early_init ;
   bool direct_complete ;
   spinlock_t lock ;
   struct list_head entry ;
   struct completion completion ;
   struct wakeup_source *wakeup ;
   bool wakeup_path ;
   bool syscore ;
   struct timer_list suspend_timer ;
   unsigned long timer_expires ;
    klee_make_symbolic(&timer_expires, sizeof(long), "timer_expires");
   struct work_struct work ;
   wait_queue_head_t wait_queue ;
   struct wake_irq *wakeirq ;
   atomic_t usage_count ;
   atomic_t child_count ;
   unsigned char disable_depth : 3 ;
   unsigned char idle_notification : 1 ;
   unsigned char request_pending : 1 ;
   unsigned char deferred_resume : 1 ;
   unsigned char run_wake : 1 ;
   unsigned char runtime_auto : 1 ;
   unsigned char no_callbacks : 1 ;
   unsigned char irq_safe : 1 ;
   unsigned char use_autosuspend : 1 ;
   unsigned char timer_autosuspends : 1 ;
   unsigned char memalloc_noio : 1 ;
   enum rpm_request request ;
   enum rpm_status runtime_status ;
   int runtime_error ;
    klee_make_symbolic(&runtime_error, sizeof(int), "runtime_error");
   int autosuspend_delay ;
    klee_make_symbolic(&autosuspend_delay, sizeof(int), "autosuspend_delay");
   unsigned long last_busy ;
    klee_make_symbolic(&last_busy, sizeof(long), "last_busy");
   unsigned long active_jiffies ;
    klee_make_symbolic(&active_jiffies, sizeof(long), "active_jiffies");
   unsigned long suspended_jiffies ;
    klee_make_symbolic(&suspended_jiffies, sizeof(long), "suspended_jiffies");
   unsigned long accounting_timestamp ;
    klee_make_symbolic(&accounting_timestamp, sizeof(long), "accounting_timestamp");
   struct pm_subsys_data *subsys_data ;
   void (*set_latency_tolerance)(struct device * , s32  ) ;
   struct dev_pm_qos *qos ;
};
struct dev_pm_domain {
   struct dev_pm_ops ops ;
   void (*detach)(struct device * , bool  ) ;
   int (*activate)(struct device * ) ;
   void (*sync)(struct device * ) ;
   void (*dismiss)(struct device * ) ;
};
struct __anonstruct_mm_context_t_115 {
   void *ldt ;
   int size ;
    klee_make_symbolic(&size, sizeof(int), "size");
   unsigned short ia32_compat ;
    klee_make_symbolic(&ia32_compat, sizeof(short), "ia32_compat");
   struct mutex lock ;
   void *vdso ;
   atomic_t perf_rdpmc_allowed ;
};
typedef struct __anonstruct_mm_context_t_115 mm_context_t;
struct llist_node;
struct llist_node {
   struct llist_node *next ;
};
struct cred;
struct inode;
struct arch_uprobe_task {
   unsigned long saved_scratch_register ;
    klee_make_symbolic(&saved_scratch_register, sizeof(long), "saved_scratch_register");
   unsigned int saved_trap_nr ;
    klee_make_symbolic(&saved_trap_nr, sizeof(int), "saved_trap_nr");
   unsigned int saved_tf ;
    klee_make_symbolic(&saved_tf, sizeof(int), "saved_tf");
};
enum uprobe_task_state {
    UTASK_RUNNING = 0,
    UTASK_SSTEP = 1,
    UTASK_SSTEP_ACK = 2,
    UTASK_SSTEP_TRAPPED = 3
} ;
struct __anonstruct____missing_field_name_148 {
   struct arch_uprobe_task autask ;
   unsigned long vaddr ;
    klee_make_symbolic(&vaddr, sizeof(long), "vaddr");
};
struct __anonstruct____missing_field_name_149 {
   struct callback_head dup_xol_work ;
   unsigned long dup_xol_addr ;
    klee_make_symbolic(&dup_xol_addr, sizeof(long), "dup_xol_addr");
};
union __anonunion____missing_field_name_147 {
   struct __anonstruct____missing_field_name_148 __annonCompField33 ;
   struct __anonstruct____missing_field_name_149 __annonCompField34 ;
};
struct uprobe;
struct return_instance;
struct uprobe_task {
   enum uprobe_task_state state ;
   union __anonunion____missing_field_name_147 __annonCompField35 ;
   struct uprobe *active_uprobe ;
   unsigned long xol_vaddr ;
    klee_make_symbolic(&xol_vaddr, sizeof(long), "xol_vaddr");
   struct return_instance *return_instances ;
   unsigned int depth ;
    klee_make_symbolic(&depth, sizeof(int), "depth");
};
struct xol_area;
struct uprobes_state {
   struct xol_area *xol_area ;
};
struct address_space;
struct mem_cgroup;
typedef void compound_page_dtor(struct page * );
union __anonunion____missing_field_name_150 {
   struct address_space *mapping ;
   void *s_mem ;
};
union __anonunion____missing_field_name_152 {
   unsigned long index ;
    klee_make_symbolic(&index, sizeof(long), "index");
   void *freelist ;
   bool pfmemalloc ;
};
struct __anonstruct____missing_field_name_156 {
   unsigned short inuse ;
    klee_make_symbolic(&inuse, sizeof(short), "inuse");
   unsigned short objects : 15 ;
   unsigned char frozen : 1 ;
};
union __anonunion____missing_field_name_155 {
   atomic_t _mapcount ;
   struct __anonstruct____missing_field_name_156 __annonCompField38 ;
   int units ;
    klee_make_symbolic(&units, sizeof(int), "units");
};
struct __anonstruct____missing_field_name_154 {
   union __anonunion____missing_field_name_155 __annonCompField39 ;
   atomic_t _count ;
};
union __anonunion____missing_field_name_153 {
   unsigned long counters ;
    klee_make_symbolic(&counters, sizeof(long), "counters");
   struct __anonstruct____missing_field_name_154 __annonCompField40 ;
   unsigned int active ;
    klee_make_symbolic(&active, sizeof(int), "active");
};
struct __anonstruct____missing_field_name_151 {
   union __anonunion____missing_field_name_152 __annonCompField37 ;
   union __anonunion____missing_field_name_153 __annonCompField41 ;
};
struct __anonstruct____missing_field_name_158 {
   struct page *next ;
   int pages ;
    klee_make_symbolic(&pages, sizeof(int), "pages");
   int pobjects ;
    klee_make_symbolic(&pobjects, sizeof(int), "pobjects");
};
struct slab;
struct __anonstruct____missing_field_name_159 {
   compound_page_dtor *compound_dtor ;
   unsigned long compound_order ;
    klee_make_symbolic(&compound_order, sizeof(long), "compound_order");
};
union __anonunion____missing_field_name_157 {
   struct list_head lru ;
   struct __anonstruct____missing_field_name_158 __annonCompField43 ;
   struct slab *slab_page ;
   struct callback_head callback_head ;
   struct __anonstruct____missing_field_name_159 __annonCompField44 ;
   pgtable_t pmd_huge_pte ;
};
struct kmem_cache;
union __anonunion____missing_field_name_160 {
   unsigned long private ;
    klee_make_symbolic(&private, sizeof(long), "private");
   spinlock_t *ptl ;
   struct kmem_cache *slab_cache ;
   struct page *first_page ;
};
struct page {
   unsigned long flags ;
   union __anonunion____missing_field_name_150 __annonCompField36 ;
   struct __anonstruct____missing_field_name_151 __annonCompField42 ;
   union __anonunion____missing_field_name_157 __annonCompField45 ;
   union __anonunion____missing_field_name_160 __annonCompField46 ;
   struct mem_cgroup *mem_cgroup ;
};
struct page_frag {
   struct page *page ;
   __u32 offset ;
   __u32 size ;
};
struct __anonstruct_shared_161 {
   struct rb_node rb ;
   unsigned long rb_subtree_last ;
    klee_make_symbolic(&rb_subtree_last, sizeof(long), "rb_subtree_last");
};
struct anon_vma;
struct vm_operations_struct;
struct mempolicy;
struct vm_area_struct {
   unsigned long vm_start ;
    klee_make_symbolic(&vm_start, sizeof(long), "vm_start");
   unsigned long vm_end ;
    klee_make_symbolic(&vm_end, sizeof(long), "vm_end");
   struct vm_area_struct *vm_next ;
   struct vm_area_struct *vm_prev ;
   struct rb_node vm_rb ;
   unsigned long rb_subtree_gap ;
    klee_make_symbolic(&rb_subtree_gap, sizeof(long), "rb_subtree_gap");
   struct mm_struct *vm_mm ;
   pgprot_t vm_page_prot ;
   unsigned long vm_flags ;
    klee_make_symbolic(&vm_flags, sizeof(long), "vm_flags");
   struct __anonstruct_shared_161 shared ;
   struct list_head anon_vma_chain ;
   struct anon_vma *anon_vma ;
   struct vm_operations_struct  const  *vm_ops ;
   unsigned long vm_pgoff ;
    klee_make_symbolic(&vm_pgoff, sizeof(long), "vm_pgoff");
   struct file *vm_file ;
   void *vm_private_data ;
   struct mempolicy *vm_policy ;
};
struct core_thread {
   struct task_struct *task ;
   struct core_thread *next ;
};
struct core_state {
   atomic_t nr_threads ;
   struct core_thread dumper ;
   struct completion startup ;
};
struct task_rss_stat {
   int events ;
    klee_make_symbolic(&events, sizeof(int), "events");
   int count[3U] ;
};
struct mm_rss_stat {
   atomic_long_t count[3U] ;
};
struct kioctx_table;
struct linux_binfmt;
struct mmu_notifier_mm;
struct mm_struct {
   struct vm_area_struct *mmap ;
   struct rb_root mm_rb ;
   u32 vmacache_seqnum ;
   unsigned long (*get_unmapped_area)(struct file * , unsigned long  , unsigned long  ,
                                      unsigned long  , unsigned long  ) ;
   unsigned long mmap_base ;
    klee_make_symbolic(&mmap_base, sizeof(long), "mmap_base");
   unsigned long mmap_legacy_base ;
    klee_make_symbolic(&mmap_legacy_base, sizeof(long), "mmap_legacy_base");
   unsigned long task_size ;
    klee_make_symbolic(&task_size, sizeof(long), "task_size");
   unsigned long highest_vm_end ;
    klee_make_symbolic(&highest_vm_end, sizeof(long), "highest_vm_end");
   pgd_t *pgd ;
   atomic_t mm_users ;
   atomic_t mm_count ;
   atomic_long_t nr_ptes ;
   atomic_long_t nr_pmds ;
   int map_count ;
    klee_make_symbolic(&map_count, sizeof(int), "map_count");
   spinlock_t page_table_lock ;
   struct rw_semaphore mmap_sem ;
   struct list_head mmlist ;
   unsigned long hiwater_rss ;
    klee_make_symbolic(&hiwater_rss, sizeof(long), "hiwater_rss");
   unsigned long hiwater_vm ;
    klee_make_symbolic(&hiwater_vm, sizeof(long), "hiwater_vm");
   unsigned long total_vm ;
    klee_make_symbolic(&total_vm, sizeof(long), "total_vm");
   unsigned long locked_vm ;
    klee_make_symbolic(&locked_vm, sizeof(long), "locked_vm");
   unsigned long pinned_vm ;
    klee_make_symbolic(&pinned_vm, sizeof(long), "pinned_vm");
   unsigned long shared_vm ;
    klee_make_symbolic(&shared_vm, sizeof(long), "shared_vm");
   unsigned long exec_vm ;
    klee_make_symbolic(&exec_vm, sizeof(long), "exec_vm");
   unsigned long stack_vm ;
    klee_make_symbolic(&stack_vm, sizeof(long), "stack_vm");
   unsigned long def_flags ;
    klee_make_symbolic(&def_flags, sizeof(long), "def_flags");
   unsigned long start_code ;
    klee_make_symbolic(&start_code, sizeof(long), "start_code");
   unsigned long end_code ;
    klee_make_symbolic(&end_code, sizeof(long), "end_code");
   unsigned long start_data ;
    klee_make_symbolic(&start_data, sizeof(long), "start_data");
   unsigned long end_data ;
    klee_make_symbolic(&end_data, sizeof(long), "end_data");
   unsigned long start_brk ;
    klee_make_symbolic(&start_brk, sizeof(long), "start_brk");
   unsigned long brk ;
    klee_make_symbolic(&brk, sizeof(long), "brk");
   unsigned long start_stack ;
    klee_make_symbolic(&start_stack, sizeof(long), "start_stack");
   unsigned long arg_start ;
    klee_make_symbolic(&arg_start, sizeof(long), "arg_start");
   unsigned long arg_end ;
    klee_make_symbolic(&arg_end, sizeof(long), "arg_end");
   unsigned long env_start ;
    klee_make_symbolic(&env_start, sizeof(long), "env_start");
   unsigned long env_end ;
    klee_make_symbolic(&env_end, sizeof(long), "env_end");
   unsigned long saved_auxv[46U] ;
   struct mm_rss_stat rss_stat ;
   struct linux_binfmt *binfmt ;
   cpumask_var_t cpu_vm_mask_var ;
   mm_context_t context ;
   unsigned long flags ;
   struct core_state *core_state ;
   spinlock_t ioctx_lock ;
   struct kioctx_table *ioctx_table ;
   struct task_struct *owner ;
   struct file *exe_file ;
   struct mmu_notifier_mm *mmu_notifier_mm ;
   struct cpumask cpumask_allocation ;
   unsigned long numa_next_scan ;
    klee_make_symbolic(&numa_next_scan, sizeof(long), "numa_next_scan");
   unsigned long numa_scan_offset ;
    klee_make_symbolic(&numa_scan_offset, sizeof(long), "numa_scan_offset");
   int numa_scan_seq ;
    klee_make_symbolic(&numa_scan_seq, sizeof(int), "numa_scan_seq");
   bool tlb_flush_pending ;
   struct uprobes_state uprobes_state ;
   void *bd_addr ;
};
typedef __u64 Elf64_Addr;
typedef __u16 Elf64_Half;
typedef __u32 Elf64_Word;
typedef __u64 Elf64_Xword;
struct elf64_sym {
   Elf64_Word st_name ;
   unsigned char st_info ;
    klee_make_symbolic(&st_info, sizeof(char), "st_info");
   unsigned char st_other ;
    klee_make_symbolic(&st_other, sizeof(char), "st_other");
   Elf64_Half st_shndx ;
   Elf64_Addr st_value ;
   Elf64_Xword st_size ;
};
typedef struct elf64_sym Elf64_Sym;
union __anonunion____missing_field_name_166 {
   unsigned long bitmap[4U] ;
   struct callback_head callback_head ;
};
struct idr_layer {
   int prefix ;
    klee_make_symbolic(&prefix, sizeof(int), "prefix");
   int layer ;
    klee_make_symbolic(&layer, sizeof(int), "layer");
   struct idr_layer *ary[256U] ;
   int count ;
   union __anonunion____missing_field_name_166 __annonCompField47 ;
};
struct idr {
   struct idr_layer *hint ;
   struct idr_layer *top ;
   int layers ;
    klee_make_symbolic(&layers, sizeof(int), "layers");
   int cur ;
    klee_make_symbolic(&cur, sizeof(int), "cur");
   spinlock_t lock ;
   int id_free_cnt ;
    klee_make_symbolic(&id_free_cnt, sizeof(int), "id_free_cnt");
   struct idr_layer *id_free ;
};
struct ida_bitmap {
   long nr_busy ;
    klee_make_symbolic(&nr_busy, sizeof(long), "nr_busy");
   unsigned long bitmap[15U] ;
};
struct ida {
   struct idr idr ;
   struct ida_bitmap *free_bitmap ;
};
struct dentry;
struct iattr;
struct super_block;
struct file_system_type;
struct kernfs_open_node;
struct kernfs_iattrs;
struct kernfs_root;
struct kernfs_elem_dir {
   unsigned long subdirs ;
    klee_make_symbolic(&subdirs, sizeof(long), "subdirs");
   struct rb_root children ;
   struct kernfs_root *root ;
};
struct kernfs_node;
struct kernfs_elem_symlink {
   struct kernfs_node *target_kn ;
};
struct kernfs_ops;
struct kernfs_elem_attr {
   struct kernfs_ops  const  *ops ;
   struct kernfs_open_node *open ;
   loff_t size ;
   struct kernfs_node *notify_next ;
};
union __anonunion____missing_field_name_171 {
   struct kernfs_elem_dir dir ;
   struct kernfs_elem_symlink symlink ;
   struct kernfs_elem_attr attr ;
};
struct kernfs_node {
   atomic_t count ;
   atomic_t active ;
   struct lockdep_map dep_map ;
   struct kernfs_node *parent ;
   char const   *name ;
   struct rb_node rb ;
   void const   *ns ;
   unsigned int hash ;
    klee_make_symbolic(&hash, sizeof(int), "hash");
   union __anonunion____missing_field_name_171 __annonCompField48 ;
   void *priv ;
   unsigned short flags ;
   umode_t mode ;
   unsigned int ino ;
    klee_make_symbolic(&ino, sizeof(int), "ino");
   struct kernfs_iattrs *iattr ;
};
struct kernfs_syscall_ops {
   int (*remount_fs)(struct kernfs_root * , int * , char * ) ;
   int (*show_options)(struct seq_file * , struct kernfs_root * ) ;
   int (*mkdir)(struct kernfs_node * , char const   * , umode_t  ) ;
   int (*rmdir)(struct kernfs_node * ) ;
   int (*rename)(struct kernfs_node * , struct kernfs_node * , char const   * ) ;
};
struct kernfs_root {
   struct kernfs_node *kn ;
   unsigned int flags ;
   struct ida ino_ida ;
   struct kernfs_syscall_ops *syscall_ops ;
   struct list_head supers ;
   wait_queue_head_t deactivate_waitq ;
};
struct kernfs_open_file {
   struct kernfs_node *kn ;
   struct file *file ;
   void *priv ;
   struct mutex mutex ;
   int event ;
   struct list_head list ;
   char *prealloc_buf ;
   size_t atomic_write_len ;
   bool mmapped ;
   struct vm_operations_struct  const  *vm_ops ;
};
struct kernfs_ops {
   int (*seq_show)(struct seq_file * , void * ) ;
   void *(*seq_start)(struct seq_file * , loff_t * ) ;
   void *(*seq_next)(struct seq_file * , void * , loff_t * ) ;
   void (*seq_stop)(struct seq_file * , void * ) ;
   ssize_t (*read)(struct kernfs_open_file * , char * , size_t  , loff_t  ) ;
   size_t atomic_write_len ;
   bool prealloc ;
   ssize_t (*write)(struct kernfs_open_file * , char * , size_t  , loff_t  ) ;
   int (*mmap)(struct kernfs_open_file * , struct vm_area_struct * ) ;
   struct lock_class_key lockdep_key ;
};
struct sock;
struct kobject;
enum kobj_ns_type {
    KOBJ_NS_TYPE_NONE = 0,
    KOBJ_NS_TYPE_NET = 1,
    KOBJ_NS_TYPES = 2
} ;
struct kobj_ns_type_operations {
   enum kobj_ns_type type ;
   bool (*current_may_mount)(void) ;
   void *(*grab_current_ns)(void) ;
   void const   *(*netlink_ns)(struct sock * ) ;
   void const   *(*initial_ns)(void) ;
   void (*drop_ns)(void * ) ;
};
struct bin_attribute;
struct attribute {
   char const   *name ;
   umode_t mode ;
   bool ignore_lockdep ;
   struct lock_class_key *key ;
   struct lock_class_key skey ;
};
struct attribute_group {
   char const   *name ;
   umode_t (*is_visible)(struct kobject * , struct attribute * , int  ) ;
   struct attribute **attrs ;
   struct bin_attribute **bin_attrs ;
};
struct bin_attribute {
   struct attribute attr ;
   size_t size ;
   void *private ;
   ssize_t (*read)(struct file * , struct kobject * , struct bin_attribute * , char * ,
                   loff_t  , size_t  ) ;
   ssize_t (*write)(struct file * , struct kobject * , struct bin_attribute * , char * ,
                    loff_t  , size_t  ) ;
   int (*mmap)(struct file * , struct kobject * , struct bin_attribute * , struct vm_area_struct * ) ;
};
struct sysfs_ops {
   ssize_t (*show)(struct kobject * , struct attribute * , char * ) ;
   ssize_t (*store)(struct kobject * , struct attribute * , char const   * , size_t  ) ;
};
struct kref {
   atomic_t refcount ;
};
struct kset;
struct kobj_type;
struct kobject {
   char const   *name ;
   struct list_head entry ;
   struct kobject *parent ;
   struct kset *kset ;
   struct kobj_type *ktype ;
   struct kernfs_node *sd ;
   struct kref kref ;
   struct delayed_work release ;
   unsigned char state_initialized : 1 ;
   unsigned char state_in_sysfs : 1 ;
   unsigned char state_add_uevent_sent : 1 ;
   unsigned char state_remove_uevent_sent : 1 ;
   unsigned char uevent_suppress : 1 ;
};
struct kobj_type {
   void (*release)(struct kobject * ) ;
   struct sysfs_ops  const  *sysfs_ops ;
   struct attribute **default_attrs ;
   struct kobj_ns_type_operations  const  *(*child_ns_type)(struct kobject * ) ;
   void const   *(*namespace)(struct kobject * ) ;
};
struct kobj_uevent_env {
   char *argv[3U] ;
   char *envp[32U] ;
   int envp_idx ;
    klee_make_symbolic(&envp_idx, sizeof(int), "envp_idx");
   char buf[2048U] ;
   int buflen ;
    klee_make_symbolic(&buflen, sizeof(int), "buflen");
};
struct kset_uevent_ops {
   int (* const  filter)(struct kset * , struct kobject * ) ;
   char const   *(* const  name)(struct kset * , struct kobject * ) ;
   int (* const  uevent)(struct kset * , struct kobject * , struct kobj_uevent_env * ) ;
};
struct kset {
   struct list_head list ;
   spinlock_t list_lock ;
   struct kobject kobj ;
   struct kset_uevent_ops  const  *uevent_ops ;
};
struct kernel_param;
struct kernel_param_ops {
   unsigned int flags ;
   int (*set)(char const   * , struct kernel_param  const  * ) ;
   int (*get)(char * , struct kernel_param  const  * ) ;
   void (*free)(void * ) ;
};
struct kparam_string;
struct kparam_array;
union __anonunion____missing_field_name_172 {
   void *arg ;
   struct kparam_string  const  *str ;
   struct kparam_array  const  *arr ;
};
struct kernel_param {
   char const   *name ;
   struct module *mod ;
   struct kernel_param_ops  const  *ops ;
   u16 const   perm ;
   s8 level ;
   u8 flags ;
   union __anonunion____missing_field_name_172 __annonCompField49 ;
};
struct kparam_string {
   unsigned int maxlen ;
    klee_make_symbolic(&maxlen, sizeof(int), "maxlen");
   char *string ;
};
struct kparam_array {
   unsigned int max ;
    klee_make_symbolic(&max, sizeof(int), "max");
   unsigned int elemsize ;
    klee_make_symbolic(&elemsize, sizeof(int), "elemsize");
   unsigned int *num ;
   struct kernel_param_ops  const  *ops ;
   void *elem ;
};
struct latch_tree_node {
   struct rb_node node[2U] ;
};
struct mod_arch_specific {

};
struct module_param_attrs;
struct module_kobject {
   struct kobject kobj ;
   struct module *mod ;
   struct kobject *drivers_dir ;
   struct module_param_attrs *mp ;
   struct completion *kobj_completion ;
};
struct module_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct module_attribute * , struct module_kobject * , char * ) ;
   ssize_t (*store)(struct module_attribute * , struct module_kobject * , char const   * ,
                    size_t  ) ;
   void (*setup)(struct module * , char const   * ) ;
   int (*test)(struct module * ) ;
   void (*free)(struct module * ) ;
};
struct exception_table_entry;
enum module_state {
    MODULE_STATE_LIVE = 0,
    MODULE_STATE_COMING = 1,
    MODULE_STATE_GOING = 2,
    MODULE_STATE_UNFORMED = 3
} ;
struct mod_tree_node {
   struct module *mod ;
   struct latch_tree_node node ;
};
struct module_sect_attrs;
struct module_notes_attrs;
struct tracepoint;
struct trace_event_call;
struct trace_enum_map;
struct module {
   enum module_state state ;
   struct list_head list ;
   char name[56U] ;
   struct module_kobject mkobj ;
   struct module_attribute *modinfo_attrs ;
   char const   *version ;
   char const   *srcversion ;
   struct kobject *holders_dir ;
   struct kernel_symbol  const  *syms ;
   unsigned long const   *crcs ;
   unsigned int num_syms ;
    klee_make_symbolic(&num_syms, sizeof(int), "num_syms");
   struct mutex param_lock ;
   struct kernel_param *kp ;
   unsigned int num_kp ;
    klee_make_symbolic(&num_kp, sizeof(int), "num_kp");
   unsigned int num_gpl_syms ;
    klee_make_symbolic(&num_gpl_syms, sizeof(int), "num_gpl_syms");
   struct kernel_symbol  const  *gpl_syms ;
   unsigned long const   *gpl_crcs ;
   struct kernel_symbol  const  *unused_syms ;
   unsigned long const   *unused_crcs ;
   unsigned int num_unused_syms ;
    klee_make_symbolic(&num_unused_syms, sizeof(int), "num_unused_syms");
   unsigned int num_unused_gpl_syms ;
    klee_make_symbolic(&num_unused_gpl_syms, sizeof(int), "num_unused_gpl_syms");
   struct kernel_symbol  const  *unused_gpl_syms ;
   unsigned long const   *unused_gpl_crcs ;
   bool sig_ok ;
   bool async_probe_requested ;
   struct kernel_symbol  const  *gpl_future_syms ;
   unsigned long const   *gpl_future_crcs ;
   unsigned int num_gpl_future_syms ;
    klee_make_symbolic(&num_gpl_future_syms, sizeof(int), "num_gpl_future_syms");
   unsigned int num_exentries ;
    klee_make_symbolic(&num_exentries, sizeof(int), "num_exentries");
   struct exception_table_entry *extable ;
   int (*init)(void) ;
   void *module_init ;
   void *module_core ;
   unsigned int init_size ;
    klee_make_symbolic(&init_size, sizeof(int), "init_size");
   unsigned int core_size ;
    klee_make_symbolic(&core_size, sizeof(int), "core_size");
   unsigned int init_text_size ;
    klee_make_symbolic(&init_text_size, sizeof(int), "init_text_size");
   unsigned int core_text_size ;
    klee_make_symbolic(&core_text_size, sizeof(int), "core_text_size");
   struct mod_tree_node mtn_core ;
   struct mod_tree_node mtn_init ;
   unsigned int init_ro_size ;
    klee_make_symbolic(&init_ro_size, sizeof(int), "init_ro_size");
   unsigned int core_ro_size ;
    klee_make_symbolic(&core_ro_size, sizeof(int), "core_ro_size");
   struct mod_arch_specific arch ;
   unsigned int taints ;
    klee_make_symbolic(&taints, sizeof(int), "taints");
   unsigned int num_bugs ;
    klee_make_symbolic(&num_bugs, sizeof(int), "num_bugs");
   struct list_head bug_list ;
   struct bug_entry *bug_table ;
   Elf64_Sym *symtab ;
   Elf64_Sym *core_symtab ;
   unsigned int num_symtab ;
    klee_make_symbolic(&num_symtab, sizeof(int), "num_symtab");
   unsigned int core_num_syms ;
    klee_make_symbolic(&core_num_syms, sizeof(int), "core_num_syms");
   char *strtab ;
   char *core_strtab ;
   struct module_sect_attrs *sect_attrs ;
   struct module_notes_attrs *notes_attrs ;
   char *args ;
   void *percpu ;
   unsigned int percpu_size ;
    klee_make_symbolic(&percpu_size, sizeof(int), "percpu_size");
   unsigned int num_tracepoints ;
    klee_make_symbolic(&num_tracepoints, sizeof(int), "num_tracepoints");
   struct tracepoint * const  *tracepoints_ptrs ;
   unsigned int num_trace_bprintk_fmt ;
    klee_make_symbolic(&num_trace_bprintk_fmt, sizeof(int), "num_trace_bprintk_fmt");
   char const   **trace_bprintk_fmt_start ;
   struct trace_event_call **trace_events ;
   unsigned int num_trace_events ;
    klee_make_symbolic(&num_trace_events, sizeof(int), "num_trace_events");
   struct trace_enum_map **trace_enums ;
   unsigned int num_trace_enums ;
    klee_make_symbolic(&num_trace_enums, sizeof(int), "num_trace_enums");
   unsigned int num_ftrace_callsites ;
    klee_make_symbolic(&num_ftrace_callsites, sizeof(int), "num_ftrace_callsites");
   unsigned long *ftrace_callsites ;
   bool klp_alive ;
   struct list_head source_list ;
   struct list_head target_list ;
   void (*exit)(void) ;
   atomic_t refcnt ;
   ctor_fn_t (**ctors)(void) ;
   unsigned int num_ctors ;
    klee_make_symbolic(&num_ctors, sizeof(int), "num_ctors");
};
struct kernel_cap_struct {
   __u32 cap[2U] ;
};
typedef struct kernel_cap_struct kernel_cap_t;
struct plist_node {
   int prio ;
    klee_make_symbolic(&prio, sizeof(int), "prio");
   struct list_head prio_list ;
   struct list_head node_list ;
};
typedef unsigned long cputime_t;
    klee_make_symbolic(&cputime_t, sizeof(long), "cputime_t");
struct sem_undo_list;
struct sysv_sem {
   struct sem_undo_list *undo_list ;
};
struct user_struct;
struct sysv_shm {
   struct list_head shm_clist ;
};
struct __anonstruct_sigset_t_180 {
   unsigned long sig[1U] ;
};
typedef struct __anonstruct_sigset_t_180 sigset_t;
struct siginfo;
typedef void __signalfn_t(int  );
typedef __signalfn_t *__sighandler_t;
typedef void __restorefn_t(void);
typedef __restorefn_t *__sigrestore_t;
union sigval {
   int sival_int ;
    klee_make_symbolic(&sival_int, sizeof(int), "sival_int");
   void *sival_ptr ;
};
typedef union sigval sigval_t;
struct __anonstruct__kill_182 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
};
struct __anonstruct__timer_183 {
   __kernel_timer_t _tid ;
   int _overrun ;
    klee_make_symbolic(&_overrun, sizeof(int), "_overrun");
   char _pad[0U] ;
   sigval_t _sigval ;
   int _sys_private ;
    klee_make_symbolic(&_sys_private, sizeof(int), "_sys_private");
};
struct __anonstruct__rt_184 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
   sigval_t _sigval ;
};
struct __anonstruct__sigchld_185 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
   int _status ;
    klee_make_symbolic(&_status, sizeof(int), "_status");
   __kernel_clock_t _utime ;
   __kernel_clock_t _stime ;
};
struct __anonstruct__addr_bnd_187 {
   void *_lower ;
   void *_upper ;
};
struct __anonstruct__sigfault_186 {
   void *_addr ;
   short _addr_lsb ;
    klee_make_symbolic(&_addr_lsb, sizeof(short), "_addr_lsb");
   struct __anonstruct__addr_bnd_187 _addr_bnd ;
};
struct __anonstruct__sigpoll_188 {
   long _band ;
    klee_make_symbolic(&_band, sizeof(long), "_band");
   int _fd ;
    klee_make_symbolic(&_fd, sizeof(int), "_fd");
};
struct __anonstruct__sigsys_189 {
   void *_call_addr ;
   int _syscall ;
    klee_make_symbolic(&_syscall, sizeof(int), "_syscall");
   unsigned int _arch ;
    klee_make_symbolic(&_arch, sizeof(int), "_arch");
};
union __anonunion__sifields_181 {
   int _pad[28U] ;
   struct __anonstruct__kill_182 _kill ;
   struct __anonstruct__timer_183 _timer ;
   struct __anonstruct__rt_184 _rt ;
   struct __anonstruct__sigchld_185 _sigchld ;
   struct __anonstruct__sigfault_186 _sigfault ;
   struct __anonstruct__sigpoll_188 _sigpoll ;
   struct __anonstruct__sigsys_189 _sigsys ;
};
struct siginfo {
   int si_signo ;
    klee_make_symbolic(&si_signo, sizeof(int), "si_signo");
   int si_errno ;
    klee_make_symbolic(&si_errno, sizeof(int), "si_errno");
   int si_code ;
    klee_make_symbolic(&si_code, sizeof(int), "si_code");
   union __anonunion__sifields_181 _sifields ;
};
typedef struct siginfo siginfo_t;
struct sigpending {
   struct list_head list ;
   sigset_t signal ;
};
struct sigaction {
   __sighandler_t sa_handler ;
   unsigned long sa_flags ;
    klee_make_symbolic(&sa_flags, sizeof(long), "sa_flags");
   __sigrestore_t sa_restorer ;
   sigset_t sa_mask ;
};
struct k_sigaction {
   struct sigaction sa ;
};
enum pid_type {
    PIDTYPE_PID = 0,
    PIDTYPE_PGID = 1,
    PIDTYPE_SID = 2,
    PIDTYPE_MAX = 3
} ;
struct pid_namespace;
struct upid {
   int nr ;
    klee_make_symbolic(&nr, sizeof(int), "nr");
   struct pid_namespace *ns ;
   struct hlist_node pid_chain ;
};
struct pid {
   atomic_t count ;
   unsigned int level ;
    klee_make_symbolic(&level, sizeof(int), "level");
   struct hlist_head tasks[3U] ;
   struct callback_head rcu ;
   struct upid numbers[1U] ;
};
struct pid_link {
   struct hlist_node node ;
   struct pid *pid ;
};
struct percpu_counter {
   raw_spinlock_t lock ;
   s64 count ;
   struct list_head list ;
   s32 *counters ;
};
struct seccomp_filter;
struct seccomp {
   int mode ;
    klee_make_symbolic(&mode, sizeof(int), "mode");
   struct seccomp_filter *filter ;
};
struct rt_mutex_waiter;
struct rlimit {
   __kernel_ulong_t rlim_cur ;
   __kernel_ulong_t rlim_max ;
};
struct timerqueue_node {
   struct rb_node node ;
   ktime_t expires ;
};
struct timerqueue_head {
   struct rb_root head ;
   struct timerqueue_node *next ;
};
struct hrtimer_clock_base;
struct hrtimer_cpu_base;
enum hrtimer_restart {
    HRTIMER_NORESTART = 0,
    HRTIMER_RESTART = 1
} ;
struct hrtimer {
   struct timerqueue_node node ;
   ktime_t _softexpires ;
   enum hrtimer_restart (*function)(struct hrtimer * ) ;
   struct hrtimer_clock_base *base ;
   unsigned long state ;
    klee_make_symbolic(&state, sizeof(long), "state");
   int start_pid ;
   void *start_site ;
   char start_comm[16U] ;
};
struct hrtimer_clock_base {
   struct hrtimer_cpu_base *cpu_base ;
   int index ;
   clockid_t clockid ;
   struct timerqueue_head active ;
   ktime_t (*get_time)(void) ;
   ktime_t offset ;
};
struct hrtimer_cpu_base {
   raw_spinlock_t lock ;
   seqcount_t seq ;
   struct hrtimer *running ;
   unsigned int cpu ;
   unsigned int active_bases ;
    klee_make_symbolic(&active_bases, sizeof(int), "active_bases");
   unsigned int clock_was_set_seq ;
    klee_make_symbolic(&clock_was_set_seq, sizeof(int), "clock_was_set_seq");
   bool migration_enabled ;
   bool nohz_active ;
   unsigned char in_hrtirq : 1 ;
   unsigned char hres_active : 1 ;
   unsigned char hang_detected : 1 ;
   ktime_t expires_next ;
   struct hrtimer *next_timer ;
   unsigned int nr_events ;
    klee_make_symbolic(&nr_events, sizeof(int), "nr_events");
   unsigned int nr_retries ;
    klee_make_symbolic(&nr_retries, sizeof(int), "nr_retries");
   unsigned int nr_hangs ;
    klee_make_symbolic(&nr_hangs, sizeof(int), "nr_hangs");
   unsigned int max_hang_time ;
    klee_make_symbolic(&max_hang_time, sizeof(int), "max_hang_time");
   struct hrtimer_clock_base clock_base[4U] ;
};
struct task_io_accounting {
   u64 rchar ;
   u64 wchar ;
   u64 syscr ;
   u64 syscw ;
   u64 read_bytes ;
   u64 write_bytes ;
   u64 cancelled_write_bytes ;
};
struct latency_record {
   unsigned long backtrace[12U] ;
   unsigned int count ;
   unsigned long time ;
    klee_make_symbolic(&time, sizeof(long), "time");
   unsigned long max ;
};
struct assoc_array_ptr;
struct assoc_array {
   struct assoc_array_ptr *root ;
   unsigned long nr_leaves_on_tree ;
    klee_make_symbolic(&nr_leaves_on_tree, sizeof(long), "nr_leaves_on_tree");
};
typedef int32_t key_serial_t;
typedef uint32_t key_perm_t;
struct key;
struct signal_struct;
struct key_type;
struct keyring_index_key {
   struct key_type *type ;
   char const   *description ;
   size_t desc_len ;
};
union __anonunion____missing_field_name_196 {
   struct list_head graveyard_link ;
   struct rb_node serial_node ;
};
struct key_user;
union __anonunion____missing_field_name_197 {
   time_t expiry ;
   time_t revoked_at ;
};
struct __anonstruct____missing_field_name_199 {
   struct key_type *type ;
   char *description ;
};
union __anonunion____missing_field_name_198 {
   struct keyring_index_key index_key ;
   struct __anonstruct____missing_field_name_199 __annonCompField52 ;
};
union __anonunion_type_data_200 {
   struct list_head link ;
   unsigned long x[2U] ;
   void *p[2U] ;
   int reject_error ;
    klee_make_symbolic(&reject_error, sizeof(int), "reject_error");
};
union __anonunion_payload_202 {
   unsigned long value ;
   void *rcudata ;
   void *data ;
   void *data2[2U] ;
};
union __anonunion____missing_field_name_201 {
   union __anonunion_payload_202 payload ;
   struct assoc_array keys ;
};
struct key {
   atomic_t usage ;
   key_serial_t serial ;
   union __anonunion____missing_field_name_196 __annonCompField50 ;
   struct rw_semaphore sem ;
   struct key_user *user ;
   void *security ;
   union __anonunion____missing_field_name_197 __annonCompField51 ;
   time_t last_used_at ;
   kuid_t uid ;
   kgid_t gid ;
   key_perm_t perm ;
   unsigned short quotalen ;
    klee_make_symbolic(&quotalen, sizeof(short), "quotalen");
   unsigned short datalen ;
    klee_make_symbolic(&datalen, sizeof(short), "datalen");
   unsigned long flags ;
   union __anonunion____missing_field_name_198 __annonCompField53 ;
   union __anonunion_type_data_200 type_data ;
   union __anonunion____missing_field_name_201 __annonCompField54 ;
};
struct audit_context;
struct group_info {
   atomic_t usage ;
   int ngroups ;
    klee_make_symbolic(&ngroups, sizeof(int), "ngroups");
   int nblocks ;
    klee_make_symbolic(&nblocks, sizeof(int), "nblocks");
   kgid_t small_block[32U] ;
   kgid_t *blocks[0U] ;
};
struct cred {
   atomic_t usage ;
   atomic_t subscribers ;
   void *put_addr ;
   unsigned int magic ;
   kuid_t uid ;
   kgid_t gid ;
   kuid_t suid ;
   kgid_t sgid ;
   kuid_t euid ;
   kgid_t egid ;
   kuid_t fsuid ;
   kgid_t fsgid ;
   unsigned int securebits ;
    klee_make_symbolic(&securebits, sizeof(int), "securebits");
   kernel_cap_t cap_inheritable ;
   kernel_cap_t cap_permitted ;
   kernel_cap_t cap_effective ;
   kernel_cap_t cap_bset ;
   unsigned char jit_keyring ;
    klee_make_symbolic(&jit_keyring, sizeof(char), "jit_keyring");
   struct key *session_keyring ;
   struct key *process_keyring ;
   struct key *thread_keyring ;
   struct key *request_key_auth ;
   void *security ;
   struct user_struct *user ;
   struct user_namespace *user_ns ;
   struct group_info *group_info ;
   struct callback_head rcu ;
};
struct percpu_ref;
typedef void percpu_ref_func_t(struct percpu_ref * );
struct percpu_ref {
   atomic_long_t count ;
   unsigned long percpu_count_ptr ;
    klee_make_symbolic(&percpu_count_ptr, sizeof(long), "percpu_count_ptr");
   percpu_ref_func_t *release ;
   percpu_ref_func_t *confirm_switch ;
   bool force_atomic ;
   struct callback_head rcu ;
};
struct cgroup;
struct cgroup_root;
struct cgroup_subsys;
struct cgroup_taskset;
struct cgroup_subsys_state {
   struct cgroup *cgroup ;
   struct cgroup_subsys *ss ;
   struct percpu_ref refcnt ;
   struct cgroup_subsys_state *parent ;
   struct list_head sibling ;
   struct list_head children ;
   int id ;
    klee_make_symbolic(&id, sizeof(int), "id");
   unsigned int flags ;
   u64 serial_nr ;
   struct callback_head callback_head ;
   struct work_struct destroy_work ;
};
struct css_set {
   atomic_t refcount ;
   struct hlist_node hlist ;
   struct list_head tasks ;
   struct list_head mg_tasks ;
   struct list_head cgrp_links ;
   struct cgroup *dfl_cgrp ;
   struct cgroup_subsys_state *subsys[12U] ;
   struct list_head mg_preload_node ;
   struct list_head mg_node ;
   struct cgroup *mg_src_cgrp ;
   struct css_set *mg_dst_cset ;
   struct list_head e_cset_node[12U] ;
   struct callback_head callback_head ;
};
struct cgroup {
   struct cgroup_subsys_state self ;
   unsigned long flags ;
   int id ;
   int populated_cnt ;
    klee_make_symbolic(&populated_cnt, sizeof(int), "populated_cnt");
   struct kernfs_node *kn ;
   struct kernfs_node *procs_kn ;
   struct kernfs_node *populated_kn ;
   unsigned int subtree_control ;
    klee_make_symbolic(&subtree_control, sizeof(int), "subtree_control");
   unsigned int child_subsys_mask ;
    klee_make_symbolic(&child_subsys_mask, sizeof(int), "child_subsys_mask");
   struct cgroup_subsys_state *subsys[12U] ;
   struct cgroup_root *root ;
   struct list_head cset_links ;
   struct list_head e_csets[12U] ;
   struct list_head pidlists ;
   struct mutex pidlist_mutex ;
   wait_queue_head_t offline_waitq ;
   struct work_struct release_agent_work ;
};
struct cgroup_root {
   struct kernfs_root *kf_root ;
   unsigned int subsys_mask ;
    klee_make_symbolic(&subsys_mask, sizeof(int), "subsys_mask");
   int hierarchy_id ;
    klee_make_symbolic(&hierarchy_id, sizeof(int), "hierarchy_id");
   struct cgroup cgrp ;
   atomic_t nr_cgrps ;
   struct list_head root_list ;
   unsigned int flags ;
   struct idr cgroup_idr ;
   char release_agent_path[4096U] ;
   char name[64U] ;
};
struct cftype {
   char name[64U] ;
   int private ;
   umode_t mode ;
   size_t max_write_len ;
   unsigned int flags ;
   struct cgroup_subsys *ss ;
   struct list_head node ;
   struct kernfs_ops *kf_ops ;
   u64 (*read_u64)(struct cgroup_subsys_state * , struct cftype * ) ;
   s64 (*read_s64)(struct cgroup_subsys_state * , struct cftype * ) ;
   int (*seq_show)(struct seq_file * , void * ) ;
   void *(*seq_start)(struct seq_file * , loff_t * ) ;
   void *(*seq_next)(struct seq_file * , void * , loff_t * ) ;
   void (*seq_stop)(struct seq_file * , void * ) ;
   int (*write_u64)(struct cgroup_subsys_state * , struct cftype * , u64  ) ;
   int (*write_s64)(struct cgroup_subsys_state * , struct cftype * , s64  ) ;
   ssize_t (*write)(struct kernfs_open_file * , char * , size_t  , loff_t  ) ;
   struct lock_class_key lockdep_key ;
};
struct cgroup_subsys {
   struct cgroup_subsys_state *(*css_alloc)(struct cgroup_subsys_state * ) ;
   int (*css_online)(struct cgroup_subsys_state * ) ;
   void (*css_offline)(struct cgroup_subsys_state * ) ;
   void (*css_released)(struct cgroup_subsys_state * ) ;
   void (*css_free)(struct cgroup_subsys_state * ) ;
   void (*css_reset)(struct cgroup_subsys_state * ) ;
   void (*css_e_css_changed)(struct cgroup_subsys_state * ) ;
   int (*can_attach)(struct cgroup_subsys_state * , struct cgroup_taskset * ) ;
   void (*cancel_attach)(struct cgroup_subsys_state * , struct cgroup_taskset * ) ;
   void (*attach)(struct cgroup_subsys_state * , struct cgroup_taskset * ) ;
   void (*fork)(struct task_struct * ) ;
   void (*exit)(struct cgroup_subsys_state * , struct cgroup_subsys_state * , struct task_struct * ) ;
   void (*bind)(struct cgroup_subsys_state * ) ;
   int disabled ;
    klee_make_symbolic(&disabled, sizeof(int), "disabled");
   int early_init ;
    klee_make_symbolic(&early_init, sizeof(int), "early_init");
   bool broken_hierarchy ;
   bool warned_broken_hierarchy ;
   int id ;
   char const   *name ;
   struct cgroup_root *root ;
   struct idr css_idr ;
   struct list_head cfts ;
   struct cftype *dfl_cftypes ;
   struct cftype *legacy_cftypes ;
   unsigned int depends_on ;
    klee_make_symbolic(&depends_on, sizeof(int), "depends_on");
};
struct futex_pi_state;
struct robust_list_head;
struct bio_list;
struct fs_struct;
struct perf_event_context;
struct blk_plug;
struct nameidata;
struct cfs_rq;
struct task_group;
struct sighand_struct {
   atomic_t count ;
   struct k_sigaction action[64U] ;
   spinlock_t siglock ;
   wait_queue_head_t signalfd_wqh ;
};
struct pacct_struct {
   int ac_flag ;
    klee_make_symbolic(&ac_flag, sizeof(int), "ac_flag");
   long ac_exitcode ;
    klee_make_symbolic(&ac_exitcode, sizeof(long), "ac_exitcode");
   unsigned long ac_mem ;
    klee_make_symbolic(&ac_mem, sizeof(long), "ac_mem");
   cputime_t ac_utime ;
   cputime_t ac_stime ;
   unsigned long ac_minflt ;
    klee_make_symbolic(&ac_minflt, sizeof(long), "ac_minflt");
   unsigned long ac_majflt ;
    klee_make_symbolic(&ac_majflt, sizeof(long), "ac_majflt");
};
struct cpu_itimer {
   cputime_t expires ;
   cputime_t incr ;
   u32 error ;
   u32 incr_error ;
};
struct cputime {
   cputime_t utime ;
   cputime_t stime ;
};
struct task_cputime {
   cputime_t utime ;
   cputime_t stime ;
   unsigned long long sum_exec_runtime ;
    klee_make_symbolic(&sum_exec_runtime, sizeof(long), "sum_exec_runtime");
};
struct task_cputime_atomic {
   atomic64_t utime ;
   atomic64_t stime ;
   atomic64_t sum_exec_runtime ;
};
struct thread_group_cputimer {
   struct task_cputime_atomic cputime_atomic ;
   int running ;
    klee_make_symbolic(&running, sizeof(int), "running");
};
struct autogroup;
struct tty_struct;
struct taskstats;
struct tty_audit_buf;
struct signal_struct {
   atomic_t sigcnt ;
   atomic_t live ;
   int nr_threads ;
    klee_make_symbolic(&nr_threads, sizeof(int), "nr_threads");
   struct list_head thread_head ;
   wait_queue_head_t wait_chldexit ;
   struct task_struct *curr_target ;
   struct sigpending shared_pending ;
   int group_exit_code ;
    klee_make_symbolic(&group_exit_code, sizeof(int), "group_exit_code");
   int notify_count ;
    klee_make_symbolic(&notify_count, sizeof(int), "notify_count");
   struct task_struct *group_exit_task ;
   int group_stop_count ;
    klee_make_symbolic(&group_stop_count, sizeof(int), "group_stop_count");
   unsigned int flags ;
   unsigned char is_child_subreaper : 1 ;
   unsigned char has_child_subreaper : 1 ;
   int posix_timer_id ;
    klee_make_symbolic(&posix_timer_id, sizeof(int), "posix_timer_id");
   struct list_head posix_timers ;
   struct hrtimer real_timer ;
   struct pid *leader_pid ;
   ktime_t it_real_incr ;
   struct cpu_itimer it[2U] ;
   struct thread_group_cputimer cputimer ;
   struct task_cputime cputime_expires ;
   struct list_head cpu_timers[3U] ;
   struct pid *tty_old_pgrp ;
   int leader ;
    klee_make_symbolic(&leader, sizeof(int), "leader");
   struct tty_struct *tty ;
   struct autogroup *autogroup ;
   seqlock_t stats_lock ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t cutime ;
   cputime_t cstime ;
   cputime_t gtime ;
   cputime_t cgtime ;
   struct cputime prev_cputime ;
   unsigned long nvcsw ;
    klee_make_symbolic(&nvcsw, sizeof(long), "nvcsw");
   unsigned long nivcsw ;
    klee_make_symbolic(&nivcsw, sizeof(long), "nivcsw");
   unsigned long cnvcsw ;
    klee_make_symbolic(&cnvcsw, sizeof(long), "cnvcsw");
   unsigned long cnivcsw ;
    klee_make_symbolic(&cnivcsw, sizeof(long), "cnivcsw");
   unsigned long min_flt ;
    klee_make_symbolic(&min_flt, sizeof(long), "min_flt");
   unsigned long maj_flt ;
    klee_make_symbolic(&maj_flt, sizeof(long), "maj_flt");
   unsigned long cmin_flt ;
    klee_make_symbolic(&cmin_flt, sizeof(long), "cmin_flt");
   unsigned long cmaj_flt ;
    klee_make_symbolic(&cmaj_flt, sizeof(long), "cmaj_flt");
   unsigned long inblock ;
    klee_make_symbolic(&inblock, sizeof(long), "inblock");
   unsigned long oublock ;
    klee_make_symbolic(&oublock, sizeof(long), "oublock");
   unsigned long cinblock ;
    klee_make_symbolic(&cinblock, sizeof(long), "cinblock");
   unsigned long coublock ;
    klee_make_symbolic(&coublock, sizeof(long), "coublock");
   unsigned long maxrss ;
    klee_make_symbolic(&maxrss, sizeof(long), "maxrss");
   unsigned long cmaxrss ;
    klee_make_symbolic(&cmaxrss, sizeof(long), "cmaxrss");
   struct task_io_accounting ioac ;
   unsigned long long sum_sched_runtime ;
    klee_make_symbolic(&sum_sched_runtime, sizeof(long), "sum_sched_runtime");
   struct rlimit rlim[16U] ;
   struct pacct_struct pacct ;
   struct taskstats *stats ;
   unsigned int audit_tty ;
    klee_make_symbolic(&audit_tty, sizeof(int), "audit_tty");
   unsigned int audit_tty_log_passwd ;
    klee_make_symbolic(&audit_tty_log_passwd, sizeof(int), "audit_tty_log_passwd");
   struct tty_audit_buf *tty_audit_buf ;
   oom_flags_t oom_flags ;
   short oom_score_adj ;
    klee_make_symbolic(&oom_score_adj, sizeof(short), "oom_score_adj");
   short oom_score_adj_min ;
    klee_make_symbolic(&oom_score_adj_min, sizeof(short), "oom_score_adj_min");
   struct mutex cred_guard_mutex ;
};
struct user_struct {
   atomic_t __count ;
   atomic_t processes ;
   atomic_t sigpending ;
   atomic_t inotify_watches ;
   atomic_t inotify_devs ;
   atomic_t fanotify_listeners ;
   atomic_long_t epoll_watches ;
   unsigned long mq_bytes ;
    klee_make_symbolic(&mq_bytes, sizeof(long), "mq_bytes");
   unsigned long locked_shm ;
    klee_make_symbolic(&locked_shm, sizeof(long), "locked_shm");
   struct key *uid_keyring ;
   struct key *session_keyring ;
   struct hlist_node uidhash_node ;
   kuid_t uid ;
   atomic_long_t locked_vm ;
};
struct backing_dev_info;
struct reclaim_state;
struct sched_info {
   unsigned long pcount ;
    klee_make_symbolic(&pcount, sizeof(long), "pcount");
   unsigned long long run_delay ;
    klee_make_symbolic(&run_delay, sizeof(long), "run_delay");
   unsigned long long last_arrival ;
    klee_make_symbolic(&last_arrival, sizeof(long), "last_arrival");
   unsigned long long last_queued ;
    klee_make_symbolic(&last_queued, sizeof(long), "last_queued");
};
struct task_delay_info {
   spinlock_t lock ;
   unsigned int flags ;
   u64 blkio_start ;
   u64 blkio_delay ;
   u64 swapin_delay ;
   u32 blkio_count ;
   u32 swapin_count ;
   u64 freepages_start ;
   u64 freepages_delay ;
   u32 freepages_count ;
};
struct wake_q_node {
   struct wake_q_node *next ;
};
struct io_context;
struct pipe_inode_info;
struct load_weight {
   unsigned long weight ;
    klee_make_symbolic(&weight, sizeof(long), "weight");
   u32 inv_weight ;
};
struct sched_avg {
   u64 last_runnable_update ;
   s64 decay_count ;
   unsigned long load_avg_contrib ;
    klee_make_symbolic(&load_avg_contrib, sizeof(long), "load_avg_contrib");
   unsigned long utilization_avg_contrib ;
    klee_make_symbolic(&utilization_avg_contrib, sizeof(long), "utilization_avg_contrib");
   u32 runnable_avg_sum ;
   u32 avg_period ;
   u32 running_avg_sum ;
};
struct sched_statistics {
   u64 wait_start ;
   u64 wait_max ;
   u64 wait_count ;
   u64 wait_sum ;
   u64 iowait_count ;
   u64 iowait_sum ;
   u64 sleep_start ;
   u64 sleep_max ;
   s64 sum_sleep_runtime ;
   u64 block_start ;
   u64 block_max ;
   u64 exec_max ;
   u64 slice_max ;
   u64 nr_migrations_cold ;
   u64 nr_failed_migrations_affine ;
   u64 nr_failed_migrations_running ;
   u64 nr_failed_migrations_hot ;
   u64 nr_forced_migrations ;
   u64 nr_wakeups ;
   u64 nr_wakeups_sync ;
   u64 nr_wakeups_migrate ;
   u64 nr_wakeups_local ;
   u64 nr_wakeups_remote ;
   u64 nr_wakeups_affine ;
   u64 nr_wakeups_affine_attempts ;
   u64 nr_wakeups_passive ;
   u64 nr_wakeups_idle ;
};
struct sched_entity {
   struct load_weight load ;
   struct rb_node run_node ;
   struct list_head group_node ;
   unsigned int on_rq ;
    klee_make_symbolic(&on_rq, sizeof(int), "on_rq");
   u64 exec_start ;
   u64 sum_exec_runtime ;
   u64 vruntime ;
   u64 prev_sum_exec_runtime ;
   u64 nr_migrations ;
   struct sched_statistics statistics ;
   int depth ;
   struct sched_entity *parent ;
   struct cfs_rq *cfs_rq ;
   struct cfs_rq *my_q ;
   struct sched_avg avg ;
};
struct rt_rq;
struct sched_rt_entity {
   struct list_head run_list ;
   unsigned long timeout ;
    klee_make_symbolic(&timeout, sizeof(long), "timeout");
   unsigned long watchdog_stamp ;
    klee_make_symbolic(&watchdog_stamp, sizeof(long), "watchdog_stamp");
   unsigned int time_slice ;
    klee_make_symbolic(&time_slice, sizeof(int), "time_slice");
   struct sched_rt_entity *back ;
   struct sched_rt_entity *parent ;
   struct rt_rq *rt_rq ;
   struct rt_rq *my_q ;
};
struct sched_dl_entity {
   struct rb_node rb_node ;
   u64 dl_runtime ;
   u64 dl_deadline ;
   u64 dl_period ;
   u64 dl_bw ;
   s64 runtime ;
   u64 deadline ;
   unsigned int flags ;
   int dl_throttled ;
    klee_make_symbolic(&dl_throttled, sizeof(int), "dl_throttled");
   int dl_new ;
    klee_make_symbolic(&dl_new, sizeof(int), "dl_new");
   int dl_boosted ;
    klee_make_symbolic(&dl_boosted, sizeof(int), "dl_boosted");
   int dl_yielded ;
    klee_make_symbolic(&dl_yielded, sizeof(int), "dl_yielded");
   struct hrtimer dl_timer ;
};
struct memcg_oom_info {
   struct mem_cgroup *memcg ;
   gfp_t gfp_mask ;
   int order ;
    klee_make_symbolic(&order, sizeof(int), "order");
   unsigned char may_oom : 1 ;
};
struct sched_class;
struct files_struct;
struct compat_robust_list_head;
struct numa_group;
struct ftrace_ret_stack;
struct task_struct {
   long volatile   state ;
   void *stack ;
   atomic_t usage ;
   unsigned int flags ;
   unsigned int ptrace ;
    klee_make_symbolic(&ptrace, sizeof(int), "ptrace");
   struct llist_node wake_entry ;
   int on_cpu ;
    klee_make_symbolic(&on_cpu, sizeof(int), "on_cpu");
   struct task_struct *last_wakee ;
   unsigned long wakee_flips ;
    klee_make_symbolic(&wakee_flips, sizeof(long), "wakee_flips");
   unsigned long wakee_flip_decay_ts ;
    klee_make_symbolic(&wakee_flip_decay_ts, sizeof(long), "wakee_flip_decay_ts");
   int wake_cpu ;
    klee_make_symbolic(&wake_cpu, sizeof(int), "wake_cpu");
   int on_rq ;
   int prio ;
   int static_prio ;
    klee_make_symbolic(&static_prio, sizeof(int), "static_prio");
   int normal_prio ;
    klee_make_symbolic(&normal_prio, sizeof(int), "normal_prio");
   unsigned int rt_priority ;
    klee_make_symbolic(&rt_priority, sizeof(int), "rt_priority");
   struct sched_class  const  *sched_class ;
   struct sched_entity se ;
   struct sched_rt_entity rt ;
   struct task_group *sched_task_group ;
   struct sched_dl_entity dl ;
   struct hlist_head preempt_notifiers ;
   unsigned int btrace_seq ;
    klee_make_symbolic(&btrace_seq, sizeof(int), "btrace_seq");
   unsigned int policy ;
    klee_make_symbolic(&policy, sizeof(int), "policy");
   int nr_cpus_allowed ;
    klee_make_symbolic(&nr_cpus_allowed, sizeof(int), "nr_cpus_allowed");
   cpumask_t cpus_allowed ;
   unsigned long rcu_tasks_nvcsw ;
    klee_make_symbolic(&rcu_tasks_nvcsw, sizeof(long), "rcu_tasks_nvcsw");
   bool rcu_tasks_holdout ;
   struct list_head rcu_tasks_holdout_list ;
   int rcu_tasks_idle_cpu ;
    klee_make_symbolic(&rcu_tasks_idle_cpu, sizeof(int), "rcu_tasks_idle_cpu");
   struct sched_info sched_info ;
   struct list_head tasks ;
   struct plist_node pushable_tasks ;
   struct rb_node pushable_dl_tasks ;
   struct mm_struct *mm ;
   struct mm_struct *active_mm ;
   u32 vmacache_seqnum ;
   struct vm_area_struct *vmacache[4U] ;
   struct task_rss_stat rss_stat ;
   int exit_state ;
    klee_make_symbolic(&exit_state, sizeof(int), "exit_state");
   int exit_code ;
    klee_make_symbolic(&exit_code, sizeof(int), "exit_code");
   int exit_signal ;
    klee_make_symbolic(&exit_signal, sizeof(int), "exit_signal");
   int pdeath_signal ;
    klee_make_symbolic(&pdeath_signal, sizeof(int), "pdeath_signal");
   unsigned long jobctl ;
    klee_make_symbolic(&jobctl, sizeof(long), "jobctl");
   unsigned int personality ;
    klee_make_symbolic(&personality, sizeof(int), "personality");
   unsigned char in_execve : 1 ;
   unsigned char in_iowait : 1 ;
   unsigned char sched_reset_on_fork : 1 ;
   unsigned char sched_contributes_to_load : 1 ;
   unsigned char sched_migrated : 1 ;
   unsigned char memcg_kmem_skip_account : 1 ;
   unsigned char brk_randomized : 1 ;
   unsigned long atomic_flags ;
    klee_make_symbolic(&atomic_flags, sizeof(long), "atomic_flags");
   struct restart_block restart_block ;
   pid_t pid ;
   pid_t tgid ;
   struct task_struct *real_parent ;
   struct task_struct *parent ;
   struct list_head children ;
   struct list_head sibling ;
   struct task_struct *group_leader ;
   struct list_head ptraced ;
   struct list_head ptrace_entry ;
   struct pid_link pids[3U] ;
   struct list_head thread_group ;
   struct list_head thread_node ;
   struct completion *vfork_done ;
   int *set_child_tid ;
   int *clear_child_tid ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t utimescaled ;
   cputime_t stimescaled ;
   cputime_t gtime ;
   struct cputime prev_cputime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   u64 start_time ;
   u64 real_start_time ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   struct task_cputime cputime_expires ;
   struct list_head cpu_timers[3U] ;
   struct cred  const  *real_cred ;
   struct cred  const  *cred ;
   char comm[16U] ;
   struct nameidata *nameidata ;
   struct sysv_sem sysvsem ;
   struct sysv_shm sysvshm ;
   unsigned long last_switch_count ;
    klee_make_symbolic(&last_switch_count, sizeof(long), "last_switch_count");
   struct thread_struct thread ;
   struct fs_struct *fs ;
   struct files_struct *files ;
   struct nsproxy *nsproxy ;
   struct signal_struct *signal ;
   struct sighand_struct *sighand ;
   sigset_t blocked ;
   sigset_t real_blocked ;
   sigset_t saved_sigmask ;
   struct sigpending pending ;
   unsigned long sas_ss_sp ;
    klee_make_symbolic(&sas_ss_sp, sizeof(long), "sas_ss_sp");
   size_t sas_ss_size ;
   int (*notifier)(void * ) ;
   void *notifier_data ;
   sigset_t *notifier_mask ;
   struct callback_head *task_works ;
   struct audit_context *audit_context ;
   kuid_t loginuid ;
   unsigned int sessionid ;
    klee_make_symbolic(&sessionid, sizeof(int), "sessionid");
   struct seccomp seccomp ;
   u32 parent_exec_id ;
   u32 self_exec_id ;
   spinlock_t alloc_lock ;
   raw_spinlock_t pi_lock ;
   struct wake_q_node wake_q ;
   struct rb_root pi_waiters ;
   struct rb_node *pi_waiters_leftmost ;
   struct rt_mutex_waiter *pi_blocked_on ;
   struct mutex_waiter *blocked_on ;
   unsigned int irq_events ;
    klee_make_symbolic(&irq_events, sizeof(int), "irq_events");
   unsigned long hardirq_enable_ip ;
    klee_make_symbolic(&hardirq_enable_ip, sizeof(long), "hardirq_enable_ip");
   unsigned long hardirq_disable_ip ;
    klee_make_symbolic(&hardirq_disable_ip, sizeof(long), "hardirq_disable_ip");
   unsigned int hardirq_enable_event ;
    klee_make_symbolic(&hardirq_enable_event, sizeof(int), "hardirq_enable_event");
   unsigned int hardirq_disable_event ;
    klee_make_symbolic(&hardirq_disable_event, sizeof(int), "hardirq_disable_event");
   int hardirqs_enabled ;
    klee_make_symbolic(&hardirqs_enabled, sizeof(int), "hardirqs_enabled");
   int hardirq_context ;
    klee_make_symbolic(&hardirq_context, sizeof(int), "hardirq_context");
   unsigned long softirq_disable_ip ;
    klee_make_symbolic(&softirq_disable_ip, sizeof(long), "softirq_disable_ip");
   unsigned long softirq_enable_ip ;
    klee_make_symbolic(&softirq_enable_ip, sizeof(long), "softirq_enable_ip");
   unsigned int softirq_disable_event ;
    klee_make_symbolic(&softirq_disable_event, sizeof(int), "softirq_disable_event");
   unsigned int softirq_enable_event ;
    klee_make_symbolic(&softirq_enable_event, sizeof(int), "softirq_enable_event");
   int softirqs_enabled ;
    klee_make_symbolic(&softirqs_enabled, sizeof(int), "softirqs_enabled");
   int softirq_context ;
    klee_make_symbolic(&softirq_context, sizeof(int), "softirq_context");
   u64 curr_chain_key ;
   int lockdep_depth ;
    klee_make_symbolic(&lockdep_depth, sizeof(int), "lockdep_depth");
   unsigned int lockdep_recursion ;
    klee_make_symbolic(&lockdep_recursion, sizeof(int), "lockdep_recursion");
   struct held_lock held_locks[48U] ;
   gfp_t lockdep_reclaim_gfp ;
   void *journal_info ;
   struct bio_list *bio_list ;
   struct blk_plug *plug ;
   struct reclaim_state *reclaim_state ;
   struct backing_dev_info *backing_dev_info ;
   struct io_context *io_context ;
   unsigned long ptrace_message ;
    klee_make_symbolic(&ptrace_message, sizeof(long), "ptrace_message");
   siginfo_t *last_siginfo ;
   struct task_io_accounting ioac ;
   u64 acct_rss_mem1 ;
   u64 acct_vm_mem1 ;
   cputime_t acct_timexpd ;
   nodemask_t mems_allowed ;
   seqcount_t mems_allowed_seq ;
   int cpuset_mem_spread_rotor ;
    klee_make_symbolic(&cpuset_mem_spread_rotor, sizeof(int), "cpuset_mem_spread_rotor");
   int cpuset_slab_spread_rotor ;
    klee_make_symbolic(&cpuset_slab_spread_rotor, sizeof(int), "cpuset_slab_spread_rotor");
   struct css_set *cgroups ;
   struct list_head cg_list ;
   struct robust_list_head *robust_list ;
   struct compat_robust_list_head *compat_robust_list ;
   struct list_head pi_state_list ;
   struct futex_pi_state *pi_state_cache ;
   struct perf_event_context *perf_event_ctxp[2U] ;
   struct mutex perf_event_mutex ;
   struct list_head perf_event_list ;
   struct mempolicy *mempolicy ;
   short il_next ;
    klee_make_symbolic(&il_next, sizeof(short), "il_next");
   short pref_node_fork ;
    klee_make_symbolic(&pref_node_fork, sizeof(short), "pref_node_fork");
   int numa_scan_seq ;
   unsigned int numa_scan_period ;
    klee_make_symbolic(&numa_scan_period, sizeof(int), "numa_scan_period");
   unsigned int numa_scan_period_max ;
    klee_make_symbolic(&numa_scan_period_max, sizeof(int), "numa_scan_period_max");
   int numa_preferred_nid ;
    klee_make_symbolic(&numa_preferred_nid, sizeof(int), "numa_preferred_nid");
   unsigned long numa_migrate_retry ;
    klee_make_symbolic(&numa_migrate_retry, sizeof(long), "numa_migrate_retry");
   u64 node_stamp ;
   u64 last_task_numa_placement ;
   u64 last_sum_exec_runtime ;
   struct callback_head numa_work ;
   struct list_head numa_entry ;
   struct numa_group *numa_group ;
   unsigned long *numa_faults ;
   unsigned long total_numa_faults ;
    klee_make_symbolic(&total_numa_faults, sizeof(long), "total_numa_faults");
   unsigned long numa_faults_locality[3U] ;
   unsigned long numa_pages_migrated ;
    klee_make_symbolic(&numa_pages_migrated, sizeof(long), "numa_pages_migrated");
   struct callback_head rcu ;
   struct pipe_inode_info *splice_pipe ;
   struct page_frag task_frag ;
   struct task_delay_info *delays ;
   int make_it_fail ;
    klee_make_symbolic(&make_it_fail, sizeof(int), "make_it_fail");
   int nr_dirtied ;
    klee_make_symbolic(&nr_dirtied, sizeof(int), "nr_dirtied");
   int nr_dirtied_pause ;
    klee_make_symbolic(&nr_dirtied_pause, sizeof(int), "nr_dirtied_pause");
   unsigned long dirty_paused_when ;
    klee_make_symbolic(&dirty_paused_when, sizeof(long), "dirty_paused_when");
   int latency_record_count ;
    klee_make_symbolic(&latency_record_count, sizeof(int), "latency_record_count");
   struct latency_record latency_record[32U] ;
   unsigned long timer_slack_ns ;
    klee_make_symbolic(&timer_slack_ns, sizeof(long), "timer_slack_ns");
   unsigned long default_timer_slack_ns ;
    klee_make_symbolic(&default_timer_slack_ns, sizeof(long), "default_timer_slack_ns");
   unsigned int kasan_depth ;
    klee_make_symbolic(&kasan_depth, sizeof(int), "kasan_depth");
   int curr_ret_stack ;
    klee_make_symbolic(&curr_ret_stack, sizeof(int), "curr_ret_stack");
   struct ftrace_ret_stack *ret_stack ;
   unsigned long long ftrace_timestamp ;
    klee_make_symbolic(&ftrace_timestamp, sizeof(long), "ftrace_timestamp");
   atomic_t trace_overrun ;
   atomic_t tracing_graph_pause ;
   unsigned long trace ;
    klee_make_symbolic(&trace, sizeof(long), "trace");
   unsigned long trace_recursion ;
    klee_make_symbolic(&trace_recursion, sizeof(long), "trace_recursion");
   struct memcg_oom_info memcg_oom ;
   struct uprobe_task *utask ;
   unsigned int sequential_io ;
    klee_make_symbolic(&sequential_io, sizeof(int), "sequential_io");
   unsigned int sequential_io_avg ;
    klee_make_symbolic(&sequential_io_avg, sizeof(int), "sequential_io_avg");
   unsigned long task_state_change ;
    klee_make_symbolic(&task_state_change, sizeof(long), "task_state_change");
   int pagefault_disabled ;
    klee_make_symbolic(&pagefault_disabled, sizeof(int), "pagefault_disabled");
};
struct usb_host_endpoint;
struct usb_ep;
struct usb_request;
struct usb_gadget;
struct exception_table_entry {
   int insn ;
    klee_make_symbolic(&insn, sizeof(int), "insn");
   int fixup ;
    klee_make_symbolic(&fixup, sizeof(int), "fixup");
};
struct klist_node;
struct klist_node {
   void *n_klist ;
   struct list_head n_node ;
   struct kref n_ref ;
};
struct path;
struct seq_file {
   char *buf ;
   size_t size ;
   size_t from ;
   size_t count ;
   size_t pad_until ;
   loff_t index ;
   loff_t read_pos ;
   u64 version ;
   struct mutex lock ;
   struct seq_operations  const  *op ;
   int poll_event ;
    klee_make_symbolic(&poll_event, sizeof(int), "poll_event");
   struct user_namespace *user_ns ;
   void *private ;
};
struct seq_operations {
   void *(*start)(struct seq_file * , loff_t * ) ;
   void (*stop)(struct seq_file * , void * ) ;
   void *(*next)(struct seq_file * , void * , loff_t * ) ;
   int (*show)(struct seq_file * , void * ) ;
};
struct pinctrl;
struct pinctrl_state;
struct dev_pin_info {
   struct pinctrl *p ;
   struct pinctrl_state *default_state ;
   struct pinctrl_state *sleep_state ;
   struct pinctrl_state *idle_state ;
};
struct dma_map_ops;
struct dev_archdata {
   struct dma_map_ops *dma_ops ;
   void *iommu ;
};
struct device_private;
struct device_driver;
struct driver_private;
struct class;
struct subsys_private;
struct bus_type;
struct device_node;
struct fwnode_handle;
struct iommu_ops;
struct iommu_group;
struct device_attribute;
struct bus_type {
   char const   *name ;
   char const   *dev_name ;
   struct device *dev_root ;
   struct device_attribute *dev_attrs ;
   struct attribute_group  const  **bus_groups ;
   struct attribute_group  const  **dev_groups ;
   struct attribute_group  const  **drv_groups ;
   int (*match)(struct device * , struct device_driver * ) ;
   int (*uevent)(struct device * , struct kobj_uevent_env * ) ;
   int (*probe)(struct device * ) ;
   int (*remove)(struct device * ) ;
   void (*shutdown)(struct device * ) ;
   int (*online)(struct device * ) ;
   int (*offline)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
   struct iommu_ops  const  *iommu_ops ;
   struct subsys_private *p ;
   struct lock_class_key lock_key ;
};
struct device_type;
enum probe_type {
    PROBE_DEFAULT_STRATEGY = 0,
    PROBE_PREFER_ASYNCHRONOUS = 1,
    PROBE_FORCE_SYNCHRONOUS = 2
} ;
struct of_device_id;
struct acpi_device_id;
struct device_driver {
   char const   *name ;
   struct bus_type *bus ;
   struct module *owner ;
   char const   *mod_name ;
   bool suppress_bind_attrs ;
   enum probe_type probe_type ;
   struct of_device_id  const  *of_match_table ;
   struct acpi_device_id  const  *acpi_match_table ;
   int (*probe)(struct device * ) ;
   int (*remove)(struct device * ) ;
   void (*shutdown)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct attribute_group  const  **groups ;
   struct dev_pm_ops  const  *pm ;
   struct driver_private *p ;
};
struct class_attribute;
struct class {
   char const   *name ;
   struct module *owner ;
   struct class_attribute *class_attrs ;
   struct attribute_group  const  **dev_groups ;
   struct kobject *dev_kobj ;
   int (*dev_uevent)(struct device * , struct kobj_uevent_env * ) ;
   char *(*devnode)(struct device * , umode_t * ) ;
   void (*class_release)(struct class * ) ;
   void (*dev_release)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct kobj_ns_type_operations  const  *ns_type ;
   void const   *(*namespace)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
   struct subsys_private *p ;
};
struct class_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct class * , struct class_attribute * , char * ) ;
   ssize_t (*store)(struct class * , struct class_attribute * , char const   * , size_t  ) ;
};
struct device_type {
   char const   *name ;
   struct attribute_group  const  **groups ;
   int (*uevent)(struct device * , struct kobj_uevent_env * ) ;
   char *(*devnode)(struct device * , umode_t * , kuid_t * , kgid_t * ) ;
   void (*release)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
};
struct device_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct device * , struct device_attribute * , char * ) ;
   ssize_t (*store)(struct device * , struct device_attribute * , char const   * ,
                    size_t  ) ;
};
struct device_dma_parameters {
   unsigned int max_segment_size ;
    klee_make_symbolic(&max_segment_size, sizeof(int), "max_segment_size");
   unsigned long segment_boundary_mask ;
    klee_make_symbolic(&segment_boundary_mask, sizeof(long), "segment_boundary_mask");
};
struct dma_coherent_mem;
struct cma;
struct device {
   struct device *parent ;
   struct device_private *p ;
   struct kobject kobj ;
   char const   *init_name ;
   struct device_type  const  *type ;
   struct mutex mutex ;
   struct bus_type *bus ;
   struct device_driver *driver ;
   void *platform_data ;
   void *driver_data ;
   struct dev_pm_info power ;
   struct dev_pm_domain *pm_domain ;
   struct dev_pin_info *pins ;
   int numa_node ;
    klee_make_symbolic(&numa_node, sizeof(int), "numa_node");
   u64 *dma_mask ;
   u64 coherent_dma_mask ;
   unsigned long dma_pfn_offset ;
    klee_make_symbolic(&dma_pfn_offset, sizeof(long), "dma_pfn_offset");
   struct device_dma_parameters *dma_parms ;
   struct list_head dma_pools ;
   struct dma_coherent_mem *dma_mem ;
   struct cma *cma_area ;
   struct dev_archdata archdata ;
   struct device_node *of_node ;
   struct fwnode_handle *fwnode ;
   dev_t devt ;
   u32 id ;
   spinlock_t devres_lock ;
   struct list_head devres_head ;
   struct klist_node knode_class ;
   struct class *class ;
   struct attribute_group  const  **groups ;
   void (*release)(struct device * ) ;
   struct iommu_group *iommu_group ;
   bool offline_disabled ;
   bool offline ;
};
struct wakeup_source {
   char const   *name ;
   struct list_head entry ;
   spinlock_t lock ;
   struct wake_irq *wakeirq ;
   struct timer_list timer ;
   unsigned long timer_expires ;
   ktime_t total_time ;
   ktime_t max_time ;
   ktime_t last_time ;
   ktime_t start_prevent_time ;
   ktime_t prevent_sleep_time ;
   unsigned long event_count ;
    klee_make_symbolic(&event_count, sizeof(long), "event_count");
   unsigned long active_count ;
    klee_make_symbolic(&active_count, sizeof(long), "active_count");
   unsigned long relax_count ;
    klee_make_symbolic(&relax_count, sizeof(long), "relax_count");
   unsigned long expire_count ;
    klee_make_symbolic(&expire_count, sizeof(long), "expire_count");
   unsigned long wakeup_count ;
    klee_make_symbolic(&wakeup_count, sizeof(long), "wakeup_count");
   bool active ;
   bool autosleep_enabled ;
};
struct dma_attrs {
   unsigned long flags[1U] ;
};
enum dma_data_direction {
    DMA_BIDIRECTIONAL = 0,
    DMA_TO_DEVICE = 1,
    DMA_FROM_DEVICE = 2,
    DMA_NONE = 3
} ;
struct shrink_control {
   gfp_t gfp_mask ;
   unsigned long nr_to_scan ;
    klee_make_symbolic(&nr_to_scan, sizeof(long), "nr_to_scan");
   int nid ;
    klee_make_symbolic(&nid, sizeof(int), "nid");
   struct mem_cgroup *memcg ;
};
struct shrinker {
   unsigned long (*count_objects)(struct shrinker * , struct shrink_control * ) ;
   unsigned long (*scan_objects)(struct shrinker * , struct shrink_control * ) ;
   int seeks ;
    klee_make_symbolic(&seeks, sizeof(int), "seeks");
   long batch ;
    klee_make_symbolic(&batch, sizeof(long), "batch");
   unsigned long flags ;
   struct list_head list ;
   atomic_long_t *nr_deferred ;
};
struct file_ra_state;
struct writeback_control;
struct bdi_writeback;
struct vm_fault {
   unsigned int flags ;
   unsigned long pgoff ;
    klee_make_symbolic(&pgoff, sizeof(long), "pgoff");
   void *virtual_address ;
   struct page *cow_page ;
   struct page *page ;
   unsigned long max_pgoff ;
    klee_make_symbolic(&max_pgoff, sizeof(long), "max_pgoff");
   pte_t *pte ;
};
struct vm_operations_struct {
   void (*open)(struct vm_area_struct * ) ;
   void (*close)(struct vm_area_struct * ) ;
   int (*fault)(struct vm_area_struct * , struct vm_fault * ) ;
   void (*map_pages)(struct vm_area_struct * , struct vm_fault * ) ;
   int (*page_mkwrite)(struct vm_area_struct * , struct vm_fault * ) ;
   int (*pfn_mkwrite)(struct vm_area_struct * , struct vm_fault * ) ;
   int (*access)(struct vm_area_struct * , unsigned long  , void * , int  , int  ) ;
   char const   *(*name)(struct vm_area_struct * ) ;
   int (*set_policy)(struct vm_area_struct * , struct mempolicy * ) ;
   struct mempolicy *(*get_policy)(struct vm_area_struct * , unsigned long  ) ;
   struct page *(*find_special_page)(struct vm_area_struct * , unsigned long  ) ;
};
struct scatterlist {
   unsigned long sg_magic ;
    klee_make_symbolic(&sg_magic, sizeof(long), "sg_magic");
   unsigned long page_link ;
    klee_make_symbolic(&page_link, sizeof(long), "page_link");
   unsigned int offset ;
    klee_make_symbolic(&offset, sizeof(int), "offset");
   unsigned int length ;
    klee_make_symbolic(&length, sizeof(int), "length");
   dma_addr_t dma_address ;
   unsigned int dma_length ;
    klee_make_symbolic(&dma_length, sizeof(int), "dma_length");
};
struct sg_table {
   struct scatterlist *sgl ;
   unsigned int nents ;
    klee_make_symbolic(&nents, sizeof(int), "nents");
   unsigned int orig_nents ;
    klee_make_symbolic(&orig_nents, sizeof(int), "orig_nents");
};
struct dma_map_ops {
   void *(*alloc)(struct device * , size_t  , dma_addr_t * , gfp_t  , struct dma_attrs * ) ;
   void (*free)(struct device * , size_t  , void * , dma_addr_t  , struct dma_attrs * ) ;
   int (*mmap)(struct device * , struct vm_area_struct * , void * , dma_addr_t  ,
               size_t  , struct dma_attrs * ) ;
   int (*get_sgtable)(struct device * , struct sg_table * , void * , dma_addr_t  ,
                      size_t  , struct dma_attrs * ) ;
   dma_addr_t (*map_page)(struct device * , struct page * , unsigned long  , size_t  ,
                          enum dma_data_direction  , struct dma_attrs * ) ;
   void (*unmap_page)(struct device * , dma_addr_t  , size_t  , enum dma_data_direction  ,
                      struct dma_attrs * ) ;
   int (*map_sg)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ,
                 struct dma_attrs * ) ;
   void (*unmap_sg)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ,
                    struct dma_attrs * ) ;
   void (*sync_single_for_cpu)(struct device * , dma_addr_t  , size_t  , enum dma_data_direction  ) ;
   void (*sync_single_for_device)(struct device * , dma_addr_t  , size_t  , enum dma_data_direction  ) ;
   void (*sync_sg_for_cpu)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ) ;
   void (*sync_sg_for_device)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ) ;
   int (*mapping_error)(struct device * , dma_addr_t  ) ;
   int (*dma_supported)(struct device * , u64  ) ;
   int (*set_dma_mask)(struct device * , u64  ) ;
   int is_phys ;
    klee_make_symbolic(&is_phys, sizeof(int), "is_phys");
};
typedef unsigned long kernel_ulong_t;
    klee_make_symbolic(&kernel_ulong_t, sizeof(long), "kernel_ulong_t");
struct acpi_device_id {
   __u8 id[9U] ;
   kernel_ulong_t driver_data ;
};
struct of_device_id {
   char name[32U] ;
   char type[32U] ;
   char compatible[128U] ;
   void const   *data ;
};
struct usb_ctrlrequest {
   __u8 bRequestType ;
   __u8 bRequest ;
   __le16 wValue ;
   __le16 wIndex ;
   __le16 wLength ;
};
struct usb_device_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __le16 bcdUSB ;
   __u8 bDeviceClass ;
   __u8 bDeviceSubClass ;
   __u8 bDeviceProtocol ;
   __u8 bMaxPacketSize0 ;
   __le16 idVendor ;
   __le16 idProduct ;
   __le16 bcdDevice ;
   __u8 iManufacturer ;
   __u8 iProduct ;
   __u8 iSerialNumber ;
   __u8 bNumConfigurations ;
};
struct usb_config_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __le16 wTotalLength ;
   __u8 bNumInterfaces ;
   __u8 bConfigurationValue ;
   __u8 iConfiguration ;
   __u8 bmAttributes ;
   __u8 bMaxPower ;
};
struct usb_interface_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __u8 bInterfaceNumber ;
   __u8 bAlternateSetting ;
   __u8 bNumEndpoints ;
   __u8 bInterfaceClass ;
   __u8 bInterfaceSubClass ;
   __u8 bInterfaceProtocol ;
   __u8 iInterface ;
};
struct usb_endpoint_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __u8 bEndpointAddress ;
   __u8 bmAttributes ;
   __le16 wMaxPacketSize ;
   __u8 bInterval ;
   __u8 bRefresh ;
   __u8 bSynchAddress ;
};
struct usb_ss_ep_comp_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __u8 bMaxBurst ;
   __u8 bmAttributes ;
   __le16 wBytesPerInterval ;
};
struct usb_interface_assoc_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __u8 bFirstInterface ;
   __u8 bInterfaceCount ;
   __u8 bFunctionClass ;
   __u8 bFunctionSubClass ;
   __u8 bFunctionProtocol ;
   __u8 iFunction ;
};
struct usb_bos_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __le16 wTotalLength ;
   __u8 bNumDeviceCaps ;
};
struct usb_ext_cap_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __u8 bDevCapabilityType ;
   __le32 bmAttributes ;
};
struct usb_ss_cap_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __u8 bDevCapabilityType ;
   __u8 bmAttributes ;
   __le16 wSpeedSupported ;
   __u8 bFunctionalitySupport ;
   __u8 bU1devExitLat ;
   __le16 bU2DevExitLat ;
};
struct usb_ss_container_id_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __u8 bDevCapabilityType ;
   __u8 bReserved ;
   __u8 ContainerID[16U] ;
};
enum usb_device_speed {
    USB_SPEED_UNKNOWN = 0,
    USB_SPEED_LOW = 1,
    USB_SPEED_FULL = 2,
    USB_SPEED_HIGH = 3,
    USB_SPEED_WIRELESS = 4,
    USB_SPEED_SUPER = 5
} ;
enum usb_device_state {
    USB_STATE_NOTATTACHED = 0,
    USB_STATE_ATTACHED = 1,
    USB_STATE_POWERED = 2,
    USB_STATE_RECONNECTING = 3,
    USB_STATE_UNAUTHENTICATED = 4,
    USB_STATE_DEFAULT = 5,
    USB_STATE_ADDRESS = 6,
    USB_STATE_CONFIGURED = 7,
    USB_STATE_SUSPENDED = 8
} ;
struct hlist_bl_node;
struct hlist_bl_head {
   struct hlist_bl_node *first ;
};
struct hlist_bl_node {
   struct hlist_bl_node *next ;
   struct hlist_bl_node **pprev ;
};
struct __anonstruct____missing_field_name_231 {
   spinlock_t lock ;
   int count ;
};
union __anonunion____missing_field_name_230 {
   struct __anonstruct____missing_field_name_231 __annonCompField65 ;
};
struct lockref {
   union __anonunion____missing_field_name_230 __annonCompField66 ;
};
struct vfsmount;
struct __anonstruct____missing_field_name_233 {
   u32 hash ;
   u32 len ;
};
union __anonunion____missing_field_name_232 {
   struct __anonstruct____missing_field_name_233 __annonCompField67 ;
   u64 hash_len ;
};
struct qstr {
   union __anonunion____missing_field_name_232 __annonCompField68 ;
   unsigned char const   *name ;
};
struct dentry_operations;
union __anonunion_d_u_234 {
   struct hlist_node d_alias ;
   struct callback_head d_rcu ;
};
struct dentry {
   unsigned int d_flags ;
    klee_make_symbolic(&d_flags, sizeof(int), "d_flags");
   seqcount_t d_seq ;
   struct hlist_bl_node d_hash ;
   struct dentry *d_parent ;
   struct qstr d_name ;
   struct inode *d_inode ;
   unsigned char d_iname[32U] ;
   struct lockref d_lockref ;
   struct dentry_operations  const  *d_op ;
   struct super_block *d_sb ;
   unsigned long d_time ;
    klee_make_symbolic(&d_time, sizeof(long), "d_time");
   void *d_fsdata ;
   struct list_head d_lru ;
   struct list_head d_child ;
   struct list_head d_subdirs ;
   union __anonunion_d_u_234 d_u ;
};
struct dentry_operations {
   int (*d_revalidate)(struct dentry * , unsigned int  ) ;
   int (*d_weak_revalidate)(struct dentry * , unsigned int  ) ;
   int (*d_hash)(struct dentry  const  * , struct qstr * ) ;
   int (*d_compare)(struct dentry  const  * , struct dentry  const  * , unsigned int  ,
                    char const   * , struct qstr  const  * ) ;
   int (*d_delete)(struct dentry  const  * ) ;
   void (*d_release)(struct dentry * ) ;
   void (*d_prune)(struct dentry * ) ;
   void (*d_iput)(struct dentry * , struct inode * ) ;
   char *(*d_dname)(struct dentry * , char * , int  ) ;
   struct vfsmount *(*d_automount)(struct path * ) ;
   int (*d_manage)(struct dentry * , bool  ) ;
   struct inode *(*d_select_inode)(struct dentry * , unsigned int  ) ;
};
struct path {
   struct vfsmount *mnt ;
   struct dentry *dentry ;
};
struct list_lru_one {
   struct list_head list ;
   long nr_items ;
    klee_make_symbolic(&nr_items, sizeof(long), "nr_items");
};
struct list_lru_memcg {
   struct list_lru_one *lru[0U] ;
};
struct list_lru_node {
   spinlock_t lock ;
   struct list_lru_one lru ;
   struct list_lru_memcg *memcg_lrus ;
};
struct list_lru {
   struct list_lru_node *node ;
   struct list_head list ;
};
struct __anonstruct____missing_field_name_238 {
   struct radix_tree_node *parent ;
   void *private_data ;
};
union __anonunion____missing_field_name_237 {
   struct __anonstruct____missing_field_name_238 __annonCompField69 ;
   struct callback_head callback_head ;
};
struct radix_tree_node {
   unsigned int path ;
    klee_make_symbolic(&path, sizeof(int), "path");
   unsigned int count ;
   union __anonunion____missing_field_name_237 __annonCompField70 ;
   struct list_head private_list ;
   void *slots[64U] ;
   unsigned long tags[3U][1U] ;
};
struct radix_tree_root {
   unsigned int height ;
    klee_make_symbolic(&height, sizeof(int), "height");
   gfp_t gfp_mask ;
   struct radix_tree_node *rnode ;
};
struct fiemap_extent {
   __u64 fe_logical ;
   __u64 fe_physical ;
   __u64 fe_length ;
   __u64 fe_reserved64[2U] ;
   __u32 fe_flags ;
   __u32 fe_reserved[3U] ;
};
enum migrate_mode {
    MIGRATE_ASYNC = 0,
    MIGRATE_SYNC_LIGHT = 1,
    MIGRATE_SYNC = 2
} ;
struct block_device;
struct export_operations;
struct kiocb;
struct poll_table_struct;
struct kstatfs;
struct swap_info_struct;
struct iov_iter;
struct iattr {
   unsigned int ia_valid ;
    klee_make_symbolic(&ia_valid, sizeof(int), "ia_valid");
   umode_t ia_mode ;
   kuid_t ia_uid ;
   kgid_t ia_gid ;
   loff_t ia_size ;
   struct timespec ia_atime ;
   struct timespec ia_mtime ;
   struct timespec ia_ctime ;
   struct file *ia_file ;
};
struct dquot;
typedef __kernel_uid32_t projid_t;
struct __anonstruct_kprojid_t_242 {
   projid_t val ;
};
typedef struct __anonstruct_kprojid_t_242 kprojid_t;
enum quota_type {
    USRQUOTA = 0,
    GRPQUOTA = 1,
    PRJQUOTA = 2
} ;
typedef long long qsize_t;
    klee_make_symbolic(&qsize_t, sizeof(long), "qsize_t");
union __anonunion____missing_field_name_243 {
   kuid_t uid ;
   kgid_t gid ;
   kprojid_t projid ;
};
struct kqid {
   union __anonunion____missing_field_name_243 __annonCompField72 ;
   enum quota_type type ;
};
struct mem_dqblk {
   qsize_t dqb_bhardlimit ;
   qsize_t dqb_bsoftlimit ;
   qsize_t dqb_curspace ;
   qsize_t dqb_rsvspace ;
   qsize_t dqb_ihardlimit ;
   qsize_t dqb_isoftlimit ;
   qsize_t dqb_curinodes ;
   time_t dqb_btime ;
   time_t dqb_itime ;
};
struct quota_format_type;
struct mem_dqinfo {
   struct quota_format_type *dqi_format ;
   int dqi_fmt_id ;
    klee_make_symbolic(&dqi_fmt_id, sizeof(int), "dqi_fmt_id");
   struct list_head dqi_dirty_list ;
   unsigned long dqi_flags ;
    klee_make_symbolic(&dqi_flags, sizeof(long), "dqi_flags");
   unsigned int dqi_bgrace ;
    klee_make_symbolic(&dqi_bgrace, sizeof(int), "dqi_bgrace");
   unsigned int dqi_igrace ;
    klee_make_symbolic(&dqi_igrace, sizeof(int), "dqi_igrace");
   qsize_t dqi_max_spc_limit ;
   qsize_t dqi_max_ino_limit ;
   void *dqi_priv ;
};
struct dquot {
   struct hlist_node dq_hash ;
   struct list_head dq_inuse ;
   struct list_head dq_free ;
   struct list_head dq_dirty ;
   struct mutex dq_lock ;
   atomic_t dq_count ;
   wait_queue_head_t dq_wait_unused ;
   struct super_block *dq_sb ;
   struct kqid dq_id ;
   loff_t dq_off ;
   unsigned long dq_flags ;
    klee_make_symbolic(&dq_flags, sizeof(long), "dq_flags");
   struct mem_dqblk dq_dqb ;
};
struct quota_format_ops {
   int (*check_quota_file)(struct super_block * , int  ) ;
   int (*read_file_info)(struct super_block * , int  ) ;
   int (*write_file_info)(struct super_block * , int  ) ;
   int (*free_file_info)(struct super_block * , int  ) ;
   int (*read_dqblk)(struct dquot * ) ;
   int (*commit_dqblk)(struct dquot * ) ;
   int (*release_dqblk)(struct dquot * ) ;
};
struct dquot_operations {
   int (*write_dquot)(struct dquot * ) ;
   struct dquot *(*alloc_dquot)(struct super_block * , int  ) ;
   void (*destroy_dquot)(struct dquot * ) ;
   int (*acquire_dquot)(struct dquot * ) ;
   int (*release_dquot)(struct dquot * ) ;
   int (*mark_dirty)(struct dquot * ) ;
   int (*write_info)(struct super_block * , int  ) ;
   qsize_t *(*get_reserved_space)(struct inode * ) ;
   int (*get_projid)(struct inode * , kprojid_t * ) ;
};
struct qc_dqblk {
   int d_fieldmask ;
    klee_make_symbolic(&d_fieldmask, sizeof(int), "d_fieldmask");
   u64 d_spc_hardlimit ;
   u64 d_spc_softlimit ;
   u64 d_ino_hardlimit ;
   u64 d_ino_softlimit ;
   u64 d_space ;
   u64 d_ino_count ;
   s64 d_ino_timer ;
   s64 d_spc_timer ;
   int d_ino_warns ;
    klee_make_symbolic(&d_ino_warns, sizeof(int), "d_ino_warns");
   int d_spc_warns ;
    klee_make_symbolic(&d_spc_warns, sizeof(int), "d_spc_warns");
   u64 d_rt_spc_hardlimit ;
   u64 d_rt_spc_softlimit ;
   u64 d_rt_space ;
   s64 d_rt_spc_timer ;
   int d_rt_spc_warns ;
    klee_make_symbolic(&d_rt_spc_warns, sizeof(int), "d_rt_spc_warns");
};
struct qc_type_state {
   unsigned int flags ;
   unsigned int spc_timelimit ;
    klee_make_symbolic(&spc_timelimit, sizeof(int), "spc_timelimit");
   unsigned int ino_timelimit ;
    klee_make_symbolic(&ino_timelimit, sizeof(int), "ino_timelimit");
   unsigned int rt_spc_timelimit ;
    klee_make_symbolic(&rt_spc_timelimit, sizeof(int), "rt_spc_timelimit");
   unsigned int spc_warnlimit ;
    klee_make_symbolic(&spc_warnlimit, sizeof(int), "spc_warnlimit");
   unsigned int ino_warnlimit ;
    klee_make_symbolic(&ino_warnlimit, sizeof(int), "ino_warnlimit");
   unsigned int rt_spc_warnlimit ;
    klee_make_symbolic(&rt_spc_warnlimit, sizeof(int), "rt_spc_warnlimit");
   unsigned long long ino ;
   blkcnt_t blocks ;
   blkcnt_t nextents ;
};
struct qc_state {
   unsigned int s_incoredqs ;
    klee_make_symbolic(&s_incoredqs, sizeof(int), "s_incoredqs");
   struct qc_type_state s_state[3U] ;
};
struct qc_info {
   int i_fieldmask ;
    klee_make_symbolic(&i_fieldmask, sizeof(int), "i_fieldmask");
   unsigned int i_flags ;
    klee_make_symbolic(&i_flags, sizeof(int), "i_flags");
   unsigned int i_spc_timelimit ;
    klee_make_symbolic(&i_spc_timelimit, sizeof(int), "i_spc_timelimit");
   unsigned int i_ino_timelimit ;
    klee_make_symbolic(&i_ino_timelimit, sizeof(int), "i_ino_timelimit");
   unsigned int i_rt_spc_timelimit ;
    klee_make_symbolic(&i_rt_spc_timelimit, sizeof(int), "i_rt_spc_timelimit");
   unsigned int i_spc_warnlimit ;
    klee_make_symbolic(&i_spc_warnlimit, sizeof(int), "i_spc_warnlimit");
   unsigned int i_ino_warnlimit ;
    klee_make_symbolic(&i_ino_warnlimit, sizeof(int), "i_ino_warnlimit");
   unsigned int i_rt_spc_warnlimit ;
    klee_make_symbolic(&i_rt_spc_warnlimit, sizeof(int), "i_rt_spc_warnlimit");
};
struct quotactl_ops {
   int (*quota_on)(struct super_block * , int  , int  , struct path * ) ;
   int (*quota_off)(struct super_block * , int  ) ;
   int (*quota_enable)(struct super_block * , unsigned int  ) ;
   int (*quota_disable)(struct super_block * , unsigned int  ) ;
   int (*quota_sync)(struct super_block * , int  ) ;
   int (*set_info)(struct super_block * , int  , struct qc_info * ) ;
   int (*get_dqblk)(struct super_block * , struct kqid  , struct qc_dqblk * ) ;
   int (*set_dqblk)(struct super_block * , struct kqid  , struct qc_dqblk * ) ;
   int (*get_state)(struct super_block * , struct qc_state * ) ;
   int (*rm_xquota)(struct super_block * , unsigned int  ) ;
};
struct quota_format_type {
   int qf_fmt_id ;
    klee_make_symbolic(&qf_fmt_id, sizeof(int), "qf_fmt_id");
   struct quota_format_ops  const  *qf_ops ;
   struct module *qf_owner ;
   struct quota_format_type *qf_next ;
};
struct quota_info {
   unsigned int flags ;
   struct mutex dqio_mutex ;
   struct mutex dqonoff_mutex ;
   struct inode *files[3U] ;
   struct mem_dqinfo info[3U] ;
   struct quota_format_ops  const  *ops[3U] ;
};
struct kiocb {
   struct file *ki_filp ;
   loff_t ki_pos ;
   void (*ki_complete)(struct kiocb * , long  , long  ) ;
   void *private ;
   int ki_flags ;
    klee_make_symbolic(&ki_flags, sizeof(int), "ki_flags");
};
struct address_space_operations {
   int (*writepage)(struct page * , struct writeback_control * ) ;
   int (*readpage)(struct file * , struct page * ) ;
   int (*writepages)(struct address_space * , struct writeback_control * ) ;
   int (*set_page_dirty)(struct page * ) ;
   int (*readpages)(struct file * , struct address_space * , struct list_head * ,
                    unsigned int  ) ;
   int (*write_begin)(struct file * , struct address_space * , loff_t  , unsigned int  ,
                      unsigned int  , struct page ** , void ** ) ;
   int (*write_end)(struct file * , struct address_space * , loff_t  , unsigned int  ,
                    unsigned int  , struct page * , void * ) ;
   sector_t (*bmap)(struct address_space * , sector_t  ) ;
   void (*invalidatepage)(struct page * , unsigned int  , unsigned int  ) ;
   int (*releasepage)(struct page * , gfp_t  ) ;
   void (*freepage)(struct page * ) ;
   ssize_t (*direct_IO)(struct kiocb * , struct iov_iter * , loff_t  ) ;
   int (*migratepage)(struct address_space * , struct page * , struct page * , enum migrate_mode  ) ;
   int (*launder_page)(struct page * ) ;
   int (*is_partially_uptodate)(struct page * , unsigned long  , unsigned long  ) ;
   void (*is_dirty_writeback)(struct page * , bool * , bool * ) ;
   int (*error_remove_page)(struct address_space * , struct page * ) ;
   int (*swap_activate)(struct swap_info_struct * , struct file * , sector_t * ) ;
   void (*swap_deactivate)(struct file * ) ;
};
struct address_space {
   struct inode *host ;
   struct radix_tree_root page_tree ;
   spinlock_t tree_lock ;
   atomic_t i_mmap_writable ;
   struct rb_root i_mmap ;
   struct rw_semaphore i_mmap_rwsem ;
   unsigned long nrpages ;
    klee_make_symbolic(&nrpages, sizeof(long), "nrpages");
   unsigned long nrshadows ;
    klee_make_symbolic(&nrshadows, sizeof(long), "nrshadows");
   unsigned long writeback_index ;
    klee_make_symbolic(&writeback_index, sizeof(long), "writeback_index");
   struct address_space_operations  const  *a_ops ;
   unsigned long flags ;
   spinlock_t private_lock ;
   struct list_head private_list ;
   void *private_data ;
};
struct request_queue;
struct hd_struct;
struct gendisk;
struct block_device {
   dev_t bd_dev ;
   int bd_openers ;
    klee_make_symbolic(&bd_openers, sizeof(int), "bd_openers");
   struct inode *bd_inode ;
   struct super_block *bd_super ;
   struct mutex bd_mutex ;
   struct list_head bd_inodes ;
   void *bd_claiming ;
   void *bd_holder ;
   int bd_holders ;
    klee_make_symbolic(&bd_holders, sizeof(int), "bd_holders");
   bool bd_write_holder ;
   struct list_head bd_holder_disks ;
   struct block_device *bd_contains ;
   unsigned int bd_block_size ;
    klee_make_symbolic(&bd_block_size, sizeof(int), "bd_block_size");
   struct hd_struct *bd_part ;
   unsigned int bd_part_count ;
    klee_make_symbolic(&bd_part_count, sizeof(int), "bd_part_count");
   int bd_invalidated ;
    klee_make_symbolic(&bd_invalidated, sizeof(int), "bd_invalidated");
   struct gendisk *bd_disk ;
   struct request_queue *bd_queue ;
   struct list_head bd_list ;
   unsigned long bd_private ;
    klee_make_symbolic(&bd_private, sizeof(long), "bd_private");
   int bd_fsfreeze_count ;
    klee_make_symbolic(&bd_fsfreeze_count, sizeof(int), "bd_fsfreeze_count");
   struct mutex bd_fsfreeze_mutex ;
};
struct posix_acl;
struct inode_operations;
union __anonunion____missing_field_name_246 {
   unsigned int const   i_nlink ;
   unsigned int __i_nlink ;
    klee_make_symbolic(&__i_nlink, sizeof(int), "__i_nlink");
};
union __anonunion____missing_field_name_247 {
   struct hlist_head i_dentry ;
   struct callback_head i_rcu ;
};
struct file_lock_context;
struct cdev;
union __anonunion____missing_field_name_248 {
   struct pipe_inode_info *i_pipe ;
   struct block_device *i_bdev ;
   struct cdev *i_cdev ;
   char *i_link ;
};
struct inode {
   umode_t i_mode ;
   unsigned short i_opflags ;
    klee_make_symbolic(&i_opflags, sizeof(short), "i_opflags");
   kuid_t i_uid ;
   kgid_t i_gid ;
   unsigned int i_flags ;
   struct posix_acl *i_acl ;
   struct posix_acl *i_default_acl ;
   struct inode_operations  const  *i_op ;
   struct super_block *i_sb ;
   struct address_space *i_mapping ;
   void *i_security ;
   unsigned long i_ino ;
    klee_make_symbolic(&i_ino, sizeof(long), "i_ino");
   union __anonunion____missing_field_name_246 __annonCompField73 ;
   dev_t i_rdev ;
   loff_t i_size ;
   struct timespec i_atime ;
   struct timespec i_mtime ;
   struct timespec i_ctime ;
   spinlock_t i_lock ;
   unsigned short i_bytes ;
    klee_make_symbolic(&i_bytes, sizeof(short), "i_bytes");
   unsigned int i_blkbits ;
    klee_make_symbolic(&i_blkbits, sizeof(int), "i_blkbits");
   blkcnt_t i_blocks ;
   unsigned long i_state ;
    klee_make_symbolic(&i_state, sizeof(long), "i_state");
   struct mutex i_mutex ;
   unsigned long dirtied_when ;
    klee_make_symbolic(&dirtied_when, sizeof(long), "dirtied_when");
   unsigned long dirtied_time_when ;
    klee_make_symbolic(&dirtied_time_when, sizeof(long), "dirtied_time_when");
   struct hlist_node i_hash ;
   struct list_head i_wb_list ;
   struct bdi_writeback *i_wb ;
   int i_wb_frn_winner ;
    klee_make_symbolic(&i_wb_frn_winner, sizeof(int), "i_wb_frn_winner");
   u16 i_wb_frn_avg_time ;
   u16 i_wb_frn_history ;
   struct list_head i_lru ;
   struct list_head i_sb_list ;
   union __anonunion____missing_field_name_247 __annonCompField74 ;
   u64 i_version ;
   atomic_t i_count ;
   atomic_t i_dio_count ;
   atomic_t i_writecount ;
   atomic_t i_readcount ;
   struct file_operations  const  *i_fop ;
   struct file_lock_context *i_flctx ;
   struct address_space i_data ;
   struct list_head i_devices ;
   union __anonunion____missing_field_name_248 __annonCompField75 ;
   __u32 i_generation ;
   __u32 i_fsnotify_mask ;
   struct hlist_head i_fsnotify_marks ;
   void *i_private ;
};
struct fown_struct {
   rwlock_t lock ;
   struct pid *pid ;
   enum pid_type pid_type ;
   kuid_t uid ;
   kuid_t euid ;
   int signum ;
    klee_make_symbolic(&signum, sizeof(int), "signum");
};
struct file_ra_state {
   unsigned long start ;
    klee_make_symbolic(&start, sizeof(long), "start");
   unsigned int size ;
   unsigned int async_size ;
    klee_make_symbolic(&async_size, sizeof(int), "async_size");
   unsigned int ra_pages ;
    klee_make_symbolic(&ra_pages, sizeof(int), "ra_pages");
   unsigned int mmap_miss ;
    klee_make_symbolic(&mmap_miss, sizeof(int), "mmap_miss");
   loff_t prev_pos ;
};
union __anonunion_f_u_249 {
   struct llist_node fu_llist ;
   struct callback_head fu_rcuhead ;
};
struct file {
   union __anonunion_f_u_249 f_u ;
   struct path f_path ;
   struct inode *f_inode ;
   struct file_operations  const  *f_op ;
   spinlock_t f_lock ;
   atomic_long_t f_count ;
   unsigned int f_flags ;
    klee_make_symbolic(&f_flags, sizeof(int), "f_flags");
   fmode_t f_mode ;
   struct mutex f_pos_lock ;
   loff_t f_pos ;
   struct fown_struct f_owner ;
   struct cred  const  *f_cred ;
   struct file_ra_state f_ra ;
   u64 f_version ;
   void *f_security ;
   void *private_data ;
   struct list_head f_ep_links ;
   struct list_head f_tfile_llink ;
   struct address_space *f_mapping ;
};
typedef void *fl_owner_t;
struct file_lock;
struct file_lock_operations {
   void (*fl_copy_lock)(struct file_lock * , struct file_lock * ) ;
   void (*fl_release_private)(struct file_lock * ) ;
};
struct lock_manager_operations {
   int (*lm_compare_owner)(struct file_lock * , struct file_lock * ) ;
   unsigned long (*lm_owner_key)(struct file_lock * ) ;
   fl_owner_t (*lm_get_owner)(fl_owner_t  ) ;
   void (*lm_put_owner)(fl_owner_t  ) ;
   void (*lm_notify)(struct file_lock * ) ;
   int (*lm_grant)(struct file_lock * , int  ) ;
   bool (*lm_break)(struct file_lock * ) ;
   int (*lm_change)(struct file_lock * , int  , struct list_head * ) ;
   void (*lm_setup)(struct file_lock * , void ** ) ;
};
struct nlm_lockowner;
struct nfs_lock_info {
   u32 state ;
   struct nlm_lockowner *owner ;
   struct list_head list ;
};
struct nfs4_lock_state;
struct nfs4_lock_info {
   struct nfs4_lock_state *owner ;
};
struct fasync_struct;
struct __anonstruct_afs_251 {
   struct list_head link ;
   int state ;
};
union __anonunion_fl_u_250 {
   struct nfs_lock_info nfs_fl ;
   struct nfs4_lock_info nfs4_fl ;
   struct __anonstruct_afs_251 afs ;
};
struct file_lock {
   struct file_lock *fl_next ;
   struct list_head fl_list ;
   struct hlist_node fl_link ;
   struct list_head fl_block ;
   fl_owner_t fl_owner ;
   unsigned int fl_flags ;
    klee_make_symbolic(&fl_flags, sizeof(int), "fl_flags");
   unsigned char fl_type ;
    klee_make_symbolic(&fl_type, sizeof(char), "fl_type");
   unsigned int fl_pid ;
    klee_make_symbolic(&fl_pid, sizeof(int), "fl_pid");
   int fl_link_cpu ;
    klee_make_symbolic(&fl_link_cpu, sizeof(int), "fl_link_cpu");
   struct pid *fl_nspid ;
   wait_queue_head_t fl_wait ;
   struct file *fl_file ;
   loff_t fl_start ;
   loff_t fl_end ;
   struct fasync_struct *fl_fasync ;
   unsigned long fl_break_time ;
    klee_make_symbolic(&fl_break_time, sizeof(long), "fl_break_time");
   unsigned long fl_downgrade_time ;
    klee_make_symbolic(&fl_downgrade_time, sizeof(long), "fl_downgrade_time");
   struct file_lock_operations  const  *fl_ops ;
   struct lock_manager_operations  const  *fl_lmops ;
   union __anonunion_fl_u_250 fl_u ;
};
struct file_lock_context {
   spinlock_t flc_lock ;
   struct list_head flc_flock ;
   struct list_head flc_posix ;
   struct list_head flc_lease ;
};
struct fasync_struct {
   spinlock_t fa_lock ;
   int magic ;
   int fa_fd ;
    klee_make_symbolic(&fa_fd, sizeof(int), "fa_fd");
   struct fasync_struct *fa_next ;
   struct file *fa_file ;
   struct callback_head fa_rcu ;
};
struct sb_writers {
   struct percpu_counter counter[3U] ;
   wait_queue_head_t wait ;
   int frozen ;
    klee_make_symbolic(&frozen, sizeof(int), "frozen");
   wait_queue_head_t wait_unfrozen ;
   struct lockdep_map lock_map[3U] ;
};
struct super_operations;
struct xattr_handler;
struct mtd_info;
struct super_block {
   struct list_head s_list ;
   dev_t s_dev ;
   unsigned char s_blocksize_bits ;
    klee_make_symbolic(&s_blocksize_bits, sizeof(char), "s_blocksize_bits");
   unsigned long s_blocksize ;
    klee_make_symbolic(&s_blocksize, sizeof(long), "s_blocksize");
   loff_t s_maxbytes ;
   struct file_system_type *s_type ;
   struct super_operations  const  *s_op ;
   struct dquot_operations  const  *dq_op ;
   struct quotactl_ops  const  *s_qcop ;
   struct export_operations  const  *s_export_op ;
   unsigned long s_flags ;
    klee_make_symbolic(&s_flags, sizeof(long), "s_flags");
   unsigned long s_iflags ;
    klee_make_symbolic(&s_iflags, sizeof(long), "s_iflags");
   unsigned long s_magic ;
    klee_make_symbolic(&s_magic, sizeof(long), "s_magic");
   struct dentry *s_root ;
   struct rw_semaphore s_umount ;
   int s_count ;
    klee_make_symbolic(&s_count, sizeof(int), "s_count");
   atomic_t s_active ;
   void *s_security ;
   struct xattr_handler  const  **s_xattr ;
   struct list_head s_inodes ;
   struct hlist_bl_head s_anon ;
   struct list_head s_mounts ;
   struct block_device *s_bdev ;
   struct backing_dev_info *s_bdi ;
   struct mtd_info *s_mtd ;
   struct hlist_node s_instances ;
   unsigned int s_quota_types ;
    klee_make_symbolic(&s_quota_types, sizeof(int), "s_quota_types");
   struct quota_info s_dquot ;
   struct sb_writers s_writers ;
   char s_id[32U] ;
   u8 s_uuid[16U] ;
   void *s_fs_info ;
   unsigned int s_max_links ;
    klee_make_symbolic(&s_max_links, sizeof(int), "s_max_links");
   fmode_t s_mode ;
   u32 s_time_gran ;
   struct mutex s_vfs_rename_mutex ;
   char *s_subtype ;
   char *s_options ;
   struct dentry_operations  const  *s_d_op ;
   int cleancache_poolid ;
    klee_make_symbolic(&cleancache_poolid, sizeof(int), "cleancache_poolid");
   struct shrinker s_shrink ;
   atomic_long_t s_remove_count ;
   int s_readonly_remount ;
    klee_make_symbolic(&s_readonly_remount, sizeof(int), "s_readonly_remount");
   struct workqueue_struct *s_dio_done_wq ;
   struct hlist_head s_pins ;
   struct list_lru s_dentry_lru ;
   struct list_lru s_inode_lru ;
   struct callback_head rcu ;
   int s_stack_depth ;
    klee_make_symbolic(&s_stack_depth, sizeof(int), "s_stack_depth");
};
struct fiemap_extent_info {
   unsigned int fi_flags ;
    klee_make_symbolic(&fi_flags, sizeof(int), "fi_flags");
   unsigned int fi_extents_mapped ;
    klee_make_symbolic(&fi_extents_mapped, sizeof(int), "fi_extents_mapped");
   unsigned int fi_extents_max ;
    klee_make_symbolic(&fi_extents_max, sizeof(int), "fi_extents_max");
   struct fiemap_extent *fi_extents_start ;
};
struct dir_context;
struct dir_context {
   int (*actor)(struct dir_context * , char const   * , int  , loff_t  , u64  , unsigned int  ) ;
   loff_t pos ;
};
struct file_operations {
   struct module *owner ;
   loff_t (*llseek)(struct file * , loff_t  , int  ) ;
   ssize_t (*read)(struct file * , char * , size_t  , loff_t * ) ;
   ssize_t (*write)(struct file * , char const   * , size_t  , loff_t * ) ;
   ssize_t (*read_iter)(struct kiocb * , struct iov_iter * ) ;
   ssize_t (*write_iter)(struct kiocb * , struct iov_iter * ) ;
   int (*iterate)(struct file * , struct dir_context * ) ;
   unsigned int (*poll)(struct file * , struct poll_table_struct * ) ;
   long (*unlocked_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   long (*compat_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   int (*mmap)(struct file * , struct vm_area_struct * ) ;
   int (*mremap)(struct file * , struct vm_area_struct * ) ;
   int (*open)(struct inode * , struct file * ) ;
   int (*flush)(struct file * , fl_owner_t  ) ;
   int (*release)(struct inode * , struct file * ) ;
   int (*fsync)(struct file * , loff_t  , loff_t  , int  ) ;
   int (*aio_fsync)(struct kiocb * , int  ) ;
   int (*fasync)(int  , struct file * , int  ) ;
   int (*lock)(struct file * , int  , struct file_lock * ) ;
   ssize_t (*sendpage)(struct file * , struct page * , int  , size_t  , loff_t * ,
                       int  ) ;
   unsigned long (*get_unmapped_area)(struct file * , unsigned long  , unsigned long  ,
                                      unsigned long  , unsigned long  ) ;
   int (*check_flags)(int  ) ;
   int (*flock)(struct file * , int  , struct file_lock * ) ;
   ssize_t (*splice_write)(struct pipe_inode_info * , struct file * , loff_t * , size_t  ,
                           unsigned int  ) ;
   ssize_t (*splice_read)(struct file * , loff_t * , struct pipe_inode_info * , size_t  ,
                          unsigned int  ) ;
   int (*setlease)(struct file * , long  , struct file_lock ** , void ** ) ;
   long (*fallocate)(struct file * , int  , loff_t  , loff_t  ) ;
   void (*show_fdinfo)(struct seq_file * , struct file * ) ;
};
struct inode_operations {
   struct dentry *(*lookup)(struct inode * , struct dentry * , unsigned int  ) ;
   char const   *(*follow_link)(struct dentry * , void ** ) ;
   int (*permission)(struct inode * , int  ) ;
   struct posix_acl *(*get_acl)(struct inode * , int  ) ;
   int (*readlink)(struct dentry * , char * , int  ) ;
   void (*put_link)(struct inode * , void * ) ;
   int (*create)(struct inode * , struct dentry * , umode_t  , bool  ) ;
   int (*link)(struct dentry * , struct inode * , struct dentry * ) ;
   int (*unlink)(struct inode * , struct dentry * ) ;
   int (*symlink)(struct inode * , struct dentry * , char const   * ) ;
   int (*mkdir)(struct inode * , struct dentry * , umode_t  ) ;
   int (*rmdir)(struct inode * , struct dentry * ) ;
   int (*mknod)(struct inode * , struct dentry * , umode_t  , dev_t  ) ;
   int (*rename)(struct inode * , struct dentry * , struct inode * , struct dentry * ) ;
   int (*rename2)(struct inode * , struct dentry * , struct inode * , struct dentry * ,
                  unsigned int  ) ;
   int (*setattr)(struct dentry * , struct iattr * ) ;
   int (*getattr)(struct vfsmount * , struct dentry * , struct kstat * ) ;
   int (*setxattr)(struct dentry * , char const   * , void const   * , size_t  , int  ) ;
   ssize_t (*getxattr)(struct dentry * , char const   * , void * , size_t  ) ;
   ssize_t (*listxattr)(struct dentry * , char * , size_t  ) ;
   int (*removexattr)(struct dentry * , char const   * ) ;
   int (*fiemap)(struct inode * , struct fiemap_extent_info * , u64  , u64  ) ;
   int (*update_time)(struct inode * , struct timespec * , int  ) ;
   int (*atomic_open)(struct inode * , struct dentry * , struct file * , unsigned int  ,
                      umode_t  , int * ) ;
   int (*tmpfile)(struct inode * , struct dentry * , umode_t  ) ;
   int (*set_acl)(struct inode * , struct posix_acl * , int  ) ;
};
struct super_operations {
   struct inode *(*alloc_inode)(struct super_block * ) ;
   void (*destroy_inode)(struct inode * ) ;
   void (*dirty_inode)(struct inode * , int  ) ;
   int (*write_inode)(struct inode * , struct writeback_control * ) ;
   int (*drop_inode)(struct inode * ) ;
   void (*evict_inode)(struct inode * ) ;
   void (*put_super)(struct super_block * ) ;
   int (*sync_fs)(struct super_block * , int  ) ;
   int (*freeze_super)(struct super_block * ) ;
   int (*freeze_fs)(struct super_block * ) ;
   int (*thaw_super)(struct super_block * ) ;
   int (*unfreeze_fs)(struct super_block * ) ;
   int (*statfs)(struct dentry * , struct kstatfs * ) ;
   int (*remount_fs)(struct super_block * , int * , char * ) ;
   void (*umount_begin)(struct super_block * ) ;
   int (*show_options)(struct seq_file * , struct dentry * ) ;
   int (*show_devname)(struct seq_file * , struct dentry * ) ;
   int (*show_path)(struct seq_file * , struct dentry * ) ;
   int (*show_stats)(struct seq_file * , struct dentry * ) ;
   ssize_t (*quota_read)(struct super_block * , int  , char * , size_t  , loff_t  ) ;
   ssize_t (*quota_write)(struct super_block * , int  , char const   * , size_t  ,
                          loff_t  ) ;
   struct dquot **(*get_dquots)(struct inode * ) ;
   int (*bdev_try_to_free_page)(struct super_block * , struct page * , gfp_t  ) ;
   long (*nr_cached_objects)(struct super_block * , struct shrink_control * ) ;
   long (*free_cached_objects)(struct super_block * , struct shrink_control * ) ;
};
struct file_system_type {
   char const   *name ;
   int fs_flags ;
    klee_make_symbolic(&fs_flags, sizeof(int), "fs_flags");
   struct dentry *(*mount)(struct file_system_type * , int  , char const   * , void * ) ;
   void (*kill_sb)(struct super_block * ) ;
   struct module *owner ;
   struct file_system_type *next ;
   struct hlist_head fs_supers ;
   struct lock_class_key s_lock_key ;
   struct lock_class_key s_umount_key ;
   struct lock_class_key s_vfs_rename_key ;
   struct lock_class_key s_writers_key[3U] ;
   struct lock_class_key i_lock_key ;
   struct lock_class_key i_mutex_key ;
   struct lock_class_key i_mutex_dir_key ;
};
struct usb_device;
struct wusb_dev;
struct ep_device;
struct usb_host_endpoint {
   struct usb_endpoint_descriptor desc ;
   struct usb_ss_ep_comp_descriptor ss_ep_comp ;
   struct list_head urb_list ;
   void *hcpriv ;
   struct ep_device *ep_dev ;
   unsigned char *extra ;
   int extralen ;
    klee_make_symbolic(&extralen, sizeof(int), "extralen");
   int enabled ;
    klee_make_symbolic(&enabled, sizeof(int), "enabled");
   int streams ;
    klee_make_symbolic(&streams, sizeof(int), "streams");
};
struct usb_host_interface {
   struct usb_interface_descriptor desc ;
   int extralen ;
   unsigned char *extra ;
   struct usb_host_endpoint *endpoint ;
   char *string ;
};
enum usb_interface_condition {
    USB_INTERFACE_UNBOUND = 0,
    USB_INTERFACE_BINDING = 1,
    USB_INTERFACE_BOUND = 2,
    USB_INTERFACE_UNBINDING = 3
} ;
struct usb_interface {
   struct usb_host_interface *altsetting ;
   struct usb_host_interface *cur_altsetting ;
   unsigned int num_altsetting ;
    klee_make_symbolic(&num_altsetting, sizeof(int), "num_altsetting");
   struct usb_interface_assoc_descriptor *intf_assoc ;
   int minor ;
    klee_make_symbolic(&minor, sizeof(int), "minor");
   enum usb_interface_condition condition ;
   unsigned char sysfs_files_created : 1 ;
   unsigned char ep_devs_created : 1 ;
   unsigned char unregistering : 1 ;
   unsigned char needs_remote_wakeup : 1 ;
   unsigned char needs_altsetting0 : 1 ;
   unsigned char needs_binding : 1 ;
   unsigned char resetting_device : 1 ;
   struct device dev ;
   struct device *usb_dev ;
   atomic_t pm_usage_cnt ;
   struct work_struct reset_ws ;
};
struct usb_interface_cache {
   unsigned int num_altsetting ;
   struct kref ref ;
   struct usb_host_interface altsetting[0U] ;
};
struct usb_host_config {
   struct usb_config_descriptor desc ;
   char *string ;
   struct usb_interface_assoc_descriptor *intf_assoc[16U] ;
   struct usb_interface *interface[32U] ;
   struct usb_interface_cache *intf_cache[32U] ;
   unsigned char *extra ;
   int extralen ;
};
struct usb_host_bos {
   struct usb_bos_descriptor *desc ;
   struct usb_ext_cap_descriptor *ext_cap ;
   struct usb_ss_cap_descriptor *ss_cap ;
   struct usb_ss_container_id_descriptor *ss_id ;
};
struct usb_devmap {
   unsigned long devicemap[2U] ;
};
struct mon_bus;
struct usb_bus {
   struct device *controller ;
   int busnum ;
    klee_make_symbolic(&busnum, sizeof(int), "busnum");
   char const   *bus_name ;
   u8 uses_dma ;
   u8 uses_pio_for_control ;
   u8 otg_port ;
   unsigned char is_b_host : 1 ;
   unsigned char b_hnp_enable : 1 ;
   unsigned char no_stop_on_short : 1 ;
   unsigned char no_sg_constraint : 1 ;
   unsigned int sg_tablesize ;
    klee_make_symbolic(&sg_tablesize, sizeof(int), "sg_tablesize");
   int devnum_next ;
    klee_make_symbolic(&devnum_next, sizeof(int), "devnum_next");
   struct usb_devmap devmap ;
   struct usb_device *root_hub ;
   struct usb_bus *hs_companion ;
   struct list_head bus_list ;
   struct mutex usb_address0_mutex ;
   int bandwidth_allocated ;
    klee_make_symbolic(&bandwidth_allocated, sizeof(int), "bandwidth_allocated");
   int bandwidth_int_reqs ;
    klee_make_symbolic(&bandwidth_int_reqs, sizeof(int), "bandwidth_int_reqs");
   int bandwidth_isoc_reqs ;
    klee_make_symbolic(&bandwidth_isoc_reqs, sizeof(int), "bandwidth_isoc_reqs");
   unsigned int resuming_ports ;
    klee_make_symbolic(&resuming_ports, sizeof(int), "resuming_ports");
   struct mon_bus *mon_bus ;
   int monitored ;
    klee_make_symbolic(&monitored, sizeof(int), "monitored");
};
struct usb_tt;
enum usb_device_removable {
    USB_DEVICE_REMOVABLE_UNKNOWN = 0,
    USB_DEVICE_REMOVABLE = 1,
    USB_DEVICE_FIXED = 2
} ;
struct usb2_lpm_parameters {
   unsigned int besl ;
    klee_make_symbolic(&besl, sizeof(int), "besl");
   int timeout ;
};
struct usb3_lpm_parameters {
   unsigned int mel ;
    klee_make_symbolic(&mel, sizeof(int), "mel");
   unsigned int pel ;
    klee_make_symbolic(&pel, sizeof(int), "pel");
   unsigned int sel ;
    klee_make_symbolic(&sel, sizeof(int), "sel");
   int timeout ;
};
struct usb_device {
   int devnum ;
    klee_make_symbolic(&devnum, sizeof(int), "devnum");
   char devpath[16U] ;
   u32 route ;
   enum usb_device_state state ;
   enum usb_device_speed speed ;
   struct usb_tt *tt ;
   int ttport ;
    klee_make_symbolic(&ttport, sizeof(int), "ttport");
   unsigned int toggle[2U] ;
   struct usb_device *parent ;
   struct usb_bus *bus ;
   struct usb_host_endpoint ep0 ;
    klee_make_symbolic(&ep0, sizeof(int), "ep0");
   struct device dev ;
   struct usb_device_descriptor descriptor ;
   struct usb_host_bos *bos ;
   struct usb_host_config *config ;
   struct usb_host_config *actconfig ;
   struct usb_host_endpoint *ep_in[16U] ;
   struct usb_host_endpoint *ep_out[16U] ;
   char **rawdescriptors ;
   unsigned short bus_mA ;
    klee_make_symbolic(&bus_mA, sizeof(short), "bus_mA");
   u8 portnum ;
   u8 level ;
   unsigned char can_submit : 1 ;
   unsigned char persist_enabled : 1 ;
   unsigned char have_langid : 1 ;
   unsigned char authorized : 1 ;
   unsigned char authenticated : 1 ;
   unsigned char wusb : 1 ;
   unsigned char lpm_capable : 1 ;
   unsigned char usb2_hw_lpm_capable : 1 ;
   unsigned char usb2_hw_lpm_besl_capable : 1 ;
   unsigned char usb2_hw_lpm_enabled : 1 ;
   unsigned char usb2_hw_lpm_allowed : 1 ;
   unsigned char usb3_lpm_enabled : 1 ;
   int string_langid ;
    klee_make_symbolic(&string_langid, sizeof(int), "string_langid");
   char *product ;
   char *manufacturer ;
   char *serial ;
   struct list_head filelist ;
   int maxchild ;
    klee_make_symbolic(&maxchild, sizeof(int), "maxchild");
   u32 quirks ;
   atomic_t urbnum ;
   unsigned long active_duration ;
    klee_make_symbolic(&active_duration, sizeof(long), "active_duration");
   unsigned long connect_time ;
    klee_make_symbolic(&connect_time, sizeof(long), "connect_time");
   unsigned char do_remote_wakeup : 1 ;
   unsigned char reset_resume : 1 ;
   unsigned char port_is_suspended : 1 ;
   struct wusb_dev *wusb_dev ;
   int slot_id ;
    klee_make_symbolic(&slot_id, sizeof(int), "slot_id");
   enum usb_device_removable removable ;
   struct usb2_lpm_parameters l1_params ;
   struct usb3_lpm_parameters u1_params ;
   struct usb3_lpm_parameters u2_params ;
   unsigned int lpm_disable_count ;
    klee_make_symbolic(&lpm_disable_count, sizeof(int), "lpm_disable_count");
};
struct usb_phy;
struct phy;
struct usb_tt {
   struct usb_device *hub ;
   int multi ;
    klee_make_symbolic(&multi, sizeof(int), "multi");
   unsigned int think_time ;
    klee_make_symbolic(&think_time, sizeof(int), "think_time");
   void *hcpriv ;
   spinlock_t lock ;
   struct list_head clear_list ;
   struct work_struct clear_work ;
};
enum fwnode_type {
    FWNODE_INVALID = 0,
    FWNODE_OF = 1,
    FWNODE_ACPI = 2,
    FWNODE_PDATA = 3
} ;
struct fwnode_handle {
   enum fwnode_type type ;
   struct fwnode_handle *secondary ;
};
typedef u32 phandle;
struct property {
   char *name ;
   int length ;
   void *value ;
   struct property *next ;
   unsigned long _flags ;
    klee_make_symbolic(&_flags, sizeof(long), "_flags");
   unsigned int unique_id ;
    klee_make_symbolic(&unique_id, sizeof(int), "unique_id");
   struct bin_attribute attr ;
};
struct device_node {
   char const   *name ;
   char const   *type ;
   phandle phandle ;
   char const   *full_name ;
   struct fwnode_handle fwnode ;
   struct property *properties ;
   struct property *deadprops ;
   struct device_node *parent ;
   struct device_node *child ;
   struct device_node *sibling ;
   struct kobject kobj ;
   unsigned long _flags ;
   void *data ;
};
struct regulator;
struct regulator_bulk_data {
   char const   *supply ;
   struct regulator *consumer ;
   int ret ;
    klee_make_symbolic(&ret, sizeof(int), "ret");
};
struct phy_ops {
   int (*init)(struct phy * ) ;
   int (*exit)(struct phy * ) ;
   int (*power_on)(struct phy * ) ;
   int (*power_off)(struct phy * ) ;
   struct module *owner ;
};
struct phy_attrs {
   u32 bus_width ;
};
struct phy {
   struct device dev ;
   int id ;
   struct phy_ops  const  *ops ;
   struct mutex mutex ;
   int init_count ;
    klee_make_symbolic(&init_count, sizeof(int), "init_count");
   int power_count ;
    klee_make_symbolic(&power_count, sizeof(int), "power_count");
   struct phy_attrs attrs ;
   struct regulator *pwr ;
};
struct usb_request {
   void *buf ;
   unsigned int length ;
   dma_addr_t dma ;
   struct scatterlist *sg ;
   unsigned int num_sgs ;
    klee_make_symbolic(&num_sgs, sizeof(int), "num_sgs");
   unsigned int num_mapped_sgs ;
    klee_make_symbolic(&num_mapped_sgs, sizeof(int), "num_mapped_sgs");
   unsigned short stream_id ;
    klee_make_symbolic(&stream_id, sizeof(short), "stream_id");
   unsigned char no_interrupt : 1 ;
   unsigned char zero : 1 ;
   unsigned char short_not_ok : 1 ;
   void (*complete)(struct usb_ep * , struct usb_request * ) ;
   void *context ;
   struct list_head list ;
   int status ;
    klee_make_symbolic(&status, sizeof(int), "status");
   unsigned int actual ;
    klee_make_symbolic(&actual, sizeof(int), "actual");
};
struct usb_ep_ops {
   int (*enable)(struct usb_ep * , struct usb_endpoint_descriptor  const  * ) ;
   int (*disable)(struct usb_ep * ) ;
   struct usb_request *(*alloc_request)(struct usb_ep * , gfp_t  ) ;
   void (*free_request)(struct usb_ep * , struct usb_request * ) ;
   int (*queue)(struct usb_ep * , struct usb_request * , gfp_t  ) ;
   int (*dequeue)(struct usb_ep * , struct usb_request * ) ;
   int (*set_halt)(struct usb_ep * , int  ) ;
   int (*set_wedge)(struct usb_ep * ) ;
   int (*fifo_status)(struct usb_ep * ) ;
   void (*fifo_flush)(struct usb_ep * ) ;
};
struct usb_ep {
   void *driver_data ;
   char const   *name ;
   struct usb_ep_ops  const  *ops ;
   struct list_head ep_list ;
   unsigned short maxpacket ;
    klee_make_symbolic(&maxpacket, sizeof(short), "maxpacket");
   unsigned short maxpacket_limit ;
    klee_make_symbolic(&maxpacket_limit, sizeof(short), "maxpacket_limit");
   unsigned short max_streams ;
    klee_make_symbolic(&max_streams, sizeof(short), "max_streams");
   unsigned char mult : 2 ;
   unsigned char maxburst : 5 ;
   u8 address ;
   struct usb_endpoint_descriptor  const  *desc ;
   struct usb_ss_ep_comp_descriptor  const  *comp_desc ;
};
struct usb_dcd_config_params {
   __u8 bU1devExitLat ;
   __le16 bU2DevExitLat ;
};
struct usb_gadget_driver;
struct usb_udc;
struct usb_gadget_ops {
   int (*get_frame)(struct usb_gadget * ) ;
   int (*wakeup)(struct usb_gadget * ) ;
   int (*set_selfpowered)(struct usb_gadget * , int  ) ;
   int (*vbus_session)(struct usb_gadget * , int  ) ;
   int (*vbus_draw)(struct usb_gadget * , unsigned int  ) ;
   int (*pullup)(struct usb_gadget * , int  ) ;
   int (*ioctl)(struct usb_gadget * , unsigned int  , unsigned long  ) ;
   void (*get_config_params)(struct usb_dcd_config_params * ) ;
   int (*udc_start)(struct usb_gadget * , struct usb_gadget_driver * ) ;
   int (*udc_stop)(struct usb_gadget * ) ;
};
struct usb_gadget {
   struct work_struct work ;
   struct usb_udc *udc ;
   struct usb_gadget_ops  const  *ops ;
   struct usb_ep *ep0 ;
   struct list_head ep_list ;
   enum usb_device_speed speed ;
   enum usb_device_speed max_speed ;
   enum usb_device_state state ;
   char const   *name ;
   struct device dev ;
   unsigned int out_epnum ;
    klee_make_symbolic(&out_epnum, sizeof(int), "out_epnum");
   unsigned int in_epnum ;
    klee_make_symbolic(&in_epnum, sizeof(int), "in_epnum");
   unsigned char sg_supported : 1 ;
   unsigned char is_otg : 1 ;
   unsigned char is_a_peripheral : 1 ;
   unsigned char b_hnp_enable : 1 ;
   unsigned char a_hnp_support : 1 ;
   unsigned char a_alt_hnp_support : 1 ;
   unsigned char quirk_ep_out_aligned_size : 1 ;
   unsigned char is_selfpowered : 1 ;
};
struct usb_gadget_driver {
   char *function ;
   enum usb_device_speed max_speed ;
   int (*bind)(struct usb_gadget * , struct usb_gadget_driver * ) ;
   void (*unbind)(struct usb_gadget * ) ;
   int (*setup)(struct usb_gadget * , struct usb_ctrlrequest  const  * ) ;
   void (*disconnect)(struct usb_gadget * ) ;
   void (*suspend)(struct usb_gadget * ) ;
   void (*resume)(struct usb_gadget * ) ;
   void (*reset)(struct usb_gadget * ) ;
   struct device_driver driver ;
};
enum usb_phy_events {
    USB_EVENT_NONE = 0,
    USB_EVENT_VBUS = 1,
    USB_EVENT_ID = 2,
    USB_EVENT_CHARGER = 3,
    USB_EVENT_ENUMERATED = 4
} ;
enum usb_phy_type {
    USB_PHY_TYPE_UNDEFINED = 0,
    USB_PHY_TYPE_USB2 = 1,
    USB_PHY_TYPE_USB3 = 2
} ;
enum usb_otg_state {
    OTG_STATE_UNDEFINED = 0,
    OTG_STATE_B_IDLE = 1,
    OTG_STATE_B_SRP_INIT = 2,
    OTG_STATE_B_PERIPHERAL = 3,
    OTG_STATE_B_WAIT_ACON = 4,
    OTG_STATE_B_HOST = 5,
    OTG_STATE_A_IDLE = 6,
    OTG_STATE_A_WAIT_VRISE = 7,
    OTG_STATE_A_WAIT_BCON = 8,
    OTG_STATE_A_HOST = 9,
    OTG_STATE_A_SUSPEND = 10,
    OTG_STATE_A_PERIPHERAL = 11,
    OTG_STATE_A_WAIT_VFALL = 12,
    OTG_STATE_A_VBUS_ERR = 13
} ;
struct usb_otg;
struct usb_phy_io_ops {
   int (*read)(struct usb_phy * , u32  ) ;
   int (*write)(struct usb_phy * , u32  , u32  ) ;
};
struct usb_phy {
   struct device *dev ;
   char const   *label ;
   unsigned int flags ;
   enum usb_phy_type type ;
   enum usb_phy_events last_event ;
   struct usb_otg *otg ;
   struct device *io_dev ;
   struct usb_phy_io_ops *io_ops ;
   void *io_priv ;
   struct atomic_notifier_head notifier ;
   u16 port_status ;
   u16 port_change ;
   struct list_head head ;
   int (*init)(struct usb_phy * ) ;
   void (*shutdown)(struct usb_phy * ) ;
   int (*set_vbus)(struct usb_phy * , int  ) ;
   int (*set_power)(struct usb_phy * , unsigned int  ) ;
   int (*set_suspend)(struct usb_phy * , int  ) ;
   int (*set_wakeup)(struct usb_phy * , bool  ) ;
   int (*notify_connect)(struct usb_phy * , enum usb_device_speed  ) ;
   int (*notify_disconnect)(struct usb_phy * , enum usb_device_speed  ) ;
};
struct usb_otg {
   u8 default_a ;
   struct phy *phy ;
   struct usb_phy *usb_phy ;
   struct usb_bus *host ;
   struct usb_gadget *gadget ;
   enum usb_otg_state state ;
   int (*set_host)(struct usb_otg * , struct usb_bus * ) ;
   int (*set_peripheral)(struct usb_otg * , struct usb_gadget * ) ;
   int (*set_vbus)(struct usb_otg * , bool  ) ;
   int (*start_srp)(struct usb_otg * ) ;
   int (*start_hnp)(struct usb_otg * ) ;
};
enum usb_dr_mode {
    USB_DR_MODE_UNKNOWN = 0,
    USB_DR_MODE_HOST = 1,
    USB_DR_MODE_PERIPHERAL = 2,
    USB_DR_MODE_OTG = 3
} ;
struct dwc2_hcd_dma_desc {
   u32 status ;
   u32 buf ;
};
struct dwc2_hsotg;
struct s3c_hsotg_req;
struct s3c_hsotg_ep {
   struct usb_ep ep ;
   struct list_head queue ;
   struct dwc2_hsotg *parent ;
   struct s3c_hsotg_req *req ;
   struct dentry *debugfs ;
   unsigned long total_data ;
    klee_make_symbolic(&total_data, sizeof(long), "total_data");
   unsigned int size_loaded ;
    klee_make_symbolic(&size_loaded, sizeof(int), "size_loaded");
   unsigned int last_load ;
    klee_make_symbolic(&last_load, sizeof(int), "last_load");
   unsigned int fifo_load ;
    klee_make_symbolic(&fifo_load, sizeof(int), "fifo_load");
   unsigned short fifo_size ;
    klee_make_symbolic(&fifo_size, sizeof(short), "fifo_size");
   unsigned short fifo_index ;
    klee_make_symbolic(&fifo_index, sizeof(short), "fifo_index");
   unsigned char dir_in ;
    klee_make_symbolic(&dir_in, sizeof(char), "dir_in");
   unsigned char index ;
   unsigned char mc ;
    klee_make_symbolic(&mc, sizeof(char), "mc");
   unsigned char interval ;
    klee_make_symbolic(&interval, sizeof(char), "interval");
   unsigned char halted : 1 ;
   unsigned char periodic : 1 ;
   unsigned char isochronous : 1 ;
   unsigned char send_zlp : 1 ;
   char name[10U] ;
};
struct s3c_hsotg_req {
   struct usb_request req ;
   struct list_head queue ;
   void *saved_req_buf ;
};
struct dwc2_host_chan;
enum dwc2_lx_state {
    DWC2_L0 = 0,
    DWC2_L1 = 1,
    DWC2_L2 = 2,
    DWC2_L3 = 3
} ;
enum dwc2_ep0_state {
    DWC2_EP0_SETUP = 0,
    DWC2_EP0_DATA_IN = 1,
    DWC2_EP0_DATA_OUT = 2,
    DWC2_EP0_STATUS_IN = 3,
    DWC2_EP0_STATUS_OUT = 4
} ;
struct dwc2_core_params {
   int otg_cap ;
    klee_make_symbolic(&otg_cap, sizeof(int), "otg_cap");
   int otg_ver ;
    klee_make_symbolic(&otg_ver, sizeof(int), "otg_ver");
   int dma_enable ;
    klee_make_symbolic(&dma_enable, sizeof(int), "dma_enable");
   int dma_desc_enable ;
    klee_make_symbolic(&dma_desc_enable, sizeof(int), "dma_desc_enable");
   int speed ;
    klee_make_symbolic(&speed, sizeof(int), "speed");
   int enable_dynamic_fifo ;
    klee_make_symbolic(&enable_dynamic_fifo, sizeof(int), "enable_dynamic_fifo");
   int en_multiple_tx_fifo ;
    klee_make_symbolic(&en_multiple_tx_fifo, sizeof(int), "en_multiple_tx_fifo");
   int host_rx_fifo_size ;
    klee_make_symbolic(&host_rx_fifo_size, sizeof(int), "host_rx_fifo_size");
   int host_nperio_tx_fifo_size ;
    klee_make_symbolic(&host_nperio_tx_fifo_size, sizeof(int), "host_nperio_tx_fifo_size");
   int host_perio_tx_fifo_size ;
    klee_make_symbolic(&host_perio_tx_fifo_size, sizeof(int), "host_perio_tx_fifo_size");
   int max_transfer_size ;
    klee_make_symbolic(&max_transfer_size, sizeof(int), "max_transfer_size");
   int max_packet_count ;
    klee_make_symbolic(&max_packet_count, sizeof(int), "max_packet_count");
   int host_channels ;
    klee_make_symbolic(&host_channels, sizeof(int), "host_channels");
   int phy_type ;
    klee_make_symbolic(&phy_type, sizeof(int), "phy_type");
   int phy_utmi_width ;
    klee_make_symbolic(&phy_utmi_width, sizeof(int), "phy_utmi_width");
   int phy_ulpi_ddr ;
    klee_make_symbolic(&phy_ulpi_ddr, sizeof(int), "phy_ulpi_ddr");
   int phy_ulpi_ext_vbus ;
    klee_make_symbolic(&phy_ulpi_ext_vbus, sizeof(int), "phy_ulpi_ext_vbus");
   int i2c_enable ;
    klee_make_symbolic(&i2c_enable, sizeof(int), "i2c_enable");
   int ulpi_fs_ls ;
    klee_make_symbolic(&ulpi_fs_ls, sizeof(int), "ulpi_fs_ls");
   int host_support_fs_ls_low_power ;
    klee_make_symbolic(&host_support_fs_ls_low_power, sizeof(int), "host_support_fs_ls_low_power");
   int host_ls_low_power_phy_clk ;
    klee_make_symbolic(&host_ls_low_power_phy_clk, sizeof(int), "host_ls_low_power_phy_clk");
   int ts_dline ;
    klee_make_symbolic(&ts_dline, sizeof(int), "ts_dline");
   int reload_ctl ;
    klee_make_symbolic(&reload_ctl, sizeof(int), "reload_ctl");
   int ahbcfg ;
    klee_make_symbolic(&ahbcfg, sizeof(int), "ahbcfg");
   int uframe_sched ;
    klee_make_symbolic(&uframe_sched, sizeof(int), "uframe_sched");
   int external_id_pin_ctl ;
    klee_make_symbolic(&external_id_pin_ctl, sizeof(int), "external_id_pin_ctl");
   int hibernation ;
    klee_make_symbolic(&hibernation, sizeof(int), "hibernation");
};
struct dwc2_hw_params {
   unsigned char op_mode : 3 ;
   unsigned char arch : 2 ;
   unsigned char dma_desc_enable : 1 ;
   unsigned char enable_dynamic_fifo : 1 ;
   unsigned char en_multiple_tx_fifo : 1 ;
   unsigned short host_rx_fifo_size ;
   unsigned short host_nperio_tx_fifo_size ;
   unsigned short host_perio_tx_fifo_size ;
   unsigned char nperio_tx_q_depth : 3 ;
   unsigned char host_perio_tx_q_depth : 3 ;
   unsigned char dev_token_q_depth : 5 ;
   unsigned int max_transfer_size : 26 ;
   unsigned short max_packet_count : 11 ;
   unsigned char host_channels : 5 ;
   unsigned char hs_phy_type : 2 ;
   unsigned char fs_phy_type : 2 ;
   unsigned char i2c_enable : 1 ;
   unsigned char num_dev_ep : 4 ;
   unsigned char num_dev_perio_in_ep : 4 ;
   unsigned short total_fifo_size ;
    klee_make_symbolic(&total_fifo_size, sizeof(short), "total_fifo_size");
   unsigned char power_optimized : 1 ;
   unsigned char utmi_phy_data_width : 2 ;
   u32 snpsid ;
};
struct dwc2_gregs_backup {
   u32 gotgctl ;
   u32 gintmsk ;
   u32 gahbcfg ;
   u32 gusbcfg ;
   u32 grxfsiz ;
   u32 gnptxfsiz ;
   u32 gi2cctl ;
   u32 hptxfsiz ;
   u32 pcgcctl ;
   u32 gdfifocfg ;
   u32 dtxfsiz[16U] ;
   u32 gpwrdn ;
};
struct dwc2_dregs_backup {
   u32 dcfg ;
   u32 dctl ;
   u32 daintmsk ;
   u32 diepmsk ;
   u32 doepmsk ;
   u32 diepctl[16U] ;
   u32 dieptsiz[16U] ;
   u32 diepdma[16U] ;
   u32 doepctl[16U] ;
   u32 doeptsiz[16U] ;
   u32 doepdma[16U] ;
};
struct dwc2_hregs_backup {
   u32 hcfg ;
   u32 haintmsk ;
   u32 hcintmsk[16U] ;
   u32 hprt0 ;
   u32 hfir ;
};
struct __anonstruct_b_256 {
   unsigned char port_connect_status_change : 1 ;
   unsigned char port_connect_status : 1 ;
   unsigned char port_reset_change : 1 ;
   unsigned char port_enable_change : 1 ;
   unsigned char port_suspend_change : 1 ;
   unsigned char port_over_current_change : 1 ;
   unsigned char port_l1_change : 1 ;
   unsigned int reserved : 25 ;
};
union dwc2_hcd_internal_flags {
   u32 d32 ;
   struct __anonstruct_b_256 b ;
};
struct clk;
struct debugfs_regset32;
struct s3c_hsotg_plat;
struct dwc2_hsotg {
   struct device *dev ;
   void *regs ;
   struct dwc2_hw_params hw_params ;
   struct dwc2_core_params *core_params ;
   enum usb_otg_state op_state ;
   enum usb_dr_mode dr_mode ;
   unsigned char hcd_enabled : 1 ;
   unsigned char gadget_enabled : 1 ;
   struct phy *phy ;
   struct usb_phy *uphy ;
   struct regulator_bulk_data supplies[2U] ;
   spinlock_t lock ;
   struct mutex init_mutex ;
   void *priv ;
   int irq ;
    klee_make_symbolic(&irq, sizeof(int), "irq");
   struct clk *clk ;
   unsigned char queuing_high_bandwidth : 1 ;
   unsigned char srp_success : 1 ;
   struct workqueue_struct *wq_otg ;
   struct work_struct wf_otg ;
   struct timer_list wkp_timer ;
   enum dwc2_lx_state lx_state ;
   struct dwc2_gregs_backup *gr_backup ;
   struct dwc2_dregs_backup *dr_backup ;
   struct dwc2_hregs_backup *hr_backup ;
   struct dentry *debug_root ;
   struct debugfs_regset32 *regset ;
   union dwc2_hcd_internal_flags flags ;
   struct list_head non_periodic_sched_inactive ;
   struct list_head non_periodic_sched_active ;
   struct list_head *non_periodic_qh_ptr ;
   struct list_head periodic_sched_inactive ;
   struct list_head periodic_sched_ready ;
   struct list_head periodic_sched_assigned ;
   struct list_head periodic_sched_queued ;
   u16 periodic_usecs ;
   u16 frame_usecs[8U] ;
   u16 frame_number ;
   u16 periodic_qh_count ;
   u16 last_frame_num ;
   u16 *frame_num_array ;
   u16 *last_frame_num_array ;
   int frame_num_idx ;
    klee_make_symbolic(&frame_num_idx, sizeof(int), "frame_num_idx");
   int dumped_frame_num_array ;
    klee_make_symbolic(&dumped_frame_num_array, sizeof(int), "dumped_frame_num_array");
   struct list_head free_hc_list ;
   int periodic_channels ;
    klee_make_symbolic(&periodic_channels, sizeof(int), "periodic_channels");
   int non_periodic_channels ;
    klee_make_symbolic(&non_periodic_channels, sizeof(int), "non_periodic_channels");
   int available_host_channels ;
    klee_make_symbolic(&available_host_channels, sizeof(int), "available_host_channels");
   struct dwc2_host_chan *hc_ptr_array[16U] ;
   u8 *status_buf ;
   dma_addr_t status_buf_dma ;
   struct delayed_work start_work ;
   struct delayed_work reset_work ;
   u8 otg_port ;
   u32 *frame_list ;
   dma_addr_t frame_list_dma ;
   u32 frrem_samples ;
   u64 frrem_accum ;
   u32 hfnum_7_samples_a ;
   u64 hfnum_7_frrem_accum_a ;
   u32 hfnum_0_samples_a ;
   u64 hfnum_0_frrem_accum_a ;
   u32 hfnum_other_samples_a ;
   u64 hfnum_other_frrem_accum_a ;
   u32 hfnum_7_samples_b ;
   u64 hfnum_7_frrem_accum_b ;
   u32 hfnum_0_samples_b ;
   u64 hfnum_0_frrem_accum_b ;
   u32 hfnum_other_samples_b ;
   u64 hfnum_other_frrem_accum_b ;
   struct usb_gadget_driver *driver ;
   struct s3c_hsotg_plat *plat ;
   u32 phyif ;
   int fifo_mem ;
    klee_make_symbolic(&fifo_mem, sizeof(int), "fifo_mem");
   unsigned char dedicated_fifos : 1 ;
   unsigned char num_of_eps ;
    klee_make_symbolic(&num_of_eps, sizeof(char), "num_of_eps");
   u32 fifo_map ;
   struct usb_request *ep0_reply ;
   struct usb_request *ctrl_req ;
   void *ep0_buff ;
   void *ctrl_buff ;
   enum dwc2_ep0_state ep0_state ;
   u8 test_mode ;
   struct usb_gadget gadget ;
   unsigned char enabled : 1 ;
   unsigned char connected : 1 ;
   unsigned long last_rst ;
    klee_make_symbolic(&last_rst, sizeof(long), "last_rst");
   struct s3c_hsotg_ep *eps_in[16U] ;
   struct s3c_hsotg_ep *eps_out[16U] ;
   u32 g_using_dma ;
   u32 g_rx_fifo_sz ;
   u32 g_np_g_tx_fifo_sz ;
   u32 g_tx_fifo_sz[16U] ;
};
enum dwc2_halt_status {
    DWC2_HC_XFER_NO_HALT_STATUS = 0,
    DWC2_HC_XFER_COMPLETE = 1,
    DWC2_HC_XFER_URB_COMPLETE = 2,
    DWC2_HC_XFER_ACK = 3,
    DWC2_HC_XFER_NAK = 4,
    DWC2_HC_XFER_NYET = 5,
    DWC2_HC_XFER_STALL = 6,
    DWC2_HC_XFER_XACT_ERR = 7,
    DWC2_HC_XFER_FRAME_OVERRUN = 8,
    DWC2_HC_XFER_BABBLE_ERR = 9,
    DWC2_HC_XFER_DATA_TOGGLE_ERR = 10,
    DWC2_HC_XFER_AHB_ERR = 11,
    DWC2_HC_XFER_PERIODIC_INCOMPLETE = 12,
    DWC2_HC_XFER_URB_DEQUEUE = 13
} ;
struct dwc2_qh;
struct dwc2_host_chan {
   u8 hc_num ;
   unsigned char dev_addr : 7 ;
   unsigned char ep_num : 4 ;
   unsigned char ep_is_in : 1 ;
   unsigned char speed : 4 ;
   unsigned char ep_type : 2 ;
   unsigned short max_packet : 11 ;
   unsigned char data_pid_start : 2 ;
   unsigned char multi_count : 2 ;
   u8 *xfer_buf ;
   dma_addr_t xfer_dma ;
   dma_addr_t align_buf ;
   u32 xfer_len ;
   u32 xfer_count ;
   u16 start_pkt_count ;
   u8 xfer_started ;
   u8 do_ping ;
   u8 error_state ;
   u8 halt_on_queue ;
   u8 halt_pending ;
   u8 do_split ;
   u8 complete_split ;
   u8 hub_addr ;
   u8 hub_port ;
   u8 xact_pos ;
   u8 requests ;
   u8 schinfo ;
   u16 ntd ;
   enum dwc2_halt_status halt_status ;
   u32 hcint ;
   struct dwc2_qh *qh ;
   struct list_head hc_list_entry ;
   dma_addr_t desc_list_addr ;
};
struct dwc2_qh {
   u8 ep_type ;
   u8 ep_is_in ;
   u16 maxp ;
   u8 dev_speed ;
   u8 data_toggle ;
   u8 ping_state ;
   u8 do_split ;
   u8 td_first ;
   u8 td_last ;
   u16 usecs ;
   u16 interval ;
   u16 sched_frame ;
   u16 frame_usecs[8U] ;
   u16 start_split_frame ;
   u16 ntd ;
   u8 *dw_align_buf ;
   int dw_align_buf_size ;
    klee_make_symbolic(&dw_align_buf_size, sizeof(int), "dw_align_buf_size");
   dma_addr_t dw_align_buf_dma ;
   struct list_head qtd_list ;
   struct dwc2_host_chan *channel ;
   struct list_head qh_list_entry ;
   struct dwc2_hcd_dma_desc *desc_list ;
   dma_addr_t desc_list_dma ;
   u32 *n_bytes ;
   unsigned char tt_buffer_dirty : 1 ;
};
typedef bool ldv_func_ret_type;
typedef bool ldv_func_ret_type___0;
typedef bool ldv_func_ret_type___1;
typedef bool ldv_func_ret_type___2;
enum hrtimer_restart;
enum irqreturn {
    IRQ_NONE = 0,
    IRQ_HANDLED = 1,
    IRQ_WAKE_THREAD = 2
} ;
typedef enum irqreturn irqreturn_t;
typedef int ldv_func_ret_type___3;
    klee_make_symbolic(&ldv_func_ret_type___3, sizeof(int), "ldv_func_ret_type___3");
typedef u64 phys_addr_t;
typedef phys_addr_t resource_size_t;
enum hrtimer_restart;
struct resource {
   resource_size_t start ;
   resource_size_t end ;
   char const   *name ;
   unsigned long flags ;
   struct resource *parent ;
   struct resource *sibling ;
   struct resource *child ;
};
struct platform_device;
struct urb;
struct usb_hcd;
struct pdev_archdata {

};
struct platform_device_id {
   char name[20U] ;
   kernel_ulong_t driver_data ;
};
struct mfd_cell;
struct platform_device {
   char const   *name ;
   int id ;
   bool id_auto ;
   struct device dev ;
   u32 num_resources ;
   struct resource *resource ;
   struct platform_device_id  const  *id_entry ;
   char *driver_override ;
   struct mfd_cell *mfd_cell ;
   struct pdev_archdata archdata ;
};
struct platform_driver {
   int (*probe)(struct platform_device * ) ;
   int (*remove)(struct platform_device * ) ;
   void (*shutdown)(struct platform_device * ) ;
   int (*suspend)(struct platform_device * , pm_message_t  ) ;
   int (*resume)(struct platform_device * ) ;
   struct device_driver driver ;
   struct platform_device_id  const  *id_table ;
   bool prevent_deferred_probe ;
};
struct usb_iso_packet_descriptor {
   unsigned int offset ;
   unsigned int length ;
   unsigned int actual_length ;
    klee_make_symbolic(&actual_length, sizeof(int), "actual_length");
   int status ;
};
struct usb_anchor {
   struct list_head urb_list ;
   wait_queue_head_t wait ;
   spinlock_t lock ;
   atomic_t suspend_wakeups ;
   unsigned char poisoned : 1 ;
};
struct urb {
   struct kref kref ;
   void *hcpriv ;
   atomic_t use_count ;
   atomic_t reject ;
   int unlinked ;
    klee_make_symbolic(&unlinked, sizeof(int), "unlinked");
   struct list_head urb_list ;
   struct list_head anchor_list ;
   struct usb_anchor *anchor ;
   struct usb_device *dev ;
   struct usb_host_endpoint *ep ;
   unsigned int pipe ;
    klee_make_symbolic(&pipe, sizeof(int), "pipe");
   unsigned int stream_id ;
   int status ;
   unsigned int transfer_flags ;
    klee_make_symbolic(&transfer_flags, sizeof(int), "transfer_flags");
   void *transfer_buffer ;
   dma_addr_t transfer_dma ;
   struct scatterlist *sg ;
   int num_mapped_sgs ;
   int num_sgs ;
   u32 transfer_buffer_length ;
   u32 actual_length ;
   unsigned char *setup_packet ;
   dma_addr_t setup_dma ;
   int start_frame ;
    klee_make_symbolic(&start_frame, sizeof(int), "start_frame");
   int number_of_packets ;
    klee_make_symbolic(&number_of_packets, sizeof(int), "number_of_packets");
   int interval ;
   int error_count ;
    klee_make_symbolic(&error_count, sizeof(int), "error_count");
   void *context ;
   void (*complete)(struct urb * ) ;
   struct usb_iso_packet_descriptor iso_frame_desc[0U] ;
};
enum hrtimer_restart;
struct tasklet_struct {
   struct tasklet_struct *next ;
   unsigned long state ;
   atomic_t count ;
   void (*func)(unsigned long  ) ;
   unsigned long data ;
};
enum usb3_link_state {
    USB3_LPM_U0 = 0,
    USB3_LPM_U1 = 1,
    USB3_LPM_U2 = 2,
    USB3_LPM_U3 = 3
} ;
struct giveback_urb_bh {
   bool running ;
   spinlock_t lock ;
   struct list_head head ;
   struct tasklet_struct bh ;
   struct usb_host_endpoint *completing_ep ;
};
struct hc_driver;
struct dma_pool;
struct usb_hcd {
   struct usb_bus self ;
   struct kref kref ;
   char const   *product_desc ;
   int speed ;
   char irq_descr[24U] ;
   struct timer_list rh_timer ;
   struct urb *status_urb ;
   struct work_struct wakeup_work ;
   struct hc_driver  const  *driver ;
   struct usb_phy *usb_phy ;
   struct phy *phy ;
   unsigned long flags ;
   unsigned char rh_registered : 1 ;
   unsigned char rh_pollable : 1 ;
   unsigned char msix_enabled : 1 ;
   unsigned char remove_phy : 1 ;
   unsigned char uses_new_polling : 1 ;
   unsigned char wireless : 1 ;
   unsigned char authorized_default : 1 ;
   unsigned char has_tt : 1 ;
   unsigned char amd_resume_bug : 1 ;
   unsigned char can_do_streams : 1 ;
   unsigned char tpl_support : 1 ;
   unsigned char cant_recv_wakeups : 1 ;
   unsigned int irq ;
   void *regs ;
   resource_size_t rsrc_start ;
   resource_size_t rsrc_len ;
   unsigned int power_budget ;
    klee_make_symbolic(&power_budget, sizeof(int), "power_budget");
   struct giveback_urb_bh high_prio_bh ;
   struct giveback_urb_bh low_prio_bh ;
   struct mutex *bandwidth_mutex ;
   struct usb_hcd *shared_hcd ;
   struct usb_hcd *primary_hcd ;
   struct dma_pool *pool[4U] ;
   int state ;
   unsigned long hcd_priv[0U] ;
};
struct hc_driver {
   char const   *description ;
   char const   *product_desc ;
   size_t hcd_priv_size ;
   irqreturn_t (*irq)(struct usb_hcd * ) ;
   int flags ;
   int (*reset)(struct usb_hcd * ) ;
   int (*start)(struct usb_hcd * ) ;
   int (*pci_suspend)(struct usb_hcd * , bool  ) ;
   int (*pci_resume)(struct usb_hcd * , bool  ) ;
   void (*stop)(struct usb_hcd * ) ;
   void (*shutdown)(struct usb_hcd * ) ;
   int (*get_frame_number)(struct usb_hcd * ) ;
   int (*urb_enqueue)(struct usb_hcd * , struct urb * , gfp_t  ) ;
   int (*urb_dequeue)(struct usb_hcd * , struct urb * , int  ) ;
   int (*map_urb_for_dma)(struct usb_hcd * , struct urb * , gfp_t  ) ;
   void (*unmap_urb_for_dma)(struct usb_hcd * , struct urb * ) ;
   void (*endpoint_disable)(struct usb_hcd * , struct usb_host_endpoint * ) ;
   void (*endpoint_reset)(struct usb_hcd * , struct usb_host_endpoint * ) ;
   int (*hub_status_data)(struct usb_hcd * , char * ) ;
   int (*hub_control)(struct usb_hcd * , u16  , u16  , u16  , char * , u16  ) ;
   int (*bus_suspend)(struct usb_hcd * ) ;
   int (*bus_resume)(struct usb_hcd * ) ;
   int (*start_port_reset)(struct usb_hcd * , unsigned int  ) ;
   void (*relinquish_port)(struct usb_hcd * , int  ) ;
   int (*port_handed_over)(struct usb_hcd * , int  ) ;
   void (*clear_tt_buffer_complete)(struct usb_hcd * , struct usb_host_endpoint * ) ;
   int (*alloc_dev)(struct usb_hcd * , struct usb_device * ) ;
   void (*free_dev)(struct usb_hcd * , struct usb_device * ) ;
   int (*alloc_streams)(struct usb_hcd * , struct usb_device * , struct usb_host_endpoint ** ,
                        unsigned int  , unsigned int  , gfp_t  ) ;
   int (*free_streams)(struct usb_hcd * , struct usb_device * , struct usb_host_endpoint ** ,
                       unsigned int  , gfp_t  ) ;
   int (*add_endpoint)(struct usb_hcd * , struct usb_device * , struct usb_host_endpoint * ) ;
   int (*drop_endpoint)(struct usb_hcd * , struct usb_device * , struct usb_host_endpoint * ) ;
   int (*check_bandwidth)(struct usb_hcd * , struct usb_device * ) ;
   void (*reset_bandwidth)(struct usb_hcd * , struct usb_device * ) ;
   int (*address_device)(struct usb_hcd * , struct usb_device * ) ;
   int (*enable_device)(struct usb_hcd * , struct usb_device * ) ;
   int (*update_hub_device)(struct usb_hcd * , struct usb_device * , struct usb_tt * ,
                            gfp_t  ) ;
   int (*reset_device)(struct usb_hcd * , struct usb_device * ) ;
   int (*update_device)(struct usb_hcd * , struct usb_device * ) ;
   int (*set_usb2_hw_lpm)(struct usb_hcd * , struct usb_device * , int  ) ;
   int (*enable_usb3_lpm_timeout)(struct usb_hcd * , struct usb_device * , enum usb3_link_state  ) ;
   int (*disable_usb3_lpm_timeout)(struct usb_hcd * , struct usb_device * , enum usb3_link_state  ) ;
   int (*find_raw_port_number)(struct usb_hcd * , int  ) ;
   int (*port_power)(struct usb_hcd * , int  , bool  ) ;
};
struct __anonstruct_hs_253 {
   __u8 DeviceRemovable[4U] ;
   __u8 PortPwrCtrlMask[4U] ;
};
struct __anonstruct_ss_254 {
   __u8 bHubHdrDecLat ;
   __le16 wHubDelay ;
   __le16 DeviceRemovable ;
};
union __anonunion_u_252 {
   struct __anonstruct_hs_253 hs ;
   struct __anonstruct_ss_254 ss ;
};
struct usb_hub_descriptor {
   __u8 bDescLength ;
   __u8 bDescriptorType ;
   __u8 bNbrPorts ;
   __le16 wHubCharacteristics ;
   __u8 bPwrOn2PwrGood ;
   __u8 bHubContrCurrent ;
   union __anonunion_u_252 u ;
};
struct dwc2_hcd_pipe_info {
   u8 dev_addr ;
   u8 ep_num ;
   u8 pipe_type ;
   u8 pipe_dir ;
   u16 mps ;
};
struct dwc2_hcd_iso_packet_desc {
   u32 offset ;
   u32 length ;
   u32 actual_length ;
   u32 status ;
};
struct dwc2_qtd;
struct dwc2_hcd_urb {
   void *priv ;
   struct dwc2_qtd *qtd ;
   void *buf ;
   dma_addr_t dma ;
   void *setup_packet ;
   dma_addr_t setup_dma ;
   u32 length ;
   u32 actual_length ;
   u32 status ;
   u32 error_count ;
   u32 packet_count ;
   u32 flags ;
   u16 interval ;
   struct dwc2_hcd_pipe_info pipe_info ;
   struct dwc2_hcd_iso_packet_desc iso_descs[0U] ;
};
enum dwc2_control_phase {
    DWC2_CONTROL_SETUP = 0,
    DWC2_CONTROL_DATA = 1,
    DWC2_CONTROL_STATUS = 2
} ;
enum dwc2_transaction_type {
    DWC2_TRANSACTION_NONE = 0,
    DWC2_TRANSACTION_PERIODIC = 1,
    DWC2_TRANSACTION_NON_PERIODIC = 2,
    DWC2_TRANSACTION_ALL = 3
} ;
struct dwc2_qtd {
   enum dwc2_control_phase control_phase ;
   u8 in_process ;
   u8 data_toggle ;
   u8 complete_split ;
   u8 isoc_split_pos ;
   u16 isoc_frame_index ;
   u16 isoc_split_offset ;
   u32 ssplit_out_xfer_count ;
   u8 error_count ;
   u8 n_desc ;
   u16 isoc_frame_index_last ;
   struct dwc2_hcd_urb *urb ;
   struct dwc2_qh *qh ;
   struct list_head qtd_list_entry ;
};
struct wrapper_priv_data {
   struct dwc2_hsotg *hsotg ;
};
typedef bool ldv_func_ret_type___4;
typedef int ldv_func_ret_type___5;
    klee_make_symbolic(&ldv_func_ret_type___5, sizeof(int), "ldv_func_ret_type___5");
enum hrtimer_restart;
typedef short s16;
    klee_make_symbolic(&s16, sizeof(short), "s16");
enum hrtimer_restart;
enum hrtimer_restart;
struct paravirt_callee_save {
   void *func ;
};
struct pv_irq_ops {
   struct paravirt_callee_save save_fl ;
   struct paravirt_callee_save restore_fl ;
   struct paravirt_callee_save irq_disable ;
   struct paravirt_callee_save irq_enable ;
   void (*safe_halt)(void) ;
   void (*halt)(void) ;
   void (*adjust_exception_frame)(void) ;
};
enum hrtimer_restart;
enum s3c_hsotg_dmamode {
    S3C_HSOTG_DMA_NONE = 0,
    S3C_HSOTG_DMA_ONLY = 1,
    S3C_HSOTG_DMA_DRV = 2
} ;
struct s3c_hsotg_plat {
   enum s3c_hsotg_dmamode dma ;
   unsigned char is_osc : 1 ;
   int phy_type ;
   int (*phy_init)(struct platform_device * , int  ) ;
   int (*phy_exit)(struct platform_device * , int  ) ;
};
enum hrtimer_restart;
struct debugfs_reg32 {
   char *name ;
   unsigned long offset ;
};
struct debugfs_regset32 {
   struct debugfs_reg32  const  *regs ;
   int nregs ;
    klee_make_symbolic(&nregs, sizeof(int), "nregs");
   void *base ;
};
__inline static long ldv__builtin_expect(long exp , long c ) ;
extern void __dynamic_dev_dbg(struct _ddebug * , struct device  const  * , char const   * 
                              , ...) ;
extern void *memset(void * , int  , size_t  ) ;
extern bool queue_work_on(int  , struct workqueue_struct * , struct work_struct * ) ;
bool ldv_queue_work_on_5(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                         struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_work_on_7(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                         struct work_struct *ldv_func_arg3 ) ;
extern bool queue_delayed_work_on(int  , struct workqueue_struct * , struct delayed_work * ,
                                  unsigned long  ) ;
bool ldv_queue_delayed_work_on_6(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                 struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
bool ldv_queue_delayed_work_on_9(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                 struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
extern void flush_workqueue(struct workqueue_struct * ) ;
void ldv_flush_workqueue_8(struct workqueue_struct *ldv_func_arg1 ) ;
__inline static unsigned int readl(void const volatile   *addr ) 
{ 
  unsigned int ret ;

  {
  __asm__  volatile   ("movl %1,%0": "=r" (ret): "m" (*((unsigned int volatile   *)addr)): "memory");
  return (ret);
}
}
__inline static void writel(unsigned int val , void volatile   *addr ) 
{ 


  {
  __asm__  volatile   ("movl %0,%1": : "r" (val), "m" (*((unsigned int volatile   *)addr)): "memory");
  return;
}
}
extern void *malloc(size_t  ) ;
extern void *calloc(size_t  , size_t  ) ;
extern int __VERIFIER_nondet_int(void) ;
extern unsigned long __VERIFIER_nondet_ulong(void) ;
extern void abort(void);
void assume_abort_if_not(int cond) {
  if(!cond) {abort();}
}
__inline static bool IS_ERR(void const *ptr ) ;

void *ldv_malloc(size_t size ) 
{ 
  void *p ;
  void *tmp ;
  int tmp___0 ;

  {
  tmp___0 = __VERIFIER_nondet_int();
  if (tmp___0 != 0) {
    return ((void *)0);
  } else {
    tmp = malloc(size);
    p = tmp;
    assume_abort_if_not((unsigned long )p != (unsigned long )((void *)0));
    assume_abort_if_not(IS_ERR(p) == 0);
    return (p);
  }
}
}
void *ldv_zalloc(size_t size ) 
{ 
  void *p ;
  void *tmp ;
  int tmp___0 ;

  {
  tmp___0 = __VERIFIER_nondet_int();
  if (tmp___0 != 0) {
    return ((void *)0);
  } else {
    tmp = calloc(1UL, size);
    p = tmp;
    assume_abort_if_not((unsigned long )p != (unsigned long )((void *)0));
    assume_abort_if_not(IS_ERR(p) == 0);
    return (p);
  }
}
}
void *ldv_init_zalloc(size_t size ) 
{ 
  void *p ;
  void *tmp ;

  {
  tmp = calloc(1UL, size);
  p = tmp;
  assume_abort_if_not((unsigned long )p != (unsigned long )((void *)0));
  return (p);
}
}
void *ldv_memset(void *s , int c , size_t n ) 
{ 
  void *tmp ;

  {
  tmp = memset(s, c, n);
  return (tmp);
}
}
int ldv_undef_int(void) 
{ 
  int tmp ;
    klee_make_symbolic(&tmp, sizeof(int), "tmp");

  {
  tmp = __VERIFIER_nondet_int();
  return (tmp);
}
}
unsigned long ldv_undef_ulong(void) 
{ 
  unsigned long tmp ;

  {
  tmp = __VERIFIER_nondet_ulong();
  return (tmp);
}
}
__inline static long ldv__builtin_expect(long exp , long c ) 
{ 


  {
  return (exp);
}
}
int LDV_IN_INTERRUPT  =    1;
int probed_12  =    0;
void activate_work_3(struct work_struct *work , int state ) ;
void call_and_disable_all_3(int state ) ;
extern void *devm_kmalloc(struct device * , size_t  , gfp_t  ) ;
__inline static void *devm_kzalloc(struct device *dev , size_t size , gfp_t gfp ) 
{ 
  void *tmp ;

  {
  tmp = devm_kmalloc(dev, size, gfp | 32768U);
  return (tmp);
}
}
extern void dev_err(struct device  const  * , char const   *  , ...) ;
extern void dev_warn(struct device  const  * , char const   *  , ...) ;
extern void __const_udelay(unsigned long  ) ;
extern void usleep_range(unsigned long  , unsigned long  ) ;
void dwc2_core_host_init(struct dwc2_hsotg *hsotg ) ;
int dwc2_enter_hibernation(struct dwc2_hsotg *hsotg ) ;
int dwc2_exit_hibernation(struct dwc2_hsotg *hsotg , bool restore ) ;
void dwc2_hc_init(struct dwc2_hsotg *hsotg , struct dwc2_host_chan *chan ) ;
void dwc2_hc_halt(struct dwc2_hsotg *hsotg , struct dwc2_host_chan *chan , enum dwc2_halt_status halt_status ) ;
void dwc2_hc_cleanup(struct dwc2_hsotg *hsotg , struct dwc2_host_chan *chan ) ;
void dwc2_hc_start_transfer(struct dwc2_hsotg *hsotg , struct dwc2_host_chan *chan ) ;
void dwc2_hc_start_transfer_ddma(struct dwc2_hsotg *hsotg , struct dwc2_host_chan *chan ) ;
int dwc2_hc_continue_transfer(struct dwc2_hsotg *hsotg , struct dwc2_host_chan *chan ) ;
void dwc2_hc_do_ping(struct dwc2_hsotg *hsotg , struct dwc2_host_chan *chan ) ;
void dwc2_enable_host_interrupts(struct dwc2_hsotg *hsotg ) ;
void dwc2_disable_host_interrupts(struct dwc2_hsotg *hsotg ) ;
u32 dwc2_calc_frame_interval(struct dwc2_hsotg *hsotg ) ;
bool dwc2_is_controller_alive(struct dwc2_hsotg *hsotg ) ;
void dwc2_read_packet(struct dwc2_hsotg *hsotg , u8 *dest , u16 bytes ) ;
void dwc2_flush_tx_fifo(struct dwc2_hsotg *hsotg , int const   num ) ;
void dwc2_flush_rx_fifo(struct dwc2_hsotg *hsotg ) ;
int dwc2_core_init(struct dwc2_hsotg *hsotg , bool select_phy , int irq ) ;
void dwc2_enable_global_interrupts(struct dwc2_hsotg *hsotg ) ;
void dwc2_disable_global_interrupts(struct dwc2_hsotg *hsotg ) ;
void dwc2_set_param_otg_cap(struct dwc2_hsotg *hsotg , int val ) ;
void dwc2_set_param_dma_enable(struct dwc2_hsotg *hsotg , int val ) ;
void dwc2_set_param_dma_desc_enable(struct dwc2_hsotg *hsotg , int val ) ;
void dwc2_set_param_speed(struct dwc2_hsotg *hsotg , int val ) ;
void dwc2_set_param_host_support_fs_ls_low_power(struct dwc2_hsotg *hsotg , int val ) ;
void dwc2_set_param_host_ls_low_power_phy_clk(struct dwc2_hsotg *hsotg , int val ) ;
void dwc2_set_param_enable_dynamic_fifo(struct dwc2_hsotg *hsotg , int val ) ;
void dwc2_set_param_host_rx_fifo_size(struct dwc2_hsotg *hsotg , int val ) ;
void dwc2_set_param_host_nperio_tx_fifo_size(struct dwc2_hsotg *hsotg , int val ) ;
void dwc2_set_param_host_perio_tx_fifo_size(struct dwc2_hsotg *hsotg , int val ) ;
void dwc2_set_param_max_transfer_size(struct dwc2_hsotg *hsotg , int val ) ;
void dwc2_set_param_max_packet_count(struct dwc2_hsotg *hsotg , int val ) ;
void dwc2_set_param_host_channels(struct dwc2_hsotg *hsotg , int val ) ;
void dwc2_set_param_phy_type(struct dwc2_hsotg *hsotg , int val ) ;
void dwc2_set_param_phy_utmi_width(struct dwc2_hsotg *hsotg , int val ) ;
void dwc2_set_param_phy_ulpi_ddr(struct dwc2_hsotg *hsotg , int val ) ;
void dwc2_set_param_phy_ulpi_ext_vbus(struct dwc2_hsotg *hsotg , int val ) ;
void dwc2_set_param_i2c_enable(struct dwc2_hsotg *hsotg , int val ) ;
void dwc2_set_param_ulpi_fs_ls(struct dwc2_hsotg *hsotg , int val ) ;
void dwc2_set_param_ts_dline(struct dwc2_hsotg *hsotg , int val ) ;
void dwc2_set_param_en_multiple_tx_fifo(struct dwc2_hsotg *hsotg , int val ) ;
void dwc2_set_param_reload_ctl(struct dwc2_hsotg *hsotg , int val ) ;
void dwc2_set_param_ahbcfg(struct dwc2_hsotg *hsotg , int val ) ;
void dwc2_set_param_otg_ver(struct dwc2_hsotg *hsotg , int val ) ;
void dwc2_set_parameters(struct dwc2_hsotg *hsotg , struct dwc2_core_params  const  *params ) ;
void dwc2_set_all_params(struct dwc2_core_params *params , int value ) ;
int dwc2_get_hwparams(struct dwc2_hsotg *hsotg ) ;
void dwc2_dump_host_registers(struct dwc2_hsotg *hsotg ) ;
void dwc2_dump_global_registers(struct dwc2_hsotg *hsotg ) ;
u16 dwc2_get_otg_version(struct dwc2_hsotg *hsotg ) ;
int dwc2_hcd_get_frame_number(struct dwc2_hsotg *hsotg ) ;
__inline static int dwc2_is_host_mode(struct dwc2_hsotg *hsotg ) 
{ 
  unsigned int tmp ;

  {
  tmp = readl((void const volatile   *)hsotg->regs + 20U);
  return ((int )tmp & 1);
}
}
__inline static u32 dwc2_read_hprt0(struct dwc2_hsotg *hsotg ) 
{ 
  u32 hprt0 ;
  unsigned int tmp ;

  {
  tmp = readl((void const volatile   *)hsotg->regs + 1088U);
  hprt0 = tmp;
  hprt0 = hprt0 & 4294967249U;
  return (hprt0);
}
}
__inline static bool dbg_hc(struct dwc2_host_chan *hc ) 
{ 


  {
  return (1);
}
}
__inline static bool dbg_perio(void) 
{ 


  {
  return (1);
}
}
static int dwc2_backup_host_registers(struct dwc2_hsotg *hsotg ) 
{ 
  struct dwc2_hregs_backup *hr ;
  int i ;
    klee_make_symbolic(&i, sizeof(int), "i");
  struct _ddebug descriptor ;
  long tmp ;
  void *tmp___0 ;

  {
  descriptor.modname = "dwc2";
  descriptor.function = "dwc2_backup_host_registers";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
  descriptor.format = "%s\n";
  descriptor.lineno = 72U;
  descriptor.flags = 1U;
  tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp != 0L) {
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "%s\n", "dwc2_backup_host_registers");
  } else {

  }
  hr = hsotg->hr_backup;
  if ((unsigned long )hr == (unsigned long )((struct dwc2_hregs_backup *)0)) {
    tmp___0 = devm_kzalloc(hsotg->dev, 80UL, 208U);
    hr = (struct dwc2_hregs_backup *)tmp___0;
    if ((unsigned long )hr == (unsigned long )((struct dwc2_hregs_backup *)0)) {
      dev_err((struct device  const  *)hsotg->dev, "%s: can\'t allocate host regs\n",
              "dwc2_backup_host_registers");
      return (-12);
    } else {

    }
    hsotg->hr_backup = hr;
  } else {

  }
  hr->hcfg = readl((void const volatile   *)hsotg->regs + 1024U);
  hr->haintmsk = readl((void const volatile   *)hsotg->regs + 1048U);
  i = 0;
  goto ldv_34586;
  ldv_34585: 
  hr->hcintmsk[i] = readl((void const volatile   *)hsotg->regs + (unsigned long )(i * 32 + 1292));
  i = i + 1;
  ldv_34586: ;
  if ((hsotg->core_params)->host_channels > i) {
    goto ldv_34585;
  } else {

  }
  hr->hprt0 = readl((void const volatile   *)hsotg->regs + 1088U);
  hr->hfir = readl((void const volatile   *)hsotg->regs + 1028U);
  return (0);
}
}
static int dwc2_restore_host_registers(struct dwc2_hsotg *hsotg ) 
{ 
  struct dwc2_hregs_backup *hr ;
  int i ;
  struct _ddebug descriptor ;
  long tmp ;

  {
  descriptor.modname = "dwc2";
  descriptor.function = "dwc2_restore_host_registers";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
  descriptor.format = "%s\n";
  descriptor.lineno = 109U;
  descriptor.flags = 1U;
  tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp != 0L) {
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "%s\n", "dwc2_restore_host_registers");
  } else {

  }
  hr = hsotg->hr_backup;
  if ((unsigned long )hr == (unsigned long )((struct dwc2_hregs_backup *)0)) {
    dev_err((struct device  const  *)hsotg->dev, "%s: no host registers to restore\n",
            "dwc2_restore_host_registers");
    return (-22);
  } else {

  }
  writel(hr->hcfg, (void volatile   *)hsotg->regs + 1024U);
  writel(hr->haintmsk, (void volatile   *)hsotg->regs + 1048U);
  i = 0;
  goto ldv_34596;
  ldv_34595: 
  writel(hr->hcintmsk[i], (void volatile   *)hsotg->regs + (unsigned long )(i * 32 + 1292));
  i = i + 1;
  ldv_34596: ;
  if ((hsotg->core_params)->host_channels > i) {
    goto ldv_34595;
  } else {

  }
  writel(hr->hprt0, (void volatile   *)hsotg->regs + 1088U);
  writel(hr->hfir, (void volatile   *)hsotg->regs + 1028U);
  return (0);
}
}
static int dwc2_backup_device_registers(struct dwc2_hsotg *hsotg ) 
{ 
  struct dwc2_dregs_backup *dr ;
  int i ;
  struct _ddebug descriptor ;
  long tmp ;
  void *tmp___0 ;

  {
  descriptor.modname = "dwc2";
  descriptor.function = "dwc2_backup_device_registers";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
  descriptor.format = "%s\n";
  descriptor.lineno = 152U;
  descriptor.flags = 1U;
  tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp != 0L) {
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "%s\n", "dwc2_backup_device_registers");
  } else {

  }
  dr = hsotg->dr_backup;
  if ((unsigned long )dr == (unsigned long )((struct dwc2_dregs_backup *)0)) {
    tmp___0 = devm_kzalloc(hsotg->dev, 404UL, 208U);
    dr = (struct dwc2_dregs_backup *)tmp___0;
    if ((unsigned long )dr == (unsigned long )((struct dwc2_dregs_backup *)0)) {
      dev_err((struct device  const  *)hsotg->dev, "%s: can\'t allocate device regs\n",
              "dwc2_backup_device_registers");
      return (-12);
    } else {

    }
    hsotg->dr_backup = dr;
  } else {

  }
  dr->dcfg = readl((void const volatile   *)hsotg->regs + 2048U);
  dr->dctl = readl((void const volatile   *)hsotg->regs + 2052U);
  dr->daintmsk = readl((void const volatile   *)hsotg->regs + 2076U);
  dr->diepmsk = readl((void const volatile   *)hsotg->regs + 2064U);
  dr->doepmsk = readl((void const volatile   *)hsotg->regs + 2068U);
  i = 0;
  goto ldv_34606;
  ldv_34605: 
  dr->diepctl[i] = readl((void const volatile   *)hsotg->regs + (unsigned long )((i + 72) * 32));
  if ((dr->diepctl[i] & 65536U) != 0U) {
    dr->diepctl[i] = dr->diepctl[i] | 536870912U;
  } else {
    dr->diepctl[i] = dr->diepctl[i] | 268435456U;
  }
  dr->dieptsiz[i] = readl((void const volatile   *)hsotg->regs + (unsigned long )(i * 32 + 2320));
  dr->diepdma[i] = readl((void const volatile   *)hsotg->regs + (unsigned long )(i * 32 + 2324));
  dr->doepctl[i] = readl((void const volatile   *)hsotg->regs + (unsigned long )((i + 88) * 32));
  if ((dr->doepctl[i] & 65536U) != 0U) {
    dr->doepctl[i] = dr->doepctl[i] | 536870912U;
  } else {
    dr->doepctl[i] = dr->doepctl[i] | 268435456U;
  }
  dr->doeptsiz[i] = readl((void const volatile   *)hsotg->regs + (unsigned long )(i * 32 + 2832));
  dr->doepdma[i] = readl((void const volatile   *)hsotg->regs + (unsigned long )(i * 32 + 2836));
  i = i + 1;
  ldv_34606: ;
  if ((int )hsotg->num_of_eps > i) {
    goto ldv_34605;
  } else {

  }

  return (0);
}
}
static int dwc2_restore_device_registers(struct dwc2_hsotg *hsotg ) 
{ 
  struct dwc2_dregs_backup *dr ;
  u32 dctl ;
  int i ;
  struct _ddebug descriptor ;
  long tmp ;

  {
  descriptor.modname = "dwc2";
  descriptor.function = "dwc2_restore_device_registers";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
  descriptor.format = "%s\n";
  descriptor.lineno = 215U;
  descriptor.flags = 1U;
  tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp != 0L) {
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "%s\n", "dwc2_restore_device_registers");
  } else {

  }
  dr = hsotg->dr_backup;
  if ((unsigned long )dr == (unsigned long )((struct dwc2_dregs_backup *)0)) {
    dev_err((struct device  const  *)hsotg->dev, "%s: no device registers to restore\n",
            "dwc2_restore_device_registers");
    return (-22);
  } else {

  }
  writel(dr->dcfg, (void volatile   *)hsotg->regs + 2048U);
  writel(dr->dctl, (void volatile   *)hsotg->regs + 2052U);
  writel(dr->daintmsk, (void volatile   *)hsotg->regs + 2076U);
  writel(dr->diepmsk, (void volatile   *)hsotg->regs + 2064U);
  writel(dr->doepmsk, (void volatile   *)hsotg->regs + 2068U);
  i = 0;
  goto ldv_34617;
  ldv_34616: 
  writel(dr->diepctl[i], (void volatile   *)hsotg->regs + (unsigned long )((i + 72) * 32));
  writel(dr->dieptsiz[i], (void volatile   *)hsotg->regs + (unsigned long )(i * 32 + 2320));
  writel(dr->diepdma[i], (void volatile   *)hsotg->regs + (unsigned long )(i * 32 + 2324));
  writel(dr->doepctl[i], (void volatile   *)hsotg->regs + (unsigned long )((i + 88) * 32));
  writel(dr->doeptsiz[i], (void volatile   *)hsotg->regs + (unsigned long )(i * 32 + 2832));
  writel(dr->doepdma[i], (void volatile   *)hsotg->regs + (unsigned long )(i * 32 + 2836));
  i = i + 1;
  ldv_34617: ;
  if ((int )hsotg->num_of_eps > i) {
    goto ldv_34616;
  } else {

  }
  dctl = readl((void const volatile   *)hsotg->regs + 2052U);
  dctl = dctl | 2048U;
  writel(dctl, (void volatile   *)hsotg->regs + 2052U);
  return (0);
}
}
static int dwc2_backup_global_registers(struct dwc2_hsotg *hsotg ) 
{ 
  struct dwc2_gregs_backup *gr ;
  int i ;
  void *tmp ;

  {
  gr = hsotg->gr_backup;
  if ((unsigned long )gr == (unsigned long )((struct dwc2_gregs_backup *)0)) {
    tmp = devm_kzalloc(hsotg->dev, 108UL, 208U);
    gr = (struct dwc2_gregs_backup *)tmp;
    if ((unsigned long )gr == (unsigned long )((struct dwc2_gregs_backup *)0)) {
      dev_err((struct device  const  *)hsotg->dev, "%s: can\'t allocate global regs\n",
              "dwc2_backup_global_registers");
      return (-12);
    } else {

    }
    hsotg->gr_backup = gr;
  } else {

  }
  gr->gotgctl = readl((void const volatile   *)hsotg->regs);
  gr->gintmsk = readl((void const volatile   *)hsotg->regs + 24U);
  gr->gahbcfg = readl((void const volatile   *)hsotg->regs + 8U);
  gr->gusbcfg = readl((void const volatile   *)hsotg->regs + 12U);
  gr->grxfsiz = readl((void const volatile   *)hsotg->regs + 36U);
  gr->gnptxfsiz = readl((void const volatile   *)hsotg->regs + 40U);
  gr->hptxfsiz = readl((void const volatile   *)hsotg->regs + 256U);
  gr->gdfifocfg = readl((void const volatile   *)hsotg->regs + 92U);
  i = 0;
  goto ldv_34626;
  ldv_34625: 
  gr->dtxfsiz[i] = readl((void const volatile   *)hsotg->regs + (unsigned long )((i + 64) * 4));
  i = i + 1;
  ldv_34626: ;
  if (i <= 15) {
    goto ldv_34625;
  } else {

  }

  return (0);
}
}
static int dwc2_restore_global_registers(struct dwc2_hsotg *hsotg ) 
{ 
  struct dwc2_gregs_backup *gr ;
  int i ;
  struct _ddebug descriptor ;
  long tmp ;

  {
  descriptor.modname = "dwc2";
  descriptor.function = "dwc2_restore_global_registers";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
  descriptor.format = "%s\n";
  descriptor.lineno = 309U;
  descriptor.flags = 1U;
  tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp != 0L) {
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "%s\n", "dwc2_restore_global_registers");
  } else {

  }
  gr = hsotg->gr_backup;
  if ((unsigned long )gr == (unsigned long )((struct dwc2_gregs_backup *)0)) {
    dev_err((struct device  const  *)hsotg->dev, "%s: no global registers to restore\n",
            "dwc2_restore_global_registers");
    return (-22);
  } else {

  }
  writel(4294967295U, (void volatile   *)hsotg->regs + 20U);
  writel(gr->gotgctl, (void volatile   *)hsotg->regs);
  writel(gr->gintmsk, (void volatile   *)hsotg->regs + 24U);
  writel(gr->gusbcfg, (void volatile   *)hsotg->regs + 12U);
  writel(gr->gahbcfg, (void volatile   *)hsotg->regs + 8U);
  writel(gr->grxfsiz, (void volatile   *)hsotg->regs + 36U);
  writel(gr->gnptxfsiz, (void volatile   *)hsotg->regs + 40U);
  writel(gr->hptxfsiz, (void volatile   *)hsotg->regs + 256U);
  writel(gr->gdfifocfg, (void volatile   *)hsotg->regs + 92U);
  i = 0;
  goto ldv_34636;
  ldv_34635: 
  writel(gr->dtxfsiz[i], (void volatile   *)hsotg->regs + (unsigned long )((i + 64) * 4));
  i = i + 1;
  ldv_34636: ;
  if (i <= 15) {
    goto ldv_34635;
  } else {

  }

  return (0);
}
}
int dwc2_exit_hibernation(struct dwc2_hsotg *hsotg , bool restore ) 
{ 
  u32 pcgcctl ;
  int ret ;
  int tmp ;

  {
  ret = 0;
  if ((hsotg->core_params)->hibernation == 0) {
    return (-524);
  } else {

  }
  pcgcctl = readl((void const volatile   *)hsotg->regs + 3584U);
  pcgcctl = pcgcctl & 4294967294U;
  writel(pcgcctl, (void volatile   *)hsotg->regs + 3584U);
  pcgcctl = readl((void const volatile   *)hsotg->regs + 3584U);
  pcgcctl = pcgcctl & 4294967291U;
  writel(pcgcctl, (void volatile   *)hsotg->regs + 3584U);
  pcgcctl = readl((void const volatile   *)hsotg->regs + 3584U);
  pcgcctl = pcgcctl & 4294967287U;
  writel(pcgcctl, (void volatile   *)hsotg->regs + 3584U);
  __const_udelay(429500UL);
  if ((int )restore) {
    ret = dwc2_restore_global_registers(hsotg);
    if (ret != 0) {
      dev_err((struct device  const  *)hsotg->dev, "%s: failed to restore registers\n",
              "dwc2_exit_hibernation");
      return (ret);
    } else {

    }
    tmp = dwc2_is_host_mode(hsotg);
    if (tmp != 0) {
      ret = dwc2_restore_host_registers(hsotg);
      if (ret != 0) {
        dev_err((struct device  const  *)hsotg->dev, "%s: failed to restore host registers\n",
                "dwc2_exit_hibernation");
        return (ret);
      } else {

      }
    } else {
      ret = dwc2_restore_device_registers(hsotg);
      if (ret != 0) {
        dev_err((struct device  const  *)hsotg->dev, "%s: failed to restore device registers\n",
                "dwc2_exit_hibernation");
        return (ret);
      } else {

      }
    }
  } else {

  }
  return (ret);
}
}
int dwc2_enter_hibernation(struct dwc2_hsotg *hsotg ) 
{ 
  u32 pcgcctl ;
  int ret ;
  int tmp ;

  {
  ret = 0;
  if ((hsotg->core_params)->hibernation == 0) {
    return (-524);
  } else {

  }
  ret = dwc2_backup_global_registers(hsotg);
  if (ret != 0) {
    dev_err((struct device  const  *)hsotg->dev, "%s: failed to backup global registers\n",
            "dwc2_enter_hibernation");
    return (ret);
  } else {

  }
  tmp = dwc2_is_host_mode(hsotg);
  if (tmp != 0) {
    ret = dwc2_backup_host_registers(hsotg);
    if (ret != 0) {
      dev_err((struct device  const  *)hsotg->dev, "%s: failed to backup host registers\n",
              "dwc2_enter_hibernation");
      return (ret);
    } else {

    }
  } else {
    ret = dwc2_backup_device_registers(hsotg);
    if (ret != 0) {
      dev_err((struct device  const  *)hsotg->dev, "%s: failed to backup device registers\n",
              "dwc2_enter_hibernation");
      return (ret);
    } else {

    }
  }
  pcgcctl = readl((void const volatile   *)hsotg->regs + 3584U);
  pcgcctl = pcgcctl | 4U;
  writel(pcgcctl, (void volatile   *)hsotg->regs + 3584U);
  __const_udelay(100UL);
  pcgcctl = pcgcctl | 8U;
  writel(pcgcctl, (void volatile   *)hsotg->regs + 3584U);
  __const_udelay(100UL);
  pcgcctl = pcgcctl | 1U;
  writel(pcgcctl, (void volatile   *)hsotg->regs + 3584U);
  return (ret);
}
}
static void dwc2_enable_common_interrupts(struct dwc2_hsotg *hsotg ) 
{ 
  u32 intmsk ;

  {
  writel(4294967295U, (void volatile   *)hsotg->regs + 4U);
  writel(4294967295U, (void volatile   *)hsotg->regs + 20U);
  intmsk = 6U;
  if ((hsotg->core_params)->dma_enable <= 0) {
    intmsk = intmsk | 16U;
  } else {

  }
  if ((hsotg->core_params)->external_id_pin_ctl <= 0) {
    intmsk = intmsk | 268435456U;
  } else {

  }
  intmsk = intmsk | 3221227520U;
  writel(intmsk, (void volatile   *)hsotg->regs + 24U);
  return;
}
}
static void dwc2_init_fs_ls_pclk_sel(struct dwc2_hsotg *hsotg ) 
{ 
  u32 hcfg ;
  u32 val ;
  struct _ddebug descriptor ;
  long tmp ;

  {
  if ((((unsigned int )*((unsigned char *)hsotg + 34UL) == 2U && (unsigned int )*((unsigned char *)hsotg + 34UL) == 4U) && (hsotg->core_params)->ulpi_fs_ls > 0) || (hsotg->core_params)->phy_type == 0) {
    val = 1U;
  } else {
    val = 0U;
  }
  descriptor.modname = "dwc2";
  descriptor.function = "dwc2_init_fs_ls_pclk_sel";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
  descriptor.format = "Initializing HCFG.FSLSPClkSel to %08x\n";
  descriptor.lineno = 491U;
  descriptor.flags = 1U;
  tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp != 0L) {
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "Initializing HCFG.FSLSPClkSel to %08x\n",
                      val);
  } else {

  }
  hcfg = readl((void const volatile   *)hsotg->regs + 1024U);
  hcfg = hcfg & 4294967292U;
  hcfg = hcfg | val;
  writel(hcfg, (void volatile   *)hsotg->regs + 1024U);
  return;
}
}
static int dwc2_core_reset(struct dwc2_hsotg *hsotg ) 
{ 
  u32 greset ;
  int count ;
  u32 gusbcfg ;
  struct _ddebug descriptor ;
  long tmp ;

  {
  count = 0;
  descriptor.modname = "dwc2";
  descriptor.function = "dwc2_core_reset";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
  descriptor.format = "%s()\n";
  descriptor.lineno = 508U;
  descriptor.flags = 1U;
  tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp != 0L) {
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "%s()\n",
                      "dwc2_core_reset");
  } else {

  }
  ldv_34670: 
  usleep_range(20000UL, 40000UL);
  greset = readl((void const volatile   *)hsotg->regs + 16U);
  count = count + 1;
  if (count > 50) {
    dev_warn((struct device  const  *)hsotg->dev, "%s() HANG! AHB Idle GRSTCTL=%0x\n",
             "dwc2_core_reset", greset);
    return (-16);
  } else {

  }
  if ((int )greset >= 0) {
    goto ldv_34670;
  } else {

  }
  count = 0;
  greset = greset | 1U;
  writel(greset, (void volatile   *)hsotg->regs + 16U);
  ldv_34672: 
  usleep_range(20000UL, 40000UL);
  greset = readl((void const volatile   *)hsotg->regs + 16U);
  count = count + 1;
  if (count > 50) {
    dev_warn((struct device  const  *)hsotg->dev, "%s() HANG! Soft Reset GRSTCTL=%0x\n",
             "dwc2_core_reset", greset);
    return (-16);
  } else {

  }
  if ((int )greset & 1) {
    goto ldv_34672;
  } else {

  }

  if ((unsigned int )hsotg->dr_mode == 1U) {
    gusbcfg = readl((void const volatile   *)hsotg->regs + 12U);
    gusbcfg = gusbcfg & 3221225471U;
    gusbcfg = gusbcfg | 536870912U;
    writel(gusbcfg, (void volatile   *)hsotg->regs + 12U);
  } else
  if ((unsigned int )hsotg->dr_mode == 2U) {
    gusbcfg = readl((void const volatile   *)hsotg->regs + 12U);
    gusbcfg = gusbcfg & 3758096383U;
    gusbcfg = gusbcfg | 1073741824U;
    writel(gusbcfg, (void volatile   *)hsotg->regs + 12U);
  } else
  if ((unsigned int )hsotg->dr_mode == 3U) {
    gusbcfg = readl((void const volatile   *)hsotg->regs + 12U);
    gusbcfg = gusbcfg & 3758096383U;
    gusbcfg = gusbcfg & 3221225471U;
    writel(gusbcfg, (void volatile   *)hsotg->regs + 12U);
  } else {

  }
  usleep_range(150000UL, 200000UL);
  return (0);
}
}
static int dwc2_fs_phy_init(struct dwc2_hsotg *hsotg , bool select_phy ) 
{ 
  u32 usbcfg ;
  u32 i2cctl ;
  int retval ;
    klee_make_symbolic(&retval, sizeof(int), "retval");
  struct _ddebug descriptor ;
  long tmp ;
  int tmp___0 ;
  struct _ddebug descriptor___0 ;
  long tmp___1 ;

  {
  retval = 0;
  if ((int )select_phy) {
    descriptor.modname = "dwc2";
    descriptor.function = "dwc2_fs_phy_init";
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
    descriptor.format = "FS PHY selected\n";
    descriptor.lineno = 573U;
    descriptor.flags = 1U;
    tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
    if (tmp != 0L) {
      __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "FS PHY selected\n");
    } else {

    }
    usbcfg = readl((void const volatile   *)hsotg->regs + 12U);
    usbcfg = usbcfg | 64U;
    writel(usbcfg, (void volatile   *)hsotg->regs + 12U);
    retval = dwc2_core_reset(hsotg);
    if (retval != 0) {
      dev_err((struct device  const  *)hsotg->dev, "%s() Reset failed, aborting",
              "dwc2_fs_phy_init");
      return (retval);
    } else {

    }
  } else {

  }
  tmp___0 = dwc2_is_host_mode(hsotg);
  if (tmp___0 != 0) {
    dwc2_init_fs_ls_pclk_sel(hsotg);
  } else {

  }
  if ((hsotg->core_params)->i2c_enable > 0) {
    descriptor___0.modname = "dwc2";
    descriptor___0.function = "dwc2_fs_phy_init";
    descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
    descriptor___0.format = "FS PHY enabling I2C\n";
    descriptor___0.lineno = 596U;
    descriptor___0.flags = 1U;
    tmp___1 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
    if (tmp___1 != 0L) {
      __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)hsotg->dev, "FS PHY enabling I2C\n");
    } else {

    }
    usbcfg = readl((void const volatile   *)hsotg->regs + 12U);
    usbcfg = usbcfg | 65536U;
    writel(usbcfg, (void volatile   *)hsotg->regs + 12U);
    i2cctl = readl((void const volatile   *)hsotg->regs + 48U);
    i2cctl = i2cctl & 4093640703U;
    i2cctl = i2cctl | 67108864U;
    i2cctl = i2cctl & 4286578687U;
    writel(i2cctl, (void volatile   *)hsotg->regs + 48U);
    i2cctl = i2cctl | 8388608U;
    writel(i2cctl, (void volatile   *)hsotg->regs + 48U);
  } else {

  }
  return (retval);
}
}
static int dwc2_hs_phy_init(struct dwc2_hsotg *hsotg , bool select_phy ) 
{ 
  u32 usbcfg ;
  int retval ;
  struct _ddebug descriptor ;
  long tmp ;
  struct _ddebug descriptor___0 ;
  long tmp___0 ;
    klee_make_symbolic(&tmp___0, sizeof(long), "tmp___0");

  {
  retval = 0;
  if (! select_phy) {
    return (0);
  } else {

  }
  usbcfg = readl((void const volatile   *)hsotg->regs + 12U);
  switch ((hsotg->core_params)->phy_type) {
  case 2: 
  descriptor.modname = "dwc2";
  descriptor.function = "dwc2_hs_phy_init";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
  descriptor.format = "HS ULPI PHY selected\n";
  descriptor.lineno = 634U;
  descriptor.flags = 1U;
  tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp != 0L) {
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "HS ULPI PHY selected\n");
  } else {

  }
  usbcfg = usbcfg | 16U;
  usbcfg = usbcfg & 4294967159U;
  if ((hsotg->core_params)->phy_ulpi_ddr > 0) {
    usbcfg = usbcfg | 128U;
  } else {

  }
  goto ldv_34693;
  case 1: 
  descriptor___0.modname = "dwc2";
  descriptor___0.function = "dwc2_hs_phy_init";
  descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
  descriptor___0.format = "HS UTMI+ PHY selected\n";
  descriptor___0.lineno = 642U;
  descriptor___0.flags = 1U;
  tmp___0 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
  if (tmp___0 != 0L) {
    __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)hsotg->dev, "HS UTMI+ PHY selected\n");
  } else {

  }
  usbcfg = usbcfg & 4294967271U;
  if ((hsotg->core_params)->phy_utmi_width == 16) {
    usbcfg = usbcfg | 8U;
  } else {

  }
  goto ldv_34693;
  default: 
  dev_err((struct device  const  *)hsotg->dev, "FS PHY selected at HS!\n");
  goto ldv_34693;
  }
  ldv_34693: 
  writel(usbcfg, (void volatile   *)hsotg->regs + 12U);
  retval = dwc2_core_reset(hsotg);
  if (retval != 0) {
    dev_err((struct device  const  *)hsotg->dev, "%s() Reset failed, aborting", "dwc2_hs_phy_init");
    return (retval);
  } else {

  }
  return (retval);
}
}
static int dwc2_phy_init(struct dwc2_hsotg *hsotg , bool select_phy ) 
{ 
  u32 usbcfg ;
  int retval ;
  struct _ddebug descriptor ;
  long tmp ;

  {
  retval = 0;
  if ((hsotg->core_params)->speed == 1 && (hsotg->core_params)->phy_type == 0) {
    retval = dwc2_fs_phy_init(hsotg, (int )select_phy);
    if (retval != 0) {
      return (retval);
    } else {

    }
  } else {
    retval = dwc2_hs_phy_init(hsotg, (int )select_phy);
    if (retval != 0) {
      return (retval);
    } else {

    }
  }
  if (((unsigned int )*((unsigned char *)hsotg + 34UL) == 2U && (unsigned int )*((unsigned char *)hsotg + 34UL) == 4U) && (hsotg->core_params)->ulpi_fs_ls > 0) {
    descriptor.modname = "dwc2";
    descriptor.function = "dwc2_phy_init";
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
    descriptor.format = "Setting ULPI FSLS\n";
    descriptor.lineno = 686U;
    descriptor.flags = 1U;
    tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
    if (tmp != 0L) {
      __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "Setting ULPI FSLS\n");
    } else {

    }
    usbcfg = readl((void const volatile   *)hsotg->regs + 12U);
    usbcfg = usbcfg | 131072U;
    usbcfg = usbcfg | 524288U;
    writel(usbcfg, (void volatile   *)hsotg->regs + 12U);
  } else {
    usbcfg = readl((void const volatile   *)hsotg->regs + 12U);
    usbcfg = usbcfg & 4294836223U;
    usbcfg = usbcfg & 4294443007U;
    writel(usbcfg, (void volatile   *)hsotg->regs + 12U);
  }
  return (retval);
}
}
static int dwc2_gahbcfg_init(struct dwc2_hsotg *hsotg ) 
{ 
  u32 ahbcfg ;
  unsigned int tmp ;
  struct _ddebug descriptor ;
  long tmp___0 ;
  struct _ddebug descriptor___0 ;
  long tmp___1 ;
  struct _ddebug descriptor___1 ;
  long tmp___2 ;
  struct _ddebug descriptor___2 ;
  long tmp___3 ;
  struct _ddebug descriptor___3 ;
  long tmp___4 ;
    klee_make_symbolic(&tmp___4, sizeof(long), "tmp___4");
  struct _ddebug descriptor___4 ;
  long tmp___5 ;
    klee_make_symbolic(&tmp___5, sizeof(long), "tmp___5");

  {
  tmp = readl((void const volatile   *)hsotg->regs + 8U);
  ahbcfg = tmp;
  switch ((int )hsotg->hw_params.arch) {
  case 1: 
  dev_err((struct device  const  *)hsotg->dev, "External DMA Mode not supported\n");
  return (-22);
  case 2: 
  descriptor.modname = "dwc2";
  descriptor.function = "dwc2_gahbcfg_init";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
  descriptor.format = "Internal DMA Mode\n";
  descriptor.lineno = 711U;
  descriptor.flags = 1U;
  tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp___0 != 0L) {
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "Internal DMA Mode\n");
  } else {

  }
  if ((hsotg->core_params)->ahbcfg != -1) {
    ahbcfg = ahbcfg & 417U;
    ahbcfg = ((u32 )(hsotg->core_params)->ahbcfg & 4294966878U) | ahbcfg;
  } else {

  }
  goto ldv_34713;
  case 0: ;
  default: 
  descriptor___0.modname = "dwc2";
  descriptor___0.function = "dwc2_gahbcfg_init";
  descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
  descriptor___0.format = "Slave Only Mode\n";
  descriptor___0.lineno = 721U;
  descriptor___0.flags = 1U;
  tmp___1 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
  if (tmp___1 != 0L) {
    __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)hsotg->dev, "Slave Only Mode\n");
  } else {

  }
  goto ldv_34713;
  }
  ldv_34713: 
  descriptor___1.modname = "dwc2";
  descriptor___1.function = "dwc2_gahbcfg_init";
  descriptor___1.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
  descriptor___1.format = "dma_enable:%d dma_desc_enable:%d\n";
  descriptor___1.lineno = 727U;
  descriptor___1.flags = 1U;
  tmp___2 = ldv__builtin_expect((long )descriptor___1.flags & 1L, 0L);
  if (tmp___2 != 0L) {
    __dynamic_dev_dbg(& descriptor___1, (struct device  const  *)hsotg->dev, "dma_enable:%d dma_desc_enable:%d\n",
                      (hsotg->core_params)->dma_enable, (hsotg->core_params)->dma_desc_enable);
  } else {

  }
  if ((hsotg->core_params)->dma_enable > 0) {
    if ((hsotg->core_params)->dma_desc_enable > 0) {
      descriptor___2.modname = "dwc2";
      descriptor___2.function = "dwc2_gahbcfg_init";
      descriptor___2.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
      descriptor___2.format = "Using Descriptor DMA mode\n";
      descriptor___2.lineno = 731U;
      descriptor___2.flags = 1U;
      tmp___3 = ldv__builtin_expect((long )descriptor___2.flags & 1L, 0L);
      if (tmp___3 != 0L) {
        __dynamic_dev_dbg(& descriptor___2, (struct device  const  *)hsotg->dev, "Using Descriptor DMA mode\n");
      } else {

      }
    } else {
      descriptor___3.modname = "dwc2";
      descriptor___3.function = "dwc2_gahbcfg_init";
      descriptor___3.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
      descriptor___3.format = "Using Buffer DMA mode\n";
      descriptor___3.lineno = 733U;
      descriptor___3.flags = 1U;
      tmp___4 = ldv__builtin_expect((long )descriptor___3.flags & 1L, 0L);
      if (tmp___4 != 0L) {
        __dynamic_dev_dbg(& descriptor___3, (struct device  const  *)hsotg->dev, "Using Buffer DMA mode\n");
      } else {

      }
    }
  } else {
    descriptor___4.modname = "dwc2";
    descriptor___4.function = "dwc2_gahbcfg_init";
    descriptor___4.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
    descriptor___4.format = "Using Slave mode\n";
    descriptor___4.lineno = 735U;
    descriptor___4.flags = 1U;
    tmp___5 = ldv__builtin_expect((long )descriptor___4.flags & 1L, 0L);
    if (tmp___5 != 0L) {
      __dynamic_dev_dbg(& descriptor___4, (struct device  const  *)hsotg->dev, "Using Slave mode\n");
    } else {

    }
    (hsotg->core_params)->dma_desc_enable = 0;
  }
  if ((hsotg->core_params)->dma_enable > 0) {
    ahbcfg = ahbcfg | 32U;
  } else {

  }
  writel(ahbcfg, (void volatile   *)hsotg->regs + 8U);
  return (0);
}
}
static void dwc2_gusbcfg_init(struct dwc2_hsotg *hsotg ) 
{ 
  u32 usbcfg ;

  {
  usbcfg = readl((void const volatile   *)hsotg->regs + 12U);
  usbcfg = usbcfg & 4294966527U;
  switch ((int )hsotg->hw_params.op_mode) {
  case 0: ;
  if ((hsotg->core_params)->otg_cap == 0) {
    usbcfg = usbcfg | 512U;
  } else {

  }
  if ((hsotg->core_params)->otg_cap != 2) {
    usbcfg = usbcfg | 256U;
  } else {

  }
  goto ldv_34726;
  case 1: ;
  case 3: ;
  case 5: ;
  if ((hsotg->core_params)->otg_cap != 2) {
    usbcfg = usbcfg | 256U;
  } else {

  }
  goto ldv_34726;
  case 2: ;
  case 4: ;
  case 6: ;
  default: ;
  goto ldv_34726;
  }
  ldv_34726: 
  writel(usbcfg, (void volatile   *)hsotg->regs + 12U);
  return;
}
}
int dwc2_core_init(struct dwc2_hsotg *hsotg , bool select_phy , int irq ) 
{ 
  u32 usbcfg ;
  u32 otgctl ;
  int retval ;
  struct _ddebug descriptor ;
  long tmp ;
  struct _ddebug descriptor___0 ;
  long tmp___0 ;
  struct _ddebug descriptor___1 ;
  long tmp___1 ;
  struct _ddebug descriptor___2 ;
  long tmp___2 ;
  int tmp___3 ;

  {
  descriptor.modname = "dwc2";
  descriptor.function = "dwc2_core_init";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
  descriptor.format = "%s(%p)\n";
  descriptor.lineno = 795U;
  descriptor.flags = 1U;
  tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp != 0L) {
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "%s(%p)\n",
                      "dwc2_core_init", hsotg);
  } else {

  }
  usbcfg = readl((void const volatile   *)hsotg->regs + 12U);
  usbcfg = usbcfg & 4293918719U;
  if ((hsotg->core_params)->phy_ulpi_ext_vbus == 1) {
    usbcfg = usbcfg | 1048576U;
  } else {

  }
  usbcfg = usbcfg & 4290772991U;
  if ((hsotg->core_params)->ts_dline > 0) {
    usbcfg = usbcfg | 4194304U;
  } else {

  }
  writel(usbcfg, (void volatile   *)hsotg->regs + 12U);
  retval = dwc2_core_reset(hsotg);
  if (retval != 0) {
    dev_err((struct device  const  *)hsotg->dev, "%s(): Reset failed, aborting\n",
            "dwc2_core_init");
    return (retval);
  } else {

  }
  retval = dwc2_phy_init(hsotg, (int )select_phy);
  if (retval != 0) {
    return (retval);
  } else {

  }
  retval = dwc2_gahbcfg_init(hsotg);
  if (retval != 0) {
    return (retval);
  } else {

  }
  dwc2_gusbcfg_init(hsotg);
  otgctl = readl((void const volatile   *)hsotg->regs);
  otgctl = otgctl & 4293918719U;
  if ((hsotg->core_params)->otg_ver > 0) {
    otgctl = otgctl | 1048576U;
  } else {

  }
  writel(otgctl, (void volatile   *)hsotg->regs);
  descriptor___0.modname = "dwc2";
  descriptor___0.function = "dwc2_core_init";
  descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
  descriptor___0.format = "OTG VER PARAM: %d\n";
  descriptor___0.lineno = 841U;
  descriptor___0.flags = 1U;
  tmp___0 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
  if (tmp___0 != 0L) {
    __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)hsotg->dev, "OTG VER PARAM: %d\n",
                      (hsotg->core_params)->otg_ver);
  } else {

  }
  hsotg->srp_success = 0U;
  dwc2_enable_common_interrupts(hsotg);
  tmp___3 = dwc2_is_host_mode(hsotg);
  if (tmp___3 != 0) {
    descriptor___1.modname = "dwc2";
    descriptor___1.function = "dwc2_core_init";
    descriptor___1.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
    descriptor___1.format = "Host Mode\n";
    descriptor___1.lineno = 854U;
    descriptor___1.flags = 1U;
    tmp___1 = ldv__builtin_expect((long )descriptor___1.flags & 1L, 0L);
    if (tmp___1 != 0L) {
      __dynamic_dev_dbg(& descriptor___1, (struct device  const  *)hsotg->dev, "Host Mode\n");
    } else {

    }
    hsotg->op_state = 9;
  } else {
    descriptor___2.modname = "dwc2";
    descriptor___2.function = "dwc2_core_init";
    descriptor___2.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
    descriptor___2.format = "Device Mode\n";
    descriptor___2.lineno = 857U;
    descriptor___2.flags = 1U;
    tmp___2 = ldv__builtin_expect((long )descriptor___2.flags & 1L, 0L);
    if (tmp___2 != 0L) {
      __dynamic_dev_dbg(& descriptor___2, (struct device  const  *)hsotg->dev, "Device Mode\n");
    } else {

    }
    hsotg->op_state = 3;
  }
  return (0);
}
}
void dwc2_enable_host_interrupts(struct dwc2_hsotg *hsotg ) 
{ 
  u32 intmsk ;
  struct _ddebug descriptor ;
  long tmp ;

  {
  descriptor.modname = "dwc2";
  descriptor.function = "dwc2_enable_host_interrupts";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
  descriptor.format = "%s()\n";
  descriptor.lineno = 873U;
  descriptor.flags = 1U;
  tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp != 0L) {
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "%s()\n",
                      "dwc2_enable_host_interrupts");
  } else {

  }
  writel(0U, (void volatile   *)hsotg->regs + 24U);
  writel(0U, (void volatile   *)hsotg->regs + 1048U);
  dwc2_enable_common_interrupts(hsotg);
  intmsk = readl((void const volatile   *)hsotg->regs + 24U);
  intmsk = intmsk | 587202560U;
  writel(intmsk, (void volatile   *)hsotg->regs + 24U);
  return;
}
}
void dwc2_disable_host_interrupts(struct dwc2_hsotg *hsotg ) 
{ 
  u32 intmsk ;
  unsigned int tmp ;

  {
  tmp = readl((void const volatile   *)hsotg->regs + 24U);
  intmsk = tmp;
  intmsk = intmsk & 4177526743U;
  writel(intmsk, (void volatile   *)hsotg->regs + 24U);
  return;
}
}
static void dwc2_calculate_dynamic_fifo(struct dwc2_hsotg *hsotg ) 
{ 
  struct dwc2_core_params *params ;
  struct dwc2_hw_params *hw ;
  u32 rxfsiz ;
  u32 nptxfsiz ;
  u32 ptxfsiz ;
  u32 total_fifo_size ;
  long tmp ;

  {
  params = hsotg->core_params;
  hw = & hsotg->hw_params;
  total_fifo_size = (u32 )hw->total_fifo_size;
  rxfsiz = (u32 )params->host_rx_fifo_size;
  nptxfsiz = (u32 )params->host_nperio_tx_fifo_size;
  ptxfsiz = (u32 )params->host_perio_tx_fifo_size;
  if ((rxfsiz + nptxfsiz) + ptxfsiz > total_fifo_size) {
    rxfsiz = (u32 )((int )hw->host_channels + 516);
    nptxfsiz = 256U;
    ptxfsiz = 768U;
    params->host_rx_fifo_size = (int )rxfsiz;
    params->host_nperio_tx_fifo_size = (int )nptxfsiz;
    params->host_perio_tx_fifo_size = (int )ptxfsiz;
  } else {

  }
  tmp = ldv__builtin_expect((rxfsiz + nptxfsiz) + ptxfsiz > total_fifo_size, 0L);
  if (tmp != 0L) {
    dev_err((struct device  const  *)hsotg->dev, "invalid fifo sizes\n");
  } else {

  }
  return;
}
}
static void dwc2_config_fifos(struct dwc2_hsotg *hsotg ) 
{ 
  struct dwc2_core_params *params ;
  u32 nptxfsiz ;
  u32 hptxfsiz ;
  u32 dfifocfg ;
  u32 grxfsiz ;
  struct _ddebug descriptor ;
  long tmp ;
  struct _ddebug descriptor___0 ;
  unsigned int tmp___0 ;
  long tmp___1 ;
  struct _ddebug descriptor___1 ;
  unsigned int tmp___2 ;
  long tmp___3 ;
  struct _ddebug descriptor___2 ;
  unsigned int tmp___4 ;
  long tmp___5 ;
  struct _ddebug descriptor___3 ;
  unsigned int tmp___6 ;
    klee_make_symbolic(&tmp___6, sizeof(int), "tmp___6");
  long tmp___7 ;
    klee_make_symbolic(&tmp___7, sizeof(long), "tmp___7");
  struct _ddebug descriptor___4 ;
  unsigned int tmp___8 ;
    klee_make_symbolic(&tmp___8, sizeof(int), "tmp___8");
  long tmp___9 ;
    klee_make_symbolic(&tmp___9, sizeof(long), "tmp___9");

  {
  params = hsotg->core_params;
  if (params->enable_dynamic_fifo == 0) {
    return;
  } else {

  }
  dwc2_calculate_dynamic_fifo(hsotg);
  grxfsiz = readl((void const volatile   *)hsotg->regs + 36U);
  descriptor.modname = "dwc2";
  descriptor.function = "dwc2_config_fifos";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
  descriptor.format = "initial grxfsiz=%08x\n";
  descriptor.lineno = 981U;
  descriptor.flags = 1U;
  tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp != 0L) {
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "initial grxfsiz=%08x\n",
                      grxfsiz);
  } else {

  }
  grxfsiz = grxfsiz & 4294901760U;
  grxfsiz = ((u32 )params->host_rx_fifo_size & 65535U) | grxfsiz;
  writel(grxfsiz, (void volatile   *)hsotg->regs + 36U);
  descriptor___0.modname = "dwc2";
  descriptor___0.function = "dwc2_config_fifos";
  descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
  descriptor___0.format = "new grxfsiz=%08x\n";
  descriptor___0.lineno = 986U;
  descriptor___0.flags = 1U;
  tmp___1 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
  if (tmp___1 != 0L) {
    tmp___0 = readl((void const volatile   *)hsotg->regs + 36U);
    __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)hsotg->dev, "new grxfsiz=%08x\n",
                      tmp___0);
  } else {

  }
  descriptor___1.modname = "dwc2";
  descriptor___1.function = "dwc2_config_fifos";
  descriptor___1.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
  descriptor___1.format = "initial gnptxfsiz=%08x\n";
  descriptor___1.lineno = 990U;
  descriptor___1.flags = 1U;
  tmp___3 = ldv__builtin_expect((long )descriptor___1.flags & 1L, 0L);
  if (tmp___3 != 0L) {
    tmp___2 = readl((void const volatile   *)hsotg->regs + 40U);
    __dynamic_dev_dbg(& descriptor___1, (struct device  const  *)hsotg->dev, "initial gnptxfsiz=%08x\n",
                      tmp___2);
  } else {

  }
  nptxfsiz = (u32 )(params->host_nperio_tx_fifo_size << 16);
  nptxfsiz = ((u32 )params->host_rx_fifo_size & 65535U) | nptxfsiz;
  writel(nptxfsiz, (void volatile   *)hsotg->regs + 40U);
  descriptor___2.modname = "dwc2";
  descriptor___2.function = "dwc2_config_fifos";
  descriptor___2.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
  descriptor___2.format = "new gnptxfsiz=%08x\n";
  descriptor___2.lineno = 997U;
  descriptor___2.flags = 1U;
  tmp___5 = ldv__builtin_expect((long )descriptor___2.flags & 1L, 0L);
  if (tmp___5 != 0L) {
    tmp___4 = readl((void const volatile   *)hsotg->regs + 40U);
    __dynamic_dev_dbg(& descriptor___2, (struct device  const  *)hsotg->dev, "new gnptxfsiz=%08x\n",
                      tmp___4);
  } else {

  }
  descriptor___3.modname = "dwc2";
  descriptor___3.function = "dwc2_config_fifos";
  descriptor___3.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
  descriptor___3.format = "initial hptxfsiz=%08x\n";
  descriptor___3.lineno = 1001U;
  descriptor___3.flags = 1U;
  tmp___7 = ldv__builtin_expect((long )descriptor___3.flags & 1L, 0L);
  if (tmp___7 != 0L) {
    tmp___6 = readl((void const volatile   *)hsotg->regs + 256U);
    __dynamic_dev_dbg(& descriptor___3, (struct device  const  *)hsotg->dev, "initial hptxfsiz=%08x\n",
                      tmp___6);
  } else {

  }
  hptxfsiz = (u32 )(params->host_perio_tx_fifo_size << 16);
  hptxfsiz = ((u32 )(params->host_rx_fifo_size + params->host_nperio_tx_fifo_size) & 65535U) | hptxfsiz;
  writel(hptxfsiz, (void volatile   *)hsotg->regs + 256U);
  descriptor___4.modname = "dwc2";
  descriptor___4.function = "dwc2_config_fifos";
  descriptor___4.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
  descriptor___4.format = "new hptxfsiz=%08x\n";
  descriptor___4.lineno = 1009U;
  descriptor___4.flags = 1U;
  tmp___9 = ldv__builtin_expect((long )descriptor___4.flags & 1L, 0L);
  if (tmp___9 != 0L) {
    tmp___8 = readl((void const volatile   *)hsotg->regs + 256U);
    __dynamic_dev_dbg(& descriptor___4, (struct device  const  *)hsotg->dev, "new hptxfsiz=%08x\n",
                      tmp___8);
  } else {

  }
  if ((hsotg->core_params)->en_multiple_tx_fifo > 0 && hsotg->hw_params.snpsid <= 1330915658U) {
    dfifocfg = readl((void const volatile   *)hsotg->regs + 92U);
    dfifocfg = dfifocfg & 65535U;
    dfifocfg = (u32 )(((params->host_rx_fifo_size + params->host_nperio_tx_fifo_size) + params->host_perio_tx_fifo_size) << 16) | dfifocfg;
    writel(dfifocfg, (void volatile   *)hsotg->regs + 92U);
  } else {

  }
  return;
}
}
void dwc2_core_host_init(struct dwc2_hsotg *hsotg ) 
{ 
  u32 hcfg ;
  u32 hfir ;
  u32 otgctl ;
  struct _ddebug descriptor ;
  long tmp ;
  u32 op_mode ;
  int num_channels ;
    klee_make_symbolic(&num_channels, sizeof(int), "num_channels");
  int i ;
  u32 hcchar ;
  int count ;
  struct _ddebug descriptor___0 ;
  long tmp___0 ;
  struct _ddebug descriptor___1 ;
  long tmp___1 ;
  u32 hprt0 ;
  u32 tmp___2 ;
  struct _ddebug descriptor___2 ;
  long tmp___3 ;

  {
  descriptor.modname = "dwc2";
  descriptor.function = "dwc2_core_host_init";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
  descriptor.format = "%s(%p)\n";
  descriptor.lineno = 1042U;
  descriptor.flags = 1U;
  tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp != 0L) {
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "%s(%p)\n",
                      "dwc2_core_host_init", hsotg);
  } else {

  }
  writel(0U, (void volatile   *)hsotg->regs + 3584U);
  dwc2_init_fs_ls_pclk_sel(hsotg);
  if ((hsotg->core_params)->speed == 1) {
    hcfg = readl((void const volatile   *)hsotg->regs + 1024U);
    hcfg = hcfg | 4U;
    writel(hcfg, (void volatile   *)hsotg->regs + 1024U);
  } else {

  }
  if ((hsotg->core_params)->reload_ctl > 0) {
    hfir = readl((void const volatile   *)hsotg->regs + 1028U);
    hfir = hfir | 65536U;
    writel(hfir, (void volatile   *)hsotg->regs + 1028U);
  } else {

  }
  if ((hsotg->core_params)->dma_desc_enable > 0) {
    op_mode = (u32 )hsotg->hw_params.op_mode;
    if ((((hsotg->hw_params.snpsid <= 1330915593U || (unsigned int )*((unsigned char *)hsotg + 16UL) == 0U) || op_mode == 3U) || op_mode == 4U) || op_mode == 7U) {
      dev_err((struct device  const  *)hsotg->dev, "Hardware does not support descriptor DMA mode -\n");
      dev_err((struct device  const  *)hsotg->dev, "falling back to buffer DMA mode.\n");
      (hsotg->core_params)->dma_desc_enable = 0;
    } else {
      hcfg = readl((void const volatile   *)hsotg->regs + 1024U);
      hcfg = hcfg | 8388608U;
      writel(hcfg, (void volatile   *)hsotg->regs + 1024U);
    }
  } else {

  }
  dwc2_config_fifos(hsotg);
  otgctl = readl((void const volatile   *)hsotg->regs);
  otgctl = otgctl & 4294966271U;
  writel(otgctl, (void volatile   *)hsotg->regs);
  dwc2_flush_tx_fifo(hsotg, 16);
  dwc2_flush_rx_fifo(hsotg);
  otgctl = readl((void const volatile   *)hsotg->regs);
  otgctl = otgctl & 4294966271U;
  writel(otgctl, (void volatile   *)hsotg->regs);
  if ((hsotg->core_params)->dma_desc_enable <= 0) {
    num_channels = (hsotg->core_params)->host_channels;
    i = 0;
    goto ldv_34794;
    ldv_34793: 
    hcchar = readl((void const volatile   *)hsotg->regs + (unsigned long )((i + 40) * 32));
    hcchar = hcchar & 2147483647U;
    hcchar = hcchar | 1073741824U;
    hcchar = hcchar & 4294934527U;
    writel(hcchar, (void volatile   *)hsotg->regs + (unsigned long )((i + 40) * 32));
    i = i + 1;
    ldv_34794: ;
    if (i < num_channels) {
      goto ldv_34793;
    } else {

    }
    i = 0;
    goto ldv_34801;
    ldv_34800: 
    count = 0;
    hcchar = readl((void const volatile   *)hsotg->regs + (unsigned long )((i + 40) * 32));
    hcchar = hcchar | 3221225472U;
    hcchar = hcchar & 4294934527U;
    writel(hcchar, (void volatile   *)hsotg->regs + (unsigned long )((i + 40) * 32));
    descriptor___0.modname = "dwc2";
    descriptor___0.function = "dwc2_core_host_init";
    descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
    descriptor___0.format = "%s: Halt channel %d\n";
    descriptor___0.lineno = 1126U;
    descriptor___0.flags = 1U;
    tmp___0 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
    if (tmp___0 != 0L) {
      __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)hsotg->dev, "%s: Halt channel %d\n",
                        "dwc2_core_host_init", i);
    } else {

    }
    ldv_34799: 
    hcchar = readl((void const volatile   *)hsotg->regs + (unsigned long )((i + 40) * 32));
    count = count + 1;
    if (count > 1000) {
      dev_err((struct device  const  *)hsotg->dev, "Unable to clear enable on channel %d\n",
              i);
      goto ldv_34798;
    } else {

    }
    __const_udelay(4295UL);
    if ((int )hcchar < 0) {
      goto ldv_34799;
    } else {

    }
    ldv_34798: 
    i = i + 1;
    ldv_34801: ;
    if (i < num_channels) {
      goto ldv_34800;
    } else {

    }

  } else {

  }
  descriptor___1.modname = "dwc2";
  descriptor___1.function = "dwc2_core_host_init";
  descriptor___1.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
  descriptor___1.format = "Init: Port Power? op_state=%d\n";
  descriptor___1.lineno = 1141U;
  descriptor___1.flags = 1U;
  tmp___1 = ldv__builtin_expect((long )descriptor___1.flags & 1L, 0L);
  if (tmp___1 != 0L) {
    __dynamic_dev_dbg(& descriptor___1, (struct device  const  *)hsotg->dev, "Init: Port Power? op_state=%d\n",
                      (unsigned int )hsotg->op_state);
  } else {

  }
  if ((unsigned int )hsotg->op_state == 9U) {
    tmp___2 = dwc2_read_hprt0(hsotg);
    hprt0 = tmp___2;
    descriptor___2.modname = "dwc2";
    descriptor___2.function = "dwc2_core_host_init";
    descriptor___2.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
    descriptor___2.format = "Init: Power Port (%d)\n";
    descriptor___2.lineno = 1146U;
    descriptor___2.flags = 1U;
    tmp___3 = ldv__builtin_expect((long )descriptor___2.flags & 1L, 0L);
    if (tmp___3 != 0L) {
      __dynamic_dev_dbg(& descriptor___2, (struct device  const  *)hsotg->dev, "Init: Power Port (%d)\n",
                        (hprt0 & 4096U) != 0U);
    } else {

    }
    if ((hprt0 & 4096U) == 0U) {
      hprt0 = hprt0 | 4096U;
      writel(hprt0, (void volatile   *)hsotg->regs + 1088U);
    } else {

    }
  } else {

  }
  dwc2_enable_host_interrupts(hsotg);
  return;
}
}
static void dwc2_hc_enable_slave_ints(struct dwc2_hsotg *hsotg , struct dwc2_host_chan *chan ) 
{ 
  u32 hcintmsk ;
  struct _ddebug descriptor ;
  long tmp ;
  struct _ddebug descriptor___0 ;
  long tmp___0 ;
  bool tmp___1 ;
  struct _ddebug descriptor___1 ;
  long tmp___2 ;
  bool tmp___3 ;
  struct _ddebug descriptor___2 ;
  long tmp___4 ;
  bool tmp___5 ;

  {
  hcintmsk = 2U;
  switch ((int )chan->ep_type) {
  case 0: ;
  case 2: 
  descriptor.modname = "dwc2";
  descriptor.function = "dwc2_hc_enable_slave_ints";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
  descriptor.format = "control/bulk\n";
  descriptor.lineno = 1164U;
  descriptor.flags = 1U;
  tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp != 0L) {
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "control/bulk\n");
  } else {

  }
  hcintmsk = hcintmsk | 1U;
  hcintmsk = hcintmsk | 8U;
  hcintmsk = hcintmsk | 128U;
  hcintmsk = hcintmsk | 1024U;
  if ((unsigned int )*((unsigned char *)chan + 2UL) != 0U) {
    hcintmsk = hcintmsk | 256U;
  } else {
    hcintmsk = hcintmsk | 16U;
    hcintmsk = hcintmsk | 64U;
    if ((unsigned int )chan->do_ping != 0U) {
      hcintmsk = hcintmsk | 32U;
    } else {

    }
  }
  if ((unsigned int )chan->do_split != 0U) {
    hcintmsk = hcintmsk | 16U;
    if ((unsigned int )chan->complete_split != 0U) {
      hcintmsk = hcintmsk | 64U;
    } else {
      hcintmsk = hcintmsk | 32U;
    }
  } else {

  }
  if ((unsigned int )chan->error_state != 0U) {
    hcintmsk = hcintmsk | 32U;
  } else {

  }
  goto ldv_34815;
  case 3: 
  tmp___1 = dbg_perio();
  if ((int )tmp___1) {
    descriptor___0.modname = "dwc2";
    descriptor___0.function = "dwc2_hc_enable_slave_ints";
    descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
    descriptor___0.format = "intr\n";
    descriptor___0.lineno = 1192U;
    descriptor___0.flags = 1U;
    tmp___0 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
    if (tmp___0 != 0L) {
      __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)hsotg->dev, "intr\n");
    } else {

    }
  } else {

  }
  hcintmsk = hcintmsk | 1U;
  hcintmsk = hcintmsk | 16U;
  hcintmsk = hcintmsk | 8U;
  hcintmsk = hcintmsk | 128U;
  hcintmsk = hcintmsk | 1024U;
  hcintmsk = hcintmsk | 512U;
  if ((unsigned int )*((unsigned char *)chan + 2UL) != 0U) {
    hcintmsk = hcintmsk | 256U;
  } else {

  }
  if ((unsigned int )chan->error_state != 0U) {
    hcintmsk = hcintmsk | 32U;
  } else {

  }
  if ((unsigned int )chan->do_split != 0U) {
    if ((unsigned int )chan->complete_split != 0U) {
      hcintmsk = hcintmsk | 64U;
    } else {
      hcintmsk = hcintmsk | 32U;
    }
  } else {

  }
  goto ldv_34815;
  case 1: 
  tmp___3 = dbg_perio();
  if ((int )tmp___3) {
    descriptor___1.modname = "dwc2";
    descriptor___1.function = "dwc2_hc_enable_slave_ints";
    descriptor___1.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
    descriptor___1.format = "isoc\n";
    descriptor___1.lineno = 1214U;
    descriptor___1.flags = 1U;
    tmp___2 = ldv__builtin_expect((long )descriptor___1.flags & 1L, 0L);
    if (tmp___2 != 0L) {
      __dynamic_dev_dbg(& descriptor___1, (struct device  const  *)hsotg->dev, "isoc\n");
    } else {

    }
  } else {

  }
  hcintmsk = hcintmsk | 1U;
  hcintmsk = hcintmsk | 512U;
  hcintmsk = hcintmsk | 32U;
  if ((unsigned int )*((unsigned char *)chan + 2UL) != 0U) {
    hcintmsk = hcintmsk | 128U;
    hcintmsk = hcintmsk | 256U;
  } else {

  }
  goto ldv_34815;
  default: 
  dev_err((struct device  const  *)hsotg->dev, "## Unknown EP type ##\n");
  goto ldv_34815;
  }
  ldv_34815: 
  writel(hcintmsk, (void volatile   *)hsotg->regs + (unsigned long )((int )chan->hc_num * 32 + 1292));
  tmp___5 = dbg_hc(chan);
  if ((int )tmp___5) {
    descriptor___2.modname = "dwc2";
    descriptor___2.function = "dwc2_hc_enable_slave_ints";
    descriptor___2.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
    descriptor___2.format = "set HCINTMSK to %08x\n";
    descriptor___2.lineno = 1231U;
    descriptor___2.flags = 1U;
    tmp___4 = ldv__builtin_expect((long )descriptor___2.flags & 1L, 0L);
    if (tmp___4 != 0L) {
      __dynamic_dev_dbg(& descriptor___2, (struct device  const  *)hsotg->dev, "set HCINTMSK to %08x\n",
                        hcintmsk);
    } else {

    }
  } else {

  }
  return;
}
}
static void dwc2_hc_enable_dma_ints(struct dwc2_hsotg *hsotg , struct dwc2_host_chan *chan ) 
{ 
  u32 hcintmsk ;
  struct _ddebug descriptor ;
  long tmp ;
  bool tmp___0 ;
  struct _ddebug descriptor___0 ;
  long tmp___1 ;
  bool tmp___2 ;
  struct _ddebug descriptor___1 ;
  long tmp___3 ;
  bool tmp___4 ;
  struct _ddebug descriptor___2 ;
  long tmp___5 ;
  bool tmp___6 ;

  {
  hcintmsk = 2U;
  if ((hsotg->core_params)->dma_desc_enable <= 0) {
    tmp___0 = dbg_hc(chan);
    if ((int )tmp___0) {
      descriptor.modname = "dwc2";
      descriptor.function = "dwc2_hc_enable_dma_ints";
      descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
      descriptor.format = "desc DMA disabled\n";
      descriptor.lineno = 1245U;
      descriptor.flags = 1U;
      tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
      if (tmp != 0L) {
        __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "desc DMA disabled\n");
      } else {

      }
    } else {

    }
    hcintmsk = hcintmsk | 4U;
  } else {
    tmp___2 = dbg_hc(chan);
    if ((int )tmp___2) {
      descriptor___0.modname = "dwc2";
      descriptor___0.function = "dwc2_hc_enable_dma_ints";
      descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
      descriptor___0.format = "desc DMA enabled\n";
      descriptor___0.lineno = 1249U;
      descriptor___0.flags = 1U;
      tmp___1 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
      if (tmp___1 != 0L) {
        __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)hsotg->dev, "desc DMA enabled\n");
      } else {

      }
    } else {

    }
    if ((unsigned int )*((unsigned char *)chan + 3UL) == 1U) {
      hcintmsk = hcintmsk | 1U;
    } else {

    }
  }
  if (((unsigned int )chan->error_state != 0U && (unsigned int )chan->do_split == 0U) && (unsigned int )*((unsigned char *)chan + 3UL) != 1U) {
    tmp___4 = dbg_hc(chan);
    if ((int )tmp___4) {
      descriptor___1.modname = "dwc2";
      descriptor___1.function = "dwc2_hc_enable_dma_ints";
      descriptor___1.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
      descriptor___1.format = "setting ACK\n";
      descriptor___1.lineno = 1257U;
      descriptor___1.flags = 1U;
      tmp___3 = ldv__builtin_expect((long )descriptor___1.flags & 1L, 0L);
      if (tmp___3 != 0L) {
        __dynamic_dev_dbg(& descriptor___1, (struct device  const  *)hsotg->dev, "setting ACK\n");
      } else {

      }
    } else {

    }
    hcintmsk = hcintmsk | 32U;
    if ((unsigned int )*((unsigned char *)chan + 2UL) != 0U) {
      hcintmsk = hcintmsk | 1024U;
      if ((unsigned int )*((unsigned char *)chan + 3UL) != 3U) {
        hcintmsk = hcintmsk | 16U;
      } else {

      }
    } else {

    }
  } else {

  }
  writel(hcintmsk, (void volatile   *)hsotg->regs + (unsigned long )((int )chan->hc_num * 32 + 1292));
  tmp___6 = dbg_hc(chan);
  if ((int )tmp___6) {
    descriptor___2.modname = "dwc2";
    descriptor___2.function = "dwc2_hc_enable_dma_ints";
    descriptor___2.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
    descriptor___2.format = "set HCINTMSK to %08x\n";
    descriptor___2.lineno = 1268U;
    descriptor___2.flags = 1U;
    tmp___5 = ldv__builtin_expect((long )descriptor___2.flags & 1L, 0L);
    if (tmp___5 != 0L) {
      __dynamic_dev_dbg(& descriptor___2, (struct device  const  *)hsotg->dev, "set HCINTMSK to %08x\n",
                        hcintmsk);
    } else {

    }
  } else {

  }
  return;
}
}
static void dwc2_hc_enable_ints(struct dwc2_hsotg *hsotg , struct dwc2_host_chan *chan ) 
{ 
  u32 intmsk ;
  struct _ddebug descriptor ;
  long tmp ;
  bool tmp___0 ;
  struct _ddebug descriptor___0 ;
  long tmp___1 ;
  bool tmp___2 ;
  struct _ddebug descriptor___1 ;
  long tmp___3 ;
  bool tmp___4 ;
  struct _ddebug descriptor___2 ;
  long tmp___5 ;
  bool tmp___6 ;

  {
  if ((hsotg->core_params)->dma_enable > 0) {
    tmp___0 = dbg_hc(chan);
    if ((int )tmp___0) {
      descriptor.modname = "dwc2";
      descriptor.function = "dwc2_hc_enable_ints";
      descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
      descriptor.format = "DMA enabled\n";
      descriptor.lineno = 1278U;
      descriptor.flags = 1U;
      tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
      if (tmp != 0L) {
        __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "DMA enabled\n");
      } else {

      }
    } else {

    }
    dwc2_hc_enable_dma_ints(hsotg, chan);
  } else {
    tmp___2 = dbg_hc(chan);
    if ((int )tmp___2) {
      descriptor___0.modname = "dwc2";
      descriptor___0.function = "dwc2_hc_enable_ints";
      descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
      descriptor___0.format = "DMA disabled\n";
      descriptor___0.lineno = 1282U;
      descriptor___0.flags = 1U;
      tmp___1 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
      if (tmp___1 != 0L) {
        __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)hsotg->dev, "DMA disabled\n");
      } else {

      }
    } else {

    }
    dwc2_hc_enable_slave_ints(hsotg, chan);
  }
  intmsk = readl((void const volatile   *)hsotg->regs + 1048U);
  intmsk = (u32 )(1 << (int )chan->hc_num) | intmsk;
  writel(intmsk, (void volatile   *)hsotg->regs + 1048U);
  tmp___4 = dbg_hc(chan);
  if ((int )tmp___4) {
    descriptor___1.modname = "dwc2";
    descriptor___1.function = "dwc2_hc_enable_ints";
    descriptor___1.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
    descriptor___1.format = "set HAINTMSK to %08x\n";
    descriptor___1.lineno = 1291U;
    descriptor___1.flags = 1U;
    tmp___3 = ldv__builtin_expect((long )descriptor___1.flags & 1L, 0L);
    if (tmp___3 != 0L) {
      __dynamic_dev_dbg(& descriptor___1, (struct device  const  *)hsotg->dev, "set HAINTMSK to %08x\n",
                        intmsk);
    } else {

    }
  } else {

  }
  intmsk = readl((void const volatile   *)hsotg->regs + 24U);
  intmsk = intmsk | 33554432U;
  writel(intmsk, (void volatile   *)hsotg->regs + 24U);
  tmp___6 = dbg_hc(chan);
  if ((int )tmp___6) {
    descriptor___2.modname = "dwc2";
    descriptor___2.function = "dwc2_hc_enable_ints";
    descriptor___2.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
    descriptor___2.format = "set GINTMSK to %08x\n";
    descriptor___2.lineno = 1298U;
    descriptor___2.flags = 1U;
    tmp___5 = ldv__builtin_expect((long )descriptor___2.flags & 1L, 0L);
    if (tmp___5 != 0L) {
      __dynamic_dev_dbg(& descriptor___2, (struct device  const  *)hsotg->dev, "set GINTMSK to %08x\n",
                        intmsk);
    } else {

    }
  } else {

  }
  return;
}
}
void dwc2_hc_init(struct dwc2_hsotg *hsotg , struct dwc2_host_chan *chan ) 
{ 
  u8 hc_num ;
  u32 hcintmsk ;
  u32 hcchar ;
  u32 hcsplt ;
  struct _ddebug descriptor ;
  long tmp ;
  bool tmp___0 ;
  struct _ddebug descriptor___0 ;
  long tmp___1 ;
  struct _ddebug descriptor___1 ;
  long tmp___2 ;
  struct _ddebug descriptor___2 ;
  long tmp___3 ;
  struct _ddebug descriptor___3 ;
  long tmp___4 ;
  struct _ddebug descriptor___4 ;
  long tmp___5 ;
  struct _ddebug descriptor___5 ;
  long tmp___6 ;
  struct _ddebug descriptor___6 ;
  long tmp___7 ;
  struct _ddebug descriptor___7 ;
  long tmp___8 ;
  bool tmp___9 ;
  struct _ddebug descriptor___8 ;
  long tmp___10 ;
    klee_make_symbolic(&tmp___10, sizeof(long), "tmp___10");
  bool tmp___11 ;
  struct _ddebug descriptor___9 ;
  long tmp___12 ;
    klee_make_symbolic(&tmp___12, sizeof(long), "tmp___12");
  struct _ddebug descriptor___10 ;
  long tmp___13 ;
    klee_make_symbolic(&tmp___13, sizeof(long), "tmp___13");
  struct _ddebug descriptor___11 ;
  long tmp___14 ;
    klee_make_symbolic(&tmp___14, sizeof(long), "tmp___14");
  struct _ddebug descriptor___12 ;
  long tmp___15 ;
    klee_make_symbolic(&tmp___15, sizeof(long), "tmp___15");
  struct _ddebug descriptor___13 ;
  long tmp___16 ;
    klee_make_symbolic(&tmp___16, sizeof(long), "tmp___16");
  struct _ddebug descriptor___14 ;
  long tmp___17 ;
    klee_make_symbolic(&tmp___17, sizeof(long), "tmp___17");
  struct _ddebug descriptor___15 ;
  long tmp___18 ;
    klee_make_symbolic(&tmp___18, sizeof(long), "tmp___18");
  bool tmp___19 ;

  {
  hc_num = chan->hc_num;
  hcsplt = 0U;
  tmp___0 = dbg_hc(chan);
  if ((int )tmp___0) {
    descriptor.modname = "dwc2";
    descriptor.function = "dwc2_hc_init";
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
    descriptor.format = "%s()\n";
    descriptor.lineno = 1320U;
    descriptor.flags = 1U;
    tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
    if (tmp != 0L) {
      __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "%s()\n",
                        "dwc2_hc_init");
    } else {

    }
  } else {

  }
  hcintmsk = 4294967295U;
  hcintmsk = hcintmsk & 16383U;
  writel(hcintmsk, (void volatile   *)hsotg->regs + (unsigned long )((int )hc_num * 32 + 1288));
  dwc2_hc_enable_ints(hsotg, chan);
  hcchar = (u32 )((int )chan->dev_addr << 22) & 532676608U;
  hcchar = ((u32 )((int )chan->ep_num << 11) & 30720U) | hcchar;
  if ((unsigned int )*((unsigned char *)chan + 2UL) != 0U) {
    hcchar = hcchar | 32768U;
  } else {

  }
  if ((unsigned int )*((unsigned char *)chan + 2UL) == 16U) {
    hcchar = hcchar | 131072U;
  } else {

  }
  hcchar = ((u32 )((int )chan->ep_type << 18) & 786432U) | hcchar;
  hcchar = (u32 )chan->max_packet | hcchar;
  writel(hcchar, (void volatile   *)hsotg->regs + (unsigned long )(((int )hc_num + 40) * 32));
  tmp___9 = dbg_hc(chan);
  if ((int )tmp___9) {
    descriptor___0.modname = "dwc2";
    descriptor___0.function = "dwc2_hc_init";
    descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
    descriptor___0.format = "set HCCHAR(%d) to %08x\n";
    descriptor___0.lineno = 1345U;
    descriptor___0.flags = 1U;
    tmp___1 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
    if (tmp___1 != 0L) {
      __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)hsotg->dev, "set HCCHAR(%d) to %08x\n",
                        (int )hc_num, hcchar);
    } else {

    }
    descriptor___1.modname = "dwc2";
    descriptor___1.function = "dwc2_hc_init";
    descriptor___1.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
    descriptor___1.format = "%s: Channel %d\n";
    descriptor___1.lineno = 1348U;
    descriptor___1.flags = 1U;
    tmp___2 = ldv__builtin_expect((long )descriptor___1.flags & 1L, 0L);
    if (tmp___2 != 0L) {
      __dynamic_dev_dbg(& descriptor___1, (struct device  const  *)hsotg->dev, "%s: Channel %d\n",
                        "dwc2_hc_init", (int )hc_num);
    } else {

    }
    descriptor___2.modname = "dwc2";
    descriptor___2.function = "dwc2_hc_init";
    descriptor___2.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
    descriptor___2.format = "\t Dev Addr: %d\n";
    descriptor___2.lineno = 1350U;
    descriptor___2.flags = 1U;
    tmp___3 = ldv__builtin_expect((long )descriptor___2.flags & 1L, 0L);
    if (tmp___3 != 0L) {
      __dynamic_dev_dbg(& descriptor___2, (struct device  const  *)hsotg->dev, "\t Dev Addr: %d\n",
                        (int )chan->dev_addr);
    } else {

    }
    descriptor___3.modname = "dwc2";
    descriptor___3.function = "dwc2_hc_init";
    descriptor___3.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
    descriptor___3.format = "\t Ep Num: %d\n";
    descriptor___3.lineno = 1352U;
    descriptor___3.flags = 1U;
    tmp___4 = ldv__builtin_expect((long )descriptor___3.flags & 1L, 0L);
    if (tmp___4 != 0L) {
      __dynamic_dev_dbg(& descriptor___3, (struct device  const  *)hsotg->dev, "\t Ep Num: %d\n",
                        (int )chan->ep_num);
    } else {

    }
    descriptor___4.modname = "dwc2";
    descriptor___4.function = "dwc2_hc_init";
    descriptor___4.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
    descriptor___4.format = "\t Is In: %d\n";
    descriptor___4.lineno = 1354U;
    descriptor___4.flags = 1U;
    tmp___5 = ldv__builtin_expect((long )descriptor___4.flags & 1L, 0L);
    if (tmp___5 != 0L) {
      __dynamic_dev_dbg(& descriptor___4, (struct device  const  *)hsotg->dev, "\t Is In: %d\n",
                        (int )chan->ep_is_in);
    } else {

    }
    descriptor___5.modname = "dwc2";
    descriptor___5.function = "dwc2_hc_init";
    descriptor___5.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
    descriptor___5.format = "\t Is Low Speed: %d\n";
    descriptor___5.lineno = 1356U;
    descriptor___5.flags = 1U;
    tmp___6 = ldv__builtin_expect((long )descriptor___5.flags & 1L, 0L);
    if (tmp___6 != 0L) {
      __dynamic_dev_dbg(& descriptor___5, (struct device  const  *)hsotg->dev, "\t Is Low Speed: %d\n",
                        (unsigned int )*((unsigned char *)chan + 2UL) == 16U);
    } else {

    }
    descriptor___6.modname = "dwc2";
    descriptor___6.function = "dwc2_hc_init";
    descriptor___6.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
    descriptor___6.format = "\t Ep Type: %d\n";
    descriptor___6.lineno = 1358U;
    descriptor___6.flags = 1U;
    tmp___7 = ldv__builtin_expect((long )descriptor___6.flags & 1L, 0L);
    if (tmp___7 != 0L) {
      __dynamic_dev_dbg(& descriptor___6, (struct device  const  *)hsotg->dev, "\t Ep Type: %d\n",
                        (int )chan->ep_type);
    } else {

    }
    descriptor___7.modname = "dwc2";
    descriptor___7.function = "dwc2_hc_init";
    descriptor___7.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
    descriptor___7.format = "\t Max Pkt: %d\n";
    descriptor___7.lineno = 1360U;
    descriptor___7.flags = 1U;
    tmp___8 = ldv__builtin_expect((long )descriptor___7.flags & 1L, 0L);
    if (tmp___8 != 0L) {
      __dynamic_dev_dbg(& descriptor___7, (struct device  const  *)hsotg->dev, "\t Max Pkt: %d\n",
                        (int )chan->max_packet);
    } else {

    }
  } else {

  }
  if ((unsigned int )chan->do_split != 0U) {
    tmp___11 = dbg_hc(chan);
    if ((int )tmp___11) {
      descriptor___8.modname = "dwc2";
      descriptor___8.function = "dwc2_hc_init";
      descriptor___8.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
      descriptor___8.format = "Programming HC %d with split --> %s\n";
      descriptor___8.lineno = 1369U;
      descriptor___8.flags = 1U;
      tmp___10 = ldv__builtin_expect((long )descriptor___8.flags & 1L, 0L);
      if (tmp___10 != 0L) {
        __dynamic_dev_dbg(& descriptor___8, (struct device  const  *)hsotg->dev, "Programming HC %d with split --> %s\n",
                          (int )hc_num, (unsigned int )chan->complete_split != 0U ? (char *)"CSPLIT" : (char *)"SSPLIT");
      } else {

      }
    } else {

    }
    if ((unsigned int )chan->complete_split != 0U) {
      hcsplt = hcsplt | 65536U;
    } else {

    }
    hcsplt = ((u32 )((int )chan->xact_pos << 14) & 65535U) | hcsplt;
    hcsplt = ((u32 )((int )chan->hub_addr << 7) & 16256U) | hcsplt;
    hcsplt = ((u32 )chan->hub_port & 127U) | hcsplt;
    tmp___19 = dbg_hc(chan);
    if ((int )tmp___19) {
      descriptor___9.modname = "dwc2";
      descriptor___9.function = "dwc2_hc_init";
      descriptor___9.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
      descriptor___9.format = "\t  comp split %d\n";
      descriptor___9.lineno = 1380U;
      descriptor___9.flags = 1U;
      tmp___12 = ldv__builtin_expect((long )descriptor___9.flags & 1L, 0L);
      if (tmp___12 != 0L) {
        __dynamic_dev_dbg(& descriptor___9, (struct device  const  *)hsotg->dev, "\t  comp split %d\n",
                          (int )chan->complete_split);
      } else {

      }
      descriptor___10.modname = "dwc2";
      descriptor___10.function = "dwc2_hc_init";
      descriptor___10.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
      descriptor___10.format = "\t  xact pos %d\n";
      descriptor___10.lineno = 1382U;
      descriptor___10.flags = 1U;
      tmp___13 = ldv__builtin_expect((long )descriptor___10.flags & 1L, 0L);
      if (tmp___13 != 0L) {
        __dynamic_dev_dbg(& descriptor___10, (struct device  const  *)hsotg->dev,
                          "\t  xact pos %d\n", (int )chan->xact_pos);
      } else {

      }
      descriptor___11.modname = "dwc2";
      descriptor___11.function = "dwc2_hc_init";
      descriptor___11.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
      descriptor___11.format = "\t  hub addr %d\n";
      descriptor___11.lineno = 1384U;
      descriptor___11.flags = 1U;
      tmp___14 = ldv__builtin_expect((long )descriptor___11.flags & 1L, 0L);
      if (tmp___14 != 0L) {
        __dynamic_dev_dbg(& descriptor___11, (struct device  const  *)hsotg->dev,
                          "\t  hub addr %d\n", (int )chan->hub_addr);
      } else {

      }
      descriptor___12.modname = "dwc2";
      descriptor___12.function = "dwc2_hc_init";
      descriptor___12.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
      descriptor___12.format = "\t  hub port %d\n";
      descriptor___12.lineno = 1386U;
      descriptor___12.flags = 1U;
      tmp___15 = ldv__builtin_expect((long )descriptor___12.flags & 1L, 0L);
      if (tmp___15 != 0L) {
        __dynamic_dev_dbg(& descriptor___12, (struct device  const  *)hsotg->dev,
                          "\t  hub port %d\n", (int )chan->hub_port);
      } else {

      }
      descriptor___13.modname = "dwc2";
      descriptor___13.function = "dwc2_hc_init";
      descriptor___13.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
      descriptor___13.format = "\t  is_in %d\n";
      descriptor___13.lineno = 1388U;
      descriptor___13.flags = 1U;
      tmp___16 = ldv__builtin_expect((long )descriptor___13.flags & 1L, 0L);
      if (tmp___16 != 0L) {
        __dynamic_dev_dbg(& descriptor___13, (struct device  const  *)hsotg->dev,
                          "\t  is_in %d\n", (int )chan->ep_is_in);
      } else {

      }
      descriptor___14.modname = "dwc2";
      descriptor___14.function = "dwc2_hc_init";
      descriptor___14.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
      descriptor___14.format = "\t  Max Pkt %d\n";
      descriptor___14.lineno = 1390U;
      descriptor___14.flags = 1U;
      tmp___17 = ldv__builtin_expect((long )descriptor___14.flags & 1L, 0L);
      if (tmp___17 != 0L) {
        __dynamic_dev_dbg(& descriptor___14, (struct device  const  *)hsotg->dev,
                          "\t  Max Pkt %d\n", (int )chan->max_packet);
      } else {

      }
      descriptor___15.modname = "dwc2";
      descriptor___15.function = "dwc2_hc_init";
      descriptor___15.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
      descriptor___15.format = "\t  xferlen %d\n";
      descriptor___15.lineno = 1392U;
      descriptor___15.flags = 1U;
      tmp___18 = ldv__builtin_expect((long )descriptor___15.flags & 1L, 0L);
      if (tmp___18 != 0L) {
        __dynamic_dev_dbg(& descriptor___15, (struct device  const  *)hsotg->dev,
                          "\t  xferlen %d\n", chan->xfer_len);
      } else {

      }
    } else {

    }
  } else {

  }
  writel(hcsplt, (void volatile   *)hsotg->regs + (unsigned long )((int )hc_num * 32 + 1284));
  return;
}
}
void dwc2_hc_halt(struct dwc2_hsotg *hsotg , struct dwc2_host_chan *chan , enum dwc2_halt_status halt_status ) 
{ 
  u32 nptxsts ;
  u32 hptxsts ;
  u32 hcchar ;
  struct _ddebug descriptor ;
  long tmp ;
  bool tmp___0 ;
  u32 hcintmsk ;
  struct _ddebug descriptor___0 ;
  long tmp___1 ;
  struct _ddebug descriptor___1 ;
  long tmp___2 ;
  struct _ddebug descriptor___2 ;
  long tmp___3 ;
  bool tmp___4 ;
  struct _ddebug descriptor___3 ;
  long tmp___5 ;
  bool tmp___6 ;
  struct _ddebug descriptor___4 ;
  long tmp___7 ;
  bool tmp___8 ;
  struct _ddebug descriptor___5 ;
  long tmp___9 ;
  struct _ddebug descriptor___6 ;
  long tmp___10 ;
  struct _ddebug descriptor___7 ;
  long tmp___11 ;
    klee_make_symbolic(&tmp___11, sizeof(long), "tmp___11");
  bool tmp___12 ;
  struct _ddebug descriptor___8 ;
  long tmp___13 ;
  bool tmp___14 ;
  struct _ddebug descriptor___9 ;
  long tmp___15 ;
  bool tmp___16 ;
  struct _ddebug descriptor___10 ;
  long tmp___17 ;
  bool tmp___18 ;
  struct _ddebug descriptor___11 ;
  long tmp___19 ;
    klee_make_symbolic(&tmp___19, sizeof(long), "tmp___19");
  bool tmp___20 ;
  struct _ddebug descriptor___12 ;
  long tmp___21 ;
    klee_make_symbolic(&tmp___21, sizeof(long), "tmp___21");
  struct _ddebug descriptor___13 ;
  long tmp___22 ;
    klee_make_symbolic(&tmp___22, sizeof(long), "tmp___22");
  struct _ddebug descriptor___14 ;
  long tmp___23 ;
    klee_make_symbolic(&tmp___23, sizeof(long), "tmp___23");
  struct _ddebug descriptor___15 ;
  long tmp___24 ;
    klee_make_symbolic(&tmp___24, sizeof(long), "tmp___24");
  struct _ddebug descriptor___16 ;
  long tmp___25 ;
    klee_make_symbolic(&tmp___25, sizeof(long), "tmp___25");
  bool tmp___26 ;

  {
  tmp___0 = dbg_hc(chan);
  if ((int )tmp___0) {
    descriptor.modname = "dwc2";
    descriptor.function = "dwc2_hc_halt";
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
    descriptor.format = "%s()\n";
    descriptor.lineno = 1433U;
    descriptor.flags = 1U;
    tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
    if (tmp != 0L) {
      __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "%s()\n",
                        "dwc2_hc_halt");
    } else {

    }
  } else {

  }
  if ((unsigned int )halt_status == 0U) {
    dev_err((struct device  const  *)hsotg->dev, "!!! halt_status = %d !!!\n", (unsigned int )halt_status);
  } else {

  }
  if ((unsigned int )halt_status == 13U || (unsigned int )halt_status == 11U) {
    hcintmsk = 2U;
    descriptor___0.modname = "dwc2";
    descriptor___0.function = "dwc2_hc_halt";
    descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
    descriptor___0.format = "dequeue/error\n";
    descriptor___0.lineno = 1447U;
    descriptor___0.flags = 1U;
    tmp___1 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
    if (tmp___1 != 0L) {
      __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)hsotg->dev, "dequeue/error\n");
    } else {

    }
    writel(hcintmsk, (void volatile   *)hsotg->regs + (unsigned long )((int )chan->hc_num * 32 + 1292));
    writel(~ hcintmsk, (void volatile   *)hsotg->regs + (unsigned long )((int )chan->hc_num * 32 + 1288));
    chan->halt_status = halt_status;
    hcchar = readl((void const volatile   *)hsotg->regs + (unsigned long )(((int )chan->hc_num + 40) * 32));
    if ((int )hcchar >= 0) {
      return;
    } else {

    }
  } else {

  }
  if ((unsigned int )chan->halt_pending != 0U) {
    descriptor___1.modname = "dwc2";
    descriptor___1.function = "dwc2_hc_halt";
    descriptor___1.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
    descriptor___1.format = "*** %s: Channel %d, chan->halt_pending already set ***\n";
    descriptor___1.lineno = 1488U;
    descriptor___1.flags = 1U;
    tmp___2 = ldv__builtin_expect((long )descriptor___1.flags & 1L, 0L);
    if (tmp___2 != 0L) {
      __dynamic_dev_dbg(& descriptor___1, (struct device  const  *)hsotg->dev, "*** %s: Channel %d, chan->halt_pending already set ***\n",
                        "dwc2_hc_halt", (int )chan->hc_num);
    } else {

    }
    return;
  } else {

  }
  hcchar = readl((void const volatile   *)hsotg->regs + (unsigned long )(((int )chan->hc_num + 40) * 32));
  if ((hsotg->core_params)->dma_desc_enable <= 0) {
    tmp___4 = dbg_hc(chan);
    if ((int )tmp___4) {
      descriptor___2.modname = "dwc2";
      descriptor___2.function = "dwc2_hc_halt";
      descriptor___2.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
      descriptor___2.format = "desc DMA disabled\n";
      descriptor___2.lineno = 1498U;
      descriptor___2.flags = 1U;
      tmp___3 = ldv__builtin_expect((long )descriptor___2.flags & 1L, 0L);
      if (tmp___3 != 0L) {
        __dynamic_dev_dbg(& descriptor___2, (struct device  const  *)hsotg->dev, "desc DMA disabled\n");
      } else {

      }
    } else {

    }
    hcchar = hcchar | 2147483648U;
  } else {
    tmp___6 = dbg_hc(chan);
    if ((int )tmp___6) {
      descriptor___3.modname = "dwc2";
      descriptor___3.function = "dwc2_hc_halt";
      descriptor___3.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
      descriptor___3.format = "desc DMA enabled\n";
      descriptor___3.lineno = 1502U;
      descriptor___3.flags = 1U;
      tmp___5 = ldv__builtin_expect((long )descriptor___3.flags & 1L, 0L);
      if (tmp___5 != 0L) {
        __dynamic_dev_dbg(& descriptor___3, (struct device  const  *)hsotg->dev, "desc DMA enabled\n");
      } else {

      }
    } else {

    }
  }
  hcchar = hcchar | 1073741824U;
  if ((hsotg->core_params)->dma_enable <= 0) {
    tmp___8 = dbg_hc(chan);
    if ((int )tmp___8) {
      descriptor___4.modname = "dwc2";
      descriptor___4.function = "dwc2_hc_halt";
      descriptor___4.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
      descriptor___4.format = "DMA not enabled\n";
      descriptor___4.lineno = 1508U;
      descriptor___4.flags = 1U;
      tmp___7 = ldv__builtin_expect((long )descriptor___4.flags & 1L, 0L);
      if (tmp___7 != 0L) {
        __dynamic_dev_dbg(& descriptor___4, (struct device  const  *)hsotg->dev, "DMA not enabled\n");
      } else {

      }
    } else {

    }
    hcchar = hcchar | 2147483648U;
    if ((unsigned int )*((unsigned char *)chan + 3UL) == 0U || (unsigned int )*((unsigned char *)chan + 3UL) == 2U) {
      descriptor___5.modname = "dwc2";
      descriptor___5.function = "dwc2_hc_halt";
      descriptor___5.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
      descriptor___5.format = "control/bulk\n";
      descriptor___5.lineno = 1514U;
      descriptor___5.flags = 1U;
      tmp___9 = ldv__builtin_expect((long )descriptor___5.flags & 1L, 0L);
      if (tmp___9 != 0L) {
        __dynamic_dev_dbg(& descriptor___5, (struct device  const  *)hsotg->dev, "control/bulk\n");
      } else {

      }
      nptxsts = readl((void const volatile   *)hsotg->regs + 44U);
      if ((nptxsts & 16711680U) == 0U) {
        descriptor___6.modname = "dwc2";
        descriptor___6.function = "dwc2_hc_halt";
        descriptor___6.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
        descriptor___6.format = "Disabling channel\n";
        descriptor___6.lineno = 1517U;
        descriptor___6.flags = 1U;
        tmp___10 = ldv__builtin_expect((long )descriptor___6.flags & 1L, 0L);
        if (tmp___10 != 0L) {
          __dynamic_dev_dbg(& descriptor___6, (struct device  const  *)hsotg->dev,
                            "Disabling channel\n");
        } else {

        }
        hcchar = hcchar & 2147483647U;
      } else {

      }
    } else {
      tmp___12 = dbg_perio();
      if ((int )tmp___12) {
        descriptor___7.modname = "dwc2";
        descriptor___7.function = "dwc2_hc_halt";
        descriptor___7.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
        descriptor___7.format = "isoc/intr\n";
        descriptor___7.lineno = 1522U;
        descriptor___7.flags = 1U;
        tmp___11 = ldv__builtin_expect((long )descriptor___7.flags & 1L, 0L);
        if (tmp___11 != 0L) {
          __dynamic_dev_dbg(& descriptor___7, (struct device  const  *)hsotg->dev,
                            "isoc/intr\n");
        } else {

        }
      } else {

      }
      hptxsts = readl((void const volatile   *)hsotg->regs + 1040U);
      if ((hptxsts & 16711680U) == 0U || (unsigned int )*((unsigned char *)hsotg + 392UL) != 0U) {
        tmp___14 = dbg_perio();
        if ((int )tmp___14) {
          descriptor___8.modname = "dwc2";
          descriptor___8.function = "dwc2_hc_halt";
          descriptor___8.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
          descriptor___8.format = "Disabling channel\n";
          descriptor___8.lineno = 1527U;
          descriptor___8.flags = 1U;
          tmp___13 = ldv__builtin_expect((long )descriptor___8.flags & 1L, 0L);
          if (tmp___13 != 0L) {
            __dynamic_dev_dbg(& descriptor___8, (struct device  const  *)hsotg->dev,
                              "Disabling channel\n");
          } else {

          }
        } else {

        }
        hcchar = hcchar & 2147483647U;
      } else {

      }
    }
  } else {
    tmp___16 = dbg_hc(chan);
    if ((int )tmp___16) {
      descriptor___9.modname = "dwc2";
      descriptor___9.function = "dwc2_hc_halt";
      descriptor___9.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
      descriptor___9.format = "DMA enabled\n";
      descriptor___9.lineno = 1533U;
      descriptor___9.flags = 1U;
      tmp___15 = ldv__builtin_expect((long )descriptor___9.flags & 1L, 0L);
      if (tmp___15 != 0L) {
        __dynamic_dev_dbg(& descriptor___9, (struct device  const  *)hsotg->dev, "DMA enabled\n");
      } else {

      }
    } else {

    }
  }
  writel(hcchar, (void volatile   *)hsotg->regs + (unsigned long )(((int )chan->hc_num + 40) * 32));
  chan->halt_status = halt_status;
  if ((int )hcchar < 0) {
    tmp___18 = dbg_hc(chan);
    if ((int )tmp___18) {
      descriptor___10.modname = "dwc2";
      descriptor___10.function = "dwc2_hc_halt";
      descriptor___10.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
      descriptor___10.format = "Channel enabled\n";
      descriptor___10.lineno = 1541U;
      descriptor___10.flags = 1U;
      tmp___17 = ldv__builtin_expect((long )descriptor___10.flags & 1L, 0L);
      if (tmp___17 != 0L) {
        __dynamic_dev_dbg(& descriptor___10, (struct device  const  *)hsotg->dev,
                          "Channel enabled\n");
      } else {

      }
    } else {

    }
    chan->halt_pending = 1U;
    chan->halt_on_queue = 0U;
  } else {
    tmp___20 = dbg_hc(chan);
    if ((int )tmp___20) {
      descriptor___11.modname = "dwc2";
      descriptor___11.function = "dwc2_hc_halt";
      descriptor___11.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
      descriptor___11.format = "Channel disabled\n";
      descriptor___11.lineno = 1546U;
      descriptor___11.flags = 1U;
      tmp___19 = ldv__builtin_expect((long )descriptor___11.flags & 1L, 0L);
      if (tmp___19 != 0L) {
        __dynamic_dev_dbg(& descriptor___11, (struct device  const  *)hsotg->dev,
                          "Channel disabled\n");
      } else {

      }
    } else {

    }
    chan->halt_on_queue = 1U;
  }
  tmp___26 = dbg_hc(chan);
  if ((int )tmp___26) {
    descriptor___12.modname = "dwc2";
    descriptor___12.function = "dwc2_hc_halt";
    descriptor___12.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
    descriptor___12.format = "%s: Channel %d\n";
    descriptor___12.lineno = 1552U;
    descriptor___12.flags = 1U;
    tmp___21 = ldv__builtin_expect((long )descriptor___12.flags & 1L, 0L);
    if (tmp___21 != 0L) {
      __dynamic_dev_dbg(& descriptor___12, (struct device  const  *)hsotg->dev, "%s: Channel %d\n",
                        "dwc2_hc_halt", (int )chan->hc_num);
    } else {

    }
    descriptor___13.modname = "dwc2";
    descriptor___13.function = "dwc2_hc_halt";
    descriptor___13.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
    descriptor___13.format = "\t hcchar: 0x%08x\n";
    descriptor___13.lineno = 1554U;
    descriptor___13.flags = 1U;
    tmp___22 = ldv__builtin_expect((long )descriptor___13.flags & 1L, 0L);
    if (tmp___22 != 0L) {
      __dynamic_dev_dbg(& descriptor___13, (struct device  const  *)hsotg->dev, "\t hcchar: 0x%08x\n",
                        hcchar);
    } else {

    }
    descriptor___14.modname = "dwc2";
    descriptor___14.function = "dwc2_hc_halt";
    descriptor___14.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
    descriptor___14.format = "\t halt_pending: %d\n";
    descriptor___14.lineno = 1556U;
    descriptor___14.flags = 1U;
    tmp___23 = ldv__builtin_expect((long )descriptor___14.flags & 1L, 0L);
    if (tmp___23 != 0L) {
      __dynamic_dev_dbg(& descriptor___14, (struct device  const  *)hsotg->dev, "\t halt_pending: %d\n",
                        (int )chan->halt_pending);
    } else {

    }
    descriptor___15.modname = "dwc2";
    descriptor___15.function = "dwc2_hc_halt";
    descriptor___15.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
    descriptor___15.format = "\t halt_on_queue: %d\n";
    descriptor___15.lineno = 1558U;
    descriptor___15.flags = 1U;
    tmp___24 = ldv__builtin_expect((long )descriptor___15.flags & 1L, 0L);
    if (tmp___24 != 0L) {
      __dynamic_dev_dbg(& descriptor___15, (struct device  const  *)hsotg->dev, "\t halt_on_queue: %d\n",
                        (int )chan->halt_on_queue);
    } else {

    }
    descriptor___16.modname = "dwc2";
    descriptor___16.function = "dwc2_hc_halt";
    descriptor___16.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
    descriptor___16.format = "\t halt_status: %d\n";
    descriptor___16.lineno = 1560U;
    descriptor___16.flags = 1U;
    tmp___25 = ldv__builtin_expect((long )descriptor___16.flags & 1L, 0L);
    if (tmp___25 != 0L) {
      __dynamic_dev_dbg(& descriptor___16, (struct device  const  *)hsotg->dev, "\t halt_status: %d\n",
                        (unsigned int )chan->halt_status);
    } else {

    }
  } else {

  }
  return;
}
}
void dwc2_hc_cleanup(struct dwc2_hsotg *hsotg , struct dwc2_host_chan *chan ) 
{ 
  u32 hcintmsk ;

  {
  chan->xfer_started = 0U;
  writel(0U, (void volatile   *)hsotg->regs + (unsigned long )((int )chan->hc_num * 32 + 1292));
  hcintmsk = 4294967295U;
  hcintmsk = hcintmsk & 16383U;
  writel(hcintmsk, (void volatile   *)hsotg->regs + (unsigned long )((int )chan->hc_num * 32 + 1288));
  return;
}
}
static void dwc2_hc_set_even_odd_frame(struct dwc2_hsotg *hsotg , struct dwc2_host_chan *chan ,
                                       u32 *hcchar ) 
{ 
  int tmp ;

  {
  if ((unsigned int )*((unsigned char *)chan + 3UL) == 3U || (unsigned int )*((unsigned char *)chan + 3UL) == 1U) {
    tmp = dwc2_hcd_get_frame_number(hsotg);
    if ((tmp & 1) == 0) {
      *hcchar = *hcchar | 536870912U;
    } else {

    }
  } else {

  }
  return;
}
}
static void dwc2_set_pid_isoc(struct dwc2_host_chan *chan ) 
{ 


  {
  if ((unsigned int )*((unsigned char *)chan + 2UL) == 48U) {
    if ((unsigned int )*((unsigned char *)chan + 2UL) != 0U) {
      if ((unsigned int )*((unsigned char *)chan + 5UL) == 32U) {
        chan->data_pid_start = 0U;
      } else
      if ((unsigned int )*((unsigned char *)chan + 5UL) == 64U) {
        chan->data_pid_start = 2U;
      } else {
        chan->data_pid_start = 1U;
      }
    } else
    if ((unsigned int )*((unsigned char *)chan + 5UL) == 32U) {
      chan->data_pid_start = 0U;
    } else {
      chan->data_pid_start = 3U;
    }
  } else {
    chan->data_pid_start = 0U;
  }
  return;
}
}
static void dwc2_hc_write_packet(struct dwc2_hsotg *hsotg , struct dwc2_host_chan *chan ) 
{ 
  u32 i ;
  u32 remaining_count ;
  u32 byte_count ;
  u32 dword_count ;
  u32 *data_fifo ;
  u32 *data_buf ;
  struct _ddebug descriptor ;
  long tmp ;
  bool tmp___0 ;
  u32 data ;

  {
  data_buf = (u32 *)chan->xfer_buf;
  tmp___0 = dbg_hc(chan);
  if ((int )tmp___0) {
    descriptor.modname = "dwc2";
    descriptor.function = "dwc2_hc_write_packet";
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
    descriptor.format = "%s()\n";
    descriptor.lineno = 1657U;
    descriptor.flags = 1U;
    tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
    if (tmp != 0L) {
      __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "%s()\n",
                        "dwc2_hc_write_packet");
    } else {

    }
  } else {

  }
  data_fifo = (u32 *)hsotg->regs + (unsigned long )(((int )chan->hc_num + 1) * 4096);
  remaining_count = chan->xfer_len - chan->xfer_count;
  if ((u32 )chan->max_packet < remaining_count) {
    byte_count = (u32 )chan->max_packet;
  } else {
    byte_count = remaining_count;
  }
  dword_count = (byte_count + 3U) / 4U;
  if (((unsigned long )data_buf & 3UL) == 0UL) {
    i = 0U;
    goto ldv_34922;
    ldv_34921: 
    writel(*data_buf, (void volatile   *)data_fifo);
    i = i + 1U;
    data_buf = data_buf + 1;
    ldv_34922: ;
    if (i < dword_count) {
      goto ldv_34921;
    } else {

    }

  } else {
    i = 0U;
    goto ldv_34926;
    ldv_34925: 
    data = ((*data_buf | (*(data_buf + 1UL) << 8)) | (*(data_buf + 2UL) << 16)) | (*(data_buf + 3UL) << 24);
    writel(data, (void volatile   *)data_fifo);
    i = i + 1U;
    data_buf = data_buf + 1;
    ldv_34926: ;
    if (i < dword_count) {
      goto ldv_34925;
    } else {

    }

  }
  chan->xfer_count = chan->xfer_count + byte_count;
  chan->xfer_buf = chan->xfer_buf + (unsigned long )byte_count;
  return;
}
}
void dwc2_hc_start_transfer(struct dwc2_hsotg *hsotg , struct dwc2_host_chan *chan ) 
{ 
  u32 max_hc_xfer_size ;
  u16 max_hc_pkt_count ;
  u32 hcchar ;
  u32 hctsiz ;
  u16 num_packets ;
  struct _ddebug descriptor ;
  long tmp ;
  bool tmp___0 ;
  struct _ddebug descriptor___0 ;
  long tmp___1 ;
  bool tmp___2 ;
  struct _ddebug descriptor___1 ;
  long tmp___3 ;
  bool tmp___4 ;
  struct _ddebug descriptor___2 ;
  long tmp___5 ;
  bool tmp___6 ;
  struct _ddebug descriptor___3 ;
  long tmp___7 ;
  bool tmp___8 ;
  u32 max_periodic_len ;
  struct _ddebug descriptor___4 ;
  long tmp___9 ;
  struct _ddebug descriptor___5 ;
  long tmp___10 ;
  struct _ddebug descriptor___6 ;
  long tmp___11 ;
  struct _ddebug descriptor___7 ;
  long tmp___12 ;
  struct _ddebug descriptor___8 ;
  long tmp___13 ;
  bool tmp___14 ;
  dma_addr_t dma_addr ;
  struct _ddebug descriptor___9 ;
  long tmp___15 ;
  bool tmp___16 ;
  struct _ddebug descriptor___10 ;
  long tmp___17 ;
  bool tmp___18 ;
  u32 hcsplt ;
  unsigned int tmp___19 ;
  struct _ddebug descriptor___11 ;
  long tmp___20 ;
    klee_make_symbolic(&tmp___20, sizeof(long), "tmp___20");
  bool tmp___21 ;
  struct _ddebug descriptor___12 ;
  long tmp___22 ;
  bool tmp___23 ;

  {
  max_hc_xfer_size = (u32 )(hsotg->core_params)->max_transfer_size;
  max_hc_pkt_count = (u16 )(hsotg->core_params)->max_packet_count;
  hctsiz = 0U;
  tmp___0 = dbg_hc(chan);
  if ((int )tmp___0) {
    descriptor.modname = "dwc2";
    descriptor.function = "dwc2_hc_start_transfer";
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
    descriptor.format = "%s()\n";
    descriptor.lineno = 1729U;
    descriptor.flags = 1U;
    tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
    if (tmp != 0L) {
      __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "%s()\n",
                        "dwc2_hc_start_transfer");
    } else {

    }
  } else {

  }
  if ((unsigned int )chan->do_ping != 0U) {
    if ((hsotg->core_params)->dma_enable <= 0) {
      tmp___2 = dbg_hc(chan);
      if ((int )tmp___2) {
        descriptor___0.modname = "dwc2";
        descriptor___0.function = "dwc2_hc_start_transfer";
        descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
        descriptor___0.format = "ping, no DMA\n";
        descriptor___0.lineno = 1734U;
        descriptor___0.flags = 1U;
        tmp___1 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
        if (tmp___1 != 0L) {
          __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)hsotg->dev,
                            "ping, no DMA\n");
        } else {

        }
      } else {

      }
      dwc2_hc_do_ping(hsotg, chan);
      chan->xfer_started = 1U;
      return;
    } else {
      tmp___4 = dbg_hc(chan);
      if ((int )tmp___4) {
        descriptor___1.modname = "dwc2";
        descriptor___1.function = "dwc2_hc_start_transfer";
        descriptor___1.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
        descriptor___1.format = "ping, DMA\n";
        descriptor___1.lineno = 1740U;
        descriptor___1.flags = 1U;
        tmp___3 = ldv__builtin_expect((long )descriptor___1.flags & 1L, 0L);
        if (tmp___3 != 0L) {
          __dynamic_dev_dbg(& descriptor___1, (struct device  const  *)hsotg->dev,
                            "ping, DMA\n");
        } else {

        }
      } else {

      }
      hctsiz = hctsiz | 2147483648U;
    }
  } else {

  }
  if ((unsigned int )chan->do_split != 0U) {
    tmp___6 = dbg_hc(chan);
    if ((int )tmp___6) {
      descriptor___2.modname = "dwc2";
      descriptor___2.function = "dwc2_hc_start_transfer";
      descriptor___2.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
      descriptor___2.format = "split\n";
      descriptor___2.lineno = 1747U;
      descriptor___2.flags = 1U;
      tmp___5 = ldv__builtin_expect((long )descriptor___2.flags & 1L, 0L);
      if (tmp___5 != 0L) {
        __dynamic_dev_dbg(& descriptor___2, (struct device  const  *)hsotg->dev, "split\n");
      } else {

      }
    } else {

    }
    num_packets = 1U;
    if ((unsigned int )chan->complete_split != 0U && (unsigned int )*((unsigned char *)chan + 2UL) == 0U) {
      chan->xfer_len = 0U;
    } else
    if ((unsigned int )*((unsigned char *)chan + 2UL) != 0U || chan->xfer_len > (u32 )chan->max_packet) {
      chan->xfer_len = (u32 )chan->max_packet;
    } else
    if ((unsigned int )*((unsigned char *)chan + 2UL) == 0U && chan->xfer_len > 188U) {
      chan->xfer_len = 188U;
    } else {

    }
    hctsiz = (chan->xfer_len & 524287U) | hctsiz;
  } else {
    tmp___8 = dbg_hc(chan);
    if ((int )tmp___8) {
      descriptor___3.modname = "dwc2";
      descriptor___3.function = "dwc2_hc_start_transfer";
      descriptor___3.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
      descriptor___3.format = "no split\n";
      descriptor___3.lineno = 1765U;
      descriptor___3.flags = 1U;
      tmp___7 = ldv__builtin_expect((long )descriptor___3.flags & 1L, 0L);
      if (tmp___7 != 0L) {
        __dynamic_dev_dbg(& descriptor___3, (struct device  const  *)hsotg->dev, "no split\n");
      } else {

      }
    } else {

    }
    if ((unsigned int )*((unsigned char *)chan + 3UL) == 3U || (unsigned int )*((unsigned char *)chan + 3UL) == 1U) {
      max_periodic_len = (u32 )((int )chan->multi_count * (int )chan->max_packet);
      if (chan->xfer_len > max_periodic_len) {
        chan->xfer_len = max_periodic_len;
      } else {

      }
    } else
    if (chan->xfer_len > max_hc_xfer_size) {
      chan->xfer_len = (max_hc_xfer_size - (u32 )chan->max_packet) + 1U;
    } else {

    }
    if (chan->xfer_len != 0U) {
      num_packets = (u16 )(((chan->xfer_len + (u32 )chan->max_packet) - 1U) / (u32 )chan->max_packet);
      if ((int )num_packets > (int )max_hc_pkt_count) {
        num_packets = max_hc_pkt_count;
        chan->xfer_len = (u32 )((int )num_packets * (int )chan->max_packet);
      } else {

      }
    } else {
      num_packets = 1U;
    }
    if ((unsigned int )*((unsigned char *)chan + 2UL) != 0U) {
      chan->xfer_len = (u32 )((int )num_packets * (int )chan->max_packet);
    } else {

    }
    if ((unsigned int )*((unsigned char *)chan + 3UL) == 3U || (unsigned int )*((unsigned char *)chan + 3UL) == 1U) {
      chan->multi_count = (unsigned char )num_packets;
    } else {

    }
    if ((unsigned int )*((unsigned char *)chan + 3UL) == 1U) {
      dwc2_set_pid_isoc(chan);
    } else {

    }
    hctsiz = (chan->xfer_len & 524287U) | hctsiz;
  }
  chan->start_pkt_count = num_packets;
  hctsiz = ((u32 )((int )num_packets << 19) & 536346624U) | hctsiz;
  hctsiz = ((u32 )((int )chan->data_pid_start << 29) & 1610612736U) | hctsiz;
  writel(hctsiz, (void volatile   *)hsotg->regs + (unsigned long )((int )chan->hc_num * 32 + 1296));
  tmp___14 = dbg_hc(chan);
  if ((int )tmp___14) {
    descriptor___4.modname = "dwc2";
    descriptor___4.function = "dwc2_hc_start_transfer";
    descriptor___4.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
    descriptor___4.format = "Wrote %08x to HCTSIZ(%d)\n";
    descriptor___4.lineno = 1834U;
    descriptor___4.flags = 1U;
    tmp___9 = ldv__builtin_expect((long )descriptor___4.flags & 1L, 0L);
    if (tmp___9 != 0L) {
      __dynamic_dev_dbg(& descriptor___4, (struct device  const  *)hsotg->dev, "Wrote %08x to HCTSIZ(%d)\n",
                        hctsiz, (int )chan->hc_num);
    } else {

    }
    descriptor___5.modname = "dwc2";
    descriptor___5.function = "dwc2_hc_start_transfer";
    descriptor___5.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
    descriptor___5.format = "%s: Channel %d\n";
    descriptor___5.lineno = 1837U;
    descriptor___5.flags = 1U;
    tmp___10 = ldv__builtin_expect((long )descriptor___5.flags & 1L, 0L);
    if (tmp___10 != 0L) {
      __dynamic_dev_dbg(& descriptor___5, (struct device  const  *)hsotg->dev, "%s: Channel %d\n",
                        "dwc2_hc_start_transfer", (int )chan->hc_num);
    } else {

    }
    descriptor___6.modname = "dwc2";
    descriptor___6.function = "dwc2_hc_start_transfer";
    descriptor___6.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
    descriptor___6.format = "\t Xfer Size: %d\n";
    descriptor___6.lineno = 1840U;
    descriptor___6.flags = 1U;
    tmp___11 = ldv__builtin_expect((long )descriptor___6.flags & 1L, 0L);
    if (tmp___11 != 0L) {
      __dynamic_dev_dbg(& descriptor___6, (struct device  const  *)hsotg->dev, "\t Xfer Size: %d\n",
                        hctsiz & 524287U);
    } else {

    }
    descriptor___7.modname = "dwc2";
    descriptor___7.function = "dwc2_hc_start_transfer";
    descriptor___7.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
    descriptor___7.format = "\t Num Pkts: %d\n";
    descriptor___7.lineno = 1843U;
    descriptor___7.flags = 1U;
    tmp___12 = ldv__builtin_expect((long )descriptor___7.flags & 1L, 0L);
    if (tmp___12 != 0L) {
      __dynamic_dev_dbg(& descriptor___7, (struct device  const  *)hsotg->dev, "\t Num Pkts: %d\n",
                        (hctsiz & 536346624U) >> 19);
    } else {

    }
    descriptor___8.modname = "dwc2";
    descriptor___8.function = "dwc2_hc_start_transfer";
    descriptor___8.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
    descriptor___8.format = "\t Start PID: %d\n";
    descriptor___8.lineno = 1846U;
    descriptor___8.flags = 1U;
    tmp___13 = ldv__builtin_expect((long )descriptor___8.flags & 1L, 0L);
    if (tmp___13 != 0L) {
      __dynamic_dev_dbg(& descriptor___8, (struct device  const  *)hsotg->dev, "\t Start PID: %d\n",
                        (hctsiz & 1610612736U) >> 29);
    } else {

    }
  } else {

  }
  if ((hsotg->core_params)->dma_enable > 0) {
    if (chan->align_buf != 0ULL) {
      tmp___16 = dbg_hc(chan);
      if ((int )tmp___16) {
        descriptor___9.modname = "dwc2";
        descriptor___9.function = "dwc2_hc_start_transfer";
        descriptor___9.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
        descriptor___9.format = "align_buf\n";
        descriptor___9.lineno = 1854U;
        descriptor___9.flags = 1U;
        tmp___15 = ldv__builtin_expect((long )descriptor___9.flags & 1L, 0L);
        if (tmp___15 != 0L) {
          __dynamic_dev_dbg(& descriptor___9, (struct device  const  *)hsotg->dev,
                            "align_buf\n");
        } else {

        }
      } else {

      }
      dma_addr = chan->align_buf;
    } else {
      dma_addr = chan->xfer_dma;
    }
    writel((unsigned int )dma_addr, (void volatile   *)hsotg->regs + (unsigned long )((int )chan->hc_num * 32 + 1300));
    tmp___18 = dbg_hc(chan);
    if ((int )tmp___18) {
      descriptor___10.modname = "dwc2";
      descriptor___10.function = "dwc2_hc_start_transfer";
      descriptor___10.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
      descriptor___10.format = "Wrote %08lx to HCDMA(%d)\n";
      descriptor___10.lineno = 1862U;
      descriptor___10.flags = 1U;
      tmp___17 = ldv__builtin_expect((long )descriptor___10.flags & 1L, 0L);
      if (tmp___17 != 0L) {
        __dynamic_dev_dbg(& descriptor___10, (struct device  const  *)hsotg->dev,
                          "Wrote %08lx to HCDMA(%d)\n", (unsigned long )dma_addr,
                          (int )chan->hc_num);
      } else {

      }
    } else {

    }
  } else {

  }
  if ((unsigned int )chan->do_split != 0U) {
    tmp___19 = readl((void const volatile   *)hsotg->regs + (unsigned long )((int )chan->hc_num * 32 + 1284));
    hcsplt = tmp___19;
    hcsplt = hcsplt | 2147483648U;
    writel(hcsplt, (void volatile   *)hsotg->regs + (unsigned long )((int )chan->hc_num * 32 + 1284));
  } else {

  }
  hcchar = readl((void const volatile   *)hsotg->regs + (unsigned long )(((int )chan->hc_num + 40) * 32));
  hcchar = hcchar & 4291821567U;
  hcchar = ((u32 )((int )chan->multi_count << 20) & 3145728U) | hcchar;
  dwc2_hc_set_even_odd_frame(hsotg, chan, & hcchar);
  if ((hcchar & 1073741824U) != 0U) {
    dev_warn((struct device  const  *)hsotg->dev, "%s: chdis set, channel %d, hcchar 0x%08x\n",
             "dwc2_hc_start_transfer", (int )chan->hc_num, hcchar);
  } else {

  }
  hcchar = hcchar | 2147483648U;
  hcchar = hcchar & 3221225471U;
  tmp___21 = dbg_hc(chan);
  if ((int )tmp___21) {
    descriptor___11.modname = "dwc2";
    descriptor___11.function = "dwc2_hc_start_transfer";
    descriptor___11.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
    descriptor___11.format = "\t Multi Cnt: %d\n";
    descriptor___11.lineno = 1891U;
    descriptor___11.flags = 1U;
    tmp___20 = ldv__builtin_expect((long )descriptor___11.flags & 1L, 0L);
    if (tmp___20 != 0L) {
      __dynamic_dev_dbg(& descriptor___11, (struct device  const  *)hsotg->dev, "\t Multi Cnt: %d\n",
                        (hcchar & 3145728U) >> 20);
    } else {

    }
  } else {

  }
  writel(hcchar, (void volatile   *)hsotg->regs + (unsigned long )(((int )chan->hc_num + 40) * 32));
  tmp___23 = dbg_hc(chan);
  if ((int )tmp___23) {
    descriptor___12.modname = "dwc2";
    descriptor___12.function = "dwc2_hc_start_transfer";
    descriptor___12.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
    descriptor___12.format = "Wrote %08x to HCCHAR(%d)\n";
    descriptor___12.lineno = 1896U;
    descriptor___12.flags = 1U;
    tmp___22 = ldv__builtin_expect((long )descriptor___12.flags & 1L, 0L);
    if (tmp___22 != 0L) {
      __dynamic_dev_dbg(& descriptor___12, (struct device  const  *)hsotg->dev, "Wrote %08x to HCCHAR(%d)\n",
                        hcchar, (int )chan->hc_num);
    } else {

    }
  } else {

  }
  chan->xfer_started = 1U;
  chan->requests = (u8 )((int )chan->requests + 1);
  if (((hsotg->core_params)->dma_enable <= 0 && (unsigned int )*((unsigned char *)chan + 2UL) == 0U) && chan->xfer_len != 0U) {
    dwc2_hc_write_packet(hsotg, chan);
  } else {

  }
  return;
}
}
void dwc2_hc_start_transfer_ddma(struct dwc2_hsotg *hsotg , struct dwc2_host_chan *chan ) 
{ 
  u32 hcchar ;
  u32 hc_dma ;
  u32 hctsiz ;
  struct _ddebug descriptor ;
  long tmp ;
  struct _ddebug descriptor___0 ;
  long tmp___0 ;
  struct _ddebug descriptor___1 ;
  long tmp___1 ;
  bool tmp___2 ;
  struct _ddebug descriptor___2 ;
  long tmp___3 ;
  bool tmp___4 ;
  struct _ddebug descriptor___3 ;
  long tmp___5 ;
  bool tmp___6 ;
  struct _ddebug descriptor___4 ;
  long tmp___7 ;
  bool tmp___8 ;

  {
  hctsiz = 0U;
  if ((unsigned int )chan->do_ping != 0U) {
    hctsiz = hctsiz | 2147483648U;
  } else {

  }
  if ((unsigned int )*((unsigned char *)chan + 3UL) == 1U) {
    dwc2_set_pid_isoc(chan);
  } else {

  }
  hctsiz = ((u32 )((int )chan->data_pid_start << 29) & 1610612736U) | hctsiz;
  hctsiz = ((u32 )(((int )chan->ntd + -1) << 8) & 65535U) | hctsiz;
  hctsiz = (u32 )chan->schinfo | hctsiz;
  tmp___2 = dbg_hc(chan);
  if ((int )tmp___2) {
    descriptor.modname = "dwc2";
    descriptor.function = "dwc2_hc_start_transfer_ddma";
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
    descriptor.format = "%s: Channel %d\n";
    descriptor.lineno = 1946U;
    descriptor.flags = 1U;
    tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
    if (tmp != 0L) {
      __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "%s: Channel %d\n",
                        "dwc2_hc_start_transfer_ddma", (int )chan->hc_num);
    } else {

    }
    descriptor___0.modname = "dwc2";
    descriptor___0.function = "dwc2_hc_start_transfer_ddma";
    descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
    descriptor___0.format = "\t Start PID: %d\n";
    descriptor___0.lineno = 1948U;
    descriptor___0.flags = 1U;
    tmp___0 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
    if (tmp___0 != 0L) {
      __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)hsotg->dev, "\t Start PID: %d\n",
                        (int )chan->data_pid_start);
    } else {

    }
    descriptor___1.modname = "dwc2";
    descriptor___1.function = "dwc2_hc_start_transfer_ddma";
    descriptor___1.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
    descriptor___1.format = "\t NTD: %d\n";
    descriptor___1.lineno = 1949U;
    descriptor___1.flags = 1U;
    tmp___1 = ldv__builtin_expect((long )descriptor___1.flags & 1L, 0L);
    if (tmp___1 != 0L) {
      __dynamic_dev_dbg(& descriptor___1, (struct device  const  *)hsotg->dev, "\t NTD: %d\n",
                        (int )chan->ntd + -1);
    } else {

    }
  } else {

  }
  writel(hctsiz, (void volatile   *)hsotg->regs + (unsigned long )((int )chan->hc_num * 32 + 1296));
  hc_dma = (unsigned int )chan->desc_list_addr & 4294965248U;
  hc_dma = hc_dma & 4294965255U;
  writel(hc_dma, (void volatile   *)hsotg->regs + (unsigned long )((int )chan->hc_num * 32 + 1300));
  tmp___4 = dbg_hc(chan);
  if ((int )tmp___4) {
    descriptor___2.modname = "dwc2";
    descriptor___2.function = "dwc2_hc_start_transfer_ddma";
    descriptor___2.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
    descriptor___2.format = "Wrote %08x to HCDMA(%d)\n";
    descriptor___2.lineno = 1961U;
    descriptor___2.flags = 1U;
    tmp___3 = ldv__builtin_expect((long )descriptor___2.flags & 1L, 0L);
    if (tmp___3 != 0L) {
      __dynamic_dev_dbg(& descriptor___2, (struct device  const  *)hsotg->dev, "Wrote %08x to HCDMA(%d)\n",
                        hc_dma, (int )chan->hc_num);
    } else {

    }
  } else {

  }
  hcchar = readl((void const volatile   *)hsotg->regs + (unsigned long )(((int )chan->hc_num + 40) * 32));
  hcchar = hcchar & 4291821567U;
  hcchar = ((u32 )((int )chan->multi_count << 20) & 3145728U) | hcchar;
  if ((hcchar & 1073741824U) != 0U) {
    dev_warn((struct device  const  *)hsotg->dev, "%s: chdis set, channel %d, hcchar 0x%08x\n",
             "dwc2_hc_start_transfer_ddma", (int )chan->hc_num, hcchar);
  } else {

  }
  hcchar = hcchar | 2147483648U;
  hcchar = hcchar & 3221225471U;
  tmp___6 = dbg_hc(chan);
  if ((int )tmp___6) {
    descriptor___3.modname = "dwc2";
    descriptor___3.function = "dwc2_hc_start_transfer_ddma";
    descriptor___3.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
    descriptor___3.format = "\t Multi Cnt: %d\n";
    descriptor___3.lineno = 1980U;
    descriptor___3.flags = 1U;
    tmp___5 = ldv__builtin_expect((long )descriptor___3.flags & 1L, 0L);
    if (tmp___5 != 0L) {
      __dynamic_dev_dbg(& descriptor___3, (struct device  const  *)hsotg->dev, "\t Multi Cnt: %d\n",
                        (hcchar & 3145728U) >> 20);
    } else {

    }
  } else {

  }
  writel(hcchar, (void volatile   *)hsotg->regs + (unsigned long )(((int )chan->hc_num + 40) * 32));
  tmp___8 = dbg_hc(chan);
  if ((int )tmp___8) {
    descriptor___4.modname = "dwc2";
    descriptor___4.function = "dwc2_hc_start_transfer_ddma";
    descriptor___4.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
    descriptor___4.format = "Wrote %08x to HCCHAR(%d)\n";
    descriptor___4.lineno = 1985U;
    descriptor___4.flags = 1U;
    tmp___7 = ldv__builtin_expect((long )descriptor___4.flags & 1L, 0L);
    if (tmp___7 != 0L) {
      __dynamic_dev_dbg(& descriptor___4, (struct device  const  *)hsotg->dev, "Wrote %08x to HCCHAR(%d)\n",
                        hcchar, (int )chan->hc_num);
    } else {

    }
  } else {

  }
  chan->xfer_started = 1U;
  chan->requests = (u8 )((int )chan->requests + 1);
  return;
}
}
int dwc2_hc_continue_transfer(struct dwc2_hsotg *hsotg , struct dwc2_host_chan *chan ) 
{ 
  struct _ddebug descriptor ;
  long tmp ;
  bool tmp___0 ;
  u32 hcchar ;
  unsigned int tmp___1 ;
  struct _ddebug descriptor___0 ;
  long tmp___2 ;
  bool tmp___3 ;
  u32 hcchar___0 ;
  unsigned int tmp___4 ;

  {
  tmp___0 = dbg_hc(chan);
  if ((int )tmp___0) {
    descriptor.modname = "dwc2";
    descriptor.function = "dwc2_hc_continue_transfer";
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
    descriptor.format = "%s: Channel %d\n";
    descriptor.lineno = 2016U;
    descriptor.flags = 1U;
    tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
    if (tmp != 0L) {
      __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "%s: Channel %d\n",
                        "dwc2_hc_continue_transfer", (int )chan->hc_num);
    } else {

    }
  } else {

  }
  if ((unsigned int )chan->do_split != 0U) {
    return (0);
  } else {

  }
  if ((unsigned int )*((unsigned char *)chan + 5UL) == 24U) {
    return (0);
  } else {

  }
  if ((unsigned int )*((unsigned char *)chan + 2UL) != 0U) {
    tmp___1 = readl((void const volatile   *)hsotg->regs + (unsigned long )(((int )chan->hc_num + 40) * 32));
    hcchar = tmp___1;
    dwc2_hc_set_even_odd_frame(hsotg, chan, & hcchar);
    hcchar = hcchar | 2147483648U;
    hcchar = hcchar & 3221225471U;
    tmp___3 = dbg_hc(chan);
    if ((int )tmp___3) {
      descriptor___0.modname = "dwc2";
      descriptor___0.function = "dwc2_hc_continue_transfer";
      descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
      descriptor___0.format = "\t IN xfer: hcchar = 0x%08x\n";
      descriptor___0.lineno = 2046U;
      descriptor___0.flags = 1U;
      tmp___2 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
      if (tmp___2 != 0L) {
        __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)hsotg->dev, "\t IN xfer: hcchar = 0x%08x\n",
                          hcchar);
      } else {

      }
    } else {

    }
    writel(hcchar, (void volatile   *)hsotg->regs + (unsigned long )(((int )chan->hc_num + 40) * 32));
    chan->requests = (u8 )((int )chan->requests + 1);
    return (1);
  } else {

  }
  if (chan->xfer_count < chan->xfer_len) {
    if ((unsigned int )*((unsigned char *)chan + 3UL) == 3U || (unsigned int )*((unsigned char *)chan + 3UL) == 1U) {
      tmp___4 = readl((void const volatile   *)hsotg->regs + (unsigned long )(((int )chan->hc_num + 40) * 32));
      hcchar___0 = tmp___4;
      dwc2_hc_set_even_odd_frame(hsotg, chan, & hcchar___0);
    } else {

    }
    dwc2_hc_write_packet(hsotg, chan);
    chan->requests = (u8 )((int )chan->requests + 1);
    return (1);
  } else {

  }
  return (0);
}
}
void dwc2_hc_do_ping(struct dwc2_hsotg *hsotg , struct dwc2_host_chan *chan ) 
{ 
  u32 hcchar ;
  u32 hctsiz ;
  struct _ddebug descriptor ;
  long tmp ;
  bool tmp___0 ;

  {
  tmp___0 = dbg_hc(chan);
  if ((int )tmp___0) {
    descriptor.modname = "dwc2";
    descriptor.function = "dwc2_hc_do_ping";
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
    descriptor.format = "%s: Channel %d\n";
    descriptor.lineno = 2089U;
    descriptor.flags = 1U;
    tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
    if (tmp != 0L) {
      __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "%s: Channel %d\n",
                        "dwc2_hc_do_ping", (int )chan->hc_num);
    } else {

    }
  } else {

  }
  hctsiz = 2147483648U;
  hctsiz = hctsiz | 524288U;
  writel(hctsiz, (void volatile   *)hsotg->regs + (unsigned long )((int )chan->hc_num * 32 + 1296));
  hcchar = readl((void const volatile   *)hsotg->regs + (unsigned long )(((int )chan->hc_num + 40) * 32));
  hcchar = hcchar | 2147483648U;
  hcchar = hcchar & 3221225471U;
  writel(hcchar, (void volatile   *)hsotg->regs + (unsigned long )(((int )chan->hc_num + 40) * 32));
  return;
}
}
u32 dwc2_calc_frame_interval(struct dwc2_hsotg *hsotg ) 
{ 
  u32 usbcfg ;
  u32 hprt0 ;
  int clock ;
    klee_make_symbolic(&clock, sizeof(int), "clock");

  {
  clock = 60;
  usbcfg = readl((void const volatile   *)hsotg->regs + 12U);
  hprt0 = readl((void const volatile   *)hsotg->regs + 1088U);
  if (((usbcfg & 64U) == 0U && (usbcfg & 16U) != 0U) && (usbcfg & 8U) == 0U) {
    clock = 60;
  } else {

  }
  if ((usbcfg & 64U) != 0U && (unsigned int )*((unsigned char *)hsotg + 34UL) == 12U) {
    clock = 48;
  } else {

  }
  if ((((usbcfg & 32768U) == 0U && (usbcfg & 64U) == 0U) && (usbcfg & 16U) == 0U) && (usbcfg & 8U) != 0U) {
    clock = 30;
  } else {

  }
  if ((((usbcfg & 32768U) == 0U && (usbcfg & 64U) == 0U) && (usbcfg & 16U) == 0U) && (usbcfg & 8U) == 0U) {
    clock = 60;
  } else {

  }
  if ((((usbcfg & 32768U) != 0U && (usbcfg & 64U) == 0U) && (usbcfg & 16U) == 0U) && (usbcfg & 8U) != 0U) {
    clock = 48;
  } else {

  }
  if (((usbcfg & 64U) != 0U && (usbcfg & 8U) == 0U) && (unsigned int )*((unsigned char *)hsotg + 34UL) == 8U) {
    clock = 48;
  } else {

  }
  if ((usbcfg & 64U) != 0U && (unsigned int )*((unsigned char *)hsotg + 34UL) == 4U) {
    clock = 48;
  } else {

  }
  if ((hprt0 & 393216U) >> 17 == 0U) {
    return ((u32 )(clock * 125));
  } else {
    return ((u32 )(clock * 1000));
  }
}
}
void dwc2_read_packet(struct dwc2_hsotg *hsotg , u8 *dest , u16 bytes ) 
{ 
  u32 *fifo ;
  u32 *data_buf ;
  int word_count ;
    klee_make_symbolic(&word_count, sizeof(int), "word_count");
  int i ;
  struct _ddebug descriptor ;
  long tmp ;

  {
  fifo = (u32 *)hsotg->regs + 4096U;
  data_buf = (u32 *)dest;
  word_count = ((int )bytes + 3) / 4;
  descriptor.modname = "dwc2";
  descriptor.function = "dwc2_read_packet";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
  descriptor.format = "%s(%p,%p,%d)\n";
  descriptor.lineno = 2172U;
  descriptor.flags = 1U;
  tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp != 0L) {
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "%s(%p,%p,%d)\n",
                      "dwc2_read_packet", hsotg, dest, (int )bytes);
  } else {

  }
  i = 0;
  goto ldv_35004;
  ldv_35003: 
  *data_buf = readl((void const volatile   *)fifo);
  i = i + 1;
  data_buf = data_buf + 1;
  ldv_35004: ;
  if (i < word_count) {
    goto ldv_35003;
  } else {

  }

  return;
}
}
void dwc2_dump_host_registers(struct dwc2_hsotg *hsotg ) 
{ 
  u32 *addr ;
  int i ;
  struct _ddebug descriptor ;
  long tmp ;
  struct _ddebug descriptor___0 ;
  unsigned int tmp___0 ;
  long tmp___1 ;
  struct _ddebug descriptor___1 ;
  unsigned int tmp___2 ;
  long tmp___3 ;
  struct _ddebug descriptor___2 ;
  unsigned int tmp___4 ;
  long tmp___5 ;
  struct _ddebug descriptor___3 ;
  unsigned int tmp___6 ;
  long tmp___7 ;
  struct _ddebug descriptor___4 ;
  unsigned int tmp___8 ;
  long tmp___9 ;
  struct _ddebug descriptor___5 ;
  unsigned int tmp___10 ;
  long tmp___11 ;
  struct _ddebug descriptor___6 ;
  unsigned int tmp___12 ;
  long tmp___13 ;
  struct _ddebug descriptor___7 ;
  unsigned int tmp___14 ;
  long tmp___15 ;
  struct _ddebug descriptor___8 ;
  long tmp___16 ;
  struct _ddebug descriptor___9 ;
  unsigned int tmp___17 ;
  long tmp___18 ;
  struct _ddebug descriptor___10 ;
  unsigned int tmp___19 ;
  long tmp___20 ;
  struct _ddebug descriptor___11 ;
  unsigned int tmp___21 ;
  long tmp___22 ;
  struct _ddebug descriptor___12 ;
  unsigned int tmp___23 ;
  long tmp___24 ;
  struct _ddebug descriptor___13 ;
  unsigned int tmp___25 ;
  long tmp___26 ;
    klee_make_symbolic(&tmp___26, sizeof(long), "tmp___26");
  struct _ddebug descriptor___14 ;
  unsigned int tmp___27 ;
    klee_make_symbolic(&tmp___27, sizeof(int), "tmp___27");
  long tmp___28 ;
    klee_make_symbolic(&tmp___28, sizeof(long), "tmp___28");
  struct _ddebug descriptor___15 ;
  unsigned int tmp___29 ;
    klee_make_symbolic(&tmp___29, sizeof(int), "tmp___29");
  long tmp___30 ;
    klee_make_symbolic(&tmp___30, sizeof(long), "tmp___30");

  {
  descriptor.modname = "dwc2";
  descriptor.function = "dwc2_dump_host_registers";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
  descriptor.format = "Host Global Registers\n";
  descriptor.lineno = 2192U;
  descriptor.flags = 1U;
  tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp != 0L) {
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "Host Global Registers\n");
  } else {

  }
  addr = (u32 *)hsotg->regs + 1024U;
  descriptor___0.modname = "dwc2";
  descriptor___0.function = "dwc2_dump_host_registers";
  descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
  descriptor___0.format = "HCFG\t @0x%08lX : 0x%08X\n";
  descriptor___0.lineno = 2195U;
  descriptor___0.flags = 1U;
  tmp___1 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
  if (tmp___1 != 0L) {
    tmp___0 = readl((void const volatile   *)addr);
    __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)hsotg->dev, "HCFG\t @0x%08lX : 0x%08X\n",
                      (unsigned long )addr, tmp___0);
  } else {

  }
  addr = (u32 *)hsotg->regs + 1028U;
  descriptor___1.modname = "dwc2";
  descriptor___1.function = "dwc2_dump_host_registers";
  descriptor___1.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
  descriptor___1.format = "HFIR\t @0x%08lX : 0x%08X\n";
  descriptor___1.lineno = 2198U;
  descriptor___1.flags = 1U;
  tmp___3 = ldv__builtin_expect((long )descriptor___1.flags & 1L, 0L);
  if (tmp___3 != 0L) {
    tmp___2 = readl((void const volatile   *)addr);
    __dynamic_dev_dbg(& descriptor___1, (struct device  const  *)hsotg->dev, "HFIR\t @0x%08lX : 0x%08X\n",
                      (unsigned long )addr, tmp___2);
  } else {

  }
  addr = (u32 *)hsotg->regs + 1032U;
  descriptor___2.modname = "dwc2";
  descriptor___2.function = "dwc2_dump_host_registers";
  descriptor___2.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
  descriptor___2.format = "HFNUM\t @0x%08lX : 0x%08X\n";
  descriptor___2.lineno = 2201U;
  descriptor___2.flags = 1U;
  tmp___5 = ldv__builtin_expect((long )descriptor___2.flags & 1L, 0L);
  if (tmp___5 != 0L) {
    tmp___4 = readl((void const volatile   *)addr);
    __dynamic_dev_dbg(& descriptor___2, (struct device  const  *)hsotg->dev, "HFNUM\t @0x%08lX : 0x%08X\n",
                      (unsigned long )addr, tmp___4);
  } else {

  }
  addr = (u32 *)hsotg->regs + 1040U;
  descriptor___3.modname = "dwc2";
  descriptor___3.function = "dwc2_dump_host_registers";
  descriptor___3.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
  descriptor___3.format = "HPTXSTS\t @0x%08lX : 0x%08X\n";
  descriptor___3.lineno = 2204U;
  descriptor___3.flags = 1U;
  tmp___7 = ldv__builtin_expect((long )descriptor___3.flags & 1L, 0L);
  if (tmp___7 != 0L) {
    tmp___6 = readl((void const volatile   *)addr);
    __dynamic_dev_dbg(& descriptor___3, (struct device  const  *)hsotg->dev, "HPTXSTS\t @0x%08lX : 0x%08X\n",
                      (unsigned long )addr, tmp___6);
  } else {

  }
  addr = (u32 *)hsotg->regs + 1044U;
  descriptor___4.modname = "dwc2";
  descriptor___4.function = "dwc2_dump_host_registers";
  descriptor___4.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
  descriptor___4.format = "HAINT\t @0x%08lX : 0x%08X\n";
  descriptor___4.lineno = 2207U;
  descriptor___4.flags = 1U;
  tmp___9 = ldv__builtin_expect((long )descriptor___4.flags & 1L, 0L);
  if (tmp___9 != 0L) {
    tmp___8 = readl((void const volatile   *)addr);
    __dynamic_dev_dbg(& descriptor___4, (struct device  const  *)hsotg->dev, "HAINT\t @0x%08lX : 0x%08X\n",
                      (unsigned long )addr, tmp___8);
  } else {

  }
  addr = (u32 *)hsotg->regs + 1048U;
  descriptor___5.modname = "dwc2";
  descriptor___5.function = "dwc2_dump_host_registers";
  descriptor___5.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
  descriptor___5.format = "HAINTMSK\t @0x%08lX : 0x%08X\n";
  descriptor___5.lineno = 2210U;
  descriptor___5.flags = 1U;
  tmp___11 = ldv__builtin_expect((long )descriptor___5.flags & 1L, 0L);
  if (tmp___11 != 0L) {
    tmp___10 = readl((void const volatile   *)addr);
    __dynamic_dev_dbg(& descriptor___5, (struct device  const  *)hsotg->dev, "HAINTMSK\t @0x%08lX : 0x%08X\n",
                      (unsigned long )addr, tmp___10);
  } else {

  }
  if ((hsotg->core_params)->dma_desc_enable > 0) {
    addr = (u32 *)hsotg->regs + 1052U;
    descriptor___6.modname = "dwc2";
    descriptor___6.function = "dwc2_dump_host_registers";
    descriptor___6.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
    descriptor___6.format = "HFLBADDR @0x%08lX : 0x%08X\n";
    descriptor___6.lineno = 2214U;
    descriptor___6.flags = 1U;
    tmp___13 = ldv__builtin_expect((long )descriptor___6.flags & 1L, 0L);
    if (tmp___13 != 0L) {
      tmp___12 = readl((void const volatile   *)addr);
      __dynamic_dev_dbg(& descriptor___6, (struct device  const  *)hsotg->dev, "HFLBADDR @0x%08lX : 0x%08X\n",
                        (unsigned long )addr, tmp___12);
    } else {

    }
  } else {

  }
  addr = (u32 *)hsotg->regs + 1088U;
  descriptor___7.modname = "dwc2";
  descriptor___7.function = "dwc2_dump_host_registers";
  descriptor___7.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
  descriptor___7.format = "HPRT0\t @0x%08lX : 0x%08X\n";
  descriptor___7.lineno = 2219U;
  descriptor___7.flags = 1U;
  tmp___15 = ldv__builtin_expect((long )descriptor___7.flags & 1L, 0L);
  if (tmp___15 != 0L) {
    tmp___14 = readl((void const volatile   *)addr);
    __dynamic_dev_dbg(& descriptor___7, (struct device  const  *)hsotg->dev, "HPRT0\t @0x%08lX : 0x%08X\n",
                      (unsigned long )addr, tmp___14);
  } else {

  }
  i = 0;
  goto ldv_35030;
  ldv_35029: 
  descriptor___8.modname = "dwc2";
  descriptor___8.function = "dwc2_dump_host_registers";
  descriptor___8.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
  descriptor___8.format = "Host Channel %d Specific Registers\n";
  descriptor___8.lineno = 2222U;
  descriptor___8.flags = 1U;
  tmp___16 = ldv__builtin_expect((long )descriptor___8.flags & 1L, 0L);
  if (tmp___16 != 0L) {
    __dynamic_dev_dbg(& descriptor___8, (struct device  const  *)hsotg->dev, "Host Channel %d Specific Registers\n",
                      i);
  } else {

  }
  addr = (u32 *)hsotg->regs + (unsigned long )((i + 40) * 32);
  descriptor___9.modname = "dwc2";
  descriptor___9.function = "dwc2_dump_host_registers";
  descriptor___9.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
  descriptor___9.format = "HCCHAR\t @0x%08lX : 0x%08X\n";
  descriptor___9.lineno = 2225U;
  descriptor___9.flags = 1U;
  tmp___18 = ldv__builtin_expect((long )descriptor___9.flags & 1L, 0L);
  if (tmp___18 != 0L) {
    tmp___17 = readl((void const volatile   *)addr);
    __dynamic_dev_dbg(& descriptor___9, (struct device  const  *)hsotg->dev, "HCCHAR\t @0x%08lX : 0x%08X\n",
                      (unsigned long )addr, tmp___17);
  } else {

  }
  addr = (u32 *)hsotg->regs + (unsigned long )(i * 32 + 1284);
  descriptor___10.modname = "dwc2";
  descriptor___10.function = "dwc2_dump_host_registers";
  descriptor___10.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
  descriptor___10.format = "HCSPLT\t @0x%08lX : 0x%08X\n";
  descriptor___10.lineno = 2228U;
  descriptor___10.flags = 1U;
  tmp___20 = ldv__builtin_expect((long )descriptor___10.flags & 1L, 0L);
  if (tmp___20 != 0L) {
    tmp___19 = readl((void const volatile   *)addr);
    __dynamic_dev_dbg(& descriptor___10, (struct device  const  *)hsotg->dev, "HCSPLT\t @0x%08lX : 0x%08X\n",
                      (unsigned long )addr, tmp___19);
  } else {

  }
  addr = (u32 *)hsotg->regs + (unsigned long )(i * 32 + 1288);
  descriptor___11.modname = "dwc2";
  descriptor___11.function = "dwc2_dump_host_registers";
  descriptor___11.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
  descriptor___11.format = "HCINT\t @0x%08lX : 0x%08X\n";
  descriptor___11.lineno = 2231U;
  descriptor___11.flags = 1U;
  tmp___22 = ldv__builtin_expect((long )descriptor___11.flags & 1L, 0L);
  if (tmp___22 != 0L) {
    tmp___21 = readl((void const volatile   *)addr);
    __dynamic_dev_dbg(& descriptor___11, (struct device  const  *)hsotg->dev, "HCINT\t @0x%08lX : 0x%08X\n",
                      (unsigned long )addr, tmp___21);
  } else {

  }
  addr = (u32 *)hsotg->regs + (unsigned long )(i * 32 + 1292);
  descriptor___12.modname = "dwc2";
  descriptor___12.function = "dwc2_dump_host_registers";
  descriptor___12.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
  descriptor___12.format = "HCINTMSK\t @0x%08lX : 0x%08X\n";
  descriptor___12.lineno = 2234U;
  descriptor___12.flags = 1U;
  tmp___24 = ldv__builtin_expect((long )descriptor___12.flags & 1L, 0L);
  if (tmp___24 != 0L) {
    tmp___23 = readl((void const volatile   *)addr);
    __dynamic_dev_dbg(& descriptor___12, (struct device  const  *)hsotg->dev, "HCINTMSK\t @0x%08lX : 0x%08X\n",
                      (unsigned long )addr, tmp___23);
  } else {

  }
  addr = (u32 *)hsotg->regs + (unsigned long )(i * 32 + 1296);
  descriptor___13.modname = "dwc2";
  descriptor___13.function = "dwc2_dump_host_registers";
  descriptor___13.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
  descriptor___13.format = "HCTSIZ\t @0x%08lX : 0x%08X\n";
  descriptor___13.lineno = 2237U;
  descriptor___13.flags = 1U;
  tmp___26 = ldv__builtin_expect((long )descriptor___13.flags & 1L, 0L);
  if (tmp___26 != 0L) {
    tmp___25 = readl((void const volatile   *)addr);
    __dynamic_dev_dbg(& descriptor___13, (struct device  const  *)hsotg->dev, "HCTSIZ\t @0x%08lX : 0x%08X\n",
                      (unsigned long )addr, tmp___25);
  } else {

  }
  addr = (u32 *)hsotg->regs + (unsigned long )(i * 32 + 1300);
  descriptor___14.modname = "dwc2";
  descriptor___14.function = "dwc2_dump_host_registers";
  descriptor___14.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
  descriptor___14.format = "HCDMA\t @0x%08lX : 0x%08X\n";
  descriptor___14.lineno = 2240U;
  descriptor___14.flags = 1U;
  tmp___28 = ldv__builtin_expect((long )descriptor___14.flags & 1L, 0L);
  if (tmp___28 != 0L) {
    tmp___27 = readl((void const volatile   *)addr);
    __dynamic_dev_dbg(& descriptor___14, (struct device  const  *)hsotg->dev, "HCDMA\t @0x%08lX : 0x%08X\n",
                      (unsigned long )addr, tmp___27);
  } else {

  }
  if ((hsotg->core_params)->dma_desc_enable > 0) {
    addr = (u32 *)hsotg->regs + (unsigned long )(i * 32 + 1308);
    descriptor___15.modname = "dwc2";
    descriptor___15.function = "dwc2_dump_host_registers";
    descriptor___15.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
    descriptor___15.format = "HCDMAB\t @0x%08lX : 0x%08X\n";
    descriptor___15.lineno = 2244U;
    descriptor___15.flags = 1U;
    tmp___30 = ldv__builtin_expect((long )descriptor___15.flags & 1L, 0L);
    if (tmp___30 != 0L) {
      tmp___29 = readl((void const volatile   *)addr);
      __dynamic_dev_dbg(& descriptor___15, (struct device  const  *)hsotg->dev, "HCDMAB\t @0x%08lX : 0x%08X\n",
                        (unsigned long )addr, tmp___29);
    } else {

    }
  } else {

  }
  i = i + 1;
  ldv_35030: ;
  if ((hsotg->core_params)->host_channels > i) {
    goto ldv_35029;
  } else {

  }

  return;
}
}
void dwc2_dump_global_registers(struct dwc2_hsotg *hsotg ) 
{ 
  u32 *addr ;
  struct _ddebug descriptor ;
  long tmp ;
  struct _ddebug descriptor___0 ;
  unsigned int tmp___0 ;
  long tmp___1 ;
  struct _ddebug descriptor___1 ;
  unsigned int tmp___2 ;
  long tmp___3 ;
  struct _ddebug descriptor___2 ;
  unsigned int tmp___4 ;
  long tmp___5 ;
  struct _ddebug descriptor___3 ;
  unsigned int tmp___6 ;
  long tmp___7 ;
  struct _ddebug descriptor___4 ;
  unsigned int tmp___8 ;
  long tmp___9 ;
  struct _ddebug descriptor___5 ;
  unsigned int tmp___10 ;
  long tmp___11 ;
  struct _ddebug descriptor___6 ;
  unsigned int tmp___12 ;
  long tmp___13 ;
  struct _ddebug descriptor___7 ;
  unsigned int tmp___14 ;
  long tmp___15 ;
  struct _ddebug descriptor___8 ;
  unsigned int tmp___16 ;
  long tmp___17 ;
  struct _ddebug descriptor___9 ;
  unsigned int tmp___18 ;
  long tmp___19 ;
  struct _ddebug descriptor___10 ;
  unsigned int tmp___20 ;
  long tmp___21 ;
  struct _ddebug descriptor___11 ;
  unsigned int tmp___22 ;
  long tmp___23 ;
  struct _ddebug descriptor___12 ;
  unsigned int tmp___24 ;
  long tmp___25 ;
  struct _ddebug descriptor___13 ;
  unsigned int tmp___26 ;
  long tmp___27 ;
  struct _ddebug descriptor___14 ;
  unsigned int tmp___28 ;
  long tmp___29 ;
  struct _ddebug descriptor___15 ;
  unsigned int tmp___30 ;
  long tmp___31 ;
    klee_make_symbolic(&tmp___31, sizeof(long), "tmp___31");
  struct _ddebug descriptor___16 ;
  unsigned int tmp___32 ;
    klee_make_symbolic(&tmp___32, sizeof(int), "tmp___32");
  long tmp___33 ;
    klee_make_symbolic(&tmp___33, sizeof(long), "tmp___33");
  struct _ddebug descriptor___17 ;
  unsigned int tmp___34 ;
    klee_make_symbolic(&tmp___34, sizeof(int), "tmp___34");
  long tmp___35 ;
    klee_make_symbolic(&tmp___35, sizeof(long), "tmp___35");
  struct _ddebug descriptor___18 ;
  unsigned int tmp___36 ;
    klee_make_symbolic(&tmp___36, sizeof(int), "tmp___36");
  long tmp___37 ;
    klee_make_symbolic(&tmp___37, sizeof(long), "tmp___37");
  struct _ddebug descriptor___19 ;
  unsigned int tmp___38 ;
    klee_make_symbolic(&tmp___38, sizeof(int), "tmp___38");
  long tmp___39 ;
    klee_make_symbolic(&tmp___39, sizeof(long), "tmp___39");
  struct _ddebug descriptor___20 ;
  unsigned int tmp___40 ;
    klee_make_symbolic(&tmp___40, sizeof(int), "tmp___40");
  long tmp___41 ;
    klee_make_symbolic(&tmp___41, sizeof(long), "tmp___41");
  struct _ddebug descriptor___21 ;
  unsigned int tmp___42 ;
    klee_make_symbolic(&tmp___42, sizeof(int), "tmp___42");
  long tmp___43 ;
    klee_make_symbolic(&tmp___43, sizeof(long), "tmp___43");
  struct _ddebug descriptor___22 ;
  unsigned int tmp___44 ;
    klee_make_symbolic(&tmp___44, sizeof(int), "tmp___44");
  long tmp___45 ;
    klee_make_symbolic(&tmp___45, sizeof(long), "tmp___45");
  struct _ddebug descriptor___23 ;
  unsigned int tmp___46 ;
    klee_make_symbolic(&tmp___46, sizeof(int), "tmp___46");
  long tmp___47 ;
    klee_make_symbolic(&tmp___47, sizeof(long), "tmp___47");
  struct _ddebug descriptor___24 ;
  unsigned int tmp___48 ;
    klee_make_symbolic(&tmp___48, sizeof(int), "tmp___48");
  long tmp___49 ;
    klee_make_symbolic(&tmp___49, sizeof(long), "tmp___49");

  {
  descriptor.modname = "dwc2";
  descriptor.function = "dwc2_dump_global_registers";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
  descriptor.format = "Core Global Registers\n";
  descriptor.lineno = 2263U;
  descriptor.flags = 1U;
  tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp != 0L) {
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "Core Global Registers\n");
  } else {

  }
  addr = (u32 *)hsotg->regs;
  descriptor___0.modname = "dwc2";
  descriptor___0.function = "dwc2_dump_global_registers";
  descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
  descriptor___0.format = "GOTGCTL\t @0x%08lX : 0x%08X\n";
  descriptor___0.lineno = 2266U;
  descriptor___0.flags = 1U;
  tmp___1 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
  if (tmp___1 != 0L) {
    tmp___0 = readl((void const volatile   *)addr);
    __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)hsotg->dev, "GOTGCTL\t @0x%08lX : 0x%08X\n",
                      (unsigned long )addr, tmp___0);
  } else {

  }
  addr = (u32 *)hsotg->regs + 4U;
  descriptor___1.modname = "dwc2";
  descriptor___1.function = "dwc2_dump_global_registers";
  descriptor___1.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
  descriptor___1.format = "GOTGINT\t @0x%08lX : 0x%08X\n";
  descriptor___1.lineno = 2269U;
  descriptor___1.flags = 1U;
  tmp___3 = ldv__builtin_expect((long )descriptor___1.flags & 1L, 0L);
  if (tmp___3 != 0L) {
    tmp___2 = readl((void const volatile   *)addr);
    __dynamic_dev_dbg(& descriptor___1, (struct device  const  *)hsotg->dev, "GOTGINT\t @0x%08lX : 0x%08X\n",
                      (unsigned long )addr, tmp___2);
  } else {

  }
  addr = (u32 *)hsotg->regs + 8U;
  descriptor___2.modname = "dwc2";
  descriptor___2.function = "dwc2_dump_global_registers";
  descriptor___2.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
  descriptor___2.format = "GAHBCFG\t @0x%08lX : 0x%08X\n";
  descriptor___2.lineno = 2272U;
  descriptor___2.flags = 1U;
  tmp___5 = ldv__builtin_expect((long )descriptor___2.flags & 1L, 0L);
  if (tmp___5 != 0L) {
    tmp___4 = readl((void const volatile   *)addr);
    __dynamic_dev_dbg(& descriptor___2, (struct device  const  *)hsotg->dev, "GAHBCFG\t @0x%08lX : 0x%08X\n",
                      (unsigned long )addr, tmp___4);
  } else {

  }
  addr = (u32 *)hsotg->regs + 12U;
  descriptor___3.modname = "dwc2";
  descriptor___3.function = "dwc2_dump_global_registers";
  descriptor___3.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
  descriptor___3.format = "GUSBCFG\t @0x%08lX : 0x%08X\n";
  descriptor___3.lineno = 2275U;
  descriptor___3.flags = 1U;
  tmp___7 = ldv__builtin_expect((long )descriptor___3.flags & 1L, 0L);
  if (tmp___7 != 0L) {
    tmp___6 = readl((void const volatile   *)addr);
    __dynamic_dev_dbg(& descriptor___3, (struct device  const  *)hsotg->dev, "GUSBCFG\t @0x%08lX : 0x%08X\n",
                      (unsigned long )addr, tmp___6);
  } else {

  }
  addr = (u32 *)hsotg->regs + 16U;
  descriptor___4.modname = "dwc2";
  descriptor___4.function = "dwc2_dump_global_registers";
  descriptor___4.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
  descriptor___4.format = "GRSTCTL\t @0x%08lX : 0x%08X\n";
  descriptor___4.lineno = 2278U;
  descriptor___4.flags = 1U;
  tmp___9 = ldv__builtin_expect((long )descriptor___4.flags & 1L, 0L);
  if (tmp___9 != 0L) {
    tmp___8 = readl((void const volatile   *)addr);
    __dynamic_dev_dbg(& descriptor___4, (struct device  const  *)hsotg->dev, "GRSTCTL\t @0x%08lX : 0x%08X\n",
                      (unsigned long )addr, tmp___8);
  } else {

  }
  addr = (u32 *)hsotg->regs + 20U;
  descriptor___5.modname = "dwc2";
  descriptor___5.function = "dwc2_dump_global_registers";
  descriptor___5.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
  descriptor___5.format = "GINTSTS\t @0x%08lX : 0x%08X\n";
  descriptor___5.lineno = 2281U;
  descriptor___5.flags = 1U;
  tmp___11 = ldv__builtin_expect((long )descriptor___5.flags & 1L, 0L);
  if (tmp___11 != 0L) {
    tmp___10 = readl((void const volatile   *)addr);
    __dynamic_dev_dbg(& descriptor___5, (struct device  const  *)hsotg->dev, "GINTSTS\t @0x%08lX : 0x%08X\n",
                      (unsigned long )addr, tmp___10);
  } else {

  }
  addr = (u32 *)hsotg->regs + 24U;
  descriptor___6.modname = "dwc2";
  descriptor___6.function = "dwc2_dump_global_registers";
  descriptor___6.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
  descriptor___6.format = "GINTMSK\t @0x%08lX : 0x%08X\n";
  descriptor___6.lineno = 2284U;
  descriptor___6.flags = 1U;
  tmp___13 = ldv__builtin_expect((long )descriptor___6.flags & 1L, 0L);
  if (tmp___13 != 0L) {
    tmp___12 = readl((void const volatile   *)addr);
    __dynamic_dev_dbg(& descriptor___6, (struct device  const  *)hsotg->dev, "GINTMSK\t @0x%08lX : 0x%08X\n",
                      (unsigned long )addr, tmp___12);
  } else {

  }
  addr = (u32 *)hsotg->regs + 28U;
  descriptor___7.modname = "dwc2";
  descriptor___7.function = "dwc2_dump_global_registers";
  descriptor___7.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
  descriptor___7.format = "GRXSTSR\t @0x%08lX : 0x%08X\n";
  descriptor___7.lineno = 2287U;
  descriptor___7.flags = 1U;
  tmp___15 = ldv__builtin_expect((long )descriptor___7.flags & 1L, 0L);
  if (tmp___15 != 0L) {
    tmp___14 = readl((void const volatile   *)addr);
    __dynamic_dev_dbg(& descriptor___7, (struct device  const  *)hsotg->dev, "GRXSTSR\t @0x%08lX : 0x%08X\n",
                      (unsigned long )addr, tmp___14);
  } else {

  }
  addr = (u32 *)hsotg->regs + 36U;
  descriptor___8.modname = "dwc2";
  descriptor___8.function = "dwc2_dump_global_registers";
  descriptor___8.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
  descriptor___8.format = "GRXFSIZ\t @0x%08lX : 0x%08X\n";
  descriptor___8.lineno = 2290U;
  descriptor___8.flags = 1U;
  tmp___17 = ldv__builtin_expect((long )descriptor___8.flags & 1L, 0L);
  if (tmp___17 != 0L) {
    tmp___16 = readl((void const volatile   *)addr);
    __dynamic_dev_dbg(& descriptor___8, (struct device  const  *)hsotg->dev, "GRXFSIZ\t @0x%08lX : 0x%08X\n",
                      (unsigned long )addr, tmp___16);
  } else {

  }
  addr = (u32 *)hsotg->regs + 40U;
  descriptor___9.modname = "dwc2";
  descriptor___9.function = "dwc2_dump_global_registers";
  descriptor___9.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
  descriptor___9.format = "GNPTXFSIZ\t @0x%08lX : 0x%08X\n";
  descriptor___9.lineno = 2293U;
  descriptor___9.flags = 1U;
  tmp___19 = ldv__builtin_expect((long )descriptor___9.flags & 1L, 0L);
  if (tmp___19 != 0L) {
    tmp___18 = readl((void const volatile   *)addr);
    __dynamic_dev_dbg(& descriptor___9, (struct device  const  *)hsotg->dev, "GNPTXFSIZ\t @0x%08lX : 0x%08X\n",
                      (unsigned long )addr, tmp___18);
  } else {

  }
  addr = (u32 *)hsotg->regs + 44U;
  descriptor___10.modname = "dwc2";
  descriptor___10.function = "dwc2_dump_global_registers";
  descriptor___10.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
  descriptor___10.format = "GNPTXSTS\t @0x%08lX : 0x%08X\n";
  descriptor___10.lineno = 2296U;
  descriptor___10.flags = 1U;
  tmp___21 = ldv__builtin_expect((long )descriptor___10.flags & 1L, 0L);
  if (tmp___21 != 0L) {
    tmp___20 = readl((void const volatile   *)addr);
    __dynamic_dev_dbg(& descriptor___10, (struct device  const  *)hsotg->dev, "GNPTXSTS\t @0x%08lX : 0x%08X\n",
                      (unsigned long )addr, tmp___20);
  } else {

  }
  addr = (u32 *)hsotg->regs + 48U;
  descriptor___11.modname = "dwc2";
  descriptor___11.function = "dwc2_dump_global_registers";
  descriptor___11.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
  descriptor___11.format = "GI2CCTL\t @0x%08lX : 0x%08X\n";
  descriptor___11.lineno = 2299U;
  descriptor___11.flags = 1U;
  tmp___23 = ldv__builtin_expect((long )descriptor___11.flags & 1L, 0L);
  if (tmp___23 != 0L) {
    tmp___22 = readl((void const volatile   *)addr);
    __dynamic_dev_dbg(& descriptor___11, (struct device  const  *)hsotg->dev, "GI2CCTL\t @0x%08lX : 0x%08X\n",
                      (unsigned long )addr, tmp___22);
  } else {

  }
  addr = (u32 *)hsotg->regs + 52U;
  descriptor___12.modname = "dwc2";
  descriptor___12.function = "dwc2_dump_global_registers";
  descriptor___12.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
  descriptor___12.format = "GPVNDCTL\t @0x%08lX : 0x%08X\n";
  descriptor___12.lineno = 2302U;
  descriptor___12.flags = 1U;
  tmp___25 = ldv__builtin_expect((long )descriptor___12.flags & 1L, 0L);
  if (tmp___25 != 0L) {
    tmp___24 = readl((void const volatile   *)addr);
    __dynamic_dev_dbg(& descriptor___12, (struct device  const  *)hsotg->dev, "GPVNDCTL\t @0x%08lX : 0x%08X\n",
                      (unsigned long )addr, tmp___24);
  } else {

  }
  addr = (u32 *)hsotg->regs + 56U;
  descriptor___13.modname = "dwc2";
  descriptor___13.function = "dwc2_dump_global_registers";
  descriptor___13.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
  descriptor___13.format = "GGPIO\t @0x%08lX : 0x%08X\n";
  descriptor___13.lineno = 2305U;
  descriptor___13.flags = 1U;
  tmp___27 = ldv__builtin_expect((long )descriptor___13.flags & 1L, 0L);
  if (tmp___27 != 0L) {
    tmp___26 = readl((void const volatile   *)addr);
    __dynamic_dev_dbg(& descriptor___13, (struct device  const  *)hsotg->dev, "GGPIO\t @0x%08lX : 0x%08X\n",
                      (unsigned long )addr, tmp___26);
  } else {

  }
  addr = (u32 *)hsotg->regs + 60U;
  descriptor___14.modname = "dwc2";
  descriptor___14.function = "dwc2_dump_global_registers";
  descriptor___14.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
  descriptor___14.format = "GUID\t @0x%08lX : 0x%08X\n";
  descriptor___14.lineno = 2308U;
  descriptor___14.flags = 1U;
  tmp___29 = ldv__builtin_expect((long )descriptor___14.flags & 1L, 0L);
  if (tmp___29 != 0L) {
    tmp___28 = readl((void const volatile   *)addr);
    __dynamic_dev_dbg(& descriptor___14, (struct device  const  *)hsotg->dev, "GUID\t @0x%08lX : 0x%08X\n",
                      (unsigned long )addr, tmp___28);
  } else {

  }
  addr = (u32 *)hsotg->regs + 64U;
  descriptor___15.modname = "dwc2";
  descriptor___15.function = "dwc2_dump_global_registers";
  descriptor___15.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
  descriptor___15.format = "GSNPSID\t @0x%08lX : 0x%08X\n";
  descriptor___15.lineno = 2311U;
  descriptor___15.flags = 1U;
  tmp___31 = ldv__builtin_expect((long )descriptor___15.flags & 1L, 0L);
  if (tmp___31 != 0L) {
    tmp___30 = readl((void const volatile   *)addr);
    __dynamic_dev_dbg(& descriptor___15, (struct device  const  *)hsotg->dev, "GSNPSID\t @0x%08lX : 0x%08X\n",
                      (unsigned long )addr, tmp___30);
  } else {

  }
  addr = (u32 *)hsotg->regs + 68U;
  descriptor___16.modname = "dwc2";
  descriptor___16.function = "dwc2_dump_global_registers";
  descriptor___16.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
  descriptor___16.format = "GHWCFG1\t @0x%08lX : 0x%08X\n";
  descriptor___16.lineno = 2314U;
  descriptor___16.flags = 1U;
  tmp___33 = ldv__builtin_expect((long )descriptor___16.flags & 1L, 0L);
  if (tmp___33 != 0L) {
    tmp___32 = readl((void const volatile   *)addr);
    __dynamic_dev_dbg(& descriptor___16, (struct device  const  *)hsotg->dev, "GHWCFG1\t @0x%08lX : 0x%08X\n",
                      (unsigned long )addr, tmp___32);
  } else {

  }
  addr = (u32 *)hsotg->regs + 72U;
  descriptor___17.modname = "dwc2";
  descriptor___17.function = "dwc2_dump_global_registers";
  descriptor___17.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
  descriptor___17.format = "GHWCFG2\t @0x%08lX : 0x%08X\n";
  descriptor___17.lineno = 2317U;
  descriptor___17.flags = 1U;
  tmp___35 = ldv__builtin_expect((long )descriptor___17.flags & 1L, 0L);
  if (tmp___35 != 0L) {
    tmp___34 = readl((void const volatile   *)addr);
    __dynamic_dev_dbg(& descriptor___17, (struct device  const  *)hsotg->dev, "GHWCFG2\t @0x%08lX : 0x%08X\n",
                      (unsigned long )addr, tmp___34);
  } else {

  }
  addr = (u32 *)hsotg->regs + 76U;
  descriptor___18.modname = "dwc2";
  descriptor___18.function = "dwc2_dump_global_registers";
  descriptor___18.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
  descriptor___18.format = "GHWCFG3\t @0x%08lX : 0x%08X\n";
  descriptor___18.lineno = 2320U;
  descriptor___18.flags = 1U;
  tmp___37 = ldv__builtin_expect((long )descriptor___18.flags & 1L, 0L);
  if (tmp___37 != 0L) {
    tmp___36 = readl((void const volatile   *)addr);
    __dynamic_dev_dbg(& descriptor___18, (struct device  const  *)hsotg->dev, "GHWCFG3\t @0x%08lX : 0x%08X\n",
                      (unsigned long )addr, tmp___36);
  } else {

  }
  addr = (u32 *)hsotg->regs + 80U;
  descriptor___19.modname = "dwc2";
  descriptor___19.function = "dwc2_dump_global_registers";
  descriptor___19.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
  descriptor___19.format = "GHWCFG4\t @0x%08lX : 0x%08X\n";
  descriptor___19.lineno = 2323U;
  descriptor___19.flags = 1U;
  tmp___39 = ldv__builtin_expect((long )descriptor___19.flags & 1L, 0L);
  if (tmp___39 != 0L) {
    tmp___38 = readl((void const volatile   *)addr);
    __dynamic_dev_dbg(& descriptor___19, (struct device  const  *)hsotg->dev, "GHWCFG4\t @0x%08lX : 0x%08X\n",
                      (unsigned long )addr, tmp___38);
  } else {

  }
  addr = (u32 *)hsotg->regs + 84U;
  descriptor___20.modname = "dwc2";
  descriptor___20.function = "dwc2_dump_global_registers";
  descriptor___20.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
  descriptor___20.format = "GLPMCFG\t @0x%08lX : 0x%08X\n";
  descriptor___20.lineno = 2326U;
  descriptor___20.flags = 1U;
  tmp___41 = ldv__builtin_expect((long )descriptor___20.flags & 1L, 0L);
  if (tmp___41 != 0L) {
    tmp___40 = readl((void const volatile   *)addr);
    __dynamic_dev_dbg(& descriptor___20, (struct device  const  *)hsotg->dev, "GLPMCFG\t @0x%08lX : 0x%08X\n",
                      (unsigned long )addr, tmp___40);
  } else {

  }
  addr = (u32 *)hsotg->regs + 88U;
  descriptor___21.modname = "dwc2";
  descriptor___21.function = "dwc2_dump_global_registers";
  descriptor___21.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
  descriptor___21.format = "GPWRDN\t @0x%08lX : 0x%08X\n";
  descriptor___21.lineno = 2329U;
  descriptor___21.flags = 1U;
  tmp___43 = ldv__builtin_expect((long )descriptor___21.flags & 1L, 0L);
  if (tmp___43 != 0L) {
    tmp___42 = readl((void const volatile   *)addr);
    __dynamic_dev_dbg(& descriptor___21, (struct device  const  *)hsotg->dev, "GPWRDN\t @0x%08lX : 0x%08X\n",
                      (unsigned long )addr, tmp___42);
  } else {

  }
  addr = (u32 *)hsotg->regs + 92U;
  descriptor___22.modname = "dwc2";
  descriptor___22.function = "dwc2_dump_global_registers";
  descriptor___22.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
  descriptor___22.format = "GDFIFOCFG\t @0x%08lX : 0x%08X\n";
  descriptor___22.lineno = 2332U;
  descriptor___22.flags = 1U;
  tmp___45 = ldv__builtin_expect((long )descriptor___22.flags & 1L, 0L);
  if (tmp___45 != 0L) {
    tmp___44 = readl((void const volatile   *)addr);
    __dynamic_dev_dbg(& descriptor___22, (struct device  const  *)hsotg->dev, "GDFIFOCFG\t @0x%08lX : 0x%08X\n",
                      (unsigned long )addr, tmp___44);
  } else {

  }
  addr = (u32 *)hsotg->regs + 256U;
  descriptor___23.modname = "dwc2";
  descriptor___23.function = "dwc2_dump_global_registers";
  descriptor___23.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
  descriptor___23.format = "HPTXFSIZ\t @0x%08lX : 0x%08X\n";
  descriptor___23.lineno = 2335U;
  descriptor___23.flags = 1U;
  tmp___47 = ldv__builtin_expect((long )descriptor___23.flags & 1L, 0L);
  if (tmp___47 != 0L) {
    tmp___46 = readl((void const volatile   *)addr);
    __dynamic_dev_dbg(& descriptor___23, (struct device  const  *)hsotg->dev, "HPTXFSIZ\t @0x%08lX : 0x%08X\n",
                      (unsigned long )addr, tmp___46);
  } else {

  }
  addr = (u32 *)hsotg->regs + 3584U;
  descriptor___24.modname = "dwc2";
  descriptor___24.function = "dwc2_dump_global_registers";
  descriptor___24.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
  descriptor___24.format = "PCGCTL\t @0x%08lX : 0x%08X\n";
  descriptor___24.lineno = 2339U;
  descriptor___24.flags = 1U;
  tmp___49 = ldv__builtin_expect((long )descriptor___24.flags & 1L, 0L);
  if (tmp___49 != 0L) {
    tmp___48 = readl((void const volatile   *)addr);
    __dynamic_dev_dbg(& descriptor___24, (struct device  const  *)hsotg->dev, "PCGCTL\t @0x%08lX : 0x%08X\n",
                      (unsigned long )addr, tmp___48);
  } else {

  }
  return;
}
}
void dwc2_flush_tx_fifo(struct dwc2_hsotg *hsotg , int const   num ) 
{ 
  u32 greset ;
  int count ;
  struct _ddebug descriptor ;
  long tmp ;
  unsigned int tmp___0 ;

  {
  count = 0;
  descriptor.modname = "dwc2";
  descriptor.function = "dwc2_flush_tx_fifo";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
  descriptor.format = "Flush Tx FIFO %d\n";
  descriptor.lineno = 2354U;
  descriptor.flags = 1U;
  tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp != 0L) {
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "Flush Tx FIFO %d\n",
                      num);
  } else {

  }
  greset = 32U;
  greset = ((u32 )(num << 6) & 1984U) | greset;
  writel(greset, (void volatile   *)hsotg->regs + 16U);
  ldv_35072: 
  greset = readl((void const volatile   *)hsotg->regs + 16U);
  count = count + 1;
  if (count > 10000) {
    tmp___0 = readl((void const volatile   *)hsotg->regs + 44U);
    dev_warn((struct device  const  *)hsotg->dev, "%s() HANG! GRSTCTL=%0x GNPTXSTS=0x%08x\n",
             "dwc2_flush_tx_fifo", greset, tmp___0);
    goto ldv_35071;
  } else {

  }
  __const_udelay(4295UL);
  if ((greset & 32U) != 0U) {
    goto ldv_35072;
  } else {

  }
  ldv_35071: 
  __const_udelay(4295UL);
  return;
}
}
void dwc2_flush_rx_fifo(struct dwc2_hsotg *hsotg ) 
{ 
  u32 greset ;
  int count ;
  struct _ddebug descriptor ;
  long tmp ;

  {
  count = 0;
  descriptor.modname = "dwc2";
  descriptor.function = "dwc2_flush_rx_fifo";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
  descriptor.format = "%s()\n";
  descriptor.lineno = 2386U;
  descriptor.flags = 1U;
  tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp != 0L) {
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "%s()\n",
                      "dwc2_flush_rx_fifo");
  } else {

  }
  greset = 16U;
  writel(greset, (void volatile   *)hsotg->regs + 16U);
  ldv_35081: 
  greset = readl((void const volatile   *)hsotg->regs + 16U);
  count = count + 1;
  if (count > 10000) {
    dev_warn((struct device  const  *)hsotg->dev, "%s() HANG! GRSTCTL=%0x\n", "dwc2_flush_rx_fifo",
             greset);
    goto ldv_35080;
  } else {

  }
  __const_udelay(4295UL);
  if ((greset & 16U) != 0U) {
    goto ldv_35081;
  } else {

  }
  ldv_35080: 
  __const_udelay(4295UL);
  return;
}
}
void dwc2_set_param_otg_cap(struct dwc2_hsotg *hsotg , int val ) 
{ 
  int valid ;
    klee_make_symbolic(&valid, sizeof(int), "valid");
  struct _ddebug descriptor ;
  long tmp ;

  {
  valid = 1;
  switch (val) {
  case 0: ;
  if ((unsigned int )*((unsigned char *)hsotg + 16UL) != 0U) {
    valid = 0;
  } else {

  }
  goto ldv_35088;
  case 1: ;
  switch ((int )hsotg->hw_params.op_mode) {
  case 0: ;
  case 1: ;
  case 3: ;
  case 5: ;
  goto ldv_35094;
  default: 
  valid = 0;
  goto ldv_35094;
  }
  ldv_35094: ;
  goto ldv_35088;
  case 2: ;
  goto ldv_35088;
  default: 
  valid = 0;
  goto ldv_35088;
  }
  ldv_35088: ;
  if (valid == 0) {
    if (val >= 0) {
      dev_err((struct device  const  *)hsotg->dev, "%d invalid for otg_cap parameter. Check HW configuration.\n",
              val);
    } else {

    }
    switch ((int )hsotg->hw_params.op_mode) {
    case 0: 
    val = 0;
    goto ldv_35099;
    case 1: ;
    case 3: ;
    case 5: 
    val = 1;
    goto ldv_35099;
    default: 
    val = 2;
    goto ldv_35099;
    }
    ldv_35099: 
    descriptor.modname = "dwc2";
    descriptor.function = "dwc2_set_param_otg_cap";
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
    descriptor.format = "Setting otg_cap to %d\n";
    descriptor.lineno = 2455U;
    descriptor.flags = 1U;
    tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
    if (tmp != 0L) {
      __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "Setting otg_cap to %d\n",
                        val);
    } else {

    }
  } else {

  }
  (hsotg->core_params)->otg_cap = val;
  return;
}
}
void dwc2_set_param_dma_enable(struct dwc2_hsotg *hsotg , int val ) 
{ 
  int valid ;
  struct _ddebug descriptor ;
  long tmp ;

  {
  valid = 1;
  if (val > 0 && (unsigned int )*((unsigned char *)hsotg + 16UL) == 0U) {
    valid = 0;
  } else {

  }
  if (val < 0) {
    valid = 0;
  } else {

  }
  if (valid == 0) {
    if (val >= 0) {
      dev_err((struct device  const  *)hsotg->dev, "%d invalid for dma_enable parameter. Check HW configuration.\n",
              val);
    } else {

    }
    val = (unsigned int )*((unsigned char *)hsotg + 16UL) != 0U;
    descriptor.modname = "dwc2";
    descriptor.function = "dwc2_set_param_dma_enable";
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
    descriptor.format = "Setting dma_enable to %d\n";
    descriptor.lineno = 2476U;
    descriptor.flags = 1U;
    tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
    if (tmp != 0L) {
      __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "Setting dma_enable to %d\n",
                        val);
    } else {

    }
  } else {

  }
  (hsotg->core_params)->dma_enable = val;
  return;
}
}
void dwc2_set_param_dma_desc_enable(struct dwc2_hsotg *hsotg , int val ) 
{ 
  int valid ;
  struct _ddebug descriptor ;
  long tmp ;

  {
  valid = 1;
  if (val > 0 && ((hsotg->core_params)->dma_enable <= 0 || (unsigned int )*((unsigned char *)hsotg + 16UL) == 0U)) {
    valid = 0;
  } else {

  }
  if (val < 0) {
    valid = 0;
  } else {

  }
  if (valid == 0) {
    if (val >= 0) {
      dev_err((struct device  const  *)hsotg->dev, "%d invalid for dma_desc_enable parameter. Check HW configuration.\n",
              val);
    } else {

    }
    val = (hsotg->core_params)->dma_enable > 0 && (unsigned int )*((unsigned char *)hsotg + 16UL) != 0U;
    descriptor.modname = "dwc2";
    descriptor.function = "dwc2_set_param_dma_desc_enable";
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
    descriptor.format = "Setting dma_desc_enable to %d\n";
    descriptor.lineno = 2499U;
    descriptor.flags = 1U;
    tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
    if (tmp != 0L) {
      __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "Setting dma_desc_enable to %d\n",
                        val);
    } else {

    }
  } else {

  }
  (hsotg->core_params)->dma_desc_enable = val;
  return;
}
}
void dwc2_set_param_host_support_fs_ls_low_power(struct dwc2_hsotg *hsotg , int val ) 
{ 
  struct _ddebug descriptor ;
  long tmp ;

  {
  if (val < 0 || val > 1) {
    if (val >= 0) {
      dev_err((struct device  const  *)hsotg->dev, "Wrong value for host_support_fs_low_power\n");
      dev_err((struct device  const  *)hsotg->dev, "host_support_fs_low_power must be 0 or 1\n");
    } else {

    }
    val = 0;
    descriptor.modname = "dwc2";
    descriptor.function = "dwc2_set_param_host_support_fs_ls_low_power";
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
    descriptor.format = "Setting host_support_fs_low_power to %d\n";
    descriptor.lineno = 2517U;
    descriptor.flags = 1U;
    tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
    if (tmp != 0L) {
      __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "Setting host_support_fs_low_power to %d\n",
                        val);
    } else {

    }
  } else {

  }
  (hsotg->core_params)->host_support_fs_ls_low_power = val;
  return;
}
}
void dwc2_set_param_enable_dynamic_fifo(struct dwc2_hsotg *hsotg , int val ) 
{ 
  int valid ;
  struct _ddebug descriptor ;
  long tmp ;

  {
  valid = 1;
  if (val > 0 && (unsigned int )*((unsigned char *)hsotg + 16UL) == 0U) {
    valid = 0;
  } else {

  }
  if (val < 0) {
    valid = 0;
  } else {

  }
  if (valid == 0) {
    if (val >= 0) {
      dev_err((struct device  const  *)hsotg->dev, "%d invalid for enable_dynamic_fifo parameter. Check HW configuration.\n",
              val);
    } else {

    }
    val = (int )hsotg->hw_params.enable_dynamic_fifo;
    descriptor.modname = "dwc2";
    descriptor.function = "dwc2_set_param_enable_dynamic_fifo";
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
    descriptor.format = "Setting enable_dynamic_fifo to %d\n";
    descriptor.lineno = 2538U;
    descriptor.flags = 1U;
    tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
    if (tmp != 0L) {
      __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "Setting enable_dynamic_fifo to %d\n",
                        val);
    } else {

    }
  } else {

  }
  (hsotg->core_params)->enable_dynamic_fifo = val;
  return;
}
}
void dwc2_set_param_host_rx_fifo_size(struct dwc2_hsotg *hsotg , int val ) 
{ 
  int valid ;
  struct _ddebug descriptor ;
  long tmp ;

  {
  valid = 1;
  if (val <= 15 || (int )hsotg->hw_params.host_rx_fifo_size < val) {
    valid = 0;
  } else {

  }
  if (valid == 0) {
    if (val >= 0) {
      dev_err((struct device  const  *)hsotg->dev, "%d invalid for host_rx_fifo_size. Check HW configuration.\n",
              val);
    } else {

    }
    val = (int )hsotg->hw_params.host_rx_fifo_size;
    descriptor.modname = "dwc2";
    descriptor.function = "dwc2_set_param_host_rx_fifo_size";
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
    descriptor.format = "Setting host_rx_fifo_size to %d\n";
    descriptor.lineno = 2557U;
    descriptor.flags = 1U;
    tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
    if (tmp != 0L) {
      __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "Setting host_rx_fifo_size to %d\n",
                        val);
    } else {

    }
  } else {

  }
  (hsotg->core_params)->host_rx_fifo_size = val;
  return;
}
}
void dwc2_set_param_host_nperio_tx_fifo_size(struct dwc2_hsotg *hsotg , int val ) 
{ 
  int valid ;
  struct _ddebug descriptor ;
  long tmp ;

  {
  valid = 1;
  if (val <= 15 || (int )hsotg->hw_params.host_nperio_tx_fifo_size < val) {
    valid = 0;
  } else {

  }
  if (valid == 0) {
    if (val >= 0) {
      dev_err((struct device  const  *)hsotg->dev, "%d invalid for host_nperio_tx_fifo_size. Check HW configuration.\n",
              val);
    } else {

    }
    val = (int )hsotg->hw_params.host_nperio_tx_fifo_size;
    descriptor.modname = "dwc2";
    descriptor.function = "dwc2_set_param_host_nperio_tx_fifo_size";
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
    descriptor.format = "Setting host_nperio_tx_fifo_size to %d\n";
    descriptor.lineno = 2577U;
    descriptor.flags = 1U;
    tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
    if (tmp != 0L) {
      __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "Setting host_nperio_tx_fifo_size to %d\n",
                        val);
    } else {

    }
  } else {

  }
  (hsotg->core_params)->host_nperio_tx_fifo_size = val;
  return;
}
}
void dwc2_set_param_host_perio_tx_fifo_size(struct dwc2_hsotg *hsotg , int val ) 
{ 
  int valid ;
  struct _ddebug descriptor ;
  long tmp ;

  {
  valid = 1;
  if (val <= 15 || (int )hsotg->hw_params.host_perio_tx_fifo_size < val) {
    valid = 0;
  } else {

  }
  if (valid == 0) {
    if (val >= 0) {
      dev_err((struct device  const  *)hsotg->dev, "%d invalid for host_perio_tx_fifo_size. Check HW configuration.\n",
              val);
    } else {

    }
    val = (int )hsotg->hw_params.host_perio_tx_fifo_size;
    descriptor.modname = "dwc2";
    descriptor.function = "dwc2_set_param_host_perio_tx_fifo_size";
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
    descriptor.format = "Setting host_perio_tx_fifo_size to %d\n";
    descriptor.lineno = 2597U;
    descriptor.flags = 1U;
    tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
    if (tmp != 0L) {
      __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "Setting host_perio_tx_fifo_size to %d\n",
                        val);
    } else {

    }
  } else {

  }
  (hsotg->core_params)->host_perio_tx_fifo_size = val;
  return;
}
}
void dwc2_set_param_max_transfer_size(struct dwc2_hsotg *hsotg , int val ) 
{ 
  int valid ;
  struct _ddebug descriptor ;
  long tmp ;

  {
  valid = 1;
  if (val <= 2046 || (int )hsotg->hw_params.max_transfer_size < val) {
    valid = 0;
  } else {

  }
  if (valid == 0) {
    if (val >= 0) {
      dev_err((struct device  const  *)hsotg->dev, "%d invalid for max_transfer_size. Check HW configuration.\n",
              val);
    } else {

    }
    val = (int )hsotg->hw_params.max_transfer_size;
    descriptor.modname = "dwc2";
    descriptor.function = "dwc2_set_param_max_transfer_size";
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
    descriptor.format = "Setting max_transfer_size to %d\n";
    descriptor.lineno = 2616U;
    descriptor.flags = 1U;
    tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
    if (tmp != 0L) {
      __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "Setting max_transfer_size to %d\n",
                        val);
    } else {

    }
  } else {

  }
  (hsotg->core_params)->max_transfer_size = val;
  return;
}
}
void dwc2_set_param_max_packet_count(struct dwc2_hsotg *hsotg , int val ) 
{ 
  int valid ;
  struct _ddebug descriptor ;
  long tmp ;

  {
  valid = 1;
  if (val <= 14 || (int )hsotg->hw_params.max_packet_count < val) {
    valid = 0;
  } else {

  }
  if (valid == 0) {
    if (val >= 0) {
      dev_err((struct device  const  *)hsotg->dev, "%d invalid for max_packet_count. Check HW configuration.\n",
              val);
    } else {

    }
    val = (int )hsotg->hw_params.max_packet_count;
    descriptor.modname = "dwc2";
    descriptor.function = "dwc2_set_param_max_packet_count";
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
    descriptor.format = "Setting max_packet_count to %d\n";
    descriptor.lineno = 2635U;
    descriptor.flags = 1U;
    tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
    if (tmp != 0L) {
      __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "Setting max_packet_count to %d\n",
                        val);
    } else {

    }
  } else {

  }
  (hsotg->core_params)->max_packet_count = val;
  return;
}
}
void dwc2_set_param_host_channels(struct dwc2_hsotg *hsotg , int val ) 
{ 
  int valid ;
  struct _ddebug descriptor ;
  long tmp ;

  {
  valid = 1;
  if (val <= 0 || (int )hsotg->hw_params.host_channels < val) {
    valid = 0;
  } else {

  }
  if (valid == 0) {
    if (val >= 0) {
      dev_err((struct device  const  *)hsotg->dev, "%d invalid for host_channels. Check HW configuration.\n",
              val);
    } else {

    }
    val = (int )hsotg->hw_params.host_channels;
    descriptor.modname = "dwc2";
    descriptor.function = "dwc2_set_param_host_channels";
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
    descriptor.format = "Setting host_channels to %d\n";
    descriptor.lineno = 2654U;
    descriptor.flags = 1U;
    tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
    if (tmp != 0L) {
      __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "Setting host_channels to %d\n",
                        val);
    } else {

    }
  } else {

  }
  (hsotg->core_params)->host_channels = val;
  return;
}
}
void dwc2_set_param_phy_type(struct dwc2_hsotg *hsotg , int val ) 
{ 
  int valid ;
  u32 hs_phy_type ;
  u32 fs_phy_type ;
  struct _ddebug descriptor ;
  long tmp ;

  {
  valid = 0;
  if (val < 0 || val > 2) {
    if (val >= 0) {
      dev_err((struct device  const  *)hsotg->dev, "Wrong value for phy_type\n");
      dev_err((struct device  const  *)hsotg->dev, "phy_type must be 0, 1 or 2\n");
    } else {

    }
    valid = 0;
  } else {

  }
  hs_phy_type = (u32 )hsotg->hw_params.hs_phy_type;
  fs_phy_type = (u32 )hsotg->hw_params.fs_phy_type;
  if (val == 1 && (hs_phy_type == 1U || hs_phy_type == 3U)) {
    valid = 1;
  } else
  if (val == 2 && (hs_phy_type == 2U || hs_phy_type == 3U)) {
    valid = 1;
  } else
  if (val == 0 && fs_phy_type == 1U) {
    valid = 1;
  } else {

  }
  if (valid == 0) {
    if (val >= 0) {
      dev_err((struct device  const  *)hsotg->dev, "%d invalid for phy_type. Check HW configuration.\n",
              val);
    } else {

    }
    val = 0;
    if (hs_phy_type != 0U) {
      if (hs_phy_type == 1U || hs_phy_type == 3U) {
        val = 1;
      } else {
        val = 2;
      }
    } else {

    }
    descriptor.modname = "dwc2";
    descriptor.function = "dwc2_set_param_phy_type";
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
    descriptor.format = "Setting phy_type to %d\n";
    descriptor.lineno = 2702U;
    descriptor.flags = 1U;
    tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
    if (tmp != 0L) {
      __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "Setting phy_type to %d\n",
                        val);
    } else {

    }
  } else {

  }
  (hsotg->core_params)->phy_type = val;
  return;
}
}
static int dwc2_get_param_phy_type(struct dwc2_hsotg *hsotg ) 
{ 


  {
  return ((hsotg->core_params)->phy_type);
}
}
void dwc2_set_param_speed(struct dwc2_hsotg *hsotg , int val ) 
{ 
  int valid ;
  int tmp ;
  int tmp___0 ;
  struct _ddebug descriptor ;
  long tmp___1 ;

  {
  valid = 1;
  if (val < 0 || val > 1) {
    if (val >= 0) {
      dev_err((struct device  const  *)hsotg->dev, "Wrong value for speed parameter\n");
      dev_err((struct device  const  *)hsotg->dev, "max_speed parameter must be 0 or 1\n");
    } else {

    }
    valid = 0;
  } else {

  }
  if (val == 0) {
    tmp = dwc2_get_param_phy_type(hsotg);
    if (tmp == 0) {
      valid = 0;
    } else {

    }
  } else {

  }
  if (valid == 0) {
    if (val >= 0) {
      dev_err((struct device  const  *)hsotg->dev, "%d invalid for speed parameter. Check HW configuration.\n",
              val);
    } else {

    }
    tmp___0 = dwc2_get_param_phy_type(hsotg);
    val = tmp___0 == 0;
    descriptor.modname = "dwc2";
    descriptor.function = "dwc2_set_param_speed";
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
    descriptor.format = "Setting speed to %d\n";
    descriptor.lineno = 2736U;
    descriptor.flags = 1U;
    tmp___1 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
    if (tmp___1 != 0L) {
      __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "Setting speed to %d\n",
                        val);
    } else {

    }
  } else {

  }
  (hsotg->core_params)->speed = val;
  return;
}
}
void dwc2_set_param_host_ls_low_power_phy_clk(struct dwc2_hsotg *hsotg , int val ) 
{ 
  int valid ;
  int tmp ;
  int tmp___0 ;
  struct _ddebug descriptor ;
  long tmp___1 ;

  {
  valid = 1;
  if (val < 0 || val > 1) {
    if (val >= 0) {
      dev_err((struct device  const  *)hsotg->dev, "Wrong value for host_ls_low_power_phy_clk parameter\n");
      dev_err((struct device  const  *)hsotg->dev, "host_ls_low_power_phy_clk must be 0 or 1\n");
    } else {

    }
    valid = 0;
  } else {

  }
  if (val == 0) {
    tmp = dwc2_get_param_phy_type(hsotg);
    if (tmp == 0) {
      valid = 0;
    } else {

    }
  } else {

  }
  if (valid == 0) {
    if (val >= 0) {
      dev_err((struct device  const  *)hsotg->dev, "%d invalid for host_ls_low_power_phy_clk. Check HW configuration.\n",
              val);
    } else {

    }
    tmp___0 = dwc2_get_param_phy_type(hsotg);
    val = tmp___0 == 0;
    descriptor.modname = "dwc2";
    descriptor.function = "dwc2_set_param_host_ls_low_power_phy_clk";
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
    descriptor.format = "Setting host_ls_low_power_phy_clk to %d\n";
    descriptor.lineno = 2770U;
    descriptor.flags = 1U;
    tmp___1 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
    if (tmp___1 != 0L) {
      __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "Setting host_ls_low_power_phy_clk to %d\n",
                        val);
    } else {

    }
  } else {

  }
  (hsotg->core_params)->host_ls_low_power_phy_clk = val;
  return;
}
}
void dwc2_set_param_phy_ulpi_ddr(struct dwc2_hsotg *hsotg , int val ) 
{ 
  struct _ddebug descriptor ;
  long tmp ;

  {
  if (val < 0 || val > 1) {
    if (val >= 0) {
      dev_err((struct device  const  *)hsotg->dev, "Wrong value for phy_ulpi_ddr\n");
      dev_err((struct device  const  *)hsotg->dev, "phy_upli_ddr must be 0 or 1\n");
    } else {

    }
    val = 0;
    descriptor.modname = "dwc2";
    descriptor.function = "dwc2_set_param_phy_ulpi_ddr";
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
    descriptor.format = "Setting phy_upli_ddr to %d\n";
    descriptor.lineno = 2784U;
    descriptor.flags = 1U;
    tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
    if (tmp != 0L) {
      __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "Setting phy_upli_ddr to %d\n",
                        val);
    } else {

    }
  } else {

  }
  (hsotg->core_params)->phy_ulpi_ddr = val;
  return;
}
}
void dwc2_set_param_phy_ulpi_ext_vbus(struct dwc2_hsotg *hsotg , int val ) 
{ 
  struct _ddebug descriptor ;
  long tmp ;

  {
  if (val < 0 || val > 1) {
    if (val >= 0) {
      dev_err((struct device  const  *)hsotg->dev, "Wrong value for phy_ulpi_ext_vbus\n");
      dev_err((struct device  const  *)hsotg->dev, "phy_ulpi_ext_vbus must be 0 or 1\n");
    } else {

    }
    val = 0;
    descriptor.modname = "dwc2";
    descriptor.function = "dwc2_set_param_phy_ulpi_ext_vbus";
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
    descriptor.format = "Setting phy_ulpi_ext_vbus to %d\n";
    descriptor.lineno = 2800U;
    descriptor.flags = 1U;
    tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
    if (tmp != 0L) {
      __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "Setting phy_ulpi_ext_vbus to %d\n",
                        val);
    } else {

    }
  } else {

  }
  (hsotg->core_params)->phy_ulpi_ext_vbus = val;
  return;
}
}
void dwc2_set_param_phy_utmi_width(struct dwc2_hsotg *hsotg , int val ) 
{ 
  int valid ;
  struct _ddebug descriptor ;
  long tmp ;

  {
  valid = 0;
  switch ((int )hsotg->hw_params.utmi_phy_data_width) {
  case 0: 
  valid = val == 8;
  goto ldv_35219;
  case 1: 
  valid = val == 16;
  goto ldv_35219;
  case 2: 
  valid = val == 8 || val == 16;
  goto ldv_35219;
  }
  ldv_35219: ;
  if (valid == 0) {
    if (val >= 0) {
      dev_err((struct device  const  *)hsotg->dev, "%d invalid for phy_utmi_width. Check HW configuration.\n",
              val);
    } else {

    }
    val = (unsigned int )*((unsigned char *)hsotg + 38UL) == 0U ? 8 : 16;
    descriptor.modname = "dwc2";
    descriptor.function = "dwc2_set_param_phy_utmi_width";
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
    descriptor.format = "Setting phy_utmi_width to %d\n";
    descriptor.lineno = 2830U;
    descriptor.flags = 1U;
    tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
    if (tmp != 0L) {
      __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "Setting phy_utmi_width to %d\n",
                        val);
    } else {

    }
  } else {

  }
  (hsotg->core_params)->phy_utmi_width = val;
  return;
}
}
void dwc2_set_param_ulpi_fs_ls(struct dwc2_hsotg *hsotg , int val ) 
{ 
  struct _ddebug descriptor ;
  long tmp ;

  {
  if (val < 0 || val > 1) {
    if (val >= 0) {
      dev_err((struct device  const  *)hsotg->dev, "Wrong value for ulpi_fs_ls\n");
      dev_err((struct device  const  *)hsotg->dev, "ulpi_fs_ls must be 0 or 1\n");
    } else {

    }
    val = 0;
    descriptor.modname = "dwc2";
    descriptor.function = "dwc2_set_param_ulpi_fs_ls";
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
    descriptor.format = "Setting ulpi_fs_ls to %d\n";
    descriptor.lineno = 2844U;
    descriptor.flags = 1U;
    tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
    if (tmp != 0L) {
      __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "Setting ulpi_fs_ls to %d\n",
                        val);
    } else {

    }
  } else {

  }
  (hsotg->core_params)->ulpi_fs_ls = val;
  return;
}
}
void dwc2_set_param_ts_dline(struct dwc2_hsotg *hsotg , int val ) 
{ 
  struct _ddebug descriptor ;
  long tmp ;

  {
  if (val < 0 || val > 1) {
    if (val >= 0) {
      dev_err((struct device  const  *)hsotg->dev, "Wrong value for ts_dline\n");
      dev_err((struct device  const  *)hsotg->dev, "ts_dline must be 0 or 1\n");
    } else {

    }
    val = 0;
    descriptor.modname = "dwc2";
    descriptor.function = "dwc2_set_param_ts_dline";
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
    descriptor.format = "Setting ts_dline to %d\n";
    descriptor.lineno = 2858U;
    descriptor.flags = 1U;
    tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
    if (tmp != 0L) {
      __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "Setting ts_dline to %d\n",
                        val);
    } else {

    }
  } else {

  }
  (hsotg->core_params)->ts_dline = val;
  return;
}
}
void dwc2_set_param_i2c_enable(struct dwc2_hsotg *hsotg , int val ) 
{ 
  int valid ;
  struct _ddebug descriptor ;
  long tmp ;

  {
  valid = 1;
  if (val < 0 || val > 1) {
    if (val >= 0) {
      dev_err((struct device  const  *)hsotg->dev, "Wrong value for i2c_enable\n");
      dev_err((struct device  const  *)hsotg->dev, "i2c_enable must be 0 or 1\n");
    } else {

    }
    valid = 0;
  } else {

  }
  if (val == 1 && (unsigned int )*((unsigned char *)hsotg + 34UL) == 0U) {
    valid = 0;
  } else {

  }
  if (valid == 0) {
    if (val >= 0) {
      dev_err((struct device  const  *)hsotg->dev, "%d invalid for i2c_enable. Check HW configuration.\n",
              val);
    } else {

    }
    val = (int )hsotg->hw_params.i2c_enable;
    descriptor.modname = "dwc2";
    descriptor.function = "dwc2_set_param_i2c_enable";
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
    descriptor.format = "Setting i2c_enable to %d\n";
    descriptor.lineno = 2886U;
    descriptor.flags = 1U;
    tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
    if (tmp != 0L) {
      __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "Setting i2c_enable to %d\n",
                        val);
    } else {

    }
  } else {

  }
  (hsotg->core_params)->i2c_enable = val;
  return;
}
}
void dwc2_set_param_en_multiple_tx_fifo(struct dwc2_hsotg *hsotg , int val ) 
{ 
  int valid ;
  struct _ddebug descriptor ;
  long tmp ;

  {
  valid = 1;
  if (val < 0 || val > 1) {
    if (val >= 0) {
      dev_err((struct device  const  *)hsotg->dev, "Wrong value for en_multiple_tx_fifo,\n");
      dev_err((struct device  const  *)hsotg->dev, "en_multiple_tx_fifo must be 0 or 1\n");
    } else {

    }
    valid = 0;
  } else {

  }
  if (val == 1 && (unsigned int )*((unsigned char *)hsotg + 16UL) == 0U) {
    valid = 0;
  } else {

  }
  if (valid == 0) {
    if (val >= 0) {
      dev_err((struct device  const  *)hsotg->dev, "%d invalid for parameter en_multiple_tx_fifo. Check HW configuration.\n",
              val);
    } else {

    }
    val = (int )hsotg->hw_params.en_multiple_tx_fifo;
    descriptor.modname = "dwc2";
    descriptor.function = "dwc2_set_param_en_multiple_tx_fifo";
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
    descriptor.format = "Setting en_multiple_tx_fifo to %d\n";
    descriptor.lineno = 2915U;
    descriptor.flags = 1U;
    tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
    if (tmp != 0L) {
      __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "Setting en_multiple_tx_fifo to %d\n",
                        val);
    } else {

    }
  } else {

  }
  (hsotg->core_params)->en_multiple_tx_fifo = val;
  return;
}
}
void dwc2_set_param_reload_ctl(struct dwc2_hsotg *hsotg , int val ) 
{ 
  int valid ;
  struct _ddebug descriptor ;
  long tmp ;

  {
  valid = 1;
  if (val < 0 || val > 1) {
    if (val >= 0) {
      dev_err((struct device  const  *)hsotg->dev, "\'%d\' invalid for parameter reload_ctl\n",
              val);
      dev_err((struct device  const  *)hsotg->dev, "reload_ctl must be 0 or 1\n");
    } else {

    }
    valid = 0;
  } else {

  }
  if (val == 1 && hsotg->hw_params.snpsid <= 1330915625U) {
    valid = 0;
  } else {

  }
  if (valid == 0) {
    if (val >= 0) {
      dev_err((struct device  const  *)hsotg->dev, "%d invalid for parameter reload_ctl. Check HW configuration.\n",
              val);
    } else {

    }
    val = hsotg->hw_params.snpsid > 1330915625U;
    descriptor.modname = "dwc2";
    descriptor.function = "dwc2_set_param_reload_ctl";
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
    descriptor.format = "Setting reload_ctl to %d\n";
    descriptor.lineno = 2943U;
    descriptor.flags = 1U;
    tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
    if (tmp != 0L) {
      __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "Setting reload_ctl to %d\n",
                        val);
    } else {

    }
  } else {

  }
  (hsotg->core_params)->reload_ctl = val;
  return;
}
}
void dwc2_set_param_ahbcfg(struct dwc2_hsotg *hsotg , int val ) 
{ 


  {
  if (val != -1) {
    (hsotg->core_params)->ahbcfg = val;
  } else {
    (hsotg->core_params)->ahbcfg = 6;
  }
  return;
}
}
void dwc2_set_param_otg_ver(struct dwc2_hsotg *hsotg , int val ) 
{ 
  struct _ddebug descriptor ;
  long tmp ;

  {
  if (val < 0 || val > 1) {
    if (val >= 0) {
      dev_err((struct device  const  *)hsotg->dev, "\'%d\' invalid for parameter otg_ver\n",
              val);
      dev_err((struct device  const  *)hsotg->dev, "otg_ver must be 0 (for OTG 1.3 support) or 1 (for OTG 2.0 support)\n");
    } else {

    }
    val = 0;
    descriptor.modname = "dwc2";
    descriptor.function = "dwc2_set_param_otg_ver";
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
    descriptor.format = "Setting otg_ver to %d\n";
    descriptor.lineno = 2968U;
    descriptor.flags = 1U;
    tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
    if (tmp != 0L) {
      __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "Setting otg_ver to %d\n",
                        val);
    } else {

    }
  } else {

  }
  (hsotg->core_params)->otg_ver = val;
  return;
}
}
static void dwc2_set_param_uframe_sched(struct dwc2_hsotg *hsotg , int val ) 
{ 
  struct _ddebug descriptor ;
  long tmp ;

  {
  if (val < 0 || val > 1) {
    if (val >= 0) {
      dev_err((struct device  const  *)hsotg->dev, "\'%d\' invalid for parameter uframe_sched\n",
              val);
      dev_err((struct device  const  *)hsotg->dev, "uframe_sched must be 0 or 1\n");
    } else {

    }
    val = 1;
    descriptor.modname = "dwc2";
    descriptor.function = "dwc2_set_param_uframe_sched";
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
    descriptor.format = "Setting uframe_sched to %d\n";
    descriptor.lineno = 2984U;
    descriptor.flags = 1U;
    tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
    if (tmp != 0L) {
      __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "Setting uframe_sched to %d\n",
                        val);
    } else {

    }
  } else {

  }
  (hsotg->core_params)->uframe_sched = val;
  return;
}
}
static void dwc2_set_param_external_id_pin_ctl(struct dwc2_hsotg *hsotg , int val ) 
{ 
  struct _ddebug descriptor ;
  long tmp ;

  {
  if (val < 0 || val > 1) {
    if (val >= 0) {
      dev_err((struct device  const  *)hsotg->dev, "\'%d\' invalid for parameter external_id_pin_ctl\n",
              val);
      dev_err((struct device  const  *)hsotg->dev, "external_id_pin_ctl must be 0 or 1\n");
    } else {

    }
    val = 0;
    descriptor.modname = "dwc2";
    descriptor.function = "dwc2_set_param_external_id_pin_ctl";
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
    descriptor.format = "Setting external_id_pin_ctl to %d\n";
    descriptor.lineno = 3001U;
    descriptor.flags = 1U;
    tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
    if (tmp != 0L) {
      __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "Setting external_id_pin_ctl to %d\n",
                        val);
    } else {

    }
  } else {

  }
  (hsotg->core_params)->external_id_pin_ctl = val;
  return;
}
}
static void dwc2_set_param_hibernation(struct dwc2_hsotg *hsotg , int val ) 
{ 
  struct _ddebug descriptor ;
  long tmp ;

  {
  if (val < 0 || val > 1) {
    if (val >= 0) {
      dev_err((struct device  const  *)hsotg->dev, "\'%d\' invalid for parameter hibernation\n",
              val);
      dev_err((struct device  const  *)hsotg->dev, "hibernation must be 0 or 1\n");
    } else {

    }
    val = 0;
    descriptor.modname = "dwc2";
    descriptor.function = "dwc2_set_param_hibernation";
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
    descriptor.format = "Setting hibernation to %d\n";
    descriptor.lineno = 3018U;
    descriptor.flags = 1U;
    tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
    if (tmp != 0L) {
      __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "Setting hibernation to %d\n",
                        val);
    } else {

    }
  } else {

  }
  (hsotg->core_params)->hibernation = val;
  return;
}
}
void dwc2_set_parameters(struct dwc2_hsotg *hsotg , struct dwc2_core_params  const  *params ) 
{ 
  struct _ddebug descriptor ;
  long tmp ;

  {
  descriptor.modname = "dwc2";
  descriptor.function = "dwc2_set_parameters";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
  descriptor.format = "%s()\n";
  descriptor.lineno = 3031U;
  descriptor.flags = 1U;
  tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp != 0L) {
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "%s()\n",
                      "dwc2_set_parameters");
  } else {

  }
  dwc2_set_param_otg_cap(hsotg, params->otg_cap);
  dwc2_set_param_dma_enable(hsotg, params->dma_enable);
  dwc2_set_param_dma_desc_enable(hsotg, params->dma_desc_enable);
  dwc2_set_param_host_support_fs_ls_low_power(hsotg, params->host_support_fs_ls_low_power);
  dwc2_set_param_enable_dynamic_fifo(hsotg, params->enable_dynamic_fifo);
  dwc2_set_param_host_rx_fifo_size(hsotg, params->host_rx_fifo_size);
  dwc2_set_param_host_nperio_tx_fifo_size(hsotg, params->host_nperio_tx_fifo_size);
  dwc2_set_param_host_perio_tx_fifo_size(hsotg, params->host_perio_tx_fifo_size);
  dwc2_set_param_max_transfer_size(hsotg, params->max_transfer_size);
  dwc2_set_param_max_packet_count(hsotg, params->max_packet_count);
  dwc2_set_param_host_channels(hsotg, params->host_channels);
  dwc2_set_param_phy_type(hsotg, params->phy_type);
  dwc2_set_param_speed(hsotg, params->speed);
  dwc2_set_param_host_ls_low_power_phy_clk(hsotg, params->host_ls_low_power_phy_clk);
  dwc2_set_param_phy_ulpi_ddr(hsotg, params->phy_ulpi_ddr);
  dwc2_set_param_phy_ulpi_ext_vbus(hsotg, params->phy_ulpi_ext_vbus);
  dwc2_set_param_phy_utmi_width(hsotg, params->phy_utmi_width);
  dwc2_set_param_ulpi_fs_ls(hsotg, params->ulpi_fs_ls);
  dwc2_set_param_ts_dline(hsotg, params->ts_dline);
  dwc2_set_param_i2c_enable(hsotg, params->i2c_enable);
  dwc2_set_param_en_multiple_tx_fifo(hsotg, params->en_multiple_tx_fifo);
  dwc2_set_param_reload_ctl(hsotg, params->reload_ctl);
  dwc2_set_param_ahbcfg(hsotg, params->ahbcfg);
  dwc2_set_param_otg_ver(hsotg, params->otg_ver);
  dwc2_set_param_uframe_sched(hsotg, params->uframe_sched);
  dwc2_set_param_external_id_pin_ctl(hsotg, params->external_id_pin_ctl);
  dwc2_set_param_hibernation(hsotg, params->hibernation);
  return;
}
}
int dwc2_get_hwparams(struct dwc2_hsotg *hsotg ) 
{ 
  struct dwc2_hw_params *hw ;
  unsigned int width ;
    klee_make_symbolic(&width, sizeof(int), "width");
  u32 hwcfg1 ;
  u32 hwcfg2 ;
  u32 hwcfg3 ;
  u32 hwcfg4 ;
  u32 hptxfsiz ;
  u32 grxfsiz ;
  u32 gnptxfsiz ;
  u32 gusbcfg ;
  struct _ddebug descriptor ;
  long tmp ;
  struct _ddebug descriptor___0 ;
  long tmp___0 ;
  struct _ddebug descriptor___1 ;
  long tmp___1 ;
  struct _ddebug descriptor___2 ;
  long tmp___2 ;
  struct _ddebug descriptor___3 ;
  long tmp___3 ;
  struct _ddebug descriptor___4 ;
  long tmp___4 ;
  struct _ddebug descriptor___5 ;
  long tmp___5 ;
  struct _ddebug descriptor___6 ;
  long tmp___6 ;
  struct _ddebug descriptor___7 ;
  long tmp___7 ;
  struct _ddebug descriptor___8 ;
  long tmp___8 ;
  struct _ddebug descriptor___9 ;
  long tmp___9 ;
  struct _ddebug descriptor___10 ;
  long tmp___10 ;
  struct _ddebug descriptor___11 ;
  long tmp___11 ;
  struct _ddebug descriptor___12 ;
  long tmp___12 ;
  struct _ddebug descriptor___13 ;
  long tmp___13 ;
  struct _ddebug descriptor___14 ;
  long tmp___14 ;
  struct _ddebug descriptor___15 ;
  long tmp___15 ;
  struct _ddebug descriptor___16 ;
  long tmp___16 ;
  struct _ddebug descriptor___17 ;
  long tmp___17 ;
  struct _ddebug descriptor___18 ;
  long tmp___18 ;
  struct _ddebug descriptor___19 ;
  long tmp___19 ;
  struct _ddebug descriptor___20 ;
  long tmp___20 ;
  struct _ddebug descriptor___21 ;
  long tmp___21 ;
  struct _ddebug descriptor___22 ;
  long tmp___22 ;
  struct _ddebug descriptor___23 ;
  long tmp___23 ;
  struct _ddebug descriptor___24 ;
  long tmp___24 ;
  struct _ddebug descriptor___25 ;
  long tmp___25 ;
  struct _ddebug descriptor___26 ;
  long tmp___26 ;
  struct _ddebug descriptor___27 ;
  long tmp___27 ;
  struct _ddebug descriptor___28 ;
  long tmp___28 ;
  struct _ddebug descriptor___29 ;
  long tmp___29 ;
  struct _ddebug descriptor___30 ;
  long tmp___30 ;

  {
  hw = & hsotg->hw_params;
  hw->snpsid = readl((void const volatile   *)hsotg->regs + 64U);
  if ((hw->snpsid & 4294963200U) != 1330913280U && (hw->snpsid & 4294963200U) != 1330917376U) {
    dev_err((struct device  const  *)hsotg->dev, "Bad value for GSNPSID: 0x%08x\n",
            hw->snpsid);
    return (-19);
  } else {

  }
  descriptor.modname = "dwc2";
  descriptor.function = "dwc2_get_hwparams";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
  descriptor.format = "Core Release: %1x.%1x%1x%1x (snpsid=%x)\n";
  descriptor.lineno = 3100U;
  descriptor.flags = 1U;
  tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp != 0L) {
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "Core Release: %1x.%1x%1x%1x (snpsid=%x)\n",
                      (hw->snpsid >> 12) & 15U, (hw->snpsid >> 8) & 15U, (hw->snpsid >> 4) & 15U,
                      hw->snpsid & 15U, hw->snpsid);
  } else {

  }
  hwcfg1 = readl((void const volatile   *)hsotg->regs + 68U);
  hwcfg2 = readl((void const volatile   *)hsotg->regs + 72U);
  hwcfg3 = readl((void const volatile   *)hsotg->regs + 76U);
  hwcfg4 = readl((void const volatile   *)hsotg->regs + 80U);
  grxfsiz = readl((void const volatile   *)hsotg->regs + 36U);
  descriptor___0.modname = "dwc2";
  descriptor___0.function = "dwc2_get_hwparams";
  descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
  descriptor___0.format = "hwcfg1=%08x\n";
  descriptor___0.lineno = 3108U;
  descriptor___0.flags = 1U;
  tmp___0 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
  if (tmp___0 != 0L) {
    __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)hsotg->dev, "hwcfg1=%08x\n",
                      hwcfg1);
  } else {

  }
  descriptor___1.modname = "dwc2";
  descriptor___1.function = "dwc2_get_hwparams";
  descriptor___1.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
  descriptor___1.format = "hwcfg2=%08x\n";
  descriptor___1.lineno = 3109U;
  descriptor___1.flags = 1U;
  tmp___1 = ldv__builtin_expect((long )descriptor___1.flags & 1L, 0L);
  if (tmp___1 != 0L) {
    __dynamic_dev_dbg(& descriptor___1, (struct device  const  *)hsotg->dev, "hwcfg2=%08x\n",
                      hwcfg2);
  } else {

  }
  descriptor___2.modname = "dwc2";
  descriptor___2.function = "dwc2_get_hwparams";
  descriptor___2.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
  descriptor___2.format = "hwcfg3=%08x\n";
  descriptor___2.lineno = 3110U;
  descriptor___2.flags = 1U;
  tmp___2 = ldv__builtin_expect((long )descriptor___2.flags & 1L, 0L);
  if (tmp___2 != 0L) {
    __dynamic_dev_dbg(& descriptor___2, (struct device  const  *)hsotg->dev, "hwcfg3=%08x\n",
                      hwcfg3);
  } else {

  }
  descriptor___3.modname = "dwc2";
  descriptor___3.function = "dwc2_get_hwparams";
  descriptor___3.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
  descriptor___3.format = "hwcfg4=%08x\n";
  descriptor___3.lineno = 3111U;
  descriptor___3.flags = 1U;
  tmp___3 = ldv__builtin_expect((long )descriptor___3.flags & 1L, 0L);
  if (tmp___3 != 0L) {
    __dynamic_dev_dbg(& descriptor___3, (struct device  const  *)hsotg->dev, "hwcfg4=%08x\n",
                      hwcfg4);
  } else {

  }
  descriptor___4.modname = "dwc2";
  descriptor___4.function = "dwc2_get_hwparams";
  descriptor___4.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
  descriptor___4.format = "grxfsiz=%08x\n";
  descriptor___4.lineno = 3112U;
  descriptor___4.flags = 1U;
  tmp___4 = ldv__builtin_expect((long )descriptor___4.flags & 1L, 0L);
  if (tmp___4 != 0L) {
    __dynamic_dev_dbg(& descriptor___4, (struct device  const  *)hsotg->dev, "grxfsiz=%08x\n",
                      grxfsiz);
  } else {

  }
  gusbcfg = readl((void const volatile   *)hsotg->regs + 12U);
  gusbcfg = gusbcfg | 536870912U;
  writel(gusbcfg, (void volatile   *)hsotg->regs + 12U);
  usleep_range(100000UL, 150000UL);
  gnptxfsiz = readl((void const volatile   *)hsotg->regs + 40U);
  hptxfsiz = readl((void const volatile   *)hsotg->regs + 256U);
  descriptor___5.modname = "dwc2";
  descriptor___5.function = "dwc2_get_hwparams";
  descriptor___5.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
  descriptor___5.format = "gnptxfsiz=%08x\n";
  descriptor___5.lineno = 3122U;
  descriptor___5.flags = 1U;
  tmp___5 = ldv__builtin_expect((long )descriptor___5.flags & 1L, 0L);
  if (tmp___5 != 0L) {
    __dynamic_dev_dbg(& descriptor___5, (struct device  const  *)hsotg->dev, "gnptxfsiz=%08x\n",
                      gnptxfsiz);
  } else {

  }
  descriptor___6.modname = "dwc2";
  descriptor___6.function = "dwc2_get_hwparams";
  descriptor___6.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
  descriptor___6.format = "hptxfsiz=%08x\n";
  descriptor___6.lineno = 3123U;
  descriptor___6.flags = 1U;
  tmp___6 = ldv__builtin_expect((long )descriptor___6.flags & 1L, 0L);
  if (tmp___6 != 0L) {
    __dynamic_dev_dbg(& descriptor___6, (struct device  const  *)hsotg->dev, "hptxfsiz=%08x\n",
                      hptxfsiz);
  } else {

  }
  gusbcfg = readl((void const volatile   *)hsotg->regs + 12U);
  gusbcfg = gusbcfg & 3758096383U;
  writel(gusbcfg, (void volatile   *)hsotg->regs + 12U);
  usleep_range(100000UL, 150000UL);
  hw->op_mode = (unsigned int )((unsigned char )hwcfg2) & 7U;
  hw->arch = (unsigned char )((hwcfg2 & 24U) >> 3);
  hw->enable_dynamic_fifo = (hwcfg2 & 524288U) != 0U;
  hw->host_channels = (unsigned char )((unsigned int )((unsigned char )((hwcfg2 & 245760U) >> 14)) + 1U);
  hw->hs_phy_type = (unsigned char )((hwcfg2 & 192U) >> 6);
  hw->fs_phy_type = (unsigned char )((hwcfg2 & 768U) >> 8);
  hw->num_dev_ep = (unsigned char )((hwcfg2 & 15360U) >> 10);
  hw->nperio_tx_q_depth = (unsigned char )((int )((unsigned char )((hwcfg2 & 12582912U) >> 22)) << 1U);
  hw->host_perio_tx_q_depth = (unsigned char )((int )((unsigned char )((hwcfg2 & 50331648U) >> 24)) << 1U);
  hw->dev_token_q_depth = (unsigned char )((hwcfg2 & 2080374784U) >> 26);
  width = hwcfg3 & 15U;
  hw->max_transfer_size = (unsigned int )((1 << (int )(width + 11U)) + -1);
  if ((int )hw->max_transfer_size > 65535) {
    hw->max_transfer_size = 65535U;
  } else {

  }
  width = (hwcfg3 & 112U) >> 4;
  hw->max_packet_count = (unsigned short )((unsigned int )((unsigned short )(1 << (int )(width + 4U))) + 65535U);
  hw->i2c_enable = (hwcfg3 & 256U) != 0U;
  hw->total_fifo_size = (unsigned short )(hwcfg3 >> 16);
  hw->en_multiple_tx_fifo = (hwcfg4 & 33554432U) != 0U;
  hw->num_dev_perio_in_ep = (unsigned int )((unsigned char )hwcfg4) & 15U;
  hw->dma_desc_enable = (hwcfg4 & 1073741824U) != 0U;
  hw->power_optimized = (hwcfg4 & 16U) != 0U;
  hw->utmi_phy_data_width = (unsigned char )((hwcfg4 & 49152U) >> 14);
  hw->host_rx_fifo_size = (unsigned short )grxfsiz;
  hw->host_nperio_tx_fifo_size = (unsigned short )(gnptxfsiz >> 16);
  hw->host_perio_tx_fifo_size = (unsigned short )(hptxfsiz >> 16);
  descriptor___7.modname = "dwc2";
  descriptor___7.function = "dwc2_get_hwparams";
  descriptor___7.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
  descriptor___7.format = "Detected values from hardware:\n";
  descriptor___7.lineno = 3188U;
  descriptor___7.flags = 1U;
  tmp___7 = ldv__builtin_expect((long )descriptor___7.flags & 1L, 0L);
  if (tmp___7 != 0L) {
    __dynamic_dev_dbg(& descriptor___7, (struct device  const  *)hsotg->dev, "Detected values from hardware:\n");
  } else {

  }
  descriptor___8.modname = "dwc2";
  descriptor___8.function = "dwc2_get_hwparams";
  descriptor___8.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
  descriptor___8.format = "  op_mode=%d\n";
  descriptor___8.lineno = 3190U;
  descriptor___8.flags = 1U;
  tmp___8 = ldv__builtin_expect((long )descriptor___8.flags & 1L, 0L);
  if (tmp___8 != 0L) {
    __dynamic_dev_dbg(& descriptor___8, (struct device  const  *)hsotg->dev, "  op_mode=%d\n",
                      (int )hw->op_mode);
  } else {

  }
  descriptor___9.modname = "dwc2";
  descriptor___9.function = "dwc2_get_hwparams";
  descriptor___9.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
  descriptor___9.format = "  arch=%d\n";
  descriptor___9.lineno = 3192U;
  descriptor___9.flags = 1U;
  tmp___9 = ldv__builtin_expect((long )descriptor___9.flags & 1L, 0L);
  if (tmp___9 != 0L) {
    __dynamic_dev_dbg(& descriptor___9, (struct device  const  *)hsotg->dev, "  arch=%d\n",
                      (int )hw->arch);
  } else {

  }
  descriptor___10.modname = "dwc2";
  descriptor___10.function = "dwc2_get_hwparams";
  descriptor___10.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
  descriptor___10.format = "  dma_desc_enable=%d\n";
  descriptor___10.lineno = 3194U;
  descriptor___10.flags = 1U;
  tmp___10 = ldv__builtin_expect((long )descriptor___10.flags & 1L, 0L);
  if (tmp___10 != 0L) {
    __dynamic_dev_dbg(& descriptor___10, (struct device  const  *)hsotg->dev, "  dma_desc_enable=%d\n",
                      (int )hw->dma_desc_enable);
  } else {

  }
  descriptor___11.modname = "dwc2";
  descriptor___11.function = "dwc2_get_hwparams";
  descriptor___11.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
  descriptor___11.format = "  power_optimized=%d\n";
  descriptor___11.lineno = 3196U;
  descriptor___11.flags = 1U;
  tmp___11 = ldv__builtin_expect((long )descriptor___11.flags & 1L, 0L);
  if (tmp___11 != 0L) {
    __dynamic_dev_dbg(& descriptor___11, (struct device  const  *)hsotg->dev, "  power_optimized=%d\n",
                      (int )hw->power_optimized);
  } else {

  }
  descriptor___12.modname = "dwc2";
  descriptor___12.function = "dwc2_get_hwparams";
  descriptor___12.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
  descriptor___12.format = "  i2c_enable=%d\n";
  descriptor___12.lineno = 3198U;
  descriptor___12.flags = 1U;
  tmp___12 = ldv__builtin_expect((long )descriptor___12.flags & 1L, 0L);
  if (tmp___12 != 0L) {
    __dynamic_dev_dbg(& descriptor___12, (struct device  const  *)hsotg->dev, "  i2c_enable=%d\n",
                      (int )hw->i2c_enable);
  } else {

  }
  descriptor___13.modname = "dwc2";
  descriptor___13.function = "dwc2_get_hwparams";
  descriptor___13.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
  descriptor___13.format = "  hs_phy_type=%d\n";
  descriptor___13.lineno = 3200U;
  descriptor___13.flags = 1U;
  tmp___13 = ldv__builtin_expect((long )descriptor___13.flags & 1L, 0L);
  if (tmp___13 != 0L) {
    __dynamic_dev_dbg(& descriptor___13, (struct device  const  *)hsotg->dev, "  hs_phy_type=%d\n",
                      (int )hw->hs_phy_type);
  } else {

  }
  descriptor___14.modname = "dwc2";
  descriptor___14.function = "dwc2_get_hwparams";
  descriptor___14.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
  descriptor___14.format = "  fs_phy_type=%d\n";
  descriptor___14.lineno = 3202U;
  descriptor___14.flags = 1U;
  tmp___14 = ldv__builtin_expect((long )descriptor___14.flags & 1L, 0L);
  if (tmp___14 != 0L) {
    __dynamic_dev_dbg(& descriptor___14, (struct device  const  *)hsotg->dev, "  fs_phy_type=%d\n",
                      (int )hw->fs_phy_type);
  } else {

  }
  descriptor___15.modname = "dwc2";
  descriptor___15.function = "dwc2_get_hwparams";
  descriptor___15.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
  descriptor___15.format = "  utmi_phy_data_wdith=%d\n";
  descriptor___15.lineno = 3204U;
  descriptor___15.flags = 1U;
  tmp___15 = ldv__builtin_expect((long )descriptor___15.flags & 1L, 0L);
  if (tmp___15 != 0L) {
    __dynamic_dev_dbg(& descriptor___15, (struct device  const  *)hsotg->dev, "  utmi_phy_data_wdith=%d\n",
                      (int )hw->utmi_phy_data_width);
  } else {

  }
  descriptor___16.modname = "dwc2";
  descriptor___16.function = "dwc2_get_hwparams";
  descriptor___16.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
  descriptor___16.format = "  num_dev_ep=%d\n";
  descriptor___16.lineno = 3206U;
  descriptor___16.flags = 1U;
  tmp___16 = ldv__builtin_expect((long )descriptor___16.flags & 1L, 0L);
  if (tmp___16 != 0L) {
    __dynamic_dev_dbg(& descriptor___16, (struct device  const  *)hsotg->dev, "  num_dev_ep=%d\n",
                      (int )hw->num_dev_ep);
  } else {

  }
  descriptor___17.modname = "dwc2";
  descriptor___17.function = "dwc2_get_hwparams";
  descriptor___17.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
  descriptor___17.format = "  num_dev_perio_in_ep=%d\n";
  descriptor___17.lineno = 3208U;
  descriptor___17.flags = 1U;
  tmp___17 = ldv__builtin_expect((long )descriptor___17.flags & 1L, 0L);
  if (tmp___17 != 0L) {
    __dynamic_dev_dbg(& descriptor___17, (struct device  const  *)hsotg->dev, "  num_dev_perio_in_ep=%d\n",
                      (int )hw->num_dev_perio_in_ep);
  } else {

  }
  descriptor___18.modname = "dwc2";
  descriptor___18.function = "dwc2_get_hwparams";
  descriptor___18.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
  descriptor___18.format = "  host_channels=%d\n";
  descriptor___18.lineno = 3210U;
  descriptor___18.flags = 1U;
  tmp___18 = ldv__builtin_expect((long )descriptor___18.flags & 1L, 0L);
  if (tmp___18 != 0L) {
    __dynamic_dev_dbg(& descriptor___18, (struct device  const  *)hsotg->dev, "  host_channels=%d\n",
                      (int )hw->host_channels);
  } else {

  }
  descriptor___19.modname = "dwc2";
  descriptor___19.function = "dwc2_get_hwparams";
  descriptor___19.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
  descriptor___19.format = "  max_transfer_size=%d\n";
  descriptor___19.lineno = 3212U;
  descriptor___19.flags = 1U;
  tmp___19 = ldv__builtin_expect((long )descriptor___19.flags & 1L, 0L);
  if (tmp___19 != 0L) {
    __dynamic_dev_dbg(& descriptor___19, (struct device  const  *)hsotg->dev, "  max_transfer_size=%d\n",
                      (int )hw->max_transfer_size);
  } else {

  }
  descriptor___20.modname = "dwc2";
  descriptor___20.function = "dwc2_get_hwparams";
  descriptor___20.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
  descriptor___20.format = "  max_packet_count=%d\n";
  descriptor___20.lineno = 3214U;
  descriptor___20.flags = 1U;
  tmp___20 = ldv__builtin_expect((long )descriptor___20.flags & 1L, 0L);
  if (tmp___20 != 0L) {
    __dynamic_dev_dbg(& descriptor___20, (struct device  const  *)hsotg->dev, "  max_packet_count=%d\n",
                      (int )hw->max_packet_count);
  } else {

  }
  descriptor___21.modname = "dwc2";
  descriptor___21.function = "dwc2_get_hwparams";
  descriptor___21.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
  descriptor___21.format = "  nperio_tx_q_depth=0x%0x\n";
  descriptor___21.lineno = 3216U;
  descriptor___21.flags = 1U;
  tmp___21 = ldv__builtin_expect((long )descriptor___21.flags & 1L, 0L);
  if (tmp___21 != 0L) {
    __dynamic_dev_dbg(& descriptor___21, (struct device  const  *)hsotg->dev, "  nperio_tx_q_depth=0x%0x\n",
                      (int )hw->nperio_tx_q_depth);
  } else {

  }
  descriptor___22.modname = "dwc2";
  descriptor___22.function = "dwc2_get_hwparams";
  descriptor___22.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
  descriptor___22.format = "  host_perio_tx_q_depth=0x%0x\n";
  descriptor___22.lineno = 3218U;
  descriptor___22.flags = 1U;
  tmp___22 = ldv__builtin_expect((long )descriptor___22.flags & 1L, 0L);
  if (tmp___22 != 0L) {
    __dynamic_dev_dbg(& descriptor___22, (struct device  const  *)hsotg->dev, "  host_perio_tx_q_depth=0x%0x\n",
                      (int )hw->host_perio_tx_q_depth);
  } else {

  }
  descriptor___23.modname = "dwc2";
  descriptor___23.function = "dwc2_get_hwparams";
  descriptor___23.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
  descriptor___23.format = "  dev_token_q_depth=0x%0x\n";
  descriptor___23.lineno = 3220U;
  descriptor___23.flags = 1U;
  tmp___23 = ldv__builtin_expect((long )descriptor___23.flags & 1L, 0L);
  if (tmp___23 != 0L) {
    __dynamic_dev_dbg(& descriptor___23, (struct device  const  *)hsotg->dev, "  dev_token_q_depth=0x%0x\n",
                      (int )hw->dev_token_q_depth);
  } else {

  }
  descriptor___24.modname = "dwc2";
  descriptor___24.function = "dwc2_get_hwparams";
  descriptor___24.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
  descriptor___24.format = "  enable_dynamic_fifo=%d\n";
  descriptor___24.lineno = 3222U;
  descriptor___24.flags = 1U;
  tmp___24 = ldv__builtin_expect((long )descriptor___24.flags & 1L, 0L);
  if (tmp___24 != 0L) {
    __dynamic_dev_dbg(& descriptor___24, (struct device  const  *)hsotg->dev, "  enable_dynamic_fifo=%d\n",
                      (int )hw->enable_dynamic_fifo);
  } else {

  }
  descriptor___25.modname = "dwc2";
  descriptor___25.function = "dwc2_get_hwparams";
  descriptor___25.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
  descriptor___25.format = "  en_multiple_tx_fifo=%d\n";
  descriptor___25.lineno = 3224U;
  descriptor___25.flags = 1U;
  tmp___25 = ldv__builtin_expect((long )descriptor___25.flags & 1L, 0L);
  if (tmp___25 != 0L) {
    __dynamic_dev_dbg(& descriptor___25, (struct device  const  *)hsotg->dev, "  en_multiple_tx_fifo=%d\n",
                      (int )hw->en_multiple_tx_fifo);
  } else {

  }
  descriptor___26.modname = "dwc2";
  descriptor___26.function = "dwc2_get_hwparams";
  descriptor___26.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
  descriptor___26.format = "  total_fifo_size=%d\n";
  descriptor___26.lineno = 3226U;
  descriptor___26.flags = 1U;
  tmp___26 = ldv__builtin_expect((long )descriptor___26.flags & 1L, 0L);
  if (tmp___26 != 0L) {
    __dynamic_dev_dbg(& descriptor___26, (struct device  const  *)hsotg->dev, "  total_fifo_size=%d\n",
                      (int )hw->total_fifo_size);
  } else {

  }
  descriptor___27.modname = "dwc2";
  descriptor___27.function = "dwc2_get_hwparams";
  descriptor___27.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
  descriptor___27.format = "  host_rx_fifo_size=%d\n";
  descriptor___27.lineno = 3228U;
  descriptor___27.flags = 1U;
  tmp___27 = ldv__builtin_expect((long )descriptor___27.flags & 1L, 0L);
  if (tmp___27 != 0L) {
    __dynamic_dev_dbg(& descriptor___27, (struct device  const  *)hsotg->dev, "  host_rx_fifo_size=%d\n",
                      (int )hw->host_rx_fifo_size);
  } else {

  }
  descriptor___28.modname = "dwc2";
  descriptor___28.function = "dwc2_get_hwparams";
  descriptor___28.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
  descriptor___28.format = "  host_nperio_tx_fifo_size=%d\n";
  descriptor___28.lineno = 3230U;
  descriptor___28.flags = 1U;
  tmp___28 = ldv__builtin_expect((long )descriptor___28.flags & 1L, 0L);
  if (tmp___28 != 0L) {
    __dynamic_dev_dbg(& descriptor___28, (struct device  const  *)hsotg->dev, "  host_nperio_tx_fifo_size=%d\n",
                      (int )hw->host_nperio_tx_fifo_size);
  } else {

  }
  descriptor___29.modname = "dwc2";
  descriptor___29.function = "dwc2_get_hwparams";
  descriptor___29.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
  descriptor___29.format = "  host_perio_tx_fifo_size=%d\n";
  descriptor___29.lineno = 3232U;
  descriptor___29.flags = 1U;
  tmp___29 = ldv__builtin_expect((long )descriptor___29.flags & 1L, 0L);
  if (tmp___29 != 0L) {
    __dynamic_dev_dbg(& descriptor___29, (struct device  const  *)hsotg->dev, "  host_perio_tx_fifo_size=%d\n",
                      (int )hw->host_perio_tx_fifo_size);
  } else {

  }
  descriptor___30.modname = "dwc2";
  descriptor___30.function = "dwc2_get_hwparams";
  descriptor___30.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core.c";
  descriptor___30.format = "\n";
  descriptor___30.lineno = 3233U;
  descriptor___30.flags = 1U;
  tmp___30 = ldv__builtin_expect((long )descriptor___30.flags & 1L, 0L);
  if (tmp___30 != 0L) {
    __dynamic_dev_dbg(& descriptor___30, (struct device  const  *)hsotg->dev, "\n");
  } else {

  }
  return (0);
}
}
void dwc2_set_all_params(struct dwc2_core_params *params , int value ) 
{ 
  int *p ;
  size_t size ;
  int i ;

  {
  p = (int *)params;
  size = 27UL;
  i = 0;
  goto ldv_35345;
  ldv_35344: 
  *(p + (unsigned long )i) = value;
  i = i + 1;
  ldv_35345: ;
  if ((size_t )i < size) {
    goto ldv_35344;
  } else {

  }

  return;
}
}
u16 dwc2_get_otg_version(struct dwc2_hsotg *hsotg ) 
{ 


  {
  return ((hsotg->core_params)->otg_ver == 1 ? 512U : 259U);
}
}
bool dwc2_is_controller_alive(struct dwc2_hsotg *hsotg ) 
{ 
  unsigned int tmp ;

  {
  tmp = readl((void const volatile   *)hsotg->regs + 64U);
  if (tmp == 4294967295U) {
    return (0);
  } else {
    return (1);
  }
}
}
void dwc2_enable_global_interrupts(struct dwc2_hsotg *hsotg ) 
{ 
  u32 ahbcfg ;
  unsigned int tmp ;

  {
  tmp = readl((void const volatile   *)hsotg->regs + 8U);
  ahbcfg = tmp;
  ahbcfg = ahbcfg | 1U;
  writel(ahbcfg, (void volatile   *)hsotg->regs + 8U);
  return;
}
}
void dwc2_disable_global_interrupts(struct dwc2_hsotg *hsotg ) 
{ 
  u32 ahbcfg ;
  unsigned int tmp ;

  {
  tmp = readl((void const volatile   *)hsotg->regs + 8U);
  ahbcfg = tmp;
  ahbcfg = ahbcfg & 4294967294U;
  writel(ahbcfg, (void volatile   *)hsotg->regs + 8U);
  return;
}
}
bool ldv_queue_work_on_5(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                         struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_3(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_delayed_work_on_6(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                 struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_3(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_work_on_7(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                         struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_3(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
void ldv_flush_workqueue_8(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
  flush_workqueue(ldv_func_arg1);
  call_and_disable_all_3(2);
  return;
}
}
bool ldv_queue_delayed_work_on_9(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                 struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_3(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
__inline static long ldv__builtin_expect(long exp , long c ) ;
bool ldv_is_err_or_null(void const   *ptr ) ;
__inline static bool IS_ERR_OR_NULL(void const   *ptr ) ;
extern void _raw_spin_lock(raw_spinlock_t * ) ;
extern void _raw_spin_unlock(raw_spinlock_t * ) ;
__inline static void spin_lock(spinlock_t *lock ) 
{ 


  {
  _raw_spin_lock(& lock->__annonCompField18.rlock);
  return;
}
}
__inline static void spin_unlock(spinlock_t *lock ) 
{ 


  {
  _raw_spin_unlock(& lock->__annonCompField18.rlock);
  return;
}
}
extern unsigned long volatile   jiffies ;
extern unsigned long __msecs_to_jiffies(unsigned int const    ) ;
__inline static unsigned long msecs_to_jiffies(unsigned int const   m ) 
{ 
  unsigned long tmp___0 ;

  {
  tmp___0 = __msecs_to_jiffies(m);
  return (tmp___0);
}
}
extern int mod_timer(struct timer_list * , unsigned long  ) ;
int ldv_mod_timer_24(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
bool ldv_queue_work_on_19(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_work_on_21(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_delayed_work_on_20(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
bool ldv_queue_delayed_work_on_23(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
void ldv_flush_workqueue_22(struct workqueue_struct *ldv_func_arg1 ) ;
__inline static bool queue_work(struct workqueue_struct *wq , struct work_struct *work ) 
{ 
  bool tmp ;

  {
  tmp = ldv_queue_work_on_19(8192, wq, work);
  return (tmp);
}
}
void activate_pending_timer_4(struct timer_list *timer , unsigned long data , int pending_flag ) ;
__inline static int usb_phy_set_suspend(struct usb_phy *x , int suspend ) 
{ 
  int tmp ;

  {
  if ((unsigned long )x != (unsigned long )((struct usb_phy *)0) && (unsigned long )x->set_suspend != (unsigned long )((int (*)(struct usb_phy * ,
                                                                                                                                int  ))0)) {
    tmp = (*(x->set_suspend))(x, suspend);
    return (tmp);
  } else {
    return (0);
  }
}
}
irqreturn_t dwc2_handle_common_intr(int irq , void *dev ) ;
void s3c_hsotg_disconnect(struct dwc2_hsotg *hsotg ) ;
void dwc2_hcd_disconnect(struct dwc2_hsotg *hsotg ) ;
void dwc2_hcd_start(struct dwc2_hsotg *hsotg ) ;
__inline static int dwc2_is_device_mode(struct dwc2_hsotg *hsotg ) 
{ 
  unsigned int tmp ;

  {
  tmp = readl((void const volatile   *)hsotg->regs + 20U);
  return ((tmp & 1U) == 0U);
}
}
static char const   *dwc2_op_state_str(struct dwc2_hsotg *hsotg ) 
{ 


  {
  switch ((unsigned int )hsotg->op_state) {
  case 9U: ;
  return ("a_host");
  case 10U: ;
  return ("a_suspend");
  case 11U: ;
  return ("a_peripheral");
  case 3U: ;
  return ("b_peripheral");
  case 5U: ;
  return ("b_host");
  default: ;
  return ("unknown");
  }
}
}
static void dwc2_handle_usb_port_intr(struct dwc2_hsotg *hsotg ) 
{ 
  u32 hprt0 ;
  unsigned int tmp ;

  {
  tmp = readl((void const volatile   *)hsotg->regs + 1088U);
  hprt0 = tmp;
  if ((hprt0 & 8U) != 0U) {
    hprt0 = hprt0 & 4294967291U;
    writel(hprt0, (void volatile   *)hsotg->regs + 1088U);
  } else {

  }
  writel(16777216U, (void volatile   *)hsotg->regs + 20U);
  return;
}
}
static void dwc2_handle_mode_mismatch_intr(struct dwc2_hsotg *hsotg ) 
{ 
  int tmp ;

  {
  tmp = dwc2_is_host_mode(hsotg);
  dev_warn((struct device  const  *)hsotg->dev, "Mode Mismatch Interrupt: currently in %s mode\n",
           tmp != 0 ? (char *)"Host" : (char *)"Device");
  writel(2U, (void volatile   *)hsotg->regs + 20U);
  return;
}
}
static void dwc2_handle_otg_intr(struct dwc2_hsotg *hsotg ) 
{ 
  u32 gotgint ;
  u32 gotgctl ;
  u32 gintmsk ;
  struct _ddebug descriptor ;
  char const   *tmp ;
  long tmp___0 ;
  struct _ddebug descriptor___0 ;
  char const   *tmp___1 ;
  long tmp___2 ;
  int tmp___3 ;
  struct _ddebug descriptor___1 ;
  long tmp___4 ;
  struct _ddebug descriptor___2 ;
  long tmp___5 ;
  int tmp___6 ;
  struct _ddebug descriptor___3 ;
  long tmp___7 ;
  struct _ddebug descriptor___4 ;
  int tmp___8 ;
  long tmp___9 ;
  struct _ddebug descriptor___5 ;
  long tmp___10 ;
  int tmp___11 ;
  struct _ddebug descriptor___6 ;
  long tmp___12 ;
  struct _ddebug descriptor___7 ;
  long tmp___13 ;

  {
  gotgint = readl((void const volatile   *)hsotg->regs + 4U);
  gotgctl = readl((void const volatile   *)hsotg->regs);
  descriptor.modname = "dwc2";
  descriptor.function = "dwc2_handle_otg_intr";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core_intr.c";
  descriptor.format = "++OTG Interrupt gotgint=%0x [%s]\n";
  descriptor.lineno = 123U;
  descriptor.flags = 1U;
  tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp___0 != 0L) {
    tmp = dwc2_op_state_str(hsotg);
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "++OTG Interrupt gotgint=%0x [%s]\n",
                      gotgint, tmp);
  } else {

  }
  if ((gotgint & 4U) != 0U) {
    descriptor___0.modname = "dwc2";
    descriptor___0.function = "dwc2_handle_otg_intr";
    descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core_intr.c";
    descriptor___0.format = " ++OTG Interrupt: Session End Detected++ (%s)\n";
    descriptor___0.lineno = 128U;
    descriptor___0.flags = 1U;
    tmp___2 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
    if (tmp___2 != 0L) {
      tmp___1 = dwc2_op_state_str(hsotg);
      __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)hsotg->dev, " ++OTG Interrupt: Session End Detected++ (%s)\n",
                        tmp___1);
    } else {

    }
    gotgctl = readl((void const volatile   *)hsotg->regs);
    tmp___3 = dwc2_is_device_mode(hsotg);
    if (tmp___3 != 0) {
      s3c_hsotg_disconnect(hsotg);
    } else {

    }
    if ((unsigned int )hsotg->op_state == 5U) {
      hsotg->op_state = 3;
    } else {
      if ((gotgctl & 2048U) != 0U) {
        descriptor___1.modname = "dwc2";
        descriptor___1.function = "dwc2_handle_otg_intr";
        descriptor___1.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core_intr.c";
        descriptor___1.format = "Session End Detected\n";
        descriptor___1.lineno = 142U;
        descriptor___1.flags = 1U;
        tmp___4 = ldv__builtin_expect((long )descriptor___1.flags & 1L, 0L);
        if (tmp___4 != 0L) {
          __dynamic_dev_dbg(& descriptor___1, (struct device  const  *)hsotg->dev,
                            "Session End Detected\n");
        } else {

        }
        dev_err((struct device  const  *)hsotg->dev, "Device Not Connected/Responding!\n");
      } else {

      }
      hsotg->lx_state = 0;
    }
    gotgctl = readl((void const volatile   *)hsotg->regs);
    gotgctl = gotgctl & 4294965247U;
    writel(gotgctl, (void volatile   *)hsotg->regs);
  } else {

  }
  if ((gotgint & 256U) != 0U) {
    descriptor___2.modname = "dwc2";
    descriptor___2.function = "dwc2_handle_otg_intr";
    descriptor___2.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core_intr.c";
    descriptor___2.format = " ++OTG Interrupt: Session Request Success Status Change++\n";
    descriptor___2.lineno = 162U;
    descriptor___2.flags = 1U;
    tmp___5 = ldv__builtin_expect((long )descriptor___2.flags & 1L, 0L);
    if (tmp___5 != 0L) {
      __dynamic_dev_dbg(& descriptor___2, (struct device  const  *)hsotg->dev, " ++OTG Interrupt: Session Request Success Status Change++\n");
    } else {

    }
    gotgctl = readl((void const volatile   *)hsotg->regs);
    if ((int )gotgctl & 1) {
      if ((hsotg->core_params)->phy_type == 0 && (hsotg->core_params)->i2c_enable > 0) {
        hsotg->srp_success = 1U;
      } else {
        gotgctl = readl((void const volatile   *)hsotg->regs);
        gotgctl = gotgctl & 4294967293U;
        writel(gotgctl, (void volatile   *)hsotg->regs);
      }
    } else {

    }
  } else {

  }
  if ((gotgint & 512U) != 0U) {
    gotgctl = readl((void const volatile   *)hsotg->regs);
    if (hsotg->hw_params.snpsid > 1330917385U) {
      __const_udelay(429500UL);
    } else {

    }
    if ((gotgctl & 256U) != 0U) {
      tmp___6 = dwc2_is_host_mode(hsotg);
      if (tmp___6 != 0) {
        hsotg->op_state = 5;
        gintmsk = readl((void const volatile   *)hsotg->regs + 24U);
        gintmsk = gintmsk & 4294967287U;
        writel(gintmsk, (void volatile   *)hsotg->regs + 24U);
        spin_unlock(& hsotg->lock);
        dwc2_hcd_start(hsotg);
        spin_lock(& hsotg->lock);
        hsotg->op_state = 5;
      } else {

      }
    } else {
      gotgctl = readl((void const volatile   *)hsotg->regs);
      gotgctl = gotgctl & 4294964735U;
      writel(gotgctl, (void volatile   *)hsotg->regs);
      descriptor___3.modname = "dwc2";
      descriptor___3.function = "dwc2_handle_otg_intr";
      descriptor___3.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core_intr.c";
      descriptor___3.format = "HNP Failed\n";
      descriptor___3.lineno = 222U;
      descriptor___3.flags = 1U;
      tmp___7 = ldv__builtin_expect((long )descriptor___3.flags & 1L, 0L);
      if (tmp___7 != 0L) {
        __dynamic_dev_dbg(& descriptor___3, (struct device  const  *)hsotg->dev, "HNP Failed\n");
      } else {

      }
      dev_err((struct device  const  *)hsotg->dev, "Device Not Connected/Responding\n");
    }
  } else {

  }
  if ((gotgint & 131072U) != 0U) {
    descriptor___4.modname = "dwc2";
    descriptor___4.function = "dwc2_handle_otg_intr";
    descriptor___4.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core_intr.c";
    descriptor___4.format = " ++OTG Interrupt: Host Negotiation Detected++ (%s)\n";
    descriptor___4.lineno = 237U;
    descriptor___4.flags = 1U;
    tmp___9 = ldv__builtin_expect((long )descriptor___4.flags & 1L, 0L);
    if (tmp___9 != 0L) {
      tmp___8 = dwc2_is_host_mode(hsotg);
      __dynamic_dev_dbg(& descriptor___4, (struct device  const  *)hsotg->dev, " ++OTG Interrupt: Host Negotiation Detected++ (%s)\n",
                        tmp___8 != 0 ? (char *)"Host" : (char *)"Device");
    } else {

    }
    tmp___11 = dwc2_is_device_mode(hsotg);
    if (tmp___11 != 0) {
      descriptor___5.modname = "dwc2";
      descriptor___5.function = "dwc2_handle_otg_intr";
      descriptor___5.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core_intr.c";
      descriptor___5.format = "a_suspend->a_peripheral (%d)\n";
      descriptor___5.lineno = 240U;
      descriptor___5.flags = 1U;
      tmp___10 = ldv__builtin_expect((long )descriptor___5.flags & 1L, 0L);
      if (tmp___10 != 0L) {
        __dynamic_dev_dbg(& descriptor___5, (struct device  const  *)hsotg->dev, "a_suspend->a_peripheral (%d)\n",
                          (unsigned int )hsotg->op_state);
      } else {

      }
      spin_unlock(& hsotg->lock);
      dwc2_hcd_disconnect(hsotg);
      spin_lock(& hsotg->lock);
      hsotg->op_state = 11;
    } else {
      gintmsk = readl((void const volatile   *)hsotg->regs + 24U);
      gintmsk = gintmsk & 4294967287U;
      writel(gintmsk, (void volatile   *)hsotg->regs + 24U);
      spin_unlock(& hsotg->lock);
      dwc2_hcd_start(hsotg);
      spin_lock(& hsotg->lock);
      hsotg->op_state = 9;
    }
  } else {

  }
  if ((gotgint & 262144U) != 0U) {
    descriptor___6.modname = "dwc2";
    descriptor___6.function = "dwc2_handle_otg_intr";
    descriptor___6.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core_intr.c";
    descriptor___6.format = " ++OTG Interrupt: A-Device Timeout Change++\n";
    descriptor___6.lineno = 259U;
    descriptor___6.flags = 1U;
    tmp___12 = ldv__builtin_expect((long )descriptor___6.flags & 1L, 0L);
    if (tmp___12 != 0L) {
      __dynamic_dev_dbg(& descriptor___6, (struct device  const  *)hsotg->dev, " ++OTG Interrupt: A-Device Timeout Change++\n");
    } else {

    }
  } else {

  }
  if ((gotgint & 524288U) != 0U) {
    descriptor___7.modname = "dwc2";
    descriptor___7.function = "dwc2_handle_otg_intr";
    descriptor___7.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core_intr.c";
    descriptor___7.format = " ++OTG Interrupt: Debounce Done++\n";
    descriptor___7.lineno = 261U;
    descriptor___7.flags = 1U;
    tmp___13 = ldv__builtin_expect((long )descriptor___7.flags & 1L, 0L);
    if (tmp___13 != 0L) {
      __dynamic_dev_dbg(& descriptor___7, (struct device  const  *)hsotg->dev, " ++OTG Interrupt: Debounce Done++\n");
    } else {

    }
  } else {

  }
  writel(gotgint, (void volatile   *)hsotg->regs + 4U);
  return;
}
}
static void dwc2_handle_conn_id_status_change_intr(struct dwc2_hsotg *hsotg ) 
{ 
  u32 gintmsk ;
  unsigned int tmp ;
  struct _ddebug descriptor ;
  int tmp___0 ;
  long tmp___1 ;

  {
  tmp = readl((void const volatile   *)hsotg->regs + 24U);
  gintmsk = tmp;
  gintmsk = gintmsk & 4294967287U;
  writel(gintmsk, (void volatile   *)hsotg->regs + 24U);
  descriptor.modname = "dwc2";
  descriptor.function = "dwc2_handle_conn_id_status_change_intr";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core_intr.c";
  descriptor.format = " ++Connector ID Status Change Interrupt++  (%s)\n";
  descriptor.lineno = 286U;
  descriptor.flags = 1U;
  tmp___1 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp___1 != 0L) {
    tmp___0 = dwc2_is_host_mode(hsotg);
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, " ++Connector ID Status Change Interrupt++  (%s)\n",
                      tmp___0 != 0 ? (char *)"Host" : (char *)"Device");
  } else {

  }
  if ((unsigned long )hsotg->wq_otg != (unsigned long )((struct workqueue_struct *)0)) {
    spin_unlock(& hsotg->lock);
    queue_work(hsotg->wq_otg, & hsotg->wf_otg);
    spin_lock(& hsotg->lock);
  } else {

  }
  writel(268435456U, (void volatile   *)hsotg->regs + 20U);
  return;
}
}
static void dwc2_handle_session_req_intr(struct dwc2_hsotg *hsotg ) 
{ 
  struct _ddebug descriptor ;
  long tmp ;
  int tmp___0 ;

  {
  descriptor.modname = "dwc2";
  descriptor.function = "dwc2_handle_session_req_intr";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core_intr.c";
  descriptor.format = "++Session Request Interrupt++\n";
  descriptor.lineno = 316U;
  descriptor.flags = 1U;
  tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp != 0L) {
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "++Session Request Interrupt++\n");
  } else {

  }
  writel(1073741824U, (void volatile   *)hsotg->regs + 20U);
  tmp___0 = dwc2_is_device_mode(hsotg);
  if (tmp___0 != 0) {
    s3c_hsotg_disconnect(hsotg);
  } else {

  }
  return;
}
}
static void dwc2_handle_wakeup_detected_intr(struct dwc2_hsotg *hsotg ) 
{ 
  int ret ;
  struct _ddebug descriptor ;
  long tmp ;
  struct _ddebug descriptor___0 ;
  long tmp___0 ;
  struct _ddebug descriptor___1 ;
  unsigned int tmp___1 ;
  long tmp___2 ;
  u32 dctl ;
  unsigned int tmp___3 ;
  u32 pcgcctl ;
  unsigned int tmp___4 ;
  unsigned long tmp___5 ;
  int tmp___6 ;

  {
  descriptor.modname = "dwc2";
  descriptor.function = "dwc2_handle_wakeup_detected_intr";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core_intr.c";
  descriptor.format = "++Resume or Remote Wakeup Detected Interrupt++\n";
  descriptor.lineno = 338U;
  descriptor.flags = 1U;
  tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp != 0L) {
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "++Resume or Remote Wakeup Detected Interrupt++\n");
  } else {

  }
  descriptor___0.modname = "dwc2";
  descriptor___0.function = "dwc2_handle_wakeup_detected_intr";
  descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core_intr.c";
  descriptor___0.format = "%s lxstate = %d\n";
  descriptor___0.lineno = 339U;
  descriptor___0.flags = 1U;
  tmp___0 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
  if (tmp___0 != 0L) {
    __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)hsotg->dev, "%s lxstate = %d\n",
                      "dwc2_handle_wakeup_detected_intr", (unsigned int )hsotg->lx_state);
  } else {

  }
  tmp___6 = dwc2_is_device_mode(hsotg);
  if (tmp___6 != 0) {
    descriptor___1.modname = "dwc2";
    descriptor___1.function = "dwc2_handle_wakeup_detected_intr";
    descriptor___1.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core_intr.c";
    descriptor___1.format = "DSTS=0x%0x\n";
    descriptor___1.lineno = 342U;
    descriptor___1.flags = 1U;
    tmp___2 = ldv__builtin_expect((long )descriptor___1.flags & 1L, 0L);
    if (tmp___2 != 0L) {
      tmp___1 = readl((void const volatile   *)hsotg->regs + 2056U);
      __dynamic_dev_dbg(& descriptor___1, (struct device  const  *)hsotg->dev, "DSTS=0x%0x\n",
                        tmp___1);
    } else {

    }
    if ((unsigned int )hsotg->lx_state == 2U) {
      tmp___3 = readl((void const volatile   *)hsotg->regs + 2052U);
      dctl = tmp___3;
      dctl = dctl & 4294967294U;
      writel(dctl, (void volatile   *)hsotg->regs + 2052U);
      ret = dwc2_exit_hibernation(hsotg, 1);
      if (ret != 0 && ret != -524) {
        dev_err((struct device  const  *)hsotg->dev, "exit hibernation failed\n");
      } else {

      }
      if (((unsigned int )hsotg->gadget.speed != 0U && (unsigned long )hsotg->driver != (unsigned long )((struct usb_gadget_driver *)0)) && (unsigned long )(hsotg->driver)->resume != (unsigned long )((void (*)(struct usb_gadget * ))0)) {
        spin_unlock(& hsotg->lock);
        (*((hsotg->driver)->resume))(& hsotg->gadget);
        spin_lock(& hsotg->lock);
      } else {

      }
    } else {

    }
    hsotg->lx_state = 0;
  } else
  if ((unsigned int )hsotg->lx_state != 1U) {
    tmp___4 = readl((void const volatile   *)hsotg->regs + 3584U);
    pcgcctl = tmp___4;
    pcgcctl = pcgcctl & 4294967294U;
    writel(pcgcctl, (void volatile   *)hsotg->regs + 3584U);
    tmp___5 = msecs_to_jiffies(71U);
    ldv_mod_timer_24(& hsotg->wkp_timer, tmp___5 + (unsigned long )jiffies);
  } else {
    hsotg->lx_state = 0;
  }
  writel(2147483648U, (void volatile   *)hsotg->regs + 20U);
  return;
}
}
static void dwc2_handle_disconnect_intr(struct dwc2_hsotg *hsotg ) 
{ 
  struct _ddebug descriptor ;
  char const   *tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
  descriptor.modname = "dwc2";
  descriptor.function = "dwc2_handle_disconnect_intr";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core_intr.c";
  descriptor.format = "++Disconnect Detected Interrupt++ (%s) %s\n";
  descriptor.lineno = 384U;
  descriptor.flags = 1U;
  tmp___1 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp___1 != 0L) {
    tmp = dwc2_op_state_str(hsotg);
    tmp___0 = dwc2_is_host_mode(hsotg);
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "++Disconnect Detected Interrupt++ (%s) %s\n",
                      tmp___0 != 0 ? (char *)"Host" : (char *)"Device", tmp);
  } else {

  }
  if ((unsigned int )hsotg->op_state == 9U) {
    dwc2_hcd_disconnect(hsotg);
  } else {

  }
  hsotg->lx_state = 3;
  writel(536870912U, (void volatile   *)hsotg->regs + 20U);
  return;
}
}
static void dwc2_handle_usb_suspend_intr(struct dwc2_hsotg *hsotg ) 
{ 
  u32 dsts ;
  int ret ;
  struct _ddebug descriptor ;
  long tmp ;
  struct _ddebug descriptor___0 ;
  long tmp___0 ;
  struct _ddebug descriptor___1 ;
  long tmp___1 ;
  struct _ddebug descriptor___2 ;
  long tmp___2 ;
  bool tmp___3 ;
  int tmp___4 ;
  struct _ddebug descriptor___3 ;
  long tmp___5 ;
  int tmp___6 ;

  {
  descriptor.modname = "dwc2";
  descriptor.function = "dwc2_handle_usb_suspend_intr";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core_intr.c";
  descriptor.format = "USB SUSPEND\n";
  descriptor.lineno = 408U;
  descriptor.flags = 1U;
  tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp != 0L) {
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "USB SUSPEND\n");
  } else {

  }
  tmp___6 = dwc2_is_device_mode(hsotg);
  if (tmp___6 != 0) {
    dsts = readl((void const volatile   *)hsotg->regs + 2056U);
    descriptor___0.modname = "dwc2";
    descriptor___0.function = "dwc2_handle_usb_suspend_intr";
    descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core_intr.c";
    descriptor___0.format = "DSTS=0x%0x\n";
    descriptor___0.lineno = 416U;
    descriptor___0.flags = 1U;
    tmp___0 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
    if (tmp___0 != 0L) {
      __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)hsotg->dev, "DSTS=0x%0x\n",
                        dsts);
    } else {

    }
    descriptor___1.modname = "dwc2";
    descriptor___1.function = "dwc2_handle_usb_suspend_intr";
    descriptor___1.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core_intr.c";
    descriptor___1.format = "DSTS.Suspend Status=%d HWCFG4.Power Optimize=%d\n";
    descriptor___1.lineno = 420U;
    descriptor___1.flags = 1U;
    tmp___1 = ldv__builtin_expect((long )descriptor___1.flags & 1L, 0L);
    if (tmp___1 != 0L) {
      __dynamic_dev_dbg(& descriptor___1, (struct device  const  *)hsotg->dev, "DSTS.Suspend Status=%d HWCFG4.Power Optimize=%d\n",
                        (int )dsts & 1, (int )hsotg->hw_params.power_optimized);
    } else {

    }
    if ((int )dsts & 1 && (unsigned int )*((unsigned char *)hsotg + 38UL) != 0U) {
      if ((unsigned int )*((unsigned char *)hsotg + 3232UL) == 0U) {
        descriptor___2.modname = "dwc2";
        descriptor___2.function = "dwc2_handle_usb_suspend_intr";
        descriptor___2.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core_intr.c";
        descriptor___2.format = "ignore suspend request before enumeration\n";
        descriptor___2.lineno = 425U;
        descriptor___2.flags = 1U;
        tmp___2 = ldv__builtin_expect((long )descriptor___2.flags & 1L, 0L);
        if (tmp___2 != 0L) {
          __dynamic_dev_dbg(& descriptor___2, (struct device  const  *)hsotg->dev,
                            "ignore suspend request before enumeration\n");
        } else {

        }
        goto clear_int;
      } else {

      }
      ret = dwc2_enter_hibernation(hsotg);
      if (ret != 0) {
        if (ret != -524) {
          dev_err((struct device  const  *)hsotg->dev, "enter hibernation failed\n");
        } else {

        }
        goto skip_power_saving;
      } else {

      }
      __const_udelay(429500UL);
      tmp___3 = IS_ERR_OR_NULL((void const   *)hsotg->uphy);
      if (tmp___3) {
        tmp___4 = 0;
      } else {
        tmp___4 = 1;
      }
      if (tmp___4) {
        usb_phy_set_suspend(hsotg->uphy, 1);
      } else {

      }
      skip_power_saving: 
      hsotg->lx_state = 2;
      if (((unsigned int )hsotg->gadget.speed != 0U && (unsigned long )hsotg->driver != (unsigned long )((struct usb_gadget_driver *)0)) && (unsigned long )(hsotg->driver)->suspend != (unsigned long )((void (*)(struct usb_gadget * ))0)) {
        spin_unlock(& hsotg->lock);
        (*((hsotg->driver)->suspend))(& hsotg->gadget);
        spin_lock(& hsotg->lock);
      } else {

      }
    } else {

    }
  } else
  if ((unsigned int )hsotg->op_state == 11U) {
    descriptor___3.modname = "dwc2";
    descriptor___3.function = "dwc2_handle_usb_suspend_intr";
    descriptor___3.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core_intr.c";
    descriptor___3.format = "a_peripheral->a_host\n";
    descriptor___3.lineno = 454U;
    descriptor___3.flags = 1U;
    tmp___5 = ldv__builtin_expect((long )descriptor___3.flags & 1L, 0L);
    if (tmp___5 != 0L) {
      __dynamic_dev_dbg(& descriptor___3, (struct device  const  *)hsotg->dev, "a_peripheral->a_host\n");
    } else {

    }
    hsotg->lx_state = 2;
    spin_unlock(& hsotg->lock);
    dwc2_hcd_start(hsotg);
    spin_lock(& hsotg->lock);
    hsotg->op_state = 9;
  } else {

  }
  clear_int: 
  writel(2048U, (void volatile   *)hsotg->regs + 20U);
  return;
}
}
static u32 dwc2_read_common_intr(struct dwc2_hsotg *hsotg ) 
{ 
  u32 gintsts ;
  u32 gintmsk ;
  u32 gahbcfg ;
  u32 gintmsk_common ;
  struct _ddebug descriptor ;
  long tmp ;

  {
  gintmsk_common = 4043311110U;
  gintsts = readl((void const volatile   *)hsotg->regs + 20U);
  gintmsk = readl((void const volatile   *)hsotg->regs + 24U);
  gahbcfg = readl((void const volatile   *)hsotg->regs + 8U);
  if ((gintsts & gintmsk_common) != 0U) {
    descriptor.modname = "dwc2";
    descriptor.function = "dwc2_read_common_intr";
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core_intr.c";
    descriptor.format = "gintsts=%08x  gintmsk=%08x\n";
    descriptor.lineno = 493U;
    descriptor.flags = 1U;
    tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
    if (tmp != 0L) {
      __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "gintsts=%08x  gintmsk=%08x\n",
                        gintsts, gintmsk);
    } else {

    }
  } else {

  }
  if ((int )gahbcfg & 1) {
    return ((gintsts & gintmsk) & gintmsk_common);
  } else {
    return (0U);
  }
}
}
irqreturn_t dwc2_handle_common_intr(int irq , void *dev ) 
{ 
  struct dwc2_hsotg *hsotg ;
  u32 gintsts ;
  irqreturn_t retval ;
  bool tmp ;
  int tmp___0 ;
  struct _ddebug descriptor ;
  long tmp___1 ;
  int tmp___2 ;

  {
  hsotg = (struct dwc2_hsotg *)dev;
  retval = 0;
  spin_lock(& hsotg->lock);
  tmp = dwc2_is_controller_alive(hsotg);
  if (tmp) {
    tmp___0 = 0;
  } else {
    tmp___0 = 1;
  }
  if (tmp___0) {
    dev_warn((struct device  const  *)hsotg->dev, "Controller is dead\n");
    goto out;
  } else {

  }
  gintsts = dwc2_read_common_intr(hsotg);
  if ((gintsts & 4278190079U) != 0U) {
    retval = 1;
  } else {

  }
  if ((gintsts & 2U) != 0U) {
    dwc2_handle_mode_mismatch_intr(hsotg);
  } else {

  }
  if ((gintsts & 4U) != 0U) {
    dwc2_handle_otg_intr(hsotg);
  } else {

  }
  if ((gintsts & 268435456U) != 0U) {
    dwc2_handle_conn_id_status_change_intr(hsotg);
  } else {

  }
  if ((gintsts & 536870912U) != 0U) {
    dwc2_handle_disconnect_intr(hsotg);
  } else {

  }
  if ((gintsts & 1073741824U) != 0U) {
    dwc2_handle_session_req_intr(hsotg);
  } else {

  }
  if ((int )gintsts < 0) {
    dwc2_handle_wakeup_detected_intr(hsotg);
  } else {

  }
  if ((gintsts & 2048U) != 0U) {
    dwc2_handle_usb_suspend_intr(hsotg);
  } else {

  }
  if ((gintsts & 16777216U) != 0U) {
    tmp___2 = dwc2_is_device_mode(hsotg);
    if (tmp___2 != 0) {
      descriptor.modname = "dwc2";
      descriptor.function = "dwc2_handle_common_intr";
      descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/core_intr.c";
      descriptor.format = " --Port interrupt received in Device mode--\n";
      descriptor.lineno = 553U;
      descriptor.flags = 1U;
      tmp___1 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
      if (tmp___1 != 0L) {
        __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, " --Port interrupt received in Device mode--\n");
      } else {

      }
      dwc2_handle_usb_port_intr(hsotg);
      retval = 1;
    } else {

    }
  } else {

  }
  out: 
  spin_unlock(& hsotg->lock);
  return (retval);
}
}
__inline static bool IS_ERR_OR_NULL(void const   *ptr ) 
{ 
  bool tmp ;

  {
  tmp = ldv_is_err_or_null(ptr);
  return (tmp);
}
}
bool ldv_queue_work_on_19(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_3(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_delayed_work_on_20(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_3(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_work_on_21(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_3(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
void ldv_flush_workqueue_22(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
  flush_workqueue(ldv_func_arg1);
  call_and_disable_all_3(2);
  return;
}
}
bool ldv_queue_delayed_work_on_23(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_3(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
int ldv_mod_timer_24(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;

  {
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
  ldv_func_res = tmp;
  activate_pending_timer_4(ldv_func_arg1, ldv_func_arg2, 1);
  return (ldv_func_res);
}
}
__inline static long ldv__builtin_expect(long exp , long c ) ;
extern struct module __this_module ;
bool ldv_is_err(void const   *ptr ) ;
long ldv_ptr_err(void const   *ptr ) ;
__inline static long PTR_ERR(void const   *ptr ) ;
__inline static bool IS_ERR(void const   *ptr ) ;
extern void __raw_spin_lock_init(raw_spinlock_t * , char const   * , struct lock_class_key * ) ;
__inline static raw_spinlock_t *spinlock_check(spinlock_t *lock ) 
{ 


  {
  return (& lock->__annonCompField18.rlock);
}
}
extern void __mutex_init(struct mutex * , char const   * , struct lock_class_key * ) ;
bool ldv_queue_work_on_35(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_work_on_37(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_delayed_work_on_36(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
bool ldv_queue_delayed_work_on_39(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
void ldv_flush_workqueue_38(struct workqueue_struct *ldv_func_arg1 ) ;
__inline static char const   *kobject_name(struct kobject  const  *kobj ) 
{ 


  {
  return ((char const   *)kobj->name);
}
}
__inline static void ldv_stop(void) 
{ 


  {
  LDV_STOP: ;
  goto LDV_STOP;
}
}
int ldv_state_variable_8  ;
    klee_make_symbolic(&ldv_state_variable_8, sizeof(int), "ldv_state_variable_8");
struct work_struct *ldv_work_struct_3_1  ;
int ldv_timer_4_0  ;
    klee_make_symbolic(&ldv_timer_4_0, sizeof(int), "ldv_timer_4_0");
struct platform_device *dwc2_platform_driver_group1  ;
struct work_struct *ldv_work_struct_1_3  ;
int ldv_state_variable_0  ;
    klee_make_symbolic(&ldv_state_variable_0, sizeof(int), "ldv_state_variable_0");
int ldv_state_variable_5  ;
    klee_make_symbolic(&ldv_state_variable_5, sizeof(int), "ldv_state_variable_5");
struct usb_host_endpoint *dwc2_hc_driver_group2  ;
int ldv_state_variable_13  ;
    klee_make_symbolic(&ldv_state_variable_13, sizeof(int), "ldv_state_variable_13");
int ldv_work_1_1  ;
    klee_make_symbolic(&ldv_work_1_1, sizeof(int), "ldv_work_1_1");
int ldv_state_variable_12  ;
    klee_make_symbolic(&ldv_state_variable_12, sizeof(int), "ldv_state_variable_12");
int ldv_work_3_2  ;
    klee_make_symbolic(&ldv_work_3_2, sizeof(int), "ldv_work_3_2");
struct inode *testmode_fops_group1  ;
int ldv_work_3_0  ;
    klee_make_symbolic(&ldv_work_3_0, sizeof(int), "ldv_work_3_0");
struct work_struct *ldv_work_struct_2_3  ;
struct work_struct *ldv_work_struct_2_0  ;
int ldv_timer_4_3  ;
    klee_make_symbolic(&ldv_timer_4_3, sizeof(int), "ldv_timer_4_3");
int ldv_state_variable_9  ;
    klee_make_symbolic(&ldv_state_variable_9, sizeof(int), "ldv_state_variable_9");
struct work_struct *ldv_work_struct_2_2  ;
struct usb_ep *s3c_hsotg_ep_ops_group0  ;
struct inode *state_fops_group1  ;
struct urb *dwc2_hc_driver_group0  ;
int ref_cnt  ;
    klee_make_symbolic(&ref_cnt, sizeof(int), "ref_cnt");
int ldv_work_3_3  ;
    klee_make_symbolic(&ldv_work_3_3, sizeof(int), "ldv_work_3_3");
struct inode *ep_fops_group1  ;
int ldv_state_variable_1  ;
    klee_make_symbolic(&ldv_state_variable_1, sizeof(int), "ldv_state_variable_1");
int ldv_state_variable_7  ;
    klee_make_symbolic(&ldv_state_variable_7, sizeof(int), "ldv_state_variable_7");
struct work_struct *ldv_work_struct_3_3  ;
struct work_struct *ldv_work_struct_1_0  ;
int ldv_timer_4_2  ;
    klee_make_symbolic(&ldv_timer_4_2, sizeof(int), "ldv_timer_4_2");
struct work_struct *ldv_work_struct_1_1  ;
int ldv_state_variable_10  ;
    klee_make_symbolic(&ldv_state_variable_10, sizeof(int), "ldv_state_variable_10");
struct timer_list *ldv_timer_list_4_0  ;
int ldv_work_1_3  ;
    klee_make_symbolic(&ldv_work_1_3, sizeof(int), "ldv_work_1_3");
struct work_struct *ldv_work_struct_2_1  ;
struct work_struct *ldv_work_struct_3_2  ;
struct inode *fifo_fops_group1  ;
int ldv_state_variable_6  ;
    klee_make_symbolic(&ldv_state_variable_6, sizeof(int), "ldv_state_variable_6");
struct device *dwc2_dev_pm_ops_group1  ;
int ldv_work_3_1  ;
    klee_make_symbolic(&ldv_work_3_1, sizeof(int), "ldv_work_3_1");
int ldv_state_variable_2  ;
    klee_make_symbolic(&ldv_state_variable_2, sizeof(int), "ldv_state_variable_2");
struct usb_request *s3c_hsotg_ep_ops_group1  ;
int ldv_work_2_0  ;
    klee_make_symbolic(&ldv_work_2_0, sizeof(int), "ldv_work_2_0");
struct usb_gadget *s3c_hsotg_gadget_ops_group0  ;
struct work_struct *ldv_work_struct_3_0  ;
int ldv_state_variable_11  ;
    klee_make_symbolic(&ldv_state_variable_11, sizeof(int), "ldv_state_variable_11");
int ldv_work_1_2  ;
    klee_make_symbolic(&ldv_work_1_2, sizeof(int), "ldv_work_1_2");
struct timer_list *ldv_timer_list_4_3  ;
struct usb_hcd *dwc2_hc_driver_group1  ;
struct timer_list *ldv_timer_list_4_2  ;
struct file *state_fops_group2  ;
struct work_struct *ldv_work_struct_1_2  ;
struct file *ep_fops_group2  ;
int ldv_work_2_2  ;
    klee_make_symbolic(&ldv_work_2_2, sizeof(int), "ldv_work_2_2");
int ldv_state_variable_3  ;
    klee_make_symbolic(&ldv_state_variable_3, sizeof(int), "ldv_state_variable_3");
struct file *testmode_fops_group2  ;
int ldv_timer_4_1  ;
    klee_make_symbolic(&ldv_timer_4_1, sizeof(int), "ldv_timer_4_1");
int ldv_work_1_0  ;
    klee_make_symbolic(&ldv_work_1_0, sizeof(int), "ldv_work_1_0");
struct timer_list *ldv_timer_list_4_1  ;
int ldv_work_2_3  ;
    klee_make_symbolic(&ldv_work_2_3, sizeof(int), "ldv_work_2_3");
int ldv_state_variable_4  ;
    klee_make_symbolic(&ldv_state_variable_4, sizeof(int), "ldv_state_variable_4");
int ldv_work_2_1  ;
    klee_make_symbolic(&ldv_work_2_1, sizeof(int), "ldv_work_2_1");
struct file *fifo_fops_group2  ;
void work_init_3(void) ;
void ldv_file_operations_7(void) ;
void ldv_file_operations_6(void) ;
void ldv_initialize_usb_gadget_ops_9(void) ;
void work_init_2(void) ;
void timer_init_4(void) ;
void ldv_platform_driver_init_12(void) ;
void ldv_file_operations_8(void) ;
void work_init_1(void) ;
void ldv_initialize_usb_ep_ops_10(void) ;
void ldv_dev_pm_ops_13(void) ;
void ldv_platform_probe_12(int (*probe)(struct platform_device * ) ) ;
void ldv_file_operations_5(void) ;
void ldv_initialize_hc_driver_11(void) ;
extern void *devm_ioremap_resource(struct device * , struct resource * ) ;
__inline static char const   *dev_name(struct device  const  *dev ) 
{ 
  char const   *tmp ;

  {
  if ((unsigned long )dev->init_name != (unsigned long )((char const   */* const  */)0)) {
    return ((char const   *)dev->init_name);
  } else {

  }
  tmp = kobject_name(& dev->kobj);
  return (tmp);
}
}
__inline static void *dev_get_drvdata(struct device  const  *dev ) 
{ 


  {
  return ((void *)dev->driver_data);
}
}
__inline static void dev_set_drvdata(struct device *dev , void *data ) 
{ 


  {
  dev->driver_data = data;
  return;
}
}
extern int dma_supported(struct device * , u64  ) ;
__inline static int dma_set_coherent_mask(struct device *dev , u64 mask ) 
{ 
  int tmp ;

  {
  tmp = dma_supported(dev, mask);
  if (tmp == 0) {
    return (-5);
  } else {

  }
  dev->coherent_dma_mask = mask;
  return (0);
}
}
extern struct resource *platform_get_resource(struct platform_device * , unsigned int  ,
                                              unsigned int  ) ;
extern int platform_get_irq(struct platform_device * , unsigned int  ) ;
extern int __platform_driver_register(struct platform_driver * , struct module * ) ;
int ldv___platform_driver_register_40(struct platform_driver *ldv_func_arg1 , struct module *ldv_func_arg2 ) ;
extern void platform_driver_unregister(struct platform_driver * ) ;
void ldv_platform_driver_unregister_41(struct platform_driver *ldv_func_arg1 ) ;
__inline static void *platform_get_drvdata(struct platform_device  const  *pdev ) 
{ 
  void *tmp ;

  {
  tmp = dev_get_drvdata(& pdev->dev);
  return (tmp);
}
}
__inline static void platform_set_drvdata(struct platform_device *pdev , void *data ) 
{ 


  {
  dev_set_drvdata(& pdev->dev, data);
  return;
}
}
extern struct of_device_id  const  *of_match_device(struct of_device_id  const  * ,
                                                    struct device  const  * ) ;
extern int phy_init(struct phy * ) ;
extern int phy_exit(struct phy * ) ;
extern int phy_power_on(struct phy * ) ;
extern int phy_power_off(struct phy * ) ;
extern struct phy *devm_phy_get(struct device * , char const   * ) ;
extern int devm_request_threaded_irq(struct device * , unsigned int  , irqreturn_t (*)(int  ,
                                                                                       void * ) ,
                                     irqreturn_t (*)(int  , void * ) , unsigned long  ,
                                     char const   * , void * ) ;
__inline static int devm_request_irq(struct device *dev , unsigned int irq , irqreturn_t (*handler)(int  ,
                                                                                                    void * ) ,
                                     unsigned long irqflags , char const   *devname ,
                                     void *dev_id ) 
{ 
  int tmp ;

  {
  tmp = devm_request_threaded_irq(dev, irq, handler, (irqreturn_t (*)(int  , void * ))0,
                                  irqflags, devname, dev_id);
  return (tmp);
}
}
extern struct usb_phy *devm_usb_get_phy(struct device * , enum usb_phy_type  ) ;
extern enum usb_dr_mode of_usb_get_dr_mode(struct device_node * ) ;
int s3c_hsotg_remove(struct dwc2_hsotg *hsotg ) ;
int s3c_hsotg_suspend(struct dwc2_hsotg *hsotg ) ;
int s3c_hsotg_resume(struct dwc2_hsotg *hsotg ) ;
int dwc2_gadget_init(struct dwc2_hsotg *hsotg , int irq ) ;
int dwc2_hcd_init(struct dwc2_hsotg *hsotg , int irq ) ;
void dwc2_hcd_remove(struct dwc2_hsotg *hsotg ) ;
int dwc2_debugfs_init(struct dwc2_hsotg *hsotg ) ;
void dwc2_debugfs_exit(struct dwc2_hsotg *hsotg ) ;
static char const   dwc2_driver_name[5U]  = {      'd',      'w',      'c',      '2', 
        '\000'};
static struct dwc2_core_params  const  params_bcm2835  = 
     {0, 0, 1, 0, 0, 1, 1, 774, 256, 512, 65535, 511, 8, 1, 8, 0, 0, 0, 0, 0, 0, 0,
    0, 16, 0, -1, -1};
static struct dwc2_core_params  const  params_rk3066  = 
     {2, -1, -1, 0, -1, 1, -1, 520, 128, 256, 65535, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, 7, -1, -1, -1};
static int dwc2_driver_remove(struct platform_device *dev ) 
{ 
  struct dwc2_hsotg *hsotg ;
  void *tmp ;

  {
  tmp = platform_get_drvdata((struct platform_device  const  *)dev);
  hsotg = (struct dwc2_hsotg *)tmp;
  dwc2_debugfs_exit(hsotg);
  if ((unsigned int )*((unsigned char *)hsotg + 64UL) != 0U) {
    dwc2_hcd_remove(hsotg);
  } else {

  }
  if ((unsigned int )*((unsigned char *)hsotg + 64UL) != 0U) {
    s3c_hsotg_remove(hsotg);
  } else {

  }
  return (0);
}
}
static struct of_device_id  const  dwc2_of_match_table[5U]  = {      {{(char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
       (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
       (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
       (char)0, (char)0, (char)0, (char)0, (char)0}, {(char)0, (char)0, (char)0, (char)0,
                                                      (char)0, (char)0, (char)0, (char)0,
                                                      (char)0, (char)0, (char)0, (char)0,
                                                      (char)0, (char)0, (char)0, (char)0,
                                                      (char)0, (char)0, (char)0, (char)0,
                                                      (char)0, (char)0, (char)0, (char)0,
                                                      (char)0, (char)0, (char)0, (char)0,
                                                      (char)0, (char)0, (char)0, (char)0},
      {'b', 'r', 'c', 'm', ',', 'b', 'c', 'm', '2', '8', '3', '5', '-', 'u', 's',
       'b', '\000'}, (void const   *)(& params_bcm2835)}, 
        {{(char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
       (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
       (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
       (char)0, (char)0, (char)0, (char)0, (char)0}, {(char)0, (char)0, (char)0, (char)0,
                                                      (char)0, (char)0, (char)0, (char)0,
                                                      (char)0, (char)0, (char)0, (char)0,
                                                      (char)0, (char)0, (char)0, (char)0,
                                                      (char)0, (char)0, (char)0, (char)0,
                                                      (char)0, (char)0, (char)0, (char)0,
                                                      (char)0, (char)0, (char)0, (char)0,
                                                      (char)0, (char)0, (char)0, (char)0},
      {'r', 'o', 'c', 'k', 'c', 'h', 'i', 'p', ',', 'r', 'k', '3', '0', '6', '6',
       '-', 'u', 's', 'b', '\000'}, (void const   *)(& params_rk3066)}, 
        {{(char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
       (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
       (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
       (char)0, (char)0, (char)0, (char)0, (char)0}, {(char)0, (char)0, (char)0, (char)0,
                                                      (char)0, (char)0, (char)0, (char)0,
                                                      (char)0, (char)0, (char)0, (char)0,
                                                      (char)0, (char)0, (char)0, (char)0,
                                                      (char)0, (char)0, (char)0, (char)0,
                                                      (char)0, (char)0, (char)0, (char)0,
                                                      (char)0, (char)0, (char)0, (char)0,
                                                      (char)0, (char)0, (char)0, (char)0},
      {'s', 'n', 'p', 's', ',', 'd', 'w', 'c', '2', '\000'}, (void const   *)0}, 
        {{(char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
       (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
       (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
       (char)0, (char)0, (char)0, (char)0, (char)0}, {(char)0, (char)0, (char)0, (char)0,
                                                      (char)0, (char)0, (char)0, (char)0,
                                                      (char)0, (char)0, (char)0, (char)0,
                                                      (char)0, (char)0, (char)0, (char)0,
                                                      (char)0, (char)0, (char)0, (char)0,
                                                      (char)0, (char)0, (char)0, (char)0,
                                                      (char)0, (char)0, (char)0, (char)0,
                                                      (char)0, (char)0, (char)0, (char)0},
      {'s', 'a', 'm', 's', 'u', 'n', 'g', ',', 's', '3', 'c', '6', '4', '0', '0',
       '-', 'h', 's', 'o', 't', 'g', '\000'}, (void const   *)0}};
struct of_device_id  const  __mod_of__dwc2_of_match_table_device_table[5U]  ;
static int dwc2_driver_probe(struct platform_device *dev ) 
{ 
  struct of_device_id  const  *match ;
  struct dwc2_core_params  const  *params ;
  struct dwc2_core_params defparams ;
  struct dwc2_hsotg *hsotg ;
  struct resource *res ;
  struct phy *phy ;
  struct usb_phy *uphy ;
  int retval ;
  int irq ;
  void *tmp ;
  struct _ddebug descriptor ;
  long tmp___0 ;
  char const   *tmp___1 ;
  long tmp___2 ;
  bool tmp___3 ;
  struct _ddebug descriptor___0 ;
  long tmp___4 ;
  bool tmp___5 ;
  bool tmp___6 ;
  struct lock_class_key __key ;
  struct lock_class_key __key___0 ;
  void *tmp___7 ;

  {
  match = of_match_device((struct of_device_id  const  *)(& dwc2_of_match_table),
                          (struct device  const  *)(& dev->dev));
  if ((unsigned long )match != (unsigned long )((struct of_device_id  const  *)0) && (unsigned long )match->data != (unsigned long )((void const   */* const  */)0)) {
    params = (struct dwc2_core_params  const  *)match->data;
  } else {
    dwc2_set_all_params(& defparams, -1);
    params = (struct dwc2_core_params  const  *)(& defparams);
    defparams.dma_desc_enable = 0;
  }
  tmp = devm_kzalloc(& dev->dev, 3584UL, 208U);
  hsotg = (struct dwc2_hsotg *)tmp;
  if ((unsigned long )hsotg == (unsigned long )((struct dwc2_hsotg *)0)) {
    return (-12);
  } else {

  }
  hsotg->dev = & dev->dev;
  if ((unsigned long )dev->dev.dma_mask == (unsigned long )((u64 *)0ULL)) {
    dev->dev.dma_mask = & dev->dev.coherent_dma_mask;
  } else {

  }
  retval = dma_set_coherent_mask(& dev->dev, 4294967295ULL);
  if (retval != 0) {
    return (retval);
  } else {

  }
  irq = platform_get_irq(dev, 0U);
  if (irq < 0) {
    dev_err((struct device  const  *)(& dev->dev), "missing IRQ resource\n");
    return (irq);
  } else {

  }
  descriptor.modname = "dwc2";
  descriptor.function = "dwc2_driver_probe";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/platform.c";
  descriptor.format = "registering common handler for irq%d\n";
  descriptor.lineno = 208U;
  descriptor.flags = 1U;
  tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp___0 != 0L) {
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "registering common handler for irq%d\n",
                      irq);
  } else {

  }
  tmp___1 = dev_name((struct device  const  *)hsotg->dev);
  retval = devm_request_irq(hsotg->dev, (unsigned int )irq, & dwc2_handle_common_intr,
                            128UL, tmp___1, (void *)hsotg);
  if (retval != 0) {
    return (retval);
  } else {

  }
  res = platform_get_resource(dev, 512U, 0U);
  hsotg->regs = devm_ioremap_resource(& dev->dev, res);
  tmp___3 = IS_ERR((void const   *)hsotg->regs);
  if ((int )tmp___3) {
    tmp___2 = PTR_ERR((void const   *)hsotg->regs);
    return ((int )tmp___2);
  } else {

  }
  descriptor___0.modname = "dwc2";
  descriptor___0.function = "dwc2_driver_probe";
  descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/platform.c";
  descriptor___0.format = "mapped PA %08lx to VA %p\n";
  descriptor___0.lineno = 221U;
  descriptor___0.flags = 1U;
  tmp___4 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
  if (tmp___4 != 0L) {
    __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)(& dev->dev), "mapped PA %08lx to VA %p\n",
                      (unsigned long )res->start, hsotg->regs);
  } else {

  }
  hsotg->dr_mode = of_usb_get_dr_mode(dev->dev.of_node);
  phy = devm_phy_get(& dev->dev, "usb2-phy");
  tmp___6 = IS_ERR((void const   *)phy);
  if ((int )tmp___6) {
    hsotg->phy = (struct phy *)0;
    uphy = devm_usb_get_phy(& dev->dev, 1);
    tmp___5 = IS_ERR((void const   *)uphy);
    if ((int )tmp___5) {
      hsotg->uphy = (struct usb_phy *)0;
    } else {
      hsotg->uphy = uphy;
    }
  } else {
    hsotg->phy = phy;
    phy_power_on(hsotg->phy);
    phy_init(hsotg->phy);
  }
  spinlock_check(& hsotg->lock);
  __raw_spin_lock_init(& hsotg->lock.__annonCompField18.rlock, "&(&hsotg->lock)->rlock",
                       & __key);
  __mutex_init(& hsotg->init_mutex, "&hsotg->init_mutex", & __key___0);
  retval = dwc2_get_hwparams(hsotg);
  if (retval != 0) {
    return (retval);
  } else {

  }
  tmp___7 = devm_kzalloc(& dev->dev, 108UL, 208U);
  hsotg->core_params = (struct dwc2_core_params *)tmp___7;
  if ((unsigned long )hsotg->core_params == (unsigned long )((struct dwc2_core_params *)0)) {
    return (-12);
  } else {

  }
  dwc2_set_all_params(hsotg->core_params, -1);
  dwc2_set_parameters(hsotg, params);
  if ((unsigned int )hsotg->dr_mode != 1U) {
    retval = dwc2_gadget_init(hsotg, irq);
    if (retval != 0) {
      return (retval);
    } else {

    }
    hsotg->gadget_enabled = 1U;
  } else {

  }
  if ((unsigned int )hsotg->dr_mode != 2U) {
    retval = dwc2_hcd_init(hsotg, irq);
    if (retval != 0) {
      if ((unsigned int )*((unsigned char *)hsotg + 64UL) != 0U) {
        s3c_hsotg_remove(hsotg);
      } else {

      }
      return (retval);
    } else {

    }
    hsotg->hcd_enabled = 1U;
  } else {

  }
  platform_set_drvdata(dev, (void *)hsotg);
  dwc2_debugfs_init(hsotg);
  return (retval);
}
}
static int dwc2_suspend(struct device *dev ) 
{ 
  struct dwc2_hsotg *dwc2 ;
  void *tmp ;
  int ret ;
  int tmp___0 ;

  {
  tmp = dev_get_drvdata((struct device  const  *)dev);
  dwc2 = (struct dwc2_hsotg *)tmp;
  ret = 0;
  tmp___0 = dwc2_is_device_mode(dwc2);
  if (tmp___0 != 0) {
    ret = s3c_hsotg_suspend(dwc2);
  } else {
    if ((unsigned int )dwc2->lx_state == 0U) {
      return (0);
    } else {

    }
    phy_exit(dwc2->phy);
    phy_power_off(dwc2->phy);
  }
  return (ret);
}
}
static int dwc2_resume(struct device *dev ) 
{ 
  struct dwc2_hsotg *dwc2 ;
  void *tmp ;
  int ret ;
  int tmp___0 ;

  {
  tmp = dev_get_drvdata((struct device  const  *)dev);
  dwc2 = (struct dwc2_hsotg *)tmp;
  ret = 0;
  tmp___0 = dwc2_is_device_mode(dwc2);
  if (tmp___0 != 0) {
    ret = s3c_hsotg_resume(dwc2);
  } else {
    phy_power_on(dwc2->phy);
    phy_init(dwc2->phy);
  }
  return (ret);
}
}
static struct dev_pm_ops  const  dwc2_dev_pm_ops  = 
     {0, 0, & dwc2_suspend, & dwc2_resume, & dwc2_suspend, & dwc2_resume, & dwc2_suspend,
    & dwc2_resume, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
static struct platform_driver dwc2_platform_driver  = 
     {& dwc2_driver_probe, & dwc2_driver_remove, 0, 0, 0, {(char const   *)(& dwc2_driver_name),
                                                         0, 0, 0, (_Bool)0, 0, (struct of_device_id  const  *)(& dwc2_of_match_table),
                                                         0, 0, 0, 0, 0, 0, 0, & dwc2_dev_pm_ops,
                                                         0}, 0, (_Bool)0};
static int dwc2_platform_driver_init(void) 
{ 
  int tmp ;

  {
  tmp = ldv___platform_driver_register_40(& dwc2_platform_driver, & __this_module);
  return (tmp);
}
}
static void dwc2_platform_driver_exit(void) 
{ 


  {
  ldv_platform_driver_unregister_41(& dwc2_platform_driver);
  return;
}
}
int ldv_retval_20  ;
    klee_make_symbolic(&ldv_retval_20, sizeof(int), "ldv_retval_20");
int ldv_retval_18  ;
    klee_make_symbolic(&ldv_retval_18, sizeof(int), "ldv_retval_18");
int ldv_retval_23  ;
    klee_make_symbolic(&ldv_retval_23, sizeof(int), "ldv_retval_23");
extern int ldv_freeze_noirq_13(void) ;
extern int ldv_thaw_noirq_13(void) ;
int ldv_retval_11  ;
    klee_make_symbolic(&ldv_retval_11, sizeof(int), "ldv_retval_11");
extern int ldv_poweroff_noirq_13(void) ;
int ldv_retval_25  ;
    klee_make_symbolic(&ldv_retval_25, sizeof(int), "ldv_retval_25");
int ldv_retval_22  ;
    klee_make_symbolic(&ldv_retval_22, sizeof(int), "ldv_retval_22");
extern int ldv_suspend_noirq_13(void) ;
int ldv_retval_15  ;
    klee_make_symbolic(&ldv_retval_15, sizeof(int), "ldv_retval_15");
extern int ldv_suspend_late_13(void) ;
int ldv_retval_16  ;
    klee_make_symbolic(&ldv_retval_16, sizeof(int), "ldv_retval_16");
int ldv_retval_24  ;
    klee_make_symbolic(&ldv_retval_24, sizeof(int), "ldv_retval_24");
void ldv_check_final_state(void) ;
int ldv_retval_8  ;
    klee_make_symbolic(&ldv_retval_8, sizeof(int), "ldv_retval_8");
int ldv_retval_7  ;
    klee_make_symbolic(&ldv_retval_7, sizeof(int), "ldv_retval_7");
extern int ldv_restore_noirq_13(void) ;
extern int ldv_resume_noirq_13(void) ;
int ldv_retval_19  ;
    klee_make_symbolic(&ldv_retval_19, sizeof(int), "ldv_retval_19");
int ldv_retval_14  ;
    klee_make_symbolic(&ldv_retval_14, sizeof(int), "ldv_retval_14");
extern int ldv_prepare_13(void) ;
int ldv_retval_17  ;
    klee_make_symbolic(&ldv_retval_17, sizeof(int), "ldv_retval_17");
int ldv_retval_12  ;
    klee_make_symbolic(&ldv_retval_12, sizeof(int), "ldv_retval_12");
extern void ldv_initialize(void) ;
int ldv_retval_6  ;
    klee_make_symbolic(&ldv_retval_6, sizeof(int), "ldv_retval_6");
extern int ldv_complete_13(void) ;
extern int ldv_restore_early_13(void) ;
int ldv_retval_21  ;
    klee_make_symbolic(&ldv_retval_21, sizeof(int), "ldv_retval_21");
int ldv_retval_13  ;
    klee_make_symbolic(&ldv_retval_13, sizeof(int), "ldv_retval_13");
int ldv_retval_9  ;
    klee_make_symbolic(&ldv_retval_9, sizeof(int), "ldv_retval_9");
int ldv_retval_10  ;
    klee_make_symbolic(&ldv_retval_10, sizeof(int), "ldv_retval_10");
extern int ldv_thaw_early_13(void) ;
extern int ldv_resume_early_13(void) ;
extern int ldv_freeze_late_13(void) ;
extern int ldv_poweroff_late_13(void) ;
int ldv_retval_4  ;
    klee_make_symbolic(&ldv_retval_4, sizeof(int), "ldv_retval_4");
int ldv_retval_3  ;
    klee_make_symbolic(&ldv_retval_3, sizeof(int), "ldv_retval_3");
void ldv_platform_driver_init_12(void) 
{ 
  void *tmp ;

  {
  tmp = ldv_init_zalloc(1472UL);
  dwc2_platform_driver_group1 = (struct platform_device *)tmp;
  return;
}
}
void ldv_dev_pm_ops_13(void) 
{ 
  void *tmp ;

  {
  tmp = ldv_init_zalloc(1416UL);
  dwc2_dev_pm_ops_group1 = (struct device *)tmp;
  return;
}
}
void ldv_platform_probe_12(int (*probe)(struct platform_device * ) ) 
{ 
  int err ;
    klee_make_symbolic(&err, sizeof(int), "err");

  {
  err = (*probe)(dwc2_platform_driver_group1);
  if (err == 0) {
    probed_12 = 1;
    ref_cnt = ref_cnt + 1;
  } else {

  }
  return;
}
}
void ldv_main_exported_10(void) ;
void ldv_main_exported_9(void) ;
void ldv_main_exported_8(void) ;
void ldv_main_exported_6(void) ;
void ldv_main_exported_7(void) ;
void ldv_main_exported_5(void) ;
void ldv_main_exported_11(void) ;
int main(void) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  ldv_initialize();
  ldv_state_variable_6 = 0;
  ldv_state_variable_11 = 0;
  work_init_3();
  ldv_state_variable_3 = 1;
  ldv_state_variable_7 = 0;
  ldv_state_variable_9 = 0;
  ldv_state_variable_12 = 0;
  work_init_2();
  ldv_state_variable_2 = 1;
  ldv_state_variable_8 = 0;
  work_init_1();
  ldv_state_variable_1 = 1;
  timer_init_4();
  ldv_state_variable_4 = 1;
  ref_cnt = 0;
  ldv_state_variable_0 = 1;
  ldv_state_variable_13 = 0;
  ldv_state_variable_10 = 0;
  ldv_state_variable_5 = 0;
  ldv_34745: 
  tmp = __VERIFIER_nondet_int();
  switch (tmp) {
  case 0: ;
  if (ldv_state_variable_6 != 0) {
    ldv_main_exported_6();
  } else {

  }
  goto ldv_34699;
  case 1: ;
  if (ldv_state_variable_11 != 0) {
    ldv_main_exported_11();
  } else {

  }
  goto ldv_34699;
  case 2: ;
  goto ldv_34699;
  case 3: ;
  if (ldv_state_variable_7 != 0) {
    ldv_main_exported_7();
  } else {

  }
  goto ldv_34699;
  case 4: ;
  if (ldv_state_variable_9 != 0) {
    ldv_main_exported_9();
  } else {

  }
  goto ldv_34699;
  case 5: ;
  if (ldv_state_variable_12 != 0) {
    tmp___0 = __VERIFIER_nondet_int();
    switch (tmp___0) {
    case 0: ;
    if (ldv_state_variable_12 == 1) {
      ldv_retval_4 = dwc2_driver_probe(dwc2_platform_driver_group1);
      if (ldv_retval_4 == 0) {
        ldv_state_variable_12 = 2;
        ref_cnt = ref_cnt + 1;
        probed_12 = 1;
      } else {

      }
    } else {

    }
    goto ldv_34706;
    case 1: ;
    if (ldv_state_variable_12 == 1 && probed_12 == 1) {
      ldv_retval_3 = dwc2_driver_remove(dwc2_platform_driver_group1);
      if (ldv_retval_3 == 0) {
        ldv_state_variable_12 = 1;
        ref_cnt = ref_cnt - 1;
        probed_12 = 0;
      } else {

      }
    } else {

    }
    if (ldv_state_variable_12 == 2 && probed_12 == 1) {
      ldv_retval_3 = dwc2_driver_remove(dwc2_platform_driver_group1);
      if (ldv_retval_3 == 0) {
        ldv_state_variable_12 = 1;
        ref_cnt = ref_cnt - 1;
        probed_12 = 0;
      } else {

      }
    } else {

    }
    goto ldv_34706;
    default: 
    ldv_stop();
    }
    ldv_34706: ;
  } else {

  }
  goto ldv_34699;
  case 6: ;
  goto ldv_34699;
  case 7: ;
  if (ldv_state_variable_8 != 0) {
    ldv_main_exported_8();
  } else {

  }
  goto ldv_34699;
  case 8: ;
  goto ldv_34699;
  case 9: ;
  goto ldv_34699;
  case 10: ;
  if (ldv_state_variable_0 != 0) {
    tmp___1 = __VERIFIER_nondet_int();
    switch (tmp___1) {
    case 0: ;
    if (ldv_state_variable_0 == 3 && ref_cnt == 0) {
      dwc2_platform_driver_exit();
      ldv_state_variable_0 = 2;
      goto ldv_final;
    } else {

    }
    goto ldv_34716;
    case 1: ;
    if (ldv_state_variable_0 == 1) {
      ldv_retval_6 = dwc2_platform_driver_init();
      if (ldv_retval_6 == 0) {
        ldv_state_variable_0 = 3;
        ldv_state_variable_5 = 1;
        ldv_file_operations_5();
        ldv_state_variable_13 = 1;
        ldv_dev_pm_ops_13();
        ldv_state_variable_10 = 1;
        ldv_initialize_usb_ep_ops_10();
        ldv_state_variable_8 = 1;
        ldv_file_operations_8();
        ldv_state_variable_9 = 1;
        ldv_initialize_usb_gadget_ops_9();
        ldv_state_variable_7 = 1;
        ldv_file_operations_7();
        ldv_state_variable_11 = 1;
        ldv_initialize_hc_driver_11();
        ldv_state_variable_6 = 1;
        ldv_file_operations_6();
      } else {

      }
      if (ldv_retval_6 != 0) {
        ldv_state_variable_0 = 2;
        goto ldv_final;
      } else {

      }
    } else {

    }
    goto ldv_34716;
    default: 
    ldv_stop();
    }
    ldv_34716: ;
  } else {

  }
  goto ldv_34699;
  case 11: ;
  if (ldv_state_variable_13 != 0) {
    tmp___2 = __VERIFIER_nondet_int();
    switch (tmp___2) {
    case 0: ;
    if (ldv_state_variable_13 == 12) {
      ldv_retval_25 = dwc2_resume(dwc2_dev_pm_ops_group1);
      if (ldv_retval_25 == 0) {
        ldv_state_variable_13 = 15;
      } else {

      }
    } else {

    }
    goto ldv_34721;
    case 1: ;
    if (ldv_state_variable_13 == 13) {
      ldv_retval_24 = dwc2_resume(dwc2_dev_pm_ops_group1);
      if (ldv_retval_24 == 0) {
        ldv_state_variable_13 = 15;
      } else {

      }
    } else {

    }
    goto ldv_34721;
    case 2: ;
    if (ldv_state_variable_13 == 2) {
      ldv_retval_23 = dwc2_suspend(dwc2_dev_pm_ops_group1);
      if (ldv_retval_23 == 0) {
        ldv_state_variable_13 = 3;
      } else {

      }
    } else {

    }
    goto ldv_34721;
    case 3: ;
    if (ldv_state_variable_13 == 2) {
      ldv_retval_22 = dwc2_suspend(dwc2_dev_pm_ops_group1);
      if (ldv_retval_22 == 0) {
        ldv_state_variable_13 = 4;
      } else {

      }
    } else {

    }
    goto ldv_34721;
    case 4: ;
    if (ldv_state_variable_13 == 2) {
      ldv_retval_21 = dwc2_suspend(dwc2_dev_pm_ops_group1);
      if (ldv_retval_21 == 0) {
        ldv_state_variable_13 = 5;
      } else {

      }
    } else {

    }
    goto ldv_34721;
    case 5: ;
    if (ldv_state_variable_13 == 14) {
      ldv_retval_20 = dwc2_resume(dwc2_dev_pm_ops_group1);
      if (ldv_retval_20 == 0) {
        ldv_state_variable_13 = 15;
      } else {

      }
    } else {

    }
    goto ldv_34721;
    case 6: ;
    if (ldv_state_variable_13 == 5) {
      ldv_retval_19 = ldv_suspend_late_13();
      if (ldv_retval_19 == 0) {
        ldv_state_variable_13 = 10;
      } else {

      }
    } else {

    }
    goto ldv_34721;
    case 7: ;
    if (ldv_state_variable_13 == 7) {
      ldv_retval_18 = ldv_restore_early_13();
      if (ldv_retval_18 == 0) {
        ldv_state_variable_13 = 12;
      } else {

      }
    } else {

    }
    goto ldv_34721;
    case 8: ;
    if (ldv_state_variable_13 == 10) {
      ldv_retval_17 = ldv_resume_early_13();
      if (ldv_retval_17 == 0) {
        ldv_state_variable_13 = 14;
      } else {

      }
    } else {

    }
    goto ldv_34721;
    case 9: ;
    if (ldv_state_variable_13 == 9) {
      ldv_retval_16 = ldv_thaw_early_13();
      if (ldv_retval_16 == 0) {
        ldv_state_variable_13 = 13;
      } else {

      }
    } else {

    }
    goto ldv_34721;
    case 10: ;
    if (ldv_state_variable_13 == 11) {
      ldv_retval_15 = ldv_resume_noirq_13();
      if (ldv_retval_15 == 0) {
        ldv_state_variable_13 = 14;
      } else {

      }
    } else {

    }
    goto ldv_34721;
    case 11: ;
    if (ldv_state_variable_13 == 4) {
      ldv_retval_14 = ldv_freeze_noirq_13();
      if (ldv_retval_14 == 0) {
        ldv_state_variable_13 = 8;
      } else {

      }
    } else {

    }
    goto ldv_34721;
    case 12: ;
    if (ldv_state_variable_13 == 1) {
      ldv_retval_13 = ldv_prepare_13();
      if (ldv_retval_13 == 0) {
        ldv_state_variable_13 = 2;
        ref_cnt = ref_cnt + 1;
      } else {

      }
    } else {

    }
    goto ldv_34721;
    case 13: ;
    if (ldv_state_variable_13 == 4) {
      ldv_retval_12 = ldv_freeze_late_13();
      if (ldv_retval_12 == 0) {
        ldv_state_variable_13 = 9;
      } else {

      }
    } else {

    }
    goto ldv_34721;
    case 14: ;
    if (ldv_state_variable_13 == 8) {
      ldv_retval_11 = ldv_thaw_noirq_13();
      if (ldv_retval_11 == 0) {
        ldv_state_variable_13 = 13;
      } else {

      }
    } else {

    }
    goto ldv_34721;
    case 15: ;
    if (ldv_state_variable_13 == 3) {
      ldv_retval_10 = ldv_poweroff_noirq_13();
      if (ldv_retval_10 == 0) {
        ldv_state_variable_13 = 6;
      } else {

      }
    } else {

    }
    goto ldv_34721;
    case 16: ;
    if (ldv_state_variable_13 == 3) {
      ldv_retval_9 = ldv_poweroff_late_13();
      if (ldv_retval_9 == 0) {
        ldv_state_variable_13 = 7;
      } else {

      }
    } else {

    }
    goto ldv_34721;
    case 17: ;
    if (ldv_state_variable_13 == 6) {
      ldv_retval_8 = ldv_restore_noirq_13();
      if (ldv_retval_8 == 0) {
        ldv_state_variable_13 = 12;
      } else {

      }
    } else {

    }
    goto ldv_34721;
    case 18: ;
    if (ldv_state_variable_13 == 5) {
      ldv_retval_7 = ldv_suspend_noirq_13();
      if (ldv_retval_7 == 0) {
        ldv_state_variable_13 = 11;
      } else {

      }
    } else {

    }
    goto ldv_34721;
    case 19: ;
    if (ldv_state_variable_13 == 15) {
      ldv_complete_13();
      ldv_state_variable_13 = 1;
      ref_cnt = ref_cnt - 1;
    } else {

    }
    goto ldv_34721;
    default: 
    ldv_stop();
    }
    ldv_34721: ;
  } else {

  }
  goto ldv_34699;
  case 12: ;
  if (ldv_state_variable_10 != 0) {
    ldv_main_exported_10();
  } else {

  }
  goto ldv_34699;
  case 13: ;
  if (ldv_state_variable_5 != 0) {
    ldv_main_exported_5();
  } else {

  }
  goto ldv_34699;
  default: 
  ldv_stop();
  }
  ldv_34699: ;
  goto ldv_34745;
  ldv_final: 
  ldv_check_final_state();
  return 0;
}
}
__inline static long PTR_ERR(void const   *ptr ) 
{ 
  long tmp ;

  {
  tmp = ldv_ptr_err(ptr);
  return (tmp);
}
}
__inline static bool IS_ERR(void const   *ptr ) 
{ 
  bool tmp ;

  {
  tmp = ldv_is_err(ptr);
  return (tmp);
}
}
bool ldv_queue_work_on_35(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_3(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_delayed_work_on_36(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_3(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_work_on_37(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_3(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
void ldv_flush_workqueue_38(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
  flush_workqueue(ldv_func_arg1);
  call_and_disable_all_3(2);
  return;
}
}
bool ldv_queue_delayed_work_on_39(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_3(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
int ldv___platform_driver_register_40(struct platform_driver *ldv_func_arg1 , struct module *ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;

  {
  tmp = __platform_driver_register(ldv_func_arg1, ldv_func_arg2);
  ldv_func_res = tmp;
  ldv_state_variable_12 = 1;
  ldv_platform_driver_init_12();
  return (ldv_func_res);
}
}
void ldv_platform_driver_unregister_41(struct platform_driver *ldv_func_arg1 ) 
{ 


  {
  platform_driver_unregister(ldv_func_arg1);
  ldv_state_variable_12 = 0;
  return;
}
}
__inline static long ldv__builtin_expect(long exp , long c ) ;
__inline static void INIT_LIST_HEAD(struct list_head *list ) 
{ 


  {
  list->next = list;
  list->prev = list;
  return;
}
}
extern void __list_add(struct list_head * , struct list_head * , struct list_head * ) ;
__inline static void list_add(struct list_head *new , struct list_head *head ) 
{ 


  {
  __list_add(new, head, head->next);
  return;
}
}
__inline static void list_add_tail(struct list_head *new , struct list_head *head ) 
{ 


  {
  __list_add(new, head->prev, head);
  return;
}
}
extern void __list_del_entry(struct list_head * ) ;
extern void list_del(struct list_head * ) ;
__inline static void list_del_init(struct list_head *entry ) 
{ 


  {
  __list_del_entry(entry);
  INIT_LIST_HEAD(entry);
  return;
}
}
__inline static void list_move(struct list_head *list , struct list_head *head ) 
{ 


  {
  __list_del_entry(list);
  list_add(list, head);
  return;
}
}
__inline static int list_empty(struct list_head  const  *head ) 
{ 


  {
  return ((unsigned long )((struct list_head  const  *)head->next) == (unsigned long )head);
}
}
extern void warn_slowpath_null(char const   * , int const    ) ;
extern unsigned long __phys_addr(unsigned long  ) ;
extern void *memcpy(void * , void const   * , size_t  ) ;
__inline static bool IS_ERR_OR_NULL(void const   *ptr ) ;
extern void lockdep_init_map(struct lockdep_map * , char const   * , struct lock_class_key * ,
                             int  ) ;
extern unsigned long _raw_spin_lock_irqsave(raw_spinlock_t * ) ;
extern void _raw_spin_unlock_irqrestore(raw_spinlock_t * , unsigned long  ) ;
__inline static void spin_unlock_irqrestore(spinlock_t *lock , unsigned long flags ) 
{ 


  {
  _raw_spin_unlock_irqrestore(& lock->__annonCompField18.rlock, flags);
  return;
}
}
extern void init_timer_key(struct timer_list * , unsigned int  , char const   * ,
                           struct lock_class_key * ) ;
extern int del_timer(struct timer_list * ) ;
int ldv_del_timer_61(struct timer_list *ldv_func_arg1 ) ;
extern void delayed_work_timer_fn(unsigned long  ) ;
extern void __init_work(struct work_struct * , int  ) ;
extern struct workqueue_struct *__alloc_workqueue_key(char const   * , unsigned int  ,
                                                      int  , struct lock_class_key * ,
                                                      char const   *  , ...) ;
extern void destroy_workqueue(struct workqueue_struct * ) ;
void ldv_destroy_workqueue_60(struct workqueue_struct *ldv_func_arg1 ) ;
bool ldv_queue_work_on_53(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_work_on_55(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_delayed_work_on_54(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
bool ldv_queue_delayed_work_on_57(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
void ldv_flush_workqueue_56(struct workqueue_struct *ldv_func_arg1 ) ;
void ldv_flush_workqueue_59(struct workqueue_struct *ldv_func_arg1 ) ;
extern bool cancel_work_sync(struct work_struct * ) ;
bool ldv_cancel_work_sync_58(struct work_struct *ldv_func_arg1 ) ;
__inline static bool queue_delayed_work(struct workqueue_struct *wq , struct delayed_work *dwork ,
                                        unsigned long delay ) 
{ 
  bool tmp ;

  {
  tmp = ldv_queue_delayed_work_on_54(8192, wq, dwork, delay);
  return (tmp);
}
}
extern void kfree(void const   * ) ;
extern void *ldv_malloc(size_t);
void *__kmalloc(size_t size, gfp_t t)
{
	return ldv_malloc(size);
}
void *ldv_malloc(size_t size ) ;
__inline static void *kmalloc(size_t size , gfp_t flags ) 
{ 
  void *tmp___2 ;

  {
  tmp___2 = __kmalloc(size, flags);
  return (tmp___2);
}
}
void *ldv_zalloc(size_t size ) ;
__inline static void *kzalloc(size_t size , gfp_t flags ) 
{ 
  void *tmp ;

  {
  tmp = kmalloc(size, flags | 32768U);
  return (tmp);
}
}
void call_and_disable_work_1(struct work_struct *work ) ;
void call_and_disable_all_2(int state ) ;
void call_and_disable_all_1(int state ) ;
void activate_work_2(struct work_struct *work , int state ) ;
void activate_work_1(struct work_struct *work , int state ) ;
void choose_timer_4(void) ;
void call_and_disable_work_3(struct work_struct *work ) ;
void disable_suitable_timer_4(struct timer_list *timer ) ;
void disable_work_3(struct work_struct *work ) ;
void disable_work_2(struct work_struct *work ) ;
void disable_work_1(struct work_struct *work ) ;
int reg_timer_4(struct timer_list *timer , void (*function)(unsigned long  ) , unsigned long data ) ;
void invoke_work_3(void) ;
void invoke_work_1(void) ;
void ldv_timer_4(int state , struct timer_list *timer ) ;
void activate_suitable_timer_4(struct timer_list *timer , unsigned long data ) ;
void call_and_disable_work_2(struct work_struct *work ) ;
void invoke_work_2(void) ;
extern int device_wakeup_enable(struct device * ) ;
extern void _dev_info(struct device  const  * , char const   *  , ...) ;
__inline static int valid_dma_direction(int dma_direction ) 
{ 


  {
  return ((dma_direction == 0 || dma_direction == 1) || dma_direction == 2);
}
}
__inline static void kmemcheck_mark_initialized(void *address , unsigned int n ) 
{ 


  {
  return;
}
}
extern void debug_dma_map_page(struct device * , struct page * , size_t  , size_t  ,
                               int  , dma_addr_t  , bool  ) ;
extern void debug_dma_mapping_error(struct device * , dma_addr_t  ) ;
extern struct dma_map_ops *dma_ops ;
__inline static struct dma_map_ops *get_dma_ops(struct device *dev ) 
{ 
  long tmp ;

  {
  tmp = ldv__builtin_expect((unsigned long )dev == (unsigned long )((struct device *)0),
                         0L);
  if (tmp != 0L || (unsigned long )dev->archdata.dma_ops == (unsigned long )((struct dma_map_ops *)0)) {
    return (dma_ops);
  } else {
    return (dev->archdata.dma_ops);
  }
}
}
__inline static dma_addr_t dma_map_single_attrs(struct device *dev , void *ptr , size_t size ,
                                                enum dma_data_direction dir , struct dma_attrs *attrs ) 
{ 
  struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  dma_addr_t addr ;
  int tmp___0 ;
  long tmp___1 ;
  unsigned long tmp___2 ;
    klee_make_symbolic(&tmp___2, sizeof(long), "tmp___2");
  unsigned long tmp___3 ;

  {
  tmp = get_dma_ops(dev);
  ops = tmp;
  kmemcheck_mark_initialized(ptr, (unsigned int )size);
  tmp___0 = valid_dma_direction((int )dir);
  tmp___1 = ldv__builtin_expect(tmp___0 == 0, 0L);
  if (tmp___1 != 0L) {
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/asm-generic/dma-mapping-common.h"),
                         "i" (19), "i" (12UL));
    ldv_26530: ;
    goto ldv_26530;
  } else {

  }
  tmp___2 = __phys_addr((unsigned long )ptr);
  addr = (*(ops->map_page))(dev, (struct page *)-24189255811072L + (tmp___2 >> 12),
                            (unsigned long )ptr & 4095UL, size, dir, attrs);
  tmp___3 = __phys_addr((unsigned long )ptr);
  debug_dma_map_page(dev, (struct page *)-24189255811072L + (tmp___3 >> 12), (unsigned long )ptr & 4095UL,
                     size, (int )dir, addr, 1);
  return (addr);
}
}
__inline static int dma_mapping_error(struct device *dev , dma_addr_t dma_addr ) 
{ 
  struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  int tmp___0 ;

  {
  tmp = get_dma_ops(dev);
  ops = tmp;
  debug_dma_mapping_error(dev, dma_addr);
  if ((unsigned long )ops->mapping_error != (unsigned long )((int (*)(struct device * ,
                                                                      dma_addr_t  ))0)) {
    tmp___0 = (*(ops->mapping_error))(dev, dma_addr);
    return (tmp___0);
  } else {

  }
  return (dma_addr == 0ULL);
}
}
extern int dma_set_mask(struct device * , u64  ) ;
extern void *dma_alloc_attrs(struct device * , size_t  , dma_addr_t * , gfp_t  , struct dma_attrs * ) ;
extern void dma_free_attrs(struct device * , size_t  , void * , dma_addr_t  , struct dma_attrs * ) ;
extern void msleep(unsigned int  ) ;
__inline static int usb_endpoint_maxp(struct usb_endpoint_descriptor  const  *epd ) 
{ 


  {
  return ((int )epd->wMaxPacketSize);
}
}
extern int usb_disabled(void) ;
__inline static int usb_urb_dir_in(struct urb *urb ) 
{ 


  {
  return ((urb->transfer_flags & 512U) != 0U);
}
}
__inline static __u16 usb_maxpacket(struct usb_device *udev , int pipe , int is_out ) 
{ 
  struct usb_host_endpoint *ep ;
  unsigned int epnum ;
    klee_make_symbolic(&epnum, sizeof(int), "epnum");
  int __ret_warn_on ;
    klee_make_symbolic(&__ret_warn_on, sizeof(int), "__ret_warn_on");
  long tmp ;
  int __ret_warn_on___0 ;
    klee_make_symbolic(&__ret_warn_on___0, sizeof(int), "__ret_warn_on___0");
  long tmp___0 ;
  int tmp___1 ;

  {
  epnum = (unsigned int )(pipe >> 15) & 15U;
  if (is_out != 0) {
    __ret_warn_on = (pipe & 128) != 0;
    tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
    if (tmp != 0L) {
      warn_slowpath_null("include/linux/usb.h", 1846);
    } else {

    }
    ldv__builtin_expect(__ret_warn_on != 0, 0L);
    ep = udev->ep_out[epnum];
  } else {
    __ret_warn_on___0 = (pipe & 128) == 0;
    tmp___0 = ldv__builtin_expect(__ret_warn_on___0 != 0, 0L);
    if (tmp___0 != 0L) {
      warn_slowpath_null("include/linux/usb.h", 1849);
    } else {

    }
    ldv__builtin_expect(__ret_warn_on___0 != 0, 0L);
    ep = udev->ep_in[epnum];
  }
  if ((unsigned long )ep == (unsigned long )((struct usb_host_endpoint *)0)) {
    return (0U);
  } else {

  }
  tmp___1 = usb_endpoint_maxp((struct usb_endpoint_descriptor  const  *)(& ep->desc));
  return ((__u16 )tmp___1);
}
}
__inline static struct usb_bus *hcd_to_bus(struct usb_hcd *hcd ) 
{ 


  {
  return (& hcd->self);
}
}
extern int usb_hcd_link_urb_to_ep(struct usb_hcd * , struct urb * ) ;
extern int usb_hcd_check_unlink_urb(struct usb_hcd * , struct urb * , int  ) ;
extern void usb_hcd_unlink_urb_from_ep(struct usb_hcd * , struct urb * ) ;
extern void usb_hcd_giveback_urb(struct usb_hcd * , struct urb * , int  ) ;
extern void usb_hcd_unmap_urb_for_dma(struct usb_hcd * , struct urb * ) ;
extern struct usb_hcd *usb_create_hcd(struct hc_driver  const  * , struct device * ,
                                      char const   * ) ;
extern void usb_put_hcd(struct usb_hcd * ) ;
extern int usb_add_hcd(struct usb_hcd * , unsigned int  , unsigned long  ) ;
extern void usb_remove_hcd(struct usb_hcd * ) ;
extern void usb_hcd_resume_root_hub(struct usb_hcd * ) ;
__inline static int otg_set_host(struct usb_otg *otg , struct usb_bus *host ) 
{ 
  int tmp ;

  {
  if ((unsigned long )otg != (unsigned long )((struct usb_otg *)0) && (unsigned long )otg->set_host != (unsigned long )((int (*)(struct usb_otg * ,
                                                                                                                                 struct usb_bus * ))0)) {
    tmp = (*(otg->set_host))(otg, host);
    return (tmp);
  } else {

  }
  return (-524);
}
}
void s3c_hsotg_core_init_disconnected(struct dwc2_hsotg *hsotg , bool is_usb_reset ) ;
void s3c_hsotg_core_connect(struct dwc2_hsotg *hsotg ) ;
__inline static struct usb_hcd *dwc2_hsotg_to_hcd(struct dwc2_hsotg *hsotg ) 
{ 


  {
  return ((struct usb_hcd *)hsotg->priv);
}
}
__inline static u8 dwc2_hcd_get_ep_num(struct dwc2_hcd_pipe_info *pipe ) 
{ 


  {
  return (pipe->ep_num);
}
}
__inline static u8 dwc2_hcd_get_pipe_type(struct dwc2_hcd_pipe_info *pipe ) 
{ 


  {
  return (pipe->pipe_type);
}
}
__inline static u16 dwc2_hcd_get_mps(struct dwc2_hcd_pipe_info *pipe ) 
{ 


  {
  return (pipe->mps);
}
}
__inline static u8 dwc2_hcd_get_dev_addr(struct dwc2_hcd_pipe_info *pipe ) 
{ 


  {
  return (pipe->dev_addr);
}
}
__inline static u8 dwc2_hcd_is_pipe_in(struct dwc2_hcd_pipe_info *pipe ) 
{ 


  {
  return ((unsigned int )pipe->pipe_dir == 128U);
}
}
__inline static u8 dwc2_hcd_is_pipe_out(struct dwc2_hcd_pipe_info *pipe ) 
{ 
  u8 tmp ;

  {
  tmp = dwc2_hcd_is_pipe_in(pipe);
  return ((unsigned int )tmp == 0U);
}
}
enum dwc2_transaction_type dwc2_hcd_select_transactions(struct dwc2_hsotg *hsotg ) ;
void dwc2_hcd_queue_transactions(struct dwc2_hsotg *hsotg , enum dwc2_transaction_type tr_type ) ;
void dwc2_hcd_init_usecs(struct dwc2_hsotg *hsotg ) ;
void dwc2_hcd_qh_free(struct dwc2_hsotg *hsotg , struct dwc2_qh *qh ) ;
void dwc2_hcd_qh_unlink(struct dwc2_hsotg *hsotg , struct dwc2_qh *qh ) ;
void dwc2_hcd_qh_deactivate(struct dwc2_hsotg *hsotg , struct dwc2_qh *qh , int sched_next_periodic_split ) ;
void dwc2_hcd_qtd_init(struct dwc2_qtd *qtd , struct dwc2_hcd_urb *urb ) ;
int dwc2_hcd_qtd_add(struct dwc2_hsotg *hsotg , struct dwc2_qtd *qtd , struct dwc2_qh **qh ,
                     gfp_t mem_flags ) ;
__inline static void dwc2_hcd_qtd_unlink_and_free(struct dwc2_hsotg *hsotg , struct dwc2_qtd *qtd ,
                                                  struct dwc2_qh *qh ) 
{ 


  {
  list_del(& qtd->qtd_list_entry);
  kfree((void const   *)qtd);
  return;
}
}
void dwc2_hcd_start_xfer_ddma(struct dwc2_hsotg *hsotg , struct dwc2_qh *qh ) ;
__inline static bool dbg_qh(struct dwc2_qh *qh ) 
{ 


  {
  return (1);
}
}
__inline static bool dbg_urb(struct urb *urb ) 
{ 


  {
  return (1);
}
}
__inline static u32 dwc2_hcd_urb_get_actual_length(struct dwc2_hcd_urb *dwc2_urb ) 
{ 


  {
  return (dwc2_urb->actual_length);
}
}
__inline static u32 dwc2_hcd_urb_get_error_count(struct dwc2_hcd_urb *dwc2_urb ) 
{ 


  {
  return (dwc2_urb->error_count);
}
}
__inline static void dwc2_hcd_urb_set_iso_desc_params(struct dwc2_hcd_urb *dwc2_urb ,
                                                      int desc_num , u32 offset ,
                                                      u32 length ) 
{ 


  {
  dwc2_urb->iso_descs[desc_num].offset = offset;
  dwc2_urb->iso_descs[desc_num].length = length;
  return;
}
}
__inline static u32 dwc2_hcd_urb_get_iso_desc_status(struct dwc2_hcd_urb *dwc2_urb ,
                                                     int desc_num ) 
{ 


  {
  return (dwc2_urb->iso_descs[desc_num].status);
}
}
__inline static u32 dwc2_hcd_urb_get_iso_desc_actual_length(struct dwc2_hcd_urb *dwc2_urb ,
                                                            int desc_num ) 
{ 


  {
  return (dwc2_urb->iso_descs[desc_num].actual_length);
}
}
__inline static int dwc2_hcd_is_bandwidth_allocated(struct dwc2_hsotg *hsotg , struct usb_host_endpoint *ep ) 
{ 
  struct dwc2_qh *qh ;
  int tmp ;

  {
  qh = (struct dwc2_qh *)ep->hcpriv;
  if ((unsigned long )qh != (unsigned long )((struct dwc2_qh *)0)) {
    tmp = list_empty((struct list_head  const  *)(& qh->qh_list_entry));
    if (tmp == 0) {
      return (1);
    } else {

    }
  } else {

  }
  return (0);
}
}
__inline static u16 dwc2_hcd_get_ep_bandwidth(struct dwc2_hsotg *hsotg , struct usb_host_endpoint *ep ) 
{ 
  struct dwc2_qh *qh ;
  int __ret_warn_on ;
  long tmp ;

  {
  qh = (struct dwc2_qh *)ep->hcpriv;
  if ((unsigned long )qh == (unsigned long )((struct dwc2_qh *)0)) {
    __ret_warn_on = 1;
    tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
    if (tmp != 0L) {
      warn_slowpath_null("/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/usb/dwc2/hcd.h",
                         636);
    } else {

    }
    ldv__builtin_expect(__ret_warn_on != 0, 0L);
    return (0U);
  } else {

  }
  return (qh->usecs);
}
}
irqreturn_t dwc2_handle_hcd_intr(struct dwc2_hsotg *hsotg ) ;
void dwc2_hcd_stop(struct dwc2_hsotg *hsotg ) ;
int dwc2_hcd_is_b_host(struct dwc2_hsotg *hsotg ) ;
void dwc2_hcd_dump_state(struct dwc2_hsotg *hsotg ) ;
void dwc2_hcd_dump_frrem(struct dwc2_hsotg *hsotg ) ;
void dwc2_host_start(struct dwc2_hsotg *hsotg ) ;
void dwc2_host_disconnect(struct dwc2_hsotg *hsotg ) ;
void dwc2_host_hub_info(struct dwc2_hsotg *hsotg , void *context , int *hub_addr ,
                        int *hub_port ) ;
int dwc2_host_get_speed(struct dwc2_hsotg *hsotg , void *context ) ;
void dwc2_host_complete(struct dwc2_hsotg *hsotg , struct dwc2_qtd *qtd , int status ) ;
static void dwc2_dump_channel_info(struct dwc2_hsotg *hsotg , struct dwc2_host_chan *chan ) 
{ 
  int num_channels ;
  struct dwc2_qh *qh ;
  u32 hcchar ;
  u32 hcsplt ;
  u32 hctsiz ;
  u32 hc_dma ;
  int i ;
  struct _ddebug descriptor ;
  long tmp ;
  struct _ddebug descriptor___0 ;
  long tmp___0 ;
  struct _ddebug descriptor___1 ;
  long tmp___1 ;
  struct _ddebug descriptor___2 ;
  long tmp___2 ;
  struct _ddebug descriptor___3 ;
  long tmp___3 ;
  struct _ddebug descriptor___4 ;
  long tmp___4 ;
  struct _ddebug descriptor___5 ;
  long tmp___5 ;
  struct _ddebug descriptor___6 ;
  long tmp___6 ;
  struct _ddebug descriptor___7 ;
  long tmp___7 ;
  struct _ddebug descriptor___8 ;
  long tmp___8 ;
  struct _ddebug descriptor___9 ;
  long tmp___9 ;
  struct _ddebug descriptor___10 ;
  long tmp___10 ;
  struct _ddebug descriptor___11 ;
  long tmp___11 ;
  struct _ddebug descriptor___12 ;
  long tmp___12 ;
  struct list_head  const  *__mptr ;
  struct _ddebug descriptor___13 ;
  long tmp___13 ;
  struct list_head  const  *__mptr___0 ;
  struct _ddebug descriptor___14 ;
  long tmp___14 ;
  struct list_head  const  *__mptr___1 ;
  struct _ddebug descriptor___15 ;
  long tmp___15 ;
  struct list_head  const  *__mptr___2 ;
  struct _ddebug descriptor___16 ;
  long tmp___16 ;
  struct dwc2_host_chan *chan___0 ;
  struct _ddebug descriptor___17 ;
  long tmp___17 ;

  {
  num_channels = (hsotg->core_params)->host_channels;
  if ((unsigned long )chan == (unsigned long )((struct dwc2_host_chan *)0)) {
    return;
  } else {

  }
  hcchar = readl((void const volatile   *)hsotg->regs + (unsigned long )(((int )chan->hc_num + 40) * 32));
  hcsplt = readl((void const volatile   *)hsotg->regs + (unsigned long )((int )chan->hc_num * 32 + 1284));
  hctsiz = readl((void const volatile   *)hsotg->regs + (unsigned long )((int )chan->hc_num * 32 + 1296));
  hc_dma = readl((void const volatile   *)hsotg->regs + (unsigned long )((int )chan->hc_num * 32 + 1300));
  descriptor.modname = "dwc2";
  descriptor.function = "dwc2_dump_channel_info";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
  descriptor.format = "  Assigned to channel %p:\n";
  descriptor.lineno = 88U;
  descriptor.flags = 1U;
  tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp != 0L) {
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "  Assigned to channel %p:\n",
                      chan);
  } else {

  }
  descriptor___0.modname = "dwc2";
  descriptor___0.function = "dwc2_dump_channel_info";
  descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
  descriptor___0.format = "    hcchar 0x%08x, hcsplt 0x%08x\n";
  descriptor___0.lineno = 90U;
  descriptor___0.flags = 1U;
  tmp___0 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
  if (tmp___0 != 0L) {
    __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)hsotg->dev, "    hcchar 0x%08x, hcsplt 0x%08x\n",
                      hcchar, hcsplt);
  } else {

  }
  descriptor___1.modname = "dwc2";
  descriptor___1.function = "dwc2_dump_channel_info";
  descriptor___1.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
  descriptor___1.format = "    hctsiz 0x%08x, hc_dma 0x%08x\n";
  descriptor___1.lineno = 92U;
  descriptor___1.flags = 1U;
  tmp___1 = ldv__builtin_expect((long )descriptor___1.flags & 1L, 0L);
  if (tmp___1 != 0L) {
    __dynamic_dev_dbg(& descriptor___1, (struct device  const  *)hsotg->dev, "    hctsiz 0x%08x, hc_dma 0x%08x\n",
                      hctsiz, hc_dma);
  } else {

  }
  descriptor___2.modname = "dwc2";
  descriptor___2.function = "dwc2_dump_channel_info";
  descriptor___2.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
  descriptor___2.format = "    dev_addr: %d, ep_num: %d, ep_is_in: %d\n";
  descriptor___2.lineno = 94U;
  descriptor___2.flags = 1U;
  tmp___2 = ldv__builtin_expect((long )descriptor___2.flags & 1L, 0L);
  if (tmp___2 != 0L) {
    __dynamic_dev_dbg(& descriptor___2, (struct device  const  *)hsotg->dev, "    dev_addr: %d, ep_num: %d, ep_is_in: %d\n",
                      (int )chan->dev_addr, (int )chan->ep_num, (int )chan->ep_is_in);
  } else {

  }
  descriptor___3.modname = "dwc2";
  descriptor___3.function = "dwc2_dump_channel_info";
  descriptor___3.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
  descriptor___3.format = "    ep_type: %d\n";
  descriptor___3.lineno = 95U;
  descriptor___3.flags = 1U;
  tmp___3 = ldv__builtin_expect((long )descriptor___3.flags & 1L, 0L);
  if (tmp___3 != 0L) {
    __dynamic_dev_dbg(& descriptor___3, (struct device  const  *)hsotg->dev, "    ep_type: %d\n",
                      (int )chan->ep_type);
  } else {

  }
  descriptor___4.modname = "dwc2";
  descriptor___4.function = "dwc2_dump_channel_info";
  descriptor___4.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
  descriptor___4.format = "    max_packet: %d\n";
  descriptor___4.lineno = 96U;
  descriptor___4.flags = 1U;
  tmp___4 = ldv__builtin_expect((long )descriptor___4.flags & 1L, 0L);
  if (tmp___4 != 0L) {
    __dynamic_dev_dbg(& descriptor___4, (struct device  const  *)hsotg->dev, "    max_packet: %d\n",
                      (int )chan->max_packet);
  } else {

  }
  descriptor___5.modname = "dwc2";
  descriptor___5.function = "dwc2_dump_channel_info";
  descriptor___5.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
  descriptor___5.format = "    data_pid_start: %d\n";
  descriptor___5.lineno = 97U;
  descriptor___5.flags = 1U;
  tmp___5 = ldv__builtin_expect((long )descriptor___5.flags & 1L, 0L);
  if (tmp___5 != 0L) {
    __dynamic_dev_dbg(& descriptor___5, (struct device  const  *)hsotg->dev, "    data_pid_start: %d\n",
                      (int )chan->data_pid_start);
  } else {

  }
  descriptor___6.modname = "dwc2";
  descriptor___6.function = "dwc2_dump_channel_info";
  descriptor___6.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
  descriptor___6.format = "    xfer_started: %d\n";
  descriptor___6.lineno = 98U;
  descriptor___6.flags = 1U;
  tmp___6 = ldv__builtin_expect((long )descriptor___6.flags & 1L, 0L);
  if (tmp___6 != 0L) {
    __dynamic_dev_dbg(& descriptor___6, (struct device  const  *)hsotg->dev, "    xfer_started: %d\n",
                      (int )chan->xfer_started);
  } else {

  }
  descriptor___7.modname = "dwc2";
  descriptor___7.function = "dwc2_dump_channel_info";
  descriptor___7.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
  descriptor___7.format = "    halt_status: %d\n";
  descriptor___7.lineno = 99U;
  descriptor___7.flags = 1U;
  tmp___7 = ldv__builtin_expect((long )descriptor___7.flags & 1L, 0L);
  if (tmp___7 != 0L) {
    __dynamic_dev_dbg(& descriptor___7, (struct device  const  *)hsotg->dev, "    halt_status: %d\n",
                      (unsigned int )chan->halt_status);
  } else {

  }
  descriptor___8.modname = "dwc2";
  descriptor___8.function = "dwc2_dump_channel_info";
  descriptor___8.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
  descriptor___8.format = "    xfer_buf: %p\n";
  descriptor___8.lineno = 100U;
  descriptor___8.flags = 1U;
  tmp___8 = ldv__builtin_expect((long )descriptor___8.flags & 1L, 0L);
  if (tmp___8 != 0L) {
    __dynamic_dev_dbg(& descriptor___8, (struct device  const  *)hsotg->dev, "    xfer_buf: %p\n",
                      chan->xfer_buf);
  } else {

  }
  descriptor___9.modname = "dwc2";
  descriptor___9.function = "dwc2_dump_channel_info";
  descriptor___9.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
  descriptor___9.format = "    xfer_dma: %08lx\n";
  descriptor___9.lineno = 102U;
  descriptor___9.flags = 1U;
  tmp___9 = ldv__builtin_expect((long )descriptor___9.flags & 1L, 0L);
  if (tmp___9 != 0L) {
    __dynamic_dev_dbg(& descriptor___9, (struct device  const  *)hsotg->dev, "    xfer_dma: %08lx\n",
                      (unsigned long )chan->xfer_dma);
  } else {

  }
  descriptor___10.modname = "dwc2";
  descriptor___10.function = "dwc2_dump_channel_info";
  descriptor___10.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
  descriptor___10.format = "    xfer_len: %d\n";
  descriptor___10.lineno = 103U;
  descriptor___10.flags = 1U;
  tmp___10 = ldv__builtin_expect((long )descriptor___10.flags & 1L, 0L);
  if (tmp___10 != 0L) {
    __dynamic_dev_dbg(& descriptor___10, (struct device  const  *)hsotg->dev, "    xfer_len: %d\n",
                      chan->xfer_len);
  } else {

  }
  descriptor___11.modname = "dwc2";
  descriptor___11.function = "dwc2_dump_channel_info";
  descriptor___11.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
  descriptor___11.format = "    qh: %p\n";
  descriptor___11.lineno = 104U;
  descriptor___11.flags = 1U;
  tmp___11 = ldv__builtin_expect((long )descriptor___11.flags & 1L, 0L);
  if (tmp___11 != 0L) {
    __dynamic_dev_dbg(& descriptor___11, (struct device  const  *)hsotg->dev, "    qh: %p\n",
                      chan->qh);
  } else {

  }
  descriptor___12.modname = "dwc2";
  descriptor___12.function = "dwc2_dump_channel_info";
  descriptor___12.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
  descriptor___12.format = "  NP inactive sched:\n";
  descriptor___12.lineno = 105U;
  descriptor___12.flags = 1U;
  tmp___12 = ldv__builtin_expect((long )descriptor___12.flags & 1L, 0L);
  if (tmp___12 != 0L) {
    __dynamic_dev_dbg(& descriptor___12, (struct device  const  *)hsotg->dev, "  NP inactive sched:\n");
  } else {

  }
  __mptr = (struct list_head  const  *)hsotg->non_periodic_sched_inactive.next;
  qh = (struct dwc2_qh *)__mptr + 0xffffffffffffffa8UL;
  goto ldv_34626;
  ldv_34625: 
  descriptor___13.modname = "dwc2";
  descriptor___13.function = "dwc2_dump_channel_info";
  descriptor___13.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
  descriptor___13.format = "    %p\n";
  descriptor___13.lineno = 108U;
  descriptor___13.flags = 1U;
  tmp___13 = ldv__builtin_expect((long )descriptor___13.flags & 1L, 0L);
  if (tmp___13 != 0L) {
    __dynamic_dev_dbg(& descriptor___13, (struct device  const  *)hsotg->dev, "    %p\n",
                      qh);
  } else {

  }
  __mptr___0 = (struct list_head  const  *)qh->qh_list_entry.next;
  qh = (struct dwc2_qh *)__mptr___0 + 0xffffffffffffffa8UL;
  ldv_34626: ;
  if ((unsigned long )(& qh->qh_list_entry) != (unsigned long )(& hsotg->non_periodic_sched_inactive)) {
    goto ldv_34625;
  } else {

  }
  descriptor___14.modname = "dwc2";
  descriptor___14.function = "dwc2_dump_channel_info";
  descriptor___14.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
  descriptor___14.format = "  NP active sched:\n";
  descriptor___14.lineno = 109U;
  descriptor___14.flags = 1U;
  tmp___14 = ldv__builtin_expect((long )descriptor___14.flags & 1L, 0L);
  if (tmp___14 != 0L) {
    __dynamic_dev_dbg(& descriptor___14, (struct device  const  *)hsotg->dev, "  NP active sched:\n");
  } else {

  }
  __mptr___1 = (struct list_head  const  *)hsotg->non_periodic_sched_active.next;
  qh = (struct dwc2_qh *)__mptr___1 + 0xffffffffffffffa8UL;
  goto ldv_34635;
  ldv_34634: 
  descriptor___15.modname = "dwc2";
  descriptor___15.function = "dwc2_dump_channel_info";
  descriptor___15.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
  descriptor___15.format = "    %p\n";
  descriptor___15.lineno = 112U;
  descriptor___15.flags = 1U;
  tmp___15 = ldv__builtin_expect((long )descriptor___15.flags & 1L, 0L);
  if (tmp___15 != 0L) {
    __dynamic_dev_dbg(& descriptor___15, (struct device  const  *)hsotg->dev, "    %p\n",
                      qh);
  } else {

  }
  __mptr___2 = (struct list_head  const  *)qh->qh_list_entry.next;
  qh = (struct dwc2_qh *)__mptr___2 + 0xffffffffffffffa8UL;
  ldv_34635: ;
  if ((unsigned long )(& qh->qh_list_entry) != (unsigned long )(& hsotg->non_periodic_sched_active)) {
    goto ldv_34634;
  } else {

  }
  descriptor___16.modname = "dwc2";
  descriptor___16.function = "dwc2_dump_channel_info";
  descriptor___16.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
  descriptor___16.format = "  Channels:\n";
  descriptor___16.lineno = 113U;
  descriptor___16.flags = 1U;
  tmp___16 = ldv__builtin_expect((long )descriptor___16.flags & 1L, 0L);
  if (tmp___16 != 0L) {
    __dynamic_dev_dbg(& descriptor___16, (struct device  const  *)hsotg->dev, "  Channels:\n");
  } else {

  }
  i = 0;
  goto ldv_34641;
  ldv_34640: 
  chan___0 = hsotg->hc_ptr_array[i];
  descriptor___17.modname = "dwc2";
  descriptor___17.function = "dwc2_dump_channel_info";
  descriptor___17.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
  descriptor___17.format = "    %2d: %p\n";
  descriptor___17.lineno = 117U;
  descriptor___17.flags = 1U;
  tmp___17 = ldv__builtin_expect((long )descriptor___17.flags & 1L, 0L);
  if (tmp___17 != 0L) {
    __dynamic_dev_dbg(& descriptor___17, (struct device  const  *)hsotg->dev, "    %2d: %p\n",
                      i, chan___0);
  } else {

  }
  i = i + 1;
  ldv_34641: ;
  if (i < num_channels) {
    goto ldv_34640;
  } else {

  }

  return;
}
}
static void dwc2_kill_urbs_in_qh_list(struct dwc2_hsotg *hsotg , struct list_head *qh_list ) 
{ 
  struct dwc2_qh *qh ;
  struct dwc2_qh *qh_tmp ;
  struct dwc2_qtd *qtd ;
  struct dwc2_qtd *qtd_tmp ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;
  struct list_head  const  *__mptr___2 ;
  struct list_head  const  *__mptr___3 ;
  struct list_head  const  *__mptr___4 ;

  {
  __mptr = (struct list_head  const  *)qh_list->next;
  qh = (struct dwc2_qh *)__mptr + 0xffffffffffffffa8UL;
  __mptr___0 = (struct list_head  const  *)qh->qh_list_entry.next;
  qh_tmp = (struct dwc2_qh *)__mptr___0 + 0xffffffffffffffa8UL;
  goto ldv_34667;
  ldv_34666: 
  __mptr___1 = (struct list_head  const  *)qh->qtd_list.next;
  qtd = (struct dwc2_qtd *)__mptr___1 + 0xffffffffffffffd8UL;
  __mptr___2 = (struct list_head  const  *)qtd->qtd_list_entry.next;
  qtd_tmp = (struct dwc2_qtd *)__mptr___2 + 0xffffffffffffffd8UL;
  goto ldv_34664;
  ldv_34663: 
  dwc2_host_complete(hsotg, qtd, -110);
  dwc2_hcd_qtd_unlink_and_free(hsotg, qtd, qh);
  qtd = qtd_tmp;
  __mptr___3 = (struct list_head  const  *)qtd_tmp->qtd_list_entry.next;
  qtd_tmp = (struct dwc2_qtd *)__mptr___3 + 0xffffffffffffffd8UL;
  ldv_34664: ;
  if ((unsigned long )(& qtd->qtd_list_entry) != (unsigned long )(& qh->qtd_list)) {
    goto ldv_34663;
  } else {

  }
  qh = qh_tmp;
  __mptr___4 = (struct list_head  const  *)qh_tmp->qh_list_entry.next;
  qh_tmp = (struct dwc2_qh *)__mptr___4 + 0xffffffffffffffa8UL;
  ldv_34667: ;
  if ((unsigned long )(& qh->qh_list_entry) != (unsigned long )qh_list) {
    goto ldv_34666;
  } else {

  }

  return;
}
}
static void dwc2_qh_list_free(struct dwc2_hsotg *hsotg , struct list_head *qh_list ) 
{ 
  struct dwc2_qtd *qtd ;
  struct dwc2_qtd *qtd_tmp ;
  struct dwc2_qh *qh ;
  struct dwc2_qh *qh_tmp ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;
  struct list_head  const  *__mptr___2 ;
  struct list_head  const  *__mptr___3 ;
  raw_spinlock_t *tmp___0 ;
  struct list_head  const  *__mptr___4 ;

  {
  if ((unsigned long )qh_list->next == (unsigned long )((struct list_head *)0)) {
    return;
  } else {

  }
  tmp = spinlock_check(& hsotg->lock);
  flags = _raw_spin_lock_irqsave(tmp);
  dwc2_kill_urbs_in_qh_list(hsotg, qh_list);
  __mptr = (struct list_head  const  *)qh_list->next;
  qh = (struct dwc2_qh *)__mptr + 0xffffffffffffffa8UL;
  __mptr___0 = (struct list_head  const  *)qh->qh_list_entry.next;
  qh_tmp = (struct dwc2_qh *)__mptr___0 + 0xffffffffffffffa8UL;
  goto ldv_34700;
  ldv_34699: 
  dwc2_hcd_qh_unlink(hsotg, qh);
  __mptr___1 = (struct list_head  const  *)qh->qtd_list.next;
  qtd = (struct dwc2_qtd *)__mptr___1 + 0xffffffffffffffd8UL;
  __mptr___2 = (struct list_head  const  *)qtd->qtd_list_entry.next;
  qtd_tmp = (struct dwc2_qtd *)__mptr___2 + 0xffffffffffffffd8UL;
  goto ldv_34694;
  ldv_34693: 
  dwc2_hcd_qtd_unlink_and_free(hsotg, qtd, qh);
  qtd = qtd_tmp;
  __mptr___3 = (struct list_head  const  *)qtd_tmp->qtd_list_entry.next;
  qtd_tmp = (struct dwc2_qtd *)__mptr___3 + 0xffffffffffffffd8UL;
  ldv_34694: ;
  if ((unsigned long )(& qtd->qtd_list_entry) != (unsigned long )(& qh->qtd_list)) {
    goto ldv_34693;
  } else {

  }
  spin_unlock_irqrestore(& hsotg->lock, flags);
  dwc2_hcd_qh_free(hsotg, qh);
  tmp___0 = spinlock_check(& hsotg->lock);
  flags = _raw_spin_lock_irqsave(tmp___0);
  qh = qh_tmp;
  __mptr___4 = (struct list_head  const  *)qh_tmp->qh_list_entry.next;
  qh_tmp = (struct dwc2_qh *)__mptr___4 + 0xffffffffffffffa8UL;
  ldv_34700: ;
  if ((unsigned long )(& qh->qh_list_entry) != (unsigned long )qh_list) {
    goto ldv_34699;
  } else {

  }
  spin_unlock_irqrestore(& hsotg->lock, flags);
  return;
}
}
static void dwc2_kill_all_urbs(struct dwc2_hsotg *hsotg ) 
{ 


  {
  dwc2_kill_urbs_in_qh_list(hsotg, & hsotg->non_periodic_sched_inactive);
  dwc2_kill_urbs_in_qh_list(hsotg, & hsotg->non_periodic_sched_active);
  dwc2_kill_urbs_in_qh_list(hsotg, & hsotg->periodic_sched_inactive);
  dwc2_kill_urbs_in_qh_list(hsotg, & hsotg->periodic_sched_ready);
  dwc2_kill_urbs_in_qh_list(hsotg, & hsotg->periodic_sched_assigned);
  dwc2_kill_urbs_in_qh_list(hsotg, & hsotg->periodic_sched_queued);
  return;
}
}
void dwc2_hcd_start(struct dwc2_hsotg *hsotg ) 
{ 
  u32 hprt0 ;
  unsigned long tmp ;

  {
  if ((unsigned int )hsotg->op_state == 5U) {
    hprt0 = dwc2_read_hprt0(hsotg);
    hprt0 = hprt0 | 256U;
    writel(hprt0, (void volatile   *)hsotg->regs + 1088U);
  } else {

  }
  tmp = msecs_to_jiffies(50U);
  queue_delayed_work(hsotg->wq_otg, & hsotg->start_work, tmp);
  return;
}
}
static void dwc2_hcd_cleanup_channels(struct dwc2_hsotg *hsotg ) 
{ 
  int num_channels ;
  struct dwc2_host_chan *channel ;
  u32 hcchar ;
  int i ;
  int tmp ;
  int tmp___0 ;

  {
  num_channels = (hsotg->core_params)->host_channels;
  if ((hsotg->core_params)->dma_enable <= 0) {
    i = 0;
    goto ldv_34718;
    ldv_34717: 
    channel = hsotg->hc_ptr_array[i];
    tmp = list_empty((struct list_head  const  *)(& channel->hc_list_entry));
    if (tmp == 0) {
      goto ldv_34716;
    } else {

    }
    hcchar = readl((void const volatile   *)hsotg->regs + (unsigned long )((i + 40) * 32));
    if ((int )hcchar < 0) {
      hcchar = hcchar & 2147450879U;
      hcchar = hcchar | 1073741824U;
      writel(hcchar, (void volatile   *)hsotg->regs + (unsigned long )((i + 40) * 32));
    } else {

    }
    ldv_34716: 
    i = i + 1;
    ldv_34718: ;
    if (i < num_channels) {
      goto ldv_34717;
    } else {

    }

  } else {

  }
  i = 0;
  goto ldv_34722;
  ldv_34721: 
  channel = hsotg->hc_ptr_array[i];
  tmp___0 = list_empty((struct list_head  const  *)(& channel->hc_list_entry));
  if (tmp___0 == 0) {
    goto ldv_34720;
  } else {

  }
  hcchar = readl((void const volatile   *)hsotg->regs + (unsigned long )((i + 40) * 32));
  if ((int )hcchar < 0) {
    hcchar = hcchar | 1073741824U;
    writel(hcchar, (void volatile   *)hsotg->regs + (unsigned long )((i + 40) * 32));
  } else {

  }
  dwc2_hc_cleanup(hsotg, channel);
  list_add_tail(& channel->hc_list_entry, & hsotg->free_hc_list);
  channel->qh = (struct dwc2_qh *)0;
  ldv_34720: 
  i = i + 1;
  ldv_34722: ;
  if (i < num_channels) {
    goto ldv_34721;
  } else {

  }

  if ((hsotg->core_params)->uframe_sched > 0) {
    hsotg->available_host_channels = (hsotg->core_params)->host_channels;
  } else {
    hsotg->non_periodic_channels = 0;
    hsotg->periodic_channels = 0;
  }
  return;
}
}
void dwc2_hcd_disconnect(struct dwc2_hsotg *hsotg ) 
{ 
  u32 intr ;
  struct _ddebug descriptor ;
  long tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  hsotg->flags.b.port_connect_status_change = 1U;
  hsotg->flags.b.port_connect_status = 0U;
  intr = readl((void const volatile   *)hsotg->regs + 24U);
  intr = intr & 4194303967U;
  writel(intr, (void volatile   *)hsotg->regs + 24U);
  intr = 100663328U;
  writel(intr, (void volatile   *)hsotg->regs + 20U);
  tmp___0 = dwc2_is_device_mode(hsotg);
  if (tmp___0 != 0) {
    if ((unsigned int )hsotg->op_state != 10U) {
      descriptor.modname = "dwc2";
      descriptor.function = "dwc2_hcd_disconnect";
      descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
      descriptor.format = "Disconnect: PortPower off\n";
      descriptor.lineno = 303U;
      descriptor.flags = 1U;
      tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
      if (tmp != 0L) {
        __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "Disconnect: PortPower off\n");
      } else {

      }
      writel(0U, (void volatile   *)hsotg->regs + 1088U);
    } else {

    }
    dwc2_disable_host_interrupts(hsotg);
  } else {

  }
  dwc2_kill_all_urbs(hsotg);
  tmp___1 = dwc2_is_host_mode(hsotg);
  if (tmp___1 != 0) {
    dwc2_hcd_cleanup_channels(hsotg);
  } else {

  }
  dwc2_host_disconnect(hsotg);
  return;
}
}
static void dwc2_hcd_rem_wakeup(struct dwc2_hsotg *hsotg ) 
{ 


  {
  if ((unsigned int )hsotg->lx_state == 2U) {
    hsotg->flags.b.port_suspend_change = 1U;
    usb_hcd_resume_root_hub((struct usb_hcd *)hsotg->priv);
  } else {
    hsotg->flags.b.port_l1_change = 1U;
  }
  return;
}
}
void dwc2_hcd_stop(struct dwc2_hsotg *hsotg ) 
{ 
  struct _ddebug descriptor ;
  long tmp ;
  struct _ddebug descriptor___0 ;
  long tmp___0 ;

  {
  descriptor.modname = "dwc2";
  descriptor.function = "dwc2_hcd_stop";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
  descriptor.format = "DWC OTG HCD STOP\n";
  descriptor.lineno = 344U;
  descriptor.flags = 1U;
  tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp != 0L) {
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "DWC OTG HCD STOP\n");
  } else {

  }
  dwc2_disable_host_interrupts(hsotg);
  descriptor___0.modname = "dwc2";
  descriptor___0.function = "dwc2_hcd_stop";
  descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
  descriptor___0.format = "PortPower off\n";
  descriptor___0.lineno = 356U;
  descriptor___0.flags = 1U;
  tmp___0 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
  if (tmp___0 != 0L) {
    __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)hsotg->dev, "PortPower off\n");
  } else {

  }
  writel(0U, (void volatile   *)hsotg->regs + 1088U);
  return;
}
}
static int dwc2_hcd_urb_enqueue(struct dwc2_hsotg *hsotg , struct dwc2_hcd_urb *urb ,
                                void **ep_handle , gfp_t mem_flags ) 
{ 
  struct dwc2_qtd *qtd ;
  u32 intr_mask ;
  int retval ;
  int dev_speed ;
    klee_make_symbolic(&dev_speed, sizeof(int), "dev_speed");
  u32 hprt0 ;
  unsigned int tmp ;
  u32 prtspd ;
  void *tmp___0 ;
  enum dwc2_transaction_type tr_type ;

  {
  if ((unsigned int )*((unsigned char *)hsotg + 664UL) == 0U) {
    dev_err((struct device  const  *)hsotg->dev, "Not connected\n");
    return (-19);
  } else {

  }
  dev_speed = dwc2_host_get_speed(hsotg, urb->priv);
  if ((dev_speed == 1 && (unsigned int )*((unsigned char *)hsotg + 34UL) == 4U) && (unsigned int )*((unsigned char *)hsotg + 34UL) == 1U) {
    tmp = readl((void const volatile   *)hsotg->regs + 1088U);
    hprt0 = tmp;
    prtspd = (hprt0 & 393216U) >> 17;
    if (prtspd == 1U) {
      return (-19);
    } else {

    }
  } else {

  }
  tmp___0 = kzalloc(56UL, mem_flags);
  qtd = (struct dwc2_qtd *)tmp___0;
  if ((unsigned long )qtd == (unsigned long )((struct dwc2_qtd *)0)) {
    return (-12);
  } else {

  }
  dwc2_hcd_qtd_init(qtd, urb);
  retval = dwc2_hcd_qtd_add(hsotg, qtd, (struct dwc2_qh **)ep_handle, mem_flags);
  if (retval != 0) {
    dev_err((struct device  const  *)hsotg->dev, "DWC OTG HCD URB Enqueue failed adding QTD. Error status %d\n",
            retval);
    kfree((void const   *)qtd);
    return (retval);
  } else {

  }
  intr_mask = readl((void const volatile   *)hsotg->regs + 24U);
  if ((intr_mask & 8U) == 0U) {
    if ((unsigned int )(qtd->qh)->ep_type == 2U && ((qtd->urb)->flags & 1U) == 0U) {
      return (0);
    } else {

    }
    tr_type = dwc2_hcd_select_transactions(hsotg);
    if ((unsigned int )tr_type != 0U) {
      dwc2_hcd_queue_transactions(hsotg, tr_type);
    } else {

    }
  } else {

  }
  return (0);
}
}
static int dwc2_hcd_urb_dequeue(struct dwc2_hsotg *hsotg , struct dwc2_hcd_urb *urb ) 
{ 
  struct dwc2_qh *qh ;
  struct dwc2_qtd *urb_qtd ;
  struct _ddebug descriptor ;
  long tmp ;
  struct _ddebug descriptor___0 ;
  long tmp___0 ;
  u8 in_process ;
  int tmp___1 ;

  {
  urb_qtd = urb->qtd;
  if ((unsigned long )urb_qtd == (unsigned long )((struct dwc2_qtd *)0)) {
    descriptor.modname = "dwc2";
    descriptor.function = "dwc2_hcd_urb_dequeue";
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
    descriptor.format = "## Urb QTD is NULL ##\n";
    descriptor.lineno = 433U;
    descriptor.flags = 1U;
    tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
    if (tmp != 0L) {
      __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "## Urb QTD is NULL ##\n");
    } else {

    }
    return (-22);
  } else {

  }
  qh = urb_qtd->qh;
  if ((unsigned long )qh == (unsigned long )((struct dwc2_qh *)0)) {
    descriptor___0.modname = "dwc2";
    descriptor___0.function = "dwc2_hcd_urb_dequeue";
    descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
    descriptor___0.format = "## Urb QTD QH is NULL ##\n";
    descriptor___0.lineno = 439U;
    descriptor___0.flags = 1U;
    tmp___0 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
    if (tmp___0 != 0L) {
      __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)hsotg->dev, "## Urb QTD QH is NULL ##\n");
    } else {

    }
    return (-22);
  } else {

  }
  urb->priv = (void *)0;
  if ((unsigned int )urb_qtd->in_process != 0U && (unsigned long )qh->channel != (unsigned long )((struct dwc2_host_chan *)0)) {
    dwc2_dump_channel_info(hsotg, qh->channel);
    if ((unsigned int )*((unsigned char *)hsotg + 664UL) != 0U) {
      dwc2_hc_halt(hsotg, qh->channel, 13);
    } else {

    }
  } else {

  }
  if ((hsotg->core_params)->dma_desc_enable <= 0) {
    in_process = urb_qtd->in_process;
    dwc2_hcd_qtd_unlink_and_free(hsotg, urb_qtd, qh);
    if ((unsigned int )in_process != 0U) {
      dwc2_hcd_qh_deactivate(hsotg, qh, 0);
      qh->channel = (struct dwc2_host_chan *)0;
    } else {
      tmp___1 = list_empty((struct list_head  const  *)(& qh->qtd_list));
      if (tmp___1 != 0) {
        dwc2_hcd_qh_unlink(hsotg, qh);
      } else {

      }
    }
  } else {
    dwc2_hcd_qtd_unlink_and_free(hsotg, urb_qtd, qh);
  }
  return (0);
}
}
static int dwc2_hcd_endpoint_disable(struct dwc2_hsotg *hsotg , struct usb_host_endpoint *ep ,
                                     int retry ) 
{ 
  struct dwc2_qtd *qtd ;
  struct dwc2_qtd *qtd_tmp ;
  struct dwc2_qh *qh ;
  unsigned long flags ;
  int rc ;
    klee_make_symbolic(&rc, sizeof(int), "rc");
  raw_spinlock_t *tmp ;
  raw_spinlock_t *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;

  {
  tmp = spinlock_check(& hsotg->lock);
  flags = _raw_spin_lock_irqsave(tmp);
  qh = (struct dwc2_qh *)ep->hcpriv;
  if ((unsigned long )qh == (unsigned long )((struct dwc2_qh *)0)) {
    rc = -22;
    goto err;
  } else {

  }
  goto ldv_34780;
  ldv_34779: ;
  if (retry == 0) {
    dev_err((struct device  const  *)hsotg->dev, "## timeout in dwc2_hcd_endpoint_disable() ##\n");
    rc = -16;
    goto err;
  } else {

  }
  spin_unlock_irqrestore(& hsotg->lock, flags);
  usleep_range(20000UL, 40000UL);
  tmp___0 = spinlock_check(& hsotg->lock);
  flags = _raw_spin_lock_irqsave(tmp___0);
  qh = (struct dwc2_qh *)ep->hcpriv;
  if ((unsigned long )qh == (unsigned long )((struct dwc2_qh *)0)) {
    rc = -22;
    goto err;
  } else {

  }
  ldv_34780: 
  tmp___1 = list_empty((struct list_head  const  *)(& qh->qtd_list));
  if (tmp___1 == 0) {
    tmp___2 = retry;
    retry = retry - 1;
    if (tmp___2 != 0) {
      goto ldv_34779;
    } else {
      goto ldv_34781;
    }
  } else {

  }
  ldv_34781: 
  dwc2_hcd_qh_unlink(hsotg, qh);
  __mptr = (struct list_head  const  *)qh->qtd_list.next;
  qtd = (struct dwc2_qtd *)__mptr + 0xffffffffffffffd8UL;
  __mptr___0 = (struct list_head  const  *)qtd->qtd_list_entry.next;
  qtd_tmp = (struct dwc2_qtd *)__mptr___0 + 0xffffffffffffffd8UL;
  goto ldv_34789;
  ldv_34788: 
  dwc2_hcd_qtd_unlink_and_free(hsotg, qtd, qh);
  qtd = qtd_tmp;
  __mptr___1 = (struct list_head  const  *)qtd_tmp->qtd_list_entry.next;
  qtd_tmp = (struct dwc2_qtd *)__mptr___1 + 0xffffffffffffffd8UL;
  ldv_34789: ;
  if ((unsigned long )(& qtd->qtd_list_entry) != (unsigned long )(& qh->qtd_list)) {
    goto ldv_34788;
  } else {

  }
  ep->hcpriv = (void *)0;
  spin_unlock_irqrestore(& hsotg->lock, flags);
  dwc2_hcd_qh_free(hsotg, qh);
  return (0);
  err: 
  ep->hcpriv = (void *)0;
  spin_unlock_irqrestore(& hsotg->lock, flags);
  return (rc);
}
}
static int dwc2_hcd_endpoint_reset(struct dwc2_hsotg *hsotg , struct usb_host_endpoint *ep ) 
{ 
  struct dwc2_qh *qh ;

  {
  qh = (struct dwc2_qh *)ep->hcpriv;
  if ((unsigned long )qh == (unsigned long )((struct dwc2_qh *)0)) {
    return (-22);
  } else {

  }
  qh->data_toggle = 0U;
  return (0);
}
}
static void dwc2_hcd_reinit(struct dwc2_hsotg *hsotg ) 
{ 
  struct dwc2_host_chan *chan ;
  struct dwc2_host_chan *chan_tmp ;
  int num_channels ;
  int i ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;

  {
  hsotg->flags.d32 = 0U;
  hsotg->non_periodic_qh_ptr = & hsotg->non_periodic_sched_active;
  if ((hsotg->core_params)->uframe_sched > 0) {
    hsotg->available_host_channels = (hsotg->core_params)->host_channels;
  } else {
    hsotg->non_periodic_channels = 0;
    hsotg->periodic_channels = 0;
  }
  __mptr = (struct list_head  const  *)hsotg->free_hc_list.next;
  chan = (struct dwc2_host_chan *)__mptr + 0xffffffffffffffb8UL;
  __mptr___0 = (struct list_head  const  *)chan->hc_list_entry.next;
  chan_tmp = (struct dwc2_host_chan *)__mptr___0 + 0xffffffffffffffb8UL;
  goto ldv_34810;
  ldv_34809: 
  list_del_init(& chan->hc_list_entry);
  chan = chan_tmp;
  __mptr___1 = (struct list_head  const  *)chan_tmp->hc_list_entry.next;
  chan_tmp = (struct dwc2_host_chan *)__mptr___1 + 0xffffffffffffffb8UL;
  ldv_34810: ;
  if ((unsigned long )(& chan->hc_list_entry) != (unsigned long )(& hsotg->free_hc_list)) {
    goto ldv_34809;
  } else {

  }
  num_channels = (hsotg->core_params)->host_channels;
  i = 0;
  goto ldv_34813;
  ldv_34812: 
  chan = hsotg->hc_ptr_array[i];
  list_add_tail(& chan->hc_list_entry, & hsotg->free_hc_list);
  dwc2_hc_cleanup(hsotg, chan);
  i = i + 1;
  ldv_34813: ;
  if (i < num_channels) {
    goto ldv_34812;
  } else {

  }
  dwc2_core_host_init(hsotg);
  return;
}
}
static void dwc2_hc_init_split(struct dwc2_hsotg *hsotg , struct dwc2_host_chan *chan ,
                               struct dwc2_qtd *qtd , struct dwc2_hcd_urb *urb ) 
{ 
  int hub_addr ;
    klee_make_symbolic(&hub_addr, sizeof(int), "hub_addr");
  int hub_port ;
    klee_make_symbolic(&hub_port, sizeof(int), "hub_port");

  {
  chan->do_split = 1U;
  chan->xact_pos = qtd->isoc_split_pos;
  chan->complete_split = qtd->complete_split;
  dwc2_host_hub_info(hsotg, urb->priv, & hub_addr, & hub_port);
  chan->hub_addr = (unsigned char )hub_addr;
  chan->hub_port = (unsigned char )hub_port;
  return;
}
}
static void *dwc2_hc_init_xfer(struct dwc2_hsotg *hsotg , struct dwc2_host_chan *chan ,
                               struct dwc2_qtd *qtd , void *bufptr ) 
{ 
  struct dwc2_hcd_urb *urb ;
  struct dwc2_hcd_iso_packet_desc *frame_desc ;
  u8 tmp ;
  struct _ddebug descriptor ;
  long tmp___0 ;
  struct _ddebug descriptor___0 ;
  long tmp___1 ;
  struct _ddebug descriptor___1 ;
  long tmp___2 ;
  u8 tmp___3 ;

  {
  urb = qtd->urb;
  tmp = dwc2_hcd_get_pipe_type(& urb->pipe_info);
  switch ((int )tmp) {
  case 0: 
  chan->ep_type = 0U;
  switch ((unsigned int )qtd->control_phase) {
  case 0U: 
  descriptor.modname = "dwc2";
  descriptor.function = "dwc2_hc_init_xfer";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
  descriptor.format = "  Control setup transaction\n";
  descriptor.lineno = 618U;
  descriptor.flags = 1U;
  tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp___0 != 0L) {
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "  Control setup transaction\n");
  } else {

  }
  chan->do_ping = 0U;
  chan->ep_is_in = 0U;
  chan->data_pid_start = 3U;
  if ((hsotg->core_params)->dma_enable > 0) {
    chan->xfer_dma = urb->setup_dma;
  } else {
    chan->xfer_buf = (u8 *)urb->setup_packet;
  }
  chan->xfer_len = 8U;
  bufptr = (void *)0;
  goto ldv_34835;
  case 1U: 
  descriptor___0.modname = "dwc2";
  descriptor___0.function = "dwc2_hc_init_xfer";
  descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
  descriptor___0.format = "  Control data transaction\n";
  descriptor___0.lineno = 631U;
  descriptor___0.flags = 1U;
  tmp___1 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
  if (tmp___1 != 0L) {
    __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)hsotg->dev, "  Control data transaction\n");
  } else {

  }
  chan->data_pid_start = qtd->data_toggle;
  goto ldv_34835;
  case 2U: 
  descriptor___1.modname = "dwc2";
  descriptor___1.function = "dwc2_hc_init_xfer";
  descriptor___1.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
  descriptor___1.format = "  Control status transaction\n";
  descriptor___1.lineno = 640U;
  descriptor___1.flags = 1U;
  tmp___2 = ldv__builtin_expect((long )descriptor___1.flags & 1L, 0L);
  if (tmp___2 != 0L) {
    __dynamic_dev_dbg(& descriptor___1, (struct device  const  *)hsotg->dev, "  Control status transaction\n");
  } else {

  }
  if (urb->length == 0U) {
    chan->ep_is_in = 1U;
  } else {
    tmp___3 = dwc2_hcd_is_pipe_out(& urb->pipe_info);
    chan->ep_is_in = tmp___3;
  }
  if ((unsigned int )*((unsigned char *)chan + 2UL) != 0U) {
    chan->do_ping = 0U;
  } else {

  }
  chan->data_pid_start = 2U;
  chan->xfer_len = 0U;
  if ((hsotg->core_params)->dma_enable > 0) {
    chan->xfer_dma = hsotg->status_buf_dma;
  } else {
    chan->xfer_buf = hsotg->status_buf;
  }
  bufptr = (void *)0;
  goto ldv_34835;
  }
  ldv_34835: ;
  goto ldv_34840;
  case 2: 
  chan->ep_type = 2U;
  goto ldv_34840;
  case 3: 
  chan->ep_type = 3U;
  goto ldv_34840;
  case 1: 
  chan->ep_type = 1U;
  if ((hsotg->core_params)->dma_desc_enable > 0) {
    goto ldv_34840;
  } else {

  }
  frame_desc = (struct dwc2_hcd_iso_packet_desc *)(& urb->iso_descs) + (unsigned long )qtd->isoc_frame_index;
  frame_desc->status = 0U;
  if ((hsotg->core_params)->dma_enable > 0) {
    chan->xfer_dma = urb->dma;
    chan->xfer_dma = chan->xfer_dma + (dma_addr_t )(frame_desc->offset + (u32 )qtd->isoc_split_offset);
  } else {
    chan->xfer_buf = (u8 *)urb->buf;
    chan->xfer_buf = chan->xfer_buf + (unsigned long )(frame_desc->offset + (u32 )qtd->isoc_split_offset);
  }
  chan->xfer_len = frame_desc->length - (u32 )qtd->isoc_split_offset;
  if ((hsotg->core_params)->dma_enable > 0 && (chan->xfer_dma & 3ULL) != 0ULL) {
    bufptr = urb->buf + ((unsigned long )frame_desc->offset + (unsigned long )qtd->isoc_split_offset);
  } else {
    bufptr = (void *)0;
  }
  if ((unsigned int )chan->xact_pos == 3U) {
    if (chan->xfer_len <= 188U) {
      chan->xact_pos = 3U;
    } else {
      chan->xact_pos = 2U;
    }
  } else {

  }
  goto ldv_34840;
  }
  ldv_34840: ;
  return (bufptr);
}
}
static int dwc2_hc_setup_align_buf(struct dwc2_hsotg *hsotg , struct dwc2_qh *qh ,
                                   struct dwc2_host_chan *chan , struct dwc2_hcd_urb *urb ,
                                   void *bufptr ) 
{ 
  u32 buf_size ;
  struct urb *usb_urb ;
  struct usb_hcd *hcd ;
  void *tmp ;
  struct _ddebug descriptor ;
  long tmp___0 ;
  int tmp___1 ;

  {
  if ((unsigned long )qh->dw_align_buf == (unsigned long )((u8 *)0U)) {
    if ((unsigned int )*((unsigned char *)chan + 3UL) != 1U) {
      buf_size = (u32 )(hsotg->core_params)->max_transfer_size;
    } else {
      buf_size = 3072U;
    }
    tmp = kmalloc((size_t )buf_size, 33U);
    qh->dw_align_buf = (u8 *)tmp;
    if ((unsigned long )qh->dw_align_buf == (unsigned long )((u8 *)0U)) {
      return (-12);
    } else {

    }
    qh->dw_align_buf_size = (int )buf_size;
  } else {

  }
  if (chan->xfer_len != 0U) {
    descriptor.modname = "dwc2";
    descriptor.function = "dwc2_hc_setup_align_buf";
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
    descriptor.format = "%s(): non-aligned buffer\n";
    descriptor.lineno = 729U;
    descriptor.flags = 1U;
    tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
    if (tmp___0 != 0L) {
      __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "%s(): non-aligned buffer\n",
                        "dwc2_hc_setup_align_buf");
    } else {

    }
    usb_urb = (struct urb *)urb->priv;
    if ((unsigned long )usb_urb != (unsigned long )((struct urb *)0)) {
      if ((usb_urb->transfer_flags & 1507328U) != 0U) {
        hcd = dwc2_hsotg_to_hcd(hsotg);
        usb_hcd_unmap_urb_for_dma(hcd, usb_urb);
      } else {

      }
      if ((unsigned int )*((unsigned char *)chan + 2UL) == 0U) {
        memcpy((void *)qh->dw_align_buf, (void const   *)bufptr, (size_t )chan->xfer_len);
      } else {

      }
    } else {
      dev_warn((struct device  const  *)hsotg->dev, "no URB in dwc2_urb\n");
    }
  } else {

  }
  qh->dw_align_buf_dma = dma_map_single_attrs(hsotg->dev, (void *)qh->dw_align_buf,
                                              (size_t )qh->dw_align_buf_size, (unsigned int )*((unsigned char *)chan + 2UL) != 0U ? 2 : 1,
                                              (struct dma_attrs *)0);
  tmp___1 = dma_mapping_error(hsotg->dev, qh->dw_align_buf_dma);
  if (tmp___1 != 0) {
    dev_err((struct device  const  *)hsotg->dev, "can\'t map align_buf\n");
    chan->align_buf = 0ULL;
    return (-22);
  } else {

  }
  chan->align_buf = qh->dw_align_buf_dma;
  return (0);
}
}
static int dwc2_assign_and_init_hc(struct dwc2_hsotg *hsotg , struct dwc2_qh *qh ) 
{ 
  struct dwc2_host_chan *chan ;
  struct dwc2_hcd_urb *urb ;
  struct dwc2_qtd *qtd ;
  void *bufptr ;
  struct _ddebug descriptor ;
  long tmp ;
  bool tmp___0 ;
  struct _ddebug descriptor___0 ;
  long tmp___1 ;
  int tmp___2 ;
  struct _ddebug descriptor___1 ;
  long tmp___3 ;
  int tmp___4 ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  u8 tmp___5 ;
  u8 tmp___6 ;
  u8 tmp___7 ;
  u8 tmp___8 ;
  struct _ddebug descriptor___2 ;
  long tmp___9 ;
  int tmp___10 ;

  {
  bufptr = (void *)0;
  tmp___0 = dbg_qh(qh);
  if ((int )tmp___0) {
    descriptor.modname = "dwc2";
    descriptor.function = "dwc2_assign_and_init_hc";
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
    descriptor.format = "%s(%p,%p)\n";
    descriptor.lineno = 777U;
    descriptor.flags = 1U;
    tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
    if (tmp != 0L) {
      __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "%s(%p,%p)\n",
                        "dwc2_assign_and_init_hc", hsotg, qh);
    } else {

    }
  } else {

  }
  tmp___2 = list_empty((struct list_head  const  *)(& qh->qtd_list));
  if (tmp___2 != 0) {
    descriptor___0.modname = "dwc2";
    descriptor___0.function = "dwc2_assign_and_init_hc";
    descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
    descriptor___0.format = "No QTDs in QH list\n";
    descriptor___0.lineno = 780U;
    descriptor___0.flags = 1U;
    tmp___1 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
    if (tmp___1 != 0L) {
      __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)hsotg->dev, "No QTDs in QH list\n");
    } else {

    }
    return (-12);
  } else {

  }
  tmp___4 = list_empty((struct list_head  const  *)(& hsotg->free_hc_list));
  if (tmp___4 != 0) {
    descriptor___1.modname = "dwc2";
    descriptor___1.function = "dwc2_assign_and_init_hc";
    descriptor___1.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
    descriptor___1.format = "No free channel to assign\n";
    descriptor___1.lineno = 785U;
    descriptor___1.flags = 1U;
    tmp___3 = ldv__builtin_expect((long )descriptor___1.flags & 1L, 0L);
    if (tmp___3 != 0L) {
      __dynamic_dev_dbg(& descriptor___1, (struct device  const  *)hsotg->dev, "No free channel to assign\n");
    } else {

    }
    return (-12);
  } else {

  }
  __mptr = (struct list_head  const  *)hsotg->free_hc_list.next;
  chan = (struct dwc2_host_chan *)__mptr + 0xffffffffffffffb8UL;
  list_del_init(& chan->hc_list_entry);
  __mptr___0 = (struct list_head  const  *)qh->qtd_list.next;
  qtd = (struct dwc2_qtd *)__mptr___0 + 0xffffffffffffffd8UL;
  urb = qtd->urb;
  qh->channel = chan;
  qtd->in_process = 1U;
  tmp___5 = dwc2_hcd_get_dev_addr(& urb->pipe_info);
  chan->dev_addr = tmp___5;
  tmp___6 = dwc2_hcd_get_ep_num(& urb->pipe_info);
  chan->ep_num = tmp___6;
  chan->speed = qh->dev_speed;
  chan->max_packet = (unsigned int )qh->maxp & 2047U;
  chan->xfer_started = 0U;
  chan->halt_status = 0;
  chan->error_state = (unsigned int )qtd->error_count != 0U;
  chan->halt_on_queue = 0U;
  chan->halt_pending = 0U;
  chan->requests = 0U;
  tmp___7 = dwc2_hcd_is_pipe_in(& urb->pipe_info);
  chan->ep_is_in = (unsigned int )tmp___7 != 0U;
  if ((unsigned int )*((unsigned char *)chan + 2UL) != 0U) {
    chan->do_ping = 0U;
  } else {
    chan->do_ping = qh->ping_state;
  }
  chan->data_pid_start = qh->data_toggle;
  chan->multi_count = 1U;
  if (urb->actual_length > urb->length) {
    tmp___8 = dwc2_hcd_is_pipe_in(& urb->pipe_info);
    if ((unsigned int )tmp___8 == 0U) {
      urb->actual_length = urb->length;
    } else {

    }
  } else {

  }
  if ((hsotg->core_params)->dma_enable > 0) {
    chan->xfer_dma = urb->dma + (dma_addr_t )urb->actual_length;
    if ((hsotg->core_params)->dma_desc_enable <= 0 && (chan->xfer_dma & 3ULL) != 0ULL) {
      bufptr = urb->buf + (unsigned long )urb->actual_length;
    } else {

    }
  } else {
    chan->xfer_buf = (u8 *)urb->buf + (unsigned long )urb->actual_length;
  }
  chan->xfer_len = urb->length - urb->actual_length;
  chan->xfer_count = 0U;
  if ((unsigned int )qh->do_split != 0U) {
    dwc2_hc_init_split(hsotg, chan, qtd, urb);
  } else {
    chan->do_split = 0U;
  }
  bufptr = dwc2_hc_init_xfer(hsotg, chan, qtd, bufptr);
  if ((unsigned long )bufptr != (unsigned long )((void *)0)) {
    descriptor___2.modname = "dwc2";
    descriptor___2.function = "dwc2_assign_and_init_hc";
    descriptor___2.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
    descriptor___2.format = "Non-aligned buffer\n";
    descriptor___2.lineno = 861U;
    descriptor___2.flags = 1U;
    tmp___9 = ldv__builtin_expect((long )descriptor___2.flags & 1L, 0L);
    if (tmp___9 != 0L) {
      __dynamic_dev_dbg(& descriptor___2, (struct device  const  *)hsotg->dev, "Non-aligned buffer\n");
    } else {

    }
    tmp___10 = dwc2_hc_setup_align_buf(hsotg, qh, chan, urb, bufptr);
    if (tmp___10 != 0) {
      dev_err((struct device  const  *)hsotg->dev, "%s: Failed to allocate memory to handle non-dword aligned buffer\n",
              "dwc2_assign_and_init_hc");
      chan->align_buf = 0ULL;
      chan->multi_count = 0U;
      list_add_tail(& chan->hc_list_entry, & hsotg->free_hc_list);
      qtd->in_process = 0U;
      qh->channel = (struct dwc2_host_chan *)0;
      return (-12);
    } else {

    }
  } else {
    chan->align_buf = 0ULL;
  }
  if ((unsigned int )*((unsigned char *)chan + 3UL) == 3U || (unsigned int )*((unsigned char *)chan + 3UL) == 1U) {
    chan->multi_count = (unsigned char )(((unsigned int )((unsigned char )((int )qh->maxp >> 11)) & 3U) + 1U);
  } else {

  }
  if ((hsotg->core_params)->dma_desc_enable > 0) {
    chan->desc_list_addr = qh->desc_list_dma;
  } else {

  }
  dwc2_hc_init(hsotg, chan);
  chan->qh = qh;
  return (0);
}
}
enum dwc2_transaction_type dwc2_hcd_select_transactions(struct dwc2_hsotg *hsotg ) 
{ 
  enum dwc2_transaction_type ret_val ;
  struct list_head *qh_ptr ;
  struct dwc2_qh *qh ;
  int num_channels ;
  int tmp ;
  struct list_head  const  *__mptr ;
  int tmp___0 ;
  int tmp___1 ;
  struct list_head  const  *__mptr___0 ;
  int tmp___2 ;

  {
  ret_val = 0;
  qh_ptr = hsotg->periodic_sched_ready.next;
  goto ldv_34884;
  ldv_34883: 
  tmp = list_empty((struct list_head  const  *)(& hsotg->free_hc_list));
  if (tmp != 0) {
    goto ldv_34880;
  } else {

  }
  if ((hsotg->core_params)->uframe_sched > 0) {
    if (hsotg->available_host_channels <= 1) {
      goto ldv_34880;
    } else {

    }
    hsotg->available_host_channels = hsotg->available_host_channels - 1;
  } else {

  }
  __mptr = (struct list_head  const  *)qh_ptr;
  qh = (struct dwc2_qh *)__mptr + 0xffffffffffffffa8UL;
  tmp___0 = dwc2_assign_and_init_hc(hsotg, qh);
  if (tmp___0 != 0) {
    goto ldv_34880;
  } else {

  }
  qh_ptr = qh_ptr->next;
  list_move(& qh->qh_list_entry, & hsotg->periodic_sched_assigned);
  ret_val = 1;
  ldv_34884: ;
  if ((unsigned long )(& hsotg->periodic_sched_ready) != (unsigned long )qh_ptr) {
    goto ldv_34883;
  } else {

  }
  ldv_34880: 
  num_channels = (hsotg->core_params)->host_channels;
  qh_ptr = hsotg->non_periodic_sched_inactive.next;
  goto ldv_34889;
  ldv_34888: ;
  if ((hsotg->core_params)->uframe_sched <= 0 && hsotg->non_periodic_channels >= num_channels - hsotg->periodic_channels) {
    goto ldv_34885;
  } else {

  }
  tmp___1 = list_empty((struct list_head  const  *)(& hsotg->free_hc_list));
  if (tmp___1 != 0) {
    goto ldv_34885;
  } else {

  }
  __mptr___0 = (struct list_head  const  *)qh_ptr;
  qh = (struct dwc2_qh *)__mptr___0 + 0xffffffffffffffa8UL;
  if ((hsotg->core_params)->uframe_sched > 0) {
    if (hsotg->available_host_channels <= 0) {
      goto ldv_34885;
    } else {

    }
    hsotg->available_host_channels = hsotg->available_host_channels - 1;
  } else {

  }
  tmp___2 = dwc2_assign_and_init_hc(hsotg, qh);
  if (tmp___2 != 0) {
    goto ldv_34885;
  } else {

  }
  qh_ptr = qh_ptr->next;
  list_move(& qh->qh_list_entry, & hsotg->non_periodic_sched_active);
  if ((unsigned int )ret_val == 0U) {
    ret_val = 2;
  } else {
    ret_val = 3;
  }
  if ((hsotg->core_params)->uframe_sched <= 0) {
    hsotg->non_periodic_channels = hsotg->non_periodic_channels + 1;
  } else {

  }
  ldv_34889: ;
  if ((unsigned long )(& hsotg->non_periodic_sched_inactive) != (unsigned long )qh_ptr) {
    goto ldv_34888;
  } else {

  }
  ldv_34885: ;
  return (ret_val);
}
}
static int dwc2_queue_transaction(struct dwc2_hsotg *hsotg , struct dwc2_host_chan *chan ,
                                  u16 fifo_dwords_avail ) 
{ 
  int retval ;

  {
  retval = 0;
  if ((hsotg->core_params)->dma_enable > 0) {
    if ((hsotg->core_params)->dma_desc_enable > 0) {
      if ((unsigned int )chan->xfer_started == 0U || (unsigned int )*((unsigned char *)chan + 3UL) == 1U) {
        dwc2_hcd_start_xfer_ddma(hsotg, chan->qh);
        (chan->qh)->ping_state = 0U;
      } else {

      }
    } else
    if ((unsigned int )chan->xfer_started == 0U) {
      dwc2_hc_start_transfer(hsotg, chan);
      (chan->qh)->ping_state = 0U;
    } else {

    }
  } else
  if ((unsigned int )chan->halt_pending != 0U) {

  } else
  if ((unsigned int )chan->halt_on_queue != 0U) {
    dwc2_hc_halt(hsotg, chan, chan->halt_status);
  } else
  if ((unsigned int )chan->do_ping != 0U) {
    if ((unsigned int )chan->xfer_started == 0U) {
      dwc2_hc_start_transfer(hsotg, chan);
    } else {

    }
  } else
  if ((unsigned int )*((unsigned char *)chan + 2UL) == 0U || (unsigned int )*((unsigned char *)chan + 5UL) == 24U) {
    if ((int )fifo_dwords_avail * 4 >= (int )chan->max_packet) {
      if ((unsigned int )chan->xfer_started == 0U) {
        dwc2_hc_start_transfer(hsotg, chan);
        retval = 1;
      } else {
        retval = dwc2_hc_continue_transfer(hsotg, chan);
      }
    } else {
      retval = -1;
    }
  } else
  if ((unsigned int )chan->xfer_started == 0U) {
    dwc2_hc_start_transfer(hsotg, chan);
    retval = 1;
  } else {
    retval = dwc2_hc_continue_transfer(hsotg, chan);
  }
  return (retval);
}
}
static void dwc2_process_periodic_channels(struct dwc2_hsotg *hsotg ) 
{ 
  struct list_head *qh_ptr ;
  struct dwc2_qh *qh ;
  u32 tx_status ;
  u32 fspcavail ;
  u32 gintmsk ;
  int status ;
  int no_queue_space ;
    klee_make_symbolic(&no_queue_space, sizeof(int), "no_queue_space");
  int no_fifo_space ;
    klee_make_symbolic(&no_fifo_space, sizeof(int), "no_fifo_space");
  u32 qspcavail ;
  struct _ddebug descriptor ;
  long tmp ;
  bool tmp___0 ;
  struct _ddebug descriptor___0 ;
  long tmp___1 ;
  struct _ddebug descriptor___1 ;
  long tmp___2 ;
  bool tmp___3 ;
  struct list_head  const  *__mptr ;
  struct _ddebug descriptor___2 ;
  long tmp___4 ;
  struct _ddebug descriptor___3 ;
  long tmp___5 ;
  bool tmp___6 ;
  int tmp___7 ;

  {
  no_queue_space = 0;
  no_fifo_space = 0;
  tmp___0 = dbg_perio();
  if ((int )tmp___0) {
    descriptor.modname = "dwc2";
    descriptor.function = "dwc2_process_periodic_channels";
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
    descriptor.format = "Queue periodic transactions\n";
    descriptor.lineno = 1075U;
    descriptor.flags = 1U;
    tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
    if (tmp != 0L) {
      __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "Queue periodic transactions\n");
    } else {

    }
  } else {

  }
  tx_status = readl((void const volatile   *)hsotg->regs + 1040U);
  qspcavail = (tx_status & 16711680U) >> 16;
  fspcavail = tx_status & 65535U;
  tmp___3 = dbg_perio();
  if ((int )tmp___3) {
    descriptor___0.modname = "dwc2";
    descriptor___0.function = "dwc2_process_periodic_channels";
    descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
    descriptor___0.format = "  P Tx Req Queue Space Avail (before queue): %d\n";
    descriptor___0.lineno = 1085U;
    descriptor___0.flags = 1U;
    tmp___1 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
    if (tmp___1 != 0L) {
      __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)hsotg->dev, "  P Tx Req Queue Space Avail (before queue): %d\n",
                        qspcavail);
    } else {

    }
    descriptor___1.modname = "dwc2";
    descriptor___1.function = "dwc2_process_periodic_channels";
    descriptor___1.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
    descriptor___1.format = "  P Tx FIFO Space Avail (before queue): %d\n";
    descriptor___1.lineno = 1087U;
    descriptor___1.flags = 1U;
    tmp___2 = ldv__builtin_expect((long )descriptor___1.flags & 1L, 0L);
    if (tmp___2 != 0L) {
      __dynamic_dev_dbg(& descriptor___1, (struct device  const  *)hsotg->dev, "  P Tx FIFO Space Avail (before queue): %d\n",
                        fspcavail);
    } else {

    }
  } else {

  }
  qh_ptr = hsotg->periodic_sched_assigned.next;
  goto ldv_34915;
  ldv_34916: 
  tx_status = readl((void const volatile   *)hsotg->regs + 1040U);
  qspcavail = (tx_status & 16711680U) >> 16;
  if (qspcavail == 0U) {
    no_queue_space = 1;
    goto ldv_34912;
  } else {

  }
  __mptr = (struct list_head  const  *)qh_ptr;
  qh = (struct dwc2_qh *)__mptr + 0xffffffffffffffa8UL;
  if ((unsigned long )qh->channel == (unsigned long )((struct dwc2_host_chan *)0)) {
    qh_ptr = qh_ptr->next;
    goto ldv_34915;
  } else {

  }
  if ((unsigned int )*((unsigned char *)qh + 128UL) != 0U) {
    qh_ptr = qh_ptr->next;
    goto ldv_34915;
  } else {

  }
  if ((hsotg->core_params)->dma_enable <= 0 && (int )(qh->channel)->multi_count > 1) {
    hsotg->queuing_high_bandwidth = 1U;
  } else {

  }
  fspcavail = tx_status & 65535U;
  status = dwc2_queue_transaction(hsotg, qh->channel, (int )((u16 )fspcavail));
  if (status < 0) {
    no_fifo_space = 1;
    goto ldv_34912;
  } else {

  }
  if (((hsotg->core_params)->dma_enable > 0 || status == 0) || (int )(qh->channel)->requests == (int )(qh->channel)->multi_count) {
    qh_ptr = qh_ptr->next;
    list_move(& qh->qh_list_entry, & hsotg->periodic_sched_queued);
    hsotg->queuing_high_bandwidth = 0U;
  } else {

  }
  ldv_34915: ;
  if ((unsigned long )(& hsotg->periodic_sched_assigned) != (unsigned long )qh_ptr) {
    goto ldv_34916;
  } else {

  }
  ldv_34912: ;
  if ((hsotg->core_params)->dma_enable <= 0) {
    tx_status = readl((void const volatile   *)hsotg->regs + 1040U);
    qspcavail = (tx_status & 16711680U) >> 16;
    fspcavail = tx_status & 65535U;
    tmp___6 = dbg_perio();
    if ((int )tmp___6) {
      descriptor___2.modname = "dwc2";
      descriptor___2.function = "dwc2_process_periodic_channels";
      descriptor___2.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
      descriptor___2.format = "  P Tx Req Queue Space Avail (after queue): %d\n";
      descriptor___2.lineno = 1160U;
      descriptor___2.flags = 1U;
      tmp___4 = ldv__builtin_expect((long )descriptor___2.flags & 1L, 0L);
      if (tmp___4 != 0L) {
        __dynamic_dev_dbg(& descriptor___2, (struct device  const  *)hsotg->dev, "  P Tx Req Queue Space Avail (after queue): %d\n",
                          qspcavail);
      } else {

      }
      descriptor___3.modname = "dwc2";
      descriptor___3.function = "dwc2_process_periodic_channels";
      descriptor___3.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
      descriptor___3.format = "  P Tx FIFO Space Avail (after queue): %d\n";
      descriptor___3.lineno = 1163U;
      descriptor___3.flags = 1U;
      tmp___5 = ldv__builtin_expect((long )descriptor___3.flags & 1L, 0L);
      if (tmp___5 != 0L) {
        __dynamic_dev_dbg(& descriptor___3, (struct device  const  *)hsotg->dev, "  P Tx FIFO Space Avail (after queue): %d\n",
                          fspcavail);
      } else {

      }
    } else {

    }
    tmp___7 = list_empty((struct list_head  const  *)(& hsotg->periodic_sched_assigned));
    if ((tmp___7 == 0 || no_queue_space != 0) || no_fifo_space != 0) {
      gintmsk = readl((void const volatile   *)hsotg->regs + 24U);
      gintmsk = gintmsk | 67108864U;
      writel(gintmsk, (void volatile   *)hsotg->regs + 24U);
    } else {
      gintmsk = readl((void const volatile   *)hsotg->regs + 24U);
      gintmsk = gintmsk & 4227858431U;
      writel(gintmsk, (void volatile   *)hsotg->regs + 24U);
    }
  } else {

  }
  return;
}
}
static void dwc2_process_non_periodic_channels(struct dwc2_hsotg *hsotg ) 
{ 
  struct list_head *orig_qh_ptr ;
  struct dwc2_qh *qh ;
  u32 tx_status ;
  u32 qspcavail ;
  u32 fspcavail ;
  u32 gintmsk ;
  int status ;
  int no_queue_space ;
  int no_fifo_space ;
  int more_to_do ;
    klee_make_symbolic(&more_to_do, sizeof(int), "more_to_do");
  struct _ddebug descriptor ;
  long tmp ;
  struct _ddebug descriptor___0 ;
  long tmp___0 ;
  struct _ddebug descriptor___1 ;
  long tmp___1 ;
  struct list_head  const  *__mptr ;
  struct _ddebug descriptor___2 ;
  long tmp___2 ;
  struct _ddebug descriptor___3 ;
  long tmp___3 ;

  {
  no_queue_space = 0;
  no_fifo_space = 0;
  more_to_do = 0;
  descriptor.modname = "dwc2";
  descriptor.function = "dwc2_process_non_periodic_channels";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
  descriptor.format = "Queue non-periodic transactions\n";
  descriptor.lineno = 1215U;
  descriptor.flags = 1U;
  tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp != 0L) {
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "Queue non-periodic transactions\n");
  } else {

  }
  tx_status = readl((void const volatile   *)hsotg->regs + 44U);
  qspcavail = (tx_status & 16711680U) >> 16;
  fspcavail = tx_status & 65535U;
  descriptor___0.modname = "dwc2";
  descriptor___0.function = "dwc2_process_non_periodic_channels";
  descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
  descriptor___0.format = "  NP Tx Req Queue Space Avail (before queue): %d\n";
  descriptor___0.lineno = 1223U;
  descriptor___0.flags = 1U;
  tmp___0 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
  if (tmp___0 != 0L) {
    __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)hsotg->dev, "  NP Tx Req Queue Space Avail (before queue): %d\n",
                      qspcavail);
  } else {

  }
  descriptor___1.modname = "dwc2";
  descriptor___1.function = "dwc2_process_non_periodic_channels";
  descriptor___1.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
  descriptor___1.format = "  NP Tx FIFO Space Avail (before queue): %d\n";
  descriptor___1.lineno = 1225U;
  descriptor___1.flags = 1U;
  tmp___1 = ldv__builtin_expect((long )descriptor___1.flags & 1L, 0L);
  if (tmp___1 != 0L) {
    __dynamic_dev_dbg(& descriptor___1, (struct device  const  *)hsotg->dev, "  NP Tx FIFO Space Avail (before queue): %d\n",
                      fspcavail);
  } else {

  }
  if ((unsigned long )hsotg->non_periodic_qh_ptr == (unsigned long )(& hsotg->non_periodic_sched_active)) {
    hsotg->non_periodic_qh_ptr = (hsotg->non_periodic_qh_ptr)->next;
  } else {

  }
  orig_qh_ptr = hsotg->non_periodic_qh_ptr;
  ldv_34940: 
  tx_status = readl((void const volatile   *)hsotg->regs + 44U);
  qspcavail = (tx_status & 16711680U) >> 16;
  if ((hsotg->core_params)->dma_enable <= 0 && qspcavail == 0U) {
    no_queue_space = 1;
    goto ldv_34936;
  } else {

  }
  __mptr = (struct list_head  const  *)hsotg->non_periodic_qh_ptr;
  qh = (struct dwc2_qh *)__mptr + 0xffffffffffffffa8UL;
  if ((unsigned long )qh->channel == (unsigned long )((struct dwc2_host_chan *)0)) {
    goto next;
  } else {

  }
  if ((unsigned int )*((unsigned char *)qh + 128UL) != 0U) {
    goto next;
  } else {

  }
  fspcavail = tx_status & 65535U;
  status = dwc2_queue_transaction(hsotg, qh->channel, (int )((u16 )fspcavail));
  if (status > 0) {
    more_to_do = 1;
  } else
  if (status < 0) {
    no_fifo_space = 1;
    goto ldv_34936;
  } else {

  }
  next: 
  hsotg->non_periodic_qh_ptr = (hsotg->non_periodic_qh_ptr)->next;
  if ((unsigned long )hsotg->non_periodic_qh_ptr == (unsigned long )(& hsotg->non_periodic_sched_active)) {
    hsotg->non_periodic_qh_ptr = (hsotg->non_periodic_qh_ptr)->next;
  } else {

  }
  if ((unsigned long )hsotg->non_periodic_qh_ptr != (unsigned long )orig_qh_ptr) {
    goto ldv_34940;
  } else {

  }
  ldv_34936: ;
  if ((hsotg->core_params)->dma_enable <= 0) {
    tx_status = readl((void const volatile   *)hsotg->regs + 44U);
    qspcavail = (tx_status & 16711680U) >> 16;
    fspcavail = tx_status & 65535U;
    descriptor___2.modname = "dwc2";
    descriptor___2.function = "dwc2_process_non_periodic_channels";
    descriptor___2.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
    descriptor___2.format = "  NP Tx Req Queue Space Avail (after queue): %d\n";
    descriptor___2.lineno = 1284U;
    descriptor___2.flags = 1U;
    tmp___2 = ldv__builtin_expect((long )descriptor___2.flags & 1L, 0L);
    if (tmp___2 != 0L) {
      __dynamic_dev_dbg(& descriptor___2, (struct device  const  *)hsotg->dev, "  NP Tx Req Queue Space Avail (after queue): %d\n",
                        qspcavail);
    } else {

    }
    descriptor___3.modname = "dwc2";
    descriptor___3.function = "dwc2_process_non_periodic_channels";
    descriptor___3.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
    descriptor___3.format = "  NP Tx FIFO Space Avail (after queue): %d\n";
    descriptor___3.lineno = 1287U;
    descriptor___3.flags = 1U;
    tmp___3 = ldv__builtin_expect((long )descriptor___3.flags & 1L, 0L);
    if (tmp___3 != 0L) {
      __dynamic_dev_dbg(& descriptor___3, (struct device  const  *)hsotg->dev, "  NP Tx FIFO Space Avail (after queue): %d\n",
                        fspcavail);
    } else {

    }
    if ((more_to_do != 0 || no_queue_space != 0) || no_fifo_space != 0) {
      gintmsk = readl((void const volatile   *)hsotg->regs + 24U);
      gintmsk = gintmsk | 32U;
      writel(gintmsk, (void volatile   *)hsotg->regs + 24U);
    } else {
      gintmsk = readl((void const volatile   *)hsotg->regs + 24U);
      gintmsk = gintmsk & 4294967263U;
      writel(gintmsk, (void volatile   *)hsotg->regs + 24U);
    }
  } else {

  }
  return;
}
}
void dwc2_hcd_queue_transactions(struct dwc2_hsotg *hsotg , enum dwc2_transaction_type tr_type ) 
{ 
  int tmp ;
  u32 gintmsk ;
  unsigned int tmp___0 ;
  int tmp___1 ;

  {
  if ((unsigned int )tr_type == 1U || (unsigned int )tr_type == 3U) {
    tmp = list_empty((struct list_head  const  *)(& hsotg->periodic_sched_assigned));
    if (tmp == 0) {
      dwc2_process_periodic_channels(hsotg);
    } else {

    }
  } else {

  }
  if ((unsigned int )tr_type == 2U || (unsigned int )tr_type == 3U) {
    tmp___1 = list_empty((struct list_head  const  *)(& hsotg->non_periodic_sched_active));
    if (tmp___1 == 0) {
      dwc2_process_non_periodic_channels(hsotg);
    } else {
      tmp___0 = readl((void const volatile   *)hsotg->regs + 24U);
      gintmsk = tmp___0;
      gintmsk = gintmsk & 4294967263U;
      writel(gintmsk, (void volatile   *)hsotg->regs + 24U);
    }
  } else {

  }
  return;
}
}
static void dwc2_conn_id_status_change(struct work_struct *work ) 
{ 
  struct dwc2_hsotg *hsotg ;
  struct work_struct  const  *__mptr ;
  u32 count ;
  u32 gotgctl ;
  struct _ddebug descriptor ;
  long tmp ;
  struct _ddebug descriptor___0 ;
  long tmp___0 ;
  struct _ddebug descriptor___1 ;
  long tmp___1 ;
  struct _ddebug descriptor___2 ;
  long tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  struct _ddebug descriptor___3 ;
  long tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
  __mptr = (struct work_struct  const  *)work;
  hsotg = (struct dwc2_hsotg *)__mptr + 0xfffffffffffffe68UL;
  count = 0U;
  descriptor.modname = "dwc2";
  descriptor.function = "dwc2_conn_id_status_change";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
  descriptor.format = "%s()\n";
  descriptor.lineno = 1363U;
  descriptor.flags = 1U;
  tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp != 0L) {
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "%s()\n",
                      "dwc2_conn_id_status_change");
  } else {

  }
  gotgctl = readl((void const volatile   *)hsotg->regs);
  descriptor___0.modname = "dwc2";
  descriptor___0.function = "dwc2_conn_id_status_change";
  descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
  descriptor___0.format = "gotgctl=%0x\n";
  descriptor___0.lineno = 1366U;
  descriptor___0.flags = 1U;
  tmp___0 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
  if (tmp___0 != 0L) {
    __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)hsotg->dev, "gotgctl=%0x\n",
                      gotgctl);
  } else {

  }
  descriptor___1.modname = "dwc2";
  descriptor___1.function = "dwc2_conn_id_status_change";
  descriptor___1.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
  descriptor___1.format = "gotgctl.b.conidsts=%d\n";
  descriptor___1.lineno = 1368U;
  descriptor___1.flags = 1U;
  tmp___1 = ldv__builtin_expect((long )descriptor___1.flags & 1L, 0L);
  if (tmp___1 != 0L) {
    __dynamic_dev_dbg(& descriptor___1, (struct device  const  *)hsotg->dev, "gotgctl.b.conidsts=%d\n",
                      (gotgctl & 65536U) != 0U);
  } else {

  }
  if ((gotgctl & 65536U) != 0U) {
    descriptor___2.modname = "dwc2";
    descriptor___2.function = "dwc2_conn_id_status_change";
    descriptor___2.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
    descriptor___2.format = "connId B\n";
    descriptor___2.lineno = 1373U;
    descriptor___2.flags = 1U;
    tmp___2 = ldv__builtin_expect((long )descriptor___2.flags & 1L, 0L);
    if (tmp___2 != 0L) {
      __dynamic_dev_dbg(& descriptor___2, (struct device  const  *)hsotg->dev, "connId B\n");
    } else {

    }
    goto ldv_34963;
    ldv_34962: 
    tmp___3 = dwc2_is_host_mode(hsotg);
    _dev_info((struct device  const  *)hsotg->dev, "Waiting for Peripheral Mode, Mode=%s\n",
              tmp___3 != 0 ? (char *)"Host" : (char *)"Peripheral");
    usleep_range(20000UL, 40000UL);
    count = count + 1U;
    if (count > 250U) {
      goto ldv_34961;
    } else {

    }
    ldv_34963: 
    tmp___4 = dwc2_is_device_mode(hsotg);
    if (tmp___4 == 0) {
      goto ldv_34962;
    } else {

    }
    ldv_34961: ;
    if (count > 250U) {
      dev_err((struct device  const  *)hsotg->dev, "Connection id status change timed out\n");
    } else {

    }
    hsotg->op_state = 3;
    dwc2_core_init(hsotg, 0, -1);
    dwc2_enable_global_interrupts(hsotg);
    s3c_hsotg_core_init_disconnected(hsotg, 0);
    s3c_hsotg_core_connect(hsotg);
  } else {
    descriptor___3.modname = "dwc2";
    descriptor___3.function = "dwc2_conn_id_status_change";
    descriptor___3.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
    descriptor___3.format = "connId A\n";
    descriptor___3.lineno = 1393U;
    descriptor___3.flags = 1U;
    tmp___5 = ldv__builtin_expect((long )descriptor___3.flags & 1L, 0L);
    if (tmp___5 != 0L) {
      __dynamic_dev_dbg(& descriptor___3, (struct device  const  *)hsotg->dev, "connId A\n");
    } else {

    }
    goto ldv_34967;
    ldv_34966: 
    tmp___6 = dwc2_is_host_mode(hsotg);
    _dev_info((struct device  const  *)hsotg->dev, "Waiting for Host Mode, Mode=%s\n",
              tmp___6 != 0 ? (char *)"Host" : (char *)"Peripheral");
    usleep_range(20000UL, 40000UL);
    count = count + 1U;
    if (count > 250U) {
      goto ldv_34965;
    } else {

    }
    ldv_34967: 
    tmp___7 = dwc2_is_host_mode(hsotg);
    if (tmp___7 == 0) {
      goto ldv_34966;
    } else {

    }
    ldv_34965: ;
    if (count > 250U) {
      dev_err((struct device  const  *)hsotg->dev, "Connection id status change timed out\n");
    } else {

    }
    hsotg->op_state = 9;
    dwc2_core_init(hsotg, 0, -1);
    dwc2_enable_global_interrupts(hsotg);
    dwc2_hcd_start(hsotg);
  }
  return;
}
}
static void dwc2_wakeup_detected(unsigned long data ) 
{ 
  struct dwc2_hsotg *hsotg ;
  u32 hprt0 ;
  struct _ddebug descriptor ;
  long tmp ;
  struct _ddebug descriptor___0 ;
  long tmp___0 ;
  struct _ddebug descriptor___1 ;
  unsigned int tmp___1 ;
  long tmp___2 ;

  {
  hsotg = (struct dwc2_hsotg *)data;
  descriptor.modname = "dwc2";
  descriptor.function = "dwc2_wakeup_detected";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
  descriptor.format = "%s()\n";
  descriptor.lineno = 1419U;
  descriptor.flags = 1U;
  tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp != 0L) {
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "%s()\n",
                      "dwc2_wakeup_detected");
  } else {

  }
  hprt0 = dwc2_read_hprt0(hsotg);
  descriptor___0.modname = "dwc2";
  descriptor___0.function = "dwc2_wakeup_detected";
  descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
  descriptor___0.format = "Resume: HPRT0=%0x\n";
  descriptor___0.lineno = 1426U;
  descriptor___0.flags = 1U;
  tmp___0 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
  if (tmp___0 != 0L) {
    __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)hsotg->dev, "Resume: HPRT0=%0x\n",
                      hprt0);
  } else {

  }
  hprt0 = hprt0 & 4294967231U;
  writel(hprt0, (void volatile   *)hsotg->regs + 1088U);
  descriptor___1.modname = "dwc2";
  descriptor___1.function = "dwc2_wakeup_detected";
  descriptor___1.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
  descriptor___1.format = "Clear Resume: HPRT0=%0x\n";
  descriptor___1.lineno = 1430U;
  descriptor___1.flags = 1U;
  tmp___2 = ldv__builtin_expect((long )descriptor___1.flags & 1L, 0L);
  if (tmp___2 != 0L) {
    tmp___1 = readl((void const volatile   *)hsotg->regs + 1088U);
    __dynamic_dev_dbg(& descriptor___1, (struct device  const  *)hsotg->dev, "Clear Resume: HPRT0=%0x\n",
                      tmp___1);
  } else {

  }
  dwc2_hcd_rem_wakeup(hsotg);
  hsotg->lx_state = 0;
  return;
}
}
static int dwc2_host_is_b_hnp_enabled(struct dwc2_hsotg *hsotg ) 
{ 
  struct usb_hcd *hcd ;
  struct usb_hcd *tmp ;

  {
  tmp = dwc2_hsotg_to_hcd(hsotg);
  hcd = tmp;
  return ((int )hcd->self.b_hnp_enable);
}
}
static void dwc2_port_suspend(struct dwc2_hsotg *hsotg , u16 windex ) 
{ 
  unsigned long flags ;
  u32 hprt0 ;
  u32 pcgctl ;
  u32 gotgctl ;
  struct _ddebug descriptor ;
  long tmp ;
  raw_spinlock_t *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  descriptor.modname = "dwc2";
  descriptor.function = "dwc2_port_suspend";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
  descriptor.format = "%s()\n";
  descriptor.lineno = 1453U;
  descriptor.flags = 1U;
  tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp != 0L) {
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "%s()\n",
                      "dwc2_port_suspend");
  } else {

  }
  tmp___0 = spinlock_check(& hsotg->lock);
  flags = _raw_spin_lock_irqsave(tmp___0);
  if ((int )((unsigned short )hsotg->otg_port) == (int )windex) {
    tmp___1 = dwc2_host_is_b_hnp_enabled(hsotg);
    if (tmp___1 != 0) {
      gotgctl = readl((void const volatile   *)hsotg->regs);
      gotgctl = gotgctl | 1024U;
      writel(gotgctl, (void volatile   *)hsotg->regs);
      hsotg->op_state = 10;
    } else {

    }
  } else {

  }
  hprt0 = dwc2_read_hprt0(hsotg);
  hprt0 = hprt0 | 128U;
  writel(hprt0, (void volatile   *)hsotg->regs + 1088U);
  hsotg->lx_state = 2;
  pcgctl = readl((void const volatile   *)hsotg->regs + 3584U);
  pcgctl = pcgctl | 1U;
  writel(pcgctl, (void volatile   *)hsotg->regs + 3584U);
  __const_udelay(42950UL);
  tmp___2 = dwc2_host_is_b_hnp_enabled(hsotg);
  if (tmp___2 != 0) {
    pcgctl = readl((void const volatile   *)hsotg->regs + 3584U);
    pcgctl = pcgctl & 4294967294U;
    writel(pcgctl, (void volatile   *)hsotg->regs + 3584U);
    spin_unlock_irqrestore(& hsotg->lock, flags);
    usleep_range(200000UL, 250000UL);
  } else {
    spin_unlock_irqrestore(& hsotg->lock, flags);
  }
  return;
}
}
static int dwc2_hcd_hub_control(struct dwc2_hsotg *hsotg , u16 typereq , u16 wvalue ,
                                u16 windex , char *buf , u16 wlength ) 
{ 
  struct usb_hub_descriptor *hub_desc ;
  int retval ;
  u32 hprt0 ;
  u32 port_status ;
  u32 speed ;
  u32 pcgctl ;
  struct _ddebug descriptor ;
  long tmp ;
  struct _ddebug descriptor___0 ;
  long tmp___0 ;
  struct _ddebug descriptor___1 ;
  long tmp___1 ;
  struct _ddebug descriptor___2 ;
  long tmp___2 ;
  struct _ddebug descriptor___3 ;
  long tmp___3 ;
  struct _ddebug descriptor___4 ;
  long tmp___4 ;
  struct _ddebug descriptor___5 ;
  long tmp___5 ;
  struct _ddebug descriptor___6 ;
  long tmp___6 ;
  struct _ddebug descriptor___7 ;
  long tmp___7 ;
  struct _ddebug descriptor___8 ;
  long tmp___8 ;
  struct _ddebug descriptor___9 ;
  long tmp___9 ;
  struct _ddebug descriptor___10 ;
  long tmp___10 ;
  struct _ddebug descriptor___11 ;
  long tmp___11 ;
  struct _ddebug descriptor___12 ;
  long tmp___12 ;
  struct _ddebug descriptor___13 ;
  long tmp___13 ;
  struct _ddebug descriptor___14 ;
  long tmp___14 ;
  struct _ddebug descriptor___15 ;
  long tmp___15 ;
  struct _ddebug descriptor___16 ;
  long tmp___16 ;
  struct _ddebug descriptor___17 ;
  long tmp___17 ;
  struct _ddebug descriptor___18 ;
  long tmp___18 ;
  struct _ddebug descriptor___19 ;
  long tmp___19 ;
  struct _ddebug descriptor___20 ;
  long tmp___20 ;
  int tmp___21 ;
  struct _ddebug descriptor___21 ;
  long tmp___22 ;
  struct _ddebug descriptor___22 ;
  long tmp___23 ;
  struct _ddebug descriptor___23 ;
  long tmp___24 ;

  {
  retval = 0;
  switch ((int )typereq) {
  case 8193: 
  descriptor.modname = "dwc2";
  descriptor.function = "dwc2_hcd_hub_control";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
  descriptor.format = "ClearHubFeature %1xh\n";
  descriptor.lineno = 1504U;
  descriptor.flags = 1U;
  tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp != 0L) {
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "ClearHubFeature %1xh\n",
                      (int )wvalue);
  } else {

  }
  switch ((int )wvalue) {
  case 0: ;
  case 1: ;
  goto ldv_35013;
  default: 
  retval = -22;
  dev_err((struct device  const  *)hsotg->dev, "ClearHubFeature request %1xh unknown\n",
          (int )wvalue);
  }
  ldv_35013: ;
  goto ldv_35015;
  case 8961: ;
  if ((unsigned int )wvalue != 5U) {
    if ((unsigned int )windex == 0U || (unsigned int )windex > 1U) {
      goto error;
    } else {

    }
  } else {

  }
  switch ((int )wvalue) {
  case 1: 
  descriptor___0.modname = "dwc2";
  descriptor___0.function = "dwc2_hcd_hub_control";
  descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
  descriptor___0.format = "ClearPortFeature USB_PORT_FEAT_ENABLE\n";
  descriptor___0.lineno = 1527U;
  descriptor___0.flags = 1U;
  tmp___0 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
  if (tmp___0 != 0L) {
    __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)hsotg->dev, "ClearPortFeature USB_PORT_FEAT_ENABLE\n");
  } else {

  }
  hprt0 = dwc2_read_hprt0(hsotg);
  hprt0 = hprt0 | 4U;
  writel(hprt0, (void volatile   *)hsotg->regs + 1088U);
  goto ldv_35020;
  case 2: 
  descriptor___1.modname = "dwc2";
  descriptor___1.function = "dwc2_hcd_hub_control";
  descriptor___1.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
  descriptor___1.format = "ClearPortFeature USB_PORT_FEAT_SUSPEND\n";
  descriptor___1.lineno = 1535U;
  descriptor___1.flags = 1U;
  tmp___1 = ldv__builtin_expect((long )descriptor___1.flags & 1L, 0L);
  if (tmp___1 != 0L) {
    __dynamic_dev_dbg(& descriptor___1, (struct device  const  *)hsotg->dev, "ClearPortFeature USB_PORT_FEAT_SUSPEND\n");
  } else {

  }
  writel(0U, (void volatile   *)hsotg->regs + 3584U);
  usleep_range(20000UL, 40000UL);
  hprt0 = dwc2_read_hprt0(hsotg);
  hprt0 = hprt0 | 64U;
  writel(hprt0, (void volatile   *)hsotg->regs + 1088U);
  hprt0 = hprt0 & 4294967167U;
  msleep(40U);
  hprt0 = hprt0 & 4294967231U;
  writel(hprt0, (void volatile   *)hsotg->regs + 1088U);
  goto ldv_35020;
  case 8: 
  descriptor___2.modname = "dwc2";
  descriptor___2.function = "dwc2_hcd_hub_control";
  descriptor___2.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
  descriptor___2.format = "ClearPortFeature USB_PORT_FEAT_POWER\n";
  descriptor___2.lineno = 1551U;
  descriptor___2.flags = 1U;
  tmp___2 = ldv__builtin_expect((long )descriptor___2.flags & 1L, 0L);
  if (tmp___2 != 0L) {
    __dynamic_dev_dbg(& descriptor___2, (struct device  const  *)hsotg->dev, "ClearPortFeature USB_PORT_FEAT_POWER\n");
  } else {

  }
  hprt0 = dwc2_read_hprt0(hsotg);
  hprt0 = hprt0 & 4294963199U;
  writel(hprt0, (void volatile   *)hsotg->regs + 1088U);
  goto ldv_35020;
  case 22: 
  descriptor___3.modname = "dwc2";
  descriptor___3.function = "dwc2_hcd_hub_control";
  descriptor___3.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
  descriptor___3.format = "ClearPortFeature USB_PORT_FEAT_INDICATOR\n";
  descriptor___3.lineno = 1559U;
  descriptor___3.flags = 1U;
  tmp___3 = ldv__builtin_expect((long )descriptor___3.flags & 1L, 0L);
  if (tmp___3 != 0L) {
    __dynamic_dev_dbg(& descriptor___3, (struct device  const  *)hsotg->dev, "ClearPortFeature USB_PORT_FEAT_INDICATOR\n");
  } else {

  }
  goto ldv_35020;
  case 16: 
  descriptor___4.modname = "dwc2";
  descriptor___4.function = "dwc2_hcd_hub_control";
  descriptor___4.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
  descriptor___4.format = "ClearPortFeature USB_PORT_FEAT_C_CONNECTION\n";
  descriptor___4.lineno = 1568U;
  descriptor___4.flags = 1U;
  tmp___4 = ldv__builtin_expect((long )descriptor___4.flags & 1L, 0L);
  if (tmp___4 != 0L) {
    __dynamic_dev_dbg(& descriptor___4, (struct device  const  *)hsotg->dev, "ClearPortFeature USB_PORT_FEAT_C_CONNECTION\n");
  } else {

  }
  hsotg->flags.b.port_connect_status_change = 0U;
  goto ldv_35020;
  case 20: 
  descriptor___5.modname = "dwc2";
  descriptor___5.function = "dwc2_hcd_hub_control";
  descriptor___5.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
  descriptor___5.format = "ClearPortFeature USB_PORT_FEAT_C_RESET\n";
  descriptor___5.lineno = 1575U;
  descriptor___5.flags = 1U;
  tmp___5 = ldv__builtin_expect((long )descriptor___5.flags & 1L, 0L);
  if (tmp___5 != 0L) {
    __dynamic_dev_dbg(& descriptor___5, (struct device  const  *)hsotg->dev, "ClearPortFeature USB_PORT_FEAT_C_RESET\n");
  } else {

  }
  hsotg->flags.b.port_reset_change = 0U;
  goto ldv_35020;
  case 17: 
  descriptor___6.modname = "dwc2";
  descriptor___6.function = "dwc2_hcd_hub_control";
  descriptor___6.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
  descriptor___6.format = "ClearPortFeature USB_PORT_FEAT_C_ENABLE\n";
  descriptor___6.lineno = 1585U;
  descriptor___6.flags = 1U;
  tmp___6 = ldv__builtin_expect((long )descriptor___6.flags & 1L, 0L);
  if (tmp___6 != 0L) {
    __dynamic_dev_dbg(& descriptor___6, (struct device  const  *)hsotg->dev, "ClearPortFeature USB_PORT_FEAT_C_ENABLE\n");
  } else {

  }
  hsotg->flags.b.port_enable_change = 0U;
  goto ldv_35020;
  case 18: 
  descriptor___7.modname = "dwc2";
  descriptor___7.function = "dwc2_hcd_hub_control";
  descriptor___7.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
  descriptor___7.format = "ClearPortFeature USB_PORT_FEAT_C_SUSPEND\n";
  descriptor___7.lineno = 1596U;
  descriptor___7.flags = 1U;
  tmp___7 = ldv__builtin_expect((long )descriptor___7.flags & 1L, 0L);
  if (tmp___7 != 0L) {
    __dynamic_dev_dbg(& descriptor___7, (struct device  const  *)hsotg->dev, "ClearPortFeature USB_PORT_FEAT_C_SUSPEND\n");
  } else {

  }
  hsotg->flags.b.port_suspend_change = 0U;
  goto ldv_35020;
  case 23: 
  descriptor___8.modname = "dwc2";
  descriptor___8.function = "dwc2_hcd_hub_control";
  descriptor___8.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
  descriptor___8.format = "ClearPortFeature USB_PORT_FEAT_C_PORT_L1\n";
  descriptor___8.lineno = 1602U;
  descriptor___8.flags = 1U;
  tmp___8 = ldv__builtin_expect((long )descriptor___8.flags & 1L, 0L);
  if (tmp___8 != 0L) {
    __dynamic_dev_dbg(& descriptor___8, (struct device  const  *)hsotg->dev, "ClearPortFeature USB_PORT_FEAT_C_PORT_L1\n");
  } else {

  }
  hsotg->flags.b.port_l1_change = 0U;
  goto ldv_35020;
  case 19: 
  descriptor___9.modname = "dwc2";
  descriptor___9.function = "dwc2_hcd_hub_control";
  descriptor___9.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
  descriptor___9.format = "ClearPortFeature USB_PORT_FEAT_C_OVER_CURRENT\n";
  descriptor___9.lineno = 1608U;
  descriptor___9.flags = 1U;
  tmp___9 = ldv__builtin_expect((long )descriptor___9.flags & 1L, 0L);
  if (tmp___9 != 0L) {
    __dynamic_dev_dbg(& descriptor___9, (struct device  const  *)hsotg->dev, "ClearPortFeature USB_PORT_FEAT_C_OVER_CURRENT\n");
  } else {

  }
  hsotg->flags.b.port_over_current_change = 0U;
  goto ldv_35020;
  default: 
  retval = -22;
  dev_err((struct device  const  *)hsotg->dev, "ClearPortFeature request %1xh unknown or unsupported\n",
          (int )wvalue);
  }
  ldv_35020: ;
  goto ldv_35015;
  case 40966: 
  descriptor___10.modname = "dwc2";
  descriptor___10.function = "dwc2_hcd_hub_control";
  descriptor___10.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
  descriptor___10.format = "GetHubDescriptor\n";
  descriptor___10.lineno = 1621U;
  descriptor___10.flags = 1U;
  tmp___10 = ldv__builtin_expect((long )descriptor___10.flags & 1L, 0L);
  if (tmp___10 != 0L) {
    __dynamic_dev_dbg(& descriptor___10, (struct device  const  *)hsotg->dev, "GetHubDescriptor\n");
  } else {

  }
  hub_desc = (struct usb_hub_descriptor *)buf;
  hub_desc->bDescLength = 9U;
  hub_desc->bDescriptorType = 41U;
  hub_desc->bNbrPorts = 1U;
  hub_desc->wHubCharacteristics = 8U;
  hub_desc->bPwrOn2PwrGood = 1U;
  hub_desc->bHubContrCurrent = 0U;
  hub_desc->u.hs.DeviceRemovable[0] = 0U;
  hub_desc->u.hs.DeviceRemovable[1] = 255U;
  goto ldv_35015;
  case 40960: 
  descriptor___11.modname = "dwc2";
  descriptor___11.function = "dwc2_hcd_hub_control";
  descriptor___11.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
  descriptor___11.format = "GetHubStatus\n";
  descriptor___11.lineno = 1636U;
  descriptor___11.flags = 1U;
  tmp___11 = ldv__builtin_expect((long )descriptor___11.flags & 1L, 0L);
  if (tmp___11 != 0L) {
    __dynamic_dev_dbg(& descriptor___11, (struct device  const  *)hsotg->dev, "GetHubStatus\n");
  } else {

  }
  memset((void *)buf, 0, 4UL);
  goto ldv_35015;
  case 41728: 
  descriptor___12.modname = "dwc2";
  descriptor___12.function = "dwc2_hcd_hub_control";
  descriptor___12.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
  descriptor___12.format = "GetPortStatus wIndex=0x%04x flags=0x%08x\n";
  descriptor___12.lineno = 1643U;
  descriptor___12.flags = 1U;
  tmp___12 = ldv__builtin_expect((long )descriptor___12.flags & 1L, 0L);
  if (tmp___12 != 0L) {
    __dynamic_dev_dbg(& descriptor___12, (struct device  const  *)hsotg->dev, "GetPortStatus wIndex=0x%04x flags=0x%08x\n",
                      (int )windex, hsotg->flags.d32);
  } else {

  }
  if ((unsigned int )windex == 0U || (unsigned int )windex > 1U) {
    goto error;
  } else {

  }
  port_status = 0U;
  if ((unsigned int )*((unsigned char *)hsotg + 664UL) != 0U) {
    port_status = port_status | 65536U;
  } else {

  }
  if ((unsigned int )*((unsigned char *)hsotg + 664UL) != 0U) {
    port_status = port_status | 131072U;
  } else {

  }
  if ((unsigned int )*((unsigned char *)hsotg + 664UL) != 0U) {
    port_status = port_status | 262144U;
  } else {

  }
  if ((unsigned int )*((unsigned char *)hsotg + 664UL) != 0U) {
    port_status = port_status | 2097152U;
  } else {

  }
  if ((unsigned int )*((unsigned char *)hsotg + 664UL) != 0U) {
    port_status = port_status | 1048576U;
  } else {

  }
  if ((unsigned int )*((unsigned char *)hsotg + 664UL) != 0U) {
    dev_warn((struct device  const  *)hsotg->dev, "Overcurrent change detected\n");
    port_status = port_status | 524288U;
  } else {

  }
  if ((unsigned int )*((unsigned char *)hsotg + 664UL) == 0U) {
    *((__le32 *)buf) = port_status;
    goto ldv_35015;
  } else {

  }
  hprt0 = readl((void const volatile   *)hsotg->regs + 1088U);
  descriptor___13.modname = "dwc2";
  descriptor___13.function = "dwc2_hcd_hub_control";
  descriptor___13.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
  descriptor___13.format = "  HPRT0: 0x%08x\n";
  descriptor___13.lineno = 1676U;
  descriptor___13.flags = 1U;
  tmp___13 = ldv__builtin_expect((long )descriptor___13.flags & 1L, 0L);
  if (tmp___13 != 0L) {
    __dynamic_dev_dbg(& descriptor___13, (struct device  const  *)hsotg->dev, "  HPRT0: 0x%08x\n",
                      hprt0);
  } else {

  }
  if ((int )hprt0 & 1) {
    port_status = port_status | 1U;
  } else {

  }
  if ((hprt0 & 4U) != 0U) {
    port_status = port_status | 2U;
  } else {

  }
  if ((hprt0 & 128U) != 0U) {
    port_status = port_status | 4U;
  } else {

  }
  if ((hprt0 & 16U) != 0U) {
    port_status = port_status | 8U;
  } else {

  }
  if ((hprt0 & 256U) != 0U) {
    port_status = port_status | 16U;
  } else {

  }
  if ((hprt0 & 4096U) != 0U) {
    port_status = port_status | 256U;
  } else {

  }
  speed = (hprt0 & 393216U) >> 17;
  if (speed == 0U) {
    port_status = port_status | 1024U;
  } else
  if (speed == 2U) {
    port_status = port_status | 512U;
  } else {

  }
  if ((hprt0 & 122880U) != 0U) {
    port_status = port_status | 2048U;
  } else {

  }
  descriptor___14.modname = "dwc2";
  descriptor___14.function = "dwc2_hcd_hub_control";
  descriptor___14.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
  descriptor___14.format = "port_status=%08x\n";
  descriptor___14.lineno = 1701U;
  descriptor___14.flags = 1U;
  tmp___14 = ldv__builtin_expect((long )descriptor___14.flags & 1L, 0L);
  if (tmp___14 != 0L) {
    __dynamic_dev_dbg(& descriptor___14, (struct device  const  *)hsotg->dev, "port_status=%08x\n",
                      port_status);
  } else {

  }
  *((__le32 *)buf) = port_status;
  goto ldv_35015;
  case 8195: 
  descriptor___15.modname = "dwc2";
  descriptor___15.function = "dwc2_hcd_hub_control";
  descriptor___15.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
  descriptor___15.format = "SetHubFeature\n";
  descriptor___15.lineno = 1706U;
  descriptor___15.flags = 1U;
  tmp___15 = ldv__builtin_expect((long )descriptor___15.flags & 1L, 0L);
  if (tmp___15 != 0L) {
    __dynamic_dev_dbg(& descriptor___15, (struct device  const  *)hsotg->dev, "SetHubFeature\n");
  } else {

  }
  goto ldv_35015;
  case 8963: 
  descriptor___16.modname = "dwc2";
  descriptor___16.function = "dwc2_hcd_hub_control";
  descriptor___16.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
  descriptor___16.format = "SetPortFeature\n";
  descriptor___16.lineno = 1711U;
  descriptor___16.flags = 1U;
  tmp___16 = ldv__builtin_expect((long )descriptor___16.flags & 1L, 0L);
  if (tmp___16 != 0L) {
    __dynamic_dev_dbg(& descriptor___16, (struct device  const  *)hsotg->dev, "SetPortFeature\n");
  } else {

  }
  if ((unsigned int )wvalue != 21U && ((unsigned int )windex == 0U || (unsigned int )windex > 1U)) {
    goto error;
  } else {

  }
  if ((unsigned int )*((unsigned char *)hsotg + 664UL) == 0U) {
    goto ldv_35015;
  } else {

  }
  switch ((int )wvalue) {
  case 2: 
  descriptor___17.modname = "dwc2";
  descriptor___17.function = "dwc2_hcd_hub_control";
  descriptor___17.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
  descriptor___17.format = "SetPortFeature - USB_PORT_FEAT_SUSPEND\n";
  descriptor___17.lineno = 1729U;
  descriptor___17.flags = 1U;
  tmp___17 = ldv__builtin_expect((long )descriptor___17.flags & 1L, 0L);
  if (tmp___17 != 0L) {
    __dynamic_dev_dbg(& descriptor___17, (struct device  const  *)hsotg->dev, "SetPortFeature - USB_PORT_FEAT_SUSPEND\n");
  } else {

  }
  if ((int )((unsigned short )hsotg->otg_port) != (int )windex) {
    goto error;
  } else {

  }
  dwc2_port_suspend(hsotg, (int )windex);
  goto ldv_35054;
  case 8: 
  descriptor___18.modname = "dwc2";
  descriptor___18.function = "dwc2_hcd_hub_control";
  descriptor___18.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
  descriptor___18.format = "SetPortFeature - USB_PORT_FEAT_POWER\n";
  descriptor___18.lineno = 1737U;
  descriptor___18.flags = 1U;
  tmp___18 = ldv__builtin_expect((long )descriptor___18.flags & 1L, 0L);
  if (tmp___18 != 0L) {
    __dynamic_dev_dbg(& descriptor___18, (struct device  const  *)hsotg->dev, "SetPortFeature - USB_PORT_FEAT_POWER\n");
  } else {

  }
  hprt0 = dwc2_read_hprt0(hsotg);
  hprt0 = hprt0 | 4096U;
  writel(hprt0, (void volatile   *)hsotg->regs + 1088U);
  goto ldv_35054;
  case 4: 
  hprt0 = dwc2_read_hprt0(hsotg);
  descriptor___19.modname = "dwc2";
  descriptor___19.function = "dwc2_hcd_hub_control";
  descriptor___19.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
  descriptor___19.format = "SetPortFeature - USB_PORT_FEAT_RESET\n";
  descriptor___19.lineno = 1746U;
  descriptor___19.flags = 1U;
  tmp___19 = ldv__builtin_expect((long )descriptor___19.flags & 1L, 0L);
  if (tmp___19 != 0L) {
    __dynamic_dev_dbg(& descriptor___19, (struct device  const  *)hsotg->dev, "SetPortFeature - USB_PORT_FEAT_RESET\n");
  } else {

  }
  pcgctl = readl((void const volatile   *)hsotg->regs + 3584U);
  pcgctl = pcgctl & 4294967262U;
  writel(pcgctl, (void volatile   *)hsotg->regs + 3584U);
  writel(0U, (void volatile   *)hsotg->regs + 3584U);
  hprt0 = dwc2_read_hprt0(hsotg);
  hprt0 = hprt0 & 4294967167U;
  tmp___21 = dwc2_hcd_is_b_host(hsotg);
  if (tmp___21 == 0) {
    hprt0 = hprt0 | 4352U;
    descriptor___20.modname = "dwc2";
    descriptor___20.function = "dwc2_hcd_hub_control";
    descriptor___20.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
    descriptor___20.format = "In host mode, hprt0=%08x\n";
    descriptor___20.lineno = 1765U;
    descriptor___20.flags = 1U;
    tmp___20 = ldv__builtin_expect((long )descriptor___20.flags & 1L, 0L);
    if (tmp___20 != 0L) {
      __dynamic_dev_dbg(& descriptor___20, (struct device  const  *)hsotg->dev, "In host mode, hprt0=%08x\n",
                        hprt0);
    } else {

    }
    writel(hprt0, (void volatile   *)hsotg->regs + 1088U);
  } else {

  }
  usleep_range(50000UL, 70000UL);
  hprt0 = hprt0 & 4294967039U;
  writel(hprt0, (void volatile   *)hsotg->regs + 1088U);
  hsotg->lx_state = 0;
  goto ldv_35054;
  case 22: 
  descriptor___21.modname = "dwc2";
  descriptor___21.function = "dwc2_hcd_hub_control";
  descriptor___21.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
  descriptor___21.format = "SetPortFeature - USB_PORT_FEAT_INDICATOR\n";
  descriptor___21.lineno = 1778U;
  descriptor___21.flags = 1U;
  tmp___22 = ldv__builtin_expect((long )descriptor___21.flags & 1L, 0L);
  if (tmp___22 != 0L) {
    __dynamic_dev_dbg(& descriptor___21, (struct device  const  *)hsotg->dev, "SetPortFeature - USB_PORT_FEAT_INDICATOR\n");
  } else {

  }
  goto ldv_35054;
  case 21: 
  hprt0 = dwc2_read_hprt0(hsotg);
  descriptor___22.modname = "dwc2";
  descriptor___22.function = "dwc2_hcd_hub_control";
  descriptor___22.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
  descriptor___22.format = "SetPortFeature - USB_PORT_FEAT_TEST\n";
  descriptor___22.lineno = 1785U;
  descriptor___22.flags = 1U;
  tmp___23 = ldv__builtin_expect((long )descriptor___22.flags & 1L, 0L);
  if (tmp___23 != 0L) {
    __dynamic_dev_dbg(& descriptor___22, (struct device  const  *)hsotg->dev, "SetPortFeature - USB_PORT_FEAT_TEST\n");
  } else {

  }
  hprt0 = hprt0 & 4294844415U;
  hprt0 = (u32 )(((int )windex >> 8) << 13) | hprt0;
  writel(hprt0, (void volatile   *)hsotg->regs + 1088U);
  goto ldv_35054;
  default: 
  retval = -22;
  dev_err((struct device  const  *)hsotg->dev, "SetPortFeature %1xh unknown or unsupported\n",
          (int )wvalue);
  goto ldv_35054;
  }
  ldv_35054: ;
  goto ldv_35015;
  default: ;
  error: 
  retval = -22;
  descriptor___23.modname = "dwc2";
  descriptor___23.function = "dwc2_hcd_hub_control";
  descriptor___23.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
  descriptor___23.format = "Unknown hub control request: %1xh wIndex: %1xh wValue: %1xh\n";
  descriptor___23.lineno = 1805U;
  descriptor___23.flags = 1U;
  tmp___24 = ldv__builtin_expect((long )descriptor___23.flags & 1L, 0L);
  if (tmp___24 != 0L) {
    __dynamic_dev_dbg(& descriptor___23, (struct device  const  *)hsotg->dev, "Unknown hub control request: %1xh wIndex: %1xh wValue: %1xh\n",
                      (int )typereq, (int )windex, (int )wvalue);
  } else {

  }
  goto ldv_35015;
  }
  ldv_35015: ;
  return (retval);
}
}
static int dwc2_hcd_is_status_changed(struct dwc2_hsotg *hsotg , int port ) 
{ 
  int retval ;
  struct _ddebug descriptor ;
  long tmp ;
  struct _ddebug descriptor___0 ;
  long tmp___0 ;
  struct _ddebug descriptor___1 ;
  long tmp___1 ;
  struct _ddebug descriptor___2 ;
  long tmp___2 ;
  struct _ddebug descriptor___3 ;
  long tmp___3 ;
  struct _ddebug descriptor___4 ;
  long tmp___4 ;

  {
  if (port != 1) {
    return (-22);
  } else {

  }
  retval = ((((unsigned int )*((unsigned char *)hsotg + 664UL) != 0U || (unsigned int )*((unsigned char *)hsotg + 664UL) != 0U) || (unsigned int )*((unsigned char *)hsotg + 664UL) != 0U) || (unsigned int )*((unsigned char *)hsotg + 664UL) != 0U) || (unsigned int )*((unsigned char *)hsotg + 664UL) != 0U;
  if (retval != 0) {
    descriptor.modname = "dwc2";
    descriptor.function = "dwc2_hcd_is_status_changed";
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
    descriptor.format = "DWC OTG HCD HUB STATUS DATA: Root port status changed\n";
    descriptor.lineno = 1827U;
    descriptor.flags = 1U;
    tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
    if (tmp != 0L) {
      __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "DWC OTG HCD HUB STATUS DATA: Root port status changed\n");
    } else {

    }
    descriptor___0.modname = "dwc2";
    descriptor___0.function = "dwc2_hcd_is_status_changed";
    descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
    descriptor___0.format = "  port_connect_status_change: %d\n";
    descriptor___0.lineno = 1829U;
    descriptor___0.flags = 1U;
    tmp___0 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
    if (tmp___0 != 0L) {
      __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)hsotg->dev, "  port_connect_status_change: %d\n",
                        (int )hsotg->flags.b.port_connect_status_change);
    } else {

    }
    descriptor___1.modname = "dwc2";
    descriptor___1.function = "dwc2_hcd_is_status_changed";
    descriptor___1.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
    descriptor___1.format = "  port_reset_change: %d\n";
    descriptor___1.lineno = 1831U;
    descriptor___1.flags = 1U;
    tmp___1 = ldv__builtin_expect((long )descriptor___1.flags & 1L, 0L);
    if (tmp___1 != 0L) {
      __dynamic_dev_dbg(& descriptor___1, (struct device  const  *)hsotg->dev, "  port_reset_change: %d\n",
                        (int )hsotg->flags.b.port_reset_change);
    } else {

    }
    descriptor___2.modname = "dwc2";
    descriptor___2.function = "dwc2_hcd_is_status_changed";
    descriptor___2.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
    descriptor___2.format = "  port_enable_change: %d\n";
    descriptor___2.lineno = 1833U;
    descriptor___2.flags = 1U;
    tmp___2 = ldv__builtin_expect((long )descriptor___2.flags & 1L, 0L);
    if (tmp___2 != 0L) {
      __dynamic_dev_dbg(& descriptor___2, (struct device  const  *)hsotg->dev, "  port_enable_change: %d\n",
                        (int )hsotg->flags.b.port_enable_change);
    } else {

    }
    descriptor___3.modname = "dwc2";
    descriptor___3.function = "dwc2_hcd_is_status_changed";
    descriptor___3.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
    descriptor___3.format = "  port_suspend_change: %d\n";
    descriptor___3.lineno = 1835U;
    descriptor___3.flags = 1U;
    tmp___3 = ldv__builtin_expect((long )descriptor___3.flags & 1L, 0L);
    if (tmp___3 != 0L) {
      __dynamic_dev_dbg(& descriptor___3, (struct device  const  *)hsotg->dev, "  port_suspend_change: %d\n",
                        (int )hsotg->flags.b.port_suspend_change);
    } else {

    }
    descriptor___4.modname = "dwc2";
    descriptor___4.function = "dwc2_hcd_is_status_changed";
    descriptor___4.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
    descriptor___4.format = "  port_over_current_change: %d\n";
    descriptor___4.lineno = 1837U;
    descriptor___4.flags = 1U;
    tmp___4 = ldv__builtin_expect((long )descriptor___4.flags & 1L, 0L);
    if (tmp___4 != 0L) {
      __dynamic_dev_dbg(& descriptor___4, (struct device  const  *)hsotg->dev, "  port_over_current_change: %d\n",
                        (int )hsotg->flags.b.port_over_current_change);
    } else {

    }
  } else {

  }
  return (retval);
}
}
int dwc2_hcd_get_frame_number(struct dwc2_hsotg *hsotg ) 
{ 
  u32 hfnum ;
  unsigned int tmp ;

  {
  tmp = readl((void const volatile   *)hsotg->regs + 1032U);
  hfnum = tmp;
  return ((int )hfnum & 65535);
}
}
int dwc2_hcd_is_b_host(struct dwc2_hsotg *hsotg ) 
{ 


  {
  return ((unsigned int )hsotg->op_state == 5U);
}
}
static struct dwc2_hcd_urb *dwc2_hcd_urb_alloc(struct dwc2_hsotg *hsotg , int iso_desc_count ,
                                               gfp_t mem_flags ) 
{ 
  struct dwc2_hcd_urb *urb ;
  u32 size ;
  void *tmp ;

  {
  size = (u32 )((unsigned long )iso_desc_count + 5UL) * 16U;
  tmp = kzalloc((size_t )size, mem_flags);
  urb = (struct dwc2_hcd_urb *)tmp;
  if ((unsigned long )urb != (unsigned long )((struct dwc2_hcd_urb *)0)) {
    urb->packet_count = (u32 )iso_desc_count;
  } else {

  }
  return (urb);
}
}
static void dwc2_hcd_urb_set_pipeinfo(struct dwc2_hsotg *hsotg , struct dwc2_hcd_urb *urb ,
                                      u8 dev_addr , u8 ep_num , u8 ep_type , u8 ep_dir ,
                                      u16 mps ) 
{ 
  struct _ddebug descriptor ;
  long tmp ;
  bool tmp___0 ;

  {
  tmp___0 = dbg_perio();
  if (((int )tmp___0 || (unsigned int )ep_type == 2U) || (unsigned int )ep_type == 0U) {
    descriptor.modname = "dwc2";
    descriptor.function = "dwc2_hcd_urb_set_pipeinfo";
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
    descriptor.format = "addr=%d, ep_num=%d, ep_dir=%1x, ep_type=%1x, mps=%d\n";
    descriptor.lineno = 1882U;
    descriptor.flags = 1U;
    tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
    if (tmp != 0L) {
      __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "addr=%d, ep_num=%d, ep_dir=%1x, ep_type=%1x, mps=%d\n",
                        (int )dev_addr, (int )ep_num, (int )ep_dir, (int )ep_type,
                        (int )mps);
    } else {

    }
  } else {

  }
  urb->pipe_info.dev_addr = dev_addr;
  urb->pipe_info.ep_num = ep_num;
  urb->pipe_info.pipe_type = ep_type;
  urb->pipe_info.pipe_dir = ep_dir;
  urb->pipe_info.mps = mps;
  return;
}
}
void dwc2_hcd_dump_state(struct dwc2_hsotg *hsotg ) 
{ 
  struct dwc2_host_chan *chan ;
  struct dwc2_hcd_urb *urb ;
  struct dwc2_qtd *qtd ;
  int num_channels ;
  u32 np_tx_status ;
  u32 p_tx_status ;
  int i ;
  struct _ddebug descriptor ;
  long tmp ;
  struct _ddebug descriptor___0 ;
  long tmp___0 ;
  struct _ddebug descriptor___1 ;
  long tmp___1 ;
  struct _ddebug descriptor___2 ;
  long tmp___2 ;
  struct _ddebug descriptor___3 ;
  long tmp___3 ;
  struct _ddebug descriptor___4 ;
  long tmp___4 ;
  struct _ddebug descriptor___5 ;
  long tmp___5 ;
  struct _ddebug descriptor___6 ;
  long tmp___6 ;
  struct _ddebug descriptor___7 ;
  long tmp___7 ;
  struct _ddebug descriptor___8 ;
  long tmp___8 ;
  struct _ddebug descriptor___9 ;
  long tmp___9 ;
  struct _ddebug descriptor___10 ;
  long tmp___10 ;
  struct _ddebug descriptor___11 ;
  long tmp___11 ;
  struct _ddebug descriptor___12 ;
  long tmp___12 ;
  struct _ddebug descriptor___13 ;
  long tmp___13 ;
  struct _ddebug descriptor___14 ;
  long tmp___14 ;
  struct _ddebug descriptor___15 ;
  long tmp___15 ;
  struct _ddebug descriptor___16 ;
  long tmp___16 ;
  struct _ddebug descriptor___17 ;
  long tmp___17 ;
  struct _ddebug descriptor___18 ;
  long tmp___18 ;
  struct _ddebug descriptor___19 ;
  long tmp___19 ;
  struct _ddebug descriptor___20 ;
  long tmp___20 ;
  struct _ddebug descriptor___21 ;
  long tmp___21 ;
  struct _ddebug descriptor___22 ;
  long tmp___22 ;
  struct _ddebug descriptor___23 ;
  long tmp___23 ;
  struct _ddebug descriptor___24 ;
  long tmp___24 ;
  u32 hfnum ;
  u32 hcchar ;
  u32 hctsiz ;
  u32 hcint ;
  u32 hcintmsk ;
  struct _ddebug descriptor___25 ;
  long tmp___25 ;
  struct _ddebug descriptor___26 ;
  long tmp___26 ;
  struct _ddebug descriptor___27 ;
  long tmp___27 ;
  struct _ddebug descriptor___28 ;
  long tmp___28 ;
  struct _ddebug descriptor___29 ;
  long tmp___29 ;
  struct list_head  const  *__mptr ;
  struct _ddebug descriptor___30 ;
  long tmp___30 ;
  struct _ddebug descriptor___31 ;
  long tmp___31 ;
  struct _ddebug descriptor___32 ;
  u8 tmp___32 ;
  u8 tmp___33 ;
  u8 tmp___34 ;
  long tmp___35 ;
  struct _ddebug descriptor___33 ;
  u16 tmp___36 ;
  long tmp___37 ;
  struct _ddebug descriptor___34 ;
  long tmp___38 ;
  struct _ddebug descriptor___35 ;
  long tmp___39 ;
  struct _ddebug descriptor___36 ;
  long tmp___40 ;
  struct _ddebug descriptor___37 ;
  long tmp___41 ;
  struct list_head  const  *__mptr___0 ;
  struct _ddebug descriptor___38 ;
  long tmp___42 ;
  struct _ddebug descriptor___39 ;
  long tmp___43 ;
  struct _ddebug descriptor___40 ;
  long tmp___44 ;
  struct _ddebug descriptor___41 ;
  long tmp___45 ;
  struct _ddebug descriptor___42 ;
  long tmp___46 ;
  struct _ddebug descriptor___43 ;
  long tmp___47 ;
  struct _ddebug descriptor___44 ;
  long tmp___48 ;
  struct _ddebug descriptor___45 ;
  long tmp___49 ;
  struct _ddebug descriptor___46 ;
  long tmp___50 ;
    klee_make_symbolic(&tmp___50, sizeof(long), "tmp___50");

  {
  num_channels = (hsotg->core_params)->host_channels;
  descriptor.modname = "dwc2";
  descriptor.function = "dwc2_hcd_dump_state";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
  descriptor.format = "\n";
  descriptor.lineno = 1906U;
  descriptor.flags = 1U;
  tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp != 0L) {
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "\n");
  } else {

  }
  descriptor___0.modname = "dwc2";
  descriptor___0.function = "dwc2_hcd_dump_state";
  descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
  descriptor___0.format = "************************************************************\n";
  descriptor___0.lineno = 1908U;
  descriptor___0.flags = 1U;
  tmp___0 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
  if (tmp___0 != 0L) {
    __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)hsotg->dev, "************************************************************\n");
  } else {

  }
  descriptor___1.modname = "dwc2";
  descriptor___1.function = "dwc2_hcd_dump_state";
  descriptor___1.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
  descriptor___1.format = "HCD State:\n";
  descriptor___1.lineno = 1909U;
  descriptor___1.flags = 1U;
  tmp___1 = ldv__builtin_expect((long )descriptor___1.flags & 1L, 0L);
  if (tmp___1 != 0L) {
    __dynamic_dev_dbg(& descriptor___1, (struct device  const  *)hsotg->dev, "HCD State:\n");
  } else {

  }
  descriptor___2.modname = "dwc2";
  descriptor___2.function = "dwc2_hcd_dump_state";
  descriptor___2.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
  descriptor___2.format = "  Num channels: %d\n";
  descriptor___2.lineno = 1910U;
  descriptor___2.flags = 1U;
  tmp___2 = ldv__builtin_expect((long )descriptor___2.flags & 1L, 0L);
  if (tmp___2 != 0L) {
    __dynamic_dev_dbg(& descriptor___2, (struct device  const  *)hsotg->dev, "  Num channels: %d\n",
                      num_channels);
  } else {

  }
  i = 0;
  goto ldv_35168;
  ldv_35167: 
  chan = hsotg->hc_ptr_array[i];
  descriptor___3.modname = "dwc2";
  descriptor___3.function = "dwc2_hcd_dump_state";
  descriptor___3.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
  descriptor___3.format = "  Channel %d:\n";
  descriptor___3.lineno = 1914U;
  descriptor___3.flags = 1U;
  tmp___3 = ldv__builtin_expect((long )descriptor___3.flags & 1L, 0L);
  if (tmp___3 != 0L) {
    __dynamic_dev_dbg(& descriptor___3, (struct device  const  *)hsotg->dev, "  Channel %d:\n",
                      i);
  } else {

  }
  descriptor___4.modname = "dwc2";
  descriptor___4.function = "dwc2_hcd_dump_state";
  descriptor___4.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
  descriptor___4.format = "    dev_addr: %d, ep_num: %d, ep_is_in: %d\n";
  descriptor___4.lineno = 1917U;
  descriptor___4.flags = 1U;
  tmp___4 = ldv__builtin_expect((long )descriptor___4.flags & 1L, 0L);
  if (tmp___4 != 0L) {
    __dynamic_dev_dbg(& descriptor___4, (struct device  const  *)hsotg->dev, "    dev_addr: %d, ep_num: %d, ep_is_in: %d\n",
                      (int )chan->dev_addr, (int )chan->ep_num, (int )chan->ep_is_in);
  } else {

  }
  descriptor___5.modname = "dwc2";
  descriptor___5.function = "dwc2_hcd_dump_state";
  descriptor___5.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
  descriptor___5.format = "    speed: %d\n";
  descriptor___5.lineno = 1918U;
  descriptor___5.flags = 1U;
  tmp___5 = ldv__builtin_expect((long )descriptor___5.flags & 1L, 0L);
  if (tmp___5 != 0L) {
    __dynamic_dev_dbg(& descriptor___5, (struct device  const  *)hsotg->dev, "    speed: %d\n",
                      (int )chan->speed);
  } else {

  }
  descriptor___6.modname = "dwc2";
  descriptor___6.function = "dwc2_hcd_dump_state";
  descriptor___6.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
  descriptor___6.format = "    ep_type: %d\n";
  descriptor___6.lineno = 1919U;
  descriptor___6.flags = 1U;
  tmp___6 = ldv__builtin_expect((long )descriptor___6.flags & 1L, 0L);
  if (tmp___6 != 0L) {
    __dynamic_dev_dbg(& descriptor___6, (struct device  const  *)hsotg->dev, "    ep_type: %d\n",
                      (int )chan->ep_type);
  } else {

  }
  descriptor___7.modname = "dwc2";
  descriptor___7.function = "dwc2_hcd_dump_state";
  descriptor___7.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
  descriptor___7.format = "    max_packet: %d\n";
  descriptor___7.lineno = 1920U;
  descriptor___7.flags = 1U;
  tmp___7 = ldv__builtin_expect((long )descriptor___7.flags & 1L, 0L);
  if (tmp___7 != 0L) {
    __dynamic_dev_dbg(& descriptor___7, (struct device  const  *)hsotg->dev, "    max_packet: %d\n",
                      (int )chan->max_packet);
  } else {

  }
  descriptor___8.modname = "dwc2";
  descriptor___8.function = "dwc2_hcd_dump_state";
  descriptor___8.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
  descriptor___8.format = "    data_pid_start: %d\n";
  descriptor___8.lineno = 1922U;
  descriptor___8.flags = 1U;
  tmp___8 = ldv__builtin_expect((long )descriptor___8.flags & 1L, 0L);
  if (tmp___8 != 0L) {
    __dynamic_dev_dbg(& descriptor___8, (struct device  const  *)hsotg->dev, "    data_pid_start: %d\n",
                      (int )chan->data_pid_start);
  } else {

  }
  descriptor___9.modname = "dwc2";
  descriptor___9.function = "dwc2_hcd_dump_state";
  descriptor___9.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
  descriptor___9.format = "    multi_count: %d\n";
  descriptor___9.lineno = 1923U;
  descriptor___9.flags = 1U;
  tmp___9 = ldv__builtin_expect((long )descriptor___9.flags & 1L, 0L);
  if (tmp___9 != 0L) {
    __dynamic_dev_dbg(& descriptor___9, (struct device  const  *)hsotg->dev, "    multi_count: %d\n",
                      (int )chan->multi_count);
  } else {

  }
  descriptor___10.modname = "dwc2";
  descriptor___10.function = "dwc2_hcd_dump_state";
  descriptor___10.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
  descriptor___10.format = "    xfer_started: %d\n";
  descriptor___10.lineno = 1925U;
  descriptor___10.flags = 1U;
  tmp___10 = ldv__builtin_expect((long )descriptor___10.flags & 1L, 0L);
  if (tmp___10 != 0L) {
    __dynamic_dev_dbg(& descriptor___10, (struct device  const  *)hsotg->dev, "    xfer_started: %d\n",
                      (int )chan->xfer_started);
  } else {

  }
  descriptor___11.modname = "dwc2";
  descriptor___11.function = "dwc2_hcd_dump_state";
  descriptor___11.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
  descriptor___11.format = "    xfer_buf: %p\n";
  descriptor___11.lineno = 1926U;
  descriptor___11.flags = 1U;
  tmp___11 = ldv__builtin_expect((long )descriptor___11.flags & 1L, 0L);
  if (tmp___11 != 0L) {
    __dynamic_dev_dbg(& descriptor___11, (struct device  const  *)hsotg->dev, "    xfer_buf: %p\n",
                      chan->xfer_buf);
  } else {

  }
  descriptor___12.modname = "dwc2";
  descriptor___12.function = "dwc2_hcd_dump_state";
  descriptor___12.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
  descriptor___12.format = "    xfer_dma: %08lx\n";
  descriptor___12.lineno = 1928U;
  descriptor___12.flags = 1U;
  tmp___12 = ldv__builtin_expect((long )descriptor___12.flags & 1L, 0L);
  if (tmp___12 != 0L) {
    __dynamic_dev_dbg(& descriptor___12, (struct device  const  *)hsotg->dev, "    xfer_dma: %08lx\n",
                      (unsigned long )chan->xfer_dma);
  } else {

  }
  descriptor___13.modname = "dwc2";
  descriptor___13.function = "dwc2_hcd_dump_state";
  descriptor___13.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
  descriptor___13.format = "    xfer_len: %d\n";
  descriptor___13.lineno = 1929U;
  descriptor___13.flags = 1U;
  tmp___13 = ldv__builtin_expect((long )descriptor___13.flags & 1L, 0L);
  if (tmp___13 != 0L) {
    __dynamic_dev_dbg(& descriptor___13, (struct device  const  *)hsotg->dev, "    xfer_len: %d\n",
                      chan->xfer_len);
  } else {

  }
  descriptor___14.modname = "dwc2";
  descriptor___14.function = "dwc2_hcd_dump_state";
  descriptor___14.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
  descriptor___14.format = "    xfer_count: %d\n";
  descriptor___14.lineno = 1930U;
  descriptor___14.flags = 1U;
  tmp___14 = ldv__builtin_expect((long )descriptor___14.flags & 1L, 0L);
  if (tmp___14 != 0L) {
    __dynamic_dev_dbg(& descriptor___14, (struct device  const  *)hsotg->dev, "    xfer_count: %d\n",
                      chan->xfer_count);
  } else {

  }
  descriptor___15.modname = "dwc2";
  descriptor___15.function = "dwc2_hcd_dump_state";
  descriptor___15.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
  descriptor___15.format = "    halt_on_queue: %d\n";
  descriptor___15.lineno = 1932U;
  descriptor___15.flags = 1U;
  tmp___15 = ldv__builtin_expect((long )descriptor___15.flags & 1L, 0L);
  if (tmp___15 != 0L) {
    __dynamic_dev_dbg(& descriptor___15, (struct device  const  *)hsotg->dev, "    halt_on_queue: %d\n",
                      (int )chan->halt_on_queue);
  } else {

  }
  descriptor___16.modname = "dwc2";
  descriptor___16.function = "dwc2_hcd_dump_state";
  descriptor___16.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
  descriptor___16.format = "    halt_pending: %d\n";
  descriptor___16.lineno = 1934U;
  descriptor___16.flags = 1U;
  tmp___16 = ldv__builtin_expect((long )descriptor___16.flags & 1L, 0L);
  if (tmp___16 != 0L) {
    __dynamic_dev_dbg(& descriptor___16, (struct device  const  *)hsotg->dev, "    halt_pending: %d\n",
                      (int )chan->halt_pending);
  } else {

  }
  descriptor___17.modname = "dwc2";
  descriptor___17.function = "dwc2_hcd_dump_state";
  descriptor___17.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
  descriptor___17.format = "    halt_status: %d\n";
  descriptor___17.lineno = 1935U;
  descriptor___17.flags = 1U;
  tmp___17 = ldv__builtin_expect((long )descriptor___17.flags & 1L, 0L);
  if (tmp___17 != 0L) {
    __dynamic_dev_dbg(& descriptor___17, (struct device  const  *)hsotg->dev, "    halt_status: %d\n",
                      (unsigned int )chan->halt_status);
  } else {

  }
  descriptor___18.modname = "dwc2";
  descriptor___18.function = "dwc2_hcd_dump_state";
  descriptor___18.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
  descriptor___18.format = "    do_split: %d\n";
  descriptor___18.lineno = 1936U;
  descriptor___18.flags = 1U;
  tmp___18 = ldv__builtin_expect((long )descriptor___18.flags & 1L, 0L);
  if (tmp___18 != 0L) {
    __dynamic_dev_dbg(& descriptor___18, (struct device  const  *)hsotg->dev, "    do_split: %d\n",
                      (int )chan->do_split);
  } else {

  }
  descriptor___19.modname = "dwc2";
  descriptor___19.function = "dwc2_hcd_dump_state";
  descriptor___19.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
  descriptor___19.format = "    complete_split: %d\n";
  descriptor___19.lineno = 1938U;
  descriptor___19.flags = 1U;
  tmp___19 = ldv__builtin_expect((long )descriptor___19.flags & 1L, 0L);
  if (tmp___19 != 0L) {
    __dynamic_dev_dbg(& descriptor___19, (struct device  const  *)hsotg->dev, "    complete_split: %d\n",
                      (int )chan->complete_split);
  } else {

  }
  descriptor___20.modname = "dwc2";
  descriptor___20.function = "dwc2_hcd_dump_state";
  descriptor___20.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
  descriptor___20.format = "    hub_addr: %d\n";
  descriptor___20.lineno = 1939U;
  descriptor___20.flags = 1U;
  tmp___20 = ldv__builtin_expect((long )descriptor___20.flags & 1L, 0L);
  if (tmp___20 != 0L) {
    __dynamic_dev_dbg(& descriptor___20, (struct device  const  *)hsotg->dev, "    hub_addr: %d\n",
                      (int )chan->hub_addr);
  } else {

  }
  descriptor___21.modname = "dwc2";
  descriptor___21.function = "dwc2_hcd_dump_state";
  descriptor___21.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
  descriptor___21.format = "    hub_port: %d\n";
  descriptor___21.lineno = 1940U;
  descriptor___21.flags = 1U;
  tmp___21 = ldv__builtin_expect((long )descriptor___21.flags & 1L, 0L);
  if (tmp___21 != 0L) {
    __dynamic_dev_dbg(& descriptor___21, (struct device  const  *)hsotg->dev, "    hub_port: %d\n",
                      (int )chan->hub_port);
  } else {

  }
  descriptor___22.modname = "dwc2";
  descriptor___22.function = "dwc2_hcd_dump_state";
  descriptor___22.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
  descriptor___22.format = "    xact_pos: %d\n";
  descriptor___22.lineno = 1941U;
  descriptor___22.flags = 1U;
  tmp___22 = ldv__builtin_expect((long )descriptor___22.flags & 1L, 0L);
  if (tmp___22 != 0L) {
    __dynamic_dev_dbg(& descriptor___22, (struct device  const  *)hsotg->dev, "    xact_pos: %d\n",
                      (int )chan->xact_pos);
  } else {

  }
  descriptor___23.modname = "dwc2";
  descriptor___23.function = "dwc2_hcd_dump_state";
  descriptor___23.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
  descriptor___23.format = "    requests: %d\n";
  descriptor___23.lineno = 1942U;
  descriptor___23.flags = 1U;
  tmp___23 = ldv__builtin_expect((long )descriptor___23.flags & 1L, 0L);
  if (tmp___23 != 0L) {
    __dynamic_dev_dbg(& descriptor___23, (struct device  const  *)hsotg->dev, "    requests: %d\n",
                      (int )chan->requests);
  } else {

  }
  descriptor___24.modname = "dwc2";
  descriptor___24.function = "dwc2_hcd_dump_state";
  descriptor___24.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
  descriptor___24.format = "    qh: %p\n";
  descriptor___24.lineno = 1943U;
  descriptor___24.flags = 1U;
  tmp___24 = ldv__builtin_expect((long )descriptor___24.flags & 1L, 0L);
  if (tmp___24 != 0L) {
    __dynamic_dev_dbg(& descriptor___24, (struct device  const  *)hsotg->dev, "    qh: %p\n",
                      chan->qh);
  } else {

  }
  if ((unsigned int )chan->xfer_started != 0U) {
    hfnum = readl((void const volatile   *)hsotg->regs + 1032U);
    hcchar = readl((void const volatile   *)hsotg->regs + (unsigned long )((i + 40) * 32));
    hctsiz = readl((void const volatile   *)hsotg->regs + (unsigned long )(i * 32 + 1296));
    hcint = readl((void const volatile   *)hsotg->regs + (unsigned long )(i * 32 + 1288));
    hcintmsk = readl((void const volatile   *)hsotg->regs + (unsigned long )(i * 32 + 1292));
    descriptor___25.modname = "dwc2";
    descriptor___25.function = "dwc2_hcd_dump_state";
    descriptor___25.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
    descriptor___25.format = "    hfnum: 0x%08x\n";
    descriptor___25.lineno = 1953U;
    descriptor___25.flags = 1U;
    tmp___25 = ldv__builtin_expect((long )descriptor___25.flags & 1L, 0L);
    if (tmp___25 != 0L) {
      __dynamic_dev_dbg(& descriptor___25, (struct device  const  *)hsotg->dev, "    hfnum: 0x%08x\n",
                        hfnum);
    } else {

    }
    descriptor___26.modname = "dwc2";
    descriptor___26.function = "dwc2_hcd_dump_state";
    descriptor___26.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
    descriptor___26.format = "    hcchar: 0x%08x\n";
    descriptor___26.lineno = 1954U;
    descriptor___26.flags = 1U;
    tmp___26 = ldv__builtin_expect((long )descriptor___26.flags & 1L, 0L);
    if (tmp___26 != 0L) {
      __dynamic_dev_dbg(& descriptor___26, (struct device  const  *)hsotg->dev, "    hcchar: 0x%08x\n",
                        hcchar);
    } else {

    }
    descriptor___27.modname = "dwc2";
    descriptor___27.function = "dwc2_hcd_dump_state";
    descriptor___27.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
    descriptor___27.format = "    hctsiz: 0x%08x\n";
    descriptor___27.lineno = 1955U;
    descriptor___27.flags = 1U;
    tmp___27 = ldv__builtin_expect((long )descriptor___27.flags & 1L, 0L);
    if (tmp___27 != 0L) {
      __dynamic_dev_dbg(& descriptor___27, (struct device  const  *)hsotg->dev, "    hctsiz: 0x%08x\n",
                        hctsiz);
    } else {

    }
    descriptor___28.modname = "dwc2";
    descriptor___28.function = "dwc2_hcd_dump_state";
    descriptor___28.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
    descriptor___28.format = "    hcint: 0x%08x\n";
    descriptor___28.lineno = 1956U;
    descriptor___28.flags = 1U;
    tmp___28 = ldv__builtin_expect((long )descriptor___28.flags & 1L, 0L);
    if (tmp___28 != 0L) {
      __dynamic_dev_dbg(& descriptor___28, (struct device  const  *)hsotg->dev, "    hcint: 0x%08x\n",
                        hcint);
    } else {

    }
    descriptor___29.modname = "dwc2";
    descriptor___29.function = "dwc2_hcd_dump_state";
    descriptor___29.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
    descriptor___29.format = "    hcintmsk: 0x%08x\n";
    descriptor___29.lineno = 1957U;
    descriptor___29.flags = 1U;
    tmp___29 = ldv__builtin_expect((long )descriptor___29.flags & 1L, 0L);
    if (tmp___29 != 0L) {
      __dynamic_dev_dbg(& descriptor___29, (struct device  const  *)hsotg->dev, "    hcintmsk: 0x%08x\n",
                        hcintmsk);
    } else {

    }
  } else {

  }
  if ((unsigned int )chan->xfer_started == 0U || (unsigned long )chan->qh == (unsigned long )((struct dwc2_qh *)0)) {
    goto ldv_35151;
  } else {

  }
  __mptr = (struct list_head  const  *)(chan->qh)->qtd_list.next;
  qtd = (struct dwc2_qtd *)__mptr + 0xffffffffffffffd8UL;
  goto ldv_35166;
  ldv_35165: ;
  if ((unsigned int )qtd->in_process == 0U) {
    goto ldv_35156;
  } else {

  }
  urb = qtd->urb;
  descriptor___30.modname = "dwc2";
  descriptor___30.function = "dwc2_hcd_dump_state";
  descriptor___30.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
  descriptor___30.format = "    URB Info:\n";
  descriptor___30.lineno = 1967U;
  descriptor___30.flags = 1U;
  tmp___30 = ldv__builtin_expect((long )descriptor___30.flags & 1L, 0L);
  if (tmp___30 != 0L) {
    __dynamic_dev_dbg(& descriptor___30, (struct device  const  *)hsotg->dev, "    URB Info:\n");
  } else {

  }
  descriptor___31.modname = "dwc2";
  descriptor___31.function = "dwc2_hcd_dump_state";
  descriptor___31.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
  descriptor___31.format = "      qtd: %p, urb: %p\n";
  descriptor___31.lineno = 1969U;
  descriptor___31.flags = 1U;
  tmp___31 = ldv__builtin_expect((long )descriptor___31.flags & 1L, 0L);
  if (tmp___31 != 0L) {
    __dynamic_dev_dbg(& descriptor___31, (struct device  const  *)hsotg->dev, "      qtd: %p, urb: %p\n",
                      qtd, urb);
  } else {

  }
  if ((unsigned long )urb != (unsigned long )((struct dwc2_hcd_urb *)0)) {
    descriptor___32.modname = "dwc2";
    descriptor___32.function = "dwc2_hcd_dump_state";
    descriptor___32.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
    descriptor___32.format = "      Dev: %d, EP: %d %s\n";
    descriptor___32.lineno = 1976U;
    descriptor___32.flags = 1U;
    tmp___35 = ldv__builtin_expect((long )descriptor___32.flags & 1L, 0L);
    if (tmp___35 != 0L) {
      tmp___32 = dwc2_hcd_is_pipe_in(& urb->pipe_info);
      tmp___33 = dwc2_hcd_get_ep_num(& urb->pipe_info);
      tmp___34 = dwc2_hcd_get_dev_addr(& urb->pipe_info);
      __dynamic_dev_dbg(& descriptor___32, (struct device  const  *)hsotg->dev, "      Dev: %d, EP: %d %s\n",
                        (int )tmp___34, (int )tmp___33, (unsigned int )tmp___32 != 0U ? (char *)"IN" : (char *)"OUT");
    } else {

    }
    descriptor___33.modname = "dwc2";
    descriptor___33.function = "dwc2_hcd_dump_state";
    descriptor___33.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
    descriptor___33.format = "      Max packet size: %d\n";
    descriptor___33.lineno = 1979U;
    descriptor___33.flags = 1U;
    tmp___37 = ldv__builtin_expect((long )descriptor___33.flags & 1L, 0L);
    if (tmp___37 != 0L) {
      tmp___36 = dwc2_hcd_get_mps(& urb->pipe_info);
      __dynamic_dev_dbg(& descriptor___33, (struct device  const  *)hsotg->dev, "      Max packet size: %d\n",
                        (int )tmp___36);
    } else {

    }
    descriptor___34.modname = "dwc2";
    descriptor___34.function = "dwc2_hcd_dump_state";
    descriptor___34.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
    descriptor___34.format = "      transfer_buffer: %p\n";
    descriptor___34.lineno = 1982U;
    descriptor___34.flags = 1U;
    tmp___38 = ldv__builtin_expect((long )descriptor___34.flags & 1L, 0L);
    if (tmp___38 != 0L) {
      __dynamic_dev_dbg(& descriptor___34, (struct device  const  *)hsotg->dev, "      transfer_buffer: %p\n",
                        urb->buf);
    } else {

    }
    descriptor___35.modname = "dwc2";
    descriptor___35.function = "dwc2_hcd_dump_state";
    descriptor___35.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
    descriptor___35.format = "      transfer_dma: %08lx\n";
    descriptor___35.lineno = 1985U;
    descriptor___35.flags = 1U;
    tmp___39 = ldv__builtin_expect((long )descriptor___35.flags & 1L, 0L);
    if (tmp___39 != 0L) {
      __dynamic_dev_dbg(& descriptor___35, (struct device  const  *)hsotg->dev, "      transfer_dma: %08lx\n",
                        (unsigned long )urb->dma);
    } else {

    }
    descriptor___36.modname = "dwc2";
    descriptor___36.function = "dwc2_hcd_dump_state";
    descriptor___36.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
    descriptor___36.format = "      transfer_buffer_length: %d\n";
    descriptor___36.lineno = 1988U;
    descriptor___36.flags = 1U;
    tmp___40 = ldv__builtin_expect((long )descriptor___36.flags & 1L, 0L);
    if (tmp___40 != 0L) {
      __dynamic_dev_dbg(& descriptor___36, (struct device  const  *)hsotg->dev, "      transfer_buffer_length: %d\n",
                        urb->length);
    } else {

    }
    descriptor___37.modname = "dwc2";
    descriptor___37.function = "dwc2_hcd_dump_state";
    descriptor___37.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
    descriptor___37.format = "      actual_length: %d\n";
    descriptor___37.lineno = 1990U;
    descriptor___37.flags = 1U;
    tmp___41 = ldv__builtin_expect((long )descriptor___37.flags & 1L, 0L);
    if (tmp___41 != 0L) {
      __dynamic_dev_dbg(& descriptor___37, (struct device  const  *)hsotg->dev, "      actual_length: %d\n",
                        urb->actual_length);
    } else {

    }
  } else {

  }
  __mptr___0 = (struct list_head  const  *)qtd->qtd_list_entry.next;
  qtd = (struct dwc2_qtd *)__mptr___0 + 0xffffffffffffffd8UL;
  ldv_35166: ;
  if ((unsigned long )(& qtd->qtd_list_entry) != (unsigned long )(& (chan->qh)->qtd_list)) {
    goto ldv_35165;
  } else {

  }
  ldv_35156: ;
  ldv_35151: 
  i = i + 1;
  ldv_35168: ;
  if (i < num_channels) {
    goto ldv_35167;
  } else {

  }
  descriptor___38.modname = "dwc2";
  descriptor___38.function = "dwc2_hcd_dump_state";
  descriptor___38.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
  descriptor___38.format = "  non_periodic_channels: %d\n";
  descriptor___38.lineno = 1996U;
  descriptor___38.flags = 1U;
  tmp___42 = ldv__builtin_expect((long )descriptor___38.flags & 1L, 0L);
  if (tmp___42 != 0L) {
    __dynamic_dev_dbg(& descriptor___38, (struct device  const  *)hsotg->dev, "  non_periodic_channels: %d\n",
                      hsotg->non_periodic_channels);
  } else {

  }
  descriptor___39.modname = "dwc2";
  descriptor___39.function = "dwc2_hcd_dump_state";
  descriptor___39.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
  descriptor___39.format = "  periodic_channels: %d\n";
  descriptor___39.lineno = 1998U;
  descriptor___39.flags = 1U;
  tmp___43 = ldv__builtin_expect((long )descriptor___39.flags & 1L, 0L);
  if (tmp___43 != 0L) {
    __dynamic_dev_dbg(& descriptor___39, (struct device  const  *)hsotg->dev, "  periodic_channels: %d\n",
                      hsotg->periodic_channels);
  } else {

  }
  descriptor___40.modname = "dwc2";
  descriptor___40.function = "dwc2_hcd_dump_state";
  descriptor___40.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
  descriptor___40.format = "  periodic_usecs: %d\n";
  descriptor___40.lineno = 1999U;
  descriptor___40.flags = 1U;
  tmp___44 = ldv__builtin_expect((long )descriptor___40.flags & 1L, 0L);
  if (tmp___44 != 0L) {
    __dynamic_dev_dbg(& descriptor___40, (struct device  const  *)hsotg->dev, "  periodic_usecs: %d\n",
                      (int )hsotg->periodic_usecs);
  } else {

  }
  np_tx_status = readl((void const volatile   *)hsotg->regs + 44U);
  descriptor___41.modname = "dwc2";
  descriptor___41.function = "dwc2_hcd_dump_state";
  descriptor___41.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
  descriptor___41.format = "  NP Tx Req Queue Space Avail: %d\n";
  descriptor___41.lineno = 2002U;
  descriptor___41.flags = 1U;
  tmp___45 = ldv__builtin_expect((long )descriptor___41.flags & 1L, 0L);
  if (tmp___45 != 0L) {
    __dynamic_dev_dbg(& descriptor___41, (struct device  const  *)hsotg->dev, "  NP Tx Req Queue Space Avail: %d\n",
                      (np_tx_status & 16711680U) >> 16);
  } else {

  }
  descriptor___42.modname = "dwc2";
  descriptor___42.function = "dwc2_hcd_dump_state";
  descriptor___42.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
  descriptor___42.format = "  NP Tx FIFO Space Avail: %d\n";
  descriptor___42.lineno = 2004U;
  descriptor___42.flags = 1U;
  tmp___46 = ldv__builtin_expect((long )descriptor___42.flags & 1L, 0L);
  if (tmp___46 != 0L) {
    __dynamic_dev_dbg(& descriptor___42, (struct device  const  *)hsotg->dev, "  NP Tx FIFO Space Avail: %d\n",
                      np_tx_status & 65535U);
  } else {

  }
  p_tx_status = readl((void const volatile   *)hsotg->regs + 1040U);
  descriptor___43.modname = "dwc2";
  descriptor___43.function = "dwc2_hcd_dump_state";
  descriptor___43.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
  descriptor___43.format = "  P Tx Req Queue Space Avail: %d\n";
  descriptor___43.lineno = 2007U;
  descriptor___43.flags = 1U;
  tmp___47 = ldv__builtin_expect((long )descriptor___43.flags & 1L, 0L);
  if (tmp___47 != 0L) {
    __dynamic_dev_dbg(& descriptor___43, (struct device  const  *)hsotg->dev, "  P Tx Req Queue Space Avail: %d\n",
                      (p_tx_status & 16711680U) >> 16);
  } else {

  }
  descriptor___44.modname = "dwc2";
  descriptor___44.function = "dwc2_hcd_dump_state";
  descriptor___44.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
  descriptor___44.format = "  P Tx FIFO Space Avail: %d\n";
  descriptor___44.lineno = 2009U;
  descriptor___44.flags = 1U;
  tmp___48 = ldv__builtin_expect((long )descriptor___44.flags & 1L, 0L);
  if (tmp___48 != 0L) {
    __dynamic_dev_dbg(& descriptor___44, (struct device  const  *)hsotg->dev, "  P Tx FIFO Space Avail: %d\n",
                      p_tx_status & 65535U);
  } else {

  }
  dwc2_hcd_dump_frrem(hsotg);
  dwc2_dump_global_registers(hsotg);
  dwc2_dump_host_registers(hsotg);
  descriptor___45.modname = "dwc2";
  descriptor___45.function = "dwc2_hcd_dump_state";
  descriptor___45.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
  descriptor___45.format = "************************************************************\n";
  descriptor___45.lineno = 2014U;
  descriptor___45.flags = 1U;
  tmp___49 = ldv__builtin_expect((long )descriptor___45.flags & 1L, 0L);
  if (tmp___49 != 0L) {
    __dynamic_dev_dbg(& descriptor___45, (struct device  const  *)hsotg->dev, "************************************************************\n");
  } else {

  }
  descriptor___46.modname = "dwc2";
  descriptor___46.function = "dwc2_hcd_dump_state";
  descriptor___46.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
  descriptor___46.format = "\n";
  descriptor___46.lineno = 2015U;
  descriptor___46.flags = 1U;
  tmp___50 = ldv__builtin_expect((long )descriptor___46.flags & 1L, 0L);
  if (tmp___50 != 0L) {
    __dynamic_dev_dbg(& descriptor___46, (struct device  const  *)hsotg->dev, "\n");
  } else {

  }
  return;
}
}
void dwc2_hcd_dump_frrem(struct dwc2_hsotg *hsotg ) 
{ 


  {
  return;
}
}
static struct dwc2_hsotg *dwc2_hcd_to_hsotg(struct usb_hcd *hcd ) 
{ 
  struct wrapper_priv_data *p ;

  {
  p = (struct wrapper_priv_data *)(& hcd->hcd_priv);
  return (p->hsotg);
}
}
static int _dwc2_hcd_start(struct usb_hcd *hcd ) ;
void dwc2_host_start(struct dwc2_hsotg *hsotg ) 
{ 
  struct usb_hcd *hcd ;
  struct usb_hcd *tmp ;
  int tmp___0 ;

  {
  tmp = dwc2_hsotg_to_hcd(hsotg);
  hcd = tmp;
  tmp___0 = dwc2_hcd_is_b_host(hsotg);
  hcd->self.is_b_host = (unsigned char )tmp___0;
  _dwc2_hcd_start(hcd);
  return;
}
}
void dwc2_host_disconnect(struct dwc2_hsotg *hsotg ) 
{ 
  struct usb_hcd *hcd ;
  struct usb_hcd *tmp ;

  {
  tmp = dwc2_hsotg_to_hcd(hsotg);
  hcd = tmp;
  hcd->self.is_b_host = 0U;
  return;
}
}
void dwc2_host_hub_info(struct dwc2_hsotg *hsotg , void *context , int *hub_addr ,
                        int *hub_port ) 
{ 
  struct urb *urb ;

  {
  urb = (struct urb *)context;
  if ((unsigned long )(urb->dev)->tt != (unsigned long )((struct usb_tt *)0)) {
    *hub_addr = (((urb->dev)->tt)->hub)->devnum;
  } else {
    *hub_addr = 0;
  }
  *hub_port = (urb->dev)->ttport;
  return;
}
}
int dwc2_host_get_speed(struct dwc2_hsotg *hsotg , void *context ) 
{ 
  struct urb *urb ;

  {
  urb = (struct urb *)context;
  return ((int )(urb->dev)->speed);
}
}
static void dwc2_allocate_bus_bandwidth(struct usb_hcd *hcd , u16 bw , struct urb *urb ) 
{ 
  struct usb_bus *bus ;
  struct usb_bus *tmp ;

  {
  tmp = hcd_to_bus(hcd);
  bus = tmp;
  if (urb->interval != 0) {
    bus->bandwidth_allocated = bus->bandwidth_allocated + (int )bw / urb->interval;
  } else {

  }
  if (urb->pipe >> 30 == 0U) {
    bus->bandwidth_isoc_reqs = bus->bandwidth_isoc_reqs + 1;
  } else {
    bus->bandwidth_int_reqs = bus->bandwidth_int_reqs + 1;
  }
  return;
}
}
static void dwc2_free_bus_bandwidth(struct usb_hcd *hcd , u16 bw , struct urb *urb ) 
{ 
  struct usb_bus *bus ;
  struct usb_bus *tmp ;

  {
  tmp = hcd_to_bus(hcd);
  bus = tmp;
  if (urb->interval != 0) {
    bus->bandwidth_allocated = bus->bandwidth_allocated - (int )bw / urb->interval;
  } else {

  }
  if (urb->pipe >> 30 == 0U) {
    bus->bandwidth_isoc_reqs = bus->bandwidth_isoc_reqs - 1;
  } else {
    bus->bandwidth_int_reqs = bus->bandwidth_int_reqs - 1;
  }
  return;
}
}
void dwc2_host_complete(struct dwc2_hsotg *hsotg , struct dwc2_qtd *qtd , int status ) 
{ 
  struct urb *urb ;
  int i ;
  struct _ddebug descriptor ;
  long tmp ;
  struct _ddebug descriptor___0 ;
  long tmp___0 ;
  struct _ddebug descriptor___1 ;
  long tmp___1 ;
  struct _ddebug descriptor___2 ;
  long tmp___2 ;
  bool tmp___3 ;
  struct _ddebug descriptor___3 ;
  long tmp___4 ;
  bool tmp___5 ;
  u32 tmp___6 ;
  u32 tmp___7 ;
  struct usb_host_endpoint *ep ;
  u16 tmp___8 ;
  struct usb_hcd *tmp___9 ;
  struct usb_hcd *tmp___10 ;
  struct usb_hcd *tmp___11 ;

  {
  if ((unsigned long )qtd == (unsigned long )((struct dwc2_qtd *)0)) {
    descriptor.modname = "dwc2";
    descriptor.function = "dwc2_host_complete";
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
    descriptor.format = "## %s: qtd is NULL ##\n";
    descriptor.lineno = 2176U;
    descriptor.flags = 1U;
    tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
    if (tmp != 0L) {
      __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "## %s: qtd is NULL ##\n",
                        "dwc2_host_complete");
    } else {

    }
    return;
  } else {

  }
  if ((unsigned long )qtd->urb == (unsigned long )((struct dwc2_hcd_urb *)0)) {
    descriptor___0.modname = "dwc2";
    descriptor___0.function = "dwc2_host_complete";
    descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
    descriptor___0.format = "## %s: qtd->urb is NULL ##\n";
    descriptor___0.lineno = 2181U;
    descriptor___0.flags = 1U;
    tmp___0 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
    if (tmp___0 != 0L) {
      __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)hsotg->dev, "## %s: qtd->urb is NULL ##\n",
                        "dwc2_host_complete");
    } else {

    }
    return;
  } else {

  }
  urb = (struct urb *)(qtd->urb)->priv;
  if ((unsigned long )urb == (unsigned long )((struct urb *)0)) {
    descriptor___1.modname = "dwc2";
    descriptor___1.function = "dwc2_host_complete";
    descriptor___1.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
    descriptor___1.format = "## %s: urb->priv is NULL ##\n";
    descriptor___1.lineno = 2187U;
    descriptor___1.flags = 1U;
    tmp___1 = ldv__builtin_expect((long )descriptor___1.flags & 1L, 0L);
    if (tmp___1 != 0L) {
      __dynamic_dev_dbg(& descriptor___1, (struct device  const  *)hsotg->dev, "## %s: urb->priv is NULL ##\n",
                        "dwc2_host_complete");
    } else {

    }
    return;
  } else {

  }
  urb->actual_length = dwc2_hcd_urb_get_actual_length(qtd->urb);
  tmp___3 = dbg_urb(urb);
  if ((int )tmp___3) {
    descriptor___2.modname = "dwc2";
    descriptor___2.function = "dwc2_host_complete";
    descriptor___2.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
    descriptor___2.format = "%s: urb %p device %d ep %d-%s status %d actual %d\n";
    descriptor___2.lineno = 2199U;
    descriptor___2.flags = 1U;
    tmp___2 = ldv__builtin_expect((long )descriptor___2.flags & 1L, 0L);
    if (tmp___2 != 0L) {
      __dynamic_dev_dbg(& descriptor___2, (struct device  const  *)hsotg->dev, "%s: urb %p device %d ep %d-%s status %d actual %d\n",
                        "dwc2_host_complete", urb, (urb->pipe >> 8) & 127U, (urb->pipe >> 15) & 15U,
                        (urb->pipe & 128U) != 0U ? (char *)"IN" : (char *)"OUT", status,
                        urb->actual_length);
    } else {

    }
  } else {

  }
  if (urb->pipe >> 30 == 0U) {
    tmp___5 = dbg_perio();
    if ((int )tmp___5) {
      i = 0;
      goto ldv_35236;
      ldv_35235: 
      descriptor___3.modname = "dwc2";
      descriptor___3.function = "dwc2_host_complete";
      descriptor___3.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
      descriptor___3.format = " ISO Desc %d status %d\n";
      descriptor___3.lineno = 2204U;
      descriptor___3.flags = 1U;
      tmp___4 = ldv__builtin_expect((long )descriptor___3.flags & 1L, 0L);
      if (tmp___4 != 0L) {
        __dynamic_dev_dbg(& descriptor___3, (struct device  const  *)hsotg->dev, " ISO Desc %d status %d\n",
                          i, urb->iso_frame_desc[i].status);
      } else {

      }
      i = i + 1;
      ldv_35236: ;
      if (urb->number_of_packets > i) {
        goto ldv_35235;
      } else {

      }

    } else {

    }
  } else {

  }
  if (urb->pipe >> 30 == 0U) {
    tmp___6 = dwc2_hcd_urb_get_error_count(qtd->urb);
    urb->error_count = (int )tmp___6;
    i = 0;
    goto ldv_35239;
    ldv_35238: 
    urb->iso_frame_desc[i].actual_length = dwc2_hcd_urb_get_iso_desc_actual_length(qtd->urb,
                                                                                   i);
    tmp___7 = dwc2_hcd_urb_get_iso_desc_status(qtd->urb, i);
    urb->iso_frame_desc[i].status = (int )tmp___7;
    i = i + 1;
    ldv_35239: ;
    if (urb->number_of_packets > i) {
      goto ldv_35238;
    } else {

    }

  } else {

  }
  urb->status = status;
  if (status == 0) {
    if ((int )urb->transfer_flags & 1 && urb->actual_length < urb->transfer_buffer_length) {
      urb->status = -121;
    } else {

    }
  } else {

  }
  if (urb->pipe >> 30 == 0U || urb->pipe >> 30 == 1U) {
    ep = urb->ep;
    if ((unsigned long )ep != (unsigned long )((struct usb_host_endpoint *)0)) {
      tmp___8 = dwc2_hcd_get_ep_bandwidth(hsotg, ep);
      tmp___9 = dwc2_hsotg_to_hcd(hsotg);
      dwc2_free_bus_bandwidth(tmp___9, (int )tmp___8, urb);
    } else {

    }
  } else {

  }
  tmp___10 = dwc2_hsotg_to_hcd(hsotg);
  usb_hcd_unlink_urb_from_ep(tmp___10, urb);
  urb->hcpriv = (void *)0;
  kfree((void const   *)qtd->urb);
  qtd->urb = (struct dwc2_hcd_urb *)0;
  spin_unlock(& hsotg->lock);
  tmp___11 = dwc2_hsotg_to_hcd(hsotg);
  usb_hcd_giveback_urb(tmp___11, urb, status);
  spin_lock(& hsotg->lock);
  return;
}
}
static void dwc2_hcd_start_func(struct work_struct *work ) 
{ 
  struct dwc2_hsotg *hsotg ;
  struct work_struct  const  *__mptr ;
  struct _ddebug descriptor ;
  long tmp ;

  {
  __mptr = (struct work_struct  const  *)work;
  hsotg = (struct dwc2_hsotg *)__mptr + 0xfffffffffffffc18UL;
  descriptor.modname = "dwc2";
  descriptor.function = "dwc2_hcd_start_func";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
  descriptor.format = "%s() %p\n";
  descriptor.lineno = 2253U;
  descriptor.flags = 1U;
  tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp != 0L) {
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "%s() %p\n",
                      "dwc2_hcd_start_func", hsotg);
  } else {

  }
  dwc2_host_start(hsotg);
  return;
}
}
static void dwc2_hcd_reset_func(struct work_struct *work ) 
{ 
  struct dwc2_hsotg *hsotg ;
  struct work_struct  const  *__mptr ;
  u32 hprt0 ;
  struct _ddebug descriptor ;
  long tmp ;

  {
  __mptr = (struct work_struct  const  *)work;
  hsotg = (struct dwc2_hsotg *)__mptr + 0xfffffffffffffb38UL;
  descriptor.modname = "dwc2";
  descriptor.function = "dwc2_hcd_reset_func";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
  descriptor.format = "USB RESET function called\n";
  descriptor.lineno = 2266U;
  descriptor.flags = 1U;
  tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp != 0L) {
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "USB RESET function called\n");
  } else {

  }
  hprt0 = dwc2_read_hprt0(hsotg);
  hprt0 = hprt0 & 4294967039U;
  writel(hprt0, (void volatile   *)hsotg->regs + 1088U);
  hsotg->flags.b.port_reset_change = 1U;
  return;
}
}
static int _dwc2_hcd_start(struct usb_hcd *hcd ) 
{ 
  struct dwc2_hsotg *hsotg ;
  struct dwc2_hsotg *tmp ;
  struct usb_bus *bus ;
  struct usb_bus *tmp___0 ;
  unsigned long flags ;
  struct _ddebug descriptor ;
  long tmp___1 ;
  raw_spinlock_t *tmp___2 ;
  int tmp___3 ;
  struct _ddebug descriptor___0 ;
  long tmp___4 ;

  {
  tmp = dwc2_hcd_to_hsotg(hcd);
  hsotg = tmp;
  tmp___0 = hcd_to_bus(hcd);
  bus = tmp___0;
  descriptor.modname = "dwc2";
  descriptor.function = "_dwc2_hcd_start";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
  descriptor.format = "DWC OTG HCD START\n";
  descriptor.lineno = 2290U;
  descriptor.flags = 1U;
  tmp___1 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp___1 != 0L) {
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "DWC OTG HCD START\n");
  } else {

  }
  tmp___2 = spinlock_check(& hsotg->lock);
  flags = _raw_spin_lock_irqsave(tmp___2);
  hcd->state = 1;
  tmp___3 = dwc2_is_device_mode(hsotg);
  if (tmp___3 != 0) {
    spin_unlock_irqrestore(& hsotg->lock, flags);
    return (0);
  } else {

  }
  dwc2_hcd_reinit(hsotg);
  if ((unsigned long )bus->root_hub != (unsigned long )((struct usb_device *)0)) {
    descriptor___0.modname = "dwc2";
    descriptor___0.function = "_dwc2_hcd_start";
    descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
    descriptor___0.format = "DWC OTG HCD Has Root Hub\n";
    descriptor___0.lineno = 2305U;
    descriptor___0.flags = 1U;
    tmp___4 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
    if (tmp___4 != 0L) {
      __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)hsotg->dev, "DWC OTG HCD Has Root Hub\n");
    } else {

    }
    usb_hcd_resume_root_hub(hcd);
  } else {

  }
  spin_unlock_irqrestore(& hsotg->lock, flags);
  return (0);
}
}
static void _dwc2_hcd_stop(struct usb_hcd *hcd ) 
{ 
  struct dwc2_hsotg *hsotg ;
  struct dwc2_hsotg *tmp ;
  unsigned long flags ;
  raw_spinlock_t *tmp___0 ;

  {
  tmp = dwc2_hcd_to_hsotg(hcd);
  hsotg = tmp;
  tmp___0 = spinlock_check(& hsotg->lock);
  flags = _raw_spin_lock_irqsave(tmp___0);
  dwc2_hcd_stop(hsotg);
  spin_unlock_irqrestore(& hsotg->lock, flags);
  usleep_range(1000UL, 3000UL);
  return;
}
}
static int _dwc2_hcd_suspend(struct usb_hcd *hcd ) 
{ 
  struct dwc2_hsotg *hsotg ;
  struct dwc2_hsotg *tmp ;

  {
  tmp = dwc2_hcd_to_hsotg(hcd);
  hsotg = tmp;
  hsotg->lx_state = 2;
  return (0);
}
}
static int _dwc2_hcd_resume(struct usb_hcd *hcd ) 
{ 
  struct dwc2_hsotg *hsotg ;
  struct dwc2_hsotg *tmp ;

  {
  tmp = dwc2_hcd_to_hsotg(hcd);
  hsotg = tmp;
  hsotg->lx_state = 0;
  return (0);
}
}
static int _dwc2_hcd_get_frame_number(struct usb_hcd *hcd ) 
{ 
  struct dwc2_hsotg *hsotg ;
  struct dwc2_hsotg *tmp ;
  int tmp___0 ;

  {
  tmp = dwc2_hcd_to_hsotg(hcd);
  hsotg = tmp;
  tmp___0 = dwc2_hcd_get_frame_number(hsotg);
  return (tmp___0);
}
}
static void dwc2_dump_urb_info(struct usb_hcd *hcd , struct urb *urb , char *fn_name ) 
{ 
  struct dwc2_hsotg *hsotg ;
  struct dwc2_hsotg *tmp ;
  char *pipetype ;
  char *speed ;
  struct _ddebug descriptor ;
  long tmp___0 ;
  struct _ddebug descriptor___0 ;
  long tmp___1 ;
  struct _ddebug descriptor___1 ;
  long tmp___2 ;
  struct _ddebug descriptor___2 ;
  int tmp___3 ;
  long tmp___4 ;
  struct _ddebug descriptor___3 ;
  long tmp___5 ;
  struct _ddebug descriptor___4 ;
  __u16 tmp___6 ;
  long tmp___7 ;
  struct _ddebug descriptor___5 ;
  long tmp___8 ;
  struct _ddebug descriptor___6 ;
  long tmp___9 ;
  struct _ddebug descriptor___7 ;
  long tmp___10 ;
  struct _ddebug descriptor___8 ;
  long tmp___11 ;
  int i ;
  struct _ddebug descriptor___9 ;
  long tmp___12 ;
  struct _ddebug descriptor___10 ;
  long tmp___13 ;

  {
  tmp = dwc2_hcd_to_hsotg(hcd);
  hsotg = tmp;
  descriptor.modname = "dwc2";
  descriptor.function = "dwc2_dump_urb_info";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
  descriptor.format = "%s, urb %p\n";
  descriptor.lineno = 2362U;
  descriptor.flags = 1U;
  tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp___0 != 0L) {
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "%s, urb %p\n",
                      fn_name, urb);
  } else {

  }
  descriptor___0.modname = "dwc2";
  descriptor___0.function = "dwc2_dump_urb_info";
  descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
  descriptor___0.format = "  Device address: %d\n";
  descriptor___0.lineno = 2364U;
  descriptor___0.flags = 1U;
  tmp___1 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
  if (tmp___1 != 0L) {
    __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)hsotg->dev, "  Device address: %d\n",
                      (urb->pipe >> 8) & 127U);
  } else {

  }
  descriptor___1.modname = "dwc2";
  descriptor___1.function = "dwc2_dump_urb_info";
  descriptor___1.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
  descriptor___1.format = "  Endpoint: %d, %s\n";
  descriptor___1.lineno = 2367U;
  descriptor___1.flags = 1U;
  tmp___2 = ldv__builtin_expect((long )descriptor___1.flags & 1L, 0L);
  if (tmp___2 != 0L) {
    __dynamic_dev_dbg(& descriptor___1, (struct device  const  *)hsotg->dev, "  Endpoint: %d, %s\n",
                      (urb->pipe >> 15) & 15U, (urb->pipe & 128U) != 0U ? (char *)"IN" : (char *)"OUT");
  } else {

  }
  switch (urb->pipe >> 30) {
  case 2U: 
  pipetype = (char *)"CONTROL";
  goto ldv_35304;
  case 3U: 
  pipetype = (char *)"BULK";
  goto ldv_35304;
  case 1U: 
  pipetype = (char *)"INTERRUPT";
  goto ldv_35304;
  case 0U: 
  pipetype = (char *)"ISOCHRONOUS";
  goto ldv_35304;
  default: 
  pipetype = (char *)"UNKNOWN";
  goto ldv_35304;
  }
  ldv_35304: 
  descriptor___2.modname = "dwc2";
  descriptor___2.function = "dwc2_dump_urb_info";
  descriptor___2.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
  descriptor___2.format = "  Endpoint type: %s %s (%s)\n";
  descriptor___2.lineno = 2389U;
  descriptor___2.flags = 1U;
  tmp___4 = ldv__builtin_expect((long )descriptor___2.flags & 1L, 0L);
  if (tmp___4 != 0L) {
    tmp___3 = usb_urb_dir_in(urb);
    __dynamic_dev_dbg(& descriptor___2, (struct device  const  *)hsotg->dev, "  Endpoint type: %s %s (%s)\n",
                      pipetype, tmp___3 != 0 ? (char *)"IN" : (char *)"OUT", (urb->pipe & 128U) != 0U ? (char *)"IN" : (char *)"OUT");
  } else {

  }
  switch ((unsigned int )(urb->dev)->speed) {
  case 3U: 
  speed = (char *)"HIGH";
  goto ldv_35311;
  case 2U: 
  speed = (char *)"FULL";
  goto ldv_35311;
  case 1U: 
  speed = (char *)"LOW";
  goto ldv_35311;
  default: 
  speed = (char *)"UNKNOWN";
  goto ldv_35311;
  }
  ldv_35311: 
  descriptor___3.modname = "dwc2";
  descriptor___3.function = "dwc2_dump_urb_info";
  descriptor___3.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
  descriptor___3.format = "  Speed: %s\n";
  descriptor___3.lineno = 2406U;
  descriptor___3.flags = 1U;
  tmp___5 = ldv__builtin_expect((long )descriptor___3.flags & 1L, 0L);
  if (tmp___5 != 0L) {
    __dynamic_dev_dbg(& descriptor___3, (struct device  const  *)hsotg->dev, "  Speed: %s\n",
                      speed);
  } else {

  }
  descriptor___4.modname = "dwc2";
  descriptor___4.function = "dwc2_dump_urb_info";
  descriptor___4.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
  descriptor___4.format = "  Max packet size: %d\n";
  descriptor___4.lineno = 2408U;
  descriptor___4.flags = 1U;
  tmp___7 = ldv__builtin_expect((long )descriptor___4.flags & 1L, 0L);
  if (tmp___7 != 0L) {
    tmp___6 = usb_maxpacket(urb->dev, (int )urb->pipe, (urb->pipe & 128U) == 0U);
    __dynamic_dev_dbg(& descriptor___4, (struct device  const  *)hsotg->dev, "  Max packet size: %d\n",
                      (int )tmp___6);
  } else {

  }
  descriptor___5.modname = "dwc2";
  descriptor___5.function = "dwc2_dump_urb_info";
  descriptor___5.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
  descriptor___5.format = "  Data buffer length: %d\n";
  descriptor___5.lineno = 2410U;
  descriptor___5.flags = 1U;
  tmp___8 = ldv__builtin_expect((long )descriptor___5.flags & 1L, 0L);
  if (tmp___8 != 0L) {
    __dynamic_dev_dbg(& descriptor___5, (struct device  const  *)hsotg->dev, "  Data buffer length: %d\n",
                      urb->transfer_buffer_length);
  } else {

  }
  descriptor___6.modname = "dwc2";
  descriptor___6.function = "dwc2_dump_urb_info";
  descriptor___6.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
  descriptor___6.format = "  Transfer buffer: %p, Transfer DMA: %08lx\n";
  descriptor___6.lineno = 2412U;
  descriptor___6.flags = 1U;
  tmp___9 = ldv__builtin_expect((long )descriptor___6.flags & 1L, 0L);
  if (tmp___9 != 0L) {
    __dynamic_dev_dbg(& descriptor___6, (struct device  const  *)hsotg->dev, "  Transfer buffer: %p, Transfer DMA: %08lx\n",
                      urb->transfer_buffer, (unsigned long )urb->transfer_dma);
  } else {

  }
  descriptor___7.modname = "dwc2";
  descriptor___7.function = "dwc2_dump_urb_info";
  descriptor___7.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
  descriptor___7.format = "  Setup buffer: %p, Setup DMA: %08lx\n";
  descriptor___7.lineno = 2414U;
  descriptor___7.flags = 1U;
  tmp___10 = ldv__builtin_expect((long )descriptor___7.flags & 1L, 0L);
  if (tmp___10 != 0L) {
    __dynamic_dev_dbg(& descriptor___7, (struct device  const  *)hsotg->dev, "  Setup buffer: %p, Setup DMA: %08lx\n",
                      urb->setup_packet, (unsigned long )urb->setup_dma);
  } else {

  }
  descriptor___8.modname = "dwc2";
  descriptor___8.function = "dwc2_dump_urb_info";
  descriptor___8.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
  descriptor___8.format = "  Interval: %d\n";
  descriptor___8.lineno = 2415U;
  descriptor___8.flags = 1U;
  tmp___11 = ldv__builtin_expect((long )descriptor___8.flags & 1L, 0L);
  if (tmp___11 != 0L) {
    __dynamic_dev_dbg(& descriptor___8, (struct device  const  *)hsotg->dev, "  Interval: %d\n",
                      urb->interval);
  } else {

  }
  if (urb->pipe >> 30 == 0U) {
    i = 0;
    goto ldv_35325;
    ldv_35324: 
    descriptor___9.modname = "dwc2";
    descriptor___9.function = "dwc2_dump_urb_info";
    descriptor___9.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
    descriptor___9.format = "  ISO Desc %d:\n";
    descriptor___9.lineno = 2421U;
    descriptor___9.flags = 1U;
    tmp___12 = ldv__builtin_expect((long )descriptor___9.flags & 1L, 0L);
    if (tmp___12 != 0L) {
      __dynamic_dev_dbg(& descriptor___9, (struct device  const  *)hsotg->dev, "  ISO Desc %d:\n",
                        i);
    } else {

    }
    descriptor___10.modname = "dwc2";
    descriptor___10.function = "dwc2_dump_urb_info";
    descriptor___10.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
    descriptor___10.format = "    offset: %d, length %d\n";
    descriptor___10.lineno = 2424U;
    descriptor___10.flags = 1U;
    tmp___13 = ldv__builtin_expect((long )descriptor___10.flags & 1L, 0L);
    if (tmp___13 != 0L) {
      __dynamic_dev_dbg(& descriptor___10, (struct device  const  *)hsotg->dev, "    offset: %d, length %d\n",
                        urb->iso_frame_desc[i].offset, urb->iso_frame_desc[i].length);
    } else {

    }
    i = i + 1;
    ldv_35325: ;
    if (urb->number_of_packets > i) {
      goto ldv_35324;
    } else {

    }

  } else {

  }
  return;
}
}
static int _dwc2_hcd_urb_enqueue(struct usb_hcd *hcd , struct urb *urb , gfp_t mem_flags ) 
{ 
  struct dwc2_hsotg *hsotg ;
  struct dwc2_hsotg *tmp ;
  struct usb_host_endpoint *ep ;
  struct dwc2_hcd_urb *dwc2_urb ;
  int i ;
  int retval ;
  int alloc_bandwidth ;
    klee_make_symbolic(&alloc_bandwidth, sizeof(int), "alloc_bandwidth");
  u8 ep_type ;
  u32 tflags ;
  void *buf ;
  unsigned long flags ;
  struct _ddebug descriptor ;
  long tmp___0 ;
  bool tmp___1 ;
  raw_spinlock_t *tmp___2 ;
  int tmp___3 ;
  __u16 tmp___4 ;
  raw_spinlock_t *tmp___5 ;
  u16 tmp___6 ;

  {
  tmp = dwc2_hcd_to_hsotg(hcd);
  hsotg = tmp;
  ep = urb->ep;
  alloc_bandwidth = 0;
  ep_type = 0U;
  tflags = 0U;
  tmp___1 = dbg_urb(urb);
  if ((int )tmp___1) {
    descriptor.modname = "dwc2";
    descriptor.function = "_dwc2_hcd_urb_enqueue";
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
    descriptor.format = "DWC OTG HCD URB Enqueue\n";
    descriptor.lineno = 2450U;
    descriptor.flags = 1U;
    tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
    if (tmp___0 != 0L) {
      __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "DWC OTG HCD URB Enqueue\n");
    } else {

    }
    dwc2_dump_urb_info(hcd, urb, (char *)"urb_enqueue");
  } else {

  }
  if ((unsigned long )ep == (unsigned long )((struct usb_host_endpoint *)0)) {
    return (-22);
  } else {

  }
  if (urb->pipe >> 30 == 0U || urb->pipe >> 30 == 1U) {
    tmp___2 = spinlock_check(& hsotg->lock);
    flags = _raw_spin_lock_irqsave(tmp___2);
    tmp___3 = dwc2_hcd_is_bandwidth_allocated(hsotg, ep);
    if (tmp___3 == 0) {
      alloc_bandwidth = 1;
    } else {

    }
    spin_unlock_irqrestore(& hsotg->lock, flags);
  } else {

  }
  switch (urb->pipe >> 30) {
  case 2U: 
  ep_type = 0U;
  goto ldv_35348;
  case 0U: 
  ep_type = 1U;
  goto ldv_35348;
  case 3U: 
  ep_type = 2U;
  goto ldv_35348;
  case 1U: 
  ep_type = 3U;
  goto ldv_35348;
  default: 
  dev_warn((struct device  const  *)hsotg->dev, "Wrong ep type\n");
  }
  ldv_35348: 
  dwc2_urb = dwc2_hcd_urb_alloc(hsotg, urb->number_of_packets, mem_flags);
  if ((unsigned long )dwc2_urb == (unsigned long )((struct dwc2_hcd_urb *)0)) {
    return (-12);
  } else {

  }
  tmp___4 = usb_maxpacket(urb->dev, (int )urb->pipe, (urb->pipe & 128U) == 0U);
  dwc2_hcd_urb_set_pipeinfo(hsotg, dwc2_urb, (int )((u8 )(urb->pipe >> 8)) & 127,
                            (int )((u8 )(urb->pipe >> 15)) & 15, (int )ep_type, (int )((u8 )urb->pipe) & 128,
                            (int )tmp___4);
  buf = urb->transfer_buffer;
  if ((unsigned int )hcd->self.uses_dma != 0U) {
    if ((unsigned long )buf == (unsigned long )((void *)0) && (urb->transfer_dma & 3ULL) != 0ULL) {
      dev_err((struct device  const  *)hsotg->dev, "%s: unaligned transfer with no transfer_buffer",
              "_dwc2_hcd_urb_enqueue");
      retval = -22;
      goto fail0;
    } else {

    }
  } else {

  }
  if ((urb->transfer_flags & 128U) == 0U) {
    tflags = tflags | 1U;
  } else {

  }
  if ((urb->transfer_flags & 64U) != 0U) {
    tflags = tflags | 2U;
  } else {

  }
  dwc2_urb->priv = (void *)urb;
  dwc2_urb->buf = buf;
  dwc2_urb->dma = urb->transfer_dma;
  dwc2_urb->length = urb->transfer_buffer_length;
  dwc2_urb->setup_packet = (void *)urb->setup_packet;
  dwc2_urb->setup_dma = urb->setup_dma;
  dwc2_urb->flags = tflags;
  dwc2_urb->interval = (u16 )urb->interval;
  dwc2_urb->status = 4294967181U;
  i = 0;
  goto ldv_35355;
  ldv_35354: 
  dwc2_hcd_urb_set_iso_desc_params(dwc2_urb, i, urb->iso_frame_desc[i].offset, urb->iso_frame_desc[i].length);
  i = i + 1;
  ldv_35355: ;
  if (urb->number_of_packets > i) {
    goto ldv_35354;
  } else {

  }
  urb->hcpriv = (void *)dwc2_urb;
  tmp___5 = spinlock_check(& hsotg->lock);
  flags = _raw_spin_lock_irqsave(tmp___5);
  retval = usb_hcd_link_urb_to_ep(hcd, urb);
  if (retval != 0) {
    goto fail1;
  } else {

  }
  retval = dwc2_hcd_urb_enqueue(hsotg, dwc2_urb, & ep->hcpriv, mem_flags);
  if (retval != 0) {
    goto fail2;
  } else {

  }
  if (alloc_bandwidth != 0) {
    tmp___6 = dwc2_hcd_get_ep_bandwidth(hsotg, ep);
    dwc2_allocate_bus_bandwidth(hcd, (int )tmp___6, urb);
  } else {

  }
  spin_unlock_irqrestore(& hsotg->lock, flags);
  return (0);
  fail2: 
  dwc2_urb->priv = (void *)0;
  usb_hcd_unlink_urb_from_ep(hcd, urb);
  fail1: 
  spin_unlock_irqrestore(& hsotg->lock, flags);
  urb->hcpriv = (void *)0;
  fail0: 
  kfree((void const   *)dwc2_urb);
  return (retval);
}
}
static int _dwc2_hcd_urb_dequeue(struct usb_hcd *hcd , struct urb *urb , int status ) 
{ 
  struct dwc2_hsotg *hsotg ;
  struct dwc2_hsotg *tmp ;
  int rc ;
  unsigned long flags ;
  struct _ddebug descriptor ;
  long tmp___0 ;
  raw_spinlock_t *tmp___1 ;
  struct _ddebug descriptor___0 ;
  long tmp___2 ;
  struct _ddebug descriptor___1 ;
  long tmp___3 ;
  struct _ddebug descriptor___2 ;
  long tmp___4 ;

  {
  tmp = dwc2_hcd_to_hsotg(hcd);
  hsotg = tmp;
  descriptor.modname = "dwc2";
  descriptor.function = "_dwc2_hcd_urb_dequeue";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
  descriptor.format = "DWC OTG HCD URB Dequeue\n";
  descriptor.lineno = 2568U;
  descriptor.flags = 1U;
  tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp___0 != 0L) {
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "DWC OTG HCD URB Dequeue\n");
  } else {

  }
  dwc2_dump_urb_info(hcd, urb, (char *)"urb_dequeue");
  tmp___1 = spinlock_check(& hsotg->lock);
  flags = _raw_spin_lock_irqsave(tmp___1);
  rc = usb_hcd_check_unlink_urb(hcd, urb, status);
  if (rc != 0) {
    goto out;
  } else {

  }
  if ((unsigned long )urb->hcpriv == (unsigned long )((void *)0)) {
    descriptor___0.modname = "dwc2";
    descriptor___0.function = "_dwc2_hcd_urb_dequeue";
    descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
    descriptor___0.format = "## urb->hcpriv is NULL ##\n";
    descriptor___0.lineno = 2578U;
    descriptor___0.flags = 1U;
    tmp___2 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
    if (tmp___2 != 0L) {
      __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)hsotg->dev, "## urb->hcpriv is NULL ##\n");
    } else {

    }
    goto out;
  } else {

  }
  rc = dwc2_hcd_urb_dequeue(hsotg, (struct dwc2_hcd_urb *)urb->hcpriv);
  usb_hcd_unlink_urb_from_ep(hcd, urb);
  kfree((void const   *)urb->hcpriv);
  urb->hcpriv = (void *)0;
  spin_unlock(& hsotg->lock);
  usb_hcd_giveback_urb(hcd, urb, status);
  spin_lock(& hsotg->lock);
  descriptor___1.modname = "dwc2";
  descriptor___1.function = "_dwc2_hcd_urb_dequeue";
  descriptor___1.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
  descriptor___1.format = "Called usb_hcd_giveback_urb()\n";
  descriptor___1.lineno = 2594U;
  descriptor___1.flags = 1U;
  tmp___3 = ldv__builtin_expect((long )descriptor___1.flags & 1L, 0L);
  if (tmp___3 != 0L) {
    __dynamic_dev_dbg(& descriptor___1, (struct device  const  *)hsotg->dev, "Called usb_hcd_giveback_urb()\n");
  } else {

  }
  descriptor___2.modname = "dwc2";
  descriptor___2.function = "_dwc2_hcd_urb_dequeue";
  descriptor___2.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
  descriptor___2.format = "  urb->status = %d\n";
  descriptor___2.lineno = 2595U;
  descriptor___2.flags = 1U;
  tmp___4 = ldv__builtin_expect((long )descriptor___2.flags & 1L, 0L);
  if (tmp___4 != 0L) {
    __dynamic_dev_dbg(& descriptor___2, (struct device  const  *)hsotg->dev, "  urb->status = %d\n",
                      urb->status);
  } else {

  }
  out: 
  spin_unlock_irqrestore(& hsotg->lock, flags);
  return (rc);
}
}
static void _dwc2_hcd_endpoint_disable(struct usb_hcd *hcd , struct usb_host_endpoint *ep ) 
{ 
  struct dwc2_hsotg *hsotg ;
  struct dwc2_hsotg *tmp ;
  struct _ddebug descriptor ;
  long tmp___0 ;

  {
  tmp = dwc2_hcd_to_hsotg(hcd);
  hsotg = tmp;
  descriptor.modname = "dwc2";
  descriptor.function = "_dwc2_hcd_endpoint_disable";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
  descriptor.format = "DWC OTG HCD EP DISABLE: bEndpointAddress=0x%02x, ep->hcpriv=%p\n";
  descriptor.lineno = 2614U;
  descriptor.flags = 1U;
  tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp___0 != 0L) {
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "DWC OTG HCD EP DISABLE: bEndpointAddress=0x%02x, ep->hcpriv=%p\n",
                      (int )ep->desc.bEndpointAddress, ep->hcpriv);
  } else {

  }
  dwc2_hcd_endpoint_disable(hsotg, ep, 250);
  return;
}
}
static void _dwc2_hcd_endpoint_reset(struct usb_hcd *hcd , struct usb_host_endpoint *ep ) 
{ 
  struct dwc2_hsotg *hsotg ;
  struct dwc2_hsotg *tmp ;
  unsigned long flags ;
  struct _ddebug descriptor ;
  long tmp___0 ;
  raw_spinlock_t *tmp___1 ;

  {
  tmp = dwc2_hcd_to_hsotg(hcd);
  hsotg = tmp;
  descriptor.modname = "dwc2";
  descriptor.function = "_dwc2_hcd_endpoint_reset";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
  descriptor.format = "DWC OTG HCD EP RESET: bEndpointAddress=0x%02x\n";
  descriptor.lineno = 2631U;
  descriptor.flags = 1U;
  tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp___0 != 0L) {
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "DWC OTG HCD EP RESET: bEndpointAddress=0x%02x\n",
                      (int )ep->desc.bEndpointAddress);
  } else {

  }
  tmp___1 = spinlock_check(& hsotg->lock);
  flags = _raw_spin_lock_irqsave(tmp___1);
  dwc2_hcd_endpoint_reset(hsotg, ep);
  spin_unlock_irqrestore(& hsotg->lock, flags);
  return;
}
}
static irqreturn_t _dwc2_hcd_irq(struct usb_hcd *hcd ) 
{ 
  struct dwc2_hsotg *hsotg ;
  struct dwc2_hsotg *tmp ;
  irqreturn_t tmp___0 ;

  {
  tmp = dwc2_hcd_to_hsotg(hcd);
  hsotg = tmp;
  tmp___0 = dwc2_handle_hcd_intr(hsotg);
  return (tmp___0);
}
}
static int _dwc2_hcd_hub_status_data(struct usb_hcd *hcd , char *buf ) 
{ 
  struct dwc2_hsotg *hsotg ;
  struct dwc2_hsotg *tmp ;
  int tmp___0 ;

  {
  tmp = dwc2_hcd_to_hsotg(hcd);
  hsotg = tmp;
  tmp___0 = dwc2_hcd_is_status_changed(hsotg, 1);
  *buf = (char )(tmp___0 << 1);
  return ((int )((signed char )*buf) != 0);
}
}
static int _dwc2_hcd_hub_control(struct usb_hcd *hcd , u16 typereq , u16 wvalue ,
                                 u16 windex , char *buf , u16 wlength ) 
{ 
  int retval ;
  struct dwc2_hsotg *tmp ;
  int tmp___0 ;

  {
  tmp = dwc2_hcd_to_hsotg(hcd);
  tmp___0 = dwc2_hcd_hub_control(tmp, (int )typereq, (int )wvalue, (int )windex, buf,
                                 (int )wlength);
  retval = tmp___0;
  return (retval);
}
}
static void _dwc2_hcd_clear_tt_buffer_complete(struct usb_hcd *hcd , struct usb_host_endpoint *ep ) 
{ 
  struct dwc2_hsotg *hsotg ;
  struct dwc2_hsotg *tmp ;
  struct dwc2_qh *qh ;
  unsigned long flags ;
  raw_spinlock_t *tmp___0 ;

  {
  tmp = dwc2_hcd_to_hsotg(hcd);
  hsotg = tmp;
  qh = (struct dwc2_qh *)ep->hcpriv;
  if ((unsigned long )qh == (unsigned long )((struct dwc2_qh *)0)) {
    return;
  } else {

  }
  tmp___0 = spinlock_check(& hsotg->lock);
  flags = _raw_spin_lock_irqsave(tmp___0);
  qh->tt_buffer_dirty = 0U;
  if ((unsigned int )*((unsigned char *)hsotg + 664UL) != 0U) {
    dwc2_hcd_queue_transactions(hsotg, 3);
  } else {

  }
  spin_unlock_irqrestore(& hsotg->lock, flags);
  return;
}
}
static struct hc_driver dwc2_hc_driver  = 
     {"dwc2_hsotg", "DWC OTG Controller", 8UL, & _dwc2_hcd_irq, 33, 0, & _dwc2_hcd_start,
    0, 0, & _dwc2_hcd_stop, 0, & _dwc2_hcd_get_frame_number, & _dwc2_hcd_urb_enqueue,
    & _dwc2_hcd_urb_dequeue, 0, 0, & _dwc2_hcd_endpoint_disable, & _dwc2_hcd_endpoint_reset,
    & _dwc2_hcd_hub_status_data, & _dwc2_hcd_hub_control, & _dwc2_hcd_suspend, & _dwc2_hcd_resume,
    0, 0, 0, & _dwc2_hcd_clear_tt_buffer_complete, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0};
static void dwc2_hcd_free(struct dwc2_hsotg *hsotg ) 
{ 
  u32 ahbcfg ;
  u32 dctl ;
  int i ;
  struct _ddebug descriptor ;
  long tmp ;
  struct dwc2_host_chan *chan ;
  struct _ddebug descriptor___0 ;
  long tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;

  {
  descriptor.modname = "dwc2";
  descriptor.function = "dwc2_hcd_free";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
  descriptor.format = "DWC OTG HCD FREE\n";
  descriptor.lineno = 2730U;
  descriptor.flags = 1U;
  tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp != 0L) {
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "DWC OTG HCD FREE\n");
  } else {

  }
  dwc2_qh_list_free(hsotg, & hsotg->non_periodic_sched_inactive);
  dwc2_qh_list_free(hsotg, & hsotg->non_periodic_sched_active);
  dwc2_qh_list_free(hsotg, & hsotg->periodic_sched_inactive);
  dwc2_qh_list_free(hsotg, & hsotg->periodic_sched_ready);
  dwc2_qh_list_free(hsotg, & hsotg->periodic_sched_assigned);
  dwc2_qh_list_free(hsotg, & hsotg->periodic_sched_queued);
  i = 0;
  goto ldv_35437;
  ldv_35436: 
  chan = hsotg->hc_ptr_array[i];
  if ((unsigned long )chan != (unsigned long )((struct dwc2_host_chan *)0)) {
    descriptor___0.modname = "dwc2";
    descriptor___0.function = "dwc2_hcd_free";
    descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
    descriptor___0.format = "HCD Free channel #%i, chan=%p\n";
    descriptor___0.lineno = 2746U;
    descriptor___0.flags = 1U;
    tmp___0 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
    if (tmp___0 != 0L) {
      __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)hsotg->dev, "HCD Free channel #%i, chan=%p\n",
                        i, chan);
    } else {

    }
    hsotg->hc_ptr_array[i] = (struct dwc2_host_chan *)0;
    kfree((void const   *)chan);
  } else {

  }
  i = i + 1;
  ldv_35437: ;
  if (i <= 15) {
    goto ldv_35436;
  } else {

  }

  if ((hsotg->core_params)->dma_enable > 0) {
    if ((unsigned long )hsotg->status_buf != (unsigned long )((u8 *)0U)) {
      dma_free_attrs(hsotg->dev, 64UL, (void *)hsotg->status_buf, hsotg->status_buf_dma,
                     (struct dma_attrs *)0);
      hsotg->status_buf = (u8 *)0U;
    } else {

    }
  } else {
    kfree((void const   *)hsotg->status_buf);
    hsotg->status_buf = (u8 *)0U;
  }
  ahbcfg = readl((void const volatile   *)hsotg->regs + 8U);
  ahbcfg = ahbcfg & 4294967294U;
  writel(ahbcfg, (void volatile   *)hsotg->regs + 8U);
  writel(0U, (void volatile   *)hsotg->regs + 24U);
  if (hsotg->hw_params.snpsid > 1330917385U) {
    dctl = readl((void const volatile   *)hsotg->regs + 2052U);
    dctl = dctl | 2U;
    writel(dctl, (void volatile   *)hsotg->regs + 2052U);
  } else {

  }
  if ((unsigned long )hsotg->wq_otg != (unsigned long )((struct workqueue_struct *)0)) {
    tmp___1 = ldv_cancel_work_sync_58(& hsotg->wf_otg);
    if (tmp___1) {
      tmp___2 = 0;
    } else {
      tmp___2 = 1;
    }
    if (tmp___2) {
      ldv_flush_workqueue_59(hsotg->wq_otg);
    } else {

    }
    ldv_destroy_workqueue_60(hsotg->wq_otg);
  } else {

  }
  ldv_del_timer_61(& hsotg->wkp_timer);
  return;
}
}
static void dwc2_hcd_release(struct dwc2_hsotg *hsotg ) 
{ 


  {
  dwc2_disable_host_interrupts(hsotg);
  dwc2_hcd_free(hsotg);
  return;
}
}
int dwc2_hcd_init(struct dwc2_hsotg *hsotg , int irq ) 
{ 
  struct usb_hcd *hcd ;
  struct dwc2_host_chan *channel ;
  u32 hcfg ;
  int i ;
  int num_channels ;
  int retval ;
  int tmp ;
  struct _ddebug descriptor ;
  long tmp___0 ;
  struct _ddebug descriptor___0 ;
  long tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char const   *tmp___6 ;
  struct lock_class_key __key ;
  char const   *__lock_name ;
  struct workqueue_struct *tmp___7 ;
  struct lock_class_key __key___0 ;
  atomic_long_t __constr_expr_0 ;
  void *tmp___8 ;
  struct lock_class_key __key___1 ;
  atomic_long_t __constr_expr_1 ;
  struct lock_class_key __key___2 ;
  struct lock_class_key __key___3 ;
  atomic_long_t __constr_expr_2 ;
  struct lock_class_key __key___4 ;
  void *tmp___9 ;
  void *tmp___10 ;
  bool tmp___11 ;
  int tmp___12 ;

  {
  tmp = usb_disabled();
  if (tmp != 0) {
    return (-19);
  } else {

  }
  descriptor.modname = "dwc2";
  descriptor.function = "dwc2_hcd_init";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
  descriptor.format = "DWC OTG HCD INIT\n";
  descriptor.lineno = 2811U;
  descriptor.flags = 1U;
  tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp___0 != 0L) {
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "DWC OTG HCD INIT\n");
  } else {

  }
  retval = -12;
  hcfg = readl((void const volatile   *)hsotg->regs + 1024U);
  descriptor___0.modname = "dwc2";
  descriptor___0.function = "dwc2_hcd_init";
  descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
  descriptor___0.format = "hcfg=%08x\n";
  descriptor___0.lineno = 2816U;
  descriptor___0.flags = 1U;
  tmp___1 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
  if (tmp___1 != 0L) {
    __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)hsotg->dev, "hcfg=%08x\n",
                      hcfg);
  } else {

  }
  tmp___2 = kzalloc(2000UL, 208U);
  hsotg->frame_num_array = (u16 *)tmp___2;
  if ((unsigned long )hsotg->frame_num_array == (unsigned long )((u16 *)0U)) {
    goto error1;
  } else {

  }
  tmp___3 = kzalloc(2000UL, 208U);
  hsotg->last_frame_num_array = (u16 *)tmp___3;
  if ((unsigned long )hsotg->last_frame_num_array == (unsigned long )((u16 *)0U)) {
    goto error1;
  } else {

  }
  hsotg->last_frame_num = 16383U;
  if ((hsotg->core_params)->dma_enable > 0 && (unsigned long )(hsotg->dev)->dma_mask == (unsigned long )((u64 *)0ULL)) {
    dev_warn((struct device  const  *)hsotg->dev, "dma_mask not set, disabling DMA\n");
    (hsotg->core_params)->dma_enable = 0;
    (hsotg->core_params)->dma_desc_enable = 0;
  } else {

  }
  if ((hsotg->core_params)->dma_enable > 0) {
    tmp___4 = dma_set_mask(hsotg->dev, 4294967295ULL);
    if (tmp___4 < 0) {
      dev_warn((struct device  const  *)hsotg->dev, "can\'t set DMA mask\n");
    } else {

    }
    tmp___5 = dma_set_coherent_mask(hsotg->dev, 4294967295ULL);
    if (tmp___5 < 0) {
      dev_warn((struct device  const  *)hsotg->dev, "can\'t set coherent DMA mask\n");
    } else {

    }
  } else {

  }
  tmp___6 = dev_name((struct device  const  *)hsotg->dev);
  hcd = usb_create_hcd((struct hc_driver  const  *)(& dwc2_hc_driver), hsotg->dev,
                       tmp___6);
  if ((unsigned long )hcd == (unsigned long )((struct usb_hcd *)0)) {
    goto error1;
  } else {

  }
  if ((hsotg->core_params)->dma_enable <= 0) {
    hcd->self.uses_dma = 0U;
  } else {

  }
  hcd->has_tt = 1U;
  ((struct wrapper_priv_data *)(& hcd->hcd_priv))->hsotg = hsotg;
  hsotg->priv = (void *)hcd;
  dwc2_disable_global_interrupts(hsotg);
  retval = dwc2_core_init(hsotg, 1, irq);
  if (retval != 0) {
    goto error2;
  } else {

  }
  retval = -12;
  __lock_name = "\"%s\"\"dwc2\"";
  tmp___7 = __alloc_workqueue_key("%s", 131082U, 1, & __key, __lock_name, (char *)"dwc2");
  hsotg->wq_otg = tmp___7;
  if ((unsigned long )hsotg->wq_otg == (unsigned long )((struct workqueue_struct *)0)) {
    dev_err((struct device  const  *)hsotg->dev, "Failed to create workqueue\n");
    goto error2;
  } else {

  }
  __init_work(& hsotg->wf_otg, 0);
  __constr_expr_0.counter = 137438953408L;
  hsotg->wf_otg.data = __constr_expr_0;
  lockdep_init_map(& hsotg->wf_otg.lockdep_map, "(&hsotg->wf_otg)", & __key___0, 0);
  INIT_LIST_HEAD(& hsotg->wf_otg.entry);
  hsotg->wf_otg.func = & dwc2_conn_id_status_change;
  reg_timer_4(& hsotg->wkp_timer, & dwc2_wakeup_detected, (unsigned long )hsotg);
  INIT_LIST_HEAD(& hsotg->non_periodic_sched_inactive);
  INIT_LIST_HEAD(& hsotg->non_periodic_sched_active);
  INIT_LIST_HEAD(& hsotg->periodic_sched_inactive);
  INIT_LIST_HEAD(& hsotg->periodic_sched_ready);
  INIT_LIST_HEAD(& hsotg->periodic_sched_assigned);
  INIT_LIST_HEAD(& hsotg->periodic_sched_queued);
  INIT_LIST_HEAD(& hsotg->free_hc_list);
  num_channels = (hsotg->core_params)->host_channels;
  memset((void *)(& hsotg->hc_ptr_array), 0, 128UL);
  i = 0;
  goto ldv_35464;
  ldv_35463: 
  tmp___8 = kzalloc(96UL, 208U);
  channel = (struct dwc2_host_chan *)tmp___8;
  if ((unsigned long )channel == (unsigned long )((struct dwc2_host_chan *)0)) {
    goto error3;
  } else {

  }
  channel->hc_num = (u8 )i;
  hsotg->hc_ptr_array[i] = channel;
  i = i + 1;
  ldv_35464: ;
  if (i < num_channels) {
    goto ldv_35463;
  } else {

  }

  if ((hsotg->core_params)->uframe_sched > 0) {
    dwc2_hcd_init_usecs(hsotg);
  } else {

  }
  __init_work(& hsotg->start_work.work, 0);
  __constr_expr_1.counter = 137438953408L;
  hsotg->start_work.work.data = __constr_expr_1;
  lockdep_init_map(& hsotg->start_work.work.lockdep_map, "(&(&hsotg->start_work)->work)",
                   & __key___1, 0);
  INIT_LIST_HEAD(& hsotg->start_work.work.entry);
  hsotg->start_work.work.func = & dwc2_hcd_start_func;
  init_timer_key(& hsotg->start_work.timer, 2097152U, "(&(&hsotg->start_work)->timer)",
                 & __key___2);
  hsotg->start_work.timer.function = & delayed_work_timer_fn;
  hsotg->start_work.timer.data = (unsigned long )(& hsotg->start_work);
  __init_work(& hsotg->reset_work.work, 0);
  __constr_expr_2.counter = 137438953408L;
  hsotg->reset_work.work.data = __constr_expr_2;
  lockdep_init_map(& hsotg->reset_work.work.lockdep_map, "(&(&hsotg->reset_work)->work)",
                   & __key___3, 0);
  INIT_LIST_HEAD(& hsotg->reset_work.work.entry);
  hsotg->reset_work.work.func = & dwc2_hcd_reset_func;
  init_timer_key(& hsotg->reset_work.timer, 2097152U, "(&(&hsotg->reset_work)->timer)",
                 & __key___4);
  hsotg->reset_work.timer.function = & delayed_work_timer_fn;
  hsotg->reset_work.timer.data = (unsigned long )(& hsotg->reset_work);
  if ((hsotg->core_params)->dma_enable > 0) {
    tmp___9 = dma_alloc_attrs(hsotg->dev, 64UL, & hsotg->status_buf_dma, 208U, (struct dma_attrs *)0);
    hsotg->status_buf = (u8 *)tmp___9;
  } else {
    tmp___10 = kzalloc(64UL, 208U);
    hsotg->status_buf = (u8 *)tmp___10;
  }
  if ((unsigned long )hsotg->status_buf == (unsigned long )((u8 *)0U)) {
    goto error3;
  } else {

  }
  hsotg->otg_port = 1U;
  hsotg->frame_list = (u32 *)0U;
  hsotg->frame_list_dma = 0ULL;
  hsotg->periodic_qh_count = 0U;
  hsotg->lx_state = 3;
  hcd->self.otg_port = hsotg->otg_port;
  hcd->self.sg_tablesize = 0U;
  tmp___11 = IS_ERR_OR_NULL((void const   *)hsotg->uphy);
  if (tmp___11) {
    tmp___12 = 0;
  } else {
    tmp___12 = 1;
  }
  if (tmp___12) {
    otg_set_host((hsotg->uphy)->otg, & hcd->self);
  } else {

  }
  retval = usb_add_hcd(hcd, (unsigned int )irq, 128UL);
  if (retval < 0) {
    goto error3;
  } else {

  }
  device_wakeup_enable(hcd->self.controller);
  dwc2_hcd_dump_state(hsotg);
  dwc2_enable_global_interrupts(hsotg);
  return (0);
  error3: 
  dwc2_hcd_release(hsotg);
  error2: 
  usb_put_hcd(hcd);
  error1: 
  kfree((void const   *)hsotg->core_params);
  kfree((void const   *)hsotg->last_frame_num_array);
  kfree((void const   *)hsotg->frame_num_array);
  dev_err((struct device  const  *)hsotg->dev, "%s() FAILED, returning %d\n", "dwc2_hcd_init",
          retval);
  return (retval);
}
}
void dwc2_hcd_remove(struct dwc2_hsotg *hsotg ) 
{ 
  struct usb_hcd *hcd ;
  struct _ddebug descriptor ;
  long tmp ;
  struct _ddebug descriptor___0 ;
  long tmp___0 ;
  struct _ddebug descriptor___1 ;
  long tmp___1 ;
  bool tmp___2 ;
  int tmp___3 ;

  {
  descriptor.modname = "dwc2";
  descriptor.function = "dwc2_hcd_remove";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
  descriptor.format = "DWC OTG HCD REMOVE\n";
  descriptor.lineno = 2992U;
  descriptor.flags = 1U;
  tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp != 0L) {
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "DWC OTG HCD REMOVE\n");
  } else {

  }
  hcd = dwc2_hsotg_to_hcd(hsotg);
  descriptor___0.modname = "dwc2";
  descriptor___0.function = "dwc2_hcd_remove";
  descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
  descriptor___0.format = "hsotg->hcd = %p\n";
  descriptor___0.lineno = 2995U;
  descriptor___0.flags = 1U;
  tmp___0 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
  if (tmp___0 != 0L) {
    __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)hsotg->dev, "hsotg->hcd = %p\n",
                      hcd);
  } else {

  }
  if ((unsigned long )hcd == (unsigned long )((struct usb_hcd *)0)) {
    descriptor___1.modname = "dwc2";
    descriptor___1.function = "dwc2_hcd_remove";
    descriptor___1.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd.c";
    descriptor___1.format = "%s: dwc2_hsotg_to_hcd(hsotg) NULL!\n";
    descriptor___1.lineno = 2999U;
    descriptor___1.flags = 1U;
    tmp___1 = ldv__builtin_expect((long )descriptor___1.flags & 1L, 0L);
    if (tmp___1 != 0L) {
      __dynamic_dev_dbg(& descriptor___1, (struct device  const  *)hsotg->dev, "%s: dwc2_hsotg_to_hcd(hsotg) NULL!\n",
                        "dwc2_hcd_remove");
    } else {

    }
    return;
  } else {

  }
  tmp___2 = IS_ERR_OR_NULL((void const   *)hsotg->uphy);
  if (tmp___2) {
    tmp___3 = 0;
  } else {
    tmp___3 = 1;
  }
  if (tmp___3) {
    otg_set_host((hsotg->uphy)->otg, (struct usb_bus *)0);
  } else {

  }
  usb_remove_hcd(hcd);
  hsotg->priv = (void *)0;
  dwc2_hcd_release(hsotg);
  usb_put_hcd(hcd);
  kfree((void const   *)hsotg->last_frame_num_array);
  kfree((void const   *)hsotg->frame_num_array);
  return;
}
}
int ldv_retval_1  ;
    klee_make_symbolic(&ldv_retval_1, sizeof(int), "ldv_retval_1");
void work_init_3(void) 
{ 


  {
  ldv_work_3_0 = 0;
  ldv_work_3_1 = 0;
  ldv_work_3_2 = 0;
  ldv_work_3_3 = 0;
  return;
}
}
void call_and_disable_work_1(struct work_struct *work ) 
{ 


  {
  if ((ldv_work_1_0 == 2 || ldv_work_1_0 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_1_0) {
    dwc2_conn_id_status_change(work);
    ldv_work_1_0 = 1;
    return;
  } else {

  }
  if ((ldv_work_1_1 == 2 || ldv_work_1_1 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_1_1) {
    dwc2_conn_id_status_change(work);
    ldv_work_1_1 = 1;
    return;
  } else {

  }
  if ((ldv_work_1_2 == 2 || ldv_work_1_2 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_1_2) {
    dwc2_conn_id_status_change(work);
    ldv_work_1_2 = 1;
    return;
  } else {

  }
  if ((ldv_work_1_3 == 2 || ldv_work_1_3 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_1_3) {
    dwc2_conn_id_status_change(work);
    ldv_work_1_3 = 1;
    return;
  } else {

  }
  return;
}
}
void work_init_2(void) 
{ 


  {
  ldv_work_2_0 = 0;
  ldv_work_2_1 = 0;
  ldv_work_2_2 = 0;
  ldv_work_2_3 = 0;
  return;
}
}
void activate_pending_timer_4(struct timer_list *timer , unsigned long data , int pending_flag ) 
{ 


  {
  if ((unsigned long )ldv_timer_list_4_0 == (unsigned long )timer) {
    if (ldv_timer_4_0 == 2 || pending_flag != 0) {
      ldv_timer_list_4_0 = timer;
      ldv_timer_list_4_0->data = data;
      ldv_timer_4_0 = 1;
    } else {

    }
    return;
  } else {

  }
  if ((unsigned long )ldv_timer_list_4_1 == (unsigned long )timer) {
    if (ldv_timer_4_1 == 2 || pending_flag != 0) {
      ldv_timer_list_4_1 = timer;
      ldv_timer_list_4_1->data = data;
      ldv_timer_4_1 = 1;
    } else {

    }
    return;
  } else {

  }
  if ((unsigned long )ldv_timer_list_4_2 == (unsigned long )timer) {
    if (ldv_timer_4_2 == 2 || pending_flag != 0) {
      ldv_timer_list_4_2 = timer;
      ldv_timer_list_4_2->data = data;
      ldv_timer_4_2 = 1;
    } else {

    }
    return;
  } else {

  }
  if ((unsigned long )ldv_timer_list_4_3 == (unsigned long )timer) {
    if (ldv_timer_4_3 == 2 || pending_flag != 0) {
      ldv_timer_list_4_3 = timer;
      ldv_timer_list_4_3->data = data;
      ldv_timer_4_3 = 1;
    } else {

    }
    return;
  } else {

  }
  activate_suitable_timer_4(timer, data);
  return;
}
}
void call_and_disable_all_2(int state ) 
{ 


  {
  if (ldv_work_2_0 == state) {
    call_and_disable_work_2(ldv_work_struct_2_0);
  } else {

  }
  if (ldv_work_2_1 == state) {
    call_and_disable_work_2(ldv_work_struct_2_1);
  } else {

  }
  if (ldv_work_2_2 == state) {
    call_and_disable_work_2(ldv_work_struct_2_2);
  } else {

  }
  if (ldv_work_2_3 == state) {
    call_and_disable_work_2(ldv_work_struct_2_3);
  } else {

  }
  return;
}
}
void call_and_disable_all_1(int state ) 
{ 


  {
  if (ldv_work_1_0 == state) {
    call_and_disable_work_1(ldv_work_struct_1_0);
  } else {

  }
  if (ldv_work_1_1 == state) {
    call_and_disable_work_1(ldv_work_struct_1_1);
  } else {

  }
  if (ldv_work_1_2 == state) {
    call_and_disable_work_1(ldv_work_struct_1_2);
  } else {

  }
  if (ldv_work_1_3 == state) {
    call_and_disable_work_1(ldv_work_struct_1_3);
  } else {

  }
  return;
}
}
void activate_work_2(struct work_struct *work , int state ) 
{ 


  {
  if (ldv_work_2_0 == 0) {
    ldv_work_struct_2_0 = work;
    ldv_work_2_0 = state;
    return;
  } else {

  }
  if (ldv_work_2_1 == 0) {
    ldv_work_struct_2_1 = work;
    ldv_work_2_1 = state;
    return;
  } else {

  }
  if (ldv_work_2_2 == 0) {
    ldv_work_struct_2_2 = work;
    ldv_work_2_2 = state;
    return;
  } else {

  }
  if (ldv_work_2_3 == 0) {
    ldv_work_struct_2_3 = work;
    ldv_work_2_3 = state;
    return;
  } else {

  }
  return;
}
}
void timer_init_4(void) 
{ 


  {
  ldv_timer_4_0 = 0;
  ldv_timer_4_1 = 0;
  ldv_timer_4_2 = 0;
  ldv_timer_4_3 = 0;
  return;
}
}
void activate_work_3(struct work_struct *work , int state ) 
{ 


  {
  if (ldv_work_3_0 == 0) {
    ldv_work_struct_3_0 = work;
    ldv_work_3_0 = state;
    return;
  } else {

  }
  if (ldv_work_3_1 == 0) {
    ldv_work_struct_3_1 = work;
    ldv_work_3_1 = state;
    return;
  } else {

  }
  if (ldv_work_3_2 == 0) {
    ldv_work_struct_3_2 = work;
    ldv_work_3_2 = state;
    return;
  } else {

  }
  if (ldv_work_3_3 == 0) {
    ldv_work_struct_3_3 = work;
    ldv_work_3_3 = state;
    return;
  } else {

  }
  return;
}
}
void activate_work_1(struct work_struct *work , int state ) 
{ 


  {
  if (ldv_work_1_0 == 0) {
    ldv_work_struct_1_0 = work;
    ldv_work_1_0 = state;
    return;
  } else {

  }
  if (ldv_work_1_1 == 0) {
    ldv_work_struct_1_1 = work;
    ldv_work_1_1 = state;
    return;
  } else {

  }
  if (ldv_work_1_2 == 0) {
    ldv_work_struct_1_2 = work;
    ldv_work_1_2 = state;
    return;
  } else {

  }
  if (ldv_work_1_3 == 0) {
    ldv_work_struct_1_3 = work;
    ldv_work_1_3 = state;
    return;
  } else {

  }
  return;
}
}
void choose_timer_4(void) 
{ 
  int tmp ;

  {
  tmp = __VERIFIER_nondet_int();
  switch (tmp) {
  case 0: ;
  if (ldv_timer_4_0 == 1) {
    ldv_timer_4_0 = 2;
    ldv_timer_4(ldv_timer_4_0, ldv_timer_list_4_0);
  } else {

  }
  goto ldv_35522;
  case 1: ;
  if (ldv_timer_4_1 == 1) {
    ldv_timer_4_1 = 2;
    ldv_timer_4(ldv_timer_4_1, ldv_timer_list_4_1);
  } else {

  }
  goto ldv_35522;
  case 2: ;
  if (ldv_timer_4_2 == 1) {
    ldv_timer_4_2 = 2;
    ldv_timer_4(ldv_timer_4_2, ldv_timer_list_4_2);
  } else {

  }
  goto ldv_35522;
  case 3: ;
  if (ldv_timer_4_3 == 1) {
    ldv_timer_4_3 = 2;
    ldv_timer_4(ldv_timer_4_3, ldv_timer_list_4_3);
  } else {

  }
  goto ldv_35522;
  default: 
  ldv_stop();
  }
  ldv_35522: ;
  return;
}
}
void call_and_disable_work_3(struct work_struct *work ) 
{ 


  {
  if ((ldv_work_3_0 == 2 || ldv_work_3_0 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_3_0) {
    dwc2_hcd_reset_func(work);
    ldv_work_3_0 = 1;
    return;
  } else {

  }
  if ((ldv_work_3_1 == 2 || ldv_work_3_1 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_3_1) {
    dwc2_hcd_reset_func(work);
    ldv_work_3_1 = 1;
    return;
  } else {

  }
  if ((ldv_work_3_2 == 2 || ldv_work_3_2 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_3_2) {
    dwc2_hcd_reset_func(work);
    ldv_work_3_2 = 1;
    return;
  } else {

  }
  if ((ldv_work_3_3 == 2 || ldv_work_3_3 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_3_3) {
    dwc2_hcd_reset_func(work);
    ldv_work_3_3 = 1;
    return;
  } else {

  }
  return;
}
}
void disable_suitable_timer_4(struct timer_list *timer ) 
{ 


  {
  if (ldv_timer_4_0 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_4_0) {
    ldv_timer_4_0 = 0;
    return;
  } else {

  }
  if (ldv_timer_4_1 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_4_1) {
    ldv_timer_4_1 = 0;
    return;
  } else {

  }
  if (ldv_timer_4_2 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_4_2) {
    ldv_timer_4_2 = 0;
    return;
  } else {

  }
  if (ldv_timer_4_3 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_4_3) {
    ldv_timer_4_3 = 0;
    return;
  } else {

  }
  return;
}
}
void disable_work_3(struct work_struct *work ) 
{ 


  {
  if ((ldv_work_3_0 == 3 || ldv_work_3_0 == 2) && (unsigned long )ldv_work_struct_3_0 == (unsigned long )work) {
    ldv_work_3_0 = 1;
  } else {

  }
  if ((ldv_work_3_1 == 3 || ldv_work_3_1 == 2) && (unsigned long )ldv_work_struct_3_1 == (unsigned long )work) {
    ldv_work_3_1 = 1;
  } else {

  }
  if ((ldv_work_3_2 == 3 || ldv_work_3_2 == 2) && (unsigned long )ldv_work_struct_3_2 == (unsigned long )work) {
    ldv_work_3_2 = 1;
  } else {

  }
  if ((ldv_work_3_3 == 3 || ldv_work_3_3 == 2) && (unsigned long )ldv_work_struct_3_3 == (unsigned long )work) {
    ldv_work_3_3 = 1;
  } else {

  }
  return;
}
}
void disable_work_2(struct work_struct *work ) 
{ 


  {
  if ((ldv_work_2_0 == 3 || ldv_work_2_0 == 2) && (unsigned long )ldv_work_struct_2_0 == (unsigned long )work) {
    ldv_work_2_0 = 1;
  } else {

  }
  if ((ldv_work_2_1 == 3 || ldv_work_2_1 == 2) && (unsigned long )ldv_work_struct_2_1 == (unsigned long )work) {
    ldv_work_2_1 = 1;
  } else {

  }
  if ((ldv_work_2_2 == 3 || ldv_work_2_2 == 2) && (unsigned long )ldv_work_struct_2_2 == (unsigned long )work) {
    ldv_work_2_2 = 1;
  } else {

  }
  if ((ldv_work_2_3 == 3 || ldv_work_2_3 == 2) && (unsigned long )ldv_work_struct_2_3 == (unsigned long )work) {
    ldv_work_2_3 = 1;
  } else {

  }
  return;
}
}
void disable_work_1(struct work_struct *work ) 
{ 


  {
  if ((ldv_work_1_0 == 3 || ldv_work_1_0 == 2) && (unsigned long )ldv_work_struct_1_0 == (unsigned long )work) {
    ldv_work_1_0 = 1;
  } else {

  }
  if ((ldv_work_1_1 == 3 || ldv_work_1_1 == 2) && (unsigned long )ldv_work_struct_1_1 == (unsigned long )work) {
    ldv_work_1_1 = 1;
  } else {

  }
  if ((ldv_work_1_2 == 3 || ldv_work_1_2 == 2) && (unsigned long )ldv_work_struct_1_2 == (unsigned long )work) {
    ldv_work_1_2 = 1;
  } else {

  }
  if ((ldv_work_1_3 == 3 || ldv_work_1_3 == 2) && (unsigned long )ldv_work_struct_1_3 == (unsigned long )work) {
    ldv_work_1_3 = 1;
  } else {

  }
  return;
}
}
int reg_timer_4(struct timer_list *timer , void (*function)(unsigned long  ) , unsigned long data ) 
{ 


  {
  if ((unsigned long )function == (unsigned long )(& dwc2_wakeup_detected)) {
    activate_suitable_timer_4(timer, data);
  } else {

  }
  return (0);
}
}
void invoke_work_3(void) 
{ 
  int tmp ;

  {
  tmp = __VERIFIER_nondet_int();
  switch (tmp) {
  case 0: ;
  if (ldv_work_3_0 == 2 || ldv_work_3_0 == 3) {
    ldv_work_3_0 = 4;
    dwc2_hcd_reset_func(ldv_work_struct_3_0);
    ldv_work_3_0 = 1;
  } else {

  }
  goto ldv_35556;
  case 1: ;
  if (ldv_work_3_1 == 2 || ldv_work_3_1 == 3) {
    ldv_work_3_1 = 4;
    dwc2_hcd_reset_func(ldv_work_struct_3_0);
    ldv_work_3_1 = 1;
  } else {

  }
  goto ldv_35556;
  case 2: ;
  if (ldv_work_3_2 == 2 || ldv_work_3_2 == 3) {
    ldv_work_3_2 = 4;
    dwc2_hcd_reset_func(ldv_work_struct_3_0);
    ldv_work_3_2 = 1;
  } else {

  }
  goto ldv_35556;
  case 3: ;
  if (ldv_work_3_3 == 2 || ldv_work_3_3 == 3) {
    ldv_work_3_3 = 4;
    dwc2_hcd_reset_func(ldv_work_struct_3_0);
    ldv_work_3_3 = 1;
  } else {

  }
  goto ldv_35556;
  default: 
  ldv_stop();
  }
  ldv_35556: ;
  return;
}
}
void work_init_1(void) 
{ 


  {
  ldv_work_1_0 = 0;
  ldv_work_1_1 = 0;
  ldv_work_1_2 = 0;
  ldv_work_1_3 = 0;
  return;
}
}
void invoke_work_1(void) 
{ 
  int tmp ;

  {
  tmp = __VERIFIER_nondet_int();
  switch (tmp) {
  case 0: ;
  if (ldv_work_1_0 == 2 || ldv_work_1_0 == 3) {
    ldv_work_1_0 = 4;
    dwc2_conn_id_status_change(ldv_work_struct_1_0);
    ldv_work_1_0 = 1;
  } else {

  }
  goto ldv_35570;
  case 1: ;
  if (ldv_work_1_1 == 2 || ldv_work_1_1 == 3) {
    ldv_work_1_1 = 4;
    dwc2_conn_id_status_change(ldv_work_struct_1_0);
    ldv_work_1_1 = 1;
  } else {

  }
  goto ldv_35570;
  case 2: ;
  if (ldv_work_1_2 == 2 || ldv_work_1_2 == 3) {
    ldv_work_1_2 = 4;
    dwc2_conn_id_status_change(ldv_work_struct_1_0);
    ldv_work_1_2 = 1;
  } else {

  }
  goto ldv_35570;
  case 3: ;
  if (ldv_work_1_3 == 2 || ldv_work_1_3 == 3) {
    ldv_work_1_3 = 4;
    dwc2_conn_id_status_change(ldv_work_struct_1_0);
    ldv_work_1_3 = 1;
  } else {

  }
  goto ldv_35570;
  default: 
  ldv_stop();
  }
  ldv_35570: ;
  return;
}
}
void call_and_disable_all_3(int state ) 
{ 


  {
  if (ldv_work_3_0 == state) {
    call_and_disable_work_3(ldv_work_struct_3_0);
  } else {

  }
  if (ldv_work_3_1 == state) {
    call_and_disable_work_3(ldv_work_struct_3_1);
  } else {

  }
  if (ldv_work_3_2 == state) {
    call_and_disable_work_3(ldv_work_struct_3_2);
  } else {

  }
  if (ldv_work_3_3 == state) {
    call_and_disable_work_3(ldv_work_struct_3_3);
  } else {

  }
  return;
}
}
void ldv_timer_4(int state , struct timer_list *timer ) 
{ 


  {
  LDV_IN_INTERRUPT = 2;
  dwc2_wakeup_detected(timer->data);
  LDV_IN_INTERRUPT = 1;
  return;
}
}
void activate_suitable_timer_4(struct timer_list *timer , unsigned long data ) 
{ 


  {
  if (ldv_timer_4_0 == 0 || ldv_timer_4_0 == 2) {
    ldv_timer_list_4_0 = timer;
    ldv_timer_list_4_0->data = data;
    ldv_timer_4_0 = 1;
    return;
  } else {

  }
  if (ldv_timer_4_1 == 0 || ldv_timer_4_1 == 2) {
    ldv_timer_list_4_1 = timer;
    ldv_timer_list_4_1->data = data;
    ldv_timer_4_1 = 1;
    return;
  } else {

  }
  if (ldv_timer_4_2 == 0 || ldv_timer_4_2 == 2) {
    ldv_timer_list_4_2 = timer;
    ldv_timer_list_4_2->data = data;
    ldv_timer_4_2 = 1;
    return;
  } else {

  }
  if (ldv_timer_4_3 == 0 || ldv_timer_4_3 == 2) {
    ldv_timer_list_4_3 = timer;
    ldv_timer_list_4_3->data = data;
    ldv_timer_4_3 = 1;
    return;
  } else {

  }
  return;
}
}
void call_and_disable_work_2(struct work_struct *work ) 
{ 


  {
  if ((ldv_work_2_0 == 2 || ldv_work_2_0 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_2_0) {
    dwc2_hcd_start_func(work);
    ldv_work_2_0 = 1;
    return;
  } else {

  }
  if ((ldv_work_2_1 == 2 || ldv_work_2_1 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_2_1) {
    dwc2_hcd_start_func(work);
    ldv_work_2_1 = 1;
    return;
  } else {

  }
  if ((ldv_work_2_2 == 2 || ldv_work_2_2 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_2_2) {
    dwc2_hcd_start_func(work);
    ldv_work_2_2 = 1;
    return;
  } else {

  }
  if ((ldv_work_2_3 == 2 || ldv_work_2_3 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_2_3) {
    dwc2_hcd_start_func(work);
    ldv_work_2_3 = 1;
    return;
  } else {

  }
  return;
}
}
void invoke_work_2(void) 
{ 
  int tmp ;

  {
  tmp = __VERIFIER_nondet_int();
  switch (tmp) {
  case 0: ;
  if (ldv_work_2_0 == 2 || ldv_work_2_0 == 3) {
    ldv_work_2_0 = 4;
    dwc2_hcd_start_func(ldv_work_struct_2_0);
    ldv_work_2_0 = 1;
  } else {

  }
  goto ldv_35597;
  case 1: ;
  if (ldv_work_2_1 == 2 || ldv_work_2_1 == 3) {
    ldv_work_2_1 = 4;
    dwc2_hcd_start_func(ldv_work_struct_2_0);
    ldv_work_2_1 = 1;
  } else {

  }
  goto ldv_35597;
  case 2: ;
  if (ldv_work_2_2 == 2 || ldv_work_2_2 == 3) {
    ldv_work_2_2 = 4;
    dwc2_hcd_start_func(ldv_work_struct_2_0);
    ldv_work_2_2 = 1;
  } else {

  }
  goto ldv_35597;
  case 3: ;
  if (ldv_work_2_3 == 2 || ldv_work_2_3 == 3) {
    ldv_work_2_3 = 4;
    dwc2_hcd_start_func(ldv_work_struct_2_0);
    ldv_work_2_3 = 1;
  } else {

  }
  goto ldv_35597;
  default: 
  ldv_stop();
  }
  ldv_35597: ;
  return;
}
}
void ldv_initialize_hc_driver_11(void) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  tmp = ldv_init_zalloc(192UL);
  dwc2_hc_driver_group0 = (struct urb *)tmp;
  tmp___0 = ldv_init_zalloc(968UL);
  dwc2_hc_driver_group1 = (struct usb_hcd *)tmp___0;
  tmp___1 = ldv_init_zalloc(72UL);
  dwc2_hc_driver_group2 = (struct usb_host_endpoint *)tmp___1;
  return;
}
}
void ldv_main_exported_11(void) 
{ 
  char *ldvarg9 ;
  void *tmp ;
  gfp_t ldvarg10 ;
  u16 ldvarg8 ;
  u16 ldvarg6 ;
  u16 ldvarg5 ;
  int ldvarg12 ;
    klee_make_symbolic(&ldvarg12, sizeof(int), "ldvarg12");
  u16 ldvarg7 ;
  char *ldvarg11 ;
  void *tmp___0 ;
  int tmp___1 ;

  {
  tmp = ldv_init_zalloc(1UL);
  ldvarg9 = (char *)tmp;
  tmp___0 = ldv_init_zalloc(1UL);
  ldvarg11 = (char *)tmp___0;
  ldv_memset((void *)(& ldvarg10), 0, 4UL);
  ldv_memset((void *)(& ldvarg8), 0, 2UL);
  ldv_memset((void *)(& ldvarg6), 0, 2UL);
  ldv_memset((void *)(& ldvarg5), 0, 2UL);
  ldv_memset((void *)(& ldvarg12), 0, 4UL);
  ldv_memset((void *)(& ldvarg7), 0, 2UL);
  tmp___1 = __VERIFIER_nondet_int();
  switch (tmp___1) {
  case 0: ;
  if (ldv_state_variable_11 == 1) {
    ldv_retval_1 = _dwc2_hcd_start(dwc2_hc_driver_group1);
    if (ldv_retval_1 == 0) {
      ldv_state_variable_11 = 2;
      ref_cnt = ref_cnt + 1;
    } else {

    }
  } else {

  }
  goto ldv_35617;
  case 1: ;
  if (ldv_state_variable_11 == 1) {
    _dwc2_hcd_urb_dequeue(dwc2_hc_driver_group1, dwc2_hc_driver_group0, ldvarg12);
    ldv_state_variable_11 = 1;
  } else {

  }
  if (ldv_state_variable_11 == 2) {
    _dwc2_hcd_urb_dequeue(dwc2_hc_driver_group1, dwc2_hc_driver_group0, ldvarg12);
    ldv_state_variable_11 = 2;
  } else {

  }
  goto ldv_35617;
  case 2: ;
  if (ldv_state_variable_11 == 1) {
    _dwc2_hcd_endpoint_reset(dwc2_hc_driver_group1, dwc2_hc_driver_group2);
    ldv_state_variable_11 = 1;
  } else {

  }
  if (ldv_state_variable_11 == 2) {
    _dwc2_hcd_endpoint_reset(dwc2_hc_driver_group1, dwc2_hc_driver_group2);
    ldv_state_variable_11 = 2;
  } else {

  }
  goto ldv_35617;
  case 3: ;
  if (ldv_state_variable_11 == 1) {
    _dwc2_hcd_endpoint_disable(dwc2_hc_driver_group1, dwc2_hc_driver_group2);
    ldv_state_variable_11 = 1;
  } else {

  }
  if (ldv_state_variable_11 == 2) {
    _dwc2_hcd_endpoint_disable(dwc2_hc_driver_group1, dwc2_hc_driver_group2);
    ldv_state_variable_11 = 2;
  } else {

  }
  goto ldv_35617;
  case 4: ;
  if (ldv_state_variable_11 == 1) {
    _dwc2_hcd_resume(dwc2_hc_driver_group1);
    ldv_state_variable_11 = 1;
  } else {

  }
  if (ldv_state_variable_11 == 2) {
    _dwc2_hcd_resume(dwc2_hc_driver_group1);
    ldv_state_variable_11 = 2;
  } else {

  }
  goto ldv_35617;
  case 5: ;
  if (ldv_state_variable_11 == 1) {
    _dwc2_hcd_suspend(dwc2_hc_driver_group1);
    ldv_state_variable_11 = 1;
  } else {

  }
  if (ldv_state_variable_11 == 2) {
    _dwc2_hcd_suspend(dwc2_hc_driver_group1);
    ldv_state_variable_11 = 2;
  } else {

  }
  goto ldv_35617;
  case 6: ;
  if (ldv_state_variable_11 == 1) {
    _dwc2_hcd_clear_tt_buffer_complete(dwc2_hc_driver_group1, dwc2_hc_driver_group2);
    ldv_state_variable_11 = 1;
  } else {

  }
  if (ldv_state_variable_11 == 2) {
    _dwc2_hcd_clear_tt_buffer_complete(dwc2_hc_driver_group1, dwc2_hc_driver_group2);
    ldv_state_variable_11 = 2;
  } else {

  }
  goto ldv_35617;
  case 7: ;
  if (ldv_state_variable_11 == 1) {
    _dwc2_hcd_irq(dwc2_hc_driver_group1);
    ldv_state_variable_11 = 1;
  } else {

  }
  if (ldv_state_variable_11 == 2) {
    _dwc2_hcd_irq(dwc2_hc_driver_group1);
    ldv_state_variable_11 = 2;
  } else {

  }
  goto ldv_35617;
  case 8: ;
  if (ldv_state_variable_11 == 1) {
    _dwc2_hcd_hub_status_data(dwc2_hc_driver_group1, ldvarg11);
    ldv_state_variable_11 = 1;
  } else {

  }
  if (ldv_state_variable_11 == 2) {
    _dwc2_hcd_hub_status_data(dwc2_hc_driver_group1, ldvarg11);
    ldv_state_variable_11 = 2;
  } else {

  }
  goto ldv_35617;
  case 9: ;
  if (ldv_state_variable_11 == 2) {
    _dwc2_hcd_stop(dwc2_hc_driver_group1);
    ldv_state_variable_11 = 1;
    ref_cnt = ref_cnt - 1;
  } else {

  }
  goto ldv_35617;
  case 10: ;
  if (ldv_state_variable_11 == 1) {
    _dwc2_hcd_urb_enqueue(dwc2_hc_driver_group1, dwc2_hc_driver_group0, ldvarg10);
    ldv_state_variable_11 = 1;
  } else {

  }
  if (ldv_state_variable_11 == 2) {
    _dwc2_hcd_urb_enqueue(dwc2_hc_driver_group1, dwc2_hc_driver_group0, ldvarg10);
    ldv_state_variable_11 = 2;
  } else {

  }
  goto ldv_35617;
  case 11: ;
  if (ldv_state_variable_11 == 1) {
    _dwc2_hcd_hub_control(dwc2_hc_driver_group1, (int )ldvarg8, (int )ldvarg7, (int )ldvarg6,
                          ldvarg9, (int )ldvarg5);
    ldv_state_variable_11 = 1;
  } else {

  }
  if (ldv_state_variable_11 == 2) {
    _dwc2_hcd_hub_control(dwc2_hc_driver_group1, (int )ldvarg8, (int )ldvarg7, (int )ldvarg6,
                          ldvarg9, (int )ldvarg5);
    ldv_state_variable_11 = 2;
  } else {

  }
  goto ldv_35617;
  case 12: ;
  if (ldv_state_variable_11 == 1) {
    _dwc2_hcd_get_frame_number(dwc2_hc_driver_group1);
    ldv_state_variable_11 = 1;
  } else {

  }
  if (ldv_state_variable_11 == 2) {
    _dwc2_hcd_get_frame_number(dwc2_hc_driver_group1);
    ldv_state_variable_11 = 2;
  } else {

  }
  goto ldv_35617;
  default: 
  ldv_stop();
  }
  ldv_35617: ;
  return;
}
}
bool ldv_queue_work_on_53(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_3(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_delayed_work_on_54(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_3(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_work_on_55(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_3(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
void ldv_flush_workqueue_56(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
  flush_workqueue(ldv_func_arg1);
  call_and_disable_all_3(2);
  return;
}
}
bool ldv_queue_delayed_work_on_57(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_3(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
bool ldv_cancel_work_sync_58(struct work_struct *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___4 ldv_func_res ;
  bool tmp ;

  {
  tmp = cancel_work_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_work_3(ldv_func_arg1);
  return (ldv_func_res);
}
}
void ldv_flush_workqueue_59(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
  flush_workqueue(ldv_func_arg1);
  call_and_disable_all_3(2);
  return;
}
}
void ldv_destroy_workqueue_60(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
  destroy_workqueue(ldv_func_arg1);
  call_and_disable_all_3(2);
  return;
}
}
int ldv_del_timer_61(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___5 ldv_func_res ;
  int tmp ;

  {
  tmp = del_timer(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_suitable_timer_4(ldv_func_arg1);
  return (ldv_func_res);
}
}
__inline static long ldv__builtin_expect(long exp , long c ) ;
bool ldv_queue_work_on_75(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_work_on_77(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_delayed_work_on_76(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
bool ldv_queue_delayed_work_on_79(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
void ldv_flush_workqueue_78(struct workqueue_struct *ldv_func_arg1 ) ;
__inline static bool queue_delayed_work___0(struct workqueue_struct *wq , struct delayed_work *dwork ,
                                            unsigned long delay ) 
{ 
  bool tmp ;

  {
  tmp = ldv_queue_delayed_work_on_76(8192, wq, dwork, delay);
  return (tmp);
}
}
extern void debug_dma_unmap_page(struct device * , dma_addr_t  , size_t  , int  ,
                                 bool  ) ;
__inline static void dma_unmap_single_attrs(struct device *dev , dma_addr_t addr ,
                                            size_t size , enum dma_data_direction dir ,
                                            struct dma_attrs *attrs ) 
{ 
  struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
  tmp = get_dma_ops(dev);
  ops = tmp;
  tmp___0 = valid_dma_direction((int )dir);
  tmp___1 = ldv__builtin_expect(tmp___0 == 0, 0L);
  if (tmp___1 != 0L) {
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/asm-generic/dma-mapping-common.h"),
                         "i" (36), "i" (12UL));
    ldv_26523: ;
    goto ldv_26523;
  } else {

  }
  if ((unsigned long )ops->unmap_page != (unsigned long )((void (*)(struct device * ,
                                                                    dma_addr_t  ,
                                                                    size_t  , enum dma_data_direction  ,
                                                                    struct dma_attrs * ))0)) {
    (*(ops->unmap_page))(dev, addr, size, dir, attrs);
  } else {

  }
  debug_dma_unmap_page(dev, addr, size, (int )dir, 1);
  return;
}
}
extern int usb_hub_clear_tt_buffer(struct urb * ) ;
__inline static void disable_hc_int(struct dwc2_hsotg *hsotg , int chnum , u32 intr ) 
{ 
  u32 mask ;
  unsigned int tmp ;

  {
  tmp = readl((void const volatile   *)hsotg->regs + (unsigned long )(chnum * 32 + 1292));
  mask = tmp;
  mask = ~ intr & mask;
  writel(mask, (void volatile   *)hsotg->regs + (unsigned long )(chnum * 32 + 1292));
  return;
}
}
void dwc2_hcd_complete_xfer_ddma(struct dwc2_hsotg *hsotg , struct dwc2_host_chan *chan ,
                                 int chnum , enum dwc2_halt_status halt_status ) ;
__inline static int dwc2_frame_num_le(u16 frame1 , u16 frame2 ) 
{ 


  {
  return ((((int )frame2 - (int )frame1) & 16383) <= 8191);
}
}
__inline static u16 dwc2_full_frame_num(u16 frame ) 
{ 


  {
  return ((u16 )(((int )frame & 16383) >> 3));
}
}
__inline static u32 dwc2_read_core_intr(struct dwc2_hsotg *hsotg ) 
{ 
  unsigned int tmp ;
  unsigned int tmp___0 ;

  {
  tmp = readl((void const volatile   *)hsotg->regs + 20U);
  tmp___0 = readl((void const volatile   *)hsotg->regs + 24U);
  return (tmp & tmp___0);
}
}
void dwc2_hcd_save_data_toggle(struct dwc2_hsotg *hsotg , struct dwc2_host_chan *chan ,
                               int chnum , struct dwc2_qtd *qtd ) ;
static void dwc2_track_missed_sofs(struct dwc2_hsotg *hsotg ) 
{ 
  u16 curr_frame_number ;
  int i ;

  {
  curr_frame_number = hsotg->frame_number;
  if (hsotg->frame_num_idx <= 999) {
    if ((((int )hsotg->last_frame_num + 1) & 16383) != (int )curr_frame_number) {
      *(hsotg->frame_num_array + (unsigned long )hsotg->frame_num_idx) = curr_frame_number;
      *(hsotg->last_frame_num_array + (unsigned long )hsotg->frame_num_idx) = hsotg->last_frame_num;
      hsotg->frame_num_idx = hsotg->frame_num_idx + 1;
    } else {

    }
  } else
  if (hsotg->dumped_frame_num_array == 0) {
    _dev_info((struct device  const  *)hsotg->dev, "Frame     Last Frame\n");
    _dev_info((struct device  const  *)hsotg->dev, "-----     ----------\n");
    i = 0;
    goto ldv_34584;
    ldv_34583: 
    _dev_info((struct device  const  *)hsotg->dev, "0x%04x    0x%04x\n", (int )*(hsotg->frame_num_array + (unsigned long )i),
              (int )*(hsotg->last_frame_num_array + (unsigned long )i));
    i = i + 1;
    ldv_34584: ;
    if (i <= 999) {
      goto ldv_34583;
    } else {

    }
    hsotg->dumped_frame_num_array = 1;
  } else {

  }
  hsotg->last_frame_num = curr_frame_number;
  return;
}
}
static void dwc2_hc_handle_tt_clear(struct dwc2_hsotg *hsotg , struct dwc2_host_chan *chan ,
                                    struct dwc2_qtd *qtd ) 
{ 
  struct urb *usb_urb ;
  int tmp ;

  {
  if ((unsigned long )chan->qh == (unsigned long )((struct dwc2_qh *)0)) {
    return;
  } else {

  }
  if ((unsigned int )(chan->qh)->dev_speed == 3U) {
    return;
  } else {

  }
  if ((unsigned long )qtd->urb == (unsigned long )((struct dwc2_hcd_urb *)0)) {
    return;
  } else {

  }
  usb_urb = (struct urb *)(qtd->urb)->priv;
  if (((unsigned long )usb_urb == (unsigned long )((struct urb *)0) || (unsigned long )usb_urb->dev == (unsigned long )((struct usb_device *)0)) || (unsigned long )(usb_urb->dev)->tt == (unsigned long )((struct usb_tt *)0)) {
    return;
  } else {

  }
  if ((qtd->urb)->status != 4294967264U && (qtd->urb)->status != 4294967175U) {
    (chan->qh)->tt_buffer_dirty = 1U;
    tmp = usb_hub_clear_tt_buffer(usb_urb);
    if (tmp != 0) {
      (chan->qh)->tt_buffer_dirty = 0U;
    } else {

    }
  } else {

  }
  return;
}
}
static void dwc2_sof_intr(struct dwc2_hsotg *hsotg ) 
{ 
  struct list_head *qh_entry ;
  struct dwc2_qh *qh ;
  enum dwc2_transaction_type tr_type ;
  int tmp ;
  struct list_head  const  *__mptr ;
  int tmp___0 ;

  {
  tmp = dwc2_hcd_get_frame_number(hsotg);
  hsotg->frame_number = (u16 )tmp;
  dwc2_track_missed_sofs(hsotg);
  qh_entry = hsotg->periodic_sched_inactive.next;
  goto ldv_34601;
  ldv_34600: 
  __mptr = (struct list_head  const  *)qh_entry;
  qh = (struct dwc2_qh *)__mptr + 0xffffffffffffffa8UL;
  qh_entry = qh_entry->next;
  tmp___0 = dwc2_frame_num_le((int )qh->sched_frame, (int )hsotg->frame_number);
  if (tmp___0 != 0) {
    list_move(& qh->qh_list_entry, & hsotg->periodic_sched_ready);
  } else {

  }
  ldv_34601: ;
  if ((unsigned long )(& hsotg->periodic_sched_inactive) != (unsigned long )qh_entry) {
    goto ldv_34600;
  } else {

  }
  tr_type = dwc2_hcd_select_transactions(hsotg);
  if ((unsigned int )tr_type != 0U) {
    dwc2_hcd_queue_transactions(hsotg, tr_type);
  } else {

  }
  writel(8U, (void volatile   *)hsotg->regs + 20U);
  return;
}
}
static void dwc2_rx_fifo_level_intr(struct dwc2_hsotg *hsotg ) 
{ 
  u32 grxsts ;
  u32 chnum ;
  u32 bcnt ;
  u32 dpid ;
  u32 pktsts ;
  struct dwc2_host_chan *chan ;
  struct _ddebug descriptor ;
  long tmp ;
  bool tmp___0 ;
  struct _ddebug descriptor___0 ;
  long tmp___1 ;
  struct _ddebug descriptor___1 ;
  long tmp___2 ;
  struct _ddebug descriptor___2 ;
  long tmp___3 ;
  struct _ddebug descriptor___3 ;
  long tmp___4 ;
  bool tmp___5 ;

  {
  tmp___0 = dbg_perio();
  if ((int )tmp___0) {
    descriptor.modname = "dwc2";
    descriptor.function = "dwc2_rx_fifo_level_intr";
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd_intr.c";
    descriptor.format = "--RxFIFO Level Interrupt--\n";
    descriptor.lineno = 165U;
    descriptor.flags = 1U;
    tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
    if (tmp != 0L) {
      __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "--RxFIFO Level Interrupt--\n");
    } else {

    }
  } else {

  }
  grxsts = readl((void const volatile   *)hsotg->regs + 32U);
  chnum = grxsts & 15U;
  chan = hsotg->hc_ptr_array[chnum];
  if ((unsigned long )chan == (unsigned long )((struct dwc2_host_chan *)0)) {
    dev_err((struct device  const  *)hsotg->dev, "Unable to get corresponding channel\n");
    return;
  } else {

  }
  bcnt = (grxsts & 32752U) >> 4;
  dpid = (grxsts & 98304U) >> 15;
  pktsts = (grxsts & 1966080U) >> 17;
  tmp___5 = dbg_perio();
  if ((int )tmp___5) {
    descriptor___0.modname = "dwc2";
    descriptor___0.function = "dwc2_rx_fifo_level_intr";
    descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd_intr.c";
    descriptor___0.format = "    Ch num = %d\n";
    descriptor___0.lineno = 181U;
    descriptor___0.flags = 1U;
    tmp___1 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
    if (tmp___1 != 0L) {
      __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)hsotg->dev, "    Ch num = %d\n",
                        chnum);
    } else {

    }
    descriptor___1.modname = "dwc2";
    descriptor___1.function = "dwc2_rx_fifo_level_intr";
    descriptor___1.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd_intr.c";
    descriptor___1.format = "    Count = %d\n";
    descriptor___1.lineno = 182U;
    descriptor___1.flags = 1U;
    tmp___2 = ldv__builtin_expect((long )descriptor___1.flags & 1L, 0L);
    if (tmp___2 != 0L) {
      __dynamic_dev_dbg(& descriptor___1, (struct device  const  *)hsotg->dev, "    Count = %d\n",
                        bcnt);
    } else {

    }
    descriptor___2.modname = "dwc2";
    descriptor___2.function = "dwc2_rx_fifo_level_intr";
    descriptor___2.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd_intr.c";
    descriptor___2.format = "    DPID = %d, chan.dpid = %d\n";
    descriptor___2.lineno = 184U;
    descriptor___2.flags = 1U;
    tmp___3 = ldv__builtin_expect((long )descriptor___2.flags & 1L, 0L);
    if (tmp___3 != 0L) {
      __dynamic_dev_dbg(& descriptor___2, (struct device  const  *)hsotg->dev, "    DPID = %d, chan.dpid = %d\n",
                        dpid, (int )chan->data_pid_start);
    } else {

    }
    descriptor___3.modname = "dwc2";
    descriptor___3.function = "dwc2_rx_fifo_level_intr";
    descriptor___3.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd_intr.c";
    descriptor___3.format = "    PStatus = %d\n";
    descriptor___3.lineno = 185U;
    descriptor___3.flags = 1U;
    tmp___4 = ldv__builtin_expect((long )descriptor___3.flags & 1L, 0L);
    if (tmp___4 != 0L) {
      __dynamic_dev_dbg(& descriptor___3, (struct device  const  *)hsotg->dev, "    PStatus = %d\n",
                        pktsts);
    } else {

    }
  } else {

  }
  switch (pktsts) {
  case 2U: ;
  if (bcnt != 0U) {
    dwc2_read_packet(hsotg, chan->xfer_buf, (int )((u16 )bcnt));
    chan->xfer_count = chan->xfer_count + bcnt;
    chan->xfer_buf = chan->xfer_buf + (unsigned long )bcnt;
  } else {

  }
  goto ldv_34619;
  case 3U: ;
  case 5U: ;
  case 7U: ;
  goto ldv_34619;
  default: 
  dev_err((struct device  const  *)hsotg->dev, "RxFIFO Level Interrupt: Unknown status %d\n",
          pktsts);
  goto ldv_34619;
  }
  ldv_34619: ;
  return;
}
}
static void dwc2_np_tx_fifo_empty_intr(struct dwc2_hsotg *hsotg ) 
{ 
  struct _ddebug descriptor ;
  long tmp ;

  {
  descriptor.modname = "dwc2";
  descriptor.function = "dwc2_np_tx_fifo_empty_intr";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd_intr.c";
  descriptor.format = "--Non-Periodic TxFIFO Empty Interrupt--\n";
  descriptor.lineno = 219U;
  descriptor.flags = 1U;
  tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp != 0L) {
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "--Non-Periodic TxFIFO Empty Interrupt--\n");
  } else {

  }
  dwc2_hcd_queue_transactions(hsotg, 2);
  return;
}
}
static void dwc2_perio_tx_fifo_empty_intr(struct dwc2_hsotg *hsotg ) 
{ 
  struct _ddebug descriptor ;
  long tmp ;
  bool tmp___0 ;

  {
  tmp___0 = dbg_perio();
  if ((int )tmp___0) {
    descriptor.modname = "dwc2";
    descriptor.function = "dwc2_perio_tx_fifo_empty_intr";
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd_intr.c";
    descriptor.format = "--Periodic TxFIFO Empty Interrupt--\n";
    descriptor.lineno = 232U;
    descriptor.flags = 1U;
    tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
    if (tmp != 0L) {
      __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "--Periodic TxFIFO Empty Interrupt--\n");
    } else {

    }
  } else {

  }
  dwc2_hcd_queue_transactions(hsotg, 1);
  return;
}
}
static void dwc2_hprt0_enable(struct dwc2_hsotg *hsotg , u32 hprt0 , u32 *hprt0_modify ) 
{ 
  struct dwc2_core_params *params ;
  int do_reset ;
    klee_make_symbolic(&do_reset, sizeof(int), "do_reset");
  u32 usbcfg ;
  u32 prtspd ;
  u32 hcfg ;
  u32 fslspclksel ;
  u32 hfir ;
  struct _ddebug descriptor ;
  long tmp ;
  u32 tmp___0 ;
  struct _ddebug descriptor___0 ;
  long tmp___1 ;
  struct _ddebug descriptor___1 ;
  long tmp___2 ;
  unsigned long tmp___3 ;

  {
  params = hsotg->core_params;
  do_reset = 0;
  descriptor.modname = "dwc2";
  descriptor.function = "dwc2_hprt0_enable";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd_intr.c";
  descriptor.format = "%s(%p)\n";
  descriptor.lineno = 247U;
  descriptor.flags = 1U;
  tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp != 0L) {
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "%s(%p)\n",
                      "dwc2_hprt0_enable", hsotg);
  } else {

  }
  hfir = readl((void const volatile   *)hsotg->regs + 1028U);
  hfir = hfir & 4294901760U;
  tmp___0 = dwc2_calc_frame_interval(hsotg);
  hfir = (tmp___0 & 65535U) | hfir;
  writel(hfir, (void volatile   *)hsotg->regs + 1028U);
  if (params->host_support_fs_ls_low_power == 0) {
    hsotg->flags.b.port_reset_change = 1U;
    return;
  } else {

  }
  usbcfg = readl((void const volatile   *)hsotg->regs + 12U);
  prtspd = (hprt0 & 393216U) >> 17;
  if (prtspd == 2U || prtspd == 1U) {
    if ((usbcfg & 32768U) == 0U) {
      usbcfg = usbcfg | 32768U;
      writel(usbcfg, (void volatile   *)hsotg->regs + 12U);
      do_reset = 1;
    } else {

    }
    hcfg = readl((void const volatile   *)hsotg->regs + 1024U);
    fslspclksel = hcfg & 3U;
    if (prtspd == 2U && params->host_ls_low_power_phy_clk == 1) {
      descriptor___0.modname = "dwc2";
      descriptor___0.function = "dwc2_hprt0_enable";
      descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd_intr.c";
      descriptor___0.format = "FS_PHY programming HCFG to 6 MHz\n";
      descriptor___0.lineno = 284U;
      descriptor___0.flags = 1U;
      tmp___1 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
      if (tmp___1 != 0L) {
        __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)hsotg->dev, "FS_PHY programming HCFG to 6 MHz\n");
      } else {

      }
      if (fslspclksel != 2U) {
        fslspclksel = 2U;
        hcfg = hcfg & 4294967292U;
        hcfg = hcfg | fslspclksel;
        writel(hcfg, (void volatile   *)hsotg->regs + 1024U);
        do_reset = 1;
      } else {

      }
    } else {
      descriptor___1.modname = "dwc2";
      descriptor___1.function = "dwc2_hprt0_enable";
      descriptor___1.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd_intr.c";
      descriptor___1.format = "FS_PHY programming HCFG to 48 MHz\n";
      descriptor___1.lineno = 295U;
      descriptor___1.flags = 1U;
      tmp___2 = ldv__builtin_expect((long )descriptor___1.flags & 1L, 0L);
      if (tmp___2 != 0L) {
        __dynamic_dev_dbg(& descriptor___1, (struct device  const  *)hsotg->dev, "FS_PHY programming HCFG to 48 MHz\n");
      } else {

      }
      if (fslspclksel != 1U) {
        fslspclksel = 1U;
        hcfg = hcfg & 4294967292U;
        hcfg = hcfg | fslspclksel;
        writel(hcfg, (void volatile   *)hsotg->regs + 1024U);
        do_reset = 1;
      } else {

      }
    }
  } else
  if ((usbcfg & 32768U) != 0U) {
    usbcfg = usbcfg & 4294934527U;
    writel(usbcfg, (void volatile   *)hsotg->regs + 12U);
    do_reset = 1;
  } else {

  }
  if (do_reset != 0) {
    *hprt0_modify = *hprt0_modify | 256U;
    tmp___3 = msecs_to_jiffies(60U);
    queue_delayed_work___0(hsotg->wq_otg, & hsotg->reset_work, tmp___3);
  } else {
    hsotg->flags.b.port_reset_change = 1U;
  }
  return;
}
}
static void dwc2_port_intr(struct dwc2_hsotg *hsotg ) 
{ 
  u32 hprt0 ;
  u32 hprt0_modify ;
  struct _ddebug descriptor ;
  long tmp ;
  struct _ddebug descriptor___0 ;
  long tmp___0 ;
  struct _ddebug descriptor___1 ;
  long tmp___1 ;
  struct _ddebug descriptor___2 ;
  long tmp___2 ;

  {
  descriptor.modname = "dwc2";
  descriptor.function = "dwc2_port_intr";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd_intr.c";
  descriptor.format = "--Port Interrupt--\n";
  descriptor.lineno = 333U;
  descriptor.flags = 1U;
  tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp != 0L) {
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "--Port Interrupt--\n");
  } else {

  }
  hprt0 = readl((void const volatile   *)hsotg->regs + 1088U);
  hprt0_modify = hprt0;
  hprt0_modify = hprt0_modify & 4294967249U;
  if ((hprt0 & 2U) != 0U) {
    descriptor___0.modname = "dwc2";
    descriptor___0.function = "dwc2_port_intr";
    descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd_intr.c";
    descriptor___0.format = "--Port Interrupt HPRT0=0x%08x Port Connect Detected--\n";
    descriptor___0.lineno = 352U;
    descriptor___0.flags = 1U;
    tmp___0 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
    if (tmp___0 != 0L) {
      __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)hsotg->dev, "--Port Interrupt HPRT0=0x%08x Port Connect Detected--\n",
                        hprt0);
    } else {

    }
    if ((unsigned int )hsotg->lx_state != 0U) {
      usb_hcd_resume_root_hub((struct usb_hcd *)hsotg->priv);
    } else {

    }
    hsotg->flags.b.port_connect_status_change = 1U;
    hsotg->flags.b.port_connect_status = 1U;
    hprt0_modify = hprt0_modify | 2U;
  } else {

  }
  if ((hprt0 & 8U) != 0U) {
    descriptor___1.modname = "dwc2";
    descriptor___1.function = "dwc2_port_intr";
    descriptor___1.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd_intr.c";
    descriptor___1.format = "  --Port Interrupt HPRT0=0x%08x Port Enable Changed (now %d)--\n";
    descriptor___1.lineno = 373U;
    descriptor___1.flags = 1U;
    tmp___1 = ldv__builtin_expect((long )descriptor___1.flags & 1L, 0L);
    if (tmp___1 != 0L) {
      __dynamic_dev_dbg(& descriptor___1, (struct device  const  *)hsotg->dev, "  --Port Interrupt HPRT0=0x%08x Port Enable Changed (now %d)--\n",
                        hprt0, (hprt0 & 4U) != 0U);
    } else {

    }
    hprt0_modify = hprt0_modify | 8U;
    if ((hprt0 & 4U) != 0U) {
      dwc2_hprt0_enable(hsotg, hprt0, & hprt0_modify);
    } else {
      hsotg->flags.b.port_enable_change = 1U;
    }
  } else {

  }
  if ((hprt0 & 32U) != 0U) {
    descriptor___2.modname = "dwc2";
    descriptor___2.function = "dwc2_port_intr";
    descriptor___2.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd_intr.c";
    descriptor___2.format = "  --Port Interrupt HPRT0=0x%08x Port Overcurrent Changed--\n";
    descriptor___2.lineno = 385U;
    descriptor___2.flags = 1U;
    tmp___2 = ldv__builtin_expect((long )descriptor___2.flags & 1L, 0L);
    if (tmp___2 != 0L) {
      __dynamic_dev_dbg(& descriptor___2, (struct device  const  *)hsotg->dev, "  --Port Interrupt HPRT0=0x%08x Port Overcurrent Changed--\n",
                        hprt0);
    } else {

    }
    hsotg->flags.b.port_over_current_change = 1U;
    hprt0_modify = hprt0_modify | 32U;
  } else {

  }
  writel(hprt0_modify, (void volatile   *)hsotg->regs + 1088U);
  return;
}
}
static u32 dwc2_get_actual_xfer_length(struct dwc2_hsotg *hsotg , struct dwc2_host_chan *chan ,
                                       int chnum , struct dwc2_qtd *qtd , enum dwc2_halt_status halt_status ,
                                       int *short_read ) 
{ 
  u32 hctsiz ;
  u32 count ;
  u32 length ;

  {
  hctsiz = readl((void const volatile   *)hsotg->regs + (unsigned long )(chnum * 32 + 1296));
  if ((unsigned int )halt_status == 1U) {
    if ((unsigned int )*((unsigned char *)chan + 2UL) != 0U) {
      count = hctsiz & 524287U;
      length = chan->xfer_len - count;
      if ((unsigned long )short_read != (unsigned long )((int *)0)) {
        *short_read = count != 0U;
      } else {

      }
    } else
    if ((unsigned int )(chan->qh)->do_split != 0U) {
      length = qtd->ssplit_out_xfer_count;
    } else {
      length = chan->xfer_len;
    }
  } else {
    count = (hctsiz & 536346624U) >> 19;
    length = ((u32 )chan->start_pkt_count - count) * (u32 )chan->max_packet;
  }
  return (length);
}
}
static int dwc2_update_urb_state(struct dwc2_hsotg *hsotg , struct dwc2_host_chan *chan ,
                                 int chnum , struct dwc2_hcd_urb *urb , struct dwc2_qtd *qtd ) 
{ 
  u32 hctsiz ;
  int xfer_done ;
    klee_make_symbolic(&xfer_done, sizeof(int), "xfer_done");
  int short_read ;
    klee_make_symbolic(&short_read, sizeof(int), "short_read");
  int xfer_length ;
    klee_make_symbolic(&xfer_length, sizeof(int), "xfer_length");
  u32 tmp ;
  struct _ddebug descriptor ;
  long tmp___0 ;
  struct _ddebug descriptor___0 ;
  long tmp___1 ;
  struct _ddebug descriptor___1 ;
  long tmp___2 ;
  struct _ddebug descriptor___2 ;
  long tmp___3 ;
  struct _ddebug descriptor___3 ;
  long tmp___4 ;
  struct _ddebug descriptor___4 ;
  long tmp___5 ;
  struct _ddebug descriptor___5 ;
  long tmp___6 ;
  struct _ddebug descriptor___6 ;
  long tmp___7 ;

  {
  xfer_done = 0;
  short_read = 0;
  tmp = dwc2_get_actual_xfer_length(hsotg, chan, chnum, qtd, 1, & short_read);
  xfer_length = (int )tmp;
  if (urb->actual_length + (u32 )xfer_length > urb->length) {
    dev_warn((struct device  const  *)hsotg->dev, "%s(): trimming xfer length\n",
             "dwc2_update_urb_state");
    xfer_length = (int )(urb->length - urb->actual_length);
  } else {

  }
  if (chan->align_buf != 0ULL && xfer_length != 0) {
    descriptor.modname = "dwc2";
    descriptor.function = "dwc2_update_urb_state";
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd_intr.c";
    descriptor.format = "%s(): non-aligned buffer\n";
    descriptor.lineno = 470U;
    descriptor.flags = 1U;
    tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
    if (tmp___0 != 0L) {
      __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "%s(): non-aligned buffer\n",
                        "dwc2_update_urb_state");
    } else {

    }
    dma_unmap_single_attrs(hsotg->dev, (chan->qh)->dw_align_buf_dma, (size_t )(chan->qh)->dw_align_buf_size,
                           (unsigned int )*((unsigned char *)chan + 2UL) != 0U ? 2 : 1,
                           (struct dma_attrs *)0);
    if ((unsigned int )*((unsigned char *)chan + 2UL) != 0U) {
      memcpy(urb->buf + (unsigned long )urb->actual_length, (void const   *)(chan->qh)->dw_align_buf,
               (size_t )xfer_length);
    } else {

    }
  } else {

  }
  descriptor___0.modname = "dwc2";
  descriptor___0.function = "dwc2_update_urb_state";
  descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd_intr.c";
  descriptor___0.format = "urb->actual_length=%d xfer_length=%d\n";
  descriptor___0.lineno = 481U;
  descriptor___0.flags = 1U;
  tmp___1 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
  if (tmp___1 != 0L) {
    __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)hsotg->dev, "urb->actual_length=%d xfer_length=%d\n",
                      urb->actual_length, xfer_length);
  } else {

  }
  urb->actual_length = urb->actual_length + (u32 )xfer_length;
  if ((((xfer_length != 0 && (unsigned int )*((unsigned char *)chan + 3UL) == 2U) && (urb->flags & 2U) != 0U) && urb->actual_length >= urb->length) && urb->length % (u32 )chan->max_packet == 0U) {
    xfer_done = 0;
  } else
  if (short_read != 0 || urb->actual_length >= urb->length) {
    xfer_done = 1;
    urb->status = 0U;
  } else {

  }
  hctsiz = readl((void const volatile   *)hsotg->regs + (unsigned long )(chnum * 32 + 1296));
  descriptor___1.modname = "dwc2";
  descriptor___1.function = "dwc2_update_urb_state";
  descriptor___1.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd_intr.c";
  descriptor___1.format = "DWC_otg: %s: %s, channel %d\n";
  descriptor___1.lineno = 496U;
  descriptor___1.flags = 1U;
  tmp___2 = ldv__builtin_expect((long )descriptor___1.flags & 1L, 0L);
  if (tmp___2 != 0L) {
    __dynamic_dev_dbg(& descriptor___1, (struct device  const  *)hsotg->dev, "DWC_otg: %s: %s, channel %d\n",
                      "dwc2_update_urb_state", (unsigned int )*((unsigned char *)chan + 2UL) != 0U ? (char *)"IN" : (char *)"OUT",
                      chnum);
  } else {

  }
  descriptor___2.modname = "dwc2";
  descriptor___2.function = "dwc2_update_urb_state";
  descriptor___2.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd_intr.c";
  descriptor___2.format = "  chan->xfer_len %d\n";
  descriptor___2.lineno = 497U;
  descriptor___2.flags = 1U;
  tmp___3 = ldv__builtin_expect((long )descriptor___2.flags & 1L, 0L);
  if (tmp___3 != 0L) {
    __dynamic_dev_dbg(& descriptor___2, (struct device  const  *)hsotg->dev, "  chan->xfer_len %d\n",
                      chan->xfer_len);
  } else {

  }
  descriptor___3.modname = "dwc2";
  descriptor___3.function = "dwc2_update_urb_state";
  descriptor___3.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd_intr.c";
  descriptor___3.format = "  hctsiz.xfersize %d\n";
  descriptor___3.lineno = 499U;
  descriptor___3.flags = 1U;
  tmp___4 = ldv__builtin_expect((long )descriptor___3.flags & 1L, 0L);
  if (tmp___4 != 0L) {
    __dynamic_dev_dbg(& descriptor___3, (struct device  const  *)hsotg->dev, "  hctsiz.xfersize %d\n",
                      hctsiz & 524287U);
  } else {

  }
  descriptor___4.modname = "dwc2";
  descriptor___4.function = "dwc2_update_urb_state";
  descriptor___4.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd_intr.c";
  descriptor___4.format = "  urb->transfer_buffer_length %d\n";
  descriptor___4.lineno = 500U;
  descriptor___4.flags = 1U;
  tmp___5 = ldv__builtin_expect((long )descriptor___4.flags & 1L, 0L);
  if (tmp___5 != 0L) {
    __dynamic_dev_dbg(& descriptor___4, (struct device  const  *)hsotg->dev, "  urb->transfer_buffer_length %d\n",
                      urb->length);
  } else {

  }
  descriptor___5.modname = "dwc2";
  descriptor___5.function = "dwc2_update_urb_state";
  descriptor___5.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd_intr.c";
  descriptor___5.format = "  urb->actual_length %d\n";
  descriptor___5.lineno = 501U;
  descriptor___5.flags = 1U;
  tmp___6 = ldv__builtin_expect((long )descriptor___5.flags & 1L, 0L);
  if (tmp___6 != 0L) {
    __dynamic_dev_dbg(& descriptor___5, (struct device  const  *)hsotg->dev, "  urb->actual_length %d\n",
                      urb->actual_length);
  } else {

  }
  descriptor___6.modname = "dwc2";
  descriptor___6.function = "dwc2_update_urb_state";
  descriptor___6.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd_intr.c";
  descriptor___6.format = "  short_read %d, xfer_done %d\n";
  descriptor___6.lineno = 503U;
  descriptor___6.flags = 1U;
  tmp___7 = ldv__builtin_expect((long )descriptor___6.flags & 1L, 0L);
  if (tmp___7 != 0L) {
    __dynamic_dev_dbg(& descriptor___6, (struct device  const  *)hsotg->dev, "  short_read %d, xfer_done %d\n",
                      short_read, xfer_done);
  } else {

  }
  return (xfer_done);
}
}
void dwc2_hcd_save_data_toggle(struct dwc2_hsotg *hsotg , struct dwc2_host_chan *chan ,
                               int chnum , struct dwc2_qtd *qtd ) 
{ 
  u32 hctsiz ;
  unsigned int tmp ;
  u32 pid ;

  {
  tmp = readl((void const volatile   *)hsotg->regs + (unsigned long )(chnum * 32 + 1296));
  hctsiz = tmp;
  pid = (hctsiz & 1610612736U) >> 29;
  if ((unsigned int )*((unsigned char *)chan + 3UL) != 0U) {
    if (pid == 0U) {
      (chan->qh)->data_toggle = 0U;
    } else {
      (chan->qh)->data_toggle = 2U;
    }
  } else
  if (pid == 0U) {
    qtd->data_toggle = 0U;
  } else {
    qtd->data_toggle = 2U;
  }
  return;
}
}
static enum dwc2_halt_status dwc2_update_isoc_urb_state(struct dwc2_hsotg *hsotg ,
                                                        struct dwc2_host_chan *chan ,
                                                        int chnum , struct dwc2_qtd *qtd ,
                                                        enum dwc2_halt_status halt_status ) 
{ 
  struct dwc2_hcd_iso_packet_desc *frame_desc ;
  struct dwc2_hcd_urb *urb ;
  struct _ddebug descriptor ;
  long tmp ;
  struct _ddebug descriptor___0 ;
  long tmp___0 ;

  {
  urb = qtd->urb;
  if ((unsigned long )urb == (unsigned long )((struct dwc2_hcd_urb *)0)) {
    return (0);
  } else {

  }
  frame_desc = (struct dwc2_hcd_iso_packet_desc *)(& urb->iso_descs) + (unsigned long )qtd->isoc_frame_index;
  switch ((unsigned int )halt_status) {
  case 1U: 
  frame_desc->status = 0U;
  frame_desc->actual_length = dwc2_get_actual_xfer_length(hsotg, chan, chnum, qtd,
                                                          halt_status, (int *)0);
  if (chan->align_buf != 0ULL && frame_desc->actual_length != 0U) {
    descriptor.modname = "dwc2";
    descriptor.function = "dwc2_update_isoc_urb_state";
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd_intr.c";
    descriptor.format = "%s(): non-aligned buffer\n";
    descriptor.lineno = 565U;
    descriptor.flags = 1U;
    tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
    if (tmp != 0L) {
      __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "%s(): non-aligned buffer\n",
                        "dwc2_update_isoc_urb_state");
    } else {

    }
    dma_unmap_single_attrs(hsotg->dev, (chan->qh)->dw_align_buf_dma, (size_t )(chan->qh)->dw_align_buf_size,
                           (unsigned int )*((unsigned char *)chan + 2UL) != 0U ? 2 : 1,
                           (struct dma_attrs *)0);
    if ((unsigned int )*((unsigned char *)chan + 2UL) != 0U) {
      memcpy(urb->buf + ((unsigned long )frame_desc->offset + (unsigned long )qtd->isoc_split_offset),
               (void const   *)(chan->qh)->dw_align_buf, (size_t )frame_desc->actual_length);
    } else {

    }
  } else {

  }
  goto ldv_34711;
  case 8U: 
  urb->error_count = urb->error_count + 1U;
  if ((unsigned int )*((unsigned char *)chan + 2UL) != 0U) {
    frame_desc->status = 4294967233U;
  } else {
    frame_desc->status = 4294967226U;
  }
  frame_desc->actual_length = 0U;
  goto ldv_34711;
  case 9U: 
  urb->error_count = urb->error_count + 1U;
  frame_desc->status = 4294967221U;
  goto ldv_34711;
  case 7U: 
  urb->error_count = urb->error_count + 1U;
  frame_desc->status = 4294967225U;
  frame_desc->actual_length = dwc2_get_actual_xfer_length(hsotg, chan, chnum, qtd,
                                                          halt_status, (int *)0);
  if (chan->align_buf != 0ULL && frame_desc->actual_length != 0U) {
    descriptor___0.modname = "dwc2";
    descriptor___0.function = "dwc2_update_isoc_urb_state";
    descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd_intr.c";
    descriptor___0.format = "%s(): non-aligned buffer\n";
    descriptor___0.lineno = 599U;
    descriptor___0.flags = 1U;
    tmp___0 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
    if (tmp___0 != 0L) {
      __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)hsotg->dev, "%s(): non-aligned buffer\n",
                        "dwc2_update_isoc_urb_state");
    } else {

    }
    dma_unmap_single_attrs(hsotg->dev, (chan->qh)->dw_align_buf_dma, (size_t )(chan->qh)->dw_align_buf_size,
                           (unsigned int )*((unsigned char *)chan + 2UL) != 0U ? 2 : 1,
                           (struct dma_attrs *)0);
    if ((unsigned int )*((unsigned char *)chan + 2UL) != 0U) {
      memcpy(urb->buf + ((unsigned long )frame_desc->offset + (unsigned long )qtd->isoc_split_offset),
               (void const   *)(chan->qh)->dw_align_buf, (size_t )frame_desc->actual_length);
    } else {

    }
  } else {

  }
  if ((((unsigned int )(chan->qh)->do_split != 0U && (unsigned int )*((unsigned char *)chan + 3UL) == 1U) && (unsigned int )*((unsigned char *)chan + 2UL) != 0U) && (hsotg->core_params)->dma_enable > 0) {
    qtd->complete_split = 0U;
    qtd->isoc_split_offset = 0U;
  } else {

  }
  goto ldv_34711;
  default: 
  dev_err((struct device  const  *)hsotg->dev, "Unhandled halt_status (%d)\n", (unsigned int )halt_status);
  goto ldv_34711;
  }
  ldv_34711: 
  qtd->isoc_frame_index = (u16 )((int )qtd->isoc_frame_index + 1);
  if ((u32 )qtd->isoc_frame_index == urb->packet_count) {
    dwc2_host_complete(hsotg, qtd, 0);
    halt_status = 2;
  } else {
    halt_status = 1;
  }
  return (halt_status);
}
}
static void dwc2_deactivate_qh(struct dwc2_hsotg *hsotg , struct dwc2_qh *qh , int free_qtd ) 
{ 
  int continue_split ;
    klee_make_symbolic(&continue_split, sizeof(int), "continue_split");
  struct dwc2_qtd *qtd ;
  struct _ddebug descriptor ;
  long tmp ;
  bool tmp___0 ;
  struct _ddebug descriptor___0 ;
  long tmp___1 ;
  int tmp___2 ;
  struct list_head  const  *__mptr ;

  {
  continue_split = 0;
  tmp___0 = dbg_qh(qh);
  if ((int )tmp___0) {
    descriptor.modname = "dwc2";
    descriptor.function = "dwc2_deactivate_qh";
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd_intr.c";
    descriptor.format = "  %s(%p,%p,%d)\n";
    descriptor.lineno = 655U;
    descriptor.flags = 1U;
    tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
    if (tmp != 0L) {
      __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "  %s(%p,%p,%d)\n",
                        "dwc2_deactivate_qh", hsotg, qh, free_qtd);
    } else {

    }
  } else {

  }
  tmp___2 = list_empty((struct list_head  const  *)(& qh->qtd_list));
  if (tmp___2 != 0) {
    descriptor___0.modname = "dwc2";
    descriptor___0.function = "dwc2_deactivate_qh";
    descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd_intr.c";
    descriptor___0.format = "## QTD list empty ##\n";
    descriptor___0.lineno = 658U;
    descriptor___0.flags = 1U;
    tmp___1 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
    if (tmp___1 != 0L) {
      __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)hsotg->dev, "## QTD list empty ##\n");
    } else {

    }
    goto no_qtd;
  } else {

  }
  __mptr = (struct list_head  const  *)qh->qtd_list.next;
  qtd = (struct dwc2_qtd *)__mptr + 0xffffffffffffffd8UL;
  if ((unsigned int )qtd->complete_split != 0U) {
    continue_split = 1;
  } else
  if ((unsigned int )qtd->isoc_split_pos == 0U || (unsigned int )qtd->isoc_split_pos == 1U) {
    continue_split = 1;
  } else {

  }
  if (free_qtd != 0) {
    dwc2_hcd_qtd_unlink_and_free(hsotg, qtd, qh);
    continue_split = 0;
  } else {

  }
  no_qtd: ;
  if ((unsigned long )qh->channel != (unsigned long )((struct dwc2_host_chan *)0)) {
    (qh->channel)->align_buf = 0ULL;
  } else {

  }
  qh->channel = (struct dwc2_host_chan *)0;
  dwc2_hcd_qh_deactivate(hsotg, qh, continue_split);
  return;
}
}
static void dwc2_release_channel(struct dwc2_hsotg *hsotg , struct dwc2_host_chan *chan ,
                                 struct dwc2_qtd *qtd , enum dwc2_halt_status halt_status ) 
{ 
  enum dwc2_transaction_type tr_type ;
  u32 haintmsk ;
  int free_qtd ;
    klee_make_symbolic(&free_qtd, sizeof(int), "free_qtd");
  struct _ddebug descriptor ;
  long tmp ;
  bool tmp___0 ;
  struct _ddebug descriptor___0 ;
  long tmp___1 ;
  struct _ddebug descriptor___1 ;
  long tmp___2 ;
  int tmp___3 ;

  {
  free_qtd = 0;
  tmp___0 = dbg_hc(chan);
  if ((int )tmp___0) {
    descriptor.modname = "dwc2";
    descriptor.function = "dwc2_release_channel";
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd_intr.c";
    descriptor.format = "  %s: channel %d, halt_status %d\n";
    descriptor.lineno = 706U;
    descriptor.flags = 1U;
    tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
    if (tmp != 0L) {
      __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "  %s: channel %d, halt_status %d\n",
                        "dwc2_release_channel", (int )chan->hc_num, (unsigned int )halt_status);
    } else {

    }
  } else {

  }
  switch ((unsigned int )halt_status) {
  case 2U: 
  free_qtd = 1;
  goto ldv_34742;
  case 11U: ;
  case 6U: ;
  case 9U: 
  free_qtd = 1;
  goto ldv_34742;
  case 7U: ;
  if ((unsigned long )qtd != (unsigned long )((struct dwc2_qtd *)0) && (unsigned int )qtd->error_count > 2U) {
    descriptor___0.modname = "dwc2";
    descriptor___0.function = "dwc2_release_channel";
    descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd_intr.c";
    descriptor___0.format = "  Complete URB with transaction error\n";
    descriptor___0.lineno = 720U;
    descriptor___0.flags = 1U;
    tmp___1 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
    if (tmp___1 != 0L) {
      __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)hsotg->dev, "  Complete URB with transaction error\n");
    } else {

    }
    free_qtd = 1;
    dwc2_host_complete(hsotg, qtd, -71);
  } else {

  }
  goto ldv_34742;
  case 13U: ;
  goto cleanup;
  case 12U: 
  descriptor___1.modname = "dwc2";
  descriptor___1.function = "dwc2_release_channel";
  descriptor___1.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd_intr.c";
  descriptor___1.format = "  Complete URB with I/O error\n";
  descriptor___1.lineno = 733U;
  descriptor___1.flags = 1U;
  tmp___2 = ldv__builtin_expect((long )descriptor___1.flags & 1L, 0L);
  if (tmp___2 != 0L) {
    __dynamic_dev_dbg(& descriptor___1, (struct device  const  *)hsotg->dev, "  Complete URB with I/O error\n");
  } else {

  }
  free_qtd = 1;
  dwc2_host_complete(hsotg, qtd, -5);
  goto ldv_34742;
  case 0U: ;
  default: ;
  goto ldv_34742;
  }
  ldv_34742: 
  dwc2_deactivate_qh(hsotg, chan->qh, free_qtd);
  cleanup: 
  tmp___3 = list_empty((struct list_head  const  *)(& chan->hc_list_entry));
  if (tmp___3 == 0) {
    list_del(& chan->hc_list_entry);
  } else {

  }
  dwc2_hc_cleanup(hsotg, chan);
  list_add_tail(& chan->hc_list_entry, & hsotg->free_hc_list);
  if ((hsotg->core_params)->uframe_sched > 0) {
    hsotg->available_host_channels = hsotg->available_host_channels + 1;
  } else {
    switch ((int )chan->ep_type) {
    case 0: ;
    case 2: 
    hsotg->non_periodic_channels = hsotg->non_periodic_channels - 1;
    goto ldv_34756;
    default: ;
    goto ldv_34756;
    }
    ldv_34756: ;
  }
  haintmsk = readl((void const volatile   *)hsotg->regs + 1048U);
  haintmsk = (u32 )(~ (1 << (int )chan->hc_num)) & haintmsk;
  writel(haintmsk, (void volatile   *)hsotg->regs + 1048U);
  tr_type = dwc2_hcd_select_transactions(hsotg);
  if ((unsigned int )tr_type != 0U) {
    dwc2_hcd_queue_transactions(hsotg, tr_type);
  } else {

  }
  return;
}
}
static void dwc2_halt_channel(struct dwc2_hsotg *hsotg , struct dwc2_host_chan *chan ,
                              struct dwc2_qtd *qtd , enum dwc2_halt_status halt_status ) 
{ 
  struct _ddebug descriptor ;
  long tmp ;
  bool tmp___0 ;
  struct _ddebug descriptor___0 ;
  long tmp___1 ;
  bool tmp___2 ;
  u32 gintmsk ;
  struct _ddebug descriptor___1 ;
  long tmp___3 ;
  struct _ddebug descriptor___2 ;
  long tmp___4 ;
  struct _ddebug descriptor___3 ;
  long tmp___5 ;

  {
  tmp___0 = dbg_hc(chan);
  if ((int )tmp___0) {
    descriptor.modname = "dwc2";
    descriptor.function = "dwc2_halt_channel";
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd_intr.c";
    descriptor.format = "%s()\n";
    descriptor.lineno = 799U;
    descriptor.flags = 1U;
    tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
    if (tmp != 0L) {
      __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "%s()\n",
                        "dwc2_halt_channel");
    } else {

    }
  } else {

  }
  if ((hsotg->core_params)->dma_enable > 0) {
    tmp___2 = dbg_hc(chan);
    if ((int )tmp___2) {
      descriptor___0.modname = "dwc2";
      descriptor___0.function = "dwc2_halt_channel";
      descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd_intr.c";
      descriptor___0.format = "DMA enabled\n";
      descriptor___0.lineno = 803U;
      descriptor___0.flags = 1U;
      tmp___1 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
      if (tmp___1 != 0L) {
        __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)hsotg->dev, "DMA enabled\n");
      } else {

      }
    } else {

    }
    dwc2_release_channel(hsotg, chan, qtd, halt_status);
    return;
  } else {

  }
  dwc2_hc_halt(hsotg, chan, halt_status);
  if ((unsigned int )chan->halt_on_queue != 0U) {
    descriptor___1.modname = "dwc2";
    descriptor___1.function = "dwc2_halt_channel";
    descriptor___1.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd_intr.c";
    descriptor___1.format = "Halt on queue\n";
    descriptor___1.lineno = 814U;
    descriptor___1.flags = 1U;
    tmp___3 = ldv__builtin_expect((long )descriptor___1.flags & 1L, 0L);
    if (tmp___3 != 0L) {
      __dynamic_dev_dbg(& descriptor___1, (struct device  const  *)hsotg->dev, "Halt on queue\n");
    } else {

    }
    if ((unsigned int )*((unsigned char *)chan + 3UL) == 0U || (unsigned int )*((unsigned char *)chan + 3UL) == 2U) {
      descriptor___2.modname = "dwc2";
      descriptor___2.function = "dwc2_halt_channel";
      descriptor___2.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd_intr.c";
      descriptor___2.format = "control/bulk\n";
      descriptor___2.lineno = 817U;
      descriptor___2.flags = 1U;
      tmp___4 = ldv__builtin_expect((long )descriptor___2.flags & 1L, 0L);
      if (tmp___4 != 0L) {
        __dynamic_dev_dbg(& descriptor___2, (struct device  const  *)hsotg->dev, "control/bulk\n");
      } else {

      }
      gintmsk = readl((void const volatile   *)hsotg->regs + 24U);
      gintmsk = gintmsk | 32U;
      writel(gintmsk, (void volatile   *)hsotg->regs + 24U);
    } else {
      descriptor___3.modname = "dwc2";
      descriptor___3.function = "dwc2_halt_channel";
      descriptor___3.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd_intr.c";
      descriptor___3.format = "isoc/intr\n";
      descriptor___3.lineno = 827U;
      descriptor___3.flags = 1U;
      tmp___5 = ldv__builtin_expect((long )descriptor___3.flags & 1L, 0L);
      if (tmp___5 != 0L) {
        __dynamic_dev_dbg(& descriptor___3, (struct device  const  *)hsotg->dev, "isoc/intr\n");
      } else {

      }
      list_move(& (chan->qh)->qh_list_entry, & hsotg->periodic_sched_assigned);
      gintmsk = readl((void const volatile   *)hsotg->regs + 24U);
      gintmsk = gintmsk | 67108864U;
      writel(gintmsk, (void volatile   *)hsotg->regs + 24U);
    }
  } else {

  }
  return;
}
}
static void dwc2_complete_non_periodic_xfer(struct dwc2_hsotg *hsotg , struct dwc2_host_chan *chan ,
                                            int chnum , struct dwc2_qtd *qtd , enum dwc2_halt_status halt_status ) 
{ 
  struct _ddebug descriptor ;
  long tmp ;
  struct _ddebug descriptor___0 ;
  long tmp___0 ;

  {
  descriptor.modname = "dwc2";
  descriptor.function = "dwc2_complete_non_periodic_xfer";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd_intr.c";
  descriptor.format = "%s()\n";
  descriptor.lineno = 859U;
  descriptor.flags = 1U;
  tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp != 0L) {
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "%s()\n",
                      "dwc2_complete_non_periodic_xfer");
  } else {

  }
  qtd->error_count = 0U;
  if ((chan->hcint & 64U) != 0U) {
    descriptor___0.modname = "dwc2";
    descriptor___0.function = "dwc2_complete_non_periodic_xfer";
    descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd_intr.c";
    descriptor___0.format = "got NYET\n";
    descriptor___0.lineno = 869U;
    descriptor___0.flags = 1U;
    tmp___0 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
    if (tmp___0 != 0L) {
      __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)hsotg->dev, "got NYET\n");
    } else {

    }
    (chan->qh)->ping_state = 1U;
  } else {

  }
  if ((unsigned int )*((unsigned char *)chan + 2UL) != 0U) {
    dwc2_halt_channel(hsotg, chan, qtd, halt_status);
  } else {
    dwc2_release_channel(hsotg, chan, qtd, halt_status);
  }
  return;
}
}
static void dwc2_complete_periodic_xfer(struct dwc2_hsotg *hsotg , struct dwc2_host_chan *chan ,
                                        int chnum , struct dwc2_qtd *qtd , enum dwc2_halt_status halt_status ) 
{ 
  u32 hctsiz ;
  unsigned int tmp ;

  {
  tmp = readl((void const volatile   *)hsotg->regs + (unsigned long )(chnum * 32 + 1296));
  hctsiz = tmp;
  qtd->error_count = 0U;
  if ((unsigned int )*((unsigned char *)chan + 2UL) == 0U || (hctsiz & 536346624U) == 0U) {
    dwc2_release_channel(hsotg, chan, qtd, halt_status);
  } else {
    dwc2_halt_channel(hsotg, chan, qtd, halt_status);
  }
  return;
}
}
static int dwc2_xfercomp_isoc_split_in(struct dwc2_hsotg *hsotg , struct dwc2_host_chan *chan ,
                                       int chnum , struct dwc2_qtd *qtd ) 
{ 
  struct dwc2_hcd_iso_packet_desc *frame_desc ;
  u32 len ;
  struct _ddebug descriptor ;
  long tmp ;

  {
  if ((unsigned long )qtd->urb == (unsigned long )((struct dwc2_hcd_urb *)0)) {
    return (0);
  } else {

  }
  frame_desc = (struct dwc2_hcd_iso_packet_desc *)(& (qtd->urb)->iso_descs) + (unsigned long )qtd->isoc_frame_index;
  len = dwc2_get_actual_xfer_length(hsotg, chan, chnum, qtd, 1, (int *)0);
  if (len == 0U) {
    qtd->complete_split = 0U;
    qtd->isoc_split_offset = 0U;
    return (0);
  } else {

  }
  frame_desc->actual_length = frame_desc->actual_length + len;
  if (chan->align_buf != 0ULL) {
    descriptor.modname = "dwc2";
    descriptor.function = "dwc2_xfercomp_isoc_split_in";
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd_intr.c";
    descriptor.format = "%s(): non-aligned buffer\n";
    descriptor.lineno = 943U;
    descriptor.flags = 1U;
    tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
    if (tmp != 0L) {
      __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "%s(): non-aligned buffer\n",
                        "dwc2_xfercomp_isoc_split_in");
    } else {

    }
    dma_unmap_single_attrs(hsotg->dev, (chan->qh)->dw_align_buf_dma, (size_t )(chan->qh)->dw_align_buf_size,
                           2, (struct dma_attrs *)0);
    memcpy((qtd->urb)->buf + ((unsigned long )frame_desc->offset + (unsigned long )qtd->isoc_split_offset),
             (void const   *)(chan->qh)->dw_align_buf, (size_t )len);
  } else {

  }
  qtd->isoc_split_offset = (int )qtd->isoc_split_offset + (int )((u16 )len);
  if (frame_desc->actual_length >= frame_desc->length) {
    frame_desc->status = 0U;
    qtd->isoc_frame_index = (u16 )((int )qtd->isoc_frame_index + 1);
    qtd->complete_split = 0U;
    qtd->isoc_split_offset = 0U;
  } else {

  }
  if ((u32 )qtd->isoc_frame_index == (qtd->urb)->packet_count) {
    dwc2_host_complete(hsotg, qtd, 0);
    dwc2_release_channel(hsotg, chan, qtd, 2);
  } else {
    dwc2_release_channel(hsotg, chan, qtd, 0);
  }
  return (1);
}
}
static void dwc2_hc_xfercomp_intr(struct dwc2_hsotg *hsotg , struct dwc2_host_chan *chan ,
                                  int chnum , struct dwc2_qtd *qtd ) 
{ 
  struct dwc2_hcd_urb *urb ;
  enum dwc2_halt_status halt_status ;
  int pipe_type ;
    klee_make_symbolic(&pipe_type, sizeof(int), "pipe_type");
  int urb_xfer_done ;
    klee_make_symbolic(&urb_xfer_done, sizeof(int), "urb_xfer_done");
  struct _ddebug descriptor ;
  long tmp ;
  bool tmp___0 ;
  u8 tmp___1 ;
  int tmp___2 ;
  struct _ddebug descriptor___0 ;
  long tmp___3 ;
  struct _ddebug descriptor___1 ;
  long tmp___4 ;
  struct _ddebug descriptor___2 ;
  long tmp___5 ;
  struct _ddebug descriptor___3 ;
  long tmp___6 ;
  struct _ddebug descriptor___4 ;
  long tmp___7 ;
  struct _ddebug descriptor___5 ;
  long tmp___8 ;
  bool tmp___9 ;

  {
  urb = qtd->urb;
  halt_status = 1;
  tmp___0 = dbg_hc(chan);
  if ((int )tmp___0) {
    descriptor.modname = "dwc2";
    descriptor.function = "dwc2_hc_xfercomp_intr";
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd_intr.c";
    descriptor.format = "--Host Channel %d Interrupt: Transfer Complete--\n";
    descriptor.lineno = 987U;
    descriptor.flags = 1U;
    tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
    if (tmp != 0L) {
      __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "--Host Channel %d Interrupt: Transfer Complete--\n",
                        chnum);
    } else {

    }
  } else {

  }
  if ((unsigned long )urb == (unsigned long )((struct dwc2_hcd_urb *)0)) {
    goto handle_xfercomp_done;
  } else {

  }
  tmp___1 = dwc2_hcd_get_pipe_type(& urb->pipe_info);
  pipe_type = (int )tmp___1;
  if ((hsotg->core_params)->dma_desc_enable > 0) {
    dwc2_hcd_complete_xfer_ddma(hsotg, chan, chnum, halt_status);
    if (pipe_type == 1) {
      return;
    } else {

    }
    goto handle_xfercomp_done;
  } else {

  }
  if ((unsigned int )(chan->qh)->do_split != 0U) {
    if (((unsigned int )*((unsigned char *)chan + 3UL) == 1U && (unsigned int )*((unsigned char *)chan + 2UL) != 0U) && (hsotg->core_params)->dma_enable > 0) {
      if ((unsigned int )qtd->complete_split != 0U) {
        tmp___2 = dwc2_xfercomp_isoc_split_in(hsotg, chan, chnum, qtd);
        if (tmp___2 != 0) {
          goto handle_xfercomp_done;
        } else {

        }
      } else {

      }
    } else {
      qtd->complete_split = 0U;
    }
  } else {

  }
  switch (pipe_type) {
  case 0: ;
  switch ((unsigned int )qtd->control_phase) {
  case 0U: ;
  if (urb->length != 0U) {
    qtd->control_phase = 1;
  } else {
    qtd->control_phase = 2;
  }
  descriptor___0.modname = "dwc2";
  descriptor___0.function = "dwc2_hc_xfercomp_intr";
  descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd_intr.c";
  descriptor___0.format = "  Control setup transaction done\n";
  descriptor___0.lineno = 1025U;
  descriptor___0.flags = 1U;
  tmp___3 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
  if (tmp___3 != 0L) {
    __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)hsotg->dev, "  Control setup transaction done\n");
  } else {

  }
  halt_status = 1;
  goto ldv_34815;
  case 1U: 
  urb_xfer_done = dwc2_update_urb_state(hsotg, chan, chnum, urb, qtd);
  if (urb_xfer_done != 0) {
    qtd->control_phase = 2;
    descriptor___1.modname = "dwc2";
    descriptor___1.function = "dwc2_hc_xfercomp_intr";
    descriptor___1.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd_intr.c";
    descriptor___1.format = "  Control data transfer done\n";
    descriptor___1.lineno = 1034U;
    descriptor___1.flags = 1U;
    tmp___4 = ldv__builtin_expect((long )descriptor___1.flags & 1L, 0L);
    if (tmp___4 != 0L) {
      __dynamic_dev_dbg(& descriptor___1, (struct device  const  *)hsotg->dev, "  Control data transfer done\n");
    } else {

    }
  } else {
    dwc2_hcd_save_data_toggle(hsotg, chan, chnum, qtd);
  }
  halt_status = 1;
  goto ldv_34815;
  case 2U: 
  descriptor___2.modname = "dwc2";
  descriptor___2.function = "dwc2_hc_xfercomp_intr";
  descriptor___2.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd_intr.c";
  descriptor___2.format = "  Control transfer complete\n";
  descriptor___2.lineno = 1042U;
  descriptor___2.flags = 1U;
  tmp___5 = ldv__builtin_expect((long )descriptor___2.flags & 1L, 0L);
  if (tmp___5 != 0L) {
    __dynamic_dev_dbg(& descriptor___2, (struct device  const  *)hsotg->dev, "  Control transfer complete\n");
  } else {

  }
  if (urb->status == 4294967181U) {
    urb->status = 0U;
  } else {

  }
  dwc2_host_complete(hsotg, qtd, (int )urb->status);
  halt_status = 2;
  goto ldv_34815;
  }
  ldv_34815: 
  dwc2_complete_non_periodic_xfer(hsotg, chan, chnum, qtd, halt_status);
  goto ldv_34820;
  case 2: 
  descriptor___3.modname = "dwc2";
  descriptor___3.function = "dwc2_hc_xfercomp_intr";
  descriptor___3.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd_intr.c";
  descriptor___3.format = "  Bulk transfer complete\n";
  descriptor___3.lineno = 1054U;
  descriptor___3.flags = 1U;
  tmp___6 = ldv__builtin_expect((long )descriptor___3.flags & 1L, 0L);
  if (tmp___6 != 0L) {
    __dynamic_dev_dbg(& descriptor___3, (struct device  const  *)hsotg->dev, "  Bulk transfer complete\n");
  } else {

  }
  urb_xfer_done = dwc2_update_urb_state(hsotg, chan, chnum, urb, qtd);
  if (urb_xfer_done != 0) {
    dwc2_host_complete(hsotg, qtd, (int )urb->status);
    halt_status = 2;
  } else {
    halt_status = 1;
  }
  dwc2_hcd_save_data_toggle(hsotg, chan, chnum, qtd);
  dwc2_complete_non_periodic_xfer(hsotg, chan, chnum, qtd, halt_status);
  goto ldv_34820;
  case 3: 
  descriptor___4.modname = "dwc2";
  descriptor___4.function = "dwc2_hc_xfercomp_intr";
  descriptor___4.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd_intr.c";
  descriptor___4.format = "  Interrupt transfer complete\n";
  descriptor___4.lineno = 1069U;
  descriptor___4.flags = 1U;
  tmp___7 = ldv__builtin_expect((long )descriptor___4.flags & 1L, 0L);
  if (tmp___7 != 0L) {
    __dynamic_dev_dbg(& descriptor___4, (struct device  const  *)hsotg->dev, "  Interrupt transfer complete\n");
  } else {

  }
  urb_xfer_done = dwc2_update_urb_state(hsotg, chan, chnum, urb, qtd);
  if (urb_xfer_done != 0) {
    dwc2_host_complete(hsotg, qtd, (int )urb->status);
    halt_status = 2;
  } else {
    halt_status = 1;
  }
  dwc2_hcd_save_data_toggle(hsotg, chan, chnum, qtd);
  dwc2_complete_periodic_xfer(hsotg, chan, chnum, qtd, halt_status);
  goto ldv_34820;
  case 1: 
  tmp___9 = dbg_perio();
  if ((int )tmp___9) {
    descriptor___5.modname = "dwc2";
    descriptor___5.function = "dwc2_hc_xfercomp_intr";
    descriptor___5.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd_intr.c";
    descriptor___5.format = "  Isochronous transfer complete\n";
    descriptor___5.lineno = 1090U;
    descriptor___5.flags = 1U;
    tmp___8 = ldv__builtin_expect((long )descriptor___5.flags & 1L, 0L);
    if (tmp___8 != 0L) {
      __dynamic_dev_dbg(& descriptor___5, (struct device  const  *)hsotg->dev, "  Isochronous transfer complete\n");
    } else {

    }
  } else {

  }
  if ((unsigned int )qtd->isoc_split_pos == 3U) {
    halt_status = dwc2_update_isoc_urb_state(hsotg, chan, chnum, qtd, 1);
  } else {

  }
  dwc2_complete_periodic_xfer(hsotg, chan, chnum, qtd, halt_status);
  goto ldv_34820;
  }
  ldv_34820: ;
  handle_xfercomp_done: 
  disable_hc_int(hsotg, chnum, 1U);
  return;
}
}
static void dwc2_hc_stall_intr(struct dwc2_hsotg *hsotg , struct dwc2_host_chan *chan ,
                               int chnum , struct dwc2_qtd *qtd ) 
{ 
  struct dwc2_hcd_urb *urb ;
  int pipe_type ;
  struct _ddebug descriptor ;
  long tmp ;
  u8 tmp___0 ;

  {
  urb = qtd->urb;
  descriptor.modname = "dwc2";
  descriptor.function = "dwc2_hc_stall_intr";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd_intr.c";
  descriptor.format = "--Host Channel %d Interrupt: STALL Received--\n";
  descriptor.lineno = 1115U;
  descriptor.flags = 1U;
  tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp != 0L) {
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "--Host Channel %d Interrupt: STALL Received--\n",
                      chnum);
  } else {

  }
  if ((hsotg->core_params)->dma_desc_enable > 0) {
    dwc2_hcd_complete_xfer_ddma(hsotg, chan, chnum, 6);
    goto handle_stall_done;
  } else {

  }
  if ((unsigned long )urb == (unsigned long )((struct dwc2_hcd_urb *)0)) {
    goto handle_stall_halt;
  } else {

  }
  tmp___0 = dwc2_hcd_get_pipe_type(& urb->pipe_info);
  pipe_type = (int )tmp___0;
  if (pipe_type == 0) {
    dwc2_host_complete(hsotg, qtd, -32);
  } else {

  }
  if (pipe_type == 2 || pipe_type == 3) {
    dwc2_host_complete(hsotg, qtd, -32);
    (chan->qh)->data_toggle = 0U;
  } else {

  }
  handle_stall_halt: 
  dwc2_halt_channel(hsotg, chan, qtd, 6);
  handle_stall_done: 
  disable_hc_int(hsotg, chnum, 8U);
  return;
}
}
static void dwc2_update_urb_state_abn(struct dwc2_hsotg *hsotg , struct dwc2_host_chan *chan ,
                                      int chnum , struct dwc2_hcd_urb *urb , struct dwc2_qtd *qtd ,
                                      enum dwc2_halt_status halt_status ) 
{ 
  u32 xfer_length ;
  u32 tmp ;
  u32 hctsiz ;
  struct _ddebug descriptor ;
  long tmp___0 ;
  struct _ddebug descriptor___0 ;
  long tmp___1 ;
  struct _ddebug descriptor___1 ;
  long tmp___2 ;
  struct _ddebug descriptor___2 ;
  long tmp___3 ;
  struct _ddebug descriptor___3 ;
  long tmp___4 ;
  struct _ddebug descriptor___4 ;
  long tmp___5 ;
  struct _ddebug descriptor___5 ;
  long tmp___6 ;
  struct _ddebug descriptor___6 ;
  long tmp___7 ;

  {
  tmp = dwc2_get_actual_xfer_length(hsotg, chan, chnum, qtd, halt_status, (int *)0);
  xfer_length = tmp;
  if (urb->actual_length + xfer_length > urb->length) {
    dev_warn((struct device  const  *)hsotg->dev, "%s(): trimming xfer length\n",
             "dwc2_update_urb_state_abn");
    xfer_length = urb->length - urb->actual_length;
  } else {

  }
  if ((chan->align_buf != 0ULL && xfer_length != 0U) && (unsigned int )*((unsigned char *)chan + 2UL) != 0U) {
    descriptor.modname = "dwc2";
    descriptor.function = "dwc2_update_urb_state_abn";
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd_intr.c";
    descriptor.format = "%s(): non-aligned buffer\n";
    descriptor.lineno = 1174U;
    descriptor.flags = 1U;
    tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
    if (tmp___0 != 0L) {
      __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "%s(): non-aligned buffer\n",
                        "dwc2_update_urb_state_abn");
    } else {

    }
    dma_unmap_single_attrs(hsotg->dev, (chan->qh)->dw_align_buf_dma, (size_t )(chan->qh)->dw_align_buf_size,
                           (unsigned int )*((unsigned char *)chan + 2UL) != 0U ? 2 : 1,
                           (struct dma_attrs *)0);
    if ((unsigned int )*((unsigned char *)chan + 2UL) != 0U) {
      memcpy(urb->buf + (unsigned long )urb->actual_length, (void const   *)(chan->qh)->dw_align_buf,
               (size_t )xfer_length);
    } else {

    }
  } else {

  }
  urb->actual_length = urb->actual_length + xfer_length;
  hctsiz = readl((void const volatile   *)hsotg->regs + (unsigned long )(chnum * 32 + 1296));
  descriptor___0.modname = "dwc2";
  descriptor___0.function = "dwc2_update_urb_state_abn";
  descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd_intr.c";
  descriptor___0.format = "DWC_otg: %s: %s, channel %d\n";
  descriptor___0.lineno = 1189U;
  descriptor___0.flags = 1U;
  tmp___1 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
  if (tmp___1 != 0L) {
    __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)hsotg->dev, "DWC_otg: %s: %s, channel %d\n",
                      "dwc2_update_urb_state_abn", (unsigned int )*((unsigned char *)chan + 2UL) != 0U ? (char *)"IN" : (char *)"OUT",
                      chnum);
  } else {

  }
  descriptor___1.modname = "dwc2";
  descriptor___1.function = "dwc2_update_urb_state_abn";
  descriptor___1.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd_intr.c";
  descriptor___1.format = "  chan->start_pkt_count %d\n";
  descriptor___1.lineno = 1191U;
  descriptor___1.flags = 1U;
  tmp___2 = ldv__builtin_expect((long )descriptor___1.flags & 1L, 0L);
  if (tmp___2 != 0L) {
    __dynamic_dev_dbg(& descriptor___1, (struct device  const  *)hsotg->dev, "  chan->start_pkt_count %d\n",
                      (int )chan->start_pkt_count);
  } else {

  }
  descriptor___2.modname = "dwc2";
  descriptor___2.function = "dwc2_update_urb_state_abn";
  descriptor___2.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd_intr.c";
  descriptor___2.format = "  hctsiz.pktcnt %d\n";
  descriptor___2.lineno = 1193U;
  descriptor___2.flags = 1U;
  tmp___3 = ldv__builtin_expect((long )descriptor___2.flags & 1L, 0L);
  if (tmp___3 != 0L) {
    __dynamic_dev_dbg(& descriptor___2, (struct device  const  *)hsotg->dev, "  hctsiz.pktcnt %d\n",
                      (hctsiz & 536346624U) >> 19);
  } else {

  }
  descriptor___3.modname = "dwc2";
  descriptor___3.function = "dwc2_update_urb_state_abn";
  descriptor___3.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd_intr.c";
  descriptor___3.format = "  chan->max_packet %d\n";
  descriptor___3.lineno = 1194U;
  descriptor___3.flags = 1U;
  tmp___4 = ldv__builtin_expect((long )descriptor___3.flags & 1L, 0L);
  if (tmp___4 != 0L) {
    __dynamic_dev_dbg(& descriptor___3, (struct device  const  *)hsotg->dev, "  chan->max_packet %d\n",
                      (int )chan->max_packet);
  } else {

  }
  descriptor___4.modname = "dwc2";
  descriptor___4.function = "dwc2_update_urb_state_abn";
  descriptor___4.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd_intr.c";
  descriptor___4.format = "  bytes_transferred %d\n";
  descriptor___4.lineno = 1196U;
  descriptor___4.flags = 1U;
  tmp___5 = ldv__builtin_expect((long )descriptor___4.flags & 1L, 0L);
  if (tmp___5 != 0L) {
    __dynamic_dev_dbg(& descriptor___4, (struct device  const  *)hsotg->dev, "  bytes_transferred %d\n",
                      xfer_length);
  } else {

  }
  descriptor___5.modname = "dwc2";
  descriptor___5.function = "dwc2_update_urb_state_abn";
  descriptor___5.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd_intr.c";
  descriptor___5.format = "  urb->actual_length %d\n";
  descriptor___5.lineno = 1198U;
  descriptor___5.flags = 1U;
  tmp___6 = ldv__builtin_expect((long )descriptor___5.flags & 1L, 0L);
  if (tmp___6 != 0L) {
    __dynamic_dev_dbg(& descriptor___5, (struct device  const  *)hsotg->dev, "  urb->actual_length %d\n",
                      urb->actual_length);
  } else {

  }
  descriptor___6.modname = "dwc2";
  descriptor___6.function = "dwc2_update_urb_state_abn";
  descriptor___6.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd_intr.c";
  descriptor___6.format = "  urb->transfer_buffer_length %d\n";
  descriptor___6.lineno = 1200U;
  descriptor___6.flags = 1U;
  tmp___7 = ldv__builtin_expect((long )descriptor___6.flags & 1L, 0L);
  if (tmp___7 != 0L) {
    __dynamic_dev_dbg(& descriptor___6, (struct device  const  *)hsotg->dev, "  urb->transfer_buffer_length %d\n",
                      urb->length);
  } else {

  }
  return;
}
}
static void dwc2_hc_nak_intr(struct dwc2_hsotg *hsotg , struct dwc2_host_chan *chan ,
                             int chnum , struct dwc2_qtd *qtd ) 
{ 
  struct _ddebug descriptor ;
  long tmp ;
  struct _ddebug descriptor___0 ;
  long tmp___0 ;
  struct _ddebug descriptor___1 ;
  long tmp___1 ;
  bool tmp___2 ;
  u8 tmp___3 ;

  {
  if ((unsigned long )qtd == (unsigned long )((struct dwc2_qtd *)0)) {
    descriptor.modname = "dwc2";
    descriptor.function = "dwc2_hc_nak_intr";
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd_intr.c";
    descriptor.format = "%s: qtd is NULL\n";
    descriptor.lineno = 1212U;
    descriptor.flags = 1U;
    tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
    if (tmp != 0L) {
      __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "%s: qtd is NULL\n",
                        "dwc2_hc_nak_intr");
    } else {

    }
    return;
  } else {

  }
  if ((unsigned long )qtd->urb == (unsigned long )((struct dwc2_hcd_urb *)0)) {
    descriptor___0.modname = "dwc2";
    descriptor___0.function = "dwc2_hc_nak_intr";
    descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd_intr.c";
    descriptor___0.format = "%s: qtd->urb is NULL\n";
    descriptor___0.lineno = 1217U;
    descriptor___0.flags = 1U;
    tmp___0 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
    if (tmp___0 != 0L) {
      __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)hsotg->dev, "%s: qtd->urb is NULL\n",
                        "dwc2_hc_nak_intr");
    } else {

    }
    return;
  } else {

  }
  tmp___2 = dbg_hc(chan);
  if ((int )tmp___2) {
    descriptor___1.modname = "dwc2";
    descriptor___1.function = "dwc2_hc_nak_intr";
    descriptor___1.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd_intr.c";
    descriptor___1.format = "--Host Channel %d Interrupt: NAK Received--\n";
    descriptor___1.lineno = 1223U;
    descriptor___1.flags = 1U;
    tmp___1 = ldv__builtin_expect((long )descriptor___1.flags & 1L, 0L);
    if (tmp___1 != 0L) {
      __dynamic_dev_dbg(& descriptor___1, (struct device  const  *)hsotg->dev, "--Host Channel %d Interrupt: NAK Received--\n",
                        chnum);
    } else {

    }
  } else {

  }
  if ((unsigned int )chan->do_split != 0U) {
    if ((unsigned int )chan->complete_split != 0U) {
      qtd->error_count = 0U;
    } else {

    }
    qtd->complete_split = 0U;
    dwc2_halt_channel(hsotg, chan, qtd, 4);
    goto handle_nak_done;
  } else {

  }
  tmp___3 = dwc2_hcd_get_pipe_type(& (qtd->urb)->pipe_info);
  switch ((int )tmp___3) {
  case 0: ;
  case 2: ;
  if ((hsotg->core_params)->dma_enable > 0 && (unsigned int )*((unsigned char *)chan + 2UL) != 0U) {
    qtd->error_count = 0U;
    goto ldv_34871;
  } else {

  }
  qtd->error_count = 0U;
  if ((unsigned int )(chan->qh)->ping_state == 0U) {
    dwc2_update_urb_state_abn(hsotg, chan, chnum, qtd->urb, qtd, 4);
    dwc2_hcd_save_data_toggle(hsotg, chan, chnum, qtd);
    if ((unsigned int )*((unsigned char *)chan + 2UL) == 48U) {
      (chan->qh)->ping_state = 1U;
    } else {

    }
  } else {

  }
  dwc2_halt_channel(hsotg, chan, qtd, 4);
  goto ldv_34871;
  case 3: 
  qtd->error_count = 0U;
  dwc2_halt_channel(hsotg, chan, qtd, 4);
  goto ldv_34871;
  case 1: 
  dev_err((struct device  const  *)hsotg->dev, "NACK interrupt for ISOC transfer\n");
  goto ldv_34871;
  }
  ldv_34871: ;
  handle_nak_done: 
  disable_hc_int(hsotg, chnum, 16U);
  return;
}
}
static void dwc2_hc_ack_intr(struct dwc2_hsotg *hsotg , struct dwc2_host_chan *chan ,
                             int chnum , struct dwc2_qtd *qtd ) 
{ 
  struct dwc2_hcd_iso_packet_desc *frame_desc ;
  struct _ddebug descriptor ;
  long tmp ;
  bool tmp___0 ;

  {
  tmp___0 = dbg_hc(chan);
  if ((int )tmp___0) {
    descriptor.modname = "dwc2";
    descriptor.function = "dwc2_hc_ack_intr";
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd_intr.c";
    descriptor.format = "--Host Channel %d Interrupt: ACK Received--\n";
    descriptor.lineno = 1301U;
    descriptor.flags = 1U;
    tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
    if (tmp != 0L) {
      __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "--Host Channel %d Interrupt: ACK Received--\n",
                        chnum);
    } else {

    }
  } else {

  }
  if ((unsigned int )chan->do_split != 0U) {
    if ((unsigned int )*((unsigned char *)chan + 2UL) == 0U && (unsigned int )*((unsigned char *)chan + 5UL) != 24U) {
      qtd->ssplit_out_xfer_count = chan->xfer_len;
    } else {

    }
    if ((unsigned int )*((unsigned char *)chan + 3UL) != 1U || (unsigned int )*((unsigned char *)chan + 2UL) != 0U) {
      qtd->complete_split = 1U;
      dwc2_halt_channel(hsotg, chan, qtd, 3);
    } else {
      switch ((int )chan->xact_pos) {
      case 3: ;
      goto ldv_34884;
      case 1: 
      qtd->isoc_split_pos = 3U;
      qtd->isoc_split_offset = 0U;
      goto ldv_34884;
      case 2: ;
      case 0: 
      frame_desc = (struct dwc2_hcd_iso_packet_desc *)(& (qtd->urb)->iso_descs) + (unsigned long )qtd->isoc_frame_index;
      qtd->isoc_split_offset = (unsigned int )qtd->isoc_split_offset + 188U;
      if (frame_desc->length - (u32 )qtd->isoc_split_offset <= 188U) {
        qtd->isoc_split_pos = 1U;
      } else {
        qtd->isoc_split_pos = 0U;
      }
      goto ldv_34884;
      }
      ldv_34884: ;
    }
  } else {
    qtd->error_count = 0U;
    if ((unsigned int )(chan->qh)->ping_state != 0U) {
      (chan->qh)->ping_state = 0U;
      dwc2_halt_channel(hsotg, chan, qtd, 3);
    } else {

    }
  }
  disable_hc_int(hsotg, chnum, 32U);
  return;
}
}
static void dwc2_hc_nyet_intr(struct dwc2_hsotg *hsotg , struct dwc2_host_chan *chan ,
                              int chnum , struct dwc2_qtd *qtd ) 
{ 
  struct _ddebug descriptor ;
  long tmp ;
  bool tmp___0 ;
  int frnum ;
    klee_make_symbolic(&frnum, sizeof(int), "frnum");
  int tmp___1 ;
  u16 tmp___2 ;
  u16 tmp___3 ;

  {
  tmp___0 = dbg_hc(chan);
  if ((int )tmp___0) {
    descriptor.modname = "dwc2";
    descriptor.function = "dwc2_hc_nyet_intr";
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd_intr.c";
    descriptor.format = "--Host Channel %d Interrupt: NYET Received--\n";
    descriptor.lineno = 1378U;
    descriptor.flags = 1U;
    tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
    if (tmp != 0L) {
      __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "--Host Channel %d Interrupt: NYET Received--\n",
                        chnum);
    } else {

    }
  } else {

  }
  if ((unsigned int )chan->do_split != 0U && (unsigned int )chan->complete_split != 0U) {
    if (((unsigned int )*((unsigned char *)chan + 2UL) != 0U && (unsigned int )*((unsigned char *)chan + 3UL) == 1U) && (hsotg->core_params)->dma_enable > 0) {
      qtd->complete_split = 0U;
      qtd->isoc_split_offset = 0U;
      qtd->isoc_frame_index = (u16 )((int )qtd->isoc_frame_index + 1);
      if ((unsigned long )qtd->urb != (unsigned long )((struct dwc2_hcd_urb *)0) && (u32 )qtd->isoc_frame_index == (qtd->urb)->packet_count) {
        dwc2_host_complete(hsotg, qtd, 0);
        dwc2_release_channel(hsotg, chan, qtd, 2);
      } else {
        dwc2_release_channel(hsotg, chan, qtd, 0);
      }
      goto handle_nyet_done;
    } else {

    }
    if ((unsigned int )*((unsigned char *)chan + 3UL) == 3U || (unsigned int )*((unsigned char *)chan + 3UL) == 1U) {
      tmp___1 = dwc2_hcd_get_frame_number(hsotg);
      frnum = tmp___1;
      tmp___2 = dwc2_full_frame_num((int )((u16 )frnum));
      tmp___3 = dwc2_full_frame_num((int )(chan->qh)->sched_frame);
      if ((int )tmp___2 != (int )tmp___3) {
        qtd->complete_split = 0U;
        dwc2_halt_channel(hsotg, chan, qtd, 7);
        goto handle_nyet_done;
      } else {

      }
    } else {

    }
    dwc2_halt_channel(hsotg, chan, qtd, 5);
    goto handle_nyet_done;
  } else {

  }
  (chan->qh)->ping_state = 1U;
  qtd->error_count = 0U;
  dwc2_update_urb_state_abn(hsotg, chan, chnum, qtd->urb, qtd, 5);
  dwc2_hcd_save_data_toggle(hsotg, chan, chnum, qtd);
  dwc2_halt_channel(hsotg, chan, qtd, 5);
  handle_nyet_done: 
  disable_hc_int(hsotg, chnum, 64U);
  return;
}
}
static void dwc2_hc_babble_intr(struct dwc2_hsotg *hsotg , struct dwc2_host_chan *chan ,
                                int chnum , struct dwc2_qtd *qtd ) 
{ 
  struct _ddebug descriptor ;
  long tmp ;
  enum dwc2_halt_status halt_status ;

  {
  descriptor.modname = "dwc2";
  descriptor.function = "dwc2_hc_babble_intr";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd_intr.c";
  descriptor.format = "--Host Channel %d Interrupt: Babble Error--\n";
  descriptor.lineno = 1460U;
  descriptor.flags = 1U;
  tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp != 0L) {
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "--Host Channel %d Interrupt: Babble Error--\n",
                      chnum);
  } else {

  }
  dwc2_hc_handle_tt_clear(hsotg, chan, qtd);
  if ((hsotg->core_params)->dma_desc_enable > 0) {
    dwc2_hcd_complete_xfer_ddma(hsotg, chan, chnum, 9);
    goto disable_int;
  } else {

  }
  if ((unsigned int )*((unsigned char *)chan + 3UL) != 1U) {
    dwc2_host_complete(hsotg, qtd, -75);
    dwc2_halt_channel(hsotg, chan, qtd, 9);
  } else {
    halt_status = dwc2_update_isoc_urb_state(hsotg, chan, chnum, qtd, 9);
    dwc2_halt_channel(hsotg, chan, qtd, halt_status);
  }
  disable_int: 
  disable_hc_int(hsotg, chnum, 256U);
  return;
}
}
static void dwc2_hc_ahberr_intr(struct dwc2_hsotg *hsotg , struct dwc2_host_chan *chan ,
                                int chnum , struct dwc2_qtd *qtd ) 
{ 
  struct dwc2_hcd_urb *urb ;
  char *pipetype ;
  char *speed ;
  u32 hcchar ;
  u32 hcsplt ;
  u32 hctsiz ;
  u32 hc_dma ;
  struct _ddebug descriptor ;
  long tmp ;
  u8 tmp___0 ;
  u8 tmp___1 ;
  u8 tmp___2 ;
  u8 tmp___3 ;
  u16 tmp___4 ;

  {
  urb = qtd->urb;
  descriptor.modname = "dwc2";
  descriptor.function = "dwc2_hc_ahberr_intr";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd_intr.c";
  descriptor.format = "--Host Channel %d Interrupt: AHB Error--\n";
  descriptor.lineno = 1501U;
  descriptor.flags = 1U;
  tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp != 0L) {
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "--Host Channel %d Interrupt: AHB Error--\n",
                      chnum);
  } else {

  }
  if ((unsigned long )urb == (unsigned long )((struct dwc2_hcd_urb *)0)) {
    goto handle_ahberr_halt;
  } else {

  }
  dwc2_hc_handle_tt_clear(hsotg, chan, qtd);
  hcchar = readl((void const volatile   *)hsotg->regs + (unsigned long )((chnum + 40) * 32));
  hcsplt = readl((void const volatile   *)hsotg->regs + (unsigned long )(chnum * 32 + 1284));
  hctsiz = readl((void const volatile   *)hsotg->regs + (unsigned long )(chnum * 32 + 1296));
  hc_dma = readl((void const volatile   *)hsotg->regs + (unsigned long )(chnum * 32 + 1300));
  dev_err((struct device  const  *)hsotg->dev, "AHB OLD_ERROR, Channel %d\n", chnum);
  dev_err((struct device  const  *)hsotg->dev, "  hcchar 0x%08x, hcsplt 0x%08x\n",
          hcchar, hcsplt);
  dev_err((struct device  const  *)hsotg->dev, "  hctsiz 0x%08x, hc_dma 0x%08x\n",
          hctsiz, hc_dma);
  tmp___0 = dwc2_hcd_get_dev_addr(& urb->pipe_info);
  dev_err((struct device  const  *)hsotg->dev, "  Device address: %d\n", (int )tmp___0);
  tmp___1 = dwc2_hcd_is_pipe_in(& urb->pipe_info);
  tmp___2 = dwc2_hcd_get_ep_num(& urb->pipe_info);
  dev_err((struct device  const  *)hsotg->dev, "  Endpoint: %d, %s\n", (int )tmp___2,
          (unsigned int )tmp___1 != 0U ? (char *)"IN" : (char *)"OUT");
  tmp___3 = dwc2_hcd_get_pipe_type(& urb->pipe_info);
  switch ((int )tmp___3) {
  case 0: 
  pipetype = (char *)"CONTROL";
  goto ldv_34925;
  case 2: 
  pipetype = (char *)"BULK";
  goto ldv_34925;
  case 3: 
  pipetype = (char *)"INTERRUPT";
  goto ldv_34925;
  case 1: 
  pipetype = (char *)"ISOCHRONOUS";
  goto ldv_34925;
  default: 
  pipetype = (char *)"UNKNOWN";
  goto ldv_34925;
  }
  ldv_34925: 
  dev_err((struct device  const  *)hsotg->dev, "  Endpoint type: %s\n", pipetype);
  switch ((int )chan->speed) {
  case 3: 
  speed = (char *)"HIGH";
  goto ldv_34931;
  case 2: 
  speed = (char *)"FULL";
  goto ldv_34931;
  case 1: 
  speed = (char *)"LOW";
  goto ldv_34931;
  default: 
  speed = (char *)"UNKNOWN";
  goto ldv_34931;
  }
  ldv_34931: 
  dev_err((struct device  const  *)hsotg->dev, "  Speed: %s\n", speed);
  tmp___4 = dwc2_hcd_get_mps(& urb->pipe_info);
  dev_err((struct device  const  *)hsotg->dev, "  Max packet size: %d\n", (int )tmp___4);
  dev_err((struct device  const  *)hsotg->dev, "  Data buffer length: %d\n", urb->length);
  dev_err((struct device  const  *)hsotg->dev, "  Transfer buffer: %p, Transfer DMA: %08lx\n",
          urb->buf, (unsigned long )urb->dma);
  dev_err((struct device  const  *)hsotg->dev, "  Setup buffer: %p, Setup DMA: %08lx\n",
          urb->setup_packet, (unsigned long )urb->setup_dma);
  dev_err((struct device  const  *)hsotg->dev, "  Interval: %d\n", (int )urb->interval);
  if ((hsotg->core_params)->dma_desc_enable > 0) {
    dwc2_hcd_complete_xfer_ddma(hsotg, chan, chnum, 11);
    goto handle_ahberr_done;
  } else {

  }
  dwc2_host_complete(hsotg, qtd, -5);
  handle_ahberr_halt: 
  dwc2_hc_halt(hsotg, chan, 11);
  handle_ahberr_done: 
  disable_hc_int(hsotg, chnum, 4U);
  return;
}
}
static void dwc2_hc_xacterr_intr(struct dwc2_hsotg *hsotg , struct dwc2_host_chan *chan ,
                                 int chnum , struct dwc2_qtd *qtd ) 
{ 
  struct _ddebug descriptor ;
  long tmp ;
  u8 tmp___0 ;
  enum dwc2_halt_status halt_status ;

  {
  descriptor.modname = "dwc2";
  descriptor.function = "dwc2_hc_xacterr_intr";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd_intr.c";
  descriptor.format = "--Host Channel %d Interrupt: Transaction Error--\n";
  descriptor.lineno = 1597U;
  descriptor.flags = 1U;
  tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp != 0L) {
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "--Host Channel %d Interrupt: Transaction Error--\n",
                      chnum);
  } else {

  }
  dwc2_hc_handle_tt_clear(hsotg, chan, qtd);
  if ((hsotg->core_params)->dma_desc_enable > 0) {
    dwc2_hcd_complete_xfer_ddma(hsotg, chan, chnum, 7);
    goto handle_xacterr_done;
  } else {

  }
  tmp___0 = dwc2_hcd_get_pipe_type(& (qtd->urb)->pipe_info);
  switch ((int )tmp___0) {
  case 0: ;
  case 2: 
  qtd->error_count = (u8 )((int )qtd->error_count + 1);
  if ((unsigned int )(chan->qh)->ping_state == 0U) {
    dwc2_update_urb_state_abn(hsotg, chan, chnum, qtd->urb, qtd, 7);
    dwc2_hcd_save_data_toggle(hsotg, chan, chnum, qtd);
    if ((unsigned int )*((unsigned char *)chan + 2UL) == 0U && (unsigned int )*((unsigned char *)chan + 2UL) == 48U) {
      (chan->qh)->ping_state = 1U;
    } else {

    }
  } else {

  }
  dwc2_halt_channel(hsotg, chan, qtd, 7);
  goto ldv_34947;
  case 3: 
  qtd->error_count = (u8 )((int )qtd->error_count + 1);
  if ((unsigned int )chan->do_split != 0U && (unsigned int )chan->complete_split != 0U) {
    qtd->complete_split = 0U;
  } else {

  }
  dwc2_halt_channel(hsotg, chan, qtd, 7);
  goto ldv_34947;
  case 1: 
  halt_status = dwc2_update_isoc_urb_state(hsotg, chan, chnum, qtd, 7);
  dwc2_halt_channel(hsotg, chan, qtd, halt_status);
  goto ldv_34947;
  }
  ldv_34947: ;
  handle_xacterr_done: 
  disable_hc_int(hsotg, chnum, 128U);
  return;
}
}
static void dwc2_hc_frmovrun_intr(struct dwc2_hsotg *hsotg , struct dwc2_host_chan *chan ,
                                  int chnum , struct dwc2_qtd *qtd ) 
{ 
  enum dwc2_halt_status halt_status ;
  struct _ddebug descriptor ;
  long tmp ;
  bool tmp___0 ;
  u8 tmp___1 ;

  {
  tmp___0 = dbg_hc(chan);
  if ((int )tmp___0) {
    descriptor.modname = "dwc2";
    descriptor.function = "dwc2_hc_frmovrun_intr";
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd_intr.c";
    descriptor.format = "--Host Channel %d Interrupt: Frame Overrun--\n";
    descriptor.lineno = 1659U;
    descriptor.flags = 1U;
    tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
    if (tmp != 0L) {
      __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "--Host Channel %d Interrupt: Frame Overrun--\n",
                        chnum);
    } else {

    }
  } else {

  }
  dwc2_hc_handle_tt_clear(hsotg, chan, qtd);
  tmp___1 = dwc2_hcd_get_pipe_type(& (qtd->urb)->pipe_info);
  switch ((int )tmp___1) {
  case 0: ;
  case 2: ;
  goto ldv_34962;
  case 3: 
  dwc2_halt_channel(hsotg, chan, qtd, 8);
  goto ldv_34962;
  case 1: 
  halt_status = dwc2_update_isoc_urb_state(hsotg, chan, chnum, qtd, 8);
  dwc2_halt_channel(hsotg, chan, qtd, halt_status);
  goto ldv_34962;
  }
  ldv_34962: 
  disable_hc_int(hsotg, chnum, 512U);
  return;
}
}
static void dwc2_hc_datatglerr_intr(struct dwc2_hsotg *hsotg , struct dwc2_host_chan *chan ,
                                    int chnum , struct dwc2_qtd *qtd ) 
{ 
  struct _ddebug descriptor ;
  long tmp ;

  {
  descriptor.modname = "dwc2";
  descriptor.function = "dwc2_hc_datatglerr_intr";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd_intr.c";
  descriptor.format = "--Host Channel %d Interrupt: Data Toggle Error--\n";
  descriptor.lineno = 1689U;
  descriptor.flags = 1U;
  tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp != 0L) {
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "--Host Channel %d Interrupt: Data Toggle Error--\n",
                      chnum);
  } else {

  }
  if ((unsigned int )*((unsigned char *)chan + 2UL) != 0U) {
    qtd->error_count = 0U;
  } else {
    dev_err((struct device  const  *)hsotg->dev, "Data Toggle Error on OUT transfer, channel %d\n",
            chnum);
  }
  dwc2_hc_handle_tt_clear(hsotg, chan, qtd);
  disable_hc_int(hsotg, chnum, 1024U);
  return;
}
}
static bool dwc2_halt_status_ok(struct dwc2_hsotg *hsotg , struct dwc2_host_chan *chan ,
                                int chnum , struct dwc2_qtd *qtd ) 
{ 
  u32 hcchar ;
  u32 hctsiz ;
  u32 hcintmsk ;
  u32 hcsplt ;
  struct _ddebug descriptor ;
  long tmp ;
  struct _ddebug descriptor___0 ;
  long tmp___0 ;
  struct _ddebug descriptor___1 ;
  long tmp___1 ;
  struct _ddebug descriptor___2 ;
  long tmp___2 ;

  {
  if ((unsigned int )chan->halt_status == 0U) {
    hcchar = readl((void const volatile   *)hsotg->regs + (unsigned long )((chnum + 40) * 32));
    hctsiz = readl((void const volatile   *)hsotg->regs + (unsigned long )(chnum * 32 + 1296));
    hcintmsk = readl((void const volatile   *)hsotg->regs + (unsigned long )(chnum * 32 + 1292));
    hcsplt = readl((void const volatile   *)hsotg->regs + (unsigned long )(chnum * 32 + 1284));
    descriptor.modname = "dwc2";
    descriptor.function = "dwc2_halt_status_ok";
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd_intr.c";
    descriptor.format = "%s: chan->halt_status DWC2_HC_XFER_NO_HALT_STATUS,\n";
    descriptor.lineno = 1730U;
    descriptor.flags = 1U;
    tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
    if (tmp != 0L) {
      __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "%s: chan->halt_status DWC2_HC_XFER_NO_HALT_STATUS,\n",
                        "dwc2_halt_status_ok");
    } else {

    }
    descriptor___0.modname = "dwc2";
    descriptor___0.function = "dwc2_halt_status_ok";
    descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd_intr.c";
    descriptor___0.format = "channel %d, hcchar 0x%08x, hctsiz 0x%08x,\n";
    descriptor___0.lineno = 1733U;
    descriptor___0.flags = 1U;
    tmp___0 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
    if (tmp___0 != 0L) {
      __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)hsotg->dev, "channel %d, hcchar 0x%08x, hctsiz 0x%08x,\n",
                        chnum, hcchar, hctsiz);
    } else {

    }
    descriptor___1.modname = "dwc2";
    descriptor___1.function = "dwc2_halt_status_ok";
    descriptor___1.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd_intr.c";
    descriptor___1.format = "hcint 0x%08x, hcintmsk 0x%08x, hcsplt 0x%08x,\n";
    descriptor___1.lineno = 1736U;
    descriptor___1.flags = 1U;
    tmp___1 = ldv__builtin_expect((long )descriptor___1.flags & 1L, 0L);
    if (tmp___1 != 0L) {
      __dynamic_dev_dbg(& descriptor___1, (struct device  const  *)hsotg->dev, "hcint 0x%08x, hcintmsk 0x%08x, hcsplt 0x%08x,\n",
                        chan->hcint, hcintmsk, hcsplt);
    } else {

    }
    if ((unsigned long )qtd != (unsigned long )((struct dwc2_qtd *)0)) {
      descriptor___2.modname = "dwc2";
      descriptor___2.function = "dwc2_halt_status_ok";
      descriptor___2.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd_intr.c";
      descriptor___2.format = "qtd->complete_split %d\n";
      descriptor___2.lineno = 1739U;
      descriptor___2.flags = 1U;
      tmp___2 = ldv__builtin_expect((long )descriptor___2.flags & 1L, 0L);
      if (tmp___2 != 0L) {
        __dynamic_dev_dbg(& descriptor___2, (struct device  const  *)hsotg->dev, "qtd->complete_split %d\n",
                          (int )qtd->complete_split);
      } else {

      }
    } else {

    }
    dev_warn((struct device  const  *)hsotg->dev, "%s: no halt status, channel %d, ignoring interrupt\n",
             "dwc2_halt_status_ok", chnum);
    return (0);
  } else {

  }
  hcchar = readl((void const volatile   *)hsotg->regs + (unsigned long )((chnum + 40) * 32));
  if ((hcchar & 1073741824U) != 0U) {
    dev_warn((struct device  const  *)hsotg->dev, "%s: hcchar.chdis set unexpectedly, hcchar 0x%08x, trying to halt again\n",
             "dwc2_halt_status_ok", hcchar);
    chan->halt_pending = 0U;
    dwc2_halt_channel(hsotg, chan, qtd, chan->halt_status);
    return (0);
  } else {

  }
  return (1);
}
}
static void dwc2_hc_chhltd_intr_dma(struct dwc2_hsotg *hsotg , struct dwc2_host_chan *chan ,
                                    int chnum , struct dwc2_qtd *qtd ) 
{ 
  u32 hcintmsk ;
  int out_nak_enh ;
    klee_make_symbolic(&out_nak_enh, sizeof(int), "out_nak_enh");
  struct _ddebug descriptor ;
  long tmp ;
  bool tmp___0 ;
  struct _ddebug descriptor___0 ;
  long tmp___1 ;
  struct _ddebug descriptor___1 ;
  long tmp___2 ;
  struct _ddebug descriptor___2 ;
  long tmp___3 ;
  unsigned int tmp___4 ;

  {
  out_nak_enh = 0;
  tmp___0 = dbg_hc(chan);
  if ((int )tmp___0) {
    descriptor.modname = "dwc2";
    descriptor.function = "dwc2_hc_chhltd_intr_dma";
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd_intr.c";
    descriptor.format = "--Host Channel %d Interrupt: DMA Channel Halted--\n";
    descriptor.lineno = 1779U;
    descriptor.flags = 1U;
    tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
    if (tmp != 0L) {
      __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "--Host Channel %d Interrupt: DMA Channel Halted--\n",
                        chnum);
    } else {

    }
  } else {

  }
  if (hsotg->hw_params.snpsid > 1330915097U) {
    if (((unsigned int )*((unsigned char *)chan + 2UL) == 48U && (unsigned int )*((unsigned char *)chan + 2UL) == 0U) && ((unsigned int )*((unsigned char *)chan + 3UL) == 0U || (unsigned int )*((unsigned char *)chan + 3UL) == 2U)) {
      out_nak_enh = 1;
    } else {

    }
  } else {

  }
  if ((unsigned int )chan->halt_status == 13U || ((unsigned int )chan->halt_status == 11U && (hsotg->core_params)->dma_desc_enable <= 0)) {
    if ((hsotg->core_params)->dma_desc_enable > 0) {
      dwc2_hcd_complete_xfer_ddma(hsotg, chan, chnum, chan->halt_status);
    } else {
      dwc2_release_channel(hsotg, chan, qtd, chan->halt_status);
    }
    return;
  } else {

  }
  hcintmsk = readl((void const volatile   *)hsotg->regs + (unsigned long )(chnum * 32 + 1292));
  if ((int )chan->hcint & 1) {
    if ((unsigned int )*((unsigned char *)chan + 3UL) == 1U && (unsigned int )*((unsigned char *)chan + 2UL) == 0U) {
      dwc2_hc_ack_intr(hsotg, chan, chnum, qtd);
    } else {

    }
    dwc2_hc_xfercomp_intr(hsotg, chan, chnum, qtd);
  } else
  if ((chan->hcint & 8U) != 0U) {
    dwc2_hc_stall_intr(hsotg, chan, chnum, qtd);
  } else
  if ((chan->hcint & 128U) != 0U && (hsotg->core_params)->dma_desc_enable <= 0) {
    if (out_nak_enh != 0) {
      if ((chan->hcint & 112U) != 0U) {
        descriptor___0.modname = "dwc2";
        descriptor___0.function = "dwc2_hc_chhltd_intr_dma";
        descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd_intr.c";
        descriptor___0.format = "XactErr with NYET/NAK/ACK\n";
        descriptor___0.lineno = 1832U;
        descriptor___0.flags = 1U;
        tmp___1 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
        if (tmp___1 != 0L) {
          __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)hsotg->dev,
                            "XactErr with NYET/NAK/ACK\n");
        } else {

        }
        qtd->error_count = 0U;
      } else {
        descriptor___1.modname = "dwc2";
        descriptor___1.function = "dwc2_hc_chhltd_intr_dma";
        descriptor___1.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd_intr.c";
        descriptor___1.format = "XactErr without NYET/NAK/ACK\n";
        descriptor___1.lineno = 1836U;
        descriptor___1.flags = 1U;
        tmp___2 = ldv__builtin_expect((long )descriptor___1.flags & 1L, 0L);
        if (tmp___2 != 0L) {
          __dynamic_dev_dbg(& descriptor___1, (struct device  const  *)hsotg->dev,
                            "XactErr without NYET/NAK/ACK\n");
        } else {

        }
      }
    } else {

    }
    dwc2_hc_xacterr_intr(hsotg, chan, chnum, qtd);
  } else
  if ((chan->hcint & 4096U) != 0U && (hsotg->core_params)->dma_desc_enable > 0) {
    dwc2_hc_xacterr_intr(hsotg, chan, chnum, qtd);
  } else
  if ((chan->hcint & 4U) != 0U && (hsotg->core_params)->dma_desc_enable > 0) {
    dwc2_hc_ahberr_intr(hsotg, chan, chnum, qtd);
  } else
  if ((chan->hcint & 256U) != 0U) {
    dwc2_hc_babble_intr(hsotg, chan, chnum, qtd);
  } else
  if ((chan->hcint & 512U) != 0U) {
    dwc2_hc_frmovrun_intr(hsotg, chan, chnum, qtd);
  } else
  if (out_nak_enh == 0) {
    if ((chan->hcint & 64U) != 0U) {
      dwc2_hc_nyet_intr(hsotg, chan, chnum, qtd);
    } else
    if ((chan->hcint & 16U) != 0U && (hcintmsk & 16U) == 0U) {
      dwc2_hc_nak_intr(hsotg, chan, chnum, qtd);
    } else
    if ((chan->hcint & 32U) != 0U && (hcintmsk & 32U) == 0U) {
      dwc2_hc_ack_intr(hsotg, chan, chnum, qtd);
    } else
    if ((unsigned int )*((unsigned char *)chan + 3UL) == 3U || (unsigned int )*((unsigned char *)chan + 3UL) == 1U) {
      descriptor___2.modname = "dwc2";
      descriptor___2.function = "dwc2_hc_chhltd_intr_dma";
      descriptor___2.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd_intr.c";
      descriptor___2.format = "%s: Halt channel %d (assume incomplete periodic transfer)\n";
      descriptor___2.lineno = 1896U;
      descriptor___2.flags = 1U;
      tmp___3 = ldv__builtin_expect((long )descriptor___2.flags & 1L, 0L);
      if (tmp___3 != 0L) {
        __dynamic_dev_dbg(& descriptor___2, (struct device  const  *)hsotg->dev, "%s: Halt channel %d (assume incomplete periodic transfer)\n",
                          "dwc2_hc_chhltd_intr_dma", chnum);
      } else {

      }
      dwc2_halt_channel(hsotg, chan, qtd, 12);
    } else {
      dev_err((struct device  const  *)hsotg->dev, "%s: Channel %d - ChHltd set, but reason is unknown\n",
              "dwc2_hc_chhltd_intr_dma", chnum);
      tmp___4 = readl((void const volatile   *)hsotg->regs + 20U);
      dev_err((struct device  const  *)hsotg->dev, "hcint 0x%08x, intsts 0x%08x\n",
              chan->hcint, tmp___4);
      goto error;
    }
  } else {
    _dev_info((struct device  const  *)hsotg->dev, "NYET/NAK/ACK/other in non-error case, 0x%08x\n",
              chan->hcint);
    error: 
    qtd->error_count = (u8 )((int )qtd->error_count + 1);
    dwc2_update_urb_state_abn(hsotg, chan, chnum, qtd->urb, qtd, 7);
    dwc2_hcd_save_data_toggle(hsotg, chan, chnum, qtd);
    dwc2_halt_channel(hsotg, chan, qtd, 7);
  }
  return;
}
}
static void dwc2_hc_chhltd_intr(struct dwc2_hsotg *hsotg , struct dwc2_host_chan *chan ,
                                int chnum , struct dwc2_qtd *qtd ) 
{ 
  struct _ddebug descriptor ;
  long tmp ;
  bool tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;

  {
  tmp___0 = dbg_hc(chan);
  if ((int )tmp___0) {
    descriptor.modname = "dwc2";
    descriptor.function = "dwc2_hc_chhltd_intr";
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd_intr.c";
    descriptor.format = "--Host Channel %d Interrupt: Channel Halted--\n";
    descriptor.lineno = 1941U;
    descriptor.flags = 1U;
    tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
    if (tmp != 0L) {
      __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "--Host Channel %d Interrupt: Channel Halted--\n",
                        chnum);
    } else {

    }
  } else {

  }
  if ((hsotg->core_params)->dma_enable > 0) {
    dwc2_hc_chhltd_intr_dma(hsotg, chan, chnum, qtd);
  } else {
    tmp___1 = dwc2_halt_status_ok(hsotg, chan, chnum, qtd);
    if (tmp___1) {
      tmp___2 = 0;
    } else {
      tmp___2 = 1;
    }
    if (tmp___2) {
      return;
    } else {

    }
    dwc2_release_channel(hsotg, chan, qtd, chan->halt_status);
  }
  return;
}
}
static void dwc2_hc_n_intr(struct dwc2_hsotg *hsotg , int chnum ) 
{ 
  struct dwc2_qtd *qtd ;
  struct dwc2_host_chan *chan ;
  u32 hcint ;
  u32 hcintmsk ;
  struct _ddebug descriptor ;
  long tmp ;
  struct _ddebug descriptor___0 ;
  long tmp___0 ;
  bool tmp___1 ;
  int __ret_warn_on ;
  long tmp___2 ;
  struct _ddebug descriptor___1 ;
  long tmp___3 ;
  struct _ddebug descriptor___2 ;
  long tmp___4 ;
  int tmp___5 ;
  struct list_head  const  *__mptr ;

  {
  chan = hsotg->hc_ptr_array[chnum];
  hcint = readl((void const volatile   *)hsotg->regs + (unsigned long )(chnum * 32 + 1288));
  hcintmsk = readl((void const volatile   *)hsotg->regs + (unsigned long )(chnum * 32 + 1292));
  if ((unsigned long )chan == (unsigned long )((struct dwc2_host_chan *)0)) {
    dev_err((struct device  const  *)hsotg->dev, "## hc_ptr_array for channel is NULL ##\n");
    writel(hcint, (void volatile   *)hsotg->regs + (unsigned long )(chnum * 32 + 1288));
    return;
  } else {

  }
  tmp___1 = dbg_hc(chan);
  if ((int )tmp___1) {
    descriptor.modname = "dwc2";
    descriptor.function = "dwc2_hc_n_intr";
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd_intr.c";
    descriptor.format = "--Host Channel Interrupt--, Channel %d\n";
    descriptor.lineno = 1971U;
    descriptor.flags = 1U;
    tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
    if (tmp != 0L) {
      __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "--Host Channel Interrupt--, Channel %d\n",
                        chnum);
    } else {

    }
    descriptor___0.modname = "dwc2";
    descriptor___0.function = "dwc2_hc_n_intr";
    descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd_intr.c";
    descriptor___0.format = "  hcint 0x%08x, hcintmsk 0x%08x, hcint&hcintmsk 0x%08x\n";
    descriptor___0.lineno = 1974U;
    descriptor___0.flags = 1U;
    tmp___0 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
    if (tmp___0 != 0L) {
      __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)hsotg->dev, "  hcint 0x%08x, hcintmsk 0x%08x, hcint&hcintmsk 0x%08x\n",
                        hcint, hcintmsk, hcint & hcintmsk);
    } else {

    }
  } else {

  }
  writel(hcint, (void volatile   *)hsotg->regs + (unsigned long )(chnum * 32 + 1288));
  chan->hcint = hcint;
  hcint = hcint & hcintmsk;
  if ((unsigned int )chan->halt_status == 13U) {
    __ret_warn_on = hcint != 2U;
    tmp___2 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
    if (tmp___2 != 0L) {
      warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd_intr.c",
                         1991);
    } else {

    }
    ldv__builtin_expect(__ret_warn_on != 0, 0L);
    if ((hsotg->core_params)->dma_desc_enable > 0) {
      dwc2_hcd_complete_xfer_ddma(hsotg, chan, chnum, chan->halt_status);
    } else {
      dwc2_release_channel(hsotg, chan, (struct dwc2_qtd *)0, chan->halt_status);
    }
    return;
  } else {

  }
  tmp___5 = list_empty((struct list_head  const  *)(& (chan->qh)->qtd_list));
  if (tmp___5 != 0) {
    descriptor___1.modname = "dwc2";
    descriptor___1.function = "dwc2_hc_n_intr";
    descriptor___1.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd_intr.c";
    descriptor___1.format = "## no QTD queued for channel %d ##\n";
    descriptor___1.lineno = 2007U;
    descriptor___1.flags = 1U;
    tmp___3 = ldv__builtin_expect((long )descriptor___1.flags & 1L, 0L);
    if (tmp___3 != 0L) {
      __dynamic_dev_dbg(& descriptor___1, (struct device  const  *)hsotg->dev, "## no QTD queued for channel %d ##\n",
                        chnum);
    } else {

    }
    descriptor___2.modname = "dwc2";
    descriptor___2.function = "dwc2_hc_n_intr";
    descriptor___2.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd_intr.c";
    descriptor___2.format = "  hcint 0x%08x, hcintmsk 0x%08x, hcint&hcintmsk 0x%08x\n";
    descriptor___2.lineno = 2010U;
    descriptor___2.flags = 1U;
    tmp___4 = ldv__builtin_expect((long )descriptor___2.flags & 1L, 0L);
    if (tmp___4 != 0L) {
      __dynamic_dev_dbg(& descriptor___2, (struct device  const  *)hsotg->dev, "  hcint 0x%08x, hcintmsk 0x%08x, hcint&hcintmsk 0x%08x\n",
                        chan->hcint, hcintmsk, hcint);
    } else {

    }
    chan->halt_status = 0;
    disable_hc_int(hsotg, chnum, 2U);
    chan->hcint = 0U;
    return;
  } else {

  }
  __mptr = (struct list_head  const  *)(chan->qh)->qtd_list.next;
  qtd = (struct dwc2_qtd *)__mptr + 0xffffffffffffffd8UL;
  if ((hsotg->core_params)->dma_enable <= 0) {
    if ((hcint & 2U) != 0U && hcint != 2U) {
      hcint = hcint & 4294967293U;
    } else {

    }
  } else {

  }
  if ((int )hcint & 1) {
    dwc2_hc_xfercomp_intr(hsotg, chan, chnum, qtd);
    hcint = hcint & 4294967231U;
  } else {

  }
  if ((hcint & 2U) != 0U) {
    dwc2_hc_chhltd_intr(hsotg, chan, chnum, qtd);
  } else {

  }
  if ((hcint & 4U) != 0U) {
    dwc2_hc_ahberr_intr(hsotg, chan, chnum, qtd);
  } else {

  }
  if ((hcint & 8U) != 0U) {
    dwc2_hc_stall_intr(hsotg, chan, chnum, qtd);
  } else {

  }
  if ((hcint & 16U) != 0U) {
    dwc2_hc_nak_intr(hsotg, chan, chnum, qtd);
  } else {

  }
  if ((hcint & 32U) != 0U) {
    dwc2_hc_ack_intr(hsotg, chan, chnum, qtd);
  } else {

  }
  if ((hcint & 64U) != 0U) {
    dwc2_hc_nyet_intr(hsotg, chan, chnum, qtd);
  } else {

  }
  if ((hcint & 128U) != 0U) {
    dwc2_hc_xacterr_intr(hsotg, chan, chnum, qtd);
  } else {

  }
  if ((hcint & 256U) != 0U) {
    dwc2_hc_babble_intr(hsotg, chan, chnum, qtd);
  } else {

  }
  if ((hcint & 512U) != 0U) {
    dwc2_hc_frmovrun_intr(hsotg, chan, chnum, qtd);
  } else {

  }
  if ((hcint & 1024U) != 0U) {
    dwc2_hc_datatglerr_intr(hsotg, chan, chnum, qtd);
  } else {

  }
  chan->hcint = 0U;
  return;
}
}
static void dwc2_hc_intr(struct dwc2_hsotg *hsotg ) 
{ 
  u32 haint ;
  int i ;
  struct _ddebug descriptor ;
  long tmp ;
  struct _ddebug descriptor___0 ;
  long tmp___0 ;
  bool tmp___1 ;

  {
  haint = readl((void const volatile   *)hsotg->regs + 1044U);
  tmp___1 = dbg_perio();
  if ((int )tmp___1) {
    descriptor.modname = "dwc2";
    descriptor.function = "dwc2_hc_intr";
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd_intr.c";
    descriptor.format = "%s()\n";
    descriptor.lineno = 2071U;
    descriptor.flags = 1U;
    tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
    if (tmp != 0L) {
      __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "%s()\n",
                        "dwc2_hc_intr");
    } else {

    }
    descriptor___0.modname = "dwc2";
    descriptor___0.function = "dwc2_hc_intr";
    descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd_intr.c";
    descriptor___0.format = "HAINT=%08x\n";
    descriptor___0.lineno = 2073U;
    descriptor___0.flags = 1U;
    tmp___0 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
    if (tmp___0 != 0L) {
      __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)hsotg->dev, "HAINT=%08x\n",
                        haint);
    } else {

    }
  } else {

  }
  i = 0;
  goto ldv_35036;
  ldv_35035: ;
  if (((u32 )(1 << i) & haint) != 0U) {
    dwc2_hc_n_intr(hsotg, i);
  } else {

  }
  i = i + 1;
  ldv_35036: ;
  if ((hsotg->core_params)->host_channels > i) {
    goto ldv_35035;
  } else {

  }

  return;
}
}
irqreturn_t dwc2_handle_hcd_intr(struct dwc2_hsotg *hsotg ) 
{ 
  u32 gintsts ;
  u32 dbg_gintsts ;
  irqreturn_t retval ;
  bool tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;
  struct _ddebug descriptor ;
  long tmp___3 ;
  struct _ddebug descriptor___0 ;
  long tmp___4 ;
  struct _ddebug descriptor___1 ;
  unsigned int tmp___5 ;
  unsigned int tmp___6 ;
  long tmp___7 ;
  int tmp___8 ;

  {
  retval = 0;
  tmp = dwc2_is_controller_alive(hsotg);
  if (tmp) {
    tmp___0 = 0;
  } else {
    tmp___0 = 1;
  }
  if (tmp___0) {
    dev_warn((struct device  const  *)hsotg->dev, "Controller is dead\n");
    return (retval);
  } else {

  }
  spin_lock(& hsotg->lock);
  tmp___8 = dwc2_is_host_mode(hsotg);
  if (tmp___8 != 0) {
    gintsts = dwc2_read_core_intr(hsotg);
    if (gintsts == 0U) {
      spin_unlock(& hsotg->lock);
      return (retval);
    } else {

    }
    retval = 1;
    dbg_gintsts = gintsts;
    dbg_gintsts = dbg_gintsts & 4294967287U;
    tmp___1 = dbg_perio();
    if (tmp___1) {
      tmp___2 = 0;
    } else {
      tmp___2 = 1;
    }
    if (tmp___2) {
      dbg_gintsts = dbg_gintsts & 4194303983U;
    } else {

    }
    if (dbg_gintsts != 0U) {
      descriptor.modname = "dwc2";
      descriptor.function = "dwc2_handle_hcd_intr";
      descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd_intr.c";
      descriptor.format = "DWC OTG HCD Interrupt Detected gintsts&gintmsk=0x%08x\n";
      descriptor.lineno = 2117U;
      descriptor.flags = 1U;
      tmp___3 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
      if (tmp___3 != 0L) {
        __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "DWC OTG HCD Interrupt Detected gintsts&gintmsk=0x%08x\n",
                          gintsts);
      } else {

      }
    } else {

    }
    if ((gintsts & 8U) != 0U) {
      dwc2_sof_intr(hsotg);
    } else {

    }
    if ((gintsts & 16U) != 0U) {
      dwc2_rx_fifo_level_intr(hsotg);
    } else {

    }
    if ((gintsts & 32U) != 0U) {
      dwc2_np_tx_fifo_empty_intr(hsotg);
    } else {

    }
    if ((gintsts & 16777216U) != 0U) {
      dwc2_port_intr(hsotg);
    } else {

    }
    if ((gintsts & 33554432U) != 0U) {
      dwc2_hc_intr(hsotg);
    } else {

    }
    if ((gintsts & 67108864U) != 0U) {
      dwc2_perio_tx_fifo_empty_intr(hsotg);
    } else {

    }
    if (dbg_gintsts != 0U) {
      descriptor___0.modname = "dwc2";
      descriptor___0.function = "dwc2_handle_hcd_intr";
      descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd_intr.c";
      descriptor___0.format = "DWC OTG HCD Finished Servicing Interrupts\n";
      descriptor___0.lineno = 2134U;
      descriptor___0.flags = 1U;
      tmp___4 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
      if (tmp___4 != 0L) {
        __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)hsotg->dev, "DWC OTG HCD Finished Servicing Interrupts\n");
      } else {

      }
      descriptor___1.modname = "dwc2";
      descriptor___1.function = "dwc2_handle_hcd_intr";
      descriptor___1.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd_intr.c";
      descriptor___1.format = "DWC OTG HCD gintsts=0x%08x gintmsk=0x%08x\n";
      descriptor___1.lineno = 2138U;
      descriptor___1.flags = 1U;
      tmp___7 = ldv__builtin_expect((long )descriptor___1.flags & 1L, 0L);
      if (tmp___7 != 0L) {
        tmp___5 = readl((void const volatile   *)hsotg->regs + 24U);
        tmp___6 = readl((void const volatile   *)hsotg->regs + 20U);
        __dynamic_dev_dbg(& descriptor___1, (struct device  const  *)hsotg->dev, "DWC OTG HCD gintsts=0x%08x gintmsk=0x%08x\n",
                          tmp___6, tmp___5);
      } else {

      }
    } else {

    }
  } else {

  }
  spin_unlock(& hsotg->lock);
  return (retval);
}
}
bool ldv_queue_work_on_75(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_3(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_delayed_work_on_76(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_3(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_work_on_77(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_3(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
void ldv_flush_workqueue_78(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
  flush_workqueue(ldv_func_arg1);
  call_and_disable_all_3(2);
  return;
}
}
bool ldv_queue_delayed_work_on_79(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_3(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
__inline static long ldv__builtin_expect(long exp , long c ) ;
bool ldv_queue_work_on_89(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_work_on_91(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_delayed_work_on_90(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
bool ldv_queue_delayed_work_on_93(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
void ldv_flush_workqueue_92(struct workqueue_struct *ldv_func_arg1 ) ;
extern long usb_calc_bus_time(int  , int  , int  , int  ) ;
int dwc2_hcd_qh_add(struct dwc2_hsotg *hsotg , struct dwc2_qh *qh ) ;
int dwc2_hcd_qh_init_ddma(struct dwc2_hsotg *hsotg , struct dwc2_qh *qh , gfp_t mem_flags ) ;
void dwc2_hcd_qh_free_ddma(struct dwc2_hsotg *hsotg , struct dwc2_qh *qh ) ;
__inline static u16 dwc2_frame_num_inc(u16 frame , u16 inc ) 
{ 


  {
  return ((unsigned int )((u16 )((int )frame + (int )inc)) & 16383U);
}
}
static void dwc2_qh_init(struct dwc2_hsotg *hsotg , struct dwc2_qh *qh , struct dwc2_hcd_urb *urb ) 
{ 
  int dev_speed ;
  int hub_addr ;
  int hub_port ;
  char *speed ;
  char *type ;
  struct _ddebug descriptor ;
  long tmp ;
  u8 tmp___0 ;
  struct _ddebug descriptor___0 ;
  u8 tmp___1 ;
  long tmp___2 ;
  u32 hprt ;
  u32 prtspd ;
  int bytecount ;
    klee_make_symbolic(&bytecount, sizeof(int), "bytecount");
  long tmp___3 ;
  struct _ddebug descriptor___1 ;
  long tmp___4 ;
  struct _ddebug descriptor___2 ;
  long tmp___5 ;
  struct _ddebug descriptor___3 ;
  long tmp___6 ;
  struct _ddebug descriptor___4 ;
  u8 tmp___7 ;
  long tmp___8 ;
  struct _ddebug descriptor___5 ;
  u8 tmp___9 ;
  u8 tmp___10 ;
  long tmp___11 ;
  struct _ddebug descriptor___6 ;
  long tmp___12 ;
  struct _ddebug descriptor___7 ;
  long tmp___13 ;
  struct _ddebug descriptor___8 ;
  long tmp___14 ;
  struct _ddebug descriptor___9 ;
  long tmp___15 ;

  {
  descriptor.modname = "dwc2";
  descriptor.function = "dwc2_qh_init";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd_queue.c";
  descriptor.format = "%s()\n";
  descriptor.lineno = 71U;
  descriptor.flags = 1U;
  tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp != 0L) {
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "%s()\n",
                      "dwc2_qh_init");
  } else {

  }
  qh->ep_type = dwc2_hcd_get_pipe_type(& urb->pipe_info);
  tmp___0 = dwc2_hcd_is_pipe_in(& urb->pipe_info);
  qh->ep_is_in = (unsigned int )tmp___0 != 0U;
  qh->data_toggle = 0U;
  qh->maxp = dwc2_hcd_get_mps(& urb->pipe_info);
  INIT_LIST_HEAD(& qh->qtd_list);
  INIT_LIST_HEAD(& qh->qh_list_entry);
  dev_speed = dwc2_host_get_speed(hsotg, urb->priv);
  dwc2_host_hub_info(hsotg, urb->priv, & hub_addr, & hub_port);
  if (((dev_speed == 1 || dev_speed == 2) && hub_addr != 0) && hub_addr != 1) {
    descriptor___0.modname = "dwc2";
    descriptor___0.function = "dwc2_qh_init";
    descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd_queue.c";
    descriptor___0.format = "QH init: EP %d: TT found at hub addr %d, for port %d\n";
    descriptor___0.lineno = 92U;
    descriptor___0.flags = 1U;
    tmp___2 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
    if (tmp___2 != 0L) {
      tmp___1 = dwc2_hcd_get_ep_num(& urb->pipe_info);
      __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)hsotg->dev, "QH init: EP %d: TT found at hub addr %d, for port %d\n",
                        (int )tmp___1, hub_addr, hub_port);
    } else {

    }
    qh->do_split = 1U;
  } else {

  }
  if ((unsigned int )qh->ep_type == 3U || (unsigned int )qh->ep_type == 1U) {
    bytecount = ((((int )qh->maxp >> 11) & 3) + 1) * ((int )qh->maxp & 2047);
    tmp___3 = usb_calc_bus_time((unsigned int )qh->do_split == 0U ? dev_speed : 3,
                                (int )qh->ep_is_in, (unsigned int )qh->ep_type == 1U,
                                bytecount);
    qh->usecs = (u16 )((tmp___3 + 999L) / 1000L);
    qh->sched_frame = dwc2_frame_num_inc((int )hsotg->frame_number, 10);
    qh->interval = urb->interval;
    hprt = readl((void const volatile   *)hsotg->regs + 1088U);
    prtspd = (hprt & 393216U) >> 17;
    if (prtspd == 0U && (dev_speed == 1 || dev_speed == 2)) {
      qh->interval = (unsigned int )qh->interval * 8U;
      qh->sched_frame = (u16 )((unsigned int )qh->sched_frame | 7U);
      qh->start_split_frame = qh->sched_frame;
    } else {

    }
    descriptor___1.modname = "dwc2";
    descriptor___1.function = "dwc2_qh_init";
    descriptor___1.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd_queue.c";
    descriptor___1.format = "interval=%d\n";
    descriptor___1.lineno = 127U;
    descriptor___1.flags = 1U;
    tmp___4 = ldv__builtin_expect((long )descriptor___1.flags & 1L, 0L);
    if (tmp___4 != 0L) {
      __dynamic_dev_dbg(& descriptor___1, (struct device  const  *)hsotg->dev, "interval=%d\n",
                        (int )qh->interval);
    } else {

    }
  } else {

  }
  descriptor___2.modname = "dwc2";
  descriptor___2.function = "dwc2_qh_init";
  descriptor___2.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd_queue.c";
  descriptor___2.format = "DWC OTG HCD QH Initialized\n";
  descriptor___2.lineno = 130U;
  descriptor___2.flags = 1U;
  tmp___5 = ldv__builtin_expect((long )descriptor___2.flags & 1L, 0L);
  if (tmp___5 != 0L) {
    __dynamic_dev_dbg(& descriptor___2, (struct device  const  *)hsotg->dev, "DWC OTG HCD QH Initialized\n");
  } else {

  }
  descriptor___3.modname = "dwc2";
  descriptor___3.function = "dwc2_qh_init";
  descriptor___3.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd_queue.c";
  descriptor___3.format = "DWC OTG HCD QH - qh = %p\n";
  descriptor___3.lineno = 131U;
  descriptor___3.flags = 1U;
  tmp___6 = ldv__builtin_expect((long )descriptor___3.flags & 1L, 0L);
  if (tmp___6 != 0L) {
    __dynamic_dev_dbg(& descriptor___3, (struct device  const  *)hsotg->dev, "DWC OTG HCD QH - qh = %p\n",
                      qh);
  } else {

  }
  descriptor___4.modname = "dwc2";
  descriptor___4.function = "dwc2_qh_init";
  descriptor___4.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd_queue.c";
  descriptor___4.format = "DWC OTG HCD QH - Device Address = %d\n";
  descriptor___4.lineno = 133U;
  descriptor___4.flags = 1U;
  tmp___8 = ldv__builtin_expect((long )descriptor___4.flags & 1L, 0L);
  if (tmp___8 != 0L) {
    tmp___7 = dwc2_hcd_get_dev_addr(& urb->pipe_info);
    __dynamic_dev_dbg(& descriptor___4, (struct device  const  *)hsotg->dev, "DWC OTG HCD QH - Device Address = %d\n",
                      (int )tmp___7);
  } else {

  }
  descriptor___5.modname = "dwc2";
  descriptor___5.function = "dwc2_qh_init";
  descriptor___5.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd_queue.c";
  descriptor___5.format = "DWC OTG HCD QH - Endpoint %d, %s\n";
  descriptor___5.lineno = 136U;
  descriptor___5.flags = 1U;
  tmp___11 = ldv__builtin_expect((long )descriptor___5.flags & 1L, 0L);
  if (tmp___11 != 0L) {
    tmp___9 = dwc2_hcd_is_pipe_in(& urb->pipe_info);
    tmp___10 = dwc2_hcd_get_ep_num(& urb->pipe_info);
    __dynamic_dev_dbg(& descriptor___5, (struct device  const  *)hsotg->dev, "DWC OTG HCD QH - Endpoint %d, %s\n",
                      (int )tmp___10, (unsigned int )tmp___9 != 0U ? (char *)"IN" : (char *)"OUT");
  } else {

  }
  qh->dev_speed = (u8 )dev_speed;
  switch (dev_speed) {
  case 1: 
  speed = (char *)"low";
  goto ldv_34600;
  case 2: 
  speed = (char *)"full";
  goto ldv_34600;
  case 3: 
  speed = (char *)"high";
  goto ldv_34600;
  default: 
  speed = (char *)"?";
  goto ldv_34600;
  }
  ldv_34600: 
  descriptor___6.modname = "dwc2";
  descriptor___6.function = "dwc2_qh_init";
  descriptor___6.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd_queue.c";
  descriptor___6.format = "DWC OTG HCD QH - Speed = %s\n";
  descriptor___6.lineno = 154U;
  descriptor___6.flags = 1U;
  tmp___12 = ldv__builtin_expect((long )descriptor___6.flags & 1L, 0L);
  if (tmp___12 != 0L) {
    __dynamic_dev_dbg(& descriptor___6, (struct device  const  *)hsotg->dev, "DWC OTG HCD QH - Speed = %s\n",
                      speed);
  } else {

  }
  switch ((int )qh->ep_type) {
  case 1: 
  type = (char *)"isochronous";
  goto ldv_34606;
  case 3: 
  type = (char *)"interrupt";
  goto ldv_34606;
  case 0: 
  type = (char *)"control";
  goto ldv_34606;
  case 2: 
  type = (char *)"bulk";
  goto ldv_34606;
  default: 
  type = (char *)"?";
  goto ldv_34606;
  }
  ldv_34606: 
  descriptor___7.modname = "dwc2";
  descriptor___7.function = "dwc2_qh_init";
  descriptor___7.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd_queue.c";
  descriptor___7.format = "DWC OTG HCD QH - Type = %s\n";
  descriptor___7.lineno = 174U;
  descriptor___7.flags = 1U;
  tmp___13 = ldv__builtin_expect((long )descriptor___7.flags & 1L, 0L);
  if (tmp___13 != 0L) {
    __dynamic_dev_dbg(& descriptor___7, (struct device  const  *)hsotg->dev, "DWC OTG HCD QH - Type = %s\n",
                      type);
  } else {

  }
  if ((unsigned int )qh->ep_type == 3U) {
    descriptor___8.modname = "dwc2";
    descriptor___8.function = "dwc2_qh_init";
    descriptor___8.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd_queue.c";
    descriptor___8.format = "DWC OTG HCD QH - usecs = %d\n";
    descriptor___8.lineno = 178U;
    descriptor___8.flags = 1U;
    tmp___14 = ldv__builtin_expect((long )descriptor___8.flags & 1L, 0L);
    if (tmp___14 != 0L) {
      __dynamic_dev_dbg(& descriptor___8, (struct device  const  *)hsotg->dev, "DWC OTG HCD QH - usecs = %d\n",
                        (int )qh->usecs);
    } else {

    }
    descriptor___9.modname = "dwc2";
    descriptor___9.function = "dwc2_qh_init";
    descriptor___9.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd_queue.c";
    descriptor___9.format = "DWC OTG HCD QH - interval = %d\n";
    descriptor___9.lineno = 180U;
    descriptor___9.flags = 1U;
    tmp___15 = ldv__builtin_expect((long )descriptor___9.flags & 1L, 0L);
    if (tmp___15 != 0L) {
      __dynamic_dev_dbg(& descriptor___9, (struct device  const  *)hsotg->dev, "DWC OTG HCD QH - interval = %d\n",
                        (int )qh->interval);
    } else {

    }
  } else {

  }
  return;
}
}
static struct dwc2_qh *dwc2_hcd_qh_create(struct dwc2_hsotg *hsotg , struct dwc2_hcd_urb *urb ,
                                          gfp_t mem_flags ) 
{ 
  struct dwc2_qh *qh ;
  void *tmp ;
  int tmp___0 ;

  {
  if ((unsigned long )urb->priv == (unsigned long )((void *)0)) {
    return ((struct dwc2_qh *)0);
  } else {

  }
  tmp = kzalloc(136UL, mem_flags);
  qh = (struct dwc2_qh *)tmp;
  if ((unsigned long )qh == (unsigned long )((struct dwc2_qh *)0)) {
    return ((struct dwc2_qh *)0);
  } else {

  }
  dwc2_qh_init(hsotg, qh, urb);
  if ((hsotg->core_params)->dma_desc_enable > 0) {
    tmp___0 = dwc2_hcd_qh_init_ddma(hsotg, qh, mem_flags);
    if (tmp___0 < 0) {
      dwc2_hcd_qh_free(hsotg, qh);
      return ((struct dwc2_qh *)0);
    } else {

    }
  } else {

  }
  return (qh);
}
}
void dwc2_hcd_qh_free(struct dwc2_hsotg *hsotg , struct dwc2_qh *qh ) 
{ 


  {
  if ((hsotg->core_params)->dma_desc_enable > 0) {
    dwc2_hcd_qh_free_ddma(hsotg, qh);
  } else {
    kfree((void const   *)qh->dw_align_buf);
    qh->dw_align_buf_dma = 0ULL;
  }
  kfree((void const   *)qh);
  return;
}
}
static int dwc2_periodic_channel_available(struct dwc2_hsotg *hsotg ) 
{ 
  int status ;
  int num_channels ;
  struct _ddebug descriptor ;
  long tmp ;

  {
  num_channels = (hsotg->core_params)->host_channels;
  if (hsotg->periodic_channels + hsotg->non_periodic_channels < num_channels && hsotg->periodic_channels < num_channels + -1) {
    status = 0;
  } else {
    descriptor.modname = "dwc2";
    descriptor.function = "dwc2_periodic_channel_available";
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd_queue.c";
    descriptor.format = "%s: Total channels: %d, Periodic: %d, Non-periodic: %d\n";
    descriptor.lineno = 269U;
    descriptor.flags = 1U;
    tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
    if (tmp != 0L) {
      __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "%s: Total channels: %d, Periodic: %d, Non-periodic: %d\n",
                        "dwc2_periodic_channel_available", num_channels, hsotg->periodic_channels,
                        hsotg->non_periodic_channels);
    } else {

    }
    status = -28;
  }
  return (status);
}
}
static int dwc2_check_periodic_bandwidth(struct dwc2_hsotg *hsotg , struct dwc2_qh *qh ) 
{ 
  int status ;
  s16 max_claimed_usecs ;

  {
  status = 0;
  if ((unsigned int )qh->dev_speed == 3U || (unsigned int )qh->do_split != 0U) {
    max_claimed_usecs = (s16 )(100U - (unsigned int )qh->usecs);
  } else {
    max_claimed_usecs = (s16 )(900U - (unsigned int )qh->usecs);
  }
  if ((int )hsotg->periodic_usecs > (int )max_claimed_usecs) {
    dev_err((struct device  const  *)hsotg->dev, "%s: already claimed usecs %d, required usecs %d\n",
            "dwc2_check_periodic_bandwidth", (int )hsotg->periodic_usecs, (int )qh->usecs);
    status = -28;
  } else {

  }
  return (status);
}
}
static unsigned short const   max_uframe_usecs[8U]  = 
  {      100U,      100U,      100U,      100U, 
        100U,      100U,      30U,      0U};
void dwc2_hcd_init_usecs(struct dwc2_hsotg *hsotg ) 
{ 
  int i ;

  {
  i = 0;
  goto ldv_34644;
  ldv_34643: 
  hsotg->frame_usecs[i] = max_uframe_usecs[i];
  i = i + 1;
  ldv_34644: ;
  if (i <= 7) {
    goto ldv_34643;
  } else {

  }

  return;
}
}
static int dwc2_find_single_uframe(struct dwc2_hsotg *hsotg , struct dwc2_qh *qh ) 
{ 
  unsigned short utime ;
    klee_make_symbolic(&utime, sizeof(short), "utime");
  int i ;

  {
  utime = qh->usecs;
  i = 0;
  goto ldv_34653;
  ldv_34652: ;
  if ((int )hsotg->frame_usecs[i] >= (int )utime) {
    hsotg->frame_usecs[i] = (int )hsotg->frame_usecs[i] - (int )utime;
    qh->frame_usecs[i] = (int )qh->frame_usecs[i] + (int )utime;
    return (i);
  } else {

  }
  i = i + 1;
  ldv_34653: ;
  if (i <= 7) {
    goto ldv_34652;
  } else {

  }

  return (-28);
}
}
static int dwc2_find_multi_uframe(struct dwc2_hsotg *hsotg , struct dwc2_qh *qh ) 
{ 
  unsigned short utime ;
  unsigned short xtime ;
    klee_make_symbolic(&xtime, sizeof(short), "xtime");
  int t_left ;
    klee_make_symbolic(&t_left, sizeof(int), "t_left");
  int i ;
  int j ;
    klee_make_symbolic(&j, sizeof(int), "j");
  int k ;
    klee_make_symbolic(&k, sizeof(int), "k");

  {
  utime = qh->usecs;
  i = 0;
  goto ldv_34674;
  ldv_34673: ;
  if ((unsigned int )hsotg->frame_usecs[i] == 0U) {
    goto ldv_34665;
  } else {

  }
  xtime = hsotg->frame_usecs[i];
  j = i + 1;
  goto ldv_34671;
  ldv_34670: ;
  if ((int )xtime + (int )hsotg->frame_usecs[j] < (int )utime) {
    if ((int )hsotg->frame_usecs[j] < (int )((unsigned short )max_uframe_usecs[j])) {
      goto ldv_34666;
    } else {

    }
  } else {

  }
  if ((int )xtime >= (int )utime) {
    t_left = (int )utime;
    k = i;
    goto ldv_34668;
    ldv_34667: 
    t_left = t_left - (int )hsotg->frame_usecs[k];
    if (t_left <= 0) {
      qh->frame_usecs[k] = (int )qh->frame_usecs[k] + ((int )hsotg->frame_usecs[k] + (int )((u16 )t_left));
      hsotg->frame_usecs[k] = - ((int )((u16 )t_left));
      return (i);
    } else {
      qh->frame_usecs[k] = (int )qh->frame_usecs[k] + (int )hsotg->frame_usecs[k];
      hsotg->frame_usecs[k] = 0U;
    }
    k = k + 1;
    ldv_34668: ;
    if (k <= 7) {
      goto ldv_34667;
    } else {

    }

  } else {

  }
  xtime = (int )hsotg->frame_usecs[j] + (int )xtime;
  if ((int )xtime < (int )utime && (int )hsotg->frame_usecs[j] == (int )((unsigned short )max_uframe_usecs[j])) {

  } else {

  }
  ldv_34666: 
  j = j + 1;
  ldv_34671: ;
  if (j <= 7) {
    goto ldv_34670;
  } else {

  }

  ldv_34665: 
  i = i + 1;
  ldv_34674: ;
  if (i <= 7) {
    goto ldv_34673;
  } else {

  }

  return (-28);
}
}
static int dwc2_find_uframe(struct dwc2_hsotg *hsotg , struct dwc2_qh *qh ) 
{ 
  int ret ;

  {
  if ((unsigned int )qh->dev_speed == 3U) {
    ret = dwc2_find_single_uframe(hsotg, qh);
  } else {
    ret = dwc2_find_multi_uframe(hsotg, qh);
  }
  return (ret);
}
}
static int dwc2_check_max_xfer_size(struct dwc2_hsotg *hsotg , struct dwc2_qh *qh ) 
{ 
  u32 max_xfer_size ;
  u32 max_channel_xfer_size ;
  int status ;

  {
  status = 0;
  max_xfer_size = (u32 )(((int )qh->maxp & 2047) * ((((int )qh->maxp >> 11) & 3) + 1));
  max_channel_xfer_size = (u32 )(hsotg->core_params)->max_transfer_size;
  if (max_xfer_size > max_channel_xfer_size) {
    dev_err((struct device  const  *)hsotg->dev, "%s: Periodic xfer length %d > max xfer length for channel %d\n",
            "dwc2_check_max_xfer_size", max_xfer_size, max_channel_xfer_size);
    status = -28;
  } else {

  }
  return (status);
}
}
static int dwc2_schedule_periodic(struct dwc2_hsotg *hsotg , struct dwc2_qh *qh ) 
{ 
  int status ;
  int frame ;
    klee_make_symbolic(&frame, sizeof(int), "frame");
  struct _ddebug descriptor ;
  long tmp ;
  struct _ddebug descriptor___0 ;
  long tmp___0 ;

  {
  if ((hsotg->core_params)->uframe_sched > 0) {
    frame = -1;
    status = dwc2_find_uframe(hsotg, qh);
    if (status == 0) {
      frame = 7;
    } else
    if (status > 0) {
      frame = status + -1;
    } else {

    }
    if (frame >= 0) {
      qh->sched_frame = (unsigned int )qh->sched_frame & 65528U;
      qh->sched_frame = (u16 )((int )((short )qh->sched_frame) | ((int )((short )frame) & 7));
    } else {

    }
    if (status > 0) {
      status = 0;
    } else {

    }
  } else {
    status = dwc2_periodic_channel_available(hsotg);
    if (status != 0) {
      _dev_info((struct device  const  *)hsotg->dev, "%s: No host channel available for periodic transfer\n",
                "dwc2_schedule_periodic");
      return (status);
    } else {

    }
    status = dwc2_check_periodic_bandwidth(hsotg, qh);
  }
  if (status != 0) {
    descriptor.modname = "dwc2";
    descriptor.function = "dwc2_schedule_periodic";
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd_queue.c";
    descriptor.format = "%s: Insufficient periodic bandwidth for periodic transfer\n";
    descriptor.lineno = 506U;
    descriptor.flags = 1U;
    tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
    if (tmp != 0L) {
      __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "%s: Insufficient periodic bandwidth for periodic transfer\n",
                        "dwc2_schedule_periodic");
    } else {

    }
    return (status);
  } else {

  }
  status = dwc2_check_max_xfer_size(hsotg, qh);
  if (status != 0) {
    descriptor___0.modname = "dwc2";
    descriptor___0.function = "dwc2_schedule_periodic";
    descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd_queue.c";
    descriptor___0.format = "%s: Channel max transfer size too small for periodic transfer\n";
    descriptor___0.lineno = 514U;
    descriptor___0.flags = 1U;
    tmp___0 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
    if (tmp___0 != 0L) {
      __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)hsotg->dev, "%s: Channel max transfer size too small for periodic transfer\n",
                        "dwc2_schedule_periodic");
    } else {

    }
    return (status);
  } else {

  }
  if ((hsotg->core_params)->dma_desc_enable > 0) {
    list_add_tail(& qh->qh_list_entry, & hsotg->periodic_sched_ready);
  } else {
    list_add_tail(& qh->qh_list_entry, & hsotg->periodic_sched_inactive);
  }
  if ((hsotg->core_params)->uframe_sched <= 0) {
    hsotg->periodic_channels = hsotg->periodic_channels + 1;
  } else {

  }
  hsotg->periodic_usecs = (int )hsotg->periodic_usecs + (int )qh->usecs;
  return (status);
}
}
static void dwc2_deschedule_periodic(struct dwc2_hsotg *hsotg , struct dwc2_qh *qh ) 
{ 
  int i ;

  {
  list_del_init(& qh->qh_list_entry);
  hsotg->periodic_usecs = (int )hsotg->periodic_usecs - (int )qh->usecs;
  if ((hsotg->core_params)->uframe_sched > 0) {
    i = 0;
    goto ldv_34704;
    ldv_34703: 
    hsotg->frame_usecs[i] = (int )hsotg->frame_usecs[i] + (int )qh->frame_usecs[i];
    qh->frame_usecs[i] = 0U;
    i = i + 1;
    ldv_34704: ;
    if (i <= 7) {
      goto ldv_34703;
    } else {

    }

  } else {
    hsotg->periodic_channels = hsotg->periodic_channels - 1;
  }
  return;
}
}
int dwc2_hcd_qh_add(struct dwc2_hsotg *hsotg , struct dwc2_qh *qh ) 
{ 
  int status ;
  u32 intr_mask ;
  struct _ddebug descriptor ;
  long tmp ;
  bool tmp___0 ;
  int tmp___1 ;

  {
  tmp___0 = dbg_qh(qh);
  if ((int )tmp___0) {
    descriptor.modname = "dwc2";
    descriptor.function = "dwc2_hcd_qh_add";
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd_queue.c";
    descriptor.format = "%s()\n";
    descriptor.lineno = 580U;
    descriptor.flags = 1U;
    tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
    if (tmp != 0L) {
      __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "%s()\n",
                        "dwc2_hcd_qh_add");
    } else {

    }
  } else {

  }
  tmp___1 = list_empty((struct list_head  const  *)(& qh->qh_list_entry));
  if (tmp___1 == 0) {
    return (0);
  } else {

  }
  if ((unsigned int )qh->ep_type == 2U || (unsigned int )qh->ep_type == 0U) {
    list_add_tail(& qh->qh_list_entry, & hsotg->non_periodic_sched_inactive);
    return (0);
  } else {

  }
  status = dwc2_schedule_periodic(hsotg, qh);
  if (status != 0) {
    return (status);
  } else {

  }
  if ((unsigned int )hsotg->periodic_qh_count == 0U) {
    intr_mask = readl((void const volatile   *)hsotg->regs + 24U);
    intr_mask = intr_mask | 8U;
    writel(intr_mask, (void volatile   *)hsotg->regs + 24U);
  } else {

  }
  hsotg->periodic_qh_count = (u16 )((int )hsotg->periodic_qh_count + 1);
  return (0);
}
}
void dwc2_hcd_qh_unlink(struct dwc2_hsotg *hsotg , struct dwc2_qh *qh ) 
{ 
  u32 intr_mask ;
  struct _ddebug descriptor ;
  long tmp ;
  int tmp___0 ;

  {
  descriptor.modname = "dwc2";
  descriptor.function = "dwc2_hcd_qh_unlink";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd_queue.c";
  descriptor.format = "%s()\n";
  descriptor.lineno = 618U;
  descriptor.flags = 1U;
  tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp != 0L) {
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "%s()\n",
                      "dwc2_hcd_qh_unlink");
  } else {

  }
  tmp___0 = list_empty((struct list_head  const  *)(& qh->qh_list_entry));
  if (tmp___0 != 0) {
    return;
  } else {

  }
  if ((unsigned int )qh->ep_type == 2U || (unsigned int )qh->ep_type == 0U) {
    if ((unsigned long )hsotg->non_periodic_qh_ptr == (unsigned long )(& qh->qh_list_entry)) {
      hsotg->non_periodic_qh_ptr = (hsotg->non_periodic_qh_ptr)->next;
    } else {

    }
    list_del_init(& qh->qh_list_entry);
    return;
  } else {

  }
  dwc2_deschedule_periodic(hsotg, qh);
  hsotg->periodic_qh_count = (u16 )((int )hsotg->periodic_qh_count - 1);
  if ((unsigned int )hsotg->periodic_qh_count == 0U) {
    intr_mask = readl((void const volatile   *)hsotg->regs + 24U);
    intr_mask = intr_mask & 4294967287U;
    writel(intr_mask, (void volatile   *)hsotg->regs + 24U);
  } else {

  }
  return;
}
}
static void dwc2_sched_periodic_split(struct dwc2_hsotg *hsotg , struct dwc2_qh *qh ,
                                      u16 frame_number , int sched_next_periodic_split ) 
{ 
  u16 incr ;
  int tmp ;
  int tmp___0 ;

  {
  if (sched_next_periodic_split != 0) {
    qh->sched_frame = frame_number;
    incr = dwc2_frame_num_inc((int )qh->start_split_frame, 1);
    tmp = dwc2_frame_num_le((int )frame_number, (int )incr);
    if (tmp != 0) {
      if ((unsigned int )qh->ep_type != 1U || (unsigned int )qh->ep_is_in != 0U) {
        qh->sched_frame = dwc2_frame_num_inc((int )qh->sched_frame, 1);
      } else {

      }
    } else {

    }
  } else {
    qh->sched_frame = dwc2_frame_num_inc((int )qh->start_split_frame, (int )qh->interval);
    tmp___0 = dwc2_frame_num_le((int )qh->sched_frame, (int )frame_number);
    if (tmp___0 != 0) {
      qh->sched_frame = frame_number;
    } else {

    }
    qh->sched_frame = (u16 )((unsigned int )qh->sched_frame | 7U);
    qh->start_split_frame = qh->sched_frame;
  }
  return;
}
}
void dwc2_hcd_qh_deactivate(struct dwc2_hsotg *hsotg , struct dwc2_qh *qh , int sched_next_periodic_split ) 
{ 
  u16 frame_number ;
  struct _ddebug descriptor ;
  long tmp ;
  bool tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  tmp___0 = dbg_qh(qh);
  if ((int )tmp___0) {
    descriptor.modname = "dwc2";
    descriptor.function = "dwc2_hcd_qh_deactivate";
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd_queue.c";
    descriptor.format = "%s()\n";
    descriptor.lineno = 695U;
    descriptor.flags = 1U;
    tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
    if (tmp != 0L) {
      __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "%s()\n",
                        "dwc2_hcd_qh_deactivate");
    } else {

    }
  } else {

  }
  if ((unsigned int )qh->ep_type == 2U || (unsigned int )qh->ep_type == 0U) {
    dwc2_hcd_qh_unlink(hsotg, qh);
    tmp___1 = list_empty((struct list_head  const  *)(& qh->qtd_list));
    if (tmp___1 == 0) {
      dwc2_hcd_qh_add(hsotg, qh);
    } else {

    }
    return;
  } else {

  }
  tmp___2 = dwc2_hcd_get_frame_number(hsotg);
  frame_number = (u16 )tmp___2;
  if ((unsigned int )qh->do_split != 0U) {
    dwc2_sched_periodic_split(hsotg, qh, (int )frame_number, sched_next_periodic_split);
  } else {
    qh->sched_frame = dwc2_frame_num_inc((int )qh->sched_frame, (int )qh->interval);
    tmp___3 = dwc2_frame_num_le((int )qh->sched_frame, (int )frame_number);
    if (tmp___3 != 0) {
      qh->sched_frame = frame_number;
    } else {

    }
  }
  tmp___4 = list_empty((struct list_head  const  *)(& qh->qtd_list));
  if (tmp___4 != 0) {
    dwc2_hcd_qh_unlink(hsotg, qh);
    return;
  } else {

  }
  if ((hsotg->core_params)->uframe_sched > 0) {
    tmp___5 = dwc2_frame_num_le((int )qh->sched_frame, (int )frame_number);
    if (tmp___5 != 0) {
      list_move(& qh->qh_list_entry, & hsotg->periodic_sched_ready);
    } else {
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
  if ((hsotg->core_params)->uframe_sched <= 0 && (int )qh->sched_frame == (int )frame_number) {
    list_move(& qh->qh_list_entry, & hsotg->periodic_sched_ready);
  } else {
    list_move(& qh->qh_list_entry, & hsotg->periodic_sched_inactive);
  }
  return;
}
}
void dwc2_hcd_qtd_init(struct dwc2_qtd *qtd , struct dwc2_hcd_urb *urb ) 
{ 
  u8 tmp ;

  {
  qtd->urb = urb;
  tmp = dwc2_hcd_get_pipe_type(& urb->pipe_info);
  if ((unsigned int )tmp == 0U) {
    qtd->data_toggle = 2U;
    qtd->control_phase = 0;
  } else {

  }
  qtd->complete_split = 0U;
  qtd->isoc_split_pos = 3U;
  qtd->isoc_split_offset = 0U;
  qtd->in_process = 0U;
  urb->qtd = qtd;
  return;
}
}
int dwc2_hcd_qtd_add(struct dwc2_hsotg *hsotg , struct dwc2_qtd *qtd , struct dwc2_qh **qh ,
                     gfp_t mem_flags ) 
{ 
  struct dwc2_hcd_urb *urb ;
  int allocated ;
    klee_make_symbolic(&allocated, sizeof(int), "allocated");
  int retval ;
  struct dwc2_qtd *qtd2 ;
  struct dwc2_qtd *qtd2_tmp ;
  struct dwc2_qh *qh_tmp ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;

  {
  urb = qtd->urb;
  allocated = 0;
  if ((unsigned long )*qh == (unsigned long )((struct dwc2_qh *)0)) {
    *qh = dwc2_hcd_qh_create(hsotg, urb, mem_flags);
    if ((unsigned long )*qh == (unsigned long )((struct dwc2_qh *)0)) {
      return (-12);
    } else {

    }
    allocated = 1;
  } else {

  }
  retval = dwc2_hcd_qh_add(hsotg, *qh);
  if (retval != 0) {
    goto fail;
  } else {

  }
  qtd->qh = *qh;
  list_add_tail(& qtd->qtd_list_entry, & (*qh)->qtd_list);
  return (0);
  fail: ;
  if (allocated != 0) {
    qh_tmp = *qh;
    *qh = (struct dwc2_qh *)0;
    dwc2_hcd_qh_unlink(hsotg, qh_tmp);
    __mptr = (struct list_head  const  *)qh_tmp->qtd_list.next;
    qtd2 = (struct dwc2_qtd *)__mptr + 0xffffffffffffffd8UL;
    __mptr___0 = (struct list_head  const  *)qtd2->qtd_list_entry.next;
    qtd2_tmp = (struct dwc2_qtd *)__mptr___0 + 0xffffffffffffffd8UL;
    goto ldv_34760;
    ldv_34759: 
    dwc2_hcd_qtd_unlink_and_free(hsotg, qtd2, qh_tmp);
    qtd2 = qtd2_tmp;
    __mptr___1 = (struct list_head  const  *)qtd2_tmp->qtd_list_entry.next;
    qtd2_tmp = (struct dwc2_qtd *)__mptr___1 + 0xffffffffffffffd8UL;
    ldv_34760: ;
    if ((unsigned long )(& qtd2->qtd_list_entry) != (unsigned long )(& qh_tmp->qtd_list)) {
      goto ldv_34759;
    } else {

    }
    dwc2_hcd_qh_free(hsotg, qh_tmp);
  } else {

  }
  return (retval);
}
}
bool ldv_queue_work_on_89(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_3(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_delayed_work_on_90(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_3(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_work_on_91(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_3(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
void ldv_flush_workqueue_92(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
  flush_workqueue(ldv_func_arg1);
  call_and_disable_all_3(2);
  return;
}
}
bool ldv_queue_delayed_work_on_93(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_3(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
__inline static long ldv__builtin_expect(long exp , long c ) ;
extern int printk(char const   *  , ...) ;
bool ldv_queue_work_on_103(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_work_on_105(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_delayed_work_on_104(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
bool ldv_queue_delayed_work_on_107(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
void ldv_flush_workqueue_106(struct workqueue_struct *ldv_func_arg1 ) ;
__inline static u16 dwc2_micro_frame_num(u16 frame ) 
{ 


  {
  return ((unsigned int )frame & 7U);
}
}
static u16 dwc2_frame_list_idx(u16 frame ) 
{ 


  {
  return ((unsigned int )frame & 63U);
}
}
static u16 dwc2_desclist_idx_inc(u16 idx , u16 inc , u8 speed ) 
{ 


  {
  return ((u16 )((int )((short )((int )idx + (int )inc)) & ((unsigned int )speed == 3U ? 255 : 63)));
}
}
static u16 dwc2_desclist_idx_dec(u16 idx , u16 inc , u8 speed ) 
{ 


  {
  return ((u16 )((int )((short )((int )idx - (int )inc)) & ((unsigned int )speed == 3U ? 255 : 63)));
}
}
static u16 dwc2_max_desc_num(struct dwc2_qh *qh ) 
{ 


  {
  return ((unsigned int )qh->ep_type == 1U && (unsigned int )qh->dev_speed == 3U ? 256U : 64U);
}
}
static u16 dwc2_frame_incr_val(struct dwc2_qh *qh ) 
{ 


  {
  return ((unsigned int )qh->dev_speed == 3U ? (u16 )(((int )qh->interval + 7) / 8) : qh->interval);
}
}
static int dwc2_desc_list_alloc(struct dwc2_hsotg *hsotg , struct dwc2_qh *qh , gfp_t flags ) 
{ 
  u16 tmp ;
  void *tmp___0 ;
  u16 tmp___1 ;
  u16 tmp___2 ;
  void *tmp___3 ;
  u16 tmp___4 ;

  {
  tmp = dwc2_max_desc_num(qh);
  tmp___0 = dma_alloc_attrs(hsotg->dev, (unsigned long )tmp * 8UL, & qh->desc_list_dma,
                            flags, (struct dma_attrs *)0);
  qh->desc_list = (struct dwc2_hcd_dma_desc *)tmp___0;
  if ((unsigned long )qh->desc_list == (unsigned long )((struct dwc2_hcd_dma_desc *)0)) {
    return (-12);
  } else {

  }
  tmp___1 = dwc2_max_desc_num(qh);
  memset((void *)qh->desc_list, 0, (unsigned long )tmp___1 * 8UL);
  tmp___2 = dwc2_max_desc_num(qh);
  tmp___3 = kzalloc((unsigned long )tmp___2 * 4UL, flags);
  qh->n_bytes = (u32 *)tmp___3;
  if ((unsigned long )qh->n_bytes == (unsigned long )((u32 *)0U)) {
    tmp___4 = dwc2_max_desc_num(qh);
    dma_free_attrs(hsotg->dev, (unsigned long )tmp___4 * 8UL, (void *)qh->desc_list,
                   qh->desc_list_dma, (struct dma_attrs *)0);
    qh->desc_list = (struct dwc2_hcd_dma_desc *)0;
    return (-12);
  } else {

  }
  return (0);
}
}
static void dwc2_desc_list_free(struct dwc2_hsotg *hsotg , struct dwc2_qh *qh ) 
{ 
  u16 tmp ;

  {
  if ((unsigned long )qh->desc_list != (unsigned long )((struct dwc2_hcd_dma_desc *)0)) {
    tmp = dwc2_max_desc_num(qh);
    dma_free_attrs(hsotg->dev, (unsigned long )tmp * 8UL, (void *)qh->desc_list, qh->desc_list_dma,
                   (struct dma_attrs *)0);
    qh->desc_list = (struct dwc2_hcd_dma_desc *)0;
  } else {

  }
  kfree((void const   *)qh->n_bytes);
  qh->n_bytes = (u32 *)0U;
  return;
}
}
static int dwc2_frame_list_alloc(struct dwc2_hsotg *hsotg , gfp_t mem_flags ) 
{ 
  void *tmp ;

  {
  if ((unsigned long )hsotg->frame_list != (unsigned long )((u32 *)0U)) {
    return (0);
  } else {

  }
  tmp = dma_alloc_attrs(hsotg->dev, 256UL, & hsotg->frame_list_dma, mem_flags, (struct dma_attrs *)0);
  hsotg->frame_list = (u32 *)tmp;
  if ((unsigned long )hsotg->frame_list == (unsigned long )((u32 *)0U)) {
    return (-12);
  } else {

  }
  memset((void *)hsotg->frame_list, 0, 256UL);
  return (0);
}
}
static void dwc2_frame_list_free(struct dwc2_hsotg *hsotg ) 
{ 
  u32 *frame_list ;
  dma_addr_t frame_list_dma ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;

  {
  tmp = spinlock_check(& hsotg->lock);
  flags = _raw_spin_lock_irqsave(tmp);
  if ((unsigned long )hsotg->frame_list == (unsigned long )((u32 *)0U)) {
    spin_unlock_irqrestore(& hsotg->lock, flags);
    return;
  } else {

  }
  frame_list = hsotg->frame_list;
  frame_list_dma = hsotg->frame_list_dma;
  hsotg->frame_list = (u32 *)0U;
  spin_unlock_irqrestore(& hsotg->lock, flags);
  dma_free_attrs(hsotg->dev, 256UL, (void *)frame_list, frame_list_dma, (struct dma_attrs *)0);
  return;
}
}
static void dwc2_per_sched_enable(struct dwc2_hsotg *hsotg , u32 fr_list_en ) 
{ 
  u32 hcfg ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;
  struct _ddebug descriptor ;
  long tmp___0 ;

  {
  tmp = spinlock_check(& hsotg->lock);
  flags = _raw_spin_lock_irqsave(tmp);
  hcfg = readl((void const volatile   *)hsotg->regs + 1024U);
  if ((hcfg & 67108864U) != 0U) {
    spin_unlock_irqrestore(& hsotg->lock, flags);
    return;
  } else {

  }
  writel((unsigned int )hsotg->frame_list_dma, (void volatile   *)hsotg->regs + 1052U);
  hcfg = hcfg & 4244635647U;
  hcfg = (fr_list_en | hcfg) | 67108864U;
  descriptor.modname = "dwc2";
  descriptor.function = "dwc2_per_sched_enable";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd_ddma.c";
  descriptor.format = "Enabling Periodic schedule\n";
  descriptor.lineno = 183U;
  descriptor.flags = 1U;
  tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp___0 != 0L) {
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "Enabling Periodic schedule\n");
  } else {

  }
  writel(hcfg, (void volatile   *)hsotg->regs + 1024U);
  spin_unlock_irqrestore(& hsotg->lock, flags);
  return;
}
}
static void dwc2_per_sched_disable(struct dwc2_hsotg *hsotg ) 
{ 
  u32 hcfg ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;
  struct _ddebug descriptor ;
  long tmp___0 ;

  {
  tmp = spinlock_check(& hsotg->lock);
  flags = _raw_spin_lock_irqsave(tmp);
  hcfg = readl((void const volatile   *)hsotg->regs + 1024U);
  if ((hcfg & 67108864U) == 0U) {
    spin_unlock_irqrestore(& hsotg->lock, flags);
    return;
  } else {

  }
  hcfg = hcfg & 4227858431U;
  descriptor.modname = "dwc2";
  descriptor.function = "dwc2_per_sched_disable";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd_ddma.c";
  descriptor.format = "Disabling Periodic schedule\n";
  descriptor.lineno = 204U;
  descriptor.flags = 1U;
  tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp___0 != 0L) {
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "Disabling Periodic schedule\n");
  } else {

  }
  writel(hcfg, (void volatile   *)hsotg->regs + 1024U);
  spin_unlock_irqrestore(& hsotg->lock, flags);
  return;
}
}
static void dwc2_update_frame_list(struct dwc2_hsotg *hsotg , struct dwc2_qh *qh ,
                                   int enable ) 
{ 
  struct dwc2_host_chan *chan ;
  u16 i ;
  u16 j ;
  u16 inc ;

  {
  if ((unsigned long )hsotg == (unsigned long )((struct dwc2_hsotg *)0)) {
    printk("\vhsotg = %p\n", hsotg);
    return;
  } else {

  }
  if ((unsigned long )qh->channel == (unsigned long )((struct dwc2_host_chan *)0)) {
    dev_err((struct device  const  *)hsotg->dev, "qh->channel = %p\n", qh->channel);
    return;
  } else {

  }
  if ((unsigned long )hsotg->frame_list == (unsigned long )((u32 *)0U)) {
    dev_err((struct device  const  *)hsotg->dev, "hsotg->frame_list = %p\n", hsotg->frame_list);
    return;
  } else {

  }
  chan = qh->channel;
  inc = dwc2_frame_incr_val(qh);
  if ((unsigned int )qh->ep_type == 1U) {
    i = dwc2_frame_list_idx((int )qh->sched_frame);
  } else {
    i = 0U;
  }
  j = i;
  ldv_34649: ;
  if (enable != 0) {
    *(hsotg->frame_list + (unsigned long )j) = *(hsotg->frame_list + (unsigned long )j) | (u32 )(1 << (int )chan->hc_num);
  } else {
    *(hsotg->frame_list + (unsigned long )j) = *(hsotg->frame_list + (unsigned long )j) & (u32 )(~ (1 << (int )chan->hc_num));
  }
  j = (unsigned int )((u16 )((int )j + (int )inc)) & 63U;
  if ((int )j != (int )i) {
    goto ldv_34649;
  } else {

  }

  if (enable == 0) {
    return;
  } else {

  }
  chan->schinfo = 0U;
  if ((unsigned int )*((unsigned char *)chan + 2UL) == 48U && (unsigned int )qh->interval != 0U) {
    j = 1U;
    inc = (u16 )(((int )qh->interval + 7) / (int )qh->interval);
    i = 0U;
    goto ldv_34652;
    ldv_34651: 
    chan->schinfo = (int )chan->schinfo | (int )((u8 )j);
    j = (u16 )((int )j << (int )qh->interval);
    i = (u16 )((int )i + 1);
    ldv_34652: ;
    if ((int )i < (int )inc) {
      goto ldv_34651;
    } else {

    }

  } else {
    chan->schinfo = 255U;
  }
  return;
}
}
static void dwc2_release_channel_ddma(struct dwc2_hsotg *hsotg , struct dwc2_qh *qh ) 
{ 
  struct dwc2_host_chan *chan ;
  int tmp ;
  u16 tmp___0 ;

  {
  chan = qh->channel;
  if ((unsigned int )qh->ep_type == 2U || (unsigned int )qh->ep_type == 0U) {
    if ((hsotg->core_params)->uframe_sched > 0) {
      hsotg->available_host_channels = hsotg->available_host_channels + 1;
    } else {
      hsotg->non_periodic_channels = hsotg->non_periodic_channels - 1;
    }
  } else {
    dwc2_update_frame_list(hsotg, qh, 0);
  }
  if ((unsigned long )chan->qh != (unsigned long )((struct dwc2_qh *)0)) {
    tmp = list_empty((struct list_head  const  *)(& chan->hc_list_entry));
    if (tmp == 0) {
      list_del(& chan->hc_list_entry);
    } else {

    }
    dwc2_hc_cleanup(hsotg, chan);
    list_add_tail(& chan->hc_list_entry, & hsotg->free_hc_list);
    chan->qh = (struct dwc2_qh *)0;
  } else {

  }
  qh->channel = (struct dwc2_host_chan *)0;
  qh->ntd = 0U;
  if ((unsigned long )qh->desc_list != (unsigned long )((struct dwc2_hcd_dma_desc *)0)) {
    tmp___0 = dwc2_max_desc_num(qh);
    memset((void *)qh->desc_list, 0, (unsigned long )tmp___0 * 8UL);
  } else {

  }
  return;
}
}
int dwc2_hcd_qh_init_ddma(struct dwc2_hsotg *hsotg , struct dwc2_qh *qh , gfp_t mem_flags ) 
{ 
  int retval ;

  {
  if ((unsigned int )qh->do_split != 0U) {
    dev_err((struct device  const  *)hsotg->dev, "SPLIT Transfers are not supported in Descriptor DMA mode.\n");
    retval = -22;
    goto err0;
  } else {

  }
  retval = dwc2_desc_list_alloc(hsotg, qh, mem_flags);
  if (retval != 0) {
    goto err0;
  } else {

  }
  if ((unsigned int )qh->ep_type == 1U || (unsigned int )qh->ep_type == 3U) {
    if ((unsigned long )hsotg->frame_list == (unsigned long )((u32 *)0U)) {
      retval = dwc2_frame_list_alloc(hsotg, mem_flags);
      if (retval != 0) {
        goto err1;
      } else {

      }
      dwc2_per_sched_enable(hsotg, 50331648U);
    } else {

    }
  } else {

  }
  qh->ntd = 0U;
  return (0);
  err1: 
  dwc2_desc_list_free(hsotg, qh);
  err0: ;
  return (retval);
}
}
void dwc2_hcd_qh_free_ddma(struct dwc2_hsotg *hsotg , struct dwc2_qh *qh ) 
{ 


  {
  dwc2_desc_list_free(hsotg, qh);
  if ((unsigned long )qh->channel != (unsigned long )((struct dwc2_host_chan *)0)) {
    dwc2_release_channel_ddma(hsotg, qh);
  } else {

  }
  if ((((unsigned int )qh->ep_type == 1U || (unsigned int )qh->ep_type == 3U) && ((hsotg->core_params)->uframe_sched > 0 || hsotg->periodic_channels == 0)) && (unsigned long )hsotg->frame_list != (unsigned long )((u32 *)0U)) {
    dwc2_per_sched_disable(hsotg);
    dwc2_frame_list_free(hsotg);
  } else {

  }
  return;
}
}
static u8 dwc2_frame_to_desc_idx(struct dwc2_qh *qh , u16 frame_idx ) 
{ 


  {
  if ((unsigned int )qh->dev_speed == 3U) {
    return (((unsigned int )((u8 )frame_idx) & 31U) * 8U);
  } else {
    return ((unsigned int )((u8 )frame_idx) & 63U);
  }
}
}
static u16 dwc2_calc_starting_frame(struct dwc2_hsotg *hsotg , struct dwc2_qh *qh ,
                                    u16 *skip_frames ) 
{ 
  u16 frame ;
  int tmp ;
  u16 tmp___0 ;

  {
  tmp = dwc2_hcd_get_frame_number(hsotg);
  hsotg->frame_number = (u16 )tmp;
  if ((unsigned int )qh->dev_speed == 3U) {
    tmp___0 = dwc2_micro_frame_num((int )hsotg->frame_number);
    if ((unsigned int )tmp___0 > 4U) {
      *skip_frames = 16U;
      frame = dwc2_frame_num_inc((int )hsotg->frame_number, (int )*skip_frames);
    } else {
      *skip_frames = 8U;
      frame = dwc2_frame_num_inc((int )hsotg->frame_number, (int )*skip_frames);
    }
    frame = dwc2_full_frame_num((int )frame);
  } else {
    *skip_frames = 1U;
    frame = dwc2_frame_num_inc((int )hsotg->frame_number, 2);
  }
  return (frame);
}
}
static u16 dwc2_recalc_initial_desc_idx(struct dwc2_hsotg *hsotg , struct dwc2_qh *qh ) 
{ 
  u16 frame ;
  u16 fr_idx ;
  u16 fr_idx_tmp ;
  u16 skip_frames ;
  u16 tmp ;
  u16 tmp___0 ;
  u8 tmp___1 ;

  {
  if ((unsigned long )qh->channel != (unsigned long )((struct dwc2_host_chan *)0)) {
    frame = dwc2_calc_starting_frame(hsotg, qh, & skip_frames);
    fr_idx_tmp = dwc2_frame_list_idx((int )frame);
    tmp = dwc2_frame_list_idx((int )qh->sched_frame);
    tmp___0 = dwc2_frame_incr_val(qh);
    fr_idx = (u16 )((((int )tmp + 64) - (int )fr_idx_tmp) % (int )tmp___0);
    fr_idx = (unsigned int )((u16 )((int )fr_idx + (int )fr_idx_tmp)) & 63U;
  } else {
    qh->sched_frame = dwc2_calc_starting_frame(hsotg, qh, & skip_frames);
    fr_idx = dwc2_frame_list_idx((int )qh->sched_frame);
  }
  tmp___1 = dwc2_frame_to_desc_idx(qh, (int )fr_idx);
  qh->td_last = tmp___1;
  qh->td_first = tmp___1;
  return (skip_frames);
}
}
static void dwc2_fill_host_isoc_dma_desc(struct dwc2_hsotg *hsotg , struct dwc2_qtd *qtd ,
                                         struct dwc2_qh *qh , u32 max_xfer_size ,
                                         u16 idx ) 
{ 
  struct dwc2_hcd_dma_desc *dma_desc ;
  struct dwc2_hcd_iso_packet_desc *frame_desc ;

  {
  dma_desc = qh->desc_list + (unsigned long )idx;
  memset((void *)dma_desc, 0, 8UL);
  frame_desc = (struct dwc2_hcd_iso_packet_desc *)(& (qtd->urb)->iso_descs) + (unsigned long )qtd->isoc_frame_index_last;
  if (frame_desc->length > max_xfer_size) {
    *(qh->n_bytes + (unsigned long )idx) = max_xfer_size;
  } else {
    *(qh->n_bytes + (unsigned long )idx) = frame_desc->length;
  }
  dma_desc->buf = (unsigned int )(qtd->urb)->dma + frame_desc->offset;
  dma_desc->status = *(qh->n_bytes + (unsigned long )idx) & 4095U;
  if ((u32 )qtd->isoc_frame_index_last == (qtd->urb)->packet_count) {
    dma_desc->status = dma_desc->status | 33554432U;
  } else {

  }
  qh->ntd = (u16 )((int )qh->ntd + 1);
  qtd->isoc_frame_index_last = (u16 )((int )qtd->isoc_frame_index_last + 1);
  return;
}
}
static void dwc2_init_isoc_dma_desc(struct dwc2_hsotg *hsotg , struct dwc2_qh *qh ,
                                    u16 skip_frames ) 
{ 
  struct dwc2_qtd *qtd ;
  u32 max_xfer_size ;
  u16 idx ;
  u16 inc ;
  u16 n_desc ;
  u16 ntd_max ;
  u16 tmp ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;

  {
  ntd_max = 0U;
  idx = (u16 )qh->td_last;
  inc = qh->interval;
  n_desc = 0U;
  if ((unsigned int )qh->interval != 0U) {
    tmp = dwc2_max_desc_num(qh);
    ntd_max = (u16 )((((int )tmp + (int )qh->interval) + -1) / (int )qh->interval);
    if ((unsigned int )skip_frames != 0U && (unsigned long )qh->channel == (unsigned long )((struct dwc2_host_chan *)0)) {
      ntd_max = (int )ntd_max - (int )((u16 )((int )skip_frames / (int )qh->interval));
    } else {

    }
  } else {

  }
  max_xfer_size = (unsigned int )qh->dev_speed == 3U ? 3072U : 1023U;
  __mptr = (struct list_head  const  *)qh->qtd_list.next;
  qtd = (struct dwc2_qtd *)__mptr + 0xffffffffffffffd8UL;
  goto ldv_34717;
  ldv_34716: ;
  goto ldv_34714;
  ldv_34713: ;
  if ((unsigned int )n_desc > 1U) {
    (qh->desc_list + ((unsigned long )n_desc + 0xffffffffffffffffUL))->status = (qh->desc_list + ((unsigned long )n_desc + 0xffffffffffffffffUL))->status | 2147483648U;
  } else {

  }
  dwc2_fill_host_isoc_dma_desc(hsotg, qtd, qh, max_xfer_size, (int )idx);
  idx = dwc2_desclist_idx_inc((int )idx, (int )inc, (int )qh->dev_speed);
  n_desc = (u16 )((int )n_desc + 1);
  ldv_34714: ;
  if ((int )qh->ntd < (int )ntd_max && (u32 )qtd->isoc_frame_index_last < (qtd->urb)->packet_count) {
    goto ldv_34713;
  } else {

  }
  qtd->in_process = 1U;
  __mptr___0 = (struct list_head  const  *)qtd->qtd_list_entry.next;
  qtd = (struct dwc2_qtd *)__mptr___0 + 0xffffffffffffffd8UL;
  ldv_34717: ;
  if ((unsigned long )(& qtd->qtd_list_entry) != (unsigned long )(& qh->qtd_list)) {
    goto ldv_34716;
  } else {

  }
  qh->td_last = (u8 )idx;
  if ((int )qh->ntd == (int )ntd_max) {
    idx = dwc2_desclist_idx_dec((int )qh->td_last, (int )inc, (int )qh->dev_speed);
    (qh->desc_list + (unsigned long )idx)->status = (qh->desc_list + (unsigned long )idx)->status | 33554432U;
  } else {

  }
  if ((unsigned int )n_desc != 0U) {
    (qh->desc_list + ((unsigned long )n_desc + 0xffffffffffffffffUL))->status = (qh->desc_list + ((unsigned long )n_desc + 0xffffffffffffffffUL))->status | 2147483648U;
    if ((unsigned int )n_desc > 1U) {
      (qh->desc_list)->status = (qh->desc_list)->status | 2147483648U;
    } else {

    }
  } else {

  }
  return;
}
}
static void dwc2_fill_host_dma_desc(struct dwc2_hsotg *hsotg , struct dwc2_host_chan *chan ,
                                    struct dwc2_qtd *qtd , struct dwc2_qh *qh , int n_desc ) 
{ 
  struct dwc2_hcd_dma_desc *dma_desc ;
  int len ;
    klee_make_symbolic(&len, sizeof(int), "len");
  int num_packets ;
    klee_make_symbolic(&num_packets, sizeof(int), "num_packets");

  {
  dma_desc = qh->desc_list + (unsigned long )n_desc;
  len = (int )chan->xfer_len;
  if (131072 - (int )chan->max_packet < len) {
    len = 131072 - (int )chan->max_packet;
  } else {

  }
  if ((unsigned int )*((unsigned char *)chan + 2UL) != 0U) {
    if (len > 0 && (unsigned int )*((unsigned short *)chan + 2UL) != 0U) {
      num_packets = (((int )chan->max_packet + len) + -1) / (int )chan->max_packet;
    } else {
      num_packets = 1;
    }
    len = (int )chan->max_packet * num_packets;
  } else {

  }
  dma_desc->status = (u32 )len & 131071U;
  *(qh->n_bytes + (unsigned long )n_desc) = (u32 )len;
  if ((unsigned int )qh->ep_type == 0U && (unsigned int )qtd->control_phase == 0U) {
    dma_desc->status = dma_desc->status | 16777216U;
  } else {

  }
  dma_desc->buf = (unsigned int )chan->xfer_dma;
  if ((u32 )len > chan->xfer_len) {
    chan->xfer_len = 0U;
  } else {
    chan->xfer_dma = chan->xfer_dma + (dma_addr_t )len;
    chan->xfer_len = chan->xfer_len - (u32 )len;
  }
  return;
}
}
static void dwc2_init_non_isoc_dma_desc(struct dwc2_hsotg *hsotg , struct dwc2_qh *qh ) 
{ 
  struct dwc2_qtd *qtd ;
  struct dwc2_host_chan *chan ;
  int n_desc ;
    klee_make_symbolic(&n_desc, sizeof(int), "n_desc");
  struct _ddebug descriptor ;
  long tmp ;
  struct list_head  const  *__mptr ;
  struct _ddebug descriptor___0 ;
  long tmp___0 ;
  struct _ddebug descriptor___1 ;
  long tmp___1 ;
  struct _ddebug descriptor___2 ;
  long tmp___2 ;
  struct _ddebug descriptor___3 ;
  long tmp___3 ;
  struct _ddebug descriptor___4 ;
  long tmp___4 ;
  struct list_head  const  *__mptr___0 ;
  struct _ddebug descriptor___5 ;
  long tmp___5 ;
  struct _ddebug descriptor___6 ;
  long tmp___6 ;

  {
  chan = qh->channel;
  n_desc = 0;
  descriptor.modname = "dwc2";
  descriptor.function = "dwc2_init_non_isoc_dma_desc";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd_ddma.c";
  descriptor.format = "%s(): qh=%p dma=%08lx len=%d\n";
  descriptor.lineno = 670U;
  descriptor.flags = 1U;
  tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp != 0L) {
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "%s(): qh=%p dma=%08lx len=%d\n",
                      "dwc2_init_non_isoc_dma_desc", qh, (unsigned long )chan->xfer_dma,
                      chan->xfer_len);
  } else {

  }
  __mptr = (struct list_head  const  *)qh->qtd_list.next;
  qtd = (struct dwc2_qtd *)__mptr + 0xffffffffffffffd8UL;
  goto ldv_34751;
  ldv_34750: 
  descriptor___0.modname = "dwc2";
  descriptor___0.function = "dwc2_init_non_isoc_dma_desc";
  descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd_ddma.c";
  descriptor___0.format = "qtd=%p\n";
  descriptor___0.lineno = 680U;
  descriptor___0.flags = 1U;
  tmp___0 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
  if (tmp___0 != 0L) {
    __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)hsotg->dev, "qtd=%p\n",
                      qtd);
  } else {

  }
  if (n_desc != 0) {
    chan->xfer_dma = (qtd->urb)->dma + (dma_addr_t )(qtd->urb)->actual_length;
    chan->xfer_len = (qtd->urb)->length - (qtd->urb)->actual_length;
    descriptor___1.modname = "dwc2";
    descriptor___1.function = "dwc2_init_non_isoc_dma_desc";
    descriptor___1.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd_ddma.c";
    descriptor___1.format = "buf=%08lx len=%d\n";
    descriptor___1.lineno = 689U;
    descriptor___1.flags = 1U;
    tmp___1 = ldv__builtin_expect((long )descriptor___1.flags & 1L, 0L);
    if (tmp___1 != 0L) {
      __dynamic_dev_dbg(& descriptor___1, (struct device  const  *)hsotg->dev, "buf=%08lx len=%d\n",
                        (unsigned long )chan->xfer_dma, chan->xfer_len);
    } else {

    }
  } else {

  }
  qtd->n_desc = 0U;
  ldv_34746: ;
  if (n_desc > 1) {
    (qh->desc_list + ((unsigned long )n_desc + 0xffffffffffffffffUL))->status = (qh->desc_list + ((unsigned long )n_desc + 0xffffffffffffffffUL))->status | 2147483648U;
    descriptor___2.modname = "dwc2";
    descriptor___2.function = "dwc2_init_non_isoc_dma_desc";
    descriptor___2.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd_ddma.c";
    descriptor___2.format = "set A bit in desc %d (%p)\n";
    descriptor___2.lineno = 699U;
    descriptor___2.flags = 1U;
    tmp___2 = ldv__builtin_expect((long )descriptor___2.flags & 1L, 0L);
    if (tmp___2 != 0L) {
      __dynamic_dev_dbg(& descriptor___2, (struct device  const  *)hsotg->dev, "set A bit in desc %d (%p)\n",
                        n_desc + -1, qh->desc_list + ((unsigned long )n_desc + 0xffffffffffffffffUL));
    } else {

    }
  } else {

  }
  dwc2_fill_host_dma_desc(hsotg, chan, qtd, qh, n_desc);
  descriptor___3.modname = "dwc2";
  descriptor___3.function = "dwc2_init_non_isoc_dma_desc";
  descriptor___3.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd_ddma.c";
  descriptor___3.format = "desc %d (%p) buf=%08x status=%08x\n";
  descriptor___3.lineno = 706U;
  descriptor___3.flags = 1U;
  tmp___3 = ldv__builtin_expect((long )descriptor___3.flags & 1L, 0L);
  if (tmp___3 != 0L) {
    __dynamic_dev_dbg(& descriptor___3, (struct device  const  *)hsotg->dev, "desc %d (%p) buf=%08x status=%08x\n",
                      n_desc, qh->desc_list + (unsigned long )n_desc, (qh->desc_list + (unsigned long )n_desc)->buf,
                      (qh->desc_list + (unsigned long )n_desc)->status);
  } else {

  }
  qtd->n_desc = (u8 )((int )qtd->n_desc + 1);
  n_desc = n_desc + 1;
  if (chan->xfer_len != 0U && n_desc != 64) {
    goto ldv_34746;
  } else {

  }
  descriptor___4.modname = "dwc2";
  descriptor___4.function = "dwc2_init_non_isoc_dma_desc";
  descriptor___4.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd_ddma.c";
  descriptor___4.format = "n_desc=%d\n";
  descriptor___4.lineno = 712U;
  descriptor___4.flags = 1U;
  tmp___4 = ldv__builtin_expect((long )descriptor___4.flags & 1L, 0L);
  if (tmp___4 != 0L) {
    __dynamic_dev_dbg(& descriptor___4, (struct device  const  *)hsotg->dev, "n_desc=%d\n",
                      n_desc);
  } else {

  }
  qtd->in_process = 1U;
  if ((unsigned int )qh->ep_type == 0U) {
    goto ldv_34749;
  } else {

  }
  if (n_desc == 64) {
    goto ldv_34749;
  } else {

  }
  __mptr___0 = (struct list_head  const  *)qtd->qtd_list_entry.next;
  qtd = (struct dwc2_qtd *)__mptr___0 + 0xffffffffffffffd8UL;
  ldv_34751: ;
  if ((unsigned long )(& qtd->qtd_list_entry) != (unsigned long )(& qh->qtd_list)) {
    goto ldv_34750;
  } else {

  }
  ldv_34749: ;
  if (n_desc != 0) {
    (qh->desc_list + ((unsigned long )n_desc + 0xffffffffffffffffUL))->status = (qh->desc_list + ((unsigned long )n_desc + 0xffffffffffffffffUL))->status | 2248146944U;
    descriptor___5.modname = "dwc2";
    descriptor___5.function = "dwc2_init_non_isoc_dma_desc";
    descriptor___5.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd_ddma.c";
    descriptor___5.format = "set IOC/EOL/A bits in desc %d (%p)\n";
    descriptor___5.lineno = 724U;
    descriptor___5.flags = 1U;
    tmp___5 = ldv__builtin_expect((long )descriptor___5.flags & 1L, 0L);
    if (tmp___5 != 0L) {
      __dynamic_dev_dbg(& descriptor___5, (struct device  const  *)hsotg->dev, "set IOC/EOL/A bits in desc %d (%p)\n",
                        n_desc + -1, qh->desc_list + ((unsigned long )n_desc + 0xffffffffffffffffUL));
    } else {

    }
    if (n_desc > 1) {
      (qh->desc_list)->status = (qh->desc_list)->status | 2147483648U;
      descriptor___6.modname = "dwc2";
      descriptor___6.function = "dwc2_init_non_isoc_dma_desc";
      descriptor___6.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd_ddma.c";
      descriptor___6.format = "set A bit in desc 0 (%p)\n";
      descriptor___6.lineno = 728U;
      descriptor___6.flags = 1U;
      tmp___6 = ldv__builtin_expect((long )descriptor___6.flags & 1L, 0L);
      if (tmp___6 != 0L) {
        __dynamic_dev_dbg(& descriptor___6, (struct device  const  *)hsotg->dev, "set A bit in desc 0 (%p)\n",
                          qh->desc_list);
      } else {

      }
    } else {

    }
    chan->ntd = (u16 )n_desc;
  } else {

  }
  return;
}
}
void dwc2_hcd_start_xfer_ddma(struct dwc2_hsotg *hsotg , struct dwc2_qh *qh ) 
{ 
  struct dwc2_host_chan *chan ;
  u16 skip_frames ;

  {
  chan = qh->channel;
  skip_frames = 0U;
  switch ((int )chan->ep_type) {
  case 0: ;
  case 2: 
  dwc2_init_non_isoc_dma_desc(hsotg, qh);
  dwc2_hc_start_transfer_ddma(hsotg, chan);
  goto ldv_34762;
  case 3: 
  dwc2_init_non_isoc_dma_desc(hsotg, qh);
  dwc2_update_frame_list(hsotg, qh, 1);
  dwc2_hc_start_transfer_ddma(hsotg, chan);
  goto ldv_34762;
  case 1: ;
  if ((unsigned int )qh->ntd == 0U) {
    skip_frames = dwc2_recalc_initial_desc_idx(hsotg, qh);
  } else {

  }
  dwc2_init_isoc_dma_desc(hsotg, qh, (int )skip_frames);
  if ((unsigned int )chan->xfer_started == 0U) {
    dwc2_update_frame_list(hsotg, qh, 1);
    chan->ntd = dwc2_max_desc_num(qh);
    dwc2_hc_start_transfer_ddma(hsotg, chan);
  } else {

  }
  goto ldv_34762;
  default: ;
  goto ldv_34762;
  }
  ldv_34762: ;
  return;
}
}
static int dwc2_cmpl_host_isoc_dma_desc(struct dwc2_hsotg *hsotg , struct dwc2_host_chan *chan ,
                                        struct dwc2_qtd *qtd , struct dwc2_qh *qh ,
                                        u16 idx ) 
{ 
  struct dwc2_hcd_dma_desc *dma_desc ;
  struct dwc2_hcd_iso_packet_desc *frame_desc ;
  u16 remain ;
  int rc ;

  {
  dma_desc = qh->desc_list + (unsigned long )idx;
  remain = 0U;
  rc = 0;
  if ((unsigned long )qtd->urb == (unsigned long )((struct dwc2_hcd_urb *)0)) {
    return (-22);
  } else {

  }
  frame_desc = (struct dwc2_hcd_iso_packet_desc *)(& (qtd->urb)->iso_descs) + (unsigned long )qtd->isoc_frame_index_last;
  dma_desc->buf = (unsigned int )(qtd->urb)->dma + frame_desc->offset;
  if ((unsigned int )*((unsigned char *)chan + 2UL) != 0U) {
    remain = (unsigned int )((u16 )dma_desc->status) & 4095U;
  } else {

  }
  if ((dma_desc->status & 805306368U) == 268435456U) {
    (qtd->urb)->error_count = (qtd->urb)->error_count + 1U;
    frame_desc->actual_length = *(qh->n_bytes + (unsigned long )idx) - (u32 )remain;
    frame_desc->status = 4294967225U;
  } else {
    frame_desc->actual_length = *(qh->n_bytes + (unsigned long )idx) - (u32 )remain;
    frame_desc->status = 0U;
  }
  qtd->isoc_frame_index = (u16 )((int )qtd->isoc_frame_index + 1);
  if ((u32 )qtd->isoc_frame_index == (qtd->urb)->packet_count) {
    dwc2_host_complete(hsotg, qtd, 0);
    dwc2_hcd_qtd_unlink_and_free(hsotg, qtd, qh);
    if ((unsigned int )chan->halt_status == 13U) {
      return (-1);
    } else {

    }
    rc = 1;
  } else {

  }
  qh->ntd = (u16 )((int )qh->ntd - 1);
  if ((dma_desc->status & 33554432U) != 0U) {
    rc = 2;
  } else {

  }
  return (rc);
}
}
static void dwc2_complete_isoc_xfer_ddma(struct dwc2_hsotg *hsotg , struct dwc2_host_chan *chan ,
                                         enum dwc2_halt_status halt_status ) 
{ 
  struct dwc2_hcd_iso_packet_desc *frame_desc ;
  struct dwc2_qtd *qtd ;
  struct dwc2_qtd *qtd_tmp ;
  struct dwc2_qh *qh ;
  u16 idx ;
  int rc ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  int err ;
  struct list_head  const  *__mptr___1 ;
  struct list_head  const  *__mptr___2 ;
  struct list_head  const  *__mptr___3 ;
  struct list_head  const  *__mptr___4 ;
  struct list_head  const  *__mptr___5 ;
  struct list_head  const  *__mptr___6 ;

  {
  qh = chan->qh;
  idx = (u16 )qh->td_first;
  if ((unsigned int )chan->halt_status == 13U) {
    __mptr = (struct list_head  const  *)qh->qtd_list.next;
    qtd = (struct dwc2_qtd *)__mptr + 0xffffffffffffffd8UL;
    goto ldv_34793;
    ldv_34792: 
    qtd->in_process = 0U;
    __mptr___0 = (struct list_head  const  *)qtd->qtd_list_entry.next;
    qtd = (struct dwc2_qtd *)__mptr___0 + 0xffffffffffffffd8UL;
    ldv_34793: ;
    if ((unsigned long )(& qtd->qtd_list_entry) != (unsigned long )(& qh->qtd_list)) {
      goto ldv_34792;
    } else {

    }

    return;
  } else {

  }
  if ((unsigned int )halt_status == 11U || (unsigned int )halt_status == 9U) {
    err = (unsigned int )halt_status == 11U ? -5 : -75;
    __mptr___1 = (struct list_head  const  *)qh->qtd_list.next;
    qtd = (struct dwc2_qtd *)__mptr___1 + 0xffffffffffffffd8UL;
    __mptr___2 = (struct list_head  const  *)qtd->qtd_list_entry.next;
    qtd_tmp = (struct dwc2_qtd *)__mptr___2 + 0xffffffffffffffd8UL;
    goto ldv_34806;
    ldv_34805: ;
    if ((unsigned long )qtd->urb != (unsigned long )((struct dwc2_hcd_urb *)0)) {
      idx = 0U;
      goto ldv_34803;
      ldv_34802: 
      frame_desc = (struct dwc2_hcd_iso_packet_desc *)(& (qtd->urb)->iso_descs) + (unsigned long )idx;
      frame_desc->status = (u32 )err;
      idx = (u16 )((int )idx + 1);
      ldv_34803: ;
      if ((u32 )idx < (qtd->urb)->packet_count) {
        goto ldv_34802;
      } else {

      }
      dwc2_host_complete(hsotg, qtd, err);
    } else {

    }
    dwc2_hcd_qtd_unlink_and_free(hsotg, qtd, qh);
    qtd = qtd_tmp;
    __mptr___3 = (struct list_head  const  *)qtd_tmp->qtd_list_entry.next;
    qtd_tmp = (struct dwc2_qtd *)__mptr___3 + 0xffffffffffffffd8UL;
    ldv_34806: ;
    if ((unsigned long )(& qtd->qtd_list_entry) != (unsigned long )(& qh->qtd_list)) {
      goto ldv_34805;
    } else {

    }

    return;
  } else {

  }
  __mptr___4 = (struct list_head  const  *)qh->qtd_list.next;
  qtd = (struct dwc2_qtd *)__mptr___4 + 0xffffffffffffffd8UL;
  __mptr___5 = (struct list_head  const  *)qtd->qtd_list_entry.next;
  qtd_tmp = (struct dwc2_qtd *)__mptr___5 + 0xffffffffffffffd8UL;
  goto ldv_34819;
  ldv_34818: ;
  if ((unsigned int )qtd->in_process == 0U) {
    goto ldv_34814;
  } else {

  }
  ldv_34817: 
  rc = dwc2_cmpl_host_isoc_dma_desc(hsotg, chan, qtd, qh, (int )idx);
  if (rc < 0) {
    return;
  } else {

  }
  idx = dwc2_desclist_idx_inc((int )idx, (int )qh->interval, (int )chan->speed);
  if (rc == 2) {
    goto stop_scan;
  } else {

  }
  if (rc == 1) {
    goto ldv_34816;
  } else {

  }
  if ((int )((unsigned short )qh->td_first) != (int )idx) {
    goto ldv_34817;
  } else {

  }
  ldv_34816: 
  qtd = qtd_tmp;
  __mptr___6 = (struct list_head  const  *)qtd_tmp->qtd_list_entry.next;
  qtd_tmp = (struct dwc2_qtd *)__mptr___6 + 0xffffffffffffffd8UL;
  ldv_34819: ;
  if ((unsigned long )(& qtd->qtd_list_entry) != (unsigned long )(& qh->qtd_list)) {
    goto ldv_34818;
  } else {

  }
  ldv_34814: ;
  stop_scan: 
  qh->td_first = (u8 )idx;
  return;
}
}
static int dwc2_update_non_isoc_urb_state_ddma(struct dwc2_hsotg *hsotg , struct dwc2_host_chan *chan ,
                                               struct dwc2_qtd *qtd , struct dwc2_hcd_dma_desc *dma_desc ,
                                               enum dwc2_halt_status halt_status ,
                                               u32 n_bytes , int *xfer_done ) 
{ 
  struct dwc2_hcd_urb *urb ;
  u16 remain ;
  struct _ddebug descriptor ;
  long tmp ;
  struct _ddebug descriptor___0 ;
  long tmp___0 ;
  struct _ddebug descriptor___1 ;
  long tmp___1 ;
  struct _ddebug descriptor___2 ;
  long tmp___2 ;

  {
  urb = qtd->urb;
  remain = 0U;
  if ((unsigned int )*((unsigned char *)chan + 2UL) != 0U) {
    remain = (u16 )dma_desc->status;
  } else {

  }
  descriptor.modname = "dwc2";
  descriptor.function = "dwc2_update_non_isoc_urb_state_ddma";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd_ddma.c";
  descriptor.format = "remain=%d dwc2_urb=%p\n";
  descriptor.lineno = 946U;
  descriptor.flags = 1U;
  tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp != 0L) {
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "remain=%d dwc2_urb=%p\n",
                      (int )remain, urb);
  } else {

  }
  if ((unsigned int )halt_status == 11U) {
    dev_err((struct device  const  *)hsotg->dev, "EIO\n");
    urb->status = 4294967291U;
    return (1);
  } else {

  }
  if ((dma_desc->status & 805306368U) == 268435456U) {
    switch ((unsigned int )halt_status) {
    case 6U: 
    descriptor___0.modname = "dwc2";
    descriptor___0.function = "dwc2_update_non_isoc_urb_state_ddma";
    descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd_ddma.c";
    descriptor___0.format = "Stall\n";
    descriptor___0.lineno = 957U;
    descriptor___0.flags = 1U;
    tmp___0 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
    if (tmp___0 != 0L) {
      __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)hsotg->dev, "Stall\n");
    } else {

    }
    urb->status = 4294967264U;
    goto ldv_34835;
    case 9U: 
    dev_err((struct device  const  *)hsotg->dev, "Babble\n");
    urb->status = 4294967221U;
    goto ldv_34835;
    case 7U: 
    dev_err((struct device  const  *)hsotg->dev, "XactErr\n");
    urb->status = 4294967225U;
    goto ldv_34835;
    default: 
    dev_err((struct device  const  *)hsotg->dev, "%s: Unhandled descriptor error status (%d)\n",
            "dwc2_update_non_isoc_urb_state_ddma", (unsigned int )halt_status);
    goto ldv_34835;
    }
    ldv_34835: ;
    return (1);
  } else {

  }
  if ((int )dma_desc->status < 0) {
    descriptor___1.modname = "dwc2";
    descriptor___1.function = "dwc2_update_non_isoc_urb_state_ddma";
    descriptor___1.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd_ddma.c";
    descriptor___1.format = "Active descriptor encountered on channel %d\n";
    descriptor___1.lineno = 980U;
    descriptor___1.flags = 1U;
    tmp___1 = ldv__builtin_expect((long )descriptor___1.flags & 1L, 0L);
    if (tmp___1 != 0L) {
      __dynamic_dev_dbg(& descriptor___1, (struct device  const  *)hsotg->dev, "Active descriptor encountered on channel %d\n",
                        (int )chan->hc_num);
    } else {

    }
    return (0);
  } else {

  }
  if ((unsigned int )*((unsigned char *)chan + 3UL) == 0U) {
    if ((unsigned int )qtd->control_phase == 1U) {
      urb->actual_length = urb->actual_length + (n_bytes - (u32 )remain);
      if ((unsigned int )remain != 0U || urb->actual_length >= urb->length) {
        *xfer_done = 1;
      } else {

      }
    } else
    if ((unsigned int )qtd->control_phase == 2U) {
      urb->status = 0U;
      *xfer_done = 1;
    } else {

    }
  } else {
    urb->actual_length = urb->actual_length + (n_bytes - (u32 )remain);
    descriptor___2.modname = "dwc2";
    descriptor___2.function = "dwc2_update_non_isoc_urb_state_ddma";
    descriptor___2.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd_ddma.c";
    descriptor___2.format = "length=%d actual=%d\n";
    descriptor___2.lineno = 1004U;
    descriptor___2.flags = 1U;
    tmp___2 = ldv__builtin_expect((long )descriptor___2.flags & 1L, 0L);
    if (tmp___2 != 0L) {
      __dynamic_dev_dbg(& descriptor___2, (struct device  const  *)hsotg->dev, "length=%d actual=%d\n",
                        urb->length, urb->actual_length);
    } else {

    }
    if ((unsigned int )remain != 0U || urb->actual_length >= urb->length) {
      urb->status = 0U;
      *xfer_done = 1;
    } else {

    }
  }
  return (0);
}
}
static int dwc2_process_non_isoc_desc(struct dwc2_hsotg *hsotg , struct dwc2_host_chan *chan ,
                                      int chnum , struct dwc2_qtd *qtd , int desc_num ,
                                      enum dwc2_halt_status halt_status , int *xfer_done ) 
{ 
  struct dwc2_qh *qh ;
  struct dwc2_hcd_urb *urb ;
  struct dwc2_hcd_dma_desc *dma_desc ;
  u32 n_bytes ;
  int failed ;
    klee_make_symbolic(&failed, sizeof(int), "failed");
  struct _ddebug descriptor ;
  long tmp ;
  struct _ddebug descriptor___0 ;
  long tmp___0 ;
  struct _ddebug descriptor___1 ;
  long tmp___1 ;
  struct _ddebug descriptor___2 ;
  long tmp___2 ;
  struct _ddebug descriptor___3 ;
  long tmp___3 ;

  {
  qh = chan->qh;
  urb = qtd->urb;
  descriptor.modname = "dwc2";
  descriptor.function = "dwc2_process_non_isoc_desc";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd_ddma.c";
  descriptor.format = "%s()\n";
  descriptor.lineno = 1027U;
  descriptor.flags = 1U;
  tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp != 0L) {
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "%s()\n",
                      "dwc2_process_non_isoc_desc");
  } else {

  }
  if ((unsigned long )urb == (unsigned long )((struct dwc2_hcd_urb *)0)) {
    return (-22);
  } else {

  }
  dma_desc = qh->desc_list + (unsigned long )desc_num;
  n_bytes = *(qh->n_bytes + (unsigned long )desc_num);
  descriptor___0.modname = "dwc2";
  descriptor___0.function = "dwc2_process_non_isoc_desc";
  descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd_ddma.c";
  descriptor___0.format = "qtd=%p dwc2_urb=%p desc_num=%d desc=%p n_bytes=%d\n";
  descriptor___0.lineno = 1036U;
  descriptor___0.flags = 1U;
  tmp___0 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
  if (tmp___0 != 0L) {
    __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)hsotg->dev, "qtd=%p dwc2_urb=%p desc_num=%d desc=%p n_bytes=%d\n",
                      qtd, urb, desc_num, dma_desc, n_bytes);
  } else {

  }
  failed = dwc2_update_non_isoc_urb_state_ddma(hsotg, chan, qtd, dma_desc, halt_status,
                                               n_bytes, xfer_done);
  if (failed != 0 || (*xfer_done != 0 && urb->status != 4294967181U)) {
    dwc2_host_complete(hsotg, qtd, (int )urb->status);
    dwc2_hcd_qtd_unlink_and_free(hsotg, qtd, qh);
    descriptor___1.modname = "dwc2";
    descriptor___1.function = "dwc2_process_non_isoc_desc";
    descriptor___1.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd_ddma.c";
    descriptor___1.format = "failed=%1x xfer_done=%1x status=%08x\n";
    descriptor___1.lineno = 1044U;
    descriptor___1.flags = 1U;
    tmp___1 = ldv__builtin_expect((long )descriptor___1.flags & 1L, 0L);
    if (tmp___1 != 0L) {
      __dynamic_dev_dbg(& descriptor___1, (struct device  const  *)hsotg->dev, "failed=%1x xfer_done=%1x status=%08x\n",
                        failed, *xfer_done, urb->status);
    } else {

    }
    return (failed);
  } else {

  }
  if ((unsigned int )qh->ep_type == 0U) {
    switch ((unsigned int )qtd->control_phase) {
    case 0U: ;
    if (urb->length != 0U) {
      qtd->control_phase = 1;
    } else {
      qtd->control_phase = 2;
    }
    descriptor___2.modname = "dwc2";
    descriptor___2.function = "dwc2_process_non_isoc_desc";
    descriptor___2.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd_ddma.c";
    descriptor___2.format = "  Control setup transaction done\n";
    descriptor___2.lineno = 1056U;
    descriptor___2.flags = 1U;
    tmp___2 = ldv__builtin_expect((long )descriptor___2.flags & 1L, 0L);
    if (tmp___2 != 0L) {
      __dynamic_dev_dbg(& descriptor___2, (struct device  const  *)hsotg->dev, "  Control setup transaction done\n");
    } else {

    }
    goto ldv_34861;
    case 1U: ;
    if (*xfer_done != 0) {
      qtd->control_phase = 2;
      descriptor___3.modname = "dwc2";
      descriptor___3.function = "dwc2_process_non_isoc_desc";
      descriptor___3.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/hcd_ddma.c";
      descriptor___3.format = "  Control data transfer done\n";
      descriptor___3.lineno = 1062U;
      descriptor___3.flags = 1U;
      tmp___3 = ldv__builtin_expect((long )descriptor___3.flags & 1L, 0L);
      if (tmp___3 != 0L) {
        __dynamic_dev_dbg(& descriptor___3, (struct device  const  *)hsotg->dev, "  Control data transfer done\n");
      } else {

      }
    } else
    if (desc_num + 1 == (int )qtd->n_desc) {
      dwc2_hcd_save_data_toggle(hsotg, chan, chnum, qtd);
    } else {

    }
    goto ldv_34861;
    default: ;
    goto ldv_34861;
    }
    ldv_34861: ;
  } else {

  }
  return (0);
}
}
static void dwc2_complete_non_isoc_xfer_ddma(struct dwc2_hsotg *hsotg , struct dwc2_host_chan *chan ,
                                             int chnum , enum dwc2_halt_status halt_status ) 
{ 
  struct list_head *qtd_item ;
  struct list_head *qtd_tmp ;
  struct dwc2_qh *qh ;
  struct dwc2_qtd *qtd ;
  int xfer_done ;
  int desc_num ;
    klee_make_symbolic(&desc_num, sizeof(int), "desc_num");
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  int i ;
  struct list_head  const  *__mptr___1 ;
  int tmp ;

  {
  qh = chan->qh;
  qtd = (struct dwc2_qtd *)0;
  desc_num = 0;
  if ((unsigned int )chan->halt_status == 13U) {
    __mptr = (struct list_head  const  *)qh->qtd_list.next;
    qtd = (struct dwc2_qtd *)__mptr + 0xffffffffffffffd8UL;
    goto ldv_34882;
    ldv_34881: 
    qtd->in_process = 0U;
    __mptr___0 = (struct list_head  const  *)qtd->qtd_list_entry.next;
    qtd = (struct dwc2_qtd *)__mptr___0 + 0xffffffffffffffd8UL;
    ldv_34882: ;
    if ((unsigned long )(& qtd->qtd_list_entry) != (unsigned long )(& qh->qtd_list)) {
      goto ldv_34881;
    } else {

    }

    return;
  } else {

  }
  qtd_item = qh->qtd_list.next;
  qtd_tmp = qtd_item->next;
  goto ldv_34891;
  ldv_34890: 
  __mptr___1 = (struct list_head  const  *)qtd_item;
  qtd = (struct dwc2_qtd *)__mptr___1 + 0xffffffffffffffd8UL;
  xfer_done = 0;
  i = 0;
  goto ldv_34889;
  ldv_34888: 
  tmp = dwc2_process_non_isoc_desc(hsotg, chan, chnum, qtd, desc_num, halt_status,
                                   & xfer_done);
  if (tmp != 0) {
    qtd = (struct dwc2_qtd *)0;
    goto ldv_34887;
  } else {

  }
  desc_num = desc_num + 1;
  i = i + 1;
  ldv_34889: ;
  if ((int )qtd->n_desc > i) {
    goto ldv_34888;
  } else {

  }
  ldv_34887: 
  qtd_item = qtd_tmp;
  qtd_tmp = qtd_item->next;
  ldv_34891: ;
  if ((unsigned long )(& qh->qtd_list) != (unsigned long )qtd_item) {
    goto ldv_34890;
  } else {

  }

  if ((unsigned int )qh->ep_type != 0U) {
    if ((unsigned int )halt_status == 6U) {
      qh->data_toggle = 0U;
    } else
    if ((unsigned long )qtd != (unsigned long )((struct dwc2_qtd *)0)) {
      dwc2_hcd_save_data_toggle(hsotg, chan, chnum, qtd);
    } else {

    }
  } else {

  }
  if ((unsigned int )halt_status == 1U) {
    if ((chan->hcint & 64U) != 0U) {
      qh->ping_state = 1U;
    } else {

    }
  } else {

  }
  return;
}
}
void dwc2_hcd_complete_xfer_ddma(struct dwc2_hsotg *hsotg , struct dwc2_host_chan *chan ,
                                 int chnum , enum dwc2_halt_status halt_status ) 
{ 
  struct dwc2_qh *qh ;
  int continue_isoc_xfer ;
    klee_make_symbolic(&continue_isoc_xfer, sizeof(int), "continue_isoc_xfer");
  enum dwc2_transaction_type tr_type ;
  int tmp ;
  int tmp___0 ;

  {
  qh = chan->qh;
  continue_isoc_xfer = 0;
  if ((unsigned int )*((unsigned char *)chan + 3UL) == 1U) {
    dwc2_complete_isoc_xfer_ddma(hsotg, chan, halt_status);
    if ((unsigned int )halt_status != 1U) {
      goto _L;
    } else {
      tmp = list_empty((struct list_head  const  *)(& qh->qtd_list));
      if (tmp != 0) {
        _L: /* CIL Label */ 
        if ((unsigned int )halt_status == 1U) {
          dwc2_hc_halt(hsotg, chan, halt_status);
        } else {

        }
        dwc2_release_channel_ddma(hsotg, qh);
        dwc2_hcd_qh_unlink(hsotg, qh);
      } else {
        list_move(& qh->qh_list_entry, & hsotg->periodic_sched_assigned);
        continue_isoc_xfer = 1;
      }
    }
  } else {
    dwc2_complete_non_isoc_xfer_ddma(hsotg, chan, chnum, halt_status);
    dwc2_release_channel_ddma(hsotg, qh);
    dwc2_hcd_qh_unlink(hsotg, qh);
    tmp___0 = list_empty((struct list_head  const  *)(& qh->qtd_list));
    if (tmp___0 == 0) {
      dwc2_hcd_qh_add(hsotg, qh);
    } else {

    }
  }
  tr_type = dwc2_hcd_select_transactions(hsotg);
  if ((unsigned int )tr_type != 0U || continue_isoc_xfer != 0) {
    if (continue_isoc_xfer != 0) {
      if ((unsigned int )tr_type == 0U) {
        tr_type = 1;
      } else
      if ((unsigned int )tr_type == 2U) {
        tr_type = 3;
      } else {

      }
    } else {

    }
    dwc2_hcd_queue_transactions(hsotg, tr_type);
  } else {

  }
  return;
}
}
bool ldv_queue_work_on_103(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_3(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_delayed_work_on_104(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_3(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_work_on_105(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_3(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
void ldv_flush_workqueue_106(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
  flush_workqueue(ldv_func_arg1);
  call_and_disable_all_3(2);
  return;
}
}
bool ldv_queue_delayed_work_on_107(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_3(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
__inline static long ldv__builtin_expect(long exp , long c ) ;
extern struct pv_irq_ops pv_irq_ops ;
extern int snprintf(char * , size_t  , char const   *  , ...) ;
extern void warn_slowpath_fmt(char const   * , int const    , char const   *  , ...) ;
__inline static unsigned long arch_local_save_flags(void) 
{ 
  unsigned long __ret ;
    klee_make_symbolic(&__ret, sizeof(long), "__ret");
  unsigned long __edi ;
    klee_make_symbolic(&__edi, sizeof(long), "__edi");
  unsigned long __esi ;
    klee_make_symbolic(&__esi, sizeof(long), "__esi");
  unsigned long __edx ;
    klee_make_symbolic(&__edx, sizeof(long), "__edx");
  unsigned long __ecx ;
    klee_make_symbolic(&__ecx, sizeof(long), "__ecx");
  unsigned long __eax ;
    klee_make_symbolic(&__eax, sizeof(long), "__eax");
  long tmp ;

  {
  __edi = __edi;
  __esi = __esi;
  __edx = __edx;
  __ecx = __ecx;
  __eax = __eax;
  tmp = ldv__builtin_expect((unsigned long )pv_irq_ops.save_fl.func == (unsigned long )((void *)0),
                         0L);
  if (tmp != 0L) {
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"./arch/x86/include/asm/paravirt.h"),
                         "i" (831), "i" (12UL));
    ldv_4860: ;
    goto ldv_4860;
  } else {

  }
  __asm__  volatile   ("771:\n\tcall *%c2;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c1\n  .byte 772b-771b\n  .short %c3\n.popsection\n": "=a" (__eax): [paravirt_typenum] "i" (43UL),
                       [paravirt_opptr] "i" (& pv_irq_ops.save_fl.func), [paravirt_clobber] "i" (1): "memory",
                       "cc");
  __ret = __eax;
  return (__ret);
}
}
__inline static void arch_local_irq_restore(unsigned long f ) 
{ 
  unsigned long __edi ;
  unsigned long __esi ;
  unsigned long __edx ;
  unsigned long __ecx ;
  unsigned long __eax ;
  long tmp ;

  {
  __edi = __edi;
  __esi = __esi;
  __edx = __edx;
  __ecx = __ecx;
  __eax = __eax;
  tmp = ldv__builtin_expect((unsigned long )pv_irq_ops.restore_fl.func == (unsigned long )((void *)0),
                         0L);
  if (tmp != 0L) {
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"./arch/x86/include/asm/paravirt.h"),
                         "i" (836), "i" (12UL));
    ldv_4870: ;
    goto ldv_4870;
  } else {

  }
  __asm__  volatile   ("771:\n\tcall *%c2;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c1\n  .byte 772b-771b\n  .short %c3\n.popsection\n": "=a" (__eax): [paravirt_typenum] "i" (44UL),
                       [paravirt_opptr] "i" (& pv_irq_ops.restore_fl.func), [paravirt_clobber] "i" (1),
                       "D" (f): "memory", "cc");
  return;
}
}
__inline static void arch_local_irq_disable(void) 
{ 
  unsigned long __edi ;
  unsigned long __esi ;
  unsigned long __edx ;
  unsigned long __ecx ;
  unsigned long __eax ;
  long tmp ;

  {
  __edi = __edi;
  __esi = __esi;
  __edx = __edx;
  __ecx = __ecx;
  __eax = __eax;
  tmp = ldv__builtin_expect((unsigned long )pv_irq_ops.irq_disable.func == (unsigned long )((void *)0),
                         0L);
  if (tmp != 0L) {
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"./arch/x86/include/asm/paravirt.h"),
                         "i" (841), "i" (12UL));
    ldv_4879: ;
    goto ldv_4879;
  } else {

  }
  __asm__  volatile   ("771:\n\tcall *%c2;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c1\n  .byte 772b-771b\n  .short %c3\n.popsection\n": "=a" (__eax): [paravirt_typenum] "i" (45UL),
                       [paravirt_opptr] "i" (& pv_irq_ops.irq_disable.func), [paravirt_clobber] "i" (1): "memory",
                       "cc");
  return;
}
}
__inline static unsigned long arch_local_irq_save(void) 
{ 
  unsigned long f ;
    klee_make_symbolic(&f, sizeof(long), "f");

  {
  f = arch_local_save_flags();
  arch_local_irq_disable();
  return (f);
}
}
__inline static bool IS_ERR(void const   *ptr ) ;
__inline static bool IS_ERR_OR_NULL(void const   *ptr ) ;
__inline static int arch_irqs_disabled_flags(unsigned long flags ) 
{ 


  {
  return ((flags & 512UL) == 0UL);
}
}
extern void trace_hardirqs_on(void) ;
extern void trace_hardirqs_off(void) ;
extern void mutex_lock_nested(struct mutex * , unsigned int  ) ;
extern void mutex_unlock(struct mutex * ) ;
bool ldv_queue_work_on_117(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_work_on_119(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_delayed_work_on_118(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
bool ldv_queue_delayed_work_on_121(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
void ldv_flush_workqueue_120(struct workqueue_struct *ldv_func_arg1 ) ;
extern void ioread32_rep(void * , void * , unsigned long  ) ;
extern void iowrite32_rep(void * , void const   * , unsigned long  ) ;
__inline static void *dev_get_platdata(struct device  const  *dev ) 
{ 


  {
  return ((void *)dev->platform_data);
}
}
extern int clk_prepare(struct clk * ) ;
extern void clk_unprepare(struct clk * ) ;
extern struct clk *devm_clk_get(struct device * , char const   * ) ;
extern int clk_enable(struct clk * ) ;
extern void clk_disable(struct clk * ) ;
__inline static int clk_prepare_enable(struct clk *clk ) 
{ 
  int ret ;

  {
  ret = clk_prepare(clk);
  if (ret != 0) {
    return (ret);
  } else {

  }
  ret = clk_enable(clk);
  if (ret != 0) {
    clk_unprepare(clk);
  } else {

  }
  return (ret);
}
}
__inline static void clk_disable_unprepare(struct clk *clk ) 
{ 


  {
  clk_disable(clk);
  clk_unprepare(clk);
  return;
}
}
extern int devm_regulator_bulk_get(struct device * , int  , struct regulator_bulk_data * ) ;
extern int regulator_bulk_enable(int  , struct regulator_bulk_data * ) ;
extern int regulator_bulk_disable(int  , struct regulator_bulk_data * ) ;
extern struct property *of_find_property(struct device_node  const  * , char const   * ,
                                         int * ) ;
extern int of_property_read_u32_array(struct device_node  const  * , char const   * ,
                                      u32 * , size_t  ) ;
__inline static bool of_property_read_bool(struct device_node  const  *np , char const   *propname ) 
{ 
  struct property *prop ;
  struct property *tmp ;

  {
  tmp = of_find_property(np, propname, (int *)0);
  prop = tmp;
  return ((unsigned long )prop != (unsigned long )((struct property *)0));
}
}
__inline static int of_property_read_u32(struct device_node  const  *np , char const   *propname ,
                                         u32 *out_value ) 
{ 
  int tmp ;

  {
  tmp = of_property_read_u32_array(np, propname, out_value, 1UL);
  return (tmp);
}
}
__inline static int phy_get_bus_width(struct phy *phy ) 
{ 


  {
  return ((int )phy->attrs.bus_width);
}
}
extern char const   *usb_speed_string(enum usb_device_speed  ) ;
__inline static void usb_ep_set_maxpacket_limit(struct usb_ep *ep , unsigned int maxpacket_limit ) 
{ 


  {
  ep->maxpacket_limit = (unsigned short )maxpacket_limit;
  ep->maxpacket = (unsigned short )maxpacket_limit;
  return;
}
}
extern int usb_add_gadget_udc(struct device * , struct usb_gadget * ) ;
extern void usb_del_gadget_udc(struct usb_gadget * ) ;
extern int usb_gadget_map_request(struct usb_gadget * , struct usb_request * , int  ) ;
extern void usb_gadget_unmap_request(struct usb_gadget * , struct usb_request * ,
                                     int  ) ;
extern void usb_gadget_giveback_request(struct usb_ep * , struct usb_request * ) ;
__inline static int usb_phy_init(struct usb_phy *x ) 
{ 
  int tmp ;

  {
  if ((unsigned long )x != (unsigned long )((struct usb_phy *)0) && (unsigned long )x->init != (unsigned long )((int (*)(struct usb_phy * ))0)) {
    tmp = (*(x->init))(x);
    return (tmp);
  } else {

  }
  return (0);
}
}
__inline static void usb_phy_shutdown(struct usb_phy *x ) 
{ 


  {
  if ((unsigned long )x != (unsigned long )((struct usb_phy *)0) && (unsigned long )x->shutdown != (unsigned long )((void (*)(struct usb_phy * ))0)) {
    (*(x->shutdown))(x);
  } else {

  }
  return;
}
}
__inline static int usb_phy_set_power(struct usb_phy *x , unsigned int mA ) 
{ 
  int tmp ;

  {
  if ((unsigned long )x != (unsigned long )((struct usb_phy *)0) && (unsigned long )x->set_power != (unsigned long )((int (*)(struct usb_phy * ,
                                                                                                                              unsigned int  ))0)) {
    tmp = (*(x->set_power))(x, mA);
    return (tmp);
  } else {

  }
  return (0);
}
}
__inline static int otg_set_peripheral(struct usb_otg *otg , struct usb_gadget *periph ) 
{ 
  int tmp ;

  {
  if ((unsigned long )otg != (unsigned long )((struct usb_otg *)0) && (unsigned long )otg->set_peripheral != (unsigned long )((int (*)(struct usb_otg * ,
                                                                                                                                       struct usb_gadget * ))0)) {
    tmp = (*(otg->set_peripheral))(otg, periph);
    return (tmp);
  } else {

  }
  return (-524);
}
}
static char const   * const  s3c_hsotg_supply_names[2U]  = {      "vusb_d",      "vusb_a"};
int s3c_hsotg_set_test_mode(struct dwc2_hsotg *hsotg , int testmode ) ;
__inline static struct s3c_hsotg_req *our_req(struct usb_request *req ) 
{ 
  struct usb_request  const  *__mptr ;

  {
  __mptr = (struct usb_request  const  *)req;
  return ((struct s3c_hsotg_req *)__mptr);
}
}
__inline static struct s3c_hsotg_ep *our_ep(struct usb_ep *ep ) 
{ 
  struct usb_ep  const  *__mptr ;

  {
  __mptr = (struct usb_ep  const  *)ep;
  return ((struct s3c_hsotg_ep *)__mptr);
}
}
__inline static struct dwc2_hsotg *to_hsotg(struct usb_gadget *gadget ) 
{ 
  struct usb_gadget  const  *__mptr ;

  {
  __mptr = (struct usb_gadget  const  *)gadget;
  return ((struct dwc2_hsotg *)__mptr + 0xfffffffffffff988UL);
}
}
__inline static void __orr32(void *ptr , u32 val ) 
{ 
  unsigned int tmp ;

  {
  tmp = readl((void const volatile   *)ptr);
  writel(tmp | val, (void volatile   *)ptr);
  return;
}
}
__inline static void __bic32(void *ptr , u32 val ) 
{ 
  unsigned int tmp ;

  {
  tmp = readl((void const volatile   *)ptr);
  writel(tmp & ~ val, (void volatile   *)ptr);
  return;
}
}
__inline static struct s3c_hsotg_ep *index_to_ep(struct dwc2_hsotg *hsotg , u32 ep_index ,
                                                 u32 dir_in ) 
{ 


  {
  if (dir_in != 0U) {
    return (hsotg->eps_in[ep_index]);
  } else {
    return (hsotg->eps_out[ep_index]);
  }
}
}
static void s3c_hsotg_dump(struct dwc2_hsotg *hsotg ) ;
__inline static bool using_dma(struct dwc2_hsotg *hsotg ) 
{ 


  {
  return (hsotg->g_using_dma != 0U);
}
}
static void s3c_hsotg_en_gsint(struct dwc2_hsotg *hsotg , u32 ints ) 
{ 
  u32 gsintmsk ;
  unsigned int tmp ;
  u32 new_gsintmsk ;
  struct _ddebug descriptor ;
  long tmp___0 ;

  {
  tmp = readl((void const volatile   *)hsotg->regs + 24U);
  gsintmsk = tmp;
  new_gsintmsk = gsintmsk | ints;
  if (new_gsintmsk != gsintmsk) {
    descriptor.modname = "dwc2";
    descriptor.function = "s3c_hsotg_en_gsint";
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/gadget.c";
    descriptor.format = "gsintmsk now 0x%08x\n";
    descriptor.lineno = 116U;
    descriptor.flags = 1U;
    tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
    if (tmp___0 != 0L) {
      __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "gsintmsk now 0x%08x\n",
                        new_gsintmsk);
    } else {

    }
    writel(new_gsintmsk, (void volatile   *)hsotg->regs + 24U);
  } else {

  }
  return;
}
}
static void s3c_hsotg_disable_gsint(struct dwc2_hsotg *hsotg , u32 ints ) 
{ 
  u32 gsintmsk ;
  unsigned int tmp ;
  u32 new_gsintmsk ;

  {
  tmp = readl((void const volatile   *)hsotg->regs + 24U);
  gsintmsk = tmp;
  new_gsintmsk = ~ ints & gsintmsk;
  if (new_gsintmsk != gsintmsk) {
    writel(new_gsintmsk, (void volatile   *)hsotg->regs + 24U);
  } else {

  }
  return;
}
}
static void s3c_hsotg_ctrl_epint(struct dwc2_hsotg *hsotg , unsigned int ep , unsigned int dir_in ,
                                 unsigned int en ) 
{ 
  unsigned long flags ;
  u32 bit ;
  u32 daint ;
  int tmp ;

  {
  bit = (u32 )(1 << (int )ep);
  if (dir_in == 0U) {
    bit = bit << 16;
  } else {

  }
  flags = arch_local_irq_save();
  trace_hardirqs_off();
  daint = readl((void const volatile   *)hsotg->regs + 2076U);
  if (en != 0U) {
    daint = daint | bit;
  } else {
    daint = ~ bit & daint;
  }
  writel(daint, (void volatile   *)hsotg->regs + 2076U);
  tmp = arch_irqs_disabled_flags(flags);
  if (tmp != 0) {
    arch_local_irq_restore(flags);
    trace_hardirqs_off();
  } else {
    trace_hardirqs_on();
    arch_local_irq_restore(flags);
  }
  return;
}
}
static void s3c_hsotg_init_fifo(struct dwc2_hsotg *hsotg ) 
{ 
  unsigned int ep ;
    klee_make_symbolic(&ep, sizeof(int), "ep");
  unsigned int addr ;
    klee_make_symbolic(&addr, sizeof(int), "addr");
  int timeout ;
  u32 val ;
  int __ret_warn_on ;
  long tmp ;
  bool __warned ;
  int __ret_warn_once ;
    klee_make_symbolic(&__ret_warn_once, sizeof(int), "__ret_warn_once");
  int __ret_warn_on___0 ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  struct _ddebug descriptor ;
  long tmp___3 ;

  {
  __ret_warn_on = hsotg->fifo_map != 0U;
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/gadget.c",
                       180);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  hsotg->fifo_map = 0U;
  writel(hsotg->g_rx_fifo_sz, (void volatile   *)hsotg->regs + 36U);
  writel(hsotg->g_rx_fifo_sz | (hsotg->g_np_g_tx_fifo_sz << 16), (void volatile   *)hsotg->regs + 40U);
  addr = hsotg->g_rx_fifo_sz + hsotg->g_np_g_tx_fifo_sz;
  ep = 1U;
  goto ldv_34400;
  ldv_34399: ;
  if (hsotg->g_tx_fifo_sz[ep] == 0U) {
    goto ldv_34393;
  } else {

  }
  val = addr;
  val = (hsotg->g_tx_fifo_sz[ep] << 16) | val;
  __ret_warn_once = hsotg->g_tx_fifo_sz[ep] + addr > (unsigned int )hsotg->fifo_mem;
  tmp___2 = ldv__builtin_expect(__ret_warn_once != 0, 0L);
  if (tmp___2 != 0L) {
    __ret_warn_on___0 = ! __warned;
    tmp___0 = ldv__builtin_expect(__ret_warn_on___0 != 0, 0L);
    if (tmp___0 != 0L) {
      warn_slowpath_fmt("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/gadget.c",
                        210, "insufficient fifo memory");
    } else {

    }
    tmp___1 = ldv__builtin_expect(__ret_warn_on___0 != 0, 0L);
    if (tmp___1 != 0L) {
      __warned = 1;
    } else {

    }
  } else {

  }
  ldv__builtin_expect(__ret_warn_once != 0, 0L);
  addr = hsotg->g_tx_fifo_sz[ep] + addr;
  writel(val, (void volatile   *)hsotg->regs + (unsigned long )((ep + 64U) * 4U));
  ldv_34393: 
  ep = ep + 1U;
  ldv_34400: ;
  if (ep <= 15U) {
    goto ldv_34399;
  } else {

  }
  writel(1072U, (void volatile   *)hsotg->regs + 16U);
  timeout = 100;
  ldv_34404: 
  val = readl((void const volatile   *)hsotg->regs + 16U);
  if ((val & 48U) == 0U) {
    goto ldv_34402;
  } else {

  }
  timeout = timeout - 1;
  if (timeout == 0) {
    dev_err((struct device  const  *)hsotg->dev, "%s: timeout flushing fifos (GRSTCTL=%08x)\n",
            "s3c_hsotg_init_fifo", val);
    goto ldv_34402;
  } else {

  }
  __const_udelay(4295UL);
  goto ldv_34404;
  ldv_34402: 
  descriptor.modname = "dwc2";
  descriptor.function = "s3c_hsotg_init_fifo";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/gadget.c";
  descriptor.format = "FIFOs reset, timeout at %d\n";
  descriptor.lineno = 242U;
  descriptor.flags = 1U;
  tmp___3 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp___3 != 0L) {
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "FIFOs reset, timeout at %d\n",
                      timeout);
  } else {

  }
  return;
}
}
static struct usb_request *s3c_hsotg_ep_alloc_request(struct usb_ep *ep , gfp_t flags ) 
{ 
  struct s3c_hsotg_req *req ;
  void *tmp ;

  {
  tmp = kzalloc(112UL, flags);
  req = (struct s3c_hsotg_req *)tmp;
  if ((unsigned long )req == (unsigned long )((struct s3c_hsotg_req *)0)) {
    return ((struct usb_request *)0);
  } else {

  }
  INIT_LIST_HEAD(& req->queue);
  return (& req->req);
}
}
__inline static int is_ep_periodic(struct s3c_hsotg_ep *hs_ep ) 
{ 


  {
  return ((int )hs_ep->periodic);
}
}
static void s3c_hsotg_unmap_dma(struct dwc2_hsotg *hsotg , struct s3c_hsotg_ep *hs_ep ,
                                struct s3c_hsotg_req *hs_req ) 
{ 
  struct usb_request *req ;

  {
  req = & hs_req->req;
  if (hs_req->req.length == 0U) {
    return;
  } else {

  }
  usb_gadget_unmap_request(& hsotg->gadget, req, (int )hs_ep->dir_in);
  return;
}
}
static int s3c_hsotg_write_fifo(struct dwc2_hsotg *hsotg , struct s3c_hsotg_ep *hs_ep ,
                                struct s3c_hsotg_req *hs_req ) 
{ 
  bool periodic ;
  int tmp ;
  u32 gnptxsts ;
  unsigned int tmp___0 ;
  int buf_pos ;
    klee_make_symbolic(&buf_pos, sizeof(int), "buf_pos");
  int to_write ;
    klee_make_symbolic(&to_write, sizeof(int), "to_write");
  void *data ;
  int can_write ;
    klee_make_symbolic(&can_write, sizeof(int), "can_write");
  int pkt_round ;
    klee_make_symbolic(&pkt_round, sizeof(int), "pkt_round");
  int max_transfer ;
    klee_make_symbolic(&max_transfer, sizeof(int), "max_transfer");
  u32 epsize ;
  unsigned int tmp___1 ;
  int size_left ;
    klee_make_symbolic(&size_left, sizeof(int), "size_left");
  int size_done ;
    klee_make_symbolic(&size_done, sizeof(int), "size_done");
  struct _ddebug descriptor ;
  long tmp___2 ;
  struct _ddebug descriptor___0 ;
  long tmp___3 ;
  struct _ddebug descriptor___1 ;
  long tmp___4 ;
  unsigned int tmp___5 ;
  struct _ddebug descriptor___2 ;
  long tmp___6 ;
  struct _ddebug descriptor___3 ;
  long tmp___7 ;
  struct _ddebug descriptor___4 ;
  long tmp___8 ;

  {
  tmp = is_ep_periodic(hs_ep);
  periodic = tmp != 0;
  tmp___0 = readl((void const volatile   *)hsotg->regs + 44U);
  gnptxsts = tmp___0;
  buf_pos = (int )hs_req->req.actual;
  to_write = (int )hs_ep->size_loaded;
  to_write = (int )((hs_ep->last_load - (unsigned int )buf_pos) + (unsigned int )to_write);
  if (to_write == 0) {
    return (0);
  } else {

  }
  if ((int )periodic && (unsigned int )*((unsigned char *)hsotg + 1608UL) == 0U) {
    tmp___1 = readl((void const volatile   *)hsotg->regs + (unsigned long )((int )hs_ep->index * 32 + 2320));
    epsize = tmp___1;
    size_left = (int )epsize & 524287;
    if (hs_ep->fifo_load != 0U) {
      s3c_hsotg_en_gsint(hsotg, 67108864U);
      return (-28);
    } else {

    }
    descriptor.modname = "dwc2";
    descriptor.function = "s3c_hsotg_write_fifo";
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/gadget.c";
    descriptor.format = "%s: left=%d, load=%d, fifo=%d, size %d\n";
    descriptor.lineno = 357U;
    descriptor.flags = 1U;
    tmp___2 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
    if (tmp___2 != 0L) {
      __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "%s: left=%d, load=%d, fifo=%d, size %d\n",
                        "s3c_hsotg_write_fifo", size_left, hs_ep->size_loaded, hs_ep->fifo_load,
                        (int )hs_ep->fifo_size);
    } else {

    }
    size_done = (int )(hs_ep->size_loaded - (unsigned int )size_left);
    can_write = (int )(hs_ep->fifo_load - (unsigned int )size_done);
    descriptor___0.modname = "dwc2";
    descriptor___0.function = "s3c_hsotg_write_fifo";
    descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/gadget.c";
    descriptor___0.format = "%s: => can_write1=%d\n";
    descriptor___0.lineno = 365U;
    descriptor___0.flags = 1U;
    tmp___3 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
    if (tmp___3 != 0L) {
      __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)hsotg->dev, "%s: => can_write1=%d\n",
                        "s3c_hsotg_write_fifo", can_write);
    } else {

    }
    can_write = (int )hs_ep->fifo_size - can_write;
    descriptor___1.modname = "dwc2";
    descriptor___1.function = "s3c_hsotg_write_fifo";
    descriptor___1.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/gadget.c";
    descriptor___1.format = "%s: => can_write2=%d\n";
    descriptor___1.lineno = 369U;
    descriptor___1.flags = 1U;
    tmp___4 = ldv__builtin_expect((long )descriptor___1.flags & 1L, 0L);
    if (tmp___4 != 0L) {
      __dynamic_dev_dbg(& descriptor___1, (struct device  const  *)hsotg->dev, "%s: => can_write2=%d\n",
                        "s3c_hsotg_write_fifo", can_write);
    } else {

    }
    if (can_write <= 0) {
      s3c_hsotg_en_gsint(hsotg, 67108864U);
      return (-28);
    } else {

    }
  } else
  if ((unsigned int )*((unsigned char *)hsotg + 1608UL) != 0U && (unsigned int )hs_ep->index != 0U) {
    tmp___5 = readl((void const volatile   *)hsotg->regs + (unsigned long )((int )hs_ep->index * 32 + 2328));
    can_write = (int )tmp___5;
    can_write = can_write & 65535;
    can_write = can_write * 4;
  } else {
    if (((gnptxsts >> 16) & 255U) == 0U) {
      descriptor___2.modname = "dwc2";
      descriptor___2.function = "s3c_hsotg_write_fifo";
      descriptor___2.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/gadget.c";
      descriptor___2.format = "%s: no queue slots available (0x%08x)\n";
      descriptor___2.lineno = 384U;
      descriptor___2.flags = 1U;
      tmp___6 = ldv__builtin_expect((long )descriptor___2.flags & 1L, 0L);
      if (tmp___6 != 0L) {
        __dynamic_dev_dbg(& descriptor___2, (struct device  const  *)hsotg->dev, "%s: no queue slots available (0x%08x)\n",
                          "s3c_hsotg_write_fifo", gnptxsts);
      } else {

      }
      s3c_hsotg_en_gsint(hsotg, 32U);
      return (-28);
    } else {

    }
    can_write = (int )gnptxsts & 65535;
    can_write = can_write * 4;
  }
  max_transfer = (int )hs_ep->ep.maxpacket * (int )hs_ep->mc;
  descriptor___3.modname = "dwc2";
  descriptor___3.function = "s3c_hsotg_write_fifo";
  descriptor___3.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/gadget.c";
  descriptor___3.format = "%s: GNPTXSTS=%08x, can=%d, to=%d, max_transfer %d\n";
  descriptor___3.lineno = 397U;
  descriptor___3.flags = 1U;
  tmp___7 = ldv__builtin_expect((long )descriptor___3.flags & 1L, 0L);
  if (tmp___7 != 0L) {
    __dynamic_dev_dbg(& descriptor___3, (struct device  const  *)hsotg->dev, "%s: GNPTXSTS=%08x, can=%d, to=%d, max_transfer %d\n",
                      "s3c_hsotg_write_fifo", gnptxsts, can_write, to_write, max_transfer);
  } else {

  }
  if (can_write > 512 && ! periodic) {
    can_write = 512;
  } else {

  }
  if (to_write > max_transfer) {
    to_write = max_transfer;
    if ((unsigned int )*((unsigned char *)hsotg + 1608UL) == 0U) {
      s3c_hsotg_en_gsint(hsotg, (int )periodic ? 67108864U : 32U);
    } else {

    }
  } else {

  }
  if (to_write > can_write) {
    to_write = can_write;
    pkt_round = to_write % max_transfer;
    if (pkt_round != 0) {
      to_write = to_write - pkt_round;
    } else {

    }
    if ((unsigned int )*((unsigned char *)hsotg + 1608UL) == 0U) {
      s3c_hsotg_en_gsint(hsotg, (int )periodic ? 67108864U : 32U);
    } else {

    }
  } else {

  }
  descriptor___4.modname = "dwc2";
  descriptor___4.function = "s3c_hsotg_write_fifo";
  descriptor___4.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/gadget.c";
  descriptor___4.format = "write %d/%d, can_write %d, done %d\n";
  descriptor___4.lineno = 452U;
  descriptor___4.flags = 1U;
  tmp___8 = ldv__builtin_expect((long )descriptor___4.flags & 1L, 0L);
  if (tmp___8 != 0L) {
    __dynamic_dev_dbg(& descriptor___4, (struct device  const  *)hsotg->dev, "write %d/%d, can_write %d, done %d\n",
                      to_write, hs_req->req.length, can_write, buf_pos);
  } else {

  }
  if (to_write <= 0) {
    return (-28);
  } else {

  }
  hs_req->req.actual = (unsigned int )(buf_pos + to_write);
  hs_ep->total_data = hs_ep->total_data + (unsigned long )to_write;
  if ((int )periodic) {
    hs_ep->fifo_load = hs_ep->fifo_load + (unsigned int )to_write;
  } else {

  }
  to_write = (to_write + 3) / 4;
  data = hs_req->req.buf + (unsigned long )buf_pos;
  iowrite32_rep(hsotg->regs + (unsigned long )(((int )hs_ep->index + 1) * 4096), (void const   *)data,
                (unsigned long )to_write);
  return (to_write >= can_write ? -28 : 0);
}
}
static unsigned int get_ep_limit(struct s3c_hsotg_ep *hs_ep ) 
{ 
  int index ;
  unsigned int maxsize ;
    klee_make_symbolic(&maxsize, sizeof(int), "maxsize");
  unsigned int maxpkt ;
    klee_make_symbolic(&maxpkt, sizeof(int), "maxpkt");

  {
  index = (int )hs_ep->index;
  if (index != 0) {
    maxsize = 524288U;
    maxpkt = 1024U;
  } else {
    maxsize = 128U;
    if ((unsigned int )hs_ep->dir_in != 0U) {
      maxpkt = 4U;
    } else {
      maxpkt = 2U;
    }
  }
  maxpkt = maxpkt - 1U;
  maxsize = maxsize - 1U;
  if ((unsigned int )hs_ep->ep.maxpacket * maxpkt < maxsize) {
    maxsize = (unsigned int )hs_ep->ep.maxpacket * maxpkt;
  } else {

  }
  return (maxsize);
}
}
static void s3c_hsotg_start_req(struct dwc2_hsotg *hsotg , struct s3c_hsotg_ep *hs_ep ,
                                struct s3c_hsotg_req *hs_req , bool continuing ) 
{ 
  struct usb_request *ureq ;
  int index ;
  int dir_in ;
  u32 epctrl_reg ;
  u32 epsize_reg ;
  u32 epsize ;
  u32 ctrl ;
  unsigned int length ;
  unsigned int packets ;
    klee_make_symbolic(&packets, sizeof(int), "packets");
  unsigned int maxreq ;
    klee_make_symbolic(&maxreq, sizeof(int), "maxreq");
  int __ret_warn_on ;
  long tmp ;
  int __ret_warn_on___0 ;
  long tmp___0 ;
  struct _ddebug descriptor ;
  unsigned int tmp___1 ;
  long tmp___2 ;
  struct _ddebug descriptor___0 ;
  long tmp___3 ;
  int round ;
    klee_make_symbolic(&round, sizeof(int), "round");
  struct _ddebug descriptor___1 ;
  long tmp___4 ;
  struct _ddebug descriptor___2 ;
  long tmp___5 ;
  unsigned int dma_reg ;
    klee_make_symbolic(&dma_reg, sizeof(int), "dma_reg");
  struct _ddebug descriptor___3 ;
  long tmp___6 ;
  bool tmp___7 ;
  struct _ddebug descriptor___4 ;
  long tmp___8 ;
  struct _ddebug descriptor___5 ;
  long tmp___9 ;
  bool tmp___10 ;
  int tmp___11 ;
  struct _ddebug descriptor___6 ;
  unsigned int tmp___12 ;
  long tmp___13 ;
  unsigned int tmp___14 ;
  struct _ddebug descriptor___7 ;
  unsigned int tmp___15 ;
  long tmp___16 ;

  {
  ureq = & hs_req->req;
  index = (int )hs_ep->index;
  dir_in = (int )hs_ep->dir_in;
  if (index != 0) {
    if ((unsigned long )hs_ep->req != (unsigned long )((struct s3c_hsotg_req *)0) && ! continuing) {
      dev_err((struct device  const  *)hsotg->dev, "%s: active request\n", "s3c_hsotg_start_req");
      __ret_warn_on = 1;
      tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
      if (tmp != 0L) {
        warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/gadget.c",
                           539);
      } else {

      }
      ldv__builtin_expect(__ret_warn_on != 0, 0L);
      return;
    } else
    if ((unsigned long )hs_ep->req != (unsigned long )hs_req && (int )continuing) {
      dev_err((struct device  const  *)hsotg->dev, "%s: continue different req\n",
              "s3c_hsotg_start_req");
      __ret_warn_on___0 = 1;
      tmp___0 = ldv__builtin_expect(__ret_warn_on___0 != 0, 0L);
      if (tmp___0 != 0L) {
        warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/gadget.c",
                           544);
      } else {

      }
      ldv__builtin_expect(__ret_warn_on___0 != 0, 0L);
      return;
    } else {

    }
  } else {

  }
  epctrl_reg = (u32 )(dir_in != 0 ? (index + 72) * 32 : (index + 88) * 32);
  epsize_reg = (u32 )(dir_in != 0 ? index * 32 + 2320 : index * 32 + 2832);
  descriptor.modname = "dwc2";
  descriptor.function = "s3c_hsotg_start_req";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/gadget.c";
  descriptor.format = "%s: DxEPCTL=0x%08x, ep %d, dir %s\n";
  descriptor.lineno = 554U;
  descriptor.flags = 1U;
  tmp___2 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp___2 != 0L) {
    tmp___1 = readl((void const volatile   *)hsotg->regs + (unsigned long )epctrl_reg);
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "%s: DxEPCTL=0x%08x, ep %d, dir %s\n",
                      "s3c_hsotg_start_req", tmp___1, index, (unsigned int )hs_ep->dir_in != 0U ? (char *)"in" : (char *)"out");
  } else {

  }
  ctrl = readl((void const volatile   *)hsotg->regs + (unsigned long )epctrl_reg);
  if ((ctrl & 2097152U) != 0U) {
    dev_warn((struct device  const  *)hsotg->dev, "%s: ep%d is stalled\n", "s3c_hsotg_start_req",
             index);
    return;
  } else {

  }
  length = ureq->length - ureq->actual;
  descriptor___0.modname = "dwc2";
  descriptor___0.function = "s3c_hsotg_start_req";
  descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/gadget.c";
  descriptor___0.format = "ureq->length:%d ureq->actual:%d\n";
  descriptor___0.lineno = 566U;
  descriptor___0.flags = 1U;
  tmp___3 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
  if (tmp___3 != 0L) {
    __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)hsotg->dev, "ureq->length:%d ureq->actual:%d\n",
                      ureq->length, ureq->actual);
  } else {

  }
  maxreq = get_ep_limit(hs_ep);
  if (length > maxreq) {
    round = (int )(maxreq % (unsigned int )hs_ep->ep.maxpacket);
    descriptor___1.modname = "dwc2";
    descriptor___1.function = "s3c_hsotg_start_req";
    descriptor___1.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/gadget.c";
    descriptor___1.format = "%s: length %d, max-req %d, r %d\n";
    descriptor___1.lineno = 573U;
    descriptor___1.flags = 1U;
    tmp___4 = ldv__builtin_expect((long )descriptor___1.flags & 1L, 0L);
    if (tmp___4 != 0L) {
      __dynamic_dev_dbg(& descriptor___1, (struct device  const  *)hsotg->dev, "%s: length %d, max-req %d, r %d\n",
                        "s3c_hsotg_start_req", length, maxreq, round);
    } else {

    }
    if (round != 0) {
      maxreq = maxreq - (unsigned int )round;
    } else {

    }
    length = maxreq;
  } else {

  }
  if (length != 0U) {
    packets = (((unsigned int )hs_ep->ep.maxpacket + length) - 1U) / (unsigned int )hs_ep->ep.maxpacket;
  } else {
    packets = 1U;
  }
  if ((unsigned int )*((unsigned char *)hs_ep + 132UL) != 0U && (unsigned int )((int )hs_ep->mc * (int )hs_ep->ep.maxpacket) < length) {
    dev_err((struct device  const  *)hsotg->dev, "req length > maxpacket*mc\n");
    return;
  } else {

  }
  if (dir_in != 0 && index != 0) {
    if ((unsigned int )*((unsigned char *)hs_ep + 132UL) != 0U) {
      epsize = packets << 29;
    } else {
      epsize = 536870912U;
    }
  } else {
    epsize = 0U;
  }
  if ((dir_in != 0 && (unsigned int )*((unsigned char *)ureq + 42UL) != 0U) && ! continuing) {
    if (ureq->length >= (unsigned int )hs_ep->ep.maxpacket && ureq->length % (unsigned int )hs_ep->ep.maxpacket == 0U) {
      hs_ep->send_zlp = 1U;
    } else {

    }
  } else {

  }
  epsize = (packets << 19) | epsize;
  epsize = epsize | length;
  descriptor___2.modname = "dwc2";
  descriptor___2.function = "s3c_hsotg_start_req";
  descriptor___2.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/gadget.c";
  descriptor___2.format = "%s: %d@%d/%d, 0x%08x => 0x%08x\n";
  descriptor___2.lineno = 615U;
  descriptor___2.flags = 1U;
  tmp___5 = ldv__builtin_expect((long )descriptor___2.flags & 1L, 0L);
  if (tmp___5 != 0L) {
    __dynamic_dev_dbg(& descriptor___2, (struct device  const  *)hsotg->dev, "%s: %d@%d/%d, 0x%08x => 0x%08x\n",
                      "s3c_hsotg_start_req", packets, length, ureq->length, epsize,
                      epsize_reg);
  } else {

  }
  hs_ep->req = hs_req;
  writel(epsize, (void volatile   *)hsotg->regs + (unsigned long )epsize_reg);
  tmp___7 = using_dma(hsotg);
  if ((int )tmp___7 && ! continuing) {
    dma_reg = (unsigned int )(dir_in != 0 ? index * 32 + 2324 : index * 32 + 2836);
    writel((unsigned int )ureq->dma, (void volatile   *)hsotg->regs + (unsigned long )dma_reg);
    descriptor___3.modname = "dwc2";
    descriptor___3.function = "s3c_hsotg_start_req";
    descriptor___3.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/gadget.c";
    descriptor___3.format = "%s: %pad => 0x%08x\n";
    descriptor___3.lineno = 635U;
    descriptor___3.flags = 1U;
    tmp___6 = ldv__builtin_expect((long )descriptor___3.flags & 1L, 0L);
    if (tmp___6 != 0L) {
      __dynamic_dev_dbg(& descriptor___3, (struct device  const  *)hsotg->dev, "%s: %pad => 0x%08x\n",
                        "s3c_hsotg_start_req", & ureq->dma, dma_reg);
    } else {

    }
  } else {

  }
  ctrl = ctrl | 2147483648U;
  ctrl = ctrl | 32768U;
  descriptor___4.modname = "dwc2";
  descriptor___4.function = "s3c_hsotg_start_req";
  descriptor___4.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/gadget.c";
  descriptor___4.format = "ep0 state:%d\n";
  descriptor___4.lineno = 641U;
  descriptor___4.flags = 1U;
  tmp___8 = ldv__builtin_expect((long )descriptor___4.flags & 1L, 0L);
  if (tmp___8 != 0L) {
    __dynamic_dev_dbg(& descriptor___4, (struct device  const  *)hsotg->dev, "ep0 state:%d\n",
                      (unsigned int )hsotg->ep0_state);
  } else {

  }
  if (index != 0 || (unsigned int )hsotg->ep0_state != 0U) {
    ctrl = ctrl | 67108864U;
  } else {

  }
  descriptor___5.modname = "dwc2";
  descriptor___5.function = "s3c_hsotg_start_req";
  descriptor___5.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/gadget.c";
  descriptor___5.format = "%s: DxEPCTL=0x%08x\n";
  descriptor___5.lineno = 647U;
  descriptor___5.flags = 1U;
  tmp___9 = ldv__builtin_expect((long )descriptor___5.flags & 1L, 0L);
  if (tmp___9 != 0L) {
    __dynamic_dev_dbg(& descriptor___5, (struct device  const  *)hsotg->dev, "%s: DxEPCTL=0x%08x\n",
                      "s3c_hsotg_start_req", ctrl);
  } else {

  }
  writel(ctrl, (void volatile   *)hsotg->regs + (unsigned long )epctrl_reg);
  hs_ep->size_loaded = length;
  hs_ep->last_load = ureq->actual;
  if (dir_in != 0) {
    tmp___10 = using_dma(hsotg);
    if (tmp___10) {
      tmp___11 = 0;
    } else {
      tmp___11 = 1;
    }
    if (tmp___11) {
      hs_ep->fifo_load = 0U;
      s3c_hsotg_write_fifo(hsotg, hs_ep, hs_req);
    } else {

    }
  } else {

  }
  if (dir_in != 0) {
    writel(16U, (void volatile   *)hsotg->regs + (unsigned long )(index * 32 + 2312));
  } else {

  }
  tmp___14 = readl((void const volatile   *)hsotg->regs + (unsigned long )epctrl_reg);
  if ((int )tmp___14 >= 0) {
    descriptor___6.modname = "dwc2";
    descriptor___6.function = "s3c_hsotg_start_req";
    descriptor___6.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/gadget.c";
    descriptor___6.format = "ep%d: failed to become enabled (DXEPCTL=0x%08x)?\n";
    descriptor___6.lineno = 682U;
    descriptor___6.flags = 1U;
    tmp___13 = ldv__builtin_expect((long )descriptor___6.flags & 1L, 0L);
    if (tmp___13 != 0L) {
      tmp___12 = readl((void const volatile   *)hsotg->regs + (unsigned long )epctrl_reg);
      __dynamic_dev_dbg(& descriptor___6, (struct device  const  *)hsotg->dev, "ep%d: failed to become enabled (DXEPCTL=0x%08x)?\n",
                        index, tmp___12);
    } else {

    }
  } else {

  }
  descriptor___7.modname = "dwc2";
  descriptor___7.function = "s3c_hsotg_start_req";
  descriptor___7.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/gadget.c";
  descriptor___7.format = "%s: DXEPCTL=0x%08x\n";
  descriptor___7.lineno = 685U;
  descriptor___7.flags = 1U;
  tmp___16 = ldv__builtin_expect((long )descriptor___7.flags & 1L, 0L);
  if (tmp___16 != 0L) {
    tmp___15 = readl((void const volatile   *)hsotg->regs + (unsigned long )epctrl_reg);
    __dynamic_dev_dbg(& descriptor___7, (struct device  const  *)hsotg->dev, "%s: DXEPCTL=0x%08x\n",
                      "s3c_hsotg_start_req", tmp___15);
  } else {

  }
  s3c_hsotg_ctrl_epint(hsotg, (unsigned int )hs_ep->index, (unsigned int )hs_ep->dir_in,
                       1U);
  return;
}
}
static int s3c_hsotg_map_dma(struct dwc2_hsotg *hsotg , struct s3c_hsotg_ep *hs_ep ,
                             struct usb_request *req ) 
{ 
  struct s3c_hsotg_req *hs_req ;
  struct s3c_hsotg_req *tmp ;
  int ret ;

  {
  tmp = our_req(req);
  hs_req = tmp;
  if (hs_req->req.length == 0U) {
    return (0);
  } else {

  }
  ret = usb_gadget_map_request(& hsotg->gadget, req, (int )hs_ep->dir_in);
  if (ret != 0) {
    goto dma_error;
  } else {

  }
  return (0);
  dma_error: 
  dev_err((struct device  const  *)hsotg->dev, "%s: failed to map buffer %p, %d bytes\n",
          "s3c_hsotg_map_dma", req->buf, req->length);
  return (-5);
}
}
static int s3c_hsotg_handle_unaligned_buf_start(struct dwc2_hsotg *hsotg , struct s3c_hsotg_ep *hs_ep ,
                                                struct s3c_hsotg_req *hs_req ) 
{ 
  void *req_buf ;
  bool tmp ;
  int tmp___0 ;
  int __ret_warn_on ;
  long tmp___1 ;
  struct _ddebug descriptor ;
  long tmp___2 ;

  {
  req_buf = hs_req->req.buf;
  tmp = using_dma(hsotg);
  if (tmp) {
    tmp___0 = 0;
  } else {
    tmp___0 = 1;
  }
  if (tmp___0 || ((long )req_buf & 3L) == 0L) {
    return (0);
  } else {

  }
  __ret_warn_on = (unsigned long )hs_req->saved_req_buf != (unsigned long )((void *)0);
  tmp___1 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp___1 != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/gadget.c",
                       736);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  descriptor.modname = "dwc2";
  descriptor.function = "s3c_hsotg_handle_unaligned_buf_start";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/gadget.c";
  descriptor.format = "%s: %s: buf=%p length=%d\n";
  descriptor.lineno = 739U;
  descriptor.flags = 1U;
  tmp___2 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp___2 != 0L) {
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "%s: %s: buf=%p length=%d\n",
                      "s3c_hsotg_handle_unaligned_buf_start", hs_ep->ep.name, req_buf,
                      hs_req->req.length);
  } else {

  }
  hs_req->req.buf = kmalloc((size_t )hs_req->req.length, 32U);
  if ((unsigned long )hs_req->req.buf == (unsigned long )((void *)0)) {
    hs_req->req.buf = req_buf;
    dev_err((struct device  const  *)hsotg->dev, "%s: unable to allocate memory for bounce buffer\n",
            "s3c_hsotg_handle_unaligned_buf_start");
    return (-12);
  } else {

  }
  hs_req->saved_req_buf = req_buf;
  if ((unsigned int )hs_ep->dir_in != 0U) {
    memcpy(hs_req->req.buf, (void const   *)req_buf, (size_t )hs_req->req.length);
  } else {

  }
  return (0);
}
}
static void s3c_hsotg_handle_unaligned_buf_complete(struct dwc2_hsotg *hsotg , struct s3c_hsotg_ep *hs_ep ,
                                                    struct s3c_hsotg_req *hs_req ) 
{ 
  bool tmp ;
  int tmp___0 ;
  struct _ddebug descriptor ;
  long tmp___1 ;

  {
  tmp = using_dma(hsotg);
  if (tmp) {
    tmp___0 = 0;
  } else {
    tmp___0 = 1;
  }
  if (tmp___0 || (unsigned long )hs_req->saved_req_buf == (unsigned long )((void *)0)) {
    return;
  } else {

  }
  descriptor.modname = "dwc2";
  descriptor.function = "s3c_hsotg_handle_unaligned_buf_complete";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/gadget.c";
  descriptor.format = "%s: %s: status=%d actual-length=%d\n";
  descriptor.lineno = 766U;
  descriptor.flags = 1U;
  tmp___1 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp___1 != 0L) {
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "%s: %s: status=%d actual-length=%d\n",
                      "s3c_hsotg_handle_unaligned_buf_complete", hs_ep->ep.name, hs_req->req.status,
                      hs_req->req.actual);
  } else {

  }
  if ((unsigned int )hs_ep->dir_in == 0U && hs_req->req.status == 0) {
    memcpy(hs_req->saved_req_buf, (void const   *)hs_req->req.buf, (size_t )hs_req->req.actual);
  } else {

  }
  kfree((void const   *)hs_req->req.buf);
  hs_req->req.buf = hs_req->saved_req_buf;
  hs_req->saved_req_buf = (void *)0;
  return;
}
}
static int s3c_hsotg_ep_queue(struct usb_ep *ep , struct usb_request *req , gfp_t gfp_flags ) 
{ 
  struct s3c_hsotg_req *hs_req ;
  struct s3c_hsotg_req *tmp ;
  struct s3c_hsotg_ep *hs_ep ;
  struct s3c_hsotg_ep *tmp___0 ;
  struct dwc2_hsotg *hs ;
  bool first ;
  int ret ;
  struct _ddebug descriptor ;
  long tmp___1 ;
  struct _ddebug descriptor___0 ;
  long tmp___2 ;
  bool tmp___3 ;
  int tmp___4 ;

  {
  tmp = our_req(req);
  hs_req = tmp;
  tmp___0 = our_ep(ep);
  hs_ep = tmp___0;
  hs = hs_ep->parent;
  descriptor.modname = "dwc2";
  descriptor.function = "s3c_hsotg_ep_queue";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/gadget.c";
  descriptor.format = "%s: req %p: %d@%p, noi=%d, zero=%d, snok=%d\n";
  descriptor.lineno = 791U;
  descriptor.flags = 1U;
  tmp___1 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp___1 != 0L) {
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)hs->dev, "%s: req %p: %d@%p, noi=%d, zero=%d, snok=%d\n",
                      ep->name, req, req->length, req->buf, (int )req->no_interrupt,
                      (int )req->zero, (int )req->short_not_ok);
  } else {

  }
  if ((unsigned int )hs->lx_state == 2U) {
    descriptor___0.modname = "dwc2";
    descriptor___0.function = "s3c_hsotg_ep_queue";
    descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/gadget.c";
    descriptor___0.format = "%s: don\'t submit request while suspended\n";
    descriptor___0.lineno = 796U;
    descriptor___0.flags = 1U;
    tmp___2 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
    if (tmp___2 != 0L) {
      __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)hs->dev, "%s: don\'t submit request while suspended\n",
                        "s3c_hsotg_ep_queue");
    } else {

    }
    return (-11);
  } else {

  }
  INIT_LIST_HEAD(& hs_req->queue);
  req->actual = 0U;
  req->status = -115;
  ret = s3c_hsotg_handle_unaligned_buf_start(hs, hs_ep, hs_req);
  if (ret != 0) {
    return (ret);
  } else {

  }
  tmp___3 = using_dma(hs);
  if ((int )tmp___3) {
    ret = s3c_hsotg_map_dma(hs, hs_ep, req);
    if (ret != 0) {
      return (ret);
    } else {

    }
  } else {

  }
  tmp___4 = list_empty((struct list_head  const  *)(& hs_ep->queue));
  first = tmp___4 != 0;
  list_add_tail(& hs_req->queue, & hs_ep->queue);
  if ((int )first) {
    s3c_hsotg_start_req(hs, hs_ep, hs_req, 0);
  } else {

  }
  return (0);
}
}
static int s3c_hsotg_ep_queue_lock(struct usb_ep *ep , struct usb_request *req , gfp_t gfp_flags ) 
{ 
  struct s3c_hsotg_ep *hs_ep ;
  struct s3c_hsotg_ep *tmp ;
  struct dwc2_hsotg *hs ;
  unsigned long flags ;
  int ret ;
  raw_spinlock_t *tmp___0 ;

  {
  tmp = our_ep(ep);
  hs_ep = tmp;
  hs = hs_ep->parent;
  flags = 0UL;
  ret = 0;
  tmp___0 = spinlock_check(& hs->lock);
  flags = _raw_spin_lock_irqsave(tmp___0);
  ret = s3c_hsotg_ep_queue(ep, req, gfp_flags);
  spin_unlock_irqrestore(& hs->lock, flags);
  return (ret);
}
}
static void s3c_hsotg_ep_free_request(struct usb_ep *ep , struct usb_request *req ) 
{ 
  struct s3c_hsotg_req *hs_req ;
  struct s3c_hsotg_req *tmp ;

  {
  tmp = our_req(req);
  hs_req = tmp;
  kfree((void const   *)hs_req);
  return;
}
}
static void s3c_hsotg_complete_oursetup(struct usb_ep *ep , struct usb_request *req ) 
{ 
  struct s3c_hsotg_ep *hs_ep ;
  struct s3c_hsotg_ep *tmp ;
  struct dwc2_hsotg *hsotg ;
  struct _ddebug descriptor ;
  long tmp___0 ;

  {
  tmp = our_ep(ep);
  hs_ep = tmp;
  hsotg = hs_ep->parent;
  descriptor.modname = "dwc2";
  descriptor.function = "s3c_hsotg_complete_oursetup";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/gadget.c";
  descriptor.format = "%s: ep %p, req %p\n";
  descriptor.lineno = 862U;
  descriptor.flags = 1U;
  tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp___0 != 0L) {
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "%s: ep %p, req %p\n",
                      "s3c_hsotg_complete_oursetup", ep, req);
  } else {

  }
  s3c_hsotg_ep_free_request(ep, req);
  return;
}
}
static struct s3c_hsotg_ep *ep_from_windex(struct dwc2_hsotg *hsotg , u32 windex ) 
{ 
  struct s3c_hsotg_ep *ep ;
  int dir ;
    klee_make_symbolic(&dir, sizeof(int), "dir");
  int idx ;
    klee_make_symbolic(&idx, sizeof(int), "idx");

  {
  dir = (windex & 128U) != 0U;
  idx = (int )windex & 127;
  if (windex > 255U) {
    return ((struct s3c_hsotg_ep *)0);
  } else {

  }
  if ((int )hsotg->num_of_eps < idx) {
    return ((struct s3c_hsotg_ep *)0);
  } else {

  }
  ep = index_to_ep(hsotg, (u32 )idx, (u32 )dir);
  if (idx != 0 && (int )ep->dir_in != dir) {
    return ((struct s3c_hsotg_ep *)0);
  } else {

  }
  return (ep);
}
}
int s3c_hsotg_set_test_mode(struct dwc2_hsotg *hsotg , int testmode ) 
{ 
  int dctl ;
    klee_make_symbolic(&dctl, sizeof(int), "dctl");
  unsigned int tmp ;

  {
  tmp = readl((void const volatile   *)hsotg->regs + 2052U);
  dctl = (int )tmp;
  dctl = dctl & -113;
  switch (testmode) {
  case 1: ;
  case 2: ;
  case 3: ;
  case 4: ;
  case 5: 
  dctl = (testmode << 4) | dctl;
  goto ldv_34562;
  default: ;
  return (-22);
  }
  ldv_34562: 
  writel((unsigned int )dctl, (void volatile   *)hsotg->regs + 2052U);
  return (0);
}
}
static int s3c_hsotg_send_reply(struct dwc2_hsotg *hsotg , struct s3c_hsotg_ep *ep ,
                                void *buff , int length ) 
{ 
  struct usb_request *req ;
  int ret ;
  struct _ddebug descriptor ;
  long tmp ;

  {
  descriptor.modname = "dwc2";
  descriptor.function = "s3c_hsotg_send_reply";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/gadget.c";
  descriptor.format = "%s: buff %p, len %d\n";
  descriptor.lineno = 940U;
  descriptor.flags = 1U;
  tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp != 0L) {
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "%s: buff %p, len %d\n",
                      "s3c_hsotg_send_reply", buff, length);
  } else {

  }
  req = s3c_hsotg_ep_alloc_request(& ep->ep, 32U);
  hsotg->ep0_reply = req;
  if ((unsigned long )req == (unsigned long )((struct usb_request *)0)) {
    dev_warn((struct device  const  *)hsotg->dev, "%s: cannot alloc req\n", "s3c_hsotg_send_reply");
    return (-12);
  } else {

  }
  req->buf = hsotg->ep0_buff;
  req->length = (unsigned int )length;
  req->zero = 0U;
  req->complete = & s3c_hsotg_complete_oursetup;
  if (length != 0) {
    memcpy(req->buf, (void const   *)buff, (size_t )length);
  } else {

  }
  ret = s3c_hsotg_ep_queue(& ep->ep, req, 32U);
  if (ret != 0) {
    dev_warn((struct device  const  *)hsotg->dev, "%s: cannot queue req\n", "s3c_hsotg_send_reply");
    return (ret);
  } else {

  }
  return (0);
}
}
static int s3c_hsotg_process_req_status(struct dwc2_hsotg *hsotg , struct usb_ctrlrequest *ctrl ) 
{ 
  struct s3c_hsotg_ep *ep0 ;
  struct s3c_hsotg_ep *ep ;
  __le16 reply ;
  int ret ;
  struct _ddebug descriptor ;
  long tmp ;

  {
  ep0 = hsotg->eps_out[0];
  descriptor.modname = "dwc2";
  descriptor.function = "s3c_hsotg_process_req_status";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/gadget.c";
  descriptor.format = "%s: USB_REQ_GET_STATUS\n";
  descriptor.lineno = 983U;
  descriptor.flags = 1U;
  tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp != 0L) {
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "%s: USB_REQ_GET_STATUS\n",
                      "s3c_hsotg_process_req_status");
  } else {

  }
  if ((unsigned int )ep0->dir_in == 0U) {
    dev_warn((struct device  const  *)hsotg->dev, "%s: direction out?\n", "s3c_hsotg_process_req_status");
    return (-22);
  } else {

  }
  switch ((int )ctrl->bRequestType & 31) {
  case 0: 
  reply = 0U;
  goto ldv_34585;
  case 1: 
  reply = 0U;
  goto ldv_34585;
  case 2: 
  ep = ep_from_windex(hsotg, (u32 )ctrl->wIndex);
  if ((unsigned long )ep == (unsigned long )((struct s3c_hsotg_ep *)0)) {
    return (-2);
  } else {

  }
  reply = (unsigned int )((unsigned short )*((unsigned char *)ep + 132UL)) & 1U;
  goto ldv_34585;
  default: ;
  return (0);
  }
  ldv_34585: ;
  if ((unsigned int )ctrl->wLength != 2U) {
    return (-22);
  } else {

  }
  ret = s3c_hsotg_send_reply(hsotg, ep0, (void *)(& reply), 2);
  if (ret != 0) {
    dev_err((struct device  const  *)hsotg->dev, "%s: failed to send reply\n", "s3c_hsotg_process_req_status");
    return (ret);
  } else {

  }
  return (1);
}
}
static int s3c_hsotg_ep_sethalt(struct usb_ep *ep , int value ) ;
static struct s3c_hsotg_req *get_ep_head(struct s3c_hsotg_ep *hs_ep ) 
{ 
  int tmp ;
  struct list_head  const  *__mptr ;

  {
  tmp = list_empty((struct list_head  const  *)(& hs_ep->queue));
  if (tmp != 0) {
    return ((struct s3c_hsotg_req *)0);
  } else {

  }
  __mptr = (struct list_head  const  *)hs_ep->queue.next;
  return ((struct s3c_hsotg_req *)__mptr + 0xffffffffffffffa8UL);
}
}
static int s3c_hsotg_process_req_feature(struct dwc2_hsotg *hsotg , struct usb_ctrlrequest *ctrl ) 
{ 
  struct s3c_hsotg_ep *ep0 ;
  struct s3c_hsotg_req *hs_req ;
  bool restart ;
  bool set ;
  struct s3c_hsotg_ep *ep ;
  int ret ;
  bool halted ;
  u32 recip ;
  u32 wValue ;
  u32 wIndex ;
  struct _ddebug descriptor ;
  long tmp ;
  struct _ddebug descriptor___0 ;
  long tmp___0 ;
  int tmp___1 ;

  {
  ep0 = hsotg->eps_out[0];
  set = (unsigned int )ctrl->bRequest == 3U;
  descriptor.modname = "dwc2";
  descriptor.function = "s3c_hsotg_process_req_feature";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/gadget.c";
  descriptor.format = "%s: %s_FEATURE\n";
  descriptor.lineno = 1061U;
  descriptor.flags = 1U;
  tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp != 0L) {
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "%s: %s_FEATURE\n",
                      "s3c_hsotg_process_req_feature", (int )set ? (char *)"SET" : (char *)"CLEAR");
  } else {

  }
  wValue = (u32 )ctrl->wValue;
  wIndex = (u32 )ctrl->wIndex;
  recip = (u32 )ctrl->bRequestType & 31U;
  switch (recip) {
  case 0U: ;
  switch (wValue) {
  case 2U: ;
  if ((wIndex & 255U) != 0U) {
    return (-22);
  } else {

  }
  if (! set) {
    return (-22);
  } else {

  }
  hsotg->test_mode = (u8 )(wIndex >> 8);
  ret = s3c_hsotg_send_reply(hsotg, ep0, (void *)0, 0);
  if (ret != 0) {
    dev_err((struct device  const  *)hsotg->dev, "%s: failed to send reply\n", "s3c_hsotg_process_req_feature");
    return (ret);
  } else {

  }
  goto ldv_34615;
  default: ;
  return (-2);
  }
  ldv_34615: ;
  goto ldv_34617;
  case 2U: 
  ep = ep_from_windex(hsotg, wIndex);
  if ((unsigned long )ep == (unsigned long )((struct s3c_hsotg_ep *)0)) {
    descriptor___0.modname = "dwc2";
    descriptor___0.function = "s3c_hsotg_process_req_feature";
    descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/gadget.c";
    descriptor___0.format = "%s: no endpoint for 0x%04x\n";
    descriptor___0.lineno = 1093U;
    descriptor___0.flags = 1U;
    tmp___0 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
    if (tmp___0 != 0L) {
      __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)hsotg->dev, "%s: no endpoint for 0x%04x\n",
                        "s3c_hsotg_process_req_feature", wIndex);
    } else {

    }
    return (-2);
  } else {

  }
  switch (wValue) {
  case 0U: 
  halted = (int )ep->halted != 0;
  s3c_hsotg_ep_sethalt(& ep->ep, (int )set);
  ret = s3c_hsotg_send_reply(hsotg, ep0, (void *)0, 0);
  if (ret != 0) {
    dev_err((struct device  const  *)hsotg->dev, "%s: failed to send reply\n", "s3c_hsotg_process_req_feature");
    return (ret);
  } else {

  }
  if (! set && (int )halted) {
    if ((unsigned long )ep->req != (unsigned long )((struct s3c_hsotg_req *)0)) {
      hs_req = ep->req;
      ep->req = (struct s3c_hsotg_req *)0;
      list_del_init(& hs_req->queue);
      if ((unsigned long )hs_req->req.complete != (unsigned long )((void (*)(struct usb_ep * ,
                                                                             struct usb_request * ))0)) {
        spin_unlock(& hsotg->lock);
        usb_gadget_giveback_request(& ep->ep, & hs_req->req);
        spin_lock(& hsotg->lock);
      } else {

      }
    } else {

    }
    if ((unsigned long )ep->req == (unsigned long )((struct s3c_hsotg_req *)0)) {
      tmp___1 = list_empty((struct list_head  const  *)(& ep->queue));
      restart = tmp___1 == 0;
      if ((int )restart) {
        hs_req = get_ep_head(ep);
        s3c_hsotg_start_req(hsotg, ep, hs_req, 0);
      } else {

      }
    } else {

    }
  } else {

  }
  goto ldv_34621;
  default: ;
  return (-2);
  }
  ldv_34621: ;
  goto ldv_34617;
  default: ;
  return (-2);
  }
  ldv_34617: ;
  return (1);
}
}
static void s3c_hsotg_enqueue_setup(struct dwc2_hsotg *hsotg ) ;
static void s3c_hsotg_stall_ep0(struct dwc2_hsotg *hsotg ) 
{ 
  struct s3c_hsotg_ep *ep0 ;
  u32 reg ;
  u32 ctrl ;
  struct _ddebug descriptor ;
  long tmp ;
  struct _ddebug descriptor___0 ;
  unsigned int tmp___0 ;
  long tmp___1 ;

  {
  ep0 = hsotg->eps_out[0];
  descriptor.modname = "dwc2";
  descriptor.function = "s3c_hsotg_stall_ep0";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/gadget.c";
  descriptor.format = "ep0 stall (dir=%d)\n";
  descriptor.lineno = 1169U;
  descriptor.flags = 1U;
  tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp != 0L) {
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "ep0 stall (dir=%d)\n",
                      (int )ep0->dir_in);
  } else {

  }
  reg = (unsigned int )ep0->dir_in != 0U ? 2304U : 2816U;
  ctrl = readl((void const volatile   *)hsotg->regs + (unsigned long )reg);
  ctrl = ctrl | 2097152U;
  ctrl = ctrl | 67108864U;
  writel(ctrl, (void volatile   *)hsotg->regs + (unsigned long )reg);
  descriptor___0.modname = "dwc2";
  descriptor___0.function = "s3c_hsotg_stall_ep0";
  descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/gadget.c";
  descriptor___0.format = "written DXEPCTL=0x%08x to %08x (DXEPCTL=0x%08x)\n";
  descriptor___0.lineno = 1184U;
  descriptor___0.flags = 1U;
  tmp___1 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
  if (tmp___1 != 0L) {
    tmp___0 = readl((void const volatile   *)hsotg->regs + (unsigned long )reg);
    __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)hsotg->dev, "written DXEPCTL=0x%08x to %08x (DXEPCTL=0x%08x)\n",
                      ctrl, reg, tmp___0);
  } else {

  }
  s3c_hsotg_enqueue_setup(hsotg);
  return;
}
}
static void s3c_hsotg_process_control(struct dwc2_hsotg *hsotg , struct usb_ctrlrequest *ctrl ) 
{ 
  struct s3c_hsotg_ep *ep0 ;
  int ret ;
  u32 dcfg ;
  struct _ddebug descriptor ;
  long tmp ;
  struct _ddebug descriptor___0 ;
  long tmp___0 ;

  {
  ep0 = hsotg->eps_out[0];
  ret = 0;
  descriptor.modname = "dwc2";
  descriptor.function = "s3c_hsotg_process_control";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/gadget.c";
  descriptor.format = "ctrl Req=%02x, Type=%02x, V=%04x, L=%04x\n";
  descriptor.lineno = 1211U;
  descriptor.flags = 1U;
  tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp != 0L) {
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "ctrl Req=%02x, Type=%02x, V=%04x, L=%04x\n",
                      (int )ctrl->bRequest, (int )ctrl->bRequestType, (int )ctrl->wValue,
                      (int )ctrl->wLength);
  } else {

  }
  if ((unsigned int )ctrl->wLength == 0U) {
    ep0->dir_in = 1U;
    hsotg->ep0_state = 3;
  } else
  if ((int )((signed char )ctrl->bRequestType) < 0) {
    ep0->dir_in = 1U;
    hsotg->ep0_state = 1;
  } else {
    ep0->dir_in = 0U;
    hsotg->ep0_state = 2;
  }
  if (((int )ctrl->bRequestType & 96) == 0) {
    switch ((int )ctrl->bRequest) {
    case 5: 
    hsotg->connected = 1U;
    dcfg = readl((void const volatile   *)hsotg->regs + 2048U);
    dcfg = dcfg & 4294965263U;
    dcfg = ((u32 )((int )ctrl->wValue << 4) & 2032U) | dcfg;
    writel(dcfg, (void volatile   *)hsotg->regs + 2048U);
    _dev_info((struct device  const  *)hsotg->dev, "new address %d\n", (int )ctrl->wValue);
    ret = s3c_hsotg_send_reply(hsotg, ep0, (void *)0, 0);
    return;
    case 0: 
    ret = s3c_hsotg_process_req_status(hsotg, ctrl);
    goto ldv_34646;
    case 1: ;
    case 3: 
    ret = s3c_hsotg_process_req_feature(hsotg, ctrl);
    goto ldv_34646;
    }
    ldv_34646: ;
  } else {

  }
  if (ret == 0 && (unsigned long )hsotg->driver != (unsigned long )((struct usb_gadget_driver *)0)) {
    spin_unlock(& hsotg->lock);
    ret = (*((hsotg->driver)->setup))(& hsotg->gadget, (struct usb_ctrlrequest  const  *)ctrl);
    spin_lock(& hsotg->lock);
    if (ret < 0) {
      descriptor___0.modname = "dwc2";
      descriptor___0.function = "s3c_hsotg_process_control";
      descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/gadget.c";
      descriptor___0.format = "driver->setup() ret %d\n";
      descriptor___0.lineno = 1257U;
      descriptor___0.flags = 1U;
      tmp___0 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
      if (tmp___0 != 0L) {
        __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)hsotg->dev, "driver->setup() ret %d\n",
                          ret);
      } else {

      }
    } else {

    }
  } else {

  }
  if (ret < 0) {
    s3c_hsotg_stall_ep0(hsotg);
  } else {

  }
  return;
}
}
static void s3c_hsotg_complete_setup(struct usb_ep *ep , struct usb_request *req ) 
{ 
  struct s3c_hsotg_ep *hs_ep ;
  struct s3c_hsotg_ep *tmp ;
  struct dwc2_hsotg *hsotg ;
  struct _ddebug descriptor ;
  long tmp___0 ;

  {
  tmp = our_ep(ep);
  hs_ep = tmp;
  hsotg = hs_ep->parent;
  if (req->status < 0) {
    descriptor.modname = "dwc2";
    descriptor.function = "s3c_hsotg_complete_setup";
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/gadget.c";
    descriptor.format = "%s: failed %d\n";
    descriptor.lineno = 1284U;
    descriptor.flags = 1U;
    tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
    if (tmp___0 != 0L) {
      __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "%s: failed %d\n",
                        "s3c_hsotg_complete_setup", req->status);
    } else {

    }
    return;
  } else {

  }
  spin_lock(& hsotg->lock);
  if (req->actual == 0U) {
    s3c_hsotg_enqueue_setup(hsotg);
  } else {
    s3c_hsotg_process_control(hsotg, (struct usb_ctrlrequest *)req->buf);
  }
  spin_unlock(& hsotg->lock);
  return;
}
}
static void s3c_hsotg_enqueue_setup(struct dwc2_hsotg *hsotg ) 
{ 
  struct usb_request *req ;
  struct s3c_hsotg_req *hs_req ;
  struct s3c_hsotg_req *tmp ;
  int ret ;
  struct _ddebug descriptor ;
  long tmp___0 ;
  struct _ddebug descriptor___0 ;
  long tmp___1 ;
  int tmp___2 ;

  {
  req = hsotg->ctrl_req;
  tmp = our_req(req);
  hs_req = tmp;
  descriptor.modname = "dwc2";
  descriptor.function = "s3c_hsotg_enqueue_setup";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/gadget.c";
  descriptor.format = "%s: queueing setup request\n";
  descriptor.lineno = 1309U;
  descriptor.flags = 1U;
  tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp___0 != 0L) {
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "%s: queueing setup request\n",
                      "s3c_hsotg_enqueue_setup");
  } else {

  }
  req->zero = 0U;
  req->length = 8U;
  req->buf = hsotg->ctrl_buff;
  req->complete = & s3c_hsotg_complete_setup;
  tmp___2 = list_empty((struct list_head  const  *)(& hs_req->queue));
  if (tmp___2 == 0) {
    descriptor___0.modname = "dwc2";
    descriptor___0.function = "s3c_hsotg_enqueue_setup";
    descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/gadget.c";
    descriptor___0.format = "%s already queued???\n";
    descriptor___0.lineno = 1317U;
    descriptor___0.flags = 1U;
    tmp___1 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
    if (tmp___1 != 0L) {
      __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)hsotg->dev, "%s already queued???\n",
                        "s3c_hsotg_enqueue_setup");
    } else {

    }
    return;
  } else {

  }
  (hsotg->eps_out[0])->dir_in = 0U;
  (hsotg->eps_out[0])->send_zlp = 0U;
  hsotg->ep0_state = 0;
  ret = s3c_hsotg_ep_queue(& (hsotg->eps_out[0])->ep, req, 32U);
  if (ret < 0) {
    dev_err((struct device  const  *)hsotg->dev, "%s: failed queue (%d)\n", "s3c_hsotg_enqueue_setup",
            ret);
  } else {

  }
  return;
}
}
static void s3c_hsotg_program_zlp(struct dwc2_hsotg *hsotg , struct s3c_hsotg_ep *hs_ep ) 
{ 
  u32 ctrl ;
  u8 index ;
  u32 epctl_reg ;
  u32 epsiz_reg ;
  struct _ddebug descriptor ;
  long tmp ;
  struct _ddebug descriptor___0 ;
  long tmp___0 ;

  {
  index = hs_ep->index;
  epctl_reg = (u32 )((unsigned int )hs_ep->dir_in != 0U ? ((int )index + 72) * 32 : ((int )index + 88) * 32);
  epsiz_reg = (u32 )((unsigned int )hs_ep->dir_in != 0U ? (int )index * 32 + 2320 : (int )index * 32 + 2832);
  if ((unsigned int )hs_ep->dir_in != 0U) {
    descriptor.modname = "dwc2";
    descriptor.function = "s3c_hsotg_program_zlp";
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/gadget.c";
    descriptor.format = "Sending zero-length packet on ep%d\n";
    descriptor.lineno = 1345U;
    descriptor.flags = 1U;
    tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
    if (tmp != 0L) {
      __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "Sending zero-length packet on ep%d\n",
                        (int )index);
    } else {

    }
  } else {
    descriptor___0.modname = "dwc2";
    descriptor___0.function = "s3c_hsotg_program_zlp";
    descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/gadget.c";
    descriptor___0.format = "Receiving zero-length packet on ep%d\n";
    descriptor___0.lineno = 1348U;
    descriptor___0.flags = 1U;
    tmp___0 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
    if (tmp___0 != 0L) {
      __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)hsotg->dev, "Receiving zero-length packet on ep%d\n",
                        (int )index);
    } else {

    }
  }
  writel(537395200U, (void volatile   *)hsotg->regs + (unsigned long )epsiz_reg);
  ctrl = readl((void const volatile   *)hsotg->regs + (unsigned long )epctl_reg);
  ctrl = ctrl | 67108864U;
  ctrl = ctrl | 2147483648U;
  ctrl = ctrl | 32768U;
  writel(ctrl, (void volatile   *)hsotg->regs + (unsigned long )epctl_reg);
  return;
}
}
static void s3c_hsotg_complete_request(struct dwc2_hsotg *hsotg , struct s3c_hsotg_ep *hs_ep ,
                                       struct s3c_hsotg_req *hs_req , int result ) 
{ 
  bool restart ;
  struct _ddebug descriptor ;
  long tmp ;
  struct _ddebug descriptor___0 ;
  long tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;

  {
  if ((unsigned long )hs_req == (unsigned long )((struct s3c_hsotg_req *)0)) {
    descriptor.modname = "dwc2";
    descriptor.function = "s3c_hsotg_complete_request";
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/gadget.c";
    descriptor.format = "%s: nothing to complete?\n";
    descriptor.lineno = 1382U;
    descriptor.flags = 1U;
    tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
    if (tmp != 0L) {
      __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "%s: nothing to complete?\n",
                        "s3c_hsotg_complete_request");
    } else {

    }
    return;
  } else {

  }
  descriptor___0.modname = "dwc2";
  descriptor___0.function = "s3c_hsotg_complete_request";
  descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/gadget.c";
  descriptor___0.format = "complete: ep %p %s, req %p, %d => %p\n";
  descriptor___0.lineno = 1387U;
  descriptor___0.flags = 1U;
  tmp___0 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
  if (tmp___0 != 0L) {
    __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)hsotg->dev, "complete: ep %p %s, req %p, %d => %p\n",
                      hs_ep, hs_ep->ep.name, hs_req, result, hs_req->req.complete);
  } else {

  }
  if (hs_req->req.status == -115) {
    hs_req->req.status = result;
  } else {

  }
  s3c_hsotg_handle_unaligned_buf_complete(hsotg, hs_ep, hs_req);
  hs_ep->req = (struct s3c_hsotg_req *)0;
  list_del_init(& hs_req->queue);
  tmp___1 = using_dma(hsotg);
  if ((int )tmp___1) {
    s3c_hsotg_unmap_dma(hsotg, hs_ep, hs_req);
  } else {

  }
  if ((unsigned long )hs_req->req.complete != (unsigned long )((void (*)(struct usb_ep * ,
                                                                         struct usb_request * ))0)) {
    spin_unlock(& hsotg->lock);
    usb_gadget_giveback_request(& hs_ep->ep, & hs_req->req);
    spin_lock(& hsotg->lock);
  } else {

  }
  if ((unsigned long )hs_ep->req == (unsigned long )((struct s3c_hsotg_req *)0) && result >= 0) {
    tmp___2 = list_empty((struct list_head  const  *)(& hs_ep->queue));
    restart = tmp___2 == 0;
    if ((int )restart) {
      hs_req = get_ep_head(hs_ep);
      s3c_hsotg_start_req(hsotg, hs_ep, hs_req, 0);
    } else {

    }
  } else {

  }
  return;
}
}
static void s3c_hsotg_rx_data(struct dwc2_hsotg *hsotg , int ep_idx , int size ) 
{ 
  struct s3c_hsotg_ep *hs_ep ;
  struct s3c_hsotg_req *hs_req ;
  void *fifo ;
  int to_read ;
    klee_make_symbolic(&to_read, sizeof(int), "to_read");
  int max_req ;
    klee_make_symbolic(&max_req, sizeof(int), "max_req");
  int read_ptr ;
    klee_make_symbolic(&read_ptr, sizeof(int), "read_ptr");
  u32 epctl ;
  unsigned int tmp ;
  int ptr ;
    klee_make_symbolic(&ptr, sizeof(int), "ptr");
  struct _ddebug descriptor ;
  long tmp___0 ;
  struct _ddebug descriptor___0 ;
  long tmp___1 ;
  bool __warned ;
  int __ret_warn_once ;
  int __ret_warn_on ;
  long tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;

  {
  hs_ep = hsotg->eps_out[ep_idx];
  hs_req = hs_ep->req;
  fifo = hsotg->regs + (unsigned long )((ep_idx + 1) * 4096);
  if ((unsigned long )hs_req == (unsigned long )((struct s3c_hsotg_req *)0)) {
    tmp = readl((void const volatile   *)hsotg->regs + (unsigned long )((ep_idx + 88) * 32));
    epctl = tmp;
    descriptor.modname = "dwc2";
    descriptor.function = "s3c_hsotg_rx_data";
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/gadget.c";
    descriptor.format = "%s: FIFO %d bytes on ep%d but no req (DXEPCTl=0x%08x)\n";
    descriptor.lineno = 1457U;
    descriptor.flags = 1U;
    tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
    if (tmp___0 != 0L) {
      __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "%s: FIFO %d bytes on ep%d but no req (DXEPCTl=0x%08x)\n",
                        "s3c_hsotg_rx_data", size, ep_idx, epctl);
    } else {

    }
    ptr = 0;
    goto ldv_34704;
    ldv_34703: 
    readl((void const volatile   *)fifo);
    ptr = ptr + 4;
    ldv_34704: ;
    if (ptr < size) {
      goto ldv_34703;
    } else {

    }

    return;
  } else {

  }
  to_read = size;
  read_ptr = (int )hs_req->req.actual;
  max_req = (int )(hs_req->req.length - (unsigned int )read_ptr);
  descriptor___0.modname = "dwc2";
  descriptor___0.function = "s3c_hsotg_rx_data";
  descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/gadget.c";
  descriptor___0.format = "%s: read %d/%d, done %d/%d\n";
  descriptor___0.lineno = 1471U;
  descriptor___0.flags = 1U;
  tmp___1 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
  if (tmp___1 != 0L) {
    __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)hsotg->dev, "%s: read %d/%d, done %d/%d\n",
                      "s3c_hsotg_rx_data", to_read, max_req, read_ptr, hs_req->req.length);
  } else {

  }
  if (to_read > max_req) {
    __ret_warn_once = 1;
    tmp___4 = ldv__builtin_expect(__ret_warn_once != 0, 0L);
    if (tmp___4 != 0L) {
      __ret_warn_on = ! __warned;
      tmp___2 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
      if (tmp___2 != 0L) {
        warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/gadget.c",
                           1480);
      } else {

      }
      tmp___3 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
      if (tmp___3 != 0L) {
        __warned = 1;
      } else {

      }
    } else {

    }
    ldv__builtin_expect(__ret_warn_once != 0, 0L);
  } else {

  }
  hs_ep->total_data = hs_ep->total_data + (unsigned long )to_read;
  hs_req->req.actual = hs_req->req.actual + (unsigned int )to_read;
  to_read = (to_read + 3) / 4;
  ioread32_rep(fifo, hs_req->req.buf + (unsigned long )read_ptr, (unsigned long )to_read);
  return;
}
}
static void s3c_hsotg_ep0_zlp(struct dwc2_hsotg *hsotg , bool dir_in ) 
{ 


  {
  (hsotg->eps_out[0])->dir_in = (unsigned char )dir_in;
  hsotg->ep0_state = (int )dir_in ? 3 : 4;
  s3c_hsotg_program_zlp(hsotg, hsotg->eps_out[0]);
  return;
}
}
static void s3c_hsotg_handle_outdone(struct dwc2_hsotg *hsotg , int epnum ) 
{ 
  u32 epsize ;
  unsigned int tmp ;
  struct s3c_hsotg_ep *hs_ep ;
  struct s3c_hsotg_req *hs_req ;
  struct usb_request *req ;
  unsigned int size_left ;
  int result ;
    klee_make_symbolic(&result, sizeof(int), "result");
  struct _ddebug descriptor ;
  long tmp___0 ;
  struct _ddebug descriptor___0 ;
  long tmp___1 ;
  unsigned int size_done ;
  bool tmp___2 ;
  struct _ddebug descriptor___1 ;
  long tmp___3 ;

  {
  tmp = readl((void const volatile   *)hsotg->regs + (unsigned long )(epnum * 32 + 2832));
  epsize = tmp;
  hs_ep = hsotg->eps_out[epnum];
  hs_req = hs_ep->req;
  req = & hs_req->req;
  size_left = epsize & 524287U;
  result = 0;
  if ((unsigned long )hs_req == (unsigned long )((struct s3c_hsotg_req *)0)) {
    descriptor.modname = "dwc2";
    descriptor.function = "s3c_hsotg_handle_outdone";
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/gadget.c";
    descriptor.format = "%s: no request active\n";
    descriptor.lineno = 1534U;
    descriptor.flags = 1U;
    tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
    if (tmp___0 != 0L) {
      __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "%s: no request active\n",
                        "s3c_hsotg_handle_outdone");
    } else {

    }
    return;
  } else {

  }
  if (epnum == 0 && (unsigned int )hsotg->ep0_state == 4U) {
    descriptor___0.modname = "dwc2";
    descriptor___0.function = "s3c_hsotg_handle_outdone";
    descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/gadget.c";
    descriptor___0.format = "zlp packet received\n";
    descriptor___0.lineno = 1539U;
    descriptor___0.flags = 1U;
    tmp___1 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
    if (tmp___1 != 0L) {
      __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)hsotg->dev, "zlp packet received\n");
    } else {

    }
    s3c_hsotg_complete_request(hsotg, hs_ep, hs_req, 0);
    s3c_hsotg_enqueue_setup(hsotg);
    return;
  } else {

  }
  tmp___2 = using_dma(hsotg);
  if ((int )tmp___2) {
    size_done = hs_ep->size_loaded - size_left;
    size_done = hs_ep->last_load + size_done;
    req->actual = size_done;
  } else {

  }
  if (req->actual < req->length && size_left == 0U) {
    s3c_hsotg_start_req(hsotg, hs_ep, hs_req, 1);
    return;
  } else {

  }
  if (req->actual < req->length && (unsigned int )*((unsigned char *)req + 42UL) != 0U) {
    descriptor___1.modname = "dwc2";
    descriptor___1.function = "s3c_hsotg_handle_outdone";
    descriptor___1.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/gadget.c";
    descriptor___1.format = "%s: got %d/%d (short not ok) => error\n";
    descriptor___1.lineno = 1571U;
    descriptor___1.flags = 1U;
    tmp___3 = ldv__builtin_expect((long )descriptor___1.flags & 1L, 0L);
    if (tmp___3 != 0L) {
      __dynamic_dev_dbg(& descriptor___1, (struct device  const  *)hsotg->dev, "%s: got %d/%d (short not ok) => error\n",
                        "s3c_hsotg_handle_outdone", req->actual, req->length);
    } else {

    }
  } else {

  }
  if (epnum == 0 && (unsigned int )hsotg->ep0_state == 2U) {
    s3c_hsotg_ep0_zlp(hsotg, 1);
    return;
  } else {

  }
  s3c_hsotg_complete_request(hsotg, hs_ep, hs_req, result);
  return;
}
}
static u32 s3c_hsotg_read_frameno(struct dwc2_hsotg *hsotg ) 
{ 
  u32 dsts ;

  {
  dsts = readl((void const volatile   *)hsotg->regs + 2056U);
  dsts = dsts & 4194048U;
  dsts = dsts >> 8;
  return (dsts);
}
}
static void s3c_hsotg_handle_rx(struct dwc2_hsotg *hsotg ) 
{ 
  u32 grxstsr ;
  unsigned int tmp ;
  u32 epnum ;
  u32 status ;
  u32 size ;
  int __ret_warn_on ;
  bool tmp___0 ;
  long tmp___1 ;
  struct _ddebug descriptor ;
  long tmp___2 ;
  struct _ddebug descriptor___0 ;
  long tmp___3 ;
  struct _ddebug descriptor___1 ;
  u32 tmp___4 ;
  long tmp___5 ;
  bool tmp___6 ;
  int tmp___7 ;
  struct _ddebug descriptor___2 ;
  unsigned int tmp___8 ;
  u32 tmp___9 ;
  long tmp___10 ;
  struct _ddebug descriptor___3 ;
  unsigned int tmp___11 ;
  u32 tmp___12 ;
  long tmp___13 ;
  int __ret_warn_on___0 ;
  long tmp___14 ;

  {
  tmp = readl((void const volatile   *)hsotg->regs + 32U);
  grxstsr = tmp;
  tmp___0 = using_dma(hsotg);
  __ret_warn_on = (int )tmp___0;
  tmp___1 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp___1 != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/gadget.c",
                       1626);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  epnum = grxstsr & 15U;
  status = grxstsr & 1966080U;
  size = grxstsr & 32752U;
  size = size >> 4;
  descriptor.modname = "dwc2";
  descriptor.function = "s3c_hsotg_handle_rx";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/gadget.c";
  descriptor.format = "%s: GRXSTSP=0x%08x (%d@%d)\n";
  descriptor.lineno = 1635U;
  descriptor.flags = 1U;
  tmp___2 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp___2 != 0L) {
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "%s: GRXSTSP=0x%08x (%d@%d)\n",
                      "s3c_hsotg_handle_rx", grxstsr, size, epnum);
  } else {

  }
  switch ((status & 1966080U) >> 17) {
  case 1U: 
  descriptor___0.modname = "dwc2";
  descriptor___0.function = "s3c_hsotg_handle_rx";
  descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/gadget.c";
  descriptor___0.format = "GLOBALOUTNAK\n";
  descriptor___0.lineno = 1639U;
  descriptor___0.flags = 1U;
  tmp___3 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
  if (tmp___3 != 0L) {
    __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)hsotg->dev, "GLOBALOUTNAK\n");
  } else {

  }
  goto ldv_34748;
  case 3U: 
  descriptor___1.modname = "dwc2";
  descriptor___1.function = "s3c_hsotg_handle_rx";
  descriptor___1.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/gadget.c";
  descriptor___1.format = "OutDone (Frame=0x%08x)\n";
  descriptor___1.lineno = 1644U;
  descriptor___1.flags = 1U;
  tmp___5 = ldv__builtin_expect((long )descriptor___1.flags & 1L, 0L);
  if (tmp___5 != 0L) {
    tmp___4 = s3c_hsotg_read_frameno(hsotg);
    __dynamic_dev_dbg(& descriptor___1, (struct device  const  *)hsotg->dev, "OutDone (Frame=0x%08x)\n",
                      tmp___4);
  } else {

  }
  tmp___6 = using_dma(hsotg);
  if (tmp___6) {
    tmp___7 = 0;
  } else {
    tmp___7 = 1;
  }
  if (tmp___7) {
    s3c_hsotg_handle_outdone(hsotg, (int )epnum);
  } else {

  }
  goto ldv_34748;
  case 4U: 
  descriptor___2.modname = "dwc2";
  descriptor___2.function = "s3c_hsotg_handle_rx";
  descriptor___2.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/gadget.c";
  descriptor___2.format = "SetupDone (Frame=0x%08x, DOPEPCTL=0x%08x)\n";
  descriptor___2.lineno = 1654U;
  descriptor___2.flags = 1U;
  tmp___10 = ldv__builtin_expect((long )descriptor___2.flags & 1L, 0L);
  if (tmp___10 != 0L) {
    tmp___8 = readl((void const volatile   *)hsotg->regs + 2816U);
    tmp___9 = s3c_hsotg_read_frameno(hsotg);
    __dynamic_dev_dbg(& descriptor___2, (struct device  const  *)hsotg->dev, "SetupDone (Frame=0x%08x, DOPEPCTL=0x%08x)\n",
                      tmp___9, tmp___8);
  } else {

  }
  if ((unsigned int )hsotg->ep0_state == 0U) {
    s3c_hsotg_handle_outdone(hsotg, (int )epnum);
  } else {

  }
  goto ldv_34748;
  case 2U: 
  s3c_hsotg_rx_data(hsotg, (int )epnum, (int )size);
  goto ldv_34748;
  case 6U: 
  descriptor___3.modname = "dwc2";
  descriptor___3.function = "s3c_hsotg_handle_rx";
  descriptor___3.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/gadget.c";
  descriptor___3.format = "SetupRX (Frame=0x%08x, DOPEPCTL=0x%08x)\n";
  descriptor___3.lineno = 1672U;
  descriptor___3.flags = 1U;
  tmp___13 = ldv__builtin_expect((long )descriptor___3.flags & 1L, 0L);
  if (tmp___13 != 0L) {
    tmp___11 = readl((void const volatile   *)hsotg->regs + 2816U);
    tmp___12 = s3c_hsotg_read_frameno(hsotg);
    __dynamic_dev_dbg(& descriptor___3, (struct device  const  *)hsotg->dev, "SetupRX (Frame=0x%08x, DOPEPCTL=0x%08x)\n",
                      tmp___12, tmp___11);
  } else {

  }
  __ret_warn_on___0 = (unsigned int )hsotg->ep0_state != 0U;
  tmp___14 = ldv__builtin_expect(__ret_warn_on___0 != 0, 0L);
  if (tmp___14 != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/gadget.c",
                       1674);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on___0 != 0, 0L);
  s3c_hsotg_rx_data(hsotg, (int )epnum, (int )size);
  goto ldv_34748;
  default: 
  dev_warn((struct device  const  *)hsotg->dev, "%s: unknown status %08x\n", "s3c_hsotg_handle_rx",
           grxstsr);
  s3c_hsotg_dump(hsotg);
  goto ldv_34748;
  }
  ldv_34748: ;
  return;
}
}
static u32 s3c_hsotg_ep0_mps(unsigned int mps ) 
{ 
  int __ret_warn_on ;
  long tmp ;

  {
  switch (mps) {
  case 64U: ;
  return (0U);
  case 32U: ;
  return (1U);
  case 16U: ;
  return (2U);
  case 8U: ;
  return (3U);
  }
  __ret_warn_on = 1;
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/gadget.c",
                       1706);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  return (4294967295U);
}
}
static void s3c_hsotg_set_ep_maxpacket(struct dwc2_hsotg *hsotg , unsigned int ep ,
                                       unsigned int mps , unsigned int dir_in ) 
{ 
  struct s3c_hsotg_ep *hs_ep ;
  void *regs ;
  u32 mpsval ;
  u32 mcval ;
  u32 reg ;

  {
  regs = hsotg->regs;
  hs_ep = index_to_ep(hsotg, ep, dir_in);
  if ((unsigned long )hs_ep == (unsigned long )((struct s3c_hsotg_ep *)0)) {
    return;
  } else {

  }
  if (ep == 0U) {
    mpsval = s3c_hsotg_ep0_mps(mps);
    if (mpsval > 3U) {
      goto bad_mps;
    } else {

    }
    hs_ep->ep.maxpacket = (unsigned short )mps;
    hs_ep->mc = 1U;
  } else {
    mpsval = mps & 2047U;
    if (mpsval > 1024U) {
      goto bad_mps;
    } else {

    }
    mcval = ((mps >> 11) & 3U) + 1U;
    hs_ep->mc = (unsigned char )mcval;
    if (mcval > 3U) {
      goto bad_mps;
    } else {

    }
    hs_ep->ep.maxpacket = (unsigned short )mpsval;
  }
  if (dir_in != 0U) {
    reg = readl((void const volatile   *)regs + (unsigned long )((ep + 72U) * 32U));
    reg = reg & 4294965248U;
    reg = reg | mpsval;
    writel(reg, (void volatile   *)regs + (unsigned long )((ep + 72U) * 32U));
  } else {
    reg = readl((void const volatile   *)regs + (unsigned long )((ep + 88U) * 32U));
    reg = reg & 4294965248U;
    reg = reg | mpsval;
    writel(reg, (void volatile   *)regs + (unsigned long )((ep + 88U) * 32U));
  }
  return;
  bad_mps: 
  dev_err((struct device  const  *)hsotg->dev, "ep%d: bad mps of %d\n", ep, mps);
  return;
}
}
static void s3c_hsotg_txfifo_flush(struct dwc2_hsotg *hsotg , unsigned int idx ) 
{ 
  int timeout ;
  int val ;
    klee_make_symbolic(&val, sizeof(int), "val");
  unsigned int tmp ;

  {
  writel((idx << 6) | 32U, (void volatile   *)hsotg->regs + 16U);
  timeout = 100;
  ldv_34788: 
  tmp = readl((void const volatile   *)hsotg->regs + 16U);
  val = (int )tmp;
  if ((val & 32) == 0) {
    goto ldv_34786;
  } else {

  }
  timeout = timeout - 1;
  if (timeout == 0) {
    dev_err((struct device  const  *)hsotg->dev, "%s: timeout flushing fifo (GRSTCTL=%08x)\n",
            "s3c_hsotg_txfifo_flush", val);
    goto ldv_34786;
  } else {

  }
  __const_udelay(4295UL);
  goto ldv_34788;
  ldv_34786: ;
  return;
}
}
static int s3c_hsotg_trytx(struct dwc2_hsotg *hsotg , struct s3c_hsotg_ep *hs_ep ) 
{ 
  struct s3c_hsotg_req *hs_req ;
  struct _ddebug descriptor ;
  long tmp ;
  int tmp___0 ;

  {
  hs_req = hs_ep->req;
  if ((unsigned int )hs_ep->dir_in == 0U || (unsigned long )hs_req == (unsigned long )((struct s3c_hsotg_req *)0)) {
    if ((unsigned int )hs_ep->index != 0U) {
      s3c_hsotg_ctrl_epint(hsotg, (unsigned int )hs_ep->index, (unsigned int )hs_ep->dir_in,
                           0U);
    } else {

    }
    return (0);
  } else {

  }
  if (hs_req->req.actual < hs_req->req.length) {
    descriptor.modname = "dwc2";
    descriptor.function = "s3c_hsotg_trytx";
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/gadget.c";
    descriptor.format = "trying to write more for ep%d\n";
    descriptor.lineno = 1827U;
    descriptor.flags = 1U;
    tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
    if (tmp != 0L) {
      __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "trying to write more for ep%d\n",
                        (int )hs_ep->index);
    } else {

    }
    tmp___0 = s3c_hsotg_write_fifo(hsotg, hs_ep, hs_req);
    return (tmp___0);
  } else {

  }
  return (0);
}
}
static void s3c_hsotg_complete_in(struct dwc2_hsotg *hsotg , struct s3c_hsotg_ep *hs_ep ) 
{ 
  struct s3c_hsotg_req *hs_req ;
  u32 epsize ;
  unsigned int tmp ;
  int size_left ;
  int size_done ;
  struct _ddebug descriptor ;
  long tmp___0 ;
  struct _ddebug descriptor___0 ;
  long tmp___1 ;
  int ret ;
  struct _ddebug descriptor___1 ;
  long tmp___2 ;
  struct _ddebug descriptor___2 ;
  long tmp___3 ;
  struct _ddebug descriptor___3 ;
  long tmp___4 ;
  struct _ddebug descriptor___4 ;
  long tmp___5 ;

  {
  hs_req = hs_ep->req;
  tmp = readl((void const volatile   *)hsotg->regs + (unsigned long )((int )hs_ep->index * 32 + 2320));
  epsize = tmp;
  if ((unsigned long )hs_req == (unsigned long )((struct s3c_hsotg_req *)0)) {
    descriptor.modname = "dwc2";
    descriptor.function = "s3c_hsotg_complete_in";
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/gadget.c";
    descriptor.format = "XferCompl but no req\n";
    descriptor.lineno = 1850U;
    descriptor.flags = 1U;
    tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
    if (tmp___0 != 0L) {
      __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "XferCompl but no req\n");
    } else {

    }
    return;
  } else {

  }
  if ((unsigned int )hs_ep->index == 0U && (unsigned int )hsotg->ep0_state == 3U) {
    descriptor___0.modname = "dwc2";
    descriptor___0.function = "s3c_hsotg_complete_in";
    descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/gadget.c";
    descriptor___0.format = "zlp packet sent\n";
    descriptor___0.lineno = 1856U;
    descriptor___0.flags = 1U;
    tmp___1 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
    if (tmp___1 != 0L) {
      __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)hsotg->dev, "zlp packet sent\n");
    } else {

    }
    s3c_hsotg_complete_request(hsotg, hs_ep, hs_req, 0);
    if ((unsigned int )hsotg->test_mode != 0U) {
      ret = s3c_hsotg_set_test_mode(hsotg, (int )hsotg->test_mode);
      if (ret < 0) {
        descriptor___1.modname = "dwc2";
        descriptor___1.function = "s3c_hsotg_complete_in";
        descriptor___1.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/gadget.c";
        descriptor___1.format = "Invalid Test #%d\n";
        descriptor___1.lineno = 1864U;
        descriptor___1.flags = 1U;
        tmp___2 = ldv__builtin_expect((long )descriptor___1.flags & 1L, 0L);
        if (tmp___2 != 0L) {
          __dynamic_dev_dbg(& descriptor___1, (struct device  const  *)hsotg->dev,
                            "Invalid Test #%d\n", (int )hsotg->test_mode);
        } else {

        }
        s3c_hsotg_stall_ep0(hsotg);
        return;
      } else {

      }
    } else {

    }
    s3c_hsotg_enqueue_setup(hsotg);
    return;
  } else {

  }
  size_left = (int )epsize & 524287;
  size_done = (int )(hs_ep->size_loaded - (unsigned int )size_left);
  size_done = (int )(hs_ep->last_load + (unsigned int )size_done);
  if (hs_req->req.actual != (unsigned int )size_done) {
    descriptor___2.modname = "dwc2";
    descriptor___2.function = "s3c_hsotg_complete_in";
    descriptor___2.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/gadget.c";
    descriptor___2.format = "%s: adjusting size done %d => %d\n";
    descriptor___2.lineno = 1890U;
    descriptor___2.flags = 1U;
    tmp___3 = ldv__builtin_expect((long )descriptor___2.flags & 1L, 0L);
    if (tmp___3 != 0L) {
      __dynamic_dev_dbg(& descriptor___2, (struct device  const  *)hsotg->dev, "%s: adjusting size done %d => %d\n",
                        "s3c_hsotg_complete_in", hs_req->req.actual, size_done);
    } else {

    }
  } else {

  }
  hs_req->req.actual = (unsigned int )size_done;
  descriptor___3.modname = "dwc2";
  descriptor___3.function = "s3c_hsotg_complete_in";
  descriptor___3.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/gadget.c";
  descriptor___3.format = "req->length:%d req->actual:%d req->zero:%d\n";
  descriptor___3.lineno = 1894U;
  descriptor___3.flags = 1U;
  tmp___4 = ldv__builtin_expect((long )descriptor___3.flags & 1L, 0L);
  if (tmp___4 != 0L) {
    __dynamic_dev_dbg(& descriptor___3, (struct device  const  *)hsotg->dev, "req->length:%d req->actual:%d req->zero:%d\n",
                      hs_req->req.length, hs_req->req.actual, (int )hs_req->req.zero);
  } else {

  }
  if (size_left == 0 && hs_req->req.actual < hs_req->req.length) {
    descriptor___4.modname = "dwc2";
    descriptor___4.function = "s3c_hsotg_complete_in";
    descriptor___4.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/gadget.c";
    descriptor___4.format = "%s trying more for req...\n";
    descriptor___4.lineno = 1897U;
    descriptor___4.flags = 1U;
    tmp___5 = ldv__builtin_expect((long )descriptor___4.flags & 1L, 0L);
    if (tmp___5 != 0L) {
      __dynamic_dev_dbg(& descriptor___4, (struct device  const  *)hsotg->dev, "%s trying more for req...\n",
                        "s3c_hsotg_complete_in");
    } else {

    }
    s3c_hsotg_start_req(hsotg, hs_ep, hs_req, 1);
    return;
  } else {

  }
  if ((unsigned int )*((unsigned char *)hs_ep + 132UL) != 0U) {
    s3c_hsotg_program_zlp(hsotg, hs_ep);
    hs_ep->send_zlp = 0U;
    return;
  } else {

  }
  if ((unsigned int )hs_ep->index == 0U && (unsigned int )hsotg->ep0_state == 1U) {
    s3c_hsotg_ep0_zlp(hsotg, 0);
    return;
  } else {

  }
  s3c_hsotg_complete_request(hsotg, hs_ep, hs_req, 0);
  return;
}
}
static void s3c_hsotg_epint(struct dwc2_hsotg *hsotg , unsigned int idx , int dir_in ) 
{ 
  struct s3c_hsotg_ep *hs_ep ;
  struct s3c_hsotg_ep *tmp ;
  u32 epint_reg ;
  u32 epctl_reg ;
  u32 epsiz_reg ;
  u32 ints ;
  u32 ctrl ;
  struct _ddebug descriptor ;
  long tmp___0 ;
  struct _ddebug descriptor___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  long tmp___3 ;
  bool tmp___4 ;
  struct _ddebug descriptor___1 ;
  long tmp___5 ;
  int epctl ;
    klee_make_symbolic(&epctl, sizeof(int), "epctl");
  unsigned int tmp___6 ;
  int dctl ;
  unsigned int tmp___7 ;
  struct _ddebug descriptor___2 ;
  long tmp___8 ;
  struct _ddebug descriptor___3 ;
  long tmp___9 ;
  bool __warned ;
  int __ret_warn_once ;
  int __ret_warn_on ;
  long tmp___10 ;
  long tmp___11 ;
  long tmp___12 ;
  bool tmp___13 ;
  struct _ddebug descriptor___4 ;
  long tmp___14 ;
  struct _ddebug descriptor___5 ;
  long tmp___15 ;
  struct _ddebug descriptor___6 ;
  long tmp___16 ;
  bool tmp___17 ;
  int tmp___18 ;

  {
  tmp = index_to_ep(hsotg, idx, (u32 )dir_in);
  hs_ep = tmp;
  epint_reg = dir_in != 0 ? idx * 32U + 2312U : idx * 32U + 2824U;
  epctl_reg = dir_in != 0 ? (idx + 72U) * 32U : (idx + 88U) * 32U;
  epsiz_reg = dir_in != 0 ? idx * 32U + 2320U : idx * 32U + 2832U;
  ints = readl((void const volatile   *)hsotg->regs + (unsigned long )epint_reg);
  ctrl = readl((void const volatile   *)hsotg->regs + (unsigned long )epctl_reg);
  writel(ints, (void volatile   *)hsotg->regs + (unsigned long )epint_reg);
  if ((unsigned long )hs_ep == (unsigned long )((struct s3c_hsotg_ep *)0)) {
    dev_err((struct device  const  *)hsotg->dev, "%s:Interrupt for unconfigured ep%d(%s)\n",
            "s3c_hsotg_epint", idx, dir_in != 0 ? (char *)"in" : (char *)"out");
    return;
  } else {

  }
  descriptor.modname = "dwc2";
  descriptor.function = "s3c_hsotg_epint";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/gadget.c";
  descriptor.format = "%s: ep%d(%s) DxEPINT=0x%08x\n";
  descriptor.lineno = 1950U;
  descriptor.flags = 1U;
  tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp___0 != 0L) {
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "%s: ep%d(%s) DxEPINT=0x%08x\n",
                      "s3c_hsotg_epint", idx, dir_in != 0 ? (char *)"in" : (char *)"out",
                      ints);
  } else {

  }
  if (idx == 0U && (ints & 32776U) != 0U) {
    ints = ints & 4294967294U;
  } else {

  }
  if ((int )ints & 1) {
    if ((unsigned int )*((unsigned char *)hs_ep + 132UL) != 0U && (unsigned int )hs_ep->interval == 1U) {
      if ((ctrl & 65536U) != 0U) {
        ctrl = ctrl | 268435456U;
      } else {
        ctrl = ctrl | 536870912U;
      }
      writel(ctrl, (void volatile   *)hsotg->regs + (unsigned long )epctl_reg);
    } else {

    }
    descriptor___0.modname = "dwc2";
    descriptor___0.function = "s3c_hsotg_epint";
    descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/gadget.c";
    descriptor___0.format = "%s: XferCompl: DxEPCTL=0x%08x, DXEPTSIZ=%08x\n";
    descriptor___0.lineno = 1968U;
    descriptor___0.flags = 1U;
    tmp___3 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
    if (tmp___3 != 0L) {
      tmp___1 = readl((void const volatile   *)hsotg->regs + (unsigned long )epsiz_reg);
      tmp___2 = readl((void const volatile   *)hsotg->regs + (unsigned long )epctl_reg);
      __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)hsotg->dev, "%s: XferCompl: DxEPCTL=0x%08x, DXEPTSIZ=%08x\n",
                        "s3c_hsotg_epint", tmp___2, tmp___1);
    } else {

    }
    if (dir_in != 0) {
      s3c_hsotg_complete_in(hsotg, hs_ep);
      if (idx == 0U && (unsigned long )hs_ep->req == (unsigned long )((struct s3c_hsotg_req *)0)) {
        s3c_hsotg_enqueue_setup(hsotg);
      } else {

      }
    } else {
      tmp___4 = using_dma(hsotg);
      if ((int )tmp___4) {
        s3c_hsotg_handle_outdone(hsotg, (int )idx);
      } else {

      }
    }
  } else {

  }
  if ((ints & 2U) != 0U) {
    descriptor___1.modname = "dwc2";
    descriptor___1.function = "s3c_hsotg_epint";
    descriptor___1.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/gadget.c";
    descriptor___1.format = "%s: EPDisbld\n";
    descriptor___1.lineno = 1990U;
    descriptor___1.flags = 1U;
    tmp___5 = ldv__builtin_expect((long )descriptor___1.flags & 1L, 0L);
    if (tmp___5 != 0L) {
      __dynamic_dev_dbg(& descriptor___1, (struct device  const  *)hsotg->dev, "%s: EPDisbld\n",
                        "s3c_hsotg_epint");
    } else {

    }
    if (dir_in != 0) {
      tmp___6 = readl((void const volatile   *)hsotg->regs + (unsigned long )epctl_reg);
      epctl = (int )tmp___6;
      s3c_hsotg_txfifo_flush(hsotg, (unsigned int )hs_ep->fifo_index);
      if ((epctl & 2097152) != 0 && (epctl & 524288) != 0) {
        tmp___7 = readl((void const volatile   *)hsotg->regs + 2052U);
        dctl = (int )tmp___7;
        dctl = dctl | 256;
        writel((unsigned int )dctl, (void volatile   *)hsotg->regs + 2052U);
      } else {

      }
    } else {

    }
  } else {

  }
  if ((ints & 4U) != 0U) {
    descriptor___2.modname = "dwc2";
    descriptor___2.function = "s3c_hsotg_epint";
    descriptor___2.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/gadget.c";
    descriptor___2.format = "%s: AHBErr\n";
    descriptor___2.lineno = 2008U;
    descriptor___2.flags = 1U;
    tmp___8 = ldv__builtin_expect((long )descriptor___2.flags & 1L, 0L);
    if (tmp___8 != 0L) {
      __dynamic_dev_dbg(& descriptor___2, (struct device  const  *)hsotg->dev, "%s: AHBErr\n",
                        "s3c_hsotg_epint");
    } else {

    }
  } else {

  }
  if ((ints & 8U) != 0U) {
    descriptor___3.modname = "dwc2";
    descriptor___3.function = "s3c_hsotg_epint";
    descriptor___3.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/gadget.c";
    descriptor___3.format = "%s: Setup/Timeout\n";
    descriptor___3.lineno = 2011U;
    descriptor___3.flags = 1U;
    tmp___9 = ldv__builtin_expect((long )descriptor___3.flags & 1L, 0L);
    if (tmp___9 != 0L) {
      __dynamic_dev_dbg(& descriptor___3, (struct device  const  *)hsotg->dev, "%s: Setup/Timeout\n",
                        "s3c_hsotg_epint");
    } else {

    }
    tmp___13 = using_dma(hsotg);
    if ((int )tmp___13 && idx == 0U) {
      if (dir_in != 0) {
        __ret_warn_once = 1;
        tmp___12 = ldv__builtin_expect(__ret_warn_once != 0, 0L);
        if (tmp___12 != 0L) {
          __ret_warn_on = ! __warned;
          tmp___10 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
          if (tmp___10 != 0L) {
            warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/gadget.c",
                               2022);
          } else {

          }
          tmp___11 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
          if (tmp___11 != 0L) {
            __warned = 1;
          } else {

          }
        } else {

        }
        ldv__builtin_expect(__ret_warn_once != 0, 0L);
      } else {
        s3c_hsotg_handle_outdone(hsotg, 0);
      }
    } else {

    }
  } else {

  }
  if ((ints & 64U) != 0U) {
    descriptor___4.modname = "dwc2";
    descriptor___4.function = "s3c_hsotg_epint";
    descriptor___4.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/gadget.c";
    descriptor___4.format = "%s: B2BSetup/INEPNakEff\n";
    descriptor___4.lineno = 2029U;
    descriptor___4.flags = 1U;
    tmp___14 = ldv__builtin_expect((long )descriptor___4.flags & 1L, 0L);
    if (tmp___14 != 0L) {
      __dynamic_dev_dbg(& descriptor___4, (struct device  const  *)hsotg->dev, "%s: B2BSetup/INEPNakEff\n",
                        "s3c_hsotg_epint");
    } else {

    }
  } else {

  }
  if (dir_in != 0 && (unsigned int )*((unsigned char *)hs_ep + 132UL) == 0U) {
    if ((ints & 16U) != 0U) {
      descriptor___5.modname = "dwc2";
      descriptor___5.function = "s3c_hsotg_epint";
      descriptor___5.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/gadget.c";
      descriptor___5.format = "%s: ep%d: INTknTXFEmpMsk\n";
      descriptor___5.lineno = 2035U;
      descriptor___5.flags = 1U;
      tmp___15 = ldv__builtin_expect((long )descriptor___5.flags & 1L, 0L);
      if (tmp___15 != 0L) {
        __dynamic_dev_dbg(& descriptor___5, (struct device  const  *)hsotg->dev, "%s: ep%d: INTknTXFEmpMsk\n",
                          "s3c_hsotg_epint", idx);
      } else {

      }
    } else {

    }
    if ((ints & 32U) != 0U) {
      dev_warn((struct device  const  *)hsotg->dev, "%s: ep%d: INTknEP\n", "s3c_hsotg_epint",
               idx);
    } else {

    }
    if ((unsigned int )*((unsigned char *)hsotg + 1608UL) != 0U && (ints & 128U) != 0U) {
      descriptor___6.modname = "dwc2";
      descriptor___6.function = "s3c_hsotg_epint";
      descriptor___6.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/gadget.c";
      descriptor___6.format = "%s: ep%d: TxFIFOEmpty\n";
      descriptor___6.lineno = 2048U;
      descriptor___6.flags = 1U;
      tmp___16 = ldv__builtin_expect((long )descriptor___6.flags & 1L, 0L);
      if (tmp___16 != 0L) {
        __dynamic_dev_dbg(& descriptor___6, (struct device  const  *)hsotg->dev, "%s: ep%d: TxFIFOEmpty\n",
                          "s3c_hsotg_epint", idx);
      } else {

      }
      tmp___17 = using_dma(hsotg);
      if (tmp___17) {
        tmp___18 = 0;
      } else {
        tmp___18 = 1;
      }
      if (tmp___18) {
        s3c_hsotg_trytx(hsotg, hs_ep);
      } else {

      }
    } else {

    }
  } else {

  }
  return;
}
}
static void s3c_hsotg_irq_enumdone(struct dwc2_hsotg *hsotg ) 
{ 
  u32 dsts ;
  unsigned int tmp ;
  int ep0_mps ;
    klee_make_symbolic(&ep0_mps, sizeof(int), "ep0_mps");
  int ep_mps ;
    klee_make_symbolic(&ep_mps, sizeof(int), "ep_mps");
  struct _ddebug descriptor ;
  long tmp___0 ;
  char const   *tmp___1 ;
  int i ;
  struct _ddebug descriptor___0 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;
  long tmp___4 ;

  {
  tmp = readl((void const volatile   *)hsotg->regs + 2056U);
  dsts = tmp;
  ep0_mps = 0;
  ep_mps = 8;
  descriptor.modname = "dwc2";
  descriptor.function = "s3c_hsotg_irq_enumdone";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/gadget.c";
  descriptor.format = "EnumDone (DSTS=0x%08x)\n";
  descriptor.lineno = 2073U;
  descriptor.flags = 1U;
  tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp___0 != 0L) {
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "EnumDone (DSTS=0x%08x)\n",
                      dsts);
  } else {

  }
  switch (dsts & 6U) {
  case 1U: ;
  case 3U: 
  hsotg->gadget.speed = 2;
  ep0_mps = 64;
  ep_mps = 1023;
  goto ldv_34849;
  case 0U: 
  hsotg->gadget.speed = 3;
  ep0_mps = 64;
  ep_mps = 1024;
  goto ldv_34849;
  case 2U: 
  hsotg->gadget.speed = 1;
  goto ldv_34849;
  }
  ldv_34849: 
  tmp___1 = usb_speed_string(hsotg->gadget.speed);
  _dev_info((struct device  const  *)hsotg->dev, "new device is %s\n", tmp___1);
  if (ep0_mps != 0) {
    s3c_hsotg_set_ep_maxpacket(hsotg, 0U, (unsigned int )ep0_mps, 1U);
    s3c_hsotg_set_ep_maxpacket(hsotg, 0U, (unsigned int )ep0_mps, 0U);
    i = 1;
    goto ldv_34854;
    ldv_34853: ;
    if ((unsigned long )hsotg->eps_in[i] != (unsigned long )((struct s3c_hsotg_ep *)0)) {
      s3c_hsotg_set_ep_maxpacket(hsotg, (unsigned int )i, (unsigned int )ep_mps, 1U);
    } else {

    }
    if ((unsigned long )hsotg->eps_out[i] != (unsigned long )((struct s3c_hsotg_ep *)0)) {
      s3c_hsotg_set_ep_maxpacket(hsotg, (unsigned int )i, (unsigned int )ep_mps, 0U);
    } else {

    }
    i = i + 1;
    ldv_34854: ;
    if ((int )hsotg->num_of_eps > i) {
      goto ldv_34853;
    } else {

    }

  } else {

  }
  s3c_hsotg_enqueue_setup(hsotg);
  descriptor___0.modname = "dwc2";
  descriptor___0.function = "s3c_hsotg_irq_enumdone";
  descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/gadget.c";
  descriptor___0.format = "EP0: DIEPCTL0=0x%08x, DOEPCTL0=0x%08x\n";
  descriptor___0.lineno = 2132U;
  descriptor___0.flags = 1U;
  tmp___4 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
  if (tmp___4 != 0L) {
    tmp___2 = readl((void const volatile   *)hsotg->regs + 2816U);
    tmp___3 = readl((void const volatile   *)hsotg->regs + 2304U);
    __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)hsotg->dev, "EP0: DIEPCTL0=0x%08x, DOEPCTL0=0x%08x\n",
                      tmp___3, tmp___2);
  } else {

  }
  return;
}
}
static void kill_all_requests(struct dwc2_hsotg *hsotg , struct s3c_hsotg_ep *ep ,
                              int result ) 
{ 
  struct s3c_hsotg_req *req ;
  struct s3c_hsotg_req *treq ;
  unsigned int size ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;
  unsigned int tmp ;

  {
  ep->req = (struct s3c_hsotg_req *)0;
  __mptr = (struct list_head  const  *)ep->queue.next;
  req = (struct s3c_hsotg_req *)__mptr + 0xffffffffffffffa8UL;
  __mptr___0 = (struct list_head  const  *)req->queue.next;
  treq = (struct s3c_hsotg_req *)__mptr___0 + 0xffffffffffffffa8UL;
  goto ldv_34872;
  ldv_34871: 
  s3c_hsotg_complete_request(hsotg, ep, req, result);
  req = treq;
  __mptr___1 = (struct list_head  const  *)treq->queue.next;
  treq = (struct s3c_hsotg_req *)__mptr___1 + 0xffffffffffffffa8UL;
  ldv_34872: ;
  if ((unsigned long )(& req->queue) != (unsigned long )(& ep->queue)) {
    goto ldv_34871;
  } else {

  }

  if ((unsigned int )*((unsigned char *)hsotg + 1608UL) == 0U) {
    return;
  } else {

  }
  tmp = readl((void const volatile   *)hsotg->regs + (unsigned long )((int )ep->index * 32 + 2328));
  size = (tmp & 65535U) * 4U;
  if ((unsigned int )ep->fifo_size > size) {
    s3c_hsotg_txfifo_flush(hsotg, (unsigned int )ep->fifo_index);
  } else {

  }
  return;
}
}
void s3c_hsotg_disconnect(struct dwc2_hsotg *hsotg ) 
{ 
  unsigned int ep ;

  {
  if ((unsigned int )*((unsigned char *)hsotg + 3232UL) == 0U) {
    return;
  } else {

  }
  hsotg->connected = 0U;
  hsotg->test_mode = 0U;
  ep = 0U;
  goto ldv_34879;
  ldv_34878: ;
  if ((unsigned long )hsotg->eps_in[ep] != (unsigned long )((struct s3c_hsotg_ep *)0)) {
    kill_all_requests(hsotg, hsotg->eps_in[ep], -108);
  } else {

  }
  if ((unsigned long )hsotg->eps_out[ep] != (unsigned long )((struct s3c_hsotg_ep *)0)) {
    kill_all_requests(hsotg, hsotg->eps_out[ep], -108);
  } else {

  }
  ep = ep + 1U;
  ldv_34879: ;
  if ((unsigned int )hsotg->num_of_eps > ep) {
    goto ldv_34878;
  } else {

  }

  if (((unsigned int )hsotg->gadget.speed != 0U && (unsigned long )hsotg->driver != (unsigned long )((struct usb_gadget_driver *)0)) && (unsigned long )(hsotg->driver)->disconnect != (unsigned long )((void (*)(struct usb_gadget * ))0)) {
    spin_unlock(& hsotg->lock);
    (*((hsotg->driver)->disconnect))(& hsotg->gadget);
    spin_lock(& hsotg->lock);
  } else {

  }
  return;
}
}
static void s3c_hsotg_irq_fifoempty(struct dwc2_hsotg *hsotg , bool periodic ) 
{ 
  struct s3c_hsotg_ep *ep ;
  int epno ;
    klee_make_symbolic(&epno, sizeof(int), "epno");
  int ret ;

  {
  epno = 0;
  goto ldv_34891;
  ldv_34890: 
  ep = index_to_ep(hsotg, (u32 )epno, 1U);
  if ((unsigned long )ep == (unsigned long )((struct s3c_hsotg_ep *)0)) {
    goto ldv_34888;
  } else {

  }
  if ((unsigned int )ep->dir_in == 0U) {
    goto ldv_34888;
  } else {

  }
  if (((int )periodic && (unsigned int )*((unsigned char *)ep + 132UL) == 0U) || (! periodic && (unsigned int )*((unsigned char *)ep + 132UL) != 0U)) {
    goto ldv_34888;
  } else {

  }
  ret = s3c_hsotg_trytx(hsotg, ep);
  if (ret < 0) {
    goto ldv_34889;
  } else {

  }
  ldv_34888: 
  epno = epno + 1;
  ldv_34891: ;
  if ((int )hsotg->num_of_eps > epno) {
    goto ldv_34890;
  } else {

  }
  ldv_34889: ;
  return;
}
}
static int s3c_hsotg_corereset(struct dwc2_hsotg *hsotg ) 
{ 
  int timeout ;
  u32 grstctl ;
  struct _ddebug descriptor ;
  long tmp ;
  int tmp___0 ;
  u32 grstctl___0 ;
  unsigned int tmp___1 ;
  int tmp___2 ;
  struct _ddebug descriptor___0 ;
  long tmp___3 ;

  {
  descriptor.modname = "dwc2";
  descriptor.function = "s3c_hsotg_corereset";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/gadget.c";
  descriptor.format = "resetting core\n";
  descriptor.lineno = 2240U;
  descriptor.flags = 1U;
  tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp != 0L) {
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "resetting core\n");
  } else {

  }
  writel(1U, (void volatile   *)hsotg->regs + 16U);
  timeout = 10000;
  ldv_34899: 
  grstctl = readl((void const volatile   *)hsotg->regs + 16U);
  if ((int )grstctl & 1) {
    tmp___0 = timeout;
    timeout = timeout - 1;
    if (tmp___0 > 0) {
      goto ldv_34899;
    } else {
      goto ldv_34900;
    }
  } else {

  }
  ldv_34900: ;
  if ((int )grstctl & 1) {
    dev_err((struct device  const  *)hsotg->dev, "Failed to get CSftRst asserted\n");
    return (-22);
  } else {

  }
  timeout = 10000;
  ldv_34904: 
  tmp___1 = readl((void const volatile   *)hsotg->regs + 16U);
  grstctl___0 = tmp___1;
  tmp___2 = timeout;
  timeout = timeout - 1;
  if (tmp___2 < 0) {
    _dev_info((struct device  const  *)hsotg->dev, "%s: reset failed, GRSTCTL=%08x\n",
              "s3c_hsotg_corereset", grstctl___0);
    return (-110);
  } else {

  }
  if ((int )grstctl___0 >= 0) {
    goto ldv_34902;
  } else {

  }
  goto ldv_34903;
  ldv_34902: ;
  goto ldv_34904;
  ldv_34903: 
  descriptor___0.modname = "dwc2";
  descriptor___0.function = "s3c_hsotg_corereset";
  descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/gadget.c";
  descriptor___0.format = "reset successful\n";
  descriptor___0.lineno = 2273U;
  descriptor___0.flags = 1U;
  tmp___3 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
  if (tmp___3 != 0L) {
    __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)hsotg->dev, "reset successful\n");
  } else {

  }
  return (0);
}
}
void s3c_hsotg_core_init_disconnected(struct dwc2_hsotg *hsotg , bool is_usb_reset ) 
{ 
  u32 val ;
  bool tmp ;
  unsigned int tmp___2 ;
  bool tmp___3 ;
  int tmp___4 ;
  bool tmp___5 ;
  struct _ddebug descriptor ;
  unsigned int tmp___6 ;
  unsigned int tmp___7 ;
  long tmp___8 ;
  bool tmp___9 ;
  int tmp___10 ;
  struct _ddebug descriptor___0 ;
  unsigned int tmp___11 ;
  long tmp___12 ;
  u32 tmp___13 ;
  u32 tmp___14 ;
  struct _ddebug descriptor___1 ;
  unsigned int tmp___15 ;
  unsigned int tmp___16 ;
  long tmp___17 ;
  unsigned long __ms ;
    klee_make_symbolic(&__ms, sizeof(long), "__ms");
  unsigned long tmp___18 ;

  {
  if (! is_usb_reset) {
    s3c_hsotg_corereset(hsotg);
  } else {

  }
  val = hsotg->phyif == 0U ? 9U : 5U;
  writel((hsotg->phyif | (val << 10)) | 7U, (void volatile   *)hsotg->regs + 12U);
  s3c_hsotg_init_fifo(hsotg);
  if (! is_usb_reset) {
    __orr32(hsotg->regs + 2052UL, 2U);
  } else {

  }
  writel(262144U, (void volatile   *)hsotg->regs + 2048U);
  writel(4294967295U, (void volatile   *)hsotg->regs + 4U);
  writel(4294967295U, (void volatile   *)hsotg->regs + 20U);
  writel(3498065092U, (void volatile   *)hsotg->regs + 24U);
  tmp = using_dma(hsotg);
  if ((int )tmp) {
    writel(39U, (void volatile   *)hsotg->regs + 8U);
  } else {
    writel((unsigned int )*((unsigned char *)hsotg + 1608UL) != 0U ? 385U : 1U, (void volatile   *)hsotg->regs + 8U);
  }
  if ((unsigned int )*((unsigned char *)hsotg + 1608UL) != 0U) {
    tmp___3 = using_dma(hsotg);
    if (tmp___3) {
      tmp___4 = 0;
    } else {
      tmp___4 = 1;
    }
    if (tmp___4) {
      tmp___2 = 191U;
    } else {
      tmp___2 = 47U;
    }
  } else {
    tmp___2 = 47U;
  }
  writel(tmp___2, (void volatile   *)hsotg->regs + 2064U);
  tmp___5 = using_dma(hsotg);
  writel((int )tmp___5 ? 15U : 14U, (void volatile   *)hsotg->regs + 2068U);
  writel(0U, (void volatile   *)hsotg->regs + 2076U);
  descriptor.modname = "dwc2";
  descriptor.function = "s3c_hsotg_core_init_disconnected";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/gadget.c";
  descriptor.format = "EP0: DIEPCTL0=0x%08x, DOEPCTL0=0x%08x\n";
  descriptor.lineno = 2359U;
  descriptor.flags = 1U;
  tmp___8 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp___8 != 0L) {
    tmp___6 = readl((void const volatile   *)hsotg->regs + 2816U);
    tmp___7 = readl((void const volatile   *)hsotg->regs + 2304U);
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "EP0: DIEPCTL0=0x%08x, DOEPCTL0=0x%08x\n",
                      tmp___7, tmp___6);
  } else {

  }
  s3c_hsotg_en_gsint(hsotg, 786432U);
  tmp___9 = using_dma(hsotg);
  if (tmp___9) {
    tmp___10 = 0;
  } else {
    tmp___10 = 1;
  }
  if (tmp___10) {
    s3c_hsotg_en_gsint(hsotg, 16U);
  } else {

  }
  s3c_hsotg_ctrl_epint(hsotg, 0U, 0U, 1U);
  s3c_hsotg_ctrl_epint(hsotg, 0U, 1U, 1U);
  if (! is_usb_reset) {
    __orr32(hsotg->regs + 2052UL, 2048U);
    __const_udelay(42950UL);
    __bic32(hsotg->regs + 2052UL, 2048U);
  } else {

  }
  descriptor___0.modname = "dwc2";
  descriptor___0.function = "s3c_hsotg_core_init_disconnected";
  descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/gadget.c";
  descriptor___0.format = "DCTL=0x%08x\n";
  descriptor___0.lineno = 2382U;
  descriptor___0.flags = 1U;
  tmp___12 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
  if (tmp___12 != 0L) {
    tmp___11 = readl((void const volatile   *)hsotg->regs + 2052U);
    __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)hsotg->dev, "DCTL=0x%08x\n",
                      tmp___11);
  } else {

  }
  writel(537395208U, (void volatile   *)hsotg->regs + 2832U);
  tmp___13 = s3c_hsotg_ep0_mps((unsigned int )(hsotg->eps_out[0])->ep.maxpacket);
  writel(tmp___13 | 2214625280U, (void volatile   *)hsotg->regs + 2816U);
  tmp___14 = s3c_hsotg_ep0_mps((unsigned int )(hsotg->eps_out[0])->ep.maxpacket);
  writel(tmp___14 | 32768U, (void volatile   *)hsotg->regs + 2304U);
  s3c_hsotg_enqueue_setup(hsotg);
  descriptor___1.modname = "dwc2";
  descriptor___1.function = "s3c_hsotg_core_init_disconnected";
  descriptor___1.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/gadget.c";
  descriptor___1.format = "EP0: DIEPCTL0=0x%08x, DOEPCTL0=0x%08x\n";
  descriptor___1.lineno = 2406U;
  descriptor___1.flags = 1U;
  tmp___17 = ldv__builtin_expect((long )descriptor___1.flags & 1L, 0L);
  if (tmp___17 != 0L) {
    tmp___15 = readl((void const volatile   *)hsotg->regs + 2816U);
    tmp___16 = readl((void const volatile   *)hsotg->regs + 2304U);
    __dynamic_dev_dbg(& descriptor___1, (struct device  const  *)hsotg->dev, "EP0: DIEPCTL0=0x%08x, DOEPCTL0=0x%08x\n",
                      tmp___16, tmp___15);
  } else {

  }
  val = 1280U;
  if (! is_usb_reset) {
    val = val | 2U;
  } else {

  }
  __orr32(hsotg->regs + 2052UL, val);
  if (1) {
    __const_udelay(12885000UL);
  } else {
    __ms = 3UL;
    goto ldv_34917;
    ldv_34916: 
    __const_udelay(4295000UL);
    ldv_34917: 
    tmp___18 = __ms;
    __ms = __ms - 1UL;
    if (tmp___18 != 0UL) {
      goto ldv_34916;
    } else {

    }

  }
  hsotg->last_rst = jiffies;
  return;
}
}
static void s3c_hsotg_core_disconnect(struct dwc2_hsotg *hsotg ) 
{ 


  {
  __orr32(hsotg->regs + 2052UL, 2U);
  return;
}
}
void s3c_hsotg_core_connect(struct dwc2_hsotg *hsotg ) 
{ 


  {
  __bic32(hsotg->regs + 2052UL, 2U);
  return;
}
}
static irqreturn_t s3c_hsotg_irq(int irq , void *pw ) 
{ 
  struct dwc2_hsotg *hsotg ;
  int retry_count ;
    klee_make_symbolic(&retry_count, sizeof(int), "retry_count");
  u32 gintsts ;
  u32 gintmsk ;
  struct _ddebug descriptor ;
  long tmp ;
  u32 daint ;
  unsigned int tmp___0 ;
  u32 daintmsk ;
  unsigned int tmp___1 ;
  u32 daint_out ;
  u32 daint_in ;
  int ep ;
  struct _ddebug descriptor___0 ;
  long tmp___2 ;
  struct _ddebug descriptor___1 ;
  long tmp___3 ;
  u32 usb_status ;
  unsigned int tmp___4 ;
  struct _ddebug descriptor___2 ;
  long tmp___5 ;
  struct _ddebug descriptor___3 ;
  unsigned int tmp___6 ;
  long tmp___7 ;
  unsigned long tmp___8 ;
  struct _ddebug descriptor___4 ;
  long tmp___9 ;
  struct _ddebug descriptor___5 ;
  long tmp___10 ;
  struct _ddebug descriptor___6 ;
  long tmp___11 ;

  {
  hsotg = (struct dwc2_hsotg *)pw;
  retry_count = 8;
  spin_lock(& hsotg->lock);
  irq_retry: 
  gintsts = readl((void const volatile   *)hsotg->regs + 20U);
  gintmsk = readl((void const volatile   *)hsotg->regs + 24U);
  descriptor.modname = "dwc2";
  descriptor.function = "s3c_hsotg_irq";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/gadget.c";
  descriptor.format = "%s: %08x %08x (%08x) retry %d\n";
  descriptor.lineno = 2450U;
  descriptor.flags = 1U;
  tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp != 0L) {
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "%s: %08x %08x (%08x) retry %d\n",
                      "s3c_hsotg_irq", gintsts, gintsts & gintmsk, gintmsk, retry_count);
  } else {

  }
  gintsts = gintsts & gintmsk;
  if ((gintsts & 8192U) != 0U) {
    writel(8192U, (void volatile   *)hsotg->regs + 20U);
    s3c_hsotg_irq_enumdone(hsotg);
  } else {

  }
  if ((gintsts & 786432U) != 0U) {
    tmp___0 = readl((void const volatile   *)hsotg->regs + 2072U);
    daint = tmp___0;
    tmp___1 = readl((void const volatile   *)hsotg->regs + 2076U);
    daintmsk = tmp___1;
    daint = daint & daintmsk;
    daint_out = daint >> 16;
    daint_in = ~ (daint_out << 16) & daint;
    descriptor___0.modname = "dwc2";
    descriptor___0.function = "s3c_hsotg_irq";
    descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/gadget.c";
    descriptor___0.format = "%s: daint=%08x\n";
    descriptor___0.lineno = 2470U;
    descriptor___0.flags = 1U;
    tmp___2 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
    if (tmp___2 != 0L) {
      __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)hsotg->dev, "%s: daint=%08x\n",
                        "s3c_hsotg_irq", daint);
    } else {

    }
    ep = 0;
    goto ldv_34943;
    ldv_34942: ;
    if ((int )daint_out & 1) {
      s3c_hsotg_epint(hsotg, (unsigned int )ep, 0);
    } else {

    }
    ep = ep + 1;
    daint_out = daint_out >> 1;
    ldv_34943: ;
    if ((int )hsotg->num_of_eps > ep && daint_out != 0U) {
      goto ldv_34942;
    } else {

    }
    ep = 0;
    goto ldv_34946;
    ldv_34945: ;
    if ((int )daint_in & 1) {
      s3c_hsotg_epint(hsotg, (unsigned int )ep, 1);
    } else {

    }
    ep = ep + 1;
    daint_in = daint_in >> 1;
    ldv_34946: ;
    if ((int )hsotg->num_of_eps > ep && daint_in != 0U) {
      goto ldv_34945;
    } else {

    }

  } else {

  }
  if ((gintsts & 8388608U) != 0U) {
    descriptor___1.modname = "dwc2";
    descriptor___1.function = "s3c_hsotg_irq";
    descriptor___1.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/gadget.c";
    descriptor___1.format = "%s: USBRstDet\n";
    descriptor___1.lineno = 2486U;
    descriptor___1.flags = 1U;
    tmp___3 = ldv__builtin_expect((long )descriptor___1.flags & 1L, 0L);
    if (tmp___3 != 0L) {
      __dynamic_dev_dbg(& descriptor___1, (struct device  const  *)hsotg->dev, "%s: USBRstDet\n",
                        "s3c_hsotg_irq");
    } else {

    }
    writel(8388608U, (void volatile   *)hsotg->regs + 20U);
    if ((unsigned int )hsotg->lx_state == 2U) {
      dwc2_exit_hibernation(hsotg, 1);
      hsotg->lx_state = 0;
    } else {

    }
  } else {

  }
  if ((gintsts & 8392704U) != 0U) {
    tmp___4 = readl((void const volatile   *)hsotg->regs);
    usb_status = tmp___4;
    descriptor___2.modname = "dwc2";
    descriptor___2.function = "s3c_hsotg_irq";
    descriptor___2.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/gadget.c";
    descriptor___2.format = "%s: USBRst\n";
    descriptor___2.lineno = 2501U;
    descriptor___2.flags = 1U;
    tmp___5 = ldv__builtin_expect((long )descriptor___2.flags & 1L, 0L);
    if (tmp___5 != 0L) {
      __dynamic_dev_dbg(& descriptor___2, (struct device  const  *)hsotg->dev, "%s: USBRst\n",
                        "s3c_hsotg_irq");
    } else {

    }
    descriptor___3.modname = "dwc2";
    descriptor___3.function = "s3c_hsotg_irq";
    descriptor___3.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/gadget.c";
    descriptor___3.format = "GNPTXSTS=%08x\n";
    descriptor___3.lineno = 2503U;
    descriptor___3.flags = 1U;
    tmp___7 = ldv__builtin_expect((long )descriptor___3.flags & 1L, 0L);
    if (tmp___7 != 0L) {
      tmp___6 = readl((void const volatile   *)hsotg->regs + 44U);
      __dynamic_dev_dbg(& descriptor___3, (struct device  const  *)hsotg->dev, "GNPTXSTS=%08x\n",
                        tmp___6);
    } else {

    }
    writel(4096U, (void volatile   *)hsotg->regs + 20U);
    s3c_hsotg_disconnect(hsotg);
    if ((usb_status & 524288U) != 0U) {
      tmp___8 = msecs_to_jiffies(200U);
      if ((long )((hsotg->last_rst + tmp___8) - (unsigned long )jiffies) < 0L) {
        kill_all_requests(hsotg, hsotg->eps_out[0], -104);
        hsotg->lx_state = 0;
        s3c_hsotg_core_init_disconnected(hsotg, 1);
      } else {

      }
    } else {

    }
  } else {

  }
  if ((gintsts & 32U) != 0U) {
    descriptor___4.modname = "dwc2";
    descriptor___4.function = "s3c_hsotg_irq";
    descriptor___4.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/gadget.c";
    descriptor___4.format = "NPTxFEmp\n";
    descriptor___4.lineno = 2526U;
    descriptor___4.flags = 1U;
    tmp___9 = ldv__builtin_expect((long )descriptor___4.flags & 1L, 0L);
    if (tmp___9 != 0L) {
      __dynamic_dev_dbg(& descriptor___4, (struct device  const  *)hsotg->dev, "NPTxFEmp\n");
    } else {

    }
    s3c_hsotg_disable_gsint(hsotg, 32U);
    s3c_hsotg_irq_fifoempty(hsotg, 0);
  } else {

  }
  if ((gintsts & 67108864U) != 0U) {
    descriptor___5.modname = "dwc2";
    descriptor___5.function = "s3c_hsotg_irq";
    descriptor___5.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/gadget.c";
    descriptor___5.format = "PTxFEmp\n";
    descriptor___5.lineno = 2539U;
    descriptor___5.flags = 1U;
    tmp___10 = ldv__builtin_expect((long )descriptor___5.flags & 1L, 0L);
    if (tmp___10 != 0L) {
      __dynamic_dev_dbg(& descriptor___5, (struct device  const  *)hsotg->dev, "PTxFEmp\n");
    } else {

    }
    s3c_hsotg_disable_gsint(hsotg, 67108864U);
    s3c_hsotg_irq_fifoempty(hsotg, 1);
  } else {

  }
  if ((gintsts & 16U) != 0U) {
    s3c_hsotg_handle_rx(hsotg);
  } else {

  }
  if ((gintsts & 1024U) != 0U) {
    descriptor___6.modname = "dwc2";
    descriptor___6.function = "s3c_hsotg_irq";
    descriptor___6.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/gadget.c";
    descriptor___6.format = "GINTSTS_ErlySusp\n";
    descriptor___6.lineno = 2558U;
    descriptor___6.flags = 1U;
    tmp___11 = ldv__builtin_expect((long )descriptor___6.flags & 1L, 0L);
    if (tmp___11 != 0L) {
      __dynamic_dev_dbg(& descriptor___6, (struct device  const  *)hsotg->dev, "GINTSTS_ErlySusp\n");
    } else {

    }
    writel(1024U, (void volatile   *)hsotg->regs + 20U);
  } else {

  }
  if ((gintsts & 128U) != 0U) {
    _dev_info((struct device  const  *)hsotg->dev, "GOUTNakEff triggered\n");
    writel(1024U, (void volatile   *)hsotg->regs + 2052U);
    s3c_hsotg_dump(hsotg);
  } else {

  }
  if ((gintsts & 64U) != 0U) {
    _dev_info((struct device  const  *)hsotg->dev, "GINNakEff triggered\n");
    writel(256U, (void volatile   *)hsotg->regs + 2052U);
    s3c_hsotg_dump(hsotg);
  } else {

  }
  if ((gintsts & 67108912U) != 0U) {
    retry_count = retry_count - 1;
    if (retry_count > 0) {
      goto irq_retry;
    } else {

    }
  } else {

  }
  spin_unlock(& hsotg->lock);
  return (1);
}
}
static int s3c_hsotg_ep_enable(struct usb_ep *ep , struct usb_endpoint_descriptor  const  *desc ) 
{ 
  struct s3c_hsotg_ep *hs_ep ;
  struct s3c_hsotg_ep *tmp ;
  struct dwc2_hsotg *hsotg ;
  unsigned long flags ;
  unsigned int index ;
  u32 epctrl_reg ;
  u32 epctrl ;
  u32 mps ;
  unsigned int dir_in ;
  unsigned int i ;
  unsigned int val ;
  unsigned int size ;
  int ret ;
  struct _ddebug descriptor ;
  long tmp___0 ;
  int __ret_warn_on ;
  long tmp___1 ;
  int tmp___2 ;
  struct _ddebug descriptor___0 ;
  long tmp___3 ;
  raw_spinlock_t *tmp___4 ;
  u32 fifo_index ;
  u32 fifo_size ;
  struct _ddebug descriptor___1 ;
  long tmp___5 ;
  struct _ddebug descriptor___2 ;
  unsigned int tmp___6 ;
  long tmp___7 ;

  {
  tmp = our_ep(ep);
  hs_ep = tmp;
  hsotg = hs_ep->parent;
  index = (unsigned int )hs_ep->index;
  ret = 0;
  descriptor.modname = "dwc2";
  descriptor.function = "s3c_hsotg_ep_enable";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/gadget.c";
  descriptor.format = "%s: ep %s: a 0x%02x, attr 0x%02x, mps 0x%04x, intr %d\n";
  descriptor.lineno = 2621U;
  descriptor.flags = 1U;
  tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp___0 != 0L) {
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "%s: ep %s: a 0x%02x, attr 0x%02x, mps 0x%04x, intr %d\n",
                      "s3c_hsotg_ep_enable", ep->name, (int )desc->bEndpointAddress,
                      (int )desc->bmAttributes, (int )desc->wMaxPacketSize, (int )desc->bInterval);
  } else {

  }
  __ret_warn_on = index == 0U;
  tmp___1 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp___1 != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/gadget.c",
                       2624);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  dir_in = (int )((signed char )desc->bEndpointAddress) < 0;
  if ((unsigned int )hs_ep->dir_in != dir_in) {
    dev_err((struct device  const  *)hsotg->dev, "%s: direction mismatch!\n", "s3c_hsotg_ep_enable");
    return (-22);
  } else {

  }
  tmp___2 = usb_endpoint_maxp(desc);
  mps = (u32 )tmp___2;
  epctrl_reg = dir_in != 0U ? (index + 72U) * 32U : (index + 88U) * 32U;
  epctrl = readl((void const volatile   *)hsotg->regs + (unsigned long )epctrl_reg);
  descriptor___0.modname = "dwc2";
  descriptor___0.function = "s3c_hsotg_ep_enable";
  descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/gadget.c";
  descriptor___0.format = "%s: read DxEPCTL=0x%08x from 0x%08x\n";
  descriptor___0.lineno = 2640U;
  descriptor___0.flags = 1U;
  tmp___3 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
  if (tmp___3 != 0L) {
    __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)hsotg->dev, "%s: read DxEPCTL=0x%08x from 0x%08x\n",
                      "s3c_hsotg_ep_enable", epctrl, epctrl_reg);
  } else {

  }
  tmp___4 = spinlock_check(& hsotg->lock);
  flags = _raw_spin_lock_irqsave(tmp___4);
  epctrl = epctrl & 4294178816U;
  epctrl = epctrl | mps;
  epctrl = epctrl | 32768U;
  epctrl = epctrl | 134217728U;
  s3c_hsotg_set_ep_maxpacket(hsotg, (unsigned int )hs_ep->index, mps, dir_in);
  hs_ep->isochronous = 0U;
  hs_ep->periodic = 0U;
  hs_ep->halted = 0U;
  hs_ep->interval = desc->bInterval;
  if ((unsigned int )hs_ep->interval > 1U && (unsigned int )hs_ep->mc > 1U) {
    dev_err((struct device  const  *)hsotg->dev, "MC > 1 when interval is not 1\n");
  } else {

  }
  switch ((int )desc->bmAttributes & 3) {
  case 1: 
  epctrl = epctrl | 262144U;
  epctrl = epctrl | 268435456U;
  hs_ep->isochronous = 1U;
  if (dir_in != 0U) {
    hs_ep->periodic = 1U;
  } else {

  }
  goto ldv_34986;
  case 2: 
  epctrl = epctrl | 524288U;
  goto ldv_34986;
  case 3: ;
  if (dir_in != 0U) {
    hs_ep->periodic = 1U;
  } else {

  }
  epctrl = epctrl | 786432U;
  goto ldv_34986;
  case 0: 
  epctrl = epctrl;
  goto ldv_34986;
  }
  ldv_34986: ;
  if ((unsigned int )hs_ep->fifo_index != 0U) {
    size = (unsigned int )((int )hs_ep->ep.maxpacket * (int )hs_ep->mc);
    if ((unsigned int )hs_ep->fifo_size < size) {
      hsotg->fifo_map = hsotg->fifo_map & (u32 )(~ (1 << (int )hs_ep->fifo_index));
      hs_ep->fifo_index = 0U;
      hs_ep->fifo_size = 0U;
    } else {

    }
  } else {

  }
  if ((dir_in != 0U && (unsigned int )*((unsigned char *)hsotg + 1608UL) != 0U) && (unsigned int )hs_ep->fifo_index == 0U) {
    fifo_index = 0U;
    fifo_size = 4294967295U;
    size = (unsigned int )((int )hs_ep->ep.maxpacket * (int )hs_ep->mc);
    i = 1U;
    goto ldv_34994;
    ldv_34993: ;
    if ((hsotg->fifo_map & (u32 )(1 << (int )i)) != 0U) {
      goto ldv_34992;
    } else {

    }
    val = readl((void const volatile   *)hsotg->regs + (unsigned long )((i + 64U) * 4U));
    val = (val >> 16) * 4U;
    if (val < size) {
      goto ldv_34992;
    } else {

    }
    if (val < fifo_size) {
      fifo_size = val;
      fifo_index = i;
    } else {

    }
    ldv_34992: 
    i = i + 1U;
    ldv_34994: ;
    if ((unsigned int )hsotg->num_of_eps > i) {
      goto ldv_34993;
    } else {

    }

    if (fifo_index == 0U) {
      dev_err((struct device  const  *)hsotg->dev, "%s: No suitable fifo found\n",
              "s3c_hsotg_ep_enable");
      ret = -12;
      goto error;
    } else {

    }
    hsotg->fifo_map = hsotg->fifo_map | (u32 )(1 << (int )fifo_index);
    epctrl = (fifo_index << 22) | epctrl;
    hs_ep->fifo_index = (unsigned short )fifo_index;
    hs_ep->fifo_size = (unsigned short )fifo_size;
  } else {

  }
  if (index != 0U) {
    epctrl = epctrl | 268435456U;
  } else {

  }
  descriptor___1.modname = "dwc2";
  descriptor___1.function = "s3c_hsotg_ep_enable";
  descriptor___1.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/gadget.c";
  descriptor___1.format = "%s: write DxEPCTL=0x%08x\n";
  descriptor___1.lineno = 2748U;
  descriptor___1.flags = 1U;
  tmp___5 = ldv__builtin_expect((long )descriptor___1.flags & 1L, 0L);
  if (tmp___5 != 0L) {
    __dynamic_dev_dbg(& descriptor___1, (struct device  const  *)hsotg->dev, "%s: write DxEPCTL=0x%08x\n",
                      "s3c_hsotg_ep_enable", epctrl);
  } else {

  }
  writel(epctrl, (void volatile   *)hsotg->regs + (unsigned long )epctrl_reg);
  descriptor___2.modname = "dwc2";
  descriptor___2.function = "s3c_hsotg_ep_enable";
  descriptor___2.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/gadget.c";
  descriptor___2.format = "%s: read DxEPCTL=0x%08x\n";
  descriptor___2.lineno = 2752U;
  descriptor___2.flags = 1U;
  tmp___7 = ldv__builtin_expect((long )descriptor___2.flags & 1L, 0L);
  if (tmp___7 != 0L) {
    tmp___6 = readl((void const volatile   *)hsotg->regs + (unsigned long )epctrl_reg);
    __dynamic_dev_dbg(& descriptor___2, (struct device  const  *)hsotg->dev, "%s: read DxEPCTL=0x%08x\n",
                      "s3c_hsotg_ep_enable", tmp___6);
  } else {

  }
  s3c_hsotg_ctrl_epint(hsotg, index, dir_in, 1U);
  error: 
  spin_unlock_irqrestore(& hsotg->lock, flags);
  return (ret);
}
}
static int s3c_hsotg_ep_disable(struct usb_ep *ep ) 
{ 
  struct s3c_hsotg_ep *hs_ep ;
  struct s3c_hsotg_ep *tmp ;
  struct dwc2_hsotg *hsotg ;
  int dir_in ;
  int index ;
  unsigned long flags ;
  u32 epctrl_reg ;
  u32 ctrl ;
  struct _ddebug descriptor ;
  long tmp___0 ;
  raw_spinlock_t *tmp___1 ;
  struct _ddebug descriptor___0 ;
  long tmp___2 ;

  {
  tmp = our_ep(ep);
  hs_ep = tmp;
  hsotg = hs_ep->parent;
  dir_in = (int )hs_ep->dir_in;
  index = (int )hs_ep->index;
  descriptor.modname = "dwc2";
  descriptor.function = "s3c_hsotg_ep_disable";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/gadget.c";
  descriptor.format = "%s(ep %p)\n";
  descriptor.lineno = 2776U;
  descriptor.flags = 1U;
  tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp___0 != 0L) {
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "%s(ep %p)\n",
                      "s3c_hsotg_ep_disable", ep);
  } else {

  }
  if ((unsigned long )(& (hsotg->eps_out[0])->ep) == (unsigned long )ep) {
    dev_err((struct device  const  *)hsotg->dev, "%s: called for ep0\n", "s3c_hsotg_ep_disable");
    return (-22);
  } else {

  }
  epctrl_reg = (u32 )(dir_in != 0 ? (index + 72) * 32 : (index + 88) * 32);
  tmp___1 = spinlock_check(& hsotg->lock);
  flags = _raw_spin_lock_irqsave(tmp___1);
  hsotg->fifo_map = hsotg->fifo_map & (u32 )(~ (1 << (int )hs_ep->fifo_index));
  hs_ep->fifo_index = 0U;
  hs_ep->fifo_size = 0U;
  ctrl = readl((void const volatile   *)hsotg->regs + (unsigned long )epctrl_reg);
  ctrl = ctrl & 2147483647U;
  ctrl = ctrl & 4294934527U;
  ctrl = ctrl | 134217728U;
  descriptor___0.modname = "dwc2";
  descriptor___0.function = "s3c_hsotg_ep_disable";
  descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/gadget.c";
  descriptor___0.format = "%s: DxEPCTL=0x%08x\n";
  descriptor___0.lineno = 2796U;
  descriptor___0.flags = 1U;
  tmp___2 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
  if (tmp___2 != 0L) {
    __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)hsotg->dev, "%s: DxEPCTL=0x%08x\n",
                      "s3c_hsotg_ep_disable", ctrl);
  } else {

  }
  writel(ctrl, (void volatile   *)hsotg->regs + (unsigned long )epctrl_reg);
  s3c_hsotg_ctrl_epint(hsotg, (unsigned int )hs_ep->index, (unsigned int )hs_ep->dir_in,
                       0U);
  kill_all_requests(hsotg, hs_ep, -108);
  spin_unlock_irqrestore(& hsotg->lock, flags);
  return (0);
}
}
static bool on_list(struct s3c_hsotg_ep *ep , struct s3c_hsotg_req *test ) 
{ 
  struct s3c_hsotg_req *req ;
  struct s3c_hsotg_req *treq ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;

  {
  __mptr = (struct list_head  const  *)ep->queue.next;
  req = (struct s3c_hsotg_req *)__mptr + 0xffffffffffffffa8UL;
  __mptr___0 = (struct list_head  const  *)req->queue.next;
  treq = (struct s3c_hsotg_req *)__mptr___0 + 0xffffffffffffffa8UL;
  goto ldv_35028;
  ldv_35027: ;
  if ((unsigned long )req == (unsigned long )test) {
    return (1);
  } else {

  }
  req = treq;
  __mptr___1 = (struct list_head  const  *)treq->queue.next;
  treq = (struct s3c_hsotg_req *)__mptr___1 + 0xffffffffffffffa8UL;
  ldv_35028: ;
  if ((unsigned long )(& req->queue) != (unsigned long )(& ep->queue)) {
    goto ldv_35027;
  } else {

  }

  return (0);
}
}
static int s3c_hsotg_ep_dequeue(struct usb_ep *ep , struct usb_request *req ) 
{ 
  struct s3c_hsotg_req *hs_req ;
  struct s3c_hsotg_req *tmp ;
  struct s3c_hsotg_ep *hs_ep ;
  struct s3c_hsotg_ep *tmp___0 ;
  struct dwc2_hsotg *hs ;
  unsigned long flags ;
  struct _ddebug descriptor ;
  long tmp___1 ;
  raw_spinlock_t *tmp___2 ;
  bool tmp___3 ;
  int tmp___4 ;

  {
  tmp = our_req(req);
  hs_req = tmp;
  tmp___0 = our_ep(ep);
  hs_ep = tmp___0;
  hs = hs_ep->parent;
  descriptor.modname = "dwc2";
  descriptor.function = "s3c_hsotg_ep_dequeue";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/gadget.c";
  descriptor.format = "ep_dequeue(%p,%p)\n";
  descriptor.lineno = 2838U;
  descriptor.flags = 1U;
  tmp___1 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp___1 != 0L) {
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)hs->dev, "ep_dequeue(%p,%p)\n",
                      ep, req);
  } else {

  }
  tmp___2 = spinlock_check(& hs->lock);
  flags = _raw_spin_lock_irqsave(tmp___2);
  tmp___3 = on_list(hs_ep, hs_req);
  if (tmp___3) {
    tmp___4 = 0;
  } else {
    tmp___4 = 1;
  }
  if (tmp___4) {
    spin_unlock_irqrestore(& hs->lock, flags);
    return (-22);
  } else {

  }
  s3c_hsotg_complete_request(hs, hs_ep, hs_req, -104);
  spin_unlock_irqrestore(& hs->lock, flags);
  return (0);
}
}
static int s3c_hsotg_ep_sethalt(struct usb_ep *ep , int value ) 
{ 
  struct s3c_hsotg_ep *hs_ep ;
  struct s3c_hsotg_ep *tmp ;
  struct dwc2_hsotg *hs ;
  int index ;
  u32 epreg ;
  u32 epctl ;
  u32 xfertype ;

  {
  tmp = our_ep(ep);
  hs_ep = tmp;
  hs = hs_ep->parent;
  index = (int )hs_ep->index;
  _dev_info((struct device  const  *)hs->dev, "%s(ep %p %s, %d)\n", "s3c_hsotg_ep_sethalt",
            ep, ep->name, value);
  if (index == 0) {
    if (value != 0) {
      s3c_hsotg_stall_ep0(hs);
    } else {
      dev_warn((struct device  const  *)hs->dev, "%s: can\'t clear halt on ep0\n",
               "s3c_hsotg_ep_sethalt");
    }
    return (0);
  } else {

  }
  if ((unsigned int )hs_ep->dir_in != 0U) {
    epreg = (u32 )((index + 72) * 32);
    epctl = readl((void const volatile   *)hs->regs + (unsigned long )epreg);
    if (value != 0) {
      epctl = epctl | 136314880U;
      if ((int )epctl < 0) {
        epctl = epctl | 1073741824U;
      } else {

      }
    } else {
      epctl = epctl & 4292870143U;
      xfertype = epctl & 786432U;
      if (xfertype == 524288U || xfertype == 786432U) {
        epctl = epctl | 268435456U;
      } else {

      }
    }
    writel(epctl, (void volatile   *)hs->regs + (unsigned long )epreg);
  } else {
    epreg = (u32 )((index + 88) * 32);
    epctl = readl((void const volatile   *)hs->regs + (unsigned long )epreg);
    if (value != 0) {
      epctl = epctl | 2097152U;
    } else {
      epctl = epctl & 4292870143U;
      xfertype = epctl & 786432U;
      if (xfertype == 524288U || xfertype == 786432U) {
        epctl = epctl | 268435456U;
      } else {

      }
    }
    writel(epctl, (void volatile   *)hs->regs + (unsigned long )epreg);
  }
  hs_ep->halted = (unsigned char )value;
  return (0);
}
}
static int s3c_hsotg_ep_sethalt_lock(struct usb_ep *ep , int value ) 
{ 
  struct s3c_hsotg_ep *hs_ep ;
  struct s3c_hsotg_ep *tmp ;
  struct dwc2_hsotg *hs ;
  unsigned long flags ;
  int ret ;
  raw_spinlock_t *tmp___0 ;

  {
  tmp = our_ep(ep);
  hs_ep = tmp;
  hs = hs_ep->parent;
  flags = 0UL;
  ret = 0;
  tmp___0 = spinlock_check(& hs->lock);
  flags = _raw_spin_lock_irqsave(tmp___0);
  ret = s3c_hsotg_ep_sethalt(ep, value);
  spin_unlock_irqrestore(& hs->lock, flags);
  return (ret);
}
}
static struct usb_ep_ops s3c_hsotg_ep_ops  = 
     {& s3c_hsotg_ep_enable, & s3c_hsotg_ep_disable, & s3c_hsotg_ep_alloc_request, & s3c_hsotg_ep_free_request,
    & s3c_hsotg_ep_queue_lock, & s3c_hsotg_ep_dequeue, & s3c_hsotg_ep_sethalt_lock,
    0, 0, 0};
static void s3c_hsotg_phy_enable(struct dwc2_hsotg *hsotg ) 
{ 
  struct platform_device *pdev ;
  struct device  const  *__mptr ;
  struct _ddebug descriptor ;
  long tmp ;

  {
  __mptr = (struct device  const  *)hsotg->dev;
  pdev = (struct platform_device *)__mptr + 0xfffffffffffffff0UL;
  descriptor.modname = "dwc2";
  descriptor.function = "s3c_hsotg_phy_enable";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/gadget.c";
  descriptor.format = "pdev 0x%p\n";
  descriptor.lineno = 2957U;
  descriptor.flags = 1U;
  tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp != 0L) {
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "pdev 0x%p\n",
                      pdev);
  } else {

  }
  if ((unsigned long )hsotg->uphy != (unsigned long )((struct usb_phy *)0)) {
    usb_phy_init(hsotg->uphy);
  } else
  if ((unsigned long )hsotg->plat != (unsigned long )((struct s3c_hsotg_plat *)0) && (unsigned long )(hsotg->plat)->phy_init != (unsigned long )((int (*)(struct platform_device * ,
                                                                                                                                                          int  ))0)) {
    (*((hsotg->plat)->phy_init))(pdev, (hsotg->plat)->phy_type);
  } else {
    phy_init(hsotg->phy);
    phy_power_on(hsotg->phy);
  }
  return;
}
}
static void s3c_hsotg_phy_disable(struct dwc2_hsotg *hsotg ) 
{ 
  struct platform_device *pdev ;
  struct device  const  *__mptr ;

  {
  __mptr = (struct device  const  *)hsotg->dev;
  pdev = (struct platform_device *)__mptr + 0xfffffffffffffff0UL;
  if ((unsigned long )hsotg->uphy != (unsigned long )((struct usb_phy *)0)) {
    usb_phy_shutdown(hsotg->uphy);
  } else
  if ((unsigned long )hsotg->plat != (unsigned long )((struct s3c_hsotg_plat *)0) && (unsigned long )(hsotg->plat)->phy_exit != (unsigned long )((int (*)(struct platform_device * ,
                                                                                                                                                          int  ))0)) {
    (*((hsotg->plat)->phy_exit))(pdev, (hsotg->plat)->phy_type);
  } else {
    phy_power_off(hsotg->phy);
    phy_exit(hsotg->phy);
  }
  return;
}
}
static void s3c_hsotg_init(struct dwc2_hsotg *hsotg ) 
{ 
  u32 trdtim ;
  struct _ddebug descriptor ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  long tmp___1 ;
  bool tmp___2 ;

  {
  writel(15U, (void volatile   *)hsotg->regs + 2064U);
  writel(15U, (void volatile   *)hsotg->regs + 2068U);
  writel(0U, (void volatile   *)hsotg->regs + 2076U);
  __orr32(hsotg->regs + 2052UL, 2U);
  descriptor.modname = "dwc2";
  descriptor.function = "s3c_hsotg_init";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/gadget.c";
  descriptor.format = "GRXFSIZ=0x%08x, GNPTXFSIZ=0x%08x\n";
  descriptor.lineno = 3016U;
  descriptor.flags = 1U;
  tmp___1 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp___1 != 0L) {
    tmp = readl((void const volatile   *)hsotg->regs + 40U);
    tmp___0 = readl((void const volatile   *)hsotg->regs + 36U);
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "GRXFSIZ=0x%08x, GNPTXFSIZ=0x%08x\n",
                      tmp___0, tmp);
  } else {

  }
  s3c_hsotg_init_fifo(hsotg);
  trdtim = hsotg->phyif == 0U ? 9U : 5U;
  writel((hsotg->phyif | (trdtim << 10)) | 7U, (void volatile   *)hsotg->regs + 12U);
  tmp___2 = using_dma(hsotg);
  if ((int )tmp___2) {
    __orr32(hsotg->regs + 8UL, 32U);
  } else {

  }
  return;
}
}
static int s3c_hsotg_udc_start(struct usb_gadget *gadget , struct usb_gadget_driver *driver ) 
{ 
  struct dwc2_hsotg *hsotg ;
  struct dwc2_hsotg *tmp ;
  unsigned long flags ;
  int ret ;
  int __ret_warn_on ;
  long tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;
  raw_spinlock_t *tmp___3 ;

  {
  tmp = to_hsotg(gadget);
  hsotg = tmp;
  if ((unsigned long )hsotg == (unsigned long )((struct dwc2_hsotg *)0)) {
    printk("\v%s: called with no device\n", "s3c_hsotg_udc_start");
    return (-19);
  } else {

  }
  if ((unsigned long )driver == (unsigned long )((struct usb_gadget_driver *)0)) {
    dev_err((struct device  const  *)hsotg->dev, "%s: no driver\n", "s3c_hsotg_udc_start");
    return (-22);
  } else {

  }
  if ((unsigned int )driver->max_speed <= 1U) {
    dev_err((struct device  const  *)hsotg->dev, "%s: bad speed\n", "s3c_hsotg_udc_start");
  } else {

  }
  if ((unsigned long )driver->setup == (unsigned long )((int (*)(struct usb_gadget * ,
                                                                 struct usb_ctrlrequest  const  * ))0)) {
    dev_err((struct device  const  *)hsotg->dev, "%s: missing entry points\n", "s3c_hsotg_udc_start");
    return (-22);
  } else {

  }
  mutex_lock_nested(& hsotg->init_mutex, 0U);
  __ret_warn_on = (unsigned long )hsotg->driver != (unsigned long )((struct usb_gadget_driver *)0);
  tmp___0 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp___0 != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/gadget.c",
                       3064);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  driver->driver.bus = (struct bus_type *)0;
  hsotg->driver = driver;
  hsotg->gadget.dev.of_node = (hsotg->dev)->of_node;
  hsotg->gadget.speed = 0;
  clk_enable(hsotg->clk);
  ret = regulator_bulk_enable(2, (struct regulator_bulk_data *)(& hsotg->supplies));
  if (ret != 0) {
    dev_err((struct device  const  *)hsotg->dev, "failed to enable supplies: %d\n",
            ret);
    goto err;
  } else {

  }
  s3c_hsotg_phy_enable(hsotg);
  tmp___1 = IS_ERR_OR_NULL((void const   *)hsotg->uphy);
  if (tmp___1) {
    tmp___2 = 0;
  } else {
    tmp___2 = 1;
  }
  if (tmp___2) {
    otg_set_peripheral((hsotg->uphy)->otg, & hsotg->gadget);
  } else {

  }
  tmp___3 = spinlock_check(& hsotg->lock);
  flags = _raw_spin_lock_irqsave(tmp___3);
  s3c_hsotg_init(hsotg);
  s3c_hsotg_core_init_disconnected(hsotg, 0);
  hsotg->enabled = 0U;
  spin_unlock_irqrestore(& hsotg->lock, flags);
  _dev_info((struct device  const  *)hsotg->dev, "bound driver %s\n", driver->driver.name);
  mutex_unlock(& hsotg->init_mutex);
  return (0);
  err: 
  mutex_unlock(& hsotg->init_mutex);
  hsotg->driver = (struct usb_gadget_driver *)0;
  return (ret);
}
}
static int s3c_hsotg_udc_stop(struct usb_gadget *gadget ) 
{ 
  struct dwc2_hsotg *hsotg ;
  struct dwc2_hsotg *tmp ;
  unsigned long flags ;
  int ep ;
  raw_spinlock_t *tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;

  {
  tmp = to_hsotg(gadget);
  hsotg = tmp;
  flags = 0UL;
  if ((unsigned long )hsotg == (unsigned long )((struct dwc2_hsotg *)0)) {
    return (-19);
  } else {

  }
  mutex_lock_nested(& hsotg->init_mutex, 0U);
  ep = 1;
  goto ldv_35109;
  ldv_35108: ;
  if ((unsigned long )hsotg->eps_in[ep] != (unsigned long )((struct s3c_hsotg_ep *)0)) {
    s3c_hsotg_ep_disable(& (hsotg->eps_in[ep])->ep);
  } else {

  }
  if ((unsigned long )hsotg->eps_out[ep] != (unsigned long )((struct s3c_hsotg_ep *)0)) {
    s3c_hsotg_ep_disable(& (hsotg->eps_out[ep])->ep);
  } else {

  }
  ep = ep + 1;
  ldv_35109: ;
  if ((int )hsotg->num_of_eps > ep) {
    goto ldv_35108;
  } else {

  }
  tmp___0 = spinlock_check(& hsotg->lock);
  flags = _raw_spin_lock_irqsave(tmp___0);
  hsotg->driver = (struct usb_gadget_driver *)0;
  hsotg->gadget.speed = 0;
  hsotg->enabled = 0U;
  spin_unlock_irqrestore(& hsotg->lock, flags);
  tmp___1 = IS_ERR_OR_NULL((void const   *)hsotg->uphy);
  if (tmp___1) {
    tmp___2 = 0;
  } else {
    tmp___2 = 1;
  }
  if (tmp___2) {
    otg_set_peripheral((hsotg->uphy)->otg, (struct usb_gadget *)0);
  } else {

  }
  s3c_hsotg_phy_disable(hsotg);
  regulator_bulk_disable(2, (struct regulator_bulk_data *)(& hsotg->supplies));
  clk_disable(hsotg->clk);
  mutex_unlock(& hsotg->init_mutex);
  return (0);
}
}
static int s3c_hsotg_gadget_getframe(struct usb_gadget *gadget ) 
{ 
  struct dwc2_hsotg *tmp ;
  u32 tmp___0 ;

  {
  tmp = to_hsotg(gadget);
  tmp___0 = s3c_hsotg_read_frameno(tmp);
  return ((int )tmp___0);
}
}
static int s3c_hsotg_pullup(struct usb_gadget *gadget , int is_on ) 
{ 
  struct dwc2_hsotg *hsotg ;
  struct dwc2_hsotg *tmp ;
  unsigned long flags ;
  struct _ddebug descriptor ;
  long tmp___0 ;
  raw_spinlock_t *tmp___1 ;

  {
  tmp = to_hsotg(gadget);
  hsotg = tmp;
  flags = 0UL;
  descriptor.modname = "dwc2";
  descriptor.function = "s3c_hsotg_pullup";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/gadget.c";
  descriptor.format = "%s: is_on: %d\n";
  descriptor.lineno = 3172U;
  descriptor.flags = 1U;
  tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp___0 != 0L) {
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "%s: is_on: %d\n",
                      "s3c_hsotg_pullup", is_on);
  } else {

  }
  mutex_lock_nested(& hsotg->init_mutex, 0U);
  tmp___1 = spinlock_check(& hsotg->lock);
  flags = _raw_spin_lock_irqsave(tmp___1);
  if (is_on != 0) {
    clk_enable(hsotg->clk);
    hsotg->enabled = 1U;
    s3c_hsotg_core_init_disconnected(hsotg, 0);
    s3c_hsotg_core_connect(hsotg);
  } else {
    s3c_hsotg_core_disconnect(hsotg);
    s3c_hsotg_disconnect(hsotg);
    hsotg->enabled = 0U;
    clk_disable(hsotg->clk);
  }
  hsotg->gadget.speed = 0;
  spin_unlock_irqrestore(& hsotg->lock, flags);
  mutex_unlock(& hsotg->init_mutex);
  return (0);
}
}
static int s3c_hsotg_vbus_session(struct usb_gadget *gadget , int is_active ) 
{ 
  struct dwc2_hsotg *hsotg ;
  struct dwc2_hsotg *tmp ;
  unsigned long flags ;
  struct _ddebug descriptor ;
  long tmp___0 ;
  raw_spinlock_t *tmp___1 ;

  {
  tmp = to_hsotg(gadget);
  hsotg = tmp;
  descriptor.modname = "dwc2";
  descriptor.function = "s3c_hsotg_vbus_session";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/gadget.c";
  descriptor.format = "%s: is_active: %d\n";
  descriptor.lineno = 3200U;
  descriptor.flags = 1U;
  tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp___0 != 0L) {
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)hsotg->dev, "%s: is_active: %d\n",
                      "s3c_hsotg_vbus_session", is_active);
  } else {

  }
  tmp___1 = spinlock_check(& hsotg->lock);
  flags = _raw_spin_lock_irqsave(tmp___1);
  if (is_active != 0) {
    if ((unsigned int )hsotg->lx_state == 2U) {
      dwc2_exit_hibernation(hsotg, 0);
      hsotg->lx_state = 0;
    } else {

    }
    kill_all_requests(hsotg, hsotg->eps_out[0], -104);
    s3c_hsotg_core_init_disconnected(hsotg, 0);
    if ((unsigned int )*((unsigned char *)hsotg + 3232UL) != 0U) {
      s3c_hsotg_core_connect(hsotg);
    } else {

    }
  } else {
    s3c_hsotg_core_disconnect(hsotg);
    s3c_hsotg_disconnect(hsotg);
  }
  spin_unlock_irqrestore(& hsotg->lock, flags);
  return (0);
}
}
static int s3c_hsotg_vbus_draw(struct usb_gadget *gadget , unsigned int mA ) 
{ 
  struct dwc2_hsotg *hsotg ;
  struct dwc2_hsotg *tmp ;
  bool tmp___0 ;
  int tmp___1 ;

  {
  tmp = to_hsotg(gadget);
  hsotg = tmp;
  tmp___0 = IS_ERR_OR_NULL((void const   *)hsotg->uphy);
  if ((int )tmp___0) {
    return (-524);
  } else {

  }
  tmp___1 = usb_phy_set_power(hsotg->uphy, mA);
  return (tmp___1);
}
}
static struct usb_gadget_ops  const  s3c_hsotg_gadget_ops  = 
     {& s3c_hsotg_gadget_getframe, 0, 0, & s3c_hsotg_vbus_session, & s3c_hsotg_vbus_draw,
    & s3c_hsotg_pullup, 0, 0, & s3c_hsotg_udc_start, & s3c_hsotg_udc_stop};
static void s3c_hsotg_initep(struct dwc2_hsotg *hsotg , struct s3c_hsotg_ep *hs_ep ,
                             int epnum , bool dir_in ) 
{ 
  char *dir ;
  u32 next ;
  bool tmp ;

  {
  if (epnum == 0) {
    dir = (char *)"";
  } else
  if ((int )dir_in) {
    dir = (char *)"in";
  } else {
    dir = (char *)"out";
  }
  hs_ep->dir_in = (unsigned char )dir_in;
  hs_ep->index = (unsigned char )epnum;
  snprintf((char *)(& hs_ep->name), 10UL, "ep%d%s", epnum, dir);
  INIT_LIST_HEAD(& hs_ep->queue);
  INIT_LIST_HEAD(& hs_ep->ep.ep_list);
  if (epnum != 0) {
    list_add_tail(& hs_ep->ep.ep_list, & hsotg->gadget.ep_list);
  } else {

  }
  hs_ep->parent = hsotg;
  hs_ep->ep.name = (char const   *)(& hs_ep->name);
  usb_ep_set_maxpacket_limit(& hs_ep->ep, epnum != 0 ? 1024U : 64U);
  hs_ep->ep.ops = (struct usb_ep_ops  const  *)(& s3c_hsotg_ep_ops);
  tmp = using_dma(hsotg);
  if ((int )tmp) {
    next = (u32 )((epnum + 1) % 15 << 11);
    if ((int )dir_in) {
      writel(next, (void volatile   *)hsotg->regs + (unsigned long )((epnum + 72) * 32));
    } else {
      writel(next, (void volatile   *)hsotg->regs + (unsigned long )((epnum + 88) * 32));
    }
  } else {

  }
  return;
}
}
static int s3c_hsotg_hw_cfg(struct dwc2_hsotg *hsotg ) 
{ 
  u32 cfg ;
  u32 ep_type ;
  u32 i ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  cfg = readl((void const volatile   *)hsotg->regs + 72U);
  hsotg->num_of_eps = (unsigned int )((unsigned char )(cfg >> 10)) & 15U;
  hsotg->num_of_eps = (unsigned char )((int )hsotg->num_of_eps + 1);
  tmp = devm_kzalloc(hsotg->dev, 144UL, 208U);
  hsotg->eps_in[0] = (struct s3c_hsotg_ep *)tmp;
  if ((unsigned long )hsotg->eps_in[0] == (unsigned long )((struct s3c_hsotg_ep *)0)) {
    return (-12);
  } else {

  }
  hsotg->eps_out[0] = hsotg->eps_in[0];
  cfg = readl((void const volatile   *)hsotg->regs + 68U);
  i = 1U;
  cfg = cfg >> 2;
  goto ldv_35162;
  ldv_35161: 
  ep_type = cfg & 3U;
  if ((ep_type & 2U) == 0U) {
    tmp___0 = devm_kzalloc(hsotg->dev, 144UL, 208U);
    hsotg->eps_in[i] = (struct s3c_hsotg_ep *)tmp___0;
    if ((unsigned long )hsotg->eps_in[i] == (unsigned long )((struct s3c_hsotg_ep *)0)) {
      return (-12);
    } else {

    }
  } else {

  }
  if ((ep_type & 1U) == 0U) {
    tmp___1 = devm_kzalloc(hsotg->dev, 144UL, 208U);
    hsotg->eps_out[i] = (struct s3c_hsotg_ep *)tmp___1;
    if ((unsigned long )hsotg->eps_out[i] == (unsigned long )((struct s3c_hsotg_ep *)0)) {
      return (-12);
    } else {

    }
  } else {

  }
  i = i + 1U;
  cfg = cfg >> 2;
  ldv_35162: ;
  if ((u32 )hsotg->num_of_eps > i) {
    goto ldv_35161;
  } else {

  }
  cfg = readl((void const volatile   *)hsotg->regs + 76U);
  hsotg->fifo_mem = (int )(cfg >> 16);
  cfg = readl((void const volatile   *)hsotg->regs + 80U);
  hsotg->dedicated_fifos = (unsigned int )((unsigned char )(cfg >> 25)) & 1U;
  _dev_info((struct device  const  *)hsotg->dev, "EPs: %d, %s fifos, %d entries in SPRAM\n",
            (int )hsotg->num_of_eps, (unsigned int )*((unsigned char *)hsotg + 1608UL) != 0U ? (char *)"dedicated" : (char *)"shared",
            hsotg->fifo_mem);
  return (0);
}
}
static void s3c_hsotg_dump(struct dwc2_hsotg *hsotg ) 
{ 
  struct device *dev ;
  void *regs ;
  u32 val ;
  int idx ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;
  unsigned int tmp___4 ;
  unsigned int tmp___5 ;
  unsigned int tmp___6 ;
  unsigned int tmp___7 ;
  unsigned int tmp___8 ;
  unsigned int tmp___9 ;
  unsigned int tmp___10 ;
  unsigned int tmp___11 ;
  unsigned int tmp___12 ;
  unsigned int tmp___13 ;

  {
  dev = hsotg->dev;
  regs = hsotg->regs;
  tmp = readl((void const volatile   *)regs + 2064U);
  tmp___0 = readl((void const volatile   *)regs + 2052U);
  tmp___1 = readl((void const volatile   *)regs + 2048U);
  _dev_info((struct device  const  *)dev, "DCFG=0x%08x, DCTL=0x%08x, DIEPMSK=%08x\n",
            tmp___1, tmp___0, tmp);
  tmp___2 = readl((void const volatile   *)regs + 68U);
  tmp___3 = readl((void const volatile   *)regs + 8U);
  _dev_info((struct device  const  *)dev, "GAHBCFG=0x%08x, GHWCFG1=0x%08x\n", tmp___3,
            tmp___2);
  tmp___4 = readl((void const volatile   *)regs + 40U);
  tmp___5 = readl((void const volatile   *)regs + 36U);
  _dev_info((struct device  const  *)dev, "GRXFSIZ=0x%08x, GNPTXFSIZ=0x%08x\n", tmp___5,
            tmp___4);
  idx = 1;
  goto ldv_35172;
  ldv_35171: 
  val = readl((void const volatile   *)regs + (unsigned long )((idx + 64) * 4));
  _dev_info((struct device  const  *)dev, "DPTx[%d] FSize=%d, StAddr=0x%08x\n", idx,
            val >> 16, val & 65535U);
  idx = idx + 1;
  ldv_35172: ;
  if ((int )hsotg->num_of_eps > idx) {
    goto ldv_35171;
  } else {

  }
  idx = 0;
  goto ldv_35175;
  ldv_35174: 
  tmp___6 = readl((void const volatile   *)regs + (unsigned long )(idx * 32 + 2324));
  tmp___7 = readl((void const volatile   *)regs + (unsigned long )(idx * 32 + 2320));
  tmp___8 = readl((void const volatile   *)regs + (unsigned long )((idx + 72) * 32));
  _dev_info((struct device  const  *)dev, "ep%d-in: EPCTL=0x%08x, SIZ=0x%08x, DMA=0x%08x\n",
            idx, tmp___8, tmp___7, tmp___6);
  val = readl((void const volatile   *)regs + (unsigned long )((idx + 88) * 32));
  tmp___9 = readl((void const volatile   *)regs + (unsigned long )(idx * 32 + 2836));
  tmp___10 = readl((void const volatile   *)regs + (unsigned long )(idx * 32 + 2832));
  tmp___11 = readl((void const volatile   *)regs + (unsigned long )((idx + 88) * 32));
  _dev_info((struct device  const  *)dev, "ep%d-out: EPCTL=0x%08x, SIZ=0x%08x, DMA=0x%08x\n",
            idx, tmp___11, tmp___10, tmp___9);
  idx = idx + 1;
  ldv_35175: ;
  if ((int )hsotg->num_of_eps > idx) {
    goto ldv_35174;
  } else {

  }
  tmp___12 = readl((void const volatile   *)regs + 2092U);
  tmp___13 = readl((void const volatile   *)regs + 2088U);
  _dev_info((struct device  const  *)dev, "DVBUSDIS=0x%08x, DVBUSPULSE=%08x\n", tmp___13,
            tmp___12);
  return;
}
}
static void s3c_hsotg_of_probe(struct dwc2_hsotg *hsotg ) 
{ 
  struct device_node *np ;
  u32 len ;
  u32 i ;
  bool tmp ;
  struct property *tmp___0 ;
  int tmp___1 ;

  {
  np = (hsotg->dev)->of_node;
  len = 0U;
  i = 0U;
  tmp = of_property_read_bool((struct device_node  const  *)np, "g-use-dma");
  hsotg->g_using_dma = (u32 )tmp;
  tmp___0 = of_find_property((struct device_node  const  *)np, "g-tx-fifo-size", (int *)(& len));
  if ((unsigned long )tmp___0 == (unsigned long )((struct property *)0)) {
    goto rx_fifo;
  } else {

  }
  len = len / 4U;
  tmp___1 = of_property_read_u32_array((struct device_node  const  *)np, "g-tx-fifo-size",
                                       (u32 *)(& hsotg->g_tx_fifo_sz) + 1UL, (size_t )len);
  if (tmp___1 != 0) {
    goto rx_fifo;
  } else {

  }
  len = len + 1U;
  if (len <= 15U) {
    i = len;
    goto ldv_35185;
    ldv_35184: 
    hsotg->g_tx_fifo_sz[i] = 0U;
    i = i + 1U;
    ldv_35185: ;
    if (i <= 15U) {
      goto ldv_35184;
    } else {

    }

  } else {

  }
  rx_fifo: 
  of_property_read_u32((struct device_node  const  *)np, "g-rx-fifo-size", & hsotg->g_rx_fifo_sz);
  of_property_read_u32((struct device_node  const  *)np, "g-np-tx-fifo-size", & hsotg->g_np_g_tx_fifo_sz);
  return;
}
}
int dwc2_gadget_init(struct dwc2_hsotg *hsotg , int irq ) 
{ 
  struct device *dev ;
  struct s3c_hsotg_plat *plat ;
  int epnum ;
  int ret ;
  int i ;
  u32 p_tx_fifo[15U] ;
  struct _ddebug descriptor ;
  long tmp ;
  struct _ddebug descriptor___0 ;
  long tmp___0 ;
  struct _ddebug descriptor___1 ;
  long tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  bool tmp___4 ;
  bool tmp___5 ;
  struct _ddebug descriptor___2 ;
  long tmp___6 ;
  bool tmp___7 ;
  char const   *tmp___8 ;

  {
  dev = hsotg->dev;
  plat = (struct s3c_hsotg_plat *)dev->platform_data;
  p_tx_fifo[0] = 256U;
  p_tx_fifo[1] = 256U;
  p_tx_fifo[2] = 256U;
  p_tx_fifo[3] = 256U;
  p_tx_fifo[4] = 768U;
  p_tx_fifo[5] = 768U;
  p_tx_fifo[6] = 768U;
  p_tx_fifo[7] = 768U;
  p_tx_fifo[8] = 0U;
  p_tx_fifo[9] = 0U;
  p_tx_fifo[10] = 0U;
  p_tx_fifo[11] = 0U;
  p_tx_fifo[12] = 0U;
  p_tx_fifo[13] = 0U;
  p_tx_fifo[14] = 0U;
  hsotg->phyif = 8U;
  s3c_hsotg_of_probe(hsotg);
  hsotg->g_rx_fifo_sz = 2048U;
  hsotg->g_np_g_tx_fifo_sz = 1024U;
  memcpy((void *)(& hsotg->g_tx_fifo_sz) + 1U, (void const   *)(& p_tx_fifo), 60UL);
  s3c_hsotg_of_probe(hsotg);
  descriptor.modname = "dwc2";
  descriptor.function = "dwc2_gadget_init";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/gadget.c";
  descriptor.format = "NonPeriodic TXFIFO size: %d\n";
  descriptor.lineno = 3488U;
  descriptor.flags = 1U;
  tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp != 0L) {
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)dev, "NonPeriodic TXFIFO size: %d\n",
                      hsotg->g_np_g_tx_fifo_sz);
  } else {

  }
  descriptor___0.modname = "dwc2";
  descriptor___0.function = "dwc2_gadget_init";
  descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/gadget.c";
  descriptor___0.format = "RXFIFO size: %d\n";
  descriptor___0.lineno = 3489U;
  descriptor___0.flags = 1U;
  tmp___0 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
  if (tmp___0 != 0L) {
    __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)dev, "RXFIFO size: %d\n",
                      hsotg->g_rx_fifo_sz);
  } else {

  }
  i = 0;
  goto ldv_35202;
  ldv_35201: 
  descriptor___1.modname = "dwc2";
  descriptor___1.function = "dwc2_gadget_init";
  descriptor___1.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/gadget.c";
  descriptor___1.format = "Periodic TXFIFO%2d size: %d\n";
  descriptor___1.lineno = 3492U;
  descriptor___1.flags = 1U;
  tmp___1 = ldv__builtin_expect((long )descriptor___1.flags & 1L, 0L);
  if (tmp___1 != 0L) {
    __dynamic_dev_dbg(& descriptor___1, (struct device  const  *)dev, "Periodic TXFIFO%2d size: %d\n",
                      i, hsotg->g_tx_fifo_sz[i]);
  } else {

  }
  i = i + 1;
  ldv_35202: ;
  if (i <= 15) {
    goto ldv_35201;
  } else {

  }
  tmp___4 = IS_ERR_OR_NULL((void const   *)hsotg->phy);
  if ((int )tmp___4) {
    tmp___5 = IS_ERR_OR_NULL((void const   *)hsotg->uphy);
    if ((int )tmp___5) {
      tmp___2 = dev_get_platdata((struct device  const  *)dev);
      plat = (struct s3c_hsotg_plat *)tmp___2;
      if ((unsigned long )plat == (unsigned long )((struct s3c_hsotg_plat *)0)) {
        dev_err((struct device  const  *)dev, "no platform data or transceiver defined\n");
        return (-517);
      } else {

      }
      hsotg->plat = plat;
    } else {
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
  if ((unsigned long )hsotg->phy != (unsigned long )((struct phy *)0)) {
    tmp___3 = phy_get_bus_width(hsotg->phy);
    if (tmp___3 == 8) {
      hsotg->phyif = 0U;
    } else {

    }
  } else {

  }
  hsotg->clk = devm_clk_get(dev, "otg");
  tmp___7 = IS_ERR((void const   *)hsotg->clk);
  if ((int )tmp___7) {
    hsotg->clk = (struct clk *)0;
    descriptor___2.modname = "dwc2";
    descriptor___2.function = "dwc2_gadget_init";
    descriptor___2.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/9130/dscv_tempdir/dscv/ri/08_1a/drivers/usb/dwc2/gadget.c";
    descriptor___2.format = "cannot get otg clock\n";
    descriptor___2.lineno = 3517U;
    descriptor___2.flags = 1U;
    tmp___6 = ldv__builtin_expect((long )descriptor___2.flags & 1L, 0L);
    if (tmp___6 != 0L) {
      __dynamic_dev_dbg(& descriptor___2, (struct device  const  *)dev, "cannot get otg clock\n");
    } else {

    }
  } else {

  }
  hsotg->gadget.max_speed = 3;
  hsotg->gadget.ops = & s3c_hsotg_gadget_ops;
  hsotg->gadget.name = dev_name((struct device  const  *)dev);
  if ((unsigned int )hsotg->dr_mode == 3U) {
    hsotg->gadget.is_otg = 1U;
  } else {

  }
  ret = clk_prepare_enable(hsotg->clk);
  if (ret != 0) {
    dev_err((struct device  const  *)dev, "failed to enable otg clk\n");
    goto err_clk;
  } else {

  }
  i = 0;
  goto ldv_35209;
  ldv_35208: 
  hsotg->supplies[i].supply = s3c_hsotg_supply_names[i];
  i = i + 1;
  ldv_35209: ;
  if ((unsigned int )i <= 1U) {
    goto ldv_35208;
  } else {

  }
  ret = devm_regulator_bulk_get(dev, 2, (struct regulator_bulk_data *)(& hsotg->supplies));
  if (ret != 0) {
    dev_err((struct device  const  *)dev, "failed to request supplies: %d\n", ret);
    goto err_clk;
  } else {

  }
  ret = regulator_bulk_enable(2, (struct regulator_bulk_data *)(& hsotg->supplies));
  if (ret != 0) {
    dev_err((struct device  const  *)dev, "failed to enable supplies: %d\n", ret);
    goto err_clk;
  } else {

  }
  s3c_hsotg_phy_enable(hsotg);
  __bic32(hsotg->regs + 12UL, 536870912U);
  __orr32(hsotg->regs + 12UL, 1073741824U);
  msleep(25U);
  s3c_hsotg_corereset(hsotg);
  ret = s3c_hsotg_hw_cfg(hsotg);
  if (ret != 0) {
    dev_err((struct device  const  *)hsotg->dev, "Hardware configuration failed: %d\n",
            ret);
    goto err_clk;
  } else {

  }
  s3c_hsotg_init(hsotg);
  __bic32(hsotg->regs + 12UL, 1073741824U);
  hsotg->ctrl_buff = devm_kzalloc(hsotg->dev, 8UL, 208U);
  if ((unsigned long )hsotg->ctrl_buff == (unsigned long )((void *)0)) {
    dev_err((struct device  const  *)dev, "failed to allocate ctrl request buff\n");
    ret = -12;
    goto err_supplies;
  } else {

  }
  hsotg->ep0_buff = devm_kzalloc(hsotg->dev, 8UL, 208U);
  if ((unsigned long )hsotg->ep0_buff == (unsigned long )((void *)0)) {
    dev_err((struct device  const  *)dev, "failed to allocate ctrl reply buff\n");
    ret = -12;
    goto err_supplies;
  } else {

  }
  tmp___8 = dev_name((struct device  const  *)hsotg->dev);
  ret = devm_request_irq(hsotg->dev, (unsigned int )irq, & s3c_hsotg_irq, 128UL, tmp___8,
                         (void *)hsotg);
  if (ret < 0) {
    s3c_hsotg_phy_disable(hsotg);
    clk_disable_unprepare(hsotg->clk);
    regulator_bulk_disable(2, (struct regulator_bulk_data *)(& hsotg->supplies));
    dev_err((struct device  const  *)dev, "cannot claim IRQ for gadget\n");
    goto err_supplies;
  } else {

  }
  if ((unsigned int )hsotg->num_of_eps == 0U) {
    dev_err((struct device  const  *)dev, "wrong number of EPs (zero)\n");
    ret = -22;
    goto err_supplies;
  } else {

  }
  INIT_LIST_HEAD(& hsotg->gadget.ep_list);
  hsotg->gadget.ep0 = & (hsotg->eps_out[0])->ep;
  hsotg->ctrl_req = s3c_hsotg_ep_alloc_request(& (hsotg->eps_out[0])->ep, 208U);
  if ((unsigned long )hsotg->ctrl_req == (unsigned long )((struct usb_request *)0)) {
    dev_err((struct device  const  *)dev, "failed to allocate ctrl req\n");
    ret = -12;
    goto err_supplies;
  } else {

  }
  epnum = 0;
  goto ldv_35219;
  ldv_35218: ;
  if ((unsigned long )hsotg->eps_in[epnum] != (unsigned long )((struct s3c_hsotg_ep *)0)) {
    s3c_hsotg_initep(hsotg, hsotg->eps_in[epnum], epnum, 1);
  } else {

  }
  if ((unsigned long )hsotg->eps_out[epnum] != (unsigned long )((struct s3c_hsotg_ep *)0)) {
    s3c_hsotg_initep(hsotg, hsotg->eps_out[epnum], epnum, 0);
  } else {

  }
  epnum = epnum + 1;
  ldv_35219: ;
  if ((int )hsotg->num_of_eps > epnum) {
    goto ldv_35218;
  } else {

  }
  s3c_hsotg_phy_disable(hsotg);
  ret = regulator_bulk_disable(2, (struct regulator_bulk_data *)(& hsotg->supplies));
  if (ret != 0) {
    dev_err((struct device  const  *)dev, "failed to disable supplies: %d\n", ret);
    goto err_supplies;
  } else {

  }
  ret = usb_add_gadget_udc(dev, & hsotg->gadget);
  if (ret != 0) {
    goto err_supplies;
  } else {

  }
  s3c_hsotg_dump(hsotg);
  return (0);
  err_supplies: 
  s3c_hsotg_phy_disable(hsotg);
  err_clk: 
  clk_disable_unprepare(hsotg->clk);
  return (ret);
}
}
int s3c_hsotg_remove(struct dwc2_hsotg *hsotg ) 
{ 


  {
  usb_del_gadget_udc(& hsotg->gadget);
  clk_disable_unprepare(hsotg->clk);
  return (0);
}
}
int s3c_hsotg_suspend(struct dwc2_hsotg *hsotg ) 
{ 
  unsigned long flags ;
  int ret ;
  int ep ;
  raw_spinlock_t *tmp ;

  {
  ret = 0;
  if ((unsigned int )hsotg->lx_state != 0U) {
    return (ret);
  } else {

  }
  mutex_lock_nested(& hsotg->init_mutex, 0U);
  if ((unsigned long )hsotg->driver != (unsigned long )((struct usb_gadget_driver *)0)) {
    _dev_info((struct device  const  *)hsotg->dev, "suspending usb gadget %s\n", (hsotg->driver)->driver.name);
    tmp = spinlock_check(& hsotg->lock);
    flags = _raw_spin_lock_irqsave(tmp);
    if ((unsigned int )*((unsigned char *)hsotg + 3232UL) != 0U) {
      s3c_hsotg_core_disconnect(hsotg);
    } else {

    }
    s3c_hsotg_disconnect(hsotg);
    hsotg->gadget.speed = 0;
    spin_unlock_irqrestore(& hsotg->lock, flags);
    s3c_hsotg_phy_disable(hsotg);
    ep = 0;
    goto ldv_35236;
    ldv_35235: ;
    if ((unsigned long )hsotg->eps_in[ep] != (unsigned long )((struct s3c_hsotg_ep *)0)) {
      s3c_hsotg_ep_disable(& (hsotg->eps_in[ep])->ep);
    } else {

    }
    if ((unsigned long )hsotg->eps_out[ep] != (unsigned long )((struct s3c_hsotg_ep *)0)) {
      s3c_hsotg_ep_disable(& (hsotg->eps_out[ep])->ep);
    } else {

    }
    ep = ep + 1;
    ldv_35236: ;
    if ((int )hsotg->num_of_eps > ep) {
      goto ldv_35235;
    } else {

    }
    ret = regulator_bulk_disable(2, (struct regulator_bulk_data *)(& hsotg->supplies));
    clk_disable(hsotg->clk);
  } else {

  }
  mutex_unlock(& hsotg->init_mutex);
  return (ret);
}
}
int s3c_hsotg_resume(struct dwc2_hsotg *hsotg ) 
{ 
  unsigned long flags ;
  int ret ;
  raw_spinlock_t *tmp ;

  {
  ret = 0;
  if ((unsigned int )hsotg->lx_state == 2U) {
    return (ret);
  } else {

  }
  mutex_lock_nested(& hsotg->init_mutex, 0U);
  if ((unsigned long )hsotg->driver != (unsigned long )((struct usb_gadget_driver *)0)) {
    _dev_info((struct device  const  *)hsotg->dev, "resuming usb gadget %s\n", (hsotg->driver)->driver.name);
    clk_enable(hsotg->clk);
    ret = regulator_bulk_enable(2, (struct regulator_bulk_data *)(& hsotg->supplies));
    s3c_hsotg_phy_enable(hsotg);
    tmp = spinlock_check(& hsotg->lock);
    flags = _raw_spin_lock_irqsave(tmp);
    s3c_hsotg_core_init_disconnected(hsotg, 0);
    if ((unsigned int )*((unsigned char *)hsotg + 3232UL) != 0U) {
      s3c_hsotg_core_connect(hsotg);
    } else {

    }
    spin_unlock_irqrestore(& hsotg->lock, flags);
  } else {

  }
  mutex_unlock(& hsotg->init_mutex);
  return (ret);
}
}
void ldv_initialize_usb_gadget_ops_9(void) 
{ 
  void *tmp ;

  {
  tmp = ldv_init_zalloc(1576UL);
  s3c_hsotg_gadget_ops_group0 = (struct usb_gadget *)tmp;
  return;
}
}
void ldv_initialize_usb_ep_ops_10(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
  tmp = ldv_init_zalloc(64UL);
  s3c_hsotg_ep_ops_group0 = (struct usb_ep *)tmp;
  tmp___0 = ldv_init_zalloc(88UL);
  s3c_hsotg_ep_ops_group1 = (struct usb_request *)tmp___0;
  return;
}
}
void ldv_main_exported_10(void) 
{ 
  struct usb_endpoint_descriptor *ldvarg30 ;
  void *tmp ;
  gfp_t ldvarg33 ;
  int ldvarg31 ;
    klee_make_symbolic(&ldvarg31, sizeof(int), "ldvarg31");
  gfp_t ldvarg32 ;
  int tmp___0 ;

  {
  tmp = ldv_init_zalloc(9UL);
  ldvarg30 = (struct usb_endpoint_descriptor *)tmp;
  ldv_memset((void *)(& ldvarg33), 0, 4UL);
  ldv_memset((void *)(& ldvarg31), 0, 4UL);
  ldv_memset((void *)(& ldvarg32), 0, 4UL);
  tmp___0 = __VERIFIER_nondet_int();
  switch (tmp___0) {
  case 0: ;
  if (ldv_state_variable_10 == 1) {
    s3c_hsotg_ep_disable(s3c_hsotg_ep_ops_group0);
    ldv_state_variable_10 = 1;
  } else {

  }
  goto ldv_35264;
  case 1: ;
  if (ldv_state_variable_10 == 1) {
    s3c_hsotg_ep_queue_lock(s3c_hsotg_ep_ops_group0, s3c_hsotg_ep_ops_group1, ldvarg33);
    ldv_state_variable_10 = 1;
  } else {

  }
  goto ldv_35264;
  case 2: ;
  if (ldv_state_variable_10 == 1) {
    s3c_hsotg_ep_alloc_request(s3c_hsotg_ep_ops_group0, ldvarg32);
    ldv_state_variable_10 = 1;
  } else {

  }
  goto ldv_35264;
  case 3: ;
  if (ldv_state_variable_10 == 1) {
    s3c_hsotg_ep_dequeue(s3c_hsotg_ep_ops_group0, s3c_hsotg_ep_ops_group1);
    ldv_state_variable_10 = 1;
  } else {

  }
  goto ldv_35264;
  case 4: ;
  if (ldv_state_variable_10 == 1) {
    s3c_hsotg_ep_free_request(s3c_hsotg_ep_ops_group0, s3c_hsotg_ep_ops_group1);
    ldv_state_variable_10 = 1;
  } else {

  }
  goto ldv_35264;
  case 5: ;
  if (ldv_state_variable_10 == 1) {
    s3c_hsotg_ep_sethalt_lock(s3c_hsotg_ep_ops_group0, ldvarg31);
    ldv_state_variable_10 = 1;
  } else {

  }
  goto ldv_35264;
  case 6: ;
  if (ldv_state_variable_10 == 1) {
    s3c_hsotg_ep_enable(s3c_hsotg_ep_ops_group0, (struct usb_endpoint_descriptor  const  *)ldvarg30);
    ldv_state_variable_10 = 1;
  } else {

  }
  goto ldv_35264;
  default: 
  ldv_stop();
  }
  ldv_35264: ;
  return;
}
}
void ldv_main_exported_9(void) 
{ 
  struct usb_gadget_driver *ldvarg19 ;
  void *tmp ;
  int ldvarg20 ;
    klee_make_symbolic(&ldvarg20, sizeof(int), "ldvarg20");
  int ldvarg18 ;
    klee_make_symbolic(&ldvarg18, sizeof(int), "ldvarg18");
  unsigned int ldvarg21 ;
    klee_make_symbolic(&ldvarg21, sizeof(int), "ldvarg21");
  int tmp___0 ;

  {
  tmp = ldv_init_zalloc(192UL);
  ldvarg19 = (struct usb_gadget_driver *)tmp;
  ldv_memset((void *)(& ldvarg20), 0, 4UL);
  ldv_memset((void *)(& ldvarg18), 0, 4UL);
  ldv_memset((void *)(& ldvarg21), 0, 4UL);
  tmp___0 = __VERIFIER_nondet_int();
  switch (tmp___0) {
  case 0: ;
  if (ldv_state_variable_9 == 1) {
    s3c_hsotg_vbus_draw(s3c_hsotg_gadget_ops_group0, ldvarg21);
    ldv_state_variable_9 = 1;
  } else {

  }
  goto ldv_35280;
  case 1: ;
  if (ldv_state_variable_9 == 1) {
    s3c_hsotg_pullup(s3c_hsotg_gadget_ops_group0, ldvarg20);
    ldv_state_variable_9 = 1;
  } else {

  }
  goto ldv_35280;
  case 2: ;
  if (ldv_state_variable_9 == 1) {
    s3c_hsotg_udc_start(s3c_hsotg_gadget_ops_group0, ldvarg19);
    ldv_state_variable_9 = 1;
  } else {

  }
  goto ldv_35280;
  case 3: ;
  if (ldv_state_variable_9 == 1) {
    s3c_hsotg_gadget_getframe(s3c_hsotg_gadget_ops_group0);
    ldv_state_variable_9 = 1;
  } else {

  }
  goto ldv_35280;
  case 4: ;
  if (ldv_state_variable_9 == 1) {
    s3c_hsotg_vbus_session(s3c_hsotg_gadget_ops_group0, ldvarg18);
    ldv_state_variable_9 = 1;
  } else {

  }
  goto ldv_35280;
  case 5: ;
  if (ldv_state_variable_9 == 1) {
    s3c_hsotg_udc_stop(s3c_hsotg_gadget_ops_group0);
    ldv_state_variable_9 = 1;
  } else {

  }
  goto ldv_35280;
  default: 
  ldv_stop();
  }
  ldv_35280: ;
  return;
}
}
bool ldv_queue_work_on_117(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_3(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_delayed_work_on_118(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_3(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_work_on_119(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_3(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
void ldv_flush_workqueue_120(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
  flush_workqueue(ldv_func_arg1);
  call_and_disable_all_3(2);
  return;
}
}
bool ldv_queue_delayed_work_on_121(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_3(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
__inline static long ldv__builtin_expect(long exp , long c ) ;
extern void __might_fault(char const   * , int  ) ;
extern int strncmp(char const   * , char const   * , __kernel_size_t  ) ;
__inline static bool IS_ERR(void const   *ptr ) ;
bool ldv_queue_work_on_131(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_work_on_133(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_delayed_work_on_132(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
bool ldv_queue_delayed_work_on_135(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
void ldv_flush_workqueue_134(struct workqueue_struct *ldv_func_arg1 ) ;
extern ssize_t seq_read(struct file * , char * , size_t  , loff_t * ) ;
extern loff_t seq_lseek(struct file * , loff_t  , int  ) ;
extern int seq_puts(struct seq_file * , char const   * ) ;
extern int seq_printf(struct seq_file * , char const   *  , ...) ;
extern int single_open(struct file * , int (*)(struct seq_file * , void * ) , void * ) ;
extern int single_release(struct inode * , struct file * ) ;
extern struct dentry *debugfs_create_file(char const   * , umode_t  , struct dentry * ,
                                          void * , struct file_operations  const  * ) ;
extern struct dentry *debugfs_create_dir(char const   * , struct dentry * ) ;
extern void debugfs_remove_recursive(struct dentry * ) ;
extern struct dentry *debugfs_create_regset32(char const   * , umode_t  , struct dentry * ,
                                              struct debugfs_regset32 * ) ;
extern unsigned long _copy_from_user(void * , void const   * , unsigned int  ) ;
extern void __copy_from_user_overflow(void) ;
__inline static unsigned long copy_from_user(void *to , void const   *from , unsigned long n ) 
{ 
  int sz ;
    klee_make_symbolic(&sz, sizeof(int), "sz");
  unsigned long tmp ;
  long tmp___0 ;

  {
  tmp = __builtin_object_size((void const   *)to, 0);
  sz = (int )tmp;
  __might_fault("./arch/x86/include/asm/uaccess.h", 697);
  tmp___0 = ldv__builtin_expect((long )(sz < 0 || (unsigned long )sz >= n), 1L);
  if (tmp___0 != 0L) {
    n = _copy_from_user(to, from, (unsigned int )n);
  } else {
    __copy_from_user_overflow();
  }
  return (n);
}
}
static ssize_t testmode_write(struct file *file , char const   *ubuf , size_t count ,
                              loff_t *ppos ) 
{ 
  struct seq_file *s ;
  struct dwc2_hsotg *hsotg ;
  unsigned long flags ;
  u32 testmode ;
  char buf[32U] ;
  size_t __min1 ;
  size_t __min2 ;
  unsigned long tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  raw_spinlock_t *tmp___5 ;

  {
  s = (struct seq_file *)file->private_data;
  hsotg = (struct dwc2_hsotg *)s->private;
  testmode = 0U;
  __min1 = 31UL;
  __min2 = count;
  tmp = copy_from_user((void *)(& buf), (void const   *)ubuf, __min1 < __min2 ? __min1 : __min2);
  if (tmp != 0UL) {
    return (-14L);
  } else {

  }
  tmp___4 = strncmp((char const   *)(& buf), "test_j", 6UL);
  if (tmp___4 == 0) {
    testmode = 1U;
  } else {
    tmp___3 = strncmp((char const   *)(& buf), "test_k", 6UL);
    if (tmp___3 == 0) {
      testmode = 2U;
    } else {
      tmp___2 = strncmp((char const   *)(& buf), "test_se0_nak", 12UL);
      if (tmp___2 == 0) {
        testmode = 3U;
      } else {
        tmp___1 = strncmp((char const   *)(& buf), "test_packet", 11UL);
        if (tmp___1 == 0) {
          testmode = 4U;
        } else {
          tmp___0 = strncmp((char const   *)(& buf), "test_force_enable", 17UL);
          if (tmp___0 == 0) {
            testmode = 5U;
          } else {
            testmode = 0U;
          }
        }
      }
    }
  }
  tmp___5 = spinlock_check(& hsotg->lock);
  flags = _raw_spin_lock_irqsave(tmp___5);
  s3c_hsotg_set_test_mode(hsotg, (int )testmode);
  spin_unlock_irqrestore(& hsotg->lock, flags);
  return ((ssize_t )count);
}
}
static int testmode_show(struct seq_file *s , void *unused ) 
{ 
  struct dwc2_hsotg *hsotg ;
  unsigned long flags ;
  int dctl ;
  raw_spinlock_t *tmp ;
  unsigned int tmp___0 ;

  {
  hsotg = (struct dwc2_hsotg *)s->private;
  tmp = spinlock_check(& hsotg->lock);
  flags = _raw_spin_lock_irqsave(tmp);
  tmp___0 = readl((void const volatile   *)hsotg->regs + 2052U);
  dctl = (int )tmp___0;
  dctl = dctl & 112;
  dctl = dctl >> 4;
  spin_unlock_irqrestore(& hsotg->lock, flags);
  switch (dctl) {
  case 0: 
  seq_puts(s, "no test\n");
  goto ldv_33244;
  case 1: 
  seq_puts(s, "test_j\n");
  goto ldv_33244;
  case 2: 
  seq_puts(s, "test_k\n");
  goto ldv_33244;
  case 3: 
  seq_puts(s, "test_se0_nak\n");
  goto ldv_33244;
  case 4: 
  seq_puts(s, "test_packet\n");
  goto ldv_33244;
  case 5: 
  seq_puts(s, "test_force_enable\n");
  goto ldv_33244;
  default: 
  seq_printf(s, "UNKNOWN %d\n", dctl);
  }
  ldv_33244: ;
  return (0);
}
}
static int testmode_open(struct inode *inode , struct file *file ) 
{ 
  int tmp ;

  {
  tmp = single_open(file, & testmode_show, inode->i_private);
  return (tmp);
}
}
static struct file_operations  const  testmode_fops  = 
     {& __this_module, & seq_lseek, & seq_read, & testmode_write, 0, 0, 0, 0, 0, 0,
    0, 0, & testmode_open, 0, & single_release, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0};
static int state_show(struct seq_file *seq , void *v ) 
{ 
  struct dwc2_hsotg *hsotg ;
  void *regs ;
  int idx ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;
  unsigned int tmp___4 ;
  unsigned int tmp___5 ;
  unsigned int tmp___6 ;
  unsigned int tmp___7 ;
  unsigned int tmp___8 ;
  unsigned int tmp___9 ;
  u32 in ;
  u32 out ;

  {
  hsotg = (struct dwc2_hsotg *)seq->private;
  regs = hsotg->regs;
  tmp = readl((void const volatile   *)regs + 2056U);
  tmp___0 = readl((void const volatile   *)regs + 2052U);
  tmp___1 = readl((void const volatile   *)regs + 2048U);
  seq_printf(seq, "DCFG=0x%08x, DCTL=0x%08x, DSTS=0x%08x\n", tmp___1, tmp___0, tmp);
  tmp___2 = readl((void const volatile   *)regs + 2068U);
  tmp___3 = readl((void const volatile   *)regs + 2064U);
  seq_printf(seq, "DIEPMSK=0x%08x, DOEPMASK=0x%08x\n", tmp___3, tmp___2);
  tmp___4 = readl((void const volatile   *)regs + 20U);
  tmp___5 = readl((void const volatile   *)regs + 24U);
  seq_printf(seq, "GINTMSK=0x%08x, GINTSTS=0x%08x\n", tmp___5, tmp___4);
  tmp___6 = readl((void const volatile   *)regs + 2072U);
  tmp___7 = readl((void const volatile   *)regs + 2076U);
  seq_printf(seq, "DAINTMSK=0x%08x, DAINT=0x%08x\n", tmp___7, tmp___6);
  tmp___8 = readl((void const volatile   *)regs + 28U);
  tmp___9 = readl((void const volatile   *)regs + 44U);
  seq_printf(seq, "GNPTXSTS=0x%08x, GRXSTSR=%08x\n", tmp___9, tmp___8);
  seq_puts(seq, "\nEndpoint status:\n");
  idx = 0;
  goto ldv_33266;
  ldv_33265: 
  in = readl((void const volatile   *)regs + (unsigned long )((idx + 72) * 32));
  out = readl((void const volatile   *)regs + (unsigned long )((idx + 88) * 32));
  seq_printf(seq, "ep%d: DIEPCTL=0x%08x, DOEPCTL=0x%08x", idx, in, out);
  in = readl((void const volatile   *)regs + (unsigned long )(idx * 32 + 2320));
  out = readl((void const volatile   *)regs + (unsigned long )(idx * 32 + 2832));
  seq_printf(seq, ", DIEPTSIZ=0x%08x, DOEPTSIZ=0x%08x", in, out);
  seq_puts(seq, "\n");
  idx = idx + 1;
  ldv_33266: ;
  if ((int )hsotg->num_of_eps > idx) {
    goto ldv_33265;
  } else {

  }

  return (0);
}
}
static int state_open(struct inode *inode , struct file *file ) 
{ 
  int tmp ;

  {
  tmp = single_open(file, & state_show, inode->i_private);
  return (tmp);
}
}
static struct file_operations  const  state_fops  = 
     {& __this_module, & seq_lseek, & seq_read, 0, 0, 0, 0, 0, 0, 0, 0, 0, & state_open,
    0, & single_release, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
static int fifo_show(struct seq_file *seq , void *v ) 
{ 
  struct dwc2_hsotg *hsotg ;
  void *regs ;
  u32 val ;
  int idx ;
  unsigned int tmp ;

  {
  hsotg = (struct dwc2_hsotg *)seq->private;
  regs = hsotg->regs;
  seq_puts(seq, "Non-periodic FIFOs:\n");
  tmp = readl((void const volatile   *)regs + 36U);
  seq_printf(seq, "RXFIFO: Size %d\n", tmp);
  val = readl((void const volatile   *)regs + 40U);
  seq_printf(seq, "NPTXFIFO: Size %d, Start 0x%08x\n", val >> 16, val & 4294901760U);
  seq_puts(seq, "\nPeriodic TXFIFOs:\n");
  idx = 1;
  goto ldv_33282;
  ldv_33281: 
  val = readl((void const volatile   *)regs + (unsigned long )((idx + 64) * 4));
  seq_printf(seq, "\tDPTXFIFO%2d: Size %d, Start 0x%08x\n", idx, val >> 16, val & 65535U);
  idx = idx + 1;
  ldv_33282: ;
  if ((int )hsotg->num_of_eps > idx) {
    goto ldv_33281;
  } else {

  }

  return (0);
}
}
static int fifo_open(struct inode *inode , struct file *file ) 
{ 
  int tmp ;

  {
  tmp = single_open(file, & fifo_show, inode->i_private);
  return (tmp);
}
}
static struct file_operations  const  fifo_fops  = 
     {& __this_module, & seq_lseek, & seq_read, 0, 0, 0, 0, 0, 0, 0, 0, 0, & fifo_open,
    0, & single_release, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
static char const   *decode_direction(int is_in ) 
{ 


  {
  return (is_in != 0 ? "in" : "out");
}
}
static int ep_show(struct seq_file *seq , void *v ) 
{ 
  struct s3c_hsotg_ep *ep ;
  struct dwc2_hsotg *hsotg ;
  struct s3c_hsotg_req *req ;
  void *regs ;
  int index ;
  int show_limit ;
    klee_make_symbolic(&show_limit, sizeof(int), "show_limit");
  unsigned long flags ;
  char const   *tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;
  unsigned int tmp___4 ;
  unsigned int tmp___5 ;
  unsigned int tmp___6 ;
  unsigned int tmp___7 ;
  raw_spinlock_t *tmp___8 ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;

  {
  ep = (struct s3c_hsotg_ep *)seq->private;
  hsotg = ep->parent;
  regs = hsotg->regs;
  index = (int )ep->index;
  show_limit = 15;
  tmp = decode_direction((int )ep->dir_in);
  seq_printf(seq, "Endpoint index %d, named %s,  dir %s:\n", (int )ep->index, ep->ep.name,
             tmp);
  tmp___0 = readl((void const volatile   *)regs + (unsigned long )((index + 88) * 32));
  tmp___1 = readl((void const volatile   *)regs + (unsigned long )((index + 72) * 32));
  seq_printf(seq, "\tDIEPCTL=0x%08x, DOEPCTL=0x%08x\n", tmp___1, tmp___0);
  tmp___2 = readl((void const volatile   *)regs + (unsigned long )(index * 32 + 2836));
  tmp___3 = readl((void const volatile   *)regs + (unsigned long )(index * 32 + 2324));
  seq_printf(seq, "\tDIEPDMA=0x%08x, DOEPDMA=0x%08x\n", tmp___3, tmp___2);
  tmp___4 = readl((void const volatile   *)regs + (unsigned long )(index * 32 + 2824));
  tmp___5 = readl((void const volatile   *)regs + (unsigned long )(index * 32 + 2312));
  seq_printf(seq, "\tDIEPINT=0x%08x, DOEPINT=0x%08x\n", tmp___5, tmp___4);
  tmp___6 = readl((void const volatile   *)regs + (unsigned long )(index * 32 + 2832));
  tmp___7 = readl((void const volatile   *)regs + (unsigned long )(index * 32 + 2320));
  seq_printf(seq, "\tDIEPTSIZ=0x%08x, DOEPTSIZ=0x%08x\n", tmp___7, tmp___6);
  seq_puts(seq, "\n");
  seq_printf(seq, "mps %d\n", (int )ep->ep.maxpacket);
  seq_printf(seq, "total_data=%ld\n", ep->total_data);
  seq_printf(seq, "request list (%p,%p):\n", ep->queue.next, ep->queue.prev);
  tmp___8 = spinlock_check(& hsotg->lock);
  flags = _raw_spin_lock_irqsave(tmp___8);
  __mptr = (struct list_head  const  *)ep->queue.next;
  req = (struct s3c_hsotg_req *)__mptr + 0xffffffffffffffa8UL;
  goto ldv_33312;
  ldv_33311: 
  show_limit = show_limit - 1;
  if (show_limit < 0) {
    seq_puts(seq, "not showing more requests...\n");
    goto ldv_33310;
  } else {

  }
  seq_printf(seq, "%c req %p: %d bytes @%p, ", (unsigned long )ep->req == (unsigned long )req ? 42 : 32,
             req, req->req.length, req->req.buf);
  seq_printf(seq, "%d done, res %d\n", req->req.actual, req->req.status);
  __mptr___0 = (struct list_head  const  *)req->queue.next;
  req = (struct s3c_hsotg_req *)__mptr___0 + 0xffffffffffffffa8UL;
  ldv_33312: ;
  if ((unsigned long )(& req->queue) != (unsigned long )(& ep->queue)) {
    goto ldv_33311;
  } else {

  }
  ldv_33310: 
  spin_unlock_irqrestore(& hsotg->lock, flags);
  return (0);
}
}
static int ep_open(struct inode *inode , struct file *file ) 
{ 
  int tmp ;

  {
  tmp = single_open(file, & ep_show, inode->i_private);
  return (tmp);
}
}
static struct file_operations  const  ep_fops  = 
     {& __this_module, & seq_lseek, & seq_read, 0, 0, 0, 0, 0, 0, 0, 0, 0, & ep_open,
    0, & single_release, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
static void s3c_hsotg_create_debug(struct dwc2_hsotg *hsotg ) 
{ 
  struct dentry *root ;
  struct dentry *file ;
  unsigned int epidx ;
    klee_make_symbolic(&epidx, sizeof(int), "epidx");
  bool tmp ;
  bool tmp___0 ;
  bool tmp___1 ;
  struct s3c_hsotg_ep *ep ;
  bool tmp___2 ;
  struct s3c_hsotg_ep *ep___0 ;
  bool tmp___3 ;

  {
  root = hsotg->debug_root;
  file = debugfs_create_file("state", 292, root, (void *)hsotg, & state_fops);
  tmp = IS_ERR((void const   *)file);
  if ((int )tmp) {
    dev_err((struct device  const  *)hsotg->dev, "%s: failed to create state\n", "s3c_hsotg_create_debug");
  } else {

  }
  file = debugfs_create_file("testmode", 420, root, (void *)hsotg, & testmode_fops);
  tmp___0 = IS_ERR((void const   *)file);
  if ((int )tmp___0) {
    dev_err((struct device  const  *)hsotg->dev, "%s: failed to create testmode\n",
            "s3c_hsotg_create_debug");
  } else {

  }
  file = debugfs_create_file("fifo", 292, root, (void *)hsotg, & fifo_fops);
  tmp___1 = IS_ERR((void const   *)file);
  if ((int )tmp___1) {
    dev_err((struct device  const  *)hsotg->dev, "%s: failed to create fifo\n", "s3c_hsotg_create_debug");
  } else {

  }
  epidx = 0U;
  goto ldv_33327;
  ldv_33326: 
  ep = hsotg->eps_out[epidx];
  if ((unsigned long )ep != (unsigned long )((struct s3c_hsotg_ep *)0)) {
    file = debugfs_create_file((char const   *)(& ep->name), 292, root, (void *)ep,
                               & ep_fops);
    tmp___2 = IS_ERR((void const   *)file);
    if ((int )tmp___2) {
      dev_err((struct device  const  *)hsotg->dev, "failed to create %s debug file\n",
              (char *)(& ep->name));
    } else {

    }
  } else {

  }
  epidx = epidx + 1U;
  ldv_33327: ;
  if ((unsigned int )hsotg->num_of_eps > epidx) {
    goto ldv_33326;
  } else {

  }
  epidx = 1U;
  goto ldv_33331;
  ldv_33330: 
  ep___0 = hsotg->eps_in[epidx];
  if ((unsigned long )ep___0 != (unsigned long )((struct s3c_hsotg_ep *)0)) {
    file = debugfs_create_file((char const   *)(& ep___0->name), 292, root, (void *)ep___0,
                               & ep_fops);
    tmp___3 = IS_ERR((void const   *)file);
    if ((int )tmp___3) {
      dev_err((struct device  const  *)hsotg->dev, "failed to create %s debug file\n",
              (char *)(& ep___0->name));
    } else {

    }
  } else {

  }
  epidx = epidx + 1U;
  ldv_33331: ;
  if ((unsigned int )hsotg->num_of_eps > epidx) {
    goto ldv_33330;
  } else {

  }

  return;
}
}
static struct debugfs_reg32  const  dwc2_regs[319U]  = 
  {      {(char *)"GOTGCTL", 0UL}, 
        {(char *)"GOTGINT", 4UL}, 
        {(char *)"GAHBCFG", 8UL}, 
        {(char *)"GUSBCFG", 12UL}, 
        {(char *)"GRSTCTL", 16UL}, 
        {(char *)"GINTSTS", 20UL}, 
        {(char *)"GINTMSK", 24UL}, 
        {(char *)"GRXSTSR", 28UL}, 
        {(char *)"GRXSTSP", 32UL}, 
        {(char *)"GRXFSIZ", 36UL}, 
        {(char *)"GNPTXFSIZ", 40UL}, 
        {(char *)"GNPTXSTS", 44UL}, 
        {(char *)"GI2CCTL", 48UL}, 
        {(char *)"GPVNDCTL", 52UL}, 
        {(char *)"GGPIO", 56UL}, 
        {(char *)"GUID", 60UL}, 
        {(char *)"GSNPSID", 64UL}, 
        {(char *)"GHWCFG1", 68UL}, 
        {(char *)"GHWCFG2", 72UL}, 
        {(char *)"GHWCFG3", 76UL}, 
        {(char *)"GHWCFG4", 80UL}, 
        {(char *)"GLPMCFG", 84UL}, 
        {(char *)"GPWRDN", 88UL}, 
        {(char *)"GDFIFOCFG", 92UL}, 
        {(char *)"ADPCTL", 96UL}, 
        {(char *)"HPTXFSIZ", 256UL}, 
        {(char *)"DPTXFSIZN(1)", 260UL}, 
        {(char *)"DPTXFSIZN(2)", 264UL}, 
        {(char *)"DPTXFSIZN(3)", 268UL}, 
        {(char *)"DPTXFSIZN(4)", 272UL}, 
        {(char *)"DPTXFSIZN(5)", 276UL}, 
        {(char *)"DPTXFSIZN(6)", 280UL}, 
        {(char *)"DPTXFSIZN(7)", 284UL}, 
        {(char *)"DPTXFSIZN(8)", 288UL}, 
        {(char *)"DPTXFSIZN(9)", 292UL}, 
        {(char *)"DPTXFSIZN(10)", 296UL}, 
        {(char *)"DPTXFSIZN(11)", 300UL}, 
        {(char *)"DPTXFSIZN(12)", 304UL}, 
        {(char *)"DPTXFSIZN(13)", 308UL}, 
        {(char *)"DPTXFSIZN(14)", 312UL}, 
        {(char *)"DPTXFSIZN(15)", 316UL}, 
        {(char *)"DCFG", 2048UL}, 
        {(char *)"DCTL", 2052UL}, 
        {(char *)"DSTS", 2056UL}, 
        {(char *)"DIEPMSK", 2064UL}, 
        {(char *)"DOEPMSK", 2068UL}, 
        {(char *)"DAINT", 2072UL}, 
        {(char *)"DAINTMSK", 2076UL}, 
        {(char *)"DTKNQR1", 2080UL}, 
        {(char *)"DTKNQR2", 2084UL}, 
        {(char *)"DTKNQR3", 2096UL}, 
        {(char *)"DTKNQR4", 2100UL}, 
        {(char *)"DVBUSDIS", 2088UL}, 
        {(char *)"DVBUSPULSE", 2092UL}, 
        {(char *)"DIEPCTL(0)", 2304UL}, 
        {(char *)"DIEPCTL(1)", 2336UL}, 
        {(char *)"DIEPCTL(2)", 2368UL}, 
        {(char *)"DIEPCTL(3)", 2400UL}, 
        {(char *)"DIEPCTL(4)", 2432UL}, 
        {(char *)"DIEPCTL(5)", 2464UL}, 
        {(char *)"DIEPCTL(6)", 2496UL}, 
        {(char *)"DIEPCTL(7)", 2528UL}, 
        {(char *)"DIEPCTL(8)", 2560UL}, 
        {(char *)"DIEPCTL(9)", 2592UL}, 
        {(char *)"DIEPCTL(10)", 2624UL}, 
        {(char *)"DIEPCTL(11)", 2656UL}, 
        {(char *)"DIEPCTL(12)", 2688UL}, 
        {(char *)"DIEPCTL(13)", 2720UL}, 
        {(char *)"DIEPCTL(14)", 2752UL}, 
        {(char *)"DIEPCTL(15)", 2784UL}, 
        {(char *)"DOEPCTL(0)", 2816UL}, 
        {(char *)"DOEPCTL(1)", 2848UL}, 
        {(char *)"DOEPCTL(2)", 2880UL}, 
        {(char *)"DOEPCTL(3)", 2912UL}, 
        {(char *)"DOEPCTL(4)", 2944UL}, 
        {(char *)"DOEPCTL(5)", 2976UL}, 
        {(char *)"DOEPCTL(6)", 3008UL}, 
        {(char *)"DOEPCTL(7)", 3040UL}, 
        {(char *)"DOEPCTL(8)", 3072UL}, 
        {(char *)"DOEPCTL(9)", 3104UL}, 
        {(char *)"DOEPCTL(10)", 3136UL}, 
        {(char *)"DOEPCTL(11)", 3168UL}, 
        {(char *)"DOEPCTL(12)", 3200UL}, 
        {(char *)"DOEPCTL(13)", 3232UL}, 
        {(char *)"DOEPCTL(14)", 3264UL}, 
        {(char *)"DOEPCTL(15)", 3296UL}, 
        {(char *)"DIEPINT(0)", 2312UL}, 
        {(char *)"DIEPINT(1)", 2344UL}, 
        {(char *)"DIEPINT(2)", 2376UL}, 
        {(char *)"DIEPINT(3)", 2408UL}, 
        {(char *)"DIEPINT(4)", 2440UL}, 
        {(char *)"DIEPINT(5)", 2472UL}, 
        {(char *)"DIEPINT(6)", 2504UL}, 
        {(char *)"DIEPINT(7)", 2536UL}, 
        {(char *)"DIEPINT(8)", 2568UL}, 
        {(char *)"DIEPINT(9)", 2600UL}, 
        {(char *)"DIEPINT(10)", 2632UL}, 
        {(char *)"DIEPINT(11)", 2664UL}, 
        {(char *)"DIEPINT(12)", 2696UL}, 
        {(char *)"DIEPINT(13)", 2728UL}, 
        {(char *)"DIEPINT(14)", 2760UL}, 
        {(char *)"DIEPINT(15)", 2792UL}, 
        {(char *)"DOEPINT(0)", 2824UL}, 
        {(char *)"DOEPINT(1)", 2856UL}, 
        {(char *)"DOEPINT(2)", 2888UL}, 
        {(char *)"DOEPINT(3)", 2920UL}, 
        {(char *)"DOEPINT(4)", 2952UL}, 
        {(char *)"DOEPINT(5)", 2984UL}, 
        {(char *)"DOEPINT(6)", 3016UL}, 
        {(char *)"DOEPINT(7)", 3048UL}, 
        {(char *)"DOEPINT(8)", 3080UL}, 
        {(char *)"DOEPINT(9)", 3112UL}, 
        {(char *)"DOEPINT(10)", 3144UL}, 
        {(char *)"DOEPINT(11)", 3176UL}, 
        {(char *)"DOEPINT(12)", 3208UL}, 
        {(char *)"DOEPINT(13)", 3240UL}, 
        {(char *)"DOEPINT(14)", 3272UL}, 
        {(char *)"DOEPINT(15)", 3304UL}, 
        {(char *)"DIEPTSIZ(0)", 2320UL}, 
        {(char *)"DIEPTSIZ(1)", 2352UL}, 
        {(char *)"DIEPTSIZ(2)", 2384UL}, 
        {(char *)"DIEPTSIZ(3)", 2416UL}, 
        {(char *)"DIEPTSIZ(4)", 2448UL}, 
        {(char *)"DIEPTSIZ(5)", 2480UL}, 
        {(char *)"DIEPTSIZ(6)", 2512UL}, 
        {(char *)"DIEPTSIZ(7)", 2544UL}, 
        {(char *)"DIEPTSIZ(8)", 2576UL}, 
        {(char *)"DIEPTSIZ(9)", 2608UL}, 
        {(char *)"DIEPTSIZ(10)", 2640UL}, 
        {(char *)"DIEPTSIZ(11)", 2672UL}, 
        {(char *)"DIEPTSIZ(12)", 2704UL}, 
        {(char *)"DIEPTSIZ(13)", 2736UL}, 
        {(char *)"DIEPTSIZ(14)", 2768UL}, 
        {(char *)"DIEPTSIZ(15)", 2800UL}, 
        {(char *)"DOEPTSIZ(0)", 2832UL}, 
        {(char *)"DOEPTSIZ(1)", 2864UL}, 
        {(char *)"DOEPTSIZ(2)", 2896UL}, 
        {(char *)"DOEPTSIZ(3)", 2928UL}, 
        {(char *)"DOEPTSIZ(4)", 2960UL}, 
        {(char *)"DOEPTSIZ(5)", 2992UL}, 
        {(char *)"DOEPTSIZ(6)", 3024UL}, 
        {(char *)"DOEPTSIZ(7)", 3056UL}, 
        {(char *)"DOEPTSIZ(8)", 3088UL}, 
        {(char *)"DOEPTSIZ(9)", 3120UL}, 
        {(char *)"DOEPTSIZ(10)", 3152UL}, 
        {(char *)"DOEPTSIZ(11)", 3184UL}, 
        {(char *)"DOEPTSIZ(12)", 3216UL}, 
        {(char *)"DOEPTSIZ(13)", 3248UL}, 
        {(char *)"DOEPTSIZ(14)", 3280UL}, 
        {(char *)"DOEPTSIZ(15)", 3312UL}, 
        {(char *)"DIEPDMA(0)", 2324UL}, 
        {(char *)"DIEPDMA(1)", 2356UL}, 
        {(char *)"DIEPDMA(2)", 2388UL}, 
        {(char *)"DIEPDMA(3)", 2420UL}, 
        {(char *)"DIEPDMA(4)", 2452UL}, 
        {(char *)"DIEPDMA(5)", 2484UL}, 
        {(char *)"DIEPDMA(6)", 2516UL}, 
        {(char *)"DIEPDMA(7)", 2548UL}, 
        {(char *)"DIEPDMA(8)", 2580UL}, 
        {(char *)"DIEPDMA(9)", 2612UL}, 
        {(char *)"DIEPDMA(10)", 2644UL}, 
        {(char *)"DIEPDMA(11)", 2676UL}, 
        {(char *)"DIEPDMA(12)", 2708UL}, 
        {(char *)"DIEPDMA(13)", 2740UL}, 
        {(char *)"DIEPDMA(14)", 2772UL}, 
        {(char *)"DIEPDMA(15)", 2804UL}, 
        {(char *)"DOEPDMA(0)", 2836UL}, 
        {(char *)"DOEPDMA(1)", 2868UL}, 
        {(char *)"DOEPDMA(2)", 2900UL}, 
        {(char *)"DOEPDMA(3)", 2932UL}, 
        {(char *)"DOEPDMA(4)", 2964UL}, 
        {(char *)"DOEPDMA(5)", 2996UL}, 
        {(char *)"DOEPDMA(6)", 3028UL}, 
        {(char *)"DOEPDMA(7)", 3060UL}, 
        {(char *)"DOEPDMA(8)", 3092UL}, 
        {(char *)"DOEPDMA(9)", 3124UL}, 
        {(char *)"DOEPDMA(10)", 3156UL}, 
        {(char *)"DOEPDMA(11)", 3188UL}, 
        {(char *)"DOEPDMA(12)", 3220UL}, 
        {(char *)"DOEPDMA(13)", 3252UL}, 
        {(char *)"DOEPDMA(14)", 3284UL}, 
        {(char *)"DOEPDMA(15)", 3316UL}, 
        {(char *)"DTXFSTS(0)", 2328UL}, 
        {(char *)"DTXFSTS(1)", 2360UL}, 
        {(char *)"DTXFSTS(2)", 2392UL}, 
        {(char *)"DTXFSTS(3)", 2424UL}, 
        {(char *)"DTXFSTS(4)", 2456UL}, 
        {(char *)"DTXFSTS(5)", 2488UL}, 
        {(char *)"DTXFSTS(6)", 2520UL}, 
        {(char *)"DTXFSTS(7)", 2552UL}, 
        {(char *)"DTXFSTS(8)", 2584UL}, 
        {(char *)"DTXFSTS(9)", 2616UL}, 
        {(char *)"DTXFSTS(10)", 2648UL}, 
        {(char *)"DTXFSTS(11)", 2680UL}, 
        {(char *)"DTXFSTS(12)", 2712UL}, 
        {(char *)"DTXFSTS(13)", 2744UL}, 
        {(char *)"DTXFSTS(14)", 2776UL}, 
        {(char *)"DTXFSTS(15)", 2808UL}, 
        {(char *)"PCGCTL", 3584UL}, 
        {(char *)"HCFG", 1024UL}, 
        {(char *)"HFIR", 1028UL}, 
        {(char *)"HFNUM", 1032UL}, 
        {(char *)"HPTXSTS", 1040UL}, 
        {(char *)"HAINT", 1044UL}, 
        {(char *)"HAINTMSK", 1048UL}, 
        {(char *)"HFLBADDR", 1052UL}, 
        {(char *)"HPRT0", 1088UL}, 
        {(char *)"HCCHAR(0)", 1280UL}, 
        {(char *)"HCCHAR(1)", 1312UL}, 
        {(char *)"HCCHAR(2)", 1344UL}, 
        {(char *)"HCCHAR(3)", 1376UL}, 
        {(char *)"HCCHAR(4)", 1408UL}, 
        {(char *)"HCCHAR(5)", 1440UL}, 
        {(char *)"HCCHAR(6)", 1472UL}, 
        {(char *)"HCCHAR(7)", 1504UL}, 
        {(char *)"HCCHAR(8)", 1536UL}, 
        {(char *)"HCCHAR(9)", 1568UL}, 
        {(char *)"HCCHAR(10)", 1600UL}, 
        {(char *)"HCCHAR(11)", 1632UL}, 
        {(char *)"HCCHAR(12)", 1664UL}, 
        {(char *)"HCCHAR(13)", 1696UL}, 
        {(char *)"HCCHAR(14)", 1728UL}, 
        {(char *)"HCCHAR(15)", 1760UL}, 
        {(char *)"HCSPLT(0)", 1284UL}, 
        {(char *)"HCSPLT(1)", 1316UL}, 
        {(char *)"HCSPLT(2)", 1348UL}, 
        {(char *)"HCSPLT(3)", 1380UL}, 
        {(char *)"HCSPLT(4)", 1412UL}, 
        {(char *)"HCSPLT(5)", 1444UL}, 
        {(char *)"HCSPLT(6)", 1476UL}, 
        {(char *)"HCSPLT(7)", 1508UL}, 
        {(char *)"HCSPLT(8)", 1540UL}, 
        {(char *)"HCSPLT(9)", 1572UL}, 
        {(char *)"HCSPLT(10)", 1604UL}, 
        {(char *)"HCSPLT(11)", 1636UL}, 
        {(char *)"HCSPLT(12)", 1668UL}, 
        {(char *)"HCSPLT(13)", 1700UL}, 
        {(char *)"HCSPLT(14)", 1732UL}, 
        {(char *)"HCSPLT(15)", 1764UL}, 
        {(char *)"HCINT(0)", 1288UL}, 
        {(char *)"HCINT(1)", 1320UL}, 
        {(char *)"HCINT(2)", 1352UL}, 
        {(char *)"HCINT(3)", 1384UL}, 
        {(char *)"HCINT(4)", 1416UL}, 
        {(char *)"HCINT(5)", 1448UL}, 
        {(char *)"HCINT(6)", 1480UL}, 
        {(char *)"HCINT(7)", 1512UL}, 
        {(char *)"HCINT(8)", 1544UL}, 
        {(char *)"HCINT(9)", 1576UL}, 
        {(char *)"HCINT(10)", 1608UL}, 
        {(char *)"HCINT(11)", 1640UL}, 
        {(char *)"HCINT(12)", 1672UL}, 
        {(char *)"HCINT(13)", 1704UL}, 
        {(char *)"HCINT(14)", 1736UL}, 
        {(char *)"HCINT(15)", 1768UL}, 
        {(char *)"HCINTMSK(0)", 1292UL}, 
        {(char *)"HCINTMSK(1)", 1324UL}, 
        {(char *)"HCINTMSK(2)", 1356UL}, 
        {(char *)"HCINTMSK(3)", 1388UL}, 
        {(char *)"HCINTMSK(4)", 1420UL}, 
        {(char *)"HCINTMSK(5)", 1452UL}, 
        {(char *)"HCINTMSK(6)", 1484UL}, 
        {(char *)"HCINTMSK(7)", 1516UL}, 
        {(char *)"HCINTMSK(8)", 1548UL}, 
        {(char *)"HCINTMSK(9)", 1580UL}, 
        {(char *)"HCINTMSK(10)", 1612UL}, 
        {(char *)"HCINTMSK(11)", 1644UL}, 
        {(char *)"HCINTMSK(12)", 1676UL}, 
        {(char *)"HCINTMSK(13)", 1708UL}, 
        {(char *)"HCINTMSK(14)", 1740UL}, 
        {(char *)"HCINTMSK(15)", 1772UL}, 
        {(char *)"HCTSIZ(0)", 1296UL}, 
        {(char *)"HCTSIZ(1)", 1328UL}, 
        {(char *)"HCTSIZ(2)", 1360UL}, 
        {(char *)"HCTSIZ(3)", 1392UL}, 
        {(char *)"HCTSIZ(4)", 1424UL}, 
        {(char *)"HCTSIZ(5)", 1456UL}, 
        {(char *)"HCTSIZ(6)", 1488UL}, 
        {(char *)"HCTSIZ(7)", 1520UL}, 
        {(char *)"HCTSIZ(8)", 1552UL}, 
        {(char *)"HCTSIZ(9)", 1584UL}, 
        {(char *)"HCTSIZ(10)", 1616UL}, 
        {(char *)"HCTSIZ(11)", 1648UL}, 
        {(char *)"HCTSIZ(12)", 1680UL}, 
        {(char *)"HCTSIZ(13)", 1712UL}, 
        {(char *)"HCTSIZ(14)", 1744UL}, 
        {(char *)"HCTSIZ(15)", 1776UL}, 
        {(char *)"HCDMA(0)", 1300UL}, 
        {(char *)"HCDMA(1)", 1332UL}, 
        {(char *)"HCDMA(2)", 1364UL}, 
        {(char *)"HCDMA(3)", 1396UL}, 
        {(char *)"HCDMA(4)", 1428UL}, 
        {(char *)"HCDMA(5)", 1460UL}, 
        {(char *)"HCDMA(6)", 1492UL}, 
        {(char *)"HCDMA(7)", 1524UL}, 
        {(char *)"HCDMA(8)", 1556UL}, 
        {(char *)"HCDMA(9)", 1588UL}, 
        {(char *)"HCDMA(10)", 1620UL}, 
        {(char *)"HCDMA(11)", 1652UL}, 
        {(char *)"HCDMA(12)", 1684UL}, 
        {(char *)"HCDMA(13)", 1716UL}, 
        {(char *)"HCDMA(14)", 1748UL}, 
        {(char *)"HCDMA(15)", 1780UL}, 
        {(char *)"HCDMAB(0)", 1308UL}, 
        {(char *)"HCDMAB(1)", 1340UL}, 
        {(char *)"HCDMAB(2)", 1372UL}, 
        {(char *)"HCDMAB(3)", 1404UL}, 
        {(char *)"HCDMAB(4)", 1436UL}, 
        {(char *)"HCDMAB(5)", 1468UL}, 
        {(char *)"HCDMAB(6)", 1500UL}, 
        {(char *)"HCDMAB(7)", 1532UL}, 
        {(char *)"HCDMAB(8)", 1564UL}, 
        {(char *)"HCDMAB(9)", 1596UL}, 
        {(char *)"HCDMAB(10)", 1628UL}, 
        {(char *)"HCDMAB(11)", 1660UL}, 
        {(char *)"HCDMAB(12)", 1692UL}, 
        {(char *)"HCDMAB(13)", 1724UL}, 
        {(char *)"HCDMAB(14)", 1756UL}, 
        {(char *)"HCDMAB(15)", 1788UL}};
int dwc2_debugfs_init(struct dwc2_hsotg *hsotg ) 
{ 
  int ret ;
  struct dentry *file ;
  char const   *tmp ;
  void *tmp___0 ;

  {
  tmp = dev_name((struct device  const  *)hsotg->dev);
  hsotg->debug_root = debugfs_create_dir(tmp, (struct dentry *)0);
  if ((unsigned long )hsotg->debug_root == (unsigned long )((struct dentry *)0)) {
    ret = -12;
    goto err0;
  } else {

  }
  s3c_hsotg_create_debug(hsotg);
  tmp___0 = devm_kzalloc(hsotg->dev, 24UL, 208U);
  hsotg->regset = (struct debugfs_regset32 *)tmp___0;
  if ((unsigned long )hsotg->regset == (unsigned long )((struct debugfs_regset32 *)0)) {
    ret = -12;
    goto err1;
  } else {

  }
  (hsotg->regset)->regs = (struct debugfs_reg32  const  *)(& dwc2_regs);
  (hsotg->regset)->nregs = 319;
  (hsotg->regset)->base = hsotg->regs;
  file = debugfs_create_regset32("regdump", 292, hsotg->debug_root, hsotg->regset);
  if ((unsigned long )file == (unsigned long )((struct dentry *)0)) {
    ret = -12;
    goto err1;
  } else {

  }
  return (0);
  err1: 
  debugfs_remove_recursive(hsotg->debug_root);
  err0: ;
  return (ret);
}
}
void dwc2_debugfs_exit(struct dwc2_hsotg *hsotg ) 
{ 


  {
  debugfs_remove_recursive(hsotg->debug_root);
  hsotg->debug_root = (struct dentry *)0;
  return;
}
}
int ldv_retval_26  ;
    klee_make_symbolic(&ldv_retval_26, sizeof(int), "ldv_retval_26");
int ldv_retval_5  ;
    klee_make_symbolic(&ldv_retval_5, sizeof(int), "ldv_retval_5");
int ldv_retval_0  ;
    klee_make_symbolic(&ldv_retval_0, sizeof(int), "ldv_retval_0");
int ldv_retval_2  ;
    klee_make_symbolic(&ldv_retval_2, sizeof(int), "ldv_retval_2");
void ldv_file_operations_7(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
  tmp = ldv_init_zalloc(1000UL);
  state_fops_group1 = (struct inode *)tmp;
  tmp___0 = ldv_init_zalloc(504UL);
  state_fops_group2 = (struct file *)tmp___0;
  return;
}
}
void ldv_file_operations_6(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
  tmp = ldv_init_zalloc(1000UL);
  fifo_fops_group1 = (struct inode *)tmp;
  tmp___0 = ldv_init_zalloc(504UL);
  fifo_fops_group2 = (struct file *)tmp___0;
  return;
}
}
void ldv_file_operations_8(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
  tmp = ldv_init_zalloc(1000UL);
  testmode_fops_group1 = (struct inode *)tmp;
  tmp___0 = ldv_init_zalloc(504UL);
  testmode_fops_group2 = (struct file *)tmp___0;
  return;
}
}
void ldv_file_operations_5(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
  tmp = ldv_init_zalloc(1000UL);
  ep_fops_group1 = (struct inode *)tmp;
  tmp___0 = ldv_init_zalloc(504UL);
  ep_fops_group2 = (struct file *)tmp___0;
  return;
}
}
void ldv_main_exported_8(void) 
{ 
  size_t ldvarg28 ;
  char *ldvarg29 ;
  void *tmp ;
  int ldvarg22 ;
    klee_make_symbolic(&ldvarg22, sizeof(int), "ldvarg22");
  size_t ldvarg25 ;
  loff_t ldvarg23 ;
  char *ldvarg26 ;
  void *tmp___0 ;
  loff_t *ldvarg27 ;
  void *tmp___1 ;
  loff_t *ldvarg24 ;
  void *tmp___2 ;
  int tmp___3 ;

  {
  tmp = ldv_init_zalloc(1UL);
  ldvarg29 = (char *)tmp;
  tmp___0 = ldv_init_zalloc(1UL);
  ldvarg26 = (char *)tmp___0;
  tmp___1 = ldv_init_zalloc(8UL);
  ldvarg27 = (loff_t *)tmp___1;
  tmp___2 = ldv_init_zalloc(8UL);
  ldvarg24 = (loff_t *)tmp___2;
  ldv_memset((void *)(& ldvarg28), 0, 8UL);
  ldv_memset((void *)(& ldvarg22), 0, 4UL);
  ldv_memset((void *)(& ldvarg25), 0, 8UL);
  ldv_memset((void *)(& ldvarg23), 0, 8UL);
  tmp___3 = __VERIFIER_nondet_int();
  switch (tmp___3) {
  case 0: ;
  if (ldv_state_variable_8 == 1) {
    testmode_write(testmode_fops_group2, (char const   *)ldvarg29, ldvarg28, ldvarg27);
    ldv_state_variable_8 = 1;
  } else {

  }
  if (ldv_state_variable_8 == 2) {
    testmode_write(testmode_fops_group2, (char const   *)ldvarg29, ldvarg28, ldvarg27);
    ldv_state_variable_8 = 2;
  } else {

  }
  goto ldv_33374;
  case 1: ;
  if (ldv_state_variable_8 == 2) {
    seq_read(testmode_fops_group2, ldvarg26, ldvarg25, ldvarg24);
    ldv_state_variable_8 = 2;
  } else {

  }
  goto ldv_33374;
  case 2: ;
  if (ldv_state_variable_8 == 1) {
    ldv_retval_5 = testmode_open(testmode_fops_group1, testmode_fops_group2);
    if (ldv_retval_5 == 0) {
      ldv_state_variable_8 = 2;
      ref_cnt = ref_cnt + 1;
    } else {

    }
  } else {

  }
  goto ldv_33374;
  case 3: ;
  if (ldv_state_variable_8 == 2) {
    single_release(testmode_fops_group1, testmode_fops_group2);
    ldv_state_variable_8 = 1;
    ref_cnt = ref_cnt - 1;
  } else {

  }
  goto ldv_33374;
  case 4: ;
  if (ldv_state_variable_8 == 2) {
    seq_lseek(testmode_fops_group2, ldvarg23, ldvarg22);
    ldv_state_variable_8 = 2;
  } else {

  }
  goto ldv_33374;
  default: 
  ldv_stop();
  }
  ldv_33374: ;
  return;
}
}
void ldv_main_exported_6(void) 
{ 
  loff_t *ldvarg2 ;
  void *tmp ;
  int ldvarg0 ;
    klee_make_symbolic(&ldvarg0, sizeof(int), "ldvarg0");
  size_t ldvarg3 ;
  char *ldvarg4 ;
  void *tmp___0 ;
  loff_t ldvarg1 ;
  int tmp___1 ;

  {
  tmp = ldv_init_zalloc(8UL);
  ldvarg2 = (loff_t *)tmp;
  tmp___0 = ldv_init_zalloc(1UL);
  ldvarg4 = (char *)tmp___0;
  ldv_memset((void *)(& ldvarg0), 0, 4UL);
  ldv_memset((void *)(& ldvarg3), 0, 8UL);
  ldv_memset((void *)(& ldvarg1), 0, 8UL);
  tmp___1 = __VERIFIER_nondet_int();
  switch (tmp___1) {
  case 0: ;
  if (ldv_state_variable_6 == 2) {
    seq_read(fifo_fops_group2, ldvarg4, ldvarg3, ldvarg2);
    ldv_state_variable_6 = 2;
  } else {

  }
  goto ldv_33389;
  case 1: ;
  if (ldv_state_variable_6 == 1) {
    ldv_retval_0 = fifo_open(fifo_fops_group1, fifo_fops_group2);
    if (ldv_retval_0 == 0) {
      ldv_state_variable_6 = 2;
      ref_cnt = ref_cnt + 1;
    } else {

    }
  } else {

  }
  goto ldv_33389;
  case 2: ;
  if (ldv_state_variable_6 == 2) {
    single_release(fifo_fops_group1, fifo_fops_group2);
    ldv_state_variable_6 = 1;
    ref_cnt = ref_cnt - 1;
  } else {

  }
  goto ldv_33389;
  case 3: ;
  if (ldv_state_variable_6 == 2) {
    seq_lseek(fifo_fops_group2, ldvarg1, ldvarg0);
    ldv_state_variable_6 = 2;
  } else {

  }
  goto ldv_33389;
  default: 
  ldv_stop();
  }
  ldv_33389: ;
  return;
}
}
void ldv_main_exported_7(void) 
{ 
  loff_t *ldvarg15 ;
  void *tmp ;
  size_t ldvarg16 ;
  int ldvarg13 ;
    klee_make_symbolic(&ldvarg13, sizeof(int), "ldvarg13");
  loff_t ldvarg14 ;
  char *ldvarg17 ;
  void *tmp___0 ;
  int tmp___1 ;

  {
  tmp = ldv_init_zalloc(8UL);
  ldvarg15 = (loff_t *)tmp;
  tmp___0 = ldv_init_zalloc(1UL);
  ldvarg17 = (char *)tmp___0;
  ldv_memset((void *)(& ldvarg16), 0, 8UL);
  ldv_memset((void *)(& ldvarg13), 0, 4UL);
  ldv_memset((void *)(& ldvarg14), 0, 8UL);
  tmp___1 = __VERIFIER_nondet_int();
  switch (tmp___1) {
  case 0: ;
  if (ldv_state_variable_7 == 2) {
    seq_read(state_fops_group2, ldvarg17, ldvarg16, ldvarg15);
    ldv_state_variable_7 = 2;
  } else {

  }
  goto ldv_33403;
  case 1: ;
  if (ldv_state_variable_7 == 1) {
    ldv_retval_2 = state_open(state_fops_group1, state_fops_group2);
    if (ldv_retval_2 == 0) {
      ldv_state_variable_7 = 2;
      ref_cnt = ref_cnt + 1;
    } else {

    }
  } else {

  }
  goto ldv_33403;
  case 2: ;
  if (ldv_state_variable_7 == 2) {
    single_release(state_fops_group1, state_fops_group2);
    ldv_state_variable_7 = 1;
    ref_cnt = ref_cnt - 1;
  } else {

  }
  goto ldv_33403;
  case 3: ;
  if (ldv_state_variable_7 == 2) {
    seq_lseek(state_fops_group2, ldvarg14, ldvarg13);
    ldv_state_variable_7 = 2;
  } else {

  }
  goto ldv_33403;
  default: 
  ldv_stop();
  }
  ldv_33403: ;
  return;
}
}
void ldv_main_exported_5(void) 
{ 
  int ldvarg34 ;
    klee_make_symbolic(&ldvarg34, sizeof(int), "ldvarg34");
  char *ldvarg38 ;
  void *tmp ;
  loff_t *ldvarg36 ;
  void *tmp___0 ;
  loff_t ldvarg35 ;
  size_t ldvarg37 ;
  int tmp___1 ;

  {
  tmp = ldv_init_zalloc(1UL);
  ldvarg38 = (char *)tmp;
  tmp___0 = ldv_init_zalloc(8UL);
  ldvarg36 = (loff_t *)tmp___0;
  ldv_memset((void *)(& ldvarg34), 0, 4UL);
  ldv_memset((void *)(& ldvarg35), 0, 8UL);
  ldv_memset((void *)(& ldvarg37), 0, 8UL);
  tmp___1 = __VERIFIER_nondet_int();
  switch (tmp___1) {
  case 0: ;
  if (ldv_state_variable_5 == 2) {
    seq_read(ep_fops_group2, ldvarg38, ldvarg37, ldvarg36);
    ldv_state_variable_5 = 2;
  } else {

  }
  goto ldv_33417;
  case 1: ;
  if (ldv_state_variable_5 == 1) {
    ldv_retval_26 = ep_open(ep_fops_group1, ep_fops_group2);
    if (ldv_retval_26 == 0) {
      ldv_state_variable_5 = 2;
      ref_cnt = ref_cnt + 1;
    } else {

    }
  } else {

  }
  goto ldv_33417;
  case 2: ;
  if (ldv_state_variable_5 == 2) {
    single_release(ep_fops_group1, ep_fops_group2);
    ldv_state_variable_5 = 1;
    ref_cnt = ref_cnt - 1;
  } else {

  }
  goto ldv_33417;
  case 3: ;
  if (ldv_state_variable_5 == 2) {
    seq_lseek(ep_fops_group2, ldvarg35, ldvarg34);
    ldv_state_variable_5 = 2;
  } else {

  }
  goto ldv_33417;
  default: 
  ldv_stop();
  }
  ldv_33417: ;
  return;
}
}
bool ldv_queue_work_on_131(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_3(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_delayed_work_on_132(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_3(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_work_on_133(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_3(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
void ldv_flush_workqueue_134(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
  flush_workqueue(ldv_func_arg1);
  call_and_disable_all_3(2);
  return;
}
}
bool ldv_queue_delayed_work_on_135(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_3(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
extern void *memset(void * , int  , size_t  ) ;
__inline static void ldv_error(void) 
{ 


  {
  ERROR: ;
  {reach_error();}
}
}
bool ldv_is_err(void const   *ptr ) 
{ 


  {
  return ((unsigned long )ptr > 2012UL);
}
}
void *ldv_err_ptr(long error ) 
{ 


  {
  return ((void *)(2012L - error));
}
}
long ldv_ptr_err(void const   *ptr ) 
{ 


  {
  return ((long )(2012UL - (unsigned long )ptr));
}
}
bool ldv_is_err_or_null(void const   *ptr ) 
{ 
  bool tmp ;
  int tmp___0 ;

  {
  if ((unsigned long )ptr == (unsigned long )((void const   *)0)) {
    tmp___0 = 1;
  } else {
    tmp = ldv_is_err(ptr);
    if ((int )tmp) {
      tmp___0 = 1;
    } else {
      tmp___0 = 0;
    }
  }
  return ((bool )tmp___0);
}
}
int ldv_module_refcounter  =    1;
void ldv_module_get(struct module *module ) 
{ 


  {
  if ((unsigned long )module != (unsigned long )((struct module *)0)) {
    ldv_module_refcounter = ldv_module_refcounter + 1;
  } else {

  }
  return;
}
}
int ldv_try_module_get(struct module *module ) 
{ 
  int module_get_succeeded ;
    klee_make_symbolic(&module_get_succeeded, sizeof(int), "module_get_succeeded");

  {
  if ((unsigned long )module != (unsigned long )((struct module *)0)) {
    module_get_succeeded = ldv_undef_int();
    if (module_get_succeeded == 1) {
      ldv_module_refcounter = ldv_module_refcounter + 1;
      return (1);
    } else {
      return (0);
    }
  } else {

  }
  return (0);
}
}
void ldv_module_put(struct module *module ) 
{ 


  {
  if ((unsigned long )module != (unsigned long )((struct module *)0)) {
    if (ldv_module_refcounter <= 1) {
      ldv_error();
    } else {

    }
    ldv_module_refcounter = ldv_module_refcounter - 1;
  } else {

  }
  return;
}
}
void ldv_module_put_and_exit(void) 
{ 


  {
  ldv_module_put((struct module *)1);
  LDV_STOP: ;
  goto LDV_STOP;
}
}
unsigned int ldv_module_refcount(void) 
{ 


  {
  return ((unsigned int )(ldv_module_refcounter + -1));
}
}
void ldv_check_final_state(void) 
{ 


  {
  if (ldv_module_refcounter != 1) {
    ldv_error();
  } else {

  }
  return;
}
}
#include "model/linux-4.2-rc1.tar.xz-08_1a-drivers--usb--dwc2--dwc2.ko-entry_point_true-unreach-call.cil.out.env.c"
#include <klee/klee.h>
#include "model/common.env.c"
