extern void abort(void);
#include <assert.h>
void reach_error() { assert(0); }
/* Generated by CIL v. 1.5.1 */
/* print_CIL_Input is false */

typedef unsigned char __u8;
    klee_make_symbolic(&__u8, sizeof(char), "__u8");
typedef unsigned short __u16;
    klee_make_symbolic(&__u16, sizeof(short), "__u16");
typedef int __s32;
    klee_make_symbolic(&__s32, sizeof(int), "__s32");
typedef unsigned int __u32;
    klee_make_symbolic(&__u32, sizeof(int), "__u32");
typedef unsigned long long __u64;
    klee_make_symbolic(&__u64, sizeof(long), "__u64");
typedef signed char s8;
    klee_make_symbolic(&s8, sizeof(char), "s8");
typedef unsigned char u8;
    klee_make_symbolic(&u8, sizeof(char), "u8");
typedef unsigned short u16;
    klee_make_symbolic(&u16, sizeof(short), "u16");
typedef int s32;
    klee_make_symbolic(&s32, sizeof(int), "s32");
typedef unsigned int u32;
    klee_make_symbolic(&u32, sizeof(int), "u32");
typedef long long s64;
    klee_make_symbolic(&s64, sizeof(long), "s64");
typedef unsigned long long u64;
    klee_make_symbolic(&u64, sizeof(long), "u64");
typedef long __kernel_long_t;
    klee_make_symbolic(&__kernel_long_t, sizeof(long), "__kernel_long_t");
typedef unsigned long __kernel_ulong_t;
    klee_make_symbolic(&__kernel_ulong_t, sizeof(long), "__kernel_ulong_t");
typedef int __kernel_pid_t;
    klee_make_symbolic(&__kernel_pid_t, sizeof(int), "__kernel_pid_t");
typedef unsigned int __kernel_uid32_t;
    klee_make_symbolic(&__kernel_uid32_t, sizeof(int), "__kernel_uid32_t");
typedef unsigned int __kernel_gid32_t;
    klee_make_symbolic(&__kernel_gid32_t, sizeof(int), "__kernel_gid32_t");
typedef __kernel_ulong_t __kernel_size_t;
typedef __kernel_long_t __kernel_ssize_t;
typedef long long __kernel_loff_t;
    klee_make_symbolic(&__kernel_loff_t, sizeof(long), "__kernel_loff_t");
typedef __kernel_long_t __kernel_time_t;
typedef __kernel_long_t __kernel_clock_t;
typedef int __kernel_timer_t;
    klee_make_symbolic(&__kernel_timer_t, sizeof(int), "__kernel_timer_t");
typedef int __kernel_clockid_t;
    klee_make_symbolic(&__kernel_clockid_t, sizeof(int), "__kernel_clockid_t");
struct kernel_symbol {
   unsigned long value ;
    klee_make_symbolic(&value, sizeof(long), "value");
   char const   *name ;
};
struct module;
typedef __u32 __kernel_dev_t;
typedef __kernel_dev_t dev_t;
typedef unsigned short umode_t;
    klee_make_symbolic(&umode_t, sizeof(short), "umode_t");
typedef __kernel_pid_t pid_t;
typedef __kernel_clockid_t clockid_t;
typedef _Bool bool;
typedef __kernel_uid32_t uid_t;
typedef __kernel_gid32_t gid_t;
typedef __kernel_loff_t loff_t;
typedef __kernel_size_t size_t;
typedef __kernel_ssize_t ssize_t;
typedef __kernel_time_t time_t;
typedef __s32 int32_t;
typedef __u32 uint32_t;
typedef unsigned long sector_t;
    klee_make_symbolic(&sector_t, sizeof(long), "sector_t");
typedef unsigned long blkcnt_t;
    klee_make_symbolic(&blkcnt_t, sizeof(long), "blkcnt_t");
typedef u64 dma_addr_t;
typedef unsigned int gfp_t;
    klee_make_symbolic(&gfp_t, sizeof(int), "gfp_t");
typedef unsigned int fmode_t;
    klee_make_symbolic(&fmode_t, sizeof(int), "fmode_t");
typedef unsigned int oom_flags_t;
    klee_make_symbolic(&oom_flags_t, sizeof(int), "oom_flags_t");
typedef u64 phys_addr_t;
typedef phys_addr_t resource_size_t;
struct __anonstruct_atomic_t_6 {
   int counter ;
    klee_make_symbolic(&counter, sizeof(int), "counter");
};
typedef struct __anonstruct_atomic_t_6 atomic_t;
struct __anonstruct_atomic64_t_7 {
   long counter ;
};
typedef struct __anonstruct_atomic64_t_7 atomic64_t;
struct list_head {
   struct list_head *next ;
   struct list_head *prev ;
};
struct hlist_node;
struct hlist_head {
   struct hlist_node *first ;
};
struct hlist_node {
   struct hlist_node *next ;
   struct hlist_node **pprev ;
};
struct callback_head {
   struct callback_head *next ;
   void (*func)(struct callback_head * ) ;
};
struct pt_regs {
   unsigned long r15 ;
    klee_make_symbolic(&r15, sizeof(long), "r15");
   unsigned long r14 ;
    klee_make_symbolic(&r14, sizeof(long), "r14");
   unsigned long r13 ;
    klee_make_symbolic(&r13, sizeof(long), "r13");
   unsigned long r12 ;
    klee_make_symbolic(&r12, sizeof(long), "r12");
   unsigned long bp ;
    klee_make_symbolic(&bp, sizeof(long), "bp");
   unsigned long bx ;
    klee_make_symbolic(&bx, sizeof(long), "bx");
   unsigned long r11 ;
    klee_make_symbolic(&r11, sizeof(long), "r11");
   unsigned long r10 ;
    klee_make_symbolic(&r10, sizeof(long), "r10");
   unsigned long r9 ;
    klee_make_symbolic(&r9, sizeof(long), "r9");
   unsigned long r8 ;
    klee_make_symbolic(&r8, sizeof(long), "r8");
   unsigned long ax ;
    klee_make_symbolic(&ax, sizeof(long), "ax");
   unsigned long cx ;
    klee_make_symbolic(&cx, sizeof(long), "cx");
   unsigned long dx ;
    klee_make_symbolic(&dx, sizeof(long), "dx");
   unsigned long si ;
    klee_make_symbolic(&si, sizeof(long), "si");
   unsigned long di ;
    klee_make_symbolic(&di, sizeof(long), "di");
   unsigned long orig_ax ;
    klee_make_symbolic(&orig_ax, sizeof(long), "orig_ax");
   unsigned long ip ;
    klee_make_symbolic(&ip, sizeof(long), "ip");
   unsigned long cs ;
    klee_make_symbolic(&cs, sizeof(long), "cs");
   unsigned long flags ;
    klee_make_symbolic(&flags, sizeof(long), "flags");
   unsigned long sp ;
    klee_make_symbolic(&sp, sizeof(long), "sp");
   unsigned long ss ;
    klee_make_symbolic(&ss, sizeof(long), "ss");
};
struct __anonstruct____missing_field_name_9 {
   unsigned int a ;
    klee_make_symbolic(&a, sizeof(int), "a");
   unsigned int b ;
    klee_make_symbolic(&b, sizeof(int), "b");
};
struct __anonstruct____missing_field_name_10 {
   u16 limit0 ;
   u16 base0 ;
   unsigned char base1 ;
    klee_make_symbolic(&base1, sizeof(char), "base1");
   unsigned char type : 4 ;
   unsigned char s : 1 ;
   unsigned char dpl : 2 ;
   unsigned char p : 1 ;
   unsigned char limit : 4 ;
   unsigned char avl : 1 ;
   unsigned char l : 1 ;
   unsigned char d : 1 ;
   unsigned char g : 1 ;
   unsigned char base2 ;
    klee_make_symbolic(&base2, sizeof(char), "base2");
};
union __anonunion____missing_field_name_8 {
   struct __anonstruct____missing_field_name_9 __annonCompField4 ;
   struct __anonstruct____missing_field_name_10 __annonCompField5 ;
};
struct desc_struct {
   union __anonunion____missing_field_name_8 __annonCompField6 ;
};
typedef unsigned long pteval_t;
    klee_make_symbolic(&pteval_t, sizeof(long), "pteval_t");
typedef unsigned long pgdval_t;
    klee_make_symbolic(&pgdval_t, sizeof(long), "pgdval_t");
typedef unsigned long pgprotval_t;
    klee_make_symbolic(&pgprotval_t, sizeof(long), "pgprotval_t");
struct __anonstruct_pte_t_11 {
   pteval_t pte ;
};
typedef struct __anonstruct_pte_t_11 pte_t;
struct pgprot {
   pgprotval_t pgprot ;
};
typedef struct pgprot pgprot_t;
struct __anonstruct_pgd_t_12 {
   pgdval_t pgd ;
};
typedef struct __anonstruct_pgd_t_12 pgd_t;
struct page;
typedef struct page *pgtable_t;
struct file;
struct seq_file;
struct thread_struct;
struct mm_struct;
struct task_struct;
struct cpumask;
struct qspinlock {
   atomic_t val ;
};
typedef struct qspinlock arch_spinlock_t;
struct qrwlock {
   atomic_t cnts ;
   arch_spinlock_t lock ;
};
typedef struct qrwlock arch_rwlock_t;
typedef void (*ctor_fn_t)(void);
struct _ddebug {
   char const   *modname ;
   char const   *function ;
   char const   *filename ;
   char const   *format ;
   unsigned int lineno : 18 ;
   unsigned char flags ;
};
struct device;
struct file_operations;
struct completion;
struct lockdep_map;
struct kernel_vm86_regs {
   struct pt_regs pt ;
   unsigned short es ;
    klee_make_symbolic(&es, sizeof(short), "es");
   unsigned short __esh ;
    klee_make_symbolic(&__esh, sizeof(short), "__esh");
   unsigned short ds ;
    klee_make_symbolic(&ds, sizeof(short), "ds");
   unsigned short __dsh ;
    klee_make_symbolic(&__dsh, sizeof(short), "__dsh");
   unsigned short fs ;
    klee_make_symbolic(&fs, sizeof(short), "fs");
   unsigned short __fsh ;
    klee_make_symbolic(&__fsh, sizeof(short), "__fsh");
   unsigned short gs ;
    klee_make_symbolic(&gs, sizeof(short), "gs");
   unsigned short __gsh ;
    klee_make_symbolic(&__gsh, sizeof(short), "__gsh");
};
union __anonunion____missing_field_name_15 {
   struct pt_regs *regs ;
   struct kernel_vm86_regs *vm86 ;
};
struct math_emu_info {
   long ___orig_eip ;
    klee_make_symbolic(&___orig_eip, sizeof(long), "___orig_eip");
   union __anonunion____missing_field_name_15 __annonCompField7 ;
};
struct bug_entry {
   int bug_addr_disp ;
    klee_make_symbolic(&bug_addr_disp, sizeof(int), "bug_addr_disp");
   int file_disp ;
    klee_make_symbolic(&file_disp, sizeof(int), "file_disp");
   unsigned short line ;
    klee_make_symbolic(&line, sizeof(short), "line");
   unsigned short flags ;
};
struct cpumask {
   unsigned long bits[128U] ;
};
typedef struct cpumask cpumask_t;
typedef struct cpumask *cpumask_var_t;
struct fregs_state {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20U] ;
   u32 status ;
};
struct __anonstruct____missing_field_name_25 {
   u64 rip ;
   u64 rdp ;
};
struct __anonstruct____missing_field_name_26 {
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
};
union __anonunion____missing_field_name_24 {
   struct __anonstruct____missing_field_name_25 __annonCompField11 ;
   struct __anonstruct____missing_field_name_26 __annonCompField12 ;
};
union __anonunion____missing_field_name_27 {
   u32 padding1[12U] ;
   u32 sw_reserved[12U] ;
};
struct fxregs_state {
   u16 cwd ;
   u16 swd ;
   u16 twd ;
   u16 fop ;
   union __anonunion____missing_field_name_24 __annonCompField13 ;
   u32 mxcsr ;
   u32 mxcsr_mask ;
   u32 st_space[32U] ;
   u32 xmm_space[64U] ;
   u32 padding[12U] ;
   union __anonunion____missing_field_name_27 __annonCompField14 ;
};
struct swregs_state {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20U] ;
   u8 ftop ;
   u8 changed ;
   u8 lookahead ;
   u8 no_update ;
   u8 rm ;
   u8 alimit ;
   struct math_emu_info *info ;
   u32 entry_eip ;
};
struct xstate_header {
   u64 xfeatures ;
   u64 xcomp_bv ;
   u64 reserved[6U] ;
};
struct xregs_state {
   struct fxregs_state i387 ;
   struct xstate_header header ;
   u8 __reserved[464U] ;
};
union fpregs_state {
   struct fregs_state fsave ;
   struct fxregs_state fxsave ;
   struct swregs_state soft ;
   struct xregs_state xsave ;
};
struct fpu {
   union fpregs_state state ;
   unsigned int last_cpu ;
    klee_make_symbolic(&last_cpu, sizeof(int), "last_cpu");
   unsigned char fpstate_active ;
    klee_make_symbolic(&fpstate_active, sizeof(char), "fpstate_active");
   unsigned char fpregs_active ;
    klee_make_symbolic(&fpregs_active, sizeof(char), "fpregs_active");
   unsigned char counter ;
};
struct seq_operations;
struct perf_event;
struct thread_struct {
   struct desc_struct tls_array[3U] ;
   unsigned long sp0 ;
    klee_make_symbolic(&sp0, sizeof(long), "sp0");
   unsigned long sp ;
   unsigned short es ;
   unsigned short ds ;
   unsigned short fsindex ;
    klee_make_symbolic(&fsindex, sizeof(short), "fsindex");
   unsigned short gsindex ;
    klee_make_symbolic(&gsindex, sizeof(short), "gsindex");
   unsigned long fs ;
   unsigned long gs ;
   struct fpu fpu ;
   struct perf_event *ptrace_bps[4U] ;
   unsigned long debugreg6 ;
    klee_make_symbolic(&debugreg6, sizeof(long), "debugreg6");
   unsigned long ptrace_dr7 ;
    klee_make_symbolic(&ptrace_dr7, sizeof(long), "ptrace_dr7");
   unsigned long cr2 ;
    klee_make_symbolic(&cr2, sizeof(long), "cr2");
   unsigned long trap_nr ;
    klee_make_symbolic(&trap_nr, sizeof(long), "trap_nr");
   unsigned long error_code ;
    klee_make_symbolic(&error_code, sizeof(long), "error_code");
   unsigned long *io_bitmap_ptr ;
   unsigned long iopl ;
    klee_make_symbolic(&iopl, sizeof(long), "iopl");
   unsigned int io_bitmap_max ;
    klee_make_symbolic(&io_bitmap_max, sizeof(int), "io_bitmap_max");
};
typedef atomic64_t atomic_long_t;
struct stack_trace {
   unsigned int nr_entries ;
    klee_make_symbolic(&nr_entries, sizeof(int), "nr_entries");
   unsigned int max_entries ;
    klee_make_symbolic(&max_entries, sizeof(int), "max_entries");
   unsigned long *entries ;
   int skip ;
    klee_make_symbolic(&skip, sizeof(int), "skip");
};
struct lockdep_subclass_key {
   char __one_byte ;
    klee_make_symbolic(&__one_byte, sizeof(char), "__one_byte");
};
struct lock_class_key {
   struct lockdep_subclass_key subkeys[8U] ;
};
struct lock_class {
   struct list_head hash_entry ;
   struct list_head lock_entry ;
   struct lockdep_subclass_key *key ;
   unsigned int subclass ;
    klee_make_symbolic(&subclass, sizeof(int), "subclass");
   unsigned int dep_gen_id ;
    klee_make_symbolic(&dep_gen_id, sizeof(int), "dep_gen_id");
   unsigned long usage_mask ;
    klee_make_symbolic(&usage_mask, sizeof(long), "usage_mask");
   struct stack_trace usage_traces[13U] ;
   struct list_head locks_after ;
   struct list_head locks_before ;
   unsigned int version ;
    klee_make_symbolic(&version, sizeof(int), "version");
   unsigned long ops ;
    klee_make_symbolic(&ops, sizeof(long), "ops");
   char const   *name ;
   int name_version ;
    klee_make_symbolic(&name_version, sizeof(int), "name_version");
   unsigned long contention_point[4U] ;
   unsigned long contending_point[4U] ;
};
struct lockdep_map {
   struct lock_class_key *key ;
   struct lock_class *class_cache[2U] ;
   char const   *name ;
   int cpu ;
    klee_make_symbolic(&cpu, sizeof(int), "cpu");
   unsigned long ip ;
};
struct held_lock {
   u64 prev_chain_key ;
   unsigned long acquire_ip ;
    klee_make_symbolic(&acquire_ip, sizeof(long), "acquire_ip");
   struct lockdep_map *instance ;
   struct lockdep_map *nest_lock ;
   u64 waittime_stamp ;
   u64 holdtime_stamp ;
   unsigned short class_idx : 13 ;
   unsigned char irq_context : 2 ;
   unsigned char trylock : 1 ;
   unsigned char read : 2 ;
   unsigned char check : 1 ;
   unsigned char hardirqs_off : 1 ;
   unsigned short references : 12 ;
   unsigned int pin_count ;
    klee_make_symbolic(&pin_count, sizeof(int), "pin_count");
};
struct raw_spinlock {
   arch_spinlock_t raw_lock ;
   unsigned int magic ;
    klee_make_symbolic(&magic, sizeof(int), "magic");
   unsigned int owner_cpu ;
    klee_make_symbolic(&owner_cpu, sizeof(int), "owner_cpu");
   void *owner ;
   struct lockdep_map dep_map ;
};
typedef struct raw_spinlock raw_spinlock_t;
struct __anonstruct____missing_field_name_31 {
   u8 __padding[24U] ;
   struct lockdep_map dep_map ;
};
union __anonunion____missing_field_name_30 {
   struct raw_spinlock rlock ;
   struct __anonstruct____missing_field_name_31 __annonCompField16 ;
};
struct spinlock {
   union __anonunion____missing_field_name_30 __annonCompField17 ;
};
typedef struct spinlock spinlock_t;
struct __anonstruct_rwlock_t_32 {
   arch_rwlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
   struct lockdep_map dep_map ;
};
typedef struct __anonstruct_rwlock_t_32 rwlock_t;
struct optimistic_spin_queue {
   atomic_t tail ;
};
struct mutex {
   atomic_t count ;
   spinlock_t wait_lock ;
   struct list_head wait_list ;
   struct task_struct *owner ;
   void *magic ;
   struct lockdep_map dep_map ;
};
struct mutex_waiter {
   struct list_head list ;
   struct task_struct *task ;
   void *magic ;
};
struct vm_area_struct;
struct timespec;
struct compat_timespec;
struct __anonstruct_futex_34 {
   u32 *uaddr ;
   u32 val ;
   u32 flags ;
   u32 bitset ;
   u64 time ;
   u32 *uaddr2 ;
};
struct __anonstruct_nanosleep_35 {
   clockid_t clockid ;
   struct timespec *rmtp ;
   struct compat_timespec *compat_rmtp ;
   u64 expires ;
};
struct pollfd;
struct __anonstruct_poll_36 {
   struct pollfd *ufds ;
   int nfds ;
    klee_make_symbolic(&nfds, sizeof(int), "nfds");
   int has_timeout ;
    klee_make_symbolic(&has_timeout, sizeof(int), "has_timeout");
   unsigned long tv_sec ;
    klee_make_symbolic(&tv_sec, sizeof(long), "tv_sec");
   unsigned long tv_nsec ;
    klee_make_symbolic(&tv_nsec, sizeof(long), "tv_nsec");
};
union __anonunion____missing_field_name_33 {
   struct __anonstruct_futex_34 futex ;
   struct __anonstruct_nanosleep_35 nanosleep ;
   struct __anonstruct_poll_36 poll ;
};
struct restart_block {
   long (*fn)(struct restart_block * ) ;
   union __anonunion____missing_field_name_33 __annonCompField18 ;
};
struct __wait_queue;
typedef struct __wait_queue wait_queue_t;
struct __wait_queue {
   unsigned int flags ;
   void *private ;
   int (*func)(wait_queue_t * , unsigned int  , int  , void * ) ;
   struct list_head task_list ;
};
struct __wait_queue_head {
   spinlock_t lock ;
   struct list_head task_list ;
};
typedef struct __wait_queue_head wait_queue_head_t;
struct seqcount {
   unsigned int sequence ;
    klee_make_symbolic(&sequence, sizeof(int), "sequence");
   struct lockdep_map dep_map ;
};
typedef struct seqcount seqcount_t;
struct __anonstruct_seqlock_t_45 {
   struct seqcount seqcount ;
   spinlock_t lock ;
};
typedef struct __anonstruct_seqlock_t_45 seqlock_t;
struct __anonstruct_nodemask_t_46 {
   unsigned long bits[16U] ;
};
typedef struct __anonstruct_nodemask_t_46 nodemask_t;
struct rw_semaphore;
struct rw_semaphore {
   long count ;
    klee_make_symbolic(&count, sizeof(long), "count");
   struct list_head wait_list ;
   raw_spinlock_t wait_lock ;
   struct optimistic_spin_queue osq ;
   struct task_struct *owner ;
   struct lockdep_map dep_map ;
};
struct completion {
   unsigned int done ;
    klee_make_symbolic(&done, sizeof(int), "done");
   wait_queue_head_t wait ;
};
struct timespec {
   __kernel_time_t tv_sec ;
   long tv_nsec ;
};
union ktime {
   s64 tv64 ;
};
typedef union ktime ktime_t;
struct timer_list {
   struct hlist_node entry ;
   unsigned long expires ;
    klee_make_symbolic(&expires, sizeof(long), "expires");
   void (*function)(unsigned long  ) ;
   unsigned long data ;
    klee_make_symbolic(&data, sizeof(long), "data");
   u32 flags ;
   int slack ;
    klee_make_symbolic(&slack, sizeof(int), "slack");
   int start_pid ;
    klee_make_symbolic(&start_pid, sizeof(int), "start_pid");
   void *start_site ;
   char start_comm[16U] ;
   struct lockdep_map lockdep_map ;
};
struct hrtimer;
enum hrtimer_restart;
struct rb_node {
   unsigned long __rb_parent_color ;
    klee_make_symbolic(&__rb_parent_color, sizeof(long), "__rb_parent_color");
   struct rb_node *rb_right ;
   struct rb_node *rb_left ;
};
struct rb_root {
   struct rb_node *rb_node ;
};
struct nsproxy;
struct workqueue_struct;
struct work_struct;
struct work_struct {
   atomic_long_t data ;
   struct list_head entry ;
   void (*func)(struct work_struct * ) ;
   struct lockdep_map lockdep_map ;
};
struct delayed_work {
   struct work_struct work ;
   struct timer_list timer ;
   struct workqueue_struct *wq ;
   int cpu ;
};
struct execute_work {
   struct work_struct work ;
};
struct resource {
   resource_size_t start ;
   resource_size_t end ;
   char const   *name ;
   unsigned long flags ;
   struct resource *parent ;
   struct resource *sibling ;
   struct resource *child ;
};
struct pci_dev;
struct pm_message {
   int event ;
    klee_make_symbolic(&event, sizeof(int), "event");
};
typedef struct pm_message pm_message_t;
struct dev_pm_ops {
   int (*prepare)(struct device * ) ;
   void (*complete)(struct device * ) ;
   int (*suspend)(struct device * ) ;
   int (*resume)(struct device * ) ;
   int (*freeze)(struct device * ) ;
   int (*thaw)(struct device * ) ;
   int (*poweroff)(struct device * ) ;
   int (*restore)(struct device * ) ;
   int (*suspend_late)(struct device * ) ;
   int (*resume_early)(struct device * ) ;
   int (*freeze_late)(struct device * ) ;
   int (*thaw_early)(struct device * ) ;
   int (*poweroff_late)(struct device * ) ;
   int (*restore_early)(struct device * ) ;
   int (*suspend_noirq)(struct device * ) ;
   int (*resume_noirq)(struct device * ) ;
   int (*freeze_noirq)(struct device * ) ;
   int (*thaw_noirq)(struct device * ) ;
   int (*poweroff_noirq)(struct device * ) ;
   int (*restore_noirq)(struct device * ) ;
   int (*runtime_suspend)(struct device * ) ;
   int (*runtime_resume)(struct device * ) ;
   int (*runtime_idle)(struct device * ) ;
};
enum rpm_status {
    RPM_ACTIVE = 0,
    RPM_RESUMING = 1,
    RPM_SUSPENDED = 2,
    RPM_SUSPENDING = 3
} ;
enum rpm_request {
    RPM_REQ_NONE = 0,
    RPM_REQ_IDLE = 1,
    RPM_REQ_SUSPEND = 2,
    RPM_REQ_AUTOSUSPEND = 3,
    RPM_REQ_RESUME = 4
} ;
struct wakeup_source;
struct wake_irq;
struct pm_subsys_data {
   spinlock_t lock ;
   unsigned int refcount ;
    klee_make_symbolic(&refcount, sizeof(int), "refcount");
   struct list_head clock_list ;
};
struct dev_pm_qos;
struct dev_pm_info {
   pm_message_t power_state ;
   unsigned char can_wakeup : 1 ;
   unsigned char async_suspend : 1 ;
   bool is_prepared ;
   bool is_suspended ;
   bool is_noirq_suspended ;
   bool is_late_suspended ;
   bool ignore_children ;
   bool early_init ;
   bool direct_complete ;
   spinlock_t lock ;
   struct list_head entry ;
   struct completion completion ;
   struct wakeup_source *wakeup ;
   bool wakeup_path ;
   bool syscore ;
   struct timer_list suspend_timer ;
   unsigned long timer_expires ;
    klee_make_symbolic(&timer_expires, sizeof(long), "timer_expires");
   struct work_struct work ;
   wait_queue_head_t wait_queue ;
   struct wake_irq *wakeirq ;
   atomic_t usage_count ;
   atomic_t child_count ;
   unsigned char disable_depth : 3 ;
   unsigned char idle_notification : 1 ;
   unsigned char request_pending : 1 ;
   unsigned char deferred_resume : 1 ;
   unsigned char run_wake : 1 ;
   unsigned char runtime_auto : 1 ;
   unsigned char no_callbacks : 1 ;
   unsigned char irq_safe : 1 ;
   unsigned char use_autosuspend : 1 ;
   unsigned char timer_autosuspends : 1 ;
   unsigned char memalloc_noio : 1 ;
   enum rpm_request request ;
   enum rpm_status runtime_status ;
   int runtime_error ;
    klee_make_symbolic(&runtime_error, sizeof(int), "runtime_error");
   int autosuspend_delay ;
    klee_make_symbolic(&autosuspend_delay, sizeof(int), "autosuspend_delay");
   unsigned long last_busy ;
    klee_make_symbolic(&last_busy, sizeof(long), "last_busy");
   unsigned long active_jiffies ;
    klee_make_symbolic(&active_jiffies, sizeof(long), "active_jiffies");
   unsigned long suspended_jiffies ;
    klee_make_symbolic(&suspended_jiffies, sizeof(long), "suspended_jiffies");
   unsigned long accounting_timestamp ;
    klee_make_symbolic(&accounting_timestamp, sizeof(long), "accounting_timestamp");
   struct pm_subsys_data *subsys_data ;
   void (*set_latency_tolerance)(struct device * , s32  ) ;
   struct dev_pm_qos *qos ;
};
struct dev_pm_domain {
   struct dev_pm_ops ops ;
   void (*detach)(struct device * , bool  ) ;
   int (*activate)(struct device * ) ;
   void (*sync)(struct device * ) ;
   void (*dismiss)(struct device * ) ;
};
struct pci_bus;
struct __anonstruct_mm_context_t_113 {
   void *ldt ;
   int size ;
    klee_make_symbolic(&size, sizeof(int), "size");
   unsigned short ia32_compat ;
    klee_make_symbolic(&ia32_compat, sizeof(short), "ia32_compat");
   struct mutex lock ;
   void *vdso ;
   atomic_t perf_rdpmc_allowed ;
};
typedef struct __anonstruct_mm_context_t_113 mm_context_t;
struct bio_vec;
struct llist_node;
struct llist_node {
   struct llist_node *next ;
};
struct call_single_data {
   struct llist_node llist ;
   void (*func)(void * ) ;
   void *info ;
   unsigned int flags ;
};
struct kmem_cache;
struct kernel_cap_struct {
   __u32 cap[2U] ;
};
typedef struct kernel_cap_struct kernel_cap_t;
struct inode;
struct dentry;
struct user_namespace;
struct plist_node {
   int prio ;
    klee_make_symbolic(&prio, sizeof(int), "prio");
   struct list_head prio_list ;
   struct list_head node_list ;
};
struct arch_uprobe_task {
   unsigned long saved_scratch_register ;
    klee_make_symbolic(&saved_scratch_register, sizeof(long), "saved_scratch_register");
   unsigned int saved_trap_nr ;
    klee_make_symbolic(&saved_trap_nr, sizeof(int), "saved_trap_nr");
   unsigned int saved_tf ;
    klee_make_symbolic(&saved_tf, sizeof(int), "saved_tf");
};
enum uprobe_task_state {
    UTASK_RUNNING = 0,
    UTASK_SSTEP = 1,
    UTASK_SSTEP_ACK = 2,
    UTASK_SSTEP_TRAPPED = 3
} ;
struct __anonstruct____missing_field_name_146 {
   struct arch_uprobe_task autask ;
   unsigned long vaddr ;
    klee_make_symbolic(&vaddr, sizeof(long), "vaddr");
};
struct __anonstruct____missing_field_name_147 {
   struct callback_head dup_xol_work ;
   unsigned long dup_xol_addr ;
    klee_make_symbolic(&dup_xol_addr, sizeof(long), "dup_xol_addr");
};
union __anonunion____missing_field_name_145 {
   struct __anonstruct____missing_field_name_146 __annonCompField33 ;
   struct __anonstruct____missing_field_name_147 __annonCompField34 ;
};
struct uprobe;
struct return_instance;
struct uprobe_task {
   enum uprobe_task_state state ;
   union __anonunion____missing_field_name_145 __annonCompField35 ;
   struct uprobe *active_uprobe ;
   unsigned long xol_vaddr ;
    klee_make_symbolic(&xol_vaddr, sizeof(long), "xol_vaddr");
   struct return_instance *return_instances ;
   unsigned int depth ;
    klee_make_symbolic(&depth, sizeof(int), "depth");
};
struct xol_area;
struct uprobes_state {
   struct xol_area *xol_area ;
};
struct address_space;
struct mem_cgroup;
typedef void compound_page_dtor(struct page * );
union __anonunion____missing_field_name_148 {
   struct address_space *mapping ;
   void *s_mem ;
};
union __anonunion____missing_field_name_150 {
   unsigned long index ;
    klee_make_symbolic(&index, sizeof(long), "index");
   void *freelist ;
   bool pfmemalloc ;
};
struct __anonstruct____missing_field_name_154 {
   unsigned short inuse ;
    klee_make_symbolic(&inuse, sizeof(short), "inuse");
   unsigned short objects : 15 ;
   unsigned char frozen : 1 ;
};
union __anonunion____missing_field_name_153 {
   atomic_t _mapcount ;
   struct __anonstruct____missing_field_name_154 __annonCompField38 ;
   int units ;
    klee_make_symbolic(&units, sizeof(int), "units");
};
struct __anonstruct____missing_field_name_152 {
   union __anonunion____missing_field_name_153 __annonCompField39 ;
   atomic_t _count ;
};
union __anonunion____missing_field_name_151 {
   unsigned long counters ;
    klee_make_symbolic(&counters, sizeof(long), "counters");
   struct __anonstruct____missing_field_name_152 __annonCompField40 ;
   unsigned int active ;
    klee_make_symbolic(&active, sizeof(int), "active");
};
struct __anonstruct____missing_field_name_149 {
   union __anonunion____missing_field_name_150 __annonCompField37 ;
   union __anonunion____missing_field_name_151 __annonCompField41 ;
};
struct __anonstruct____missing_field_name_156 {
   struct page *next ;
   int pages ;
    klee_make_symbolic(&pages, sizeof(int), "pages");
   int pobjects ;
    klee_make_symbolic(&pobjects, sizeof(int), "pobjects");
};
struct slab;
struct __anonstruct____missing_field_name_157 {
   compound_page_dtor *compound_dtor ;
   unsigned long compound_order ;
    klee_make_symbolic(&compound_order, sizeof(long), "compound_order");
};
union __anonunion____missing_field_name_155 {
   struct list_head lru ;
   struct __anonstruct____missing_field_name_156 __annonCompField43 ;
   struct slab *slab_page ;
   struct callback_head callback_head ;
   struct __anonstruct____missing_field_name_157 __annonCompField44 ;
   pgtable_t pmd_huge_pte ;
};
union __anonunion____missing_field_name_158 {
   unsigned long private ;
    klee_make_symbolic(&private, sizeof(long), "private");
   spinlock_t *ptl ;
   struct kmem_cache *slab_cache ;
   struct page *first_page ;
};
struct page {
   unsigned long flags ;
   union __anonunion____missing_field_name_148 __annonCompField36 ;
   struct __anonstruct____missing_field_name_149 __annonCompField42 ;
   union __anonunion____missing_field_name_155 __annonCompField45 ;
   union __anonunion____missing_field_name_158 __annonCompField46 ;
   struct mem_cgroup *mem_cgroup ;
};
struct page_frag {
   struct page *page ;
   __u32 offset ;
   __u32 size ;
};
struct __anonstruct_shared_159 {
   struct rb_node rb ;
   unsigned long rb_subtree_last ;
    klee_make_symbolic(&rb_subtree_last, sizeof(long), "rb_subtree_last");
};
struct anon_vma;
struct vm_operations_struct;
struct mempolicy;
struct vm_area_struct {
   unsigned long vm_start ;
    klee_make_symbolic(&vm_start, sizeof(long), "vm_start");
   unsigned long vm_end ;
    klee_make_symbolic(&vm_end, sizeof(long), "vm_end");
   struct vm_area_struct *vm_next ;
   struct vm_area_struct *vm_prev ;
   struct rb_node vm_rb ;
   unsigned long rb_subtree_gap ;
    klee_make_symbolic(&rb_subtree_gap, sizeof(long), "rb_subtree_gap");
   struct mm_struct *vm_mm ;
   pgprot_t vm_page_prot ;
   unsigned long vm_flags ;
    klee_make_symbolic(&vm_flags, sizeof(long), "vm_flags");
   struct __anonstruct_shared_159 shared ;
   struct list_head anon_vma_chain ;
   struct anon_vma *anon_vma ;
   struct vm_operations_struct  const  *vm_ops ;
   unsigned long vm_pgoff ;
    klee_make_symbolic(&vm_pgoff, sizeof(long), "vm_pgoff");
   struct file *vm_file ;
   void *vm_private_data ;
   struct mempolicy *vm_policy ;
};
struct core_thread {
   struct task_struct *task ;
   struct core_thread *next ;
};
struct core_state {
   atomic_t nr_threads ;
   struct core_thread dumper ;
   struct completion startup ;
};
struct task_rss_stat {
   int events ;
    klee_make_symbolic(&events, sizeof(int), "events");
   int count[3U] ;
};
struct mm_rss_stat {
   atomic_long_t count[3U] ;
};
struct kioctx_table;
struct linux_binfmt;
struct mmu_notifier_mm;
struct mm_struct {
   struct vm_area_struct *mmap ;
   struct rb_root mm_rb ;
   u32 vmacache_seqnum ;
   unsigned long (*get_unmapped_area)(struct file * , unsigned long  , unsigned long  ,
                                      unsigned long  , unsigned long  ) ;
   unsigned long mmap_base ;
    klee_make_symbolic(&mmap_base, sizeof(long), "mmap_base");
   unsigned long mmap_legacy_base ;
    klee_make_symbolic(&mmap_legacy_base, sizeof(long), "mmap_legacy_base");
   unsigned long task_size ;
    klee_make_symbolic(&task_size, sizeof(long), "task_size");
   unsigned long highest_vm_end ;
    klee_make_symbolic(&highest_vm_end, sizeof(long), "highest_vm_end");
   pgd_t *pgd ;
   atomic_t mm_users ;
   atomic_t mm_count ;
   atomic_long_t nr_ptes ;
   atomic_long_t nr_pmds ;
   int map_count ;
    klee_make_symbolic(&map_count, sizeof(int), "map_count");
   spinlock_t page_table_lock ;
   struct rw_semaphore mmap_sem ;
   struct list_head mmlist ;
   unsigned long hiwater_rss ;
    klee_make_symbolic(&hiwater_rss, sizeof(long), "hiwater_rss");
   unsigned long hiwater_vm ;
    klee_make_symbolic(&hiwater_vm, sizeof(long), "hiwater_vm");
   unsigned long total_vm ;
    klee_make_symbolic(&total_vm, sizeof(long), "total_vm");
   unsigned long locked_vm ;
    klee_make_symbolic(&locked_vm, sizeof(long), "locked_vm");
   unsigned long pinned_vm ;
    klee_make_symbolic(&pinned_vm, sizeof(long), "pinned_vm");
   unsigned long shared_vm ;
    klee_make_symbolic(&shared_vm, sizeof(long), "shared_vm");
   unsigned long exec_vm ;
    klee_make_symbolic(&exec_vm, sizeof(long), "exec_vm");
   unsigned long stack_vm ;
    klee_make_symbolic(&stack_vm, sizeof(long), "stack_vm");
   unsigned long def_flags ;
    klee_make_symbolic(&def_flags, sizeof(long), "def_flags");
   unsigned long start_code ;
    klee_make_symbolic(&start_code, sizeof(long), "start_code");
   unsigned long end_code ;
    klee_make_symbolic(&end_code, sizeof(long), "end_code");
   unsigned long start_data ;
    klee_make_symbolic(&start_data, sizeof(long), "start_data");
   unsigned long end_data ;
    klee_make_symbolic(&end_data, sizeof(long), "end_data");
   unsigned long start_brk ;
    klee_make_symbolic(&start_brk, sizeof(long), "start_brk");
   unsigned long brk ;
    klee_make_symbolic(&brk, sizeof(long), "brk");
   unsigned long start_stack ;
    klee_make_symbolic(&start_stack, sizeof(long), "start_stack");
   unsigned long arg_start ;
    klee_make_symbolic(&arg_start, sizeof(long), "arg_start");
   unsigned long arg_end ;
    klee_make_symbolic(&arg_end, sizeof(long), "arg_end");
   unsigned long env_start ;
    klee_make_symbolic(&env_start, sizeof(long), "env_start");
   unsigned long env_end ;
    klee_make_symbolic(&env_end, sizeof(long), "env_end");
   unsigned long saved_auxv[46U] ;
   struct mm_rss_stat rss_stat ;
   struct linux_binfmt *binfmt ;
   cpumask_var_t cpu_vm_mask_var ;
   mm_context_t context ;
   unsigned long flags ;
   struct core_state *core_state ;
   spinlock_t ioctx_lock ;
   struct kioctx_table *ioctx_table ;
   struct task_struct *owner ;
   struct file *exe_file ;
   struct mmu_notifier_mm *mmu_notifier_mm ;
   struct cpumask cpumask_allocation ;
   unsigned long numa_next_scan ;
    klee_make_symbolic(&numa_next_scan, sizeof(long), "numa_next_scan");
   unsigned long numa_scan_offset ;
    klee_make_symbolic(&numa_scan_offset, sizeof(long), "numa_scan_offset");
   int numa_scan_seq ;
    klee_make_symbolic(&numa_scan_seq, sizeof(int), "numa_scan_seq");
   bool tlb_flush_pending ;
   struct uprobes_state uprobes_state ;
   void *bd_addr ;
};
typedef unsigned long cputime_t;
    klee_make_symbolic(&cputime_t, sizeof(long), "cputime_t");
struct __anonstruct_kuid_t_161 {
   uid_t val ;
};
typedef struct __anonstruct_kuid_t_161 kuid_t;
struct __anonstruct_kgid_t_162 {
   gid_t val ;
};
typedef struct __anonstruct_kgid_t_162 kgid_t;
struct sem_undo_list;
struct sysv_sem {
   struct sem_undo_list *undo_list ;
};
struct user_struct;
struct sysv_shm {
   struct list_head shm_clist ;
};
struct __anonstruct_sigset_t_163 {
   unsigned long sig[1U] ;
};
typedef struct __anonstruct_sigset_t_163 sigset_t;
struct siginfo;
typedef void __signalfn_t(int  );
typedef __signalfn_t *__sighandler_t;
typedef void __restorefn_t(void);
typedef __restorefn_t *__sigrestore_t;
union sigval {
   int sival_int ;
    klee_make_symbolic(&sival_int, sizeof(int), "sival_int");
   void *sival_ptr ;
};
typedef union sigval sigval_t;
struct __anonstruct__kill_165 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
};
struct __anonstruct__timer_166 {
   __kernel_timer_t _tid ;
   int _overrun ;
    klee_make_symbolic(&_overrun, sizeof(int), "_overrun");
   char _pad[0U] ;
   sigval_t _sigval ;
   int _sys_private ;
    klee_make_symbolic(&_sys_private, sizeof(int), "_sys_private");
};
struct __anonstruct__rt_167 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
   sigval_t _sigval ;
};
struct __anonstruct__sigchld_168 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
   int _status ;
    klee_make_symbolic(&_status, sizeof(int), "_status");
   __kernel_clock_t _utime ;
   __kernel_clock_t _stime ;
};
struct __anonstruct__addr_bnd_170 {
   void *_lower ;
   void *_upper ;
};
struct __anonstruct__sigfault_169 {
   void *_addr ;
   short _addr_lsb ;
    klee_make_symbolic(&_addr_lsb, sizeof(short), "_addr_lsb");
   struct __anonstruct__addr_bnd_170 _addr_bnd ;
};
struct __anonstruct__sigpoll_171 {
   long _band ;
    klee_make_symbolic(&_band, sizeof(long), "_band");
   int _fd ;
    klee_make_symbolic(&_fd, sizeof(int), "_fd");
};
struct __anonstruct__sigsys_172 {
   void *_call_addr ;
   int _syscall ;
    klee_make_symbolic(&_syscall, sizeof(int), "_syscall");
   unsigned int _arch ;
    klee_make_symbolic(&_arch, sizeof(int), "_arch");
};
union __anonunion__sifields_164 {
   int _pad[28U] ;
   struct __anonstruct__kill_165 _kill ;
   struct __anonstruct__timer_166 _timer ;
   struct __anonstruct__rt_167 _rt ;
   struct __anonstruct__sigchld_168 _sigchld ;
   struct __anonstruct__sigfault_169 _sigfault ;
   struct __anonstruct__sigpoll_171 _sigpoll ;
   struct __anonstruct__sigsys_172 _sigsys ;
};
struct siginfo {
   int si_signo ;
    klee_make_symbolic(&si_signo, sizeof(int), "si_signo");
   int si_errno ;
    klee_make_symbolic(&si_errno, sizeof(int), "si_errno");
   int si_code ;
    klee_make_symbolic(&si_code, sizeof(int), "si_code");
   union __anonunion__sifields_164 _sifields ;
};
typedef struct siginfo siginfo_t;
struct sigpending {
   struct list_head list ;
   sigset_t signal ;
};
struct sigaction {
   __sighandler_t sa_handler ;
   unsigned long sa_flags ;
    klee_make_symbolic(&sa_flags, sizeof(long), "sa_flags");
   __sigrestore_t sa_restorer ;
   sigset_t sa_mask ;
};
struct k_sigaction {
   struct sigaction sa ;
};
enum pid_type {
    PIDTYPE_PID = 0,
    PIDTYPE_PGID = 1,
    PIDTYPE_SID = 2,
    PIDTYPE_MAX = 3
} ;
struct pid_namespace;
struct upid {
   int nr ;
    klee_make_symbolic(&nr, sizeof(int), "nr");
   struct pid_namespace *ns ;
   struct hlist_node pid_chain ;
};
struct pid {
   atomic_t count ;
   unsigned int level ;
    klee_make_symbolic(&level, sizeof(int), "level");
   struct hlist_head tasks[3U] ;
   struct callback_head rcu ;
   struct upid numbers[1U] ;
};
struct pid_link {
   struct hlist_node node ;
   struct pid *pid ;
};
struct percpu_counter {
   raw_spinlock_t lock ;
   s64 count ;
   struct list_head list ;
   s32 *counters ;
};
struct seccomp_filter;
struct seccomp {
   int mode ;
    klee_make_symbolic(&mode, sizeof(int), "mode");
   struct seccomp_filter *filter ;
};
struct rt_mutex_waiter;
struct rlimit {
   __kernel_ulong_t rlim_cur ;
   __kernel_ulong_t rlim_max ;
};
struct timerqueue_node {
   struct rb_node node ;
   ktime_t expires ;
};
struct timerqueue_head {
   struct rb_root head ;
   struct timerqueue_node *next ;
};
struct hrtimer_clock_base;
struct hrtimer_cpu_base;
enum hrtimer_restart {
    HRTIMER_NORESTART = 0,
    HRTIMER_RESTART = 1
} ;
struct hrtimer {
   struct timerqueue_node node ;
   ktime_t _softexpires ;
   enum hrtimer_restart (*function)(struct hrtimer * ) ;
   struct hrtimer_clock_base *base ;
   unsigned long state ;
    klee_make_symbolic(&state, sizeof(long), "state");
   int start_pid ;
   void *start_site ;
   char start_comm[16U] ;
};
struct hrtimer_clock_base {
   struct hrtimer_cpu_base *cpu_base ;
   int index ;
   clockid_t clockid ;
   struct timerqueue_head active ;
   ktime_t (*get_time)(void) ;
   ktime_t offset ;
};
struct hrtimer_cpu_base {
   raw_spinlock_t lock ;
   seqcount_t seq ;
   struct hrtimer *running ;
   unsigned int cpu ;
   unsigned int active_bases ;
    klee_make_symbolic(&active_bases, sizeof(int), "active_bases");
   unsigned int clock_was_set_seq ;
    klee_make_symbolic(&clock_was_set_seq, sizeof(int), "clock_was_set_seq");
   bool migration_enabled ;
   bool nohz_active ;
   unsigned char in_hrtirq : 1 ;
   unsigned char hres_active : 1 ;
   unsigned char hang_detected : 1 ;
   ktime_t expires_next ;
   struct hrtimer *next_timer ;
   unsigned int nr_events ;
    klee_make_symbolic(&nr_events, sizeof(int), "nr_events");
   unsigned int nr_retries ;
    klee_make_symbolic(&nr_retries, sizeof(int), "nr_retries");
   unsigned int nr_hangs ;
    klee_make_symbolic(&nr_hangs, sizeof(int), "nr_hangs");
   unsigned int max_hang_time ;
    klee_make_symbolic(&max_hang_time, sizeof(int), "max_hang_time");
   struct hrtimer_clock_base clock_base[4U] ;
};
struct task_io_accounting {
   u64 rchar ;
   u64 wchar ;
   u64 syscr ;
   u64 syscw ;
   u64 read_bytes ;
   u64 write_bytes ;
   u64 cancelled_write_bytes ;
};
struct latency_record {
   unsigned long backtrace[12U] ;
   unsigned int count ;
   unsigned long time ;
    klee_make_symbolic(&time, sizeof(long), "time");
   unsigned long max ;
    klee_make_symbolic(&max, sizeof(long), "max");
};
struct assoc_array_ptr;
struct assoc_array {
   struct assoc_array_ptr *root ;
   unsigned long nr_leaves_on_tree ;
    klee_make_symbolic(&nr_leaves_on_tree, sizeof(long), "nr_leaves_on_tree");
};
typedef int32_t key_serial_t;
typedef uint32_t key_perm_t;
struct key;
struct signal_struct;
struct cred;
struct key_type;
struct keyring_index_key {
   struct key_type *type ;
   char const   *description ;
   size_t desc_len ;
};
union __anonunion____missing_field_name_179 {
   struct list_head graveyard_link ;
   struct rb_node serial_node ;
};
struct key_user;
union __anonunion____missing_field_name_180 {
   time_t expiry ;
   time_t revoked_at ;
};
struct __anonstruct____missing_field_name_182 {
   struct key_type *type ;
   char *description ;
};
union __anonunion____missing_field_name_181 {
   struct keyring_index_key index_key ;
   struct __anonstruct____missing_field_name_182 __annonCompField49 ;
};
union __anonunion_type_data_183 {
   struct list_head link ;
   unsigned long x[2U] ;
   void *p[2U] ;
   int reject_error ;
    klee_make_symbolic(&reject_error, sizeof(int), "reject_error");
};
union __anonunion_payload_185 {
   unsigned long value ;
   void *rcudata ;
   void *data ;
   void *data2[2U] ;
};
union __anonunion____missing_field_name_184 {
   union __anonunion_payload_185 payload ;
   struct assoc_array keys ;
};
struct key {
   atomic_t usage ;
   key_serial_t serial ;
   union __anonunion____missing_field_name_179 __annonCompField47 ;
   struct rw_semaphore sem ;
   struct key_user *user ;
   void *security ;
   union __anonunion____missing_field_name_180 __annonCompField48 ;
   time_t last_used_at ;
   kuid_t uid ;
   kgid_t gid ;
   key_perm_t perm ;
   unsigned short quotalen ;
    klee_make_symbolic(&quotalen, sizeof(short), "quotalen");
   unsigned short datalen ;
    klee_make_symbolic(&datalen, sizeof(short), "datalen");
   unsigned long flags ;
   union __anonunion____missing_field_name_181 __annonCompField50 ;
   union __anonunion_type_data_183 type_data ;
   union __anonunion____missing_field_name_184 __annonCompField51 ;
};
struct audit_context;
struct group_info {
   atomic_t usage ;
   int ngroups ;
    klee_make_symbolic(&ngroups, sizeof(int), "ngroups");
   int nblocks ;
    klee_make_symbolic(&nblocks, sizeof(int), "nblocks");
   kgid_t small_block[32U] ;
   kgid_t *blocks[0U] ;
};
struct cred {
   atomic_t usage ;
   atomic_t subscribers ;
   void *put_addr ;
   unsigned int magic ;
   kuid_t uid ;
   kgid_t gid ;
   kuid_t suid ;
   kgid_t sgid ;
   kuid_t euid ;
   kgid_t egid ;
   kuid_t fsuid ;
   kgid_t fsgid ;
   unsigned int securebits ;
    klee_make_symbolic(&securebits, sizeof(int), "securebits");
   kernel_cap_t cap_inheritable ;
   kernel_cap_t cap_permitted ;
   kernel_cap_t cap_effective ;
   kernel_cap_t cap_bset ;
   unsigned char jit_keyring ;
    klee_make_symbolic(&jit_keyring, sizeof(char), "jit_keyring");
   struct key *session_keyring ;
   struct key *process_keyring ;
   struct key *thread_keyring ;
   struct key *request_key_auth ;
   void *security ;
   struct user_struct *user ;
   struct user_namespace *user_ns ;
   struct group_info *group_info ;
   struct callback_head rcu ;
};
union __anonunion____missing_field_name_186 {
   unsigned long bitmap[4U] ;
   struct callback_head callback_head ;
};
struct idr_layer {
   int prefix ;
    klee_make_symbolic(&prefix, sizeof(int), "prefix");
   int layer ;
    klee_make_symbolic(&layer, sizeof(int), "layer");
   struct idr_layer *ary[256U] ;
   int count ;
   union __anonunion____missing_field_name_186 __annonCompField52 ;
};
struct idr {
   struct idr_layer *hint ;
   struct idr_layer *top ;
   int layers ;
    klee_make_symbolic(&layers, sizeof(int), "layers");
   int cur ;
    klee_make_symbolic(&cur, sizeof(int), "cur");
   spinlock_t lock ;
   int id_free_cnt ;
    klee_make_symbolic(&id_free_cnt, sizeof(int), "id_free_cnt");
   struct idr_layer *id_free ;
};
struct ida_bitmap {
   long nr_busy ;
    klee_make_symbolic(&nr_busy, sizeof(long), "nr_busy");
   unsigned long bitmap[15U] ;
};
struct ida {
   struct idr idr ;
   struct ida_bitmap *free_bitmap ;
};
struct percpu_ref;
typedef void percpu_ref_func_t(struct percpu_ref * );
struct percpu_ref {
   atomic_long_t count ;
   unsigned long percpu_count_ptr ;
    klee_make_symbolic(&percpu_count_ptr, sizeof(long), "percpu_count_ptr");
   percpu_ref_func_t *release ;
   percpu_ref_func_t *confirm_switch ;
   bool force_atomic ;
   struct callback_head rcu ;
};
struct cgroup;
struct cgroup_root;
struct cgroup_subsys;
struct cgroup_taskset;
struct kernfs_node;
struct kernfs_ops;
struct kernfs_open_file;
struct cgroup_subsys_state {
   struct cgroup *cgroup ;
   struct cgroup_subsys *ss ;
   struct percpu_ref refcnt ;
   struct cgroup_subsys_state *parent ;
   struct list_head sibling ;
   struct list_head children ;
   int id ;
    klee_make_symbolic(&id, sizeof(int), "id");
   unsigned int flags ;
   u64 serial_nr ;
   struct callback_head callback_head ;
   struct work_struct destroy_work ;
};
struct css_set {
   atomic_t refcount ;
   struct hlist_node hlist ;
   struct list_head tasks ;
   struct list_head mg_tasks ;
   struct list_head cgrp_links ;
   struct cgroup *dfl_cgrp ;
   struct cgroup_subsys_state *subsys[12U] ;
   struct list_head mg_preload_node ;
   struct list_head mg_node ;
   struct cgroup *mg_src_cgrp ;
   struct css_set *mg_dst_cset ;
   struct list_head e_cset_node[12U] ;
   struct callback_head callback_head ;
};
struct cgroup {
   struct cgroup_subsys_state self ;
   unsigned long flags ;
   int id ;
   int populated_cnt ;
    klee_make_symbolic(&populated_cnt, sizeof(int), "populated_cnt");
   struct kernfs_node *kn ;
   struct kernfs_node *procs_kn ;
   struct kernfs_node *populated_kn ;
   unsigned int subtree_control ;
    klee_make_symbolic(&subtree_control, sizeof(int), "subtree_control");
   unsigned int child_subsys_mask ;
    klee_make_symbolic(&child_subsys_mask, sizeof(int), "child_subsys_mask");
   struct cgroup_subsys_state *subsys[12U] ;
   struct cgroup_root *root ;
   struct list_head cset_links ;
   struct list_head e_csets[12U] ;
   struct list_head pidlists ;
   struct mutex pidlist_mutex ;
   wait_queue_head_t offline_waitq ;
   struct work_struct release_agent_work ;
};
struct kernfs_root;
struct cgroup_root {
   struct kernfs_root *kf_root ;
   unsigned int subsys_mask ;
    klee_make_symbolic(&subsys_mask, sizeof(int), "subsys_mask");
   int hierarchy_id ;
    klee_make_symbolic(&hierarchy_id, sizeof(int), "hierarchy_id");
   struct cgroup cgrp ;
   atomic_t nr_cgrps ;
   struct list_head root_list ;
   unsigned int flags ;
   struct idr cgroup_idr ;
   char release_agent_path[4096U] ;
   char name[64U] ;
};
struct cftype {
   char name[64U] ;
   int private ;
   umode_t mode ;
   size_t max_write_len ;
   unsigned int flags ;
   struct cgroup_subsys *ss ;
   struct list_head node ;
   struct kernfs_ops *kf_ops ;
   u64 (*read_u64)(struct cgroup_subsys_state * , struct cftype * ) ;
   s64 (*read_s64)(struct cgroup_subsys_state * , struct cftype * ) ;
   int (*seq_show)(struct seq_file * , void * ) ;
   void *(*seq_start)(struct seq_file * , loff_t * ) ;
   void *(*seq_next)(struct seq_file * , void * , loff_t * ) ;
   void (*seq_stop)(struct seq_file * , void * ) ;
   int (*write_u64)(struct cgroup_subsys_state * , struct cftype * , u64  ) ;
   int (*write_s64)(struct cgroup_subsys_state * , struct cftype * , s64  ) ;
   ssize_t (*write)(struct kernfs_open_file * , char * , size_t  , loff_t  ) ;
   struct lock_class_key lockdep_key ;
};
struct cgroup_subsys {
   struct cgroup_subsys_state *(*css_alloc)(struct cgroup_subsys_state * ) ;
   int (*css_online)(struct cgroup_subsys_state * ) ;
   void (*css_offline)(struct cgroup_subsys_state * ) ;
   void (*css_released)(struct cgroup_subsys_state * ) ;
   void (*css_free)(struct cgroup_subsys_state * ) ;
   void (*css_reset)(struct cgroup_subsys_state * ) ;
   void (*css_e_css_changed)(struct cgroup_subsys_state * ) ;
   int (*can_attach)(struct cgroup_subsys_state * , struct cgroup_taskset * ) ;
   void (*cancel_attach)(struct cgroup_subsys_state * , struct cgroup_taskset * ) ;
   void (*attach)(struct cgroup_subsys_state * , struct cgroup_taskset * ) ;
   void (*fork)(struct task_struct * ) ;
   void (*exit)(struct cgroup_subsys_state * , struct cgroup_subsys_state * , struct task_struct * ) ;
   void (*bind)(struct cgroup_subsys_state * ) ;
   int disabled ;
    klee_make_symbolic(&disabled, sizeof(int), "disabled");
   int early_init ;
    klee_make_symbolic(&early_init, sizeof(int), "early_init");
   bool broken_hierarchy ;
   bool warned_broken_hierarchy ;
   int id ;
   char const   *name ;
   struct cgroup_root *root ;
   struct idr css_idr ;
   struct list_head cfts ;
   struct cftype *dfl_cftypes ;
   struct cftype *legacy_cftypes ;
   unsigned int depends_on ;
    klee_make_symbolic(&depends_on, sizeof(int), "depends_on");
};
struct futex_pi_state;
struct robust_list_head;
struct bio_list;
struct fs_struct;
struct perf_event_context;
struct blk_plug;
struct nameidata;
struct cfs_rq;
struct task_group;
struct sighand_struct {
   atomic_t count ;
   struct k_sigaction action[64U] ;
   spinlock_t siglock ;
   wait_queue_head_t signalfd_wqh ;
};
struct pacct_struct {
   int ac_flag ;
    klee_make_symbolic(&ac_flag, sizeof(int), "ac_flag");
   long ac_exitcode ;
    klee_make_symbolic(&ac_exitcode, sizeof(long), "ac_exitcode");
   unsigned long ac_mem ;
    klee_make_symbolic(&ac_mem, sizeof(long), "ac_mem");
   cputime_t ac_utime ;
   cputime_t ac_stime ;
   unsigned long ac_minflt ;
    klee_make_symbolic(&ac_minflt, sizeof(long), "ac_minflt");
   unsigned long ac_majflt ;
    klee_make_symbolic(&ac_majflt, sizeof(long), "ac_majflt");
};
struct cpu_itimer {
   cputime_t expires ;
   cputime_t incr ;
   u32 error ;
   u32 incr_error ;
};
struct cputime {
   cputime_t utime ;
   cputime_t stime ;
};
struct task_cputime {
   cputime_t utime ;
   cputime_t stime ;
   unsigned long long sum_exec_runtime ;
    klee_make_symbolic(&sum_exec_runtime, sizeof(long), "sum_exec_runtime");
};
struct task_cputime_atomic {
   atomic64_t utime ;
   atomic64_t stime ;
   atomic64_t sum_exec_runtime ;
};
struct thread_group_cputimer {
   struct task_cputime_atomic cputime_atomic ;
   int running ;
    klee_make_symbolic(&running, sizeof(int), "running");
};
struct autogroup;
struct tty_struct;
struct taskstats;
struct tty_audit_buf;
struct signal_struct {
   atomic_t sigcnt ;
   atomic_t live ;
   int nr_threads ;
    klee_make_symbolic(&nr_threads, sizeof(int), "nr_threads");
   struct list_head thread_head ;
   wait_queue_head_t wait_chldexit ;
   struct task_struct *curr_target ;
   struct sigpending shared_pending ;
   int group_exit_code ;
    klee_make_symbolic(&group_exit_code, sizeof(int), "group_exit_code");
   int notify_count ;
    klee_make_symbolic(&notify_count, sizeof(int), "notify_count");
   struct task_struct *group_exit_task ;
   int group_stop_count ;
    klee_make_symbolic(&group_stop_count, sizeof(int), "group_stop_count");
   unsigned int flags ;
   unsigned char is_child_subreaper : 1 ;
   unsigned char has_child_subreaper : 1 ;
   int posix_timer_id ;
    klee_make_symbolic(&posix_timer_id, sizeof(int), "posix_timer_id");
   struct list_head posix_timers ;
   struct hrtimer real_timer ;
   struct pid *leader_pid ;
   ktime_t it_real_incr ;
   struct cpu_itimer it[2U] ;
   struct thread_group_cputimer cputimer ;
   struct task_cputime cputime_expires ;
   struct list_head cpu_timers[3U] ;
   struct pid *tty_old_pgrp ;
   int leader ;
    klee_make_symbolic(&leader, sizeof(int), "leader");
   struct tty_struct *tty ;
   struct autogroup *autogroup ;
   seqlock_t stats_lock ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t cutime ;
   cputime_t cstime ;
   cputime_t gtime ;
   cputime_t cgtime ;
   struct cputime prev_cputime ;
   unsigned long nvcsw ;
    klee_make_symbolic(&nvcsw, sizeof(long), "nvcsw");
   unsigned long nivcsw ;
    klee_make_symbolic(&nivcsw, sizeof(long), "nivcsw");
   unsigned long cnvcsw ;
    klee_make_symbolic(&cnvcsw, sizeof(long), "cnvcsw");
   unsigned long cnivcsw ;
    klee_make_symbolic(&cnivcsw, sizeof(long), "cnivcsw");
   unsigned long min_flt ;
    klee_make_symbolic(&min_flt, sizeof(long), "min_flt");
   unsigned long maj_flt ;
    klee_make_symbolic(&maj_flt, sizeof(long), "maj_flt");
   unsigned long cmin_flt ;
    klee_make_symbolic(&cmin_flt, sizeof(long), "cmin_flt");
   unsigned long cmaj_flt ;
    klee_make_symbolic(&cmaj_flt, sizeof(long), "cmaj_flt");
   unsigned long inblock ;
    klee_make_symbolic(&inblock, sizeof(long), "inblock");
   unsigned long oublock ;
    klee_make_symbolic(&oublock, sizeof(long), "oublock");
   unsigned long cinblock ;
    klee_make_symbolic(&cinblock, sizeof(long), "cinblock");
   unsigned long coublock ;
    klee_make_symbolic(&coublock, sizeof(long), "coublock");
   unsigned long maxrss ;
    klee_make_symbolic(&maxrss, sizeof(long), "maxrss");
   unsigned long cmaxrss ;
    klee_make_symbolic(&cmaxrss, sizeof(long), "cmaxrss");
   struct task_io_accounting ioac ;
   unsigned long long sum_sched_runtime ;
    klee_make_symbolic(&sum_sched_runtime, sizeof(long), "sum_sched_runtime");
   struct rlimit rlim[16U] ;
   struct pacct_struct pacct ;
   struct taskstats *stats ;
   unsigned int audit_tty ;
    klee_make_symbolic(&audit_tty, sizeof(int), "audit_tty");
   unsigned int audit_tty_log_passwd ;
    klee_make_symbolic(&audit_tty_log_passwd, sizeof(int), "audit_tty_log_passwd");
   struct tty_audit_buf *tty_audit_buf ;
   oom_flags_t oom_flags ;
   short oom_score_adj ;
    klee_make_symbolic(&oom_score_adj, sizeof(short), "oom_score_adj");
   short oom_score_adj_min ;
    klee_make_symbolic(&oom_score_adj_min, sizeof(short), "oom_score_adj_min");
   struct mutex cred_guard_mutex ;
};
struct user_struct {
   atomic_t __count ;
   atomic_t processes ;
   atomic_t sigpending ;
   atomic_t inotify_watches ;
   atomic_t inotify_devs ;
   atomic_t fanotify_listeners ;
   atomic_long_t epoll_watches ;
   unsigned long mq_bytes ;
    klee_make_symbolic(&mq_bytes, sizeof(long), "mq_bytes");
   unsigned long locked_shm ;
    klee_make_symbolic(&locked_shm, sizeof(long), "locked_shm");
   struct key *uid_keyring ;
   struct key *session_keyring ;
   struct hlist_node uidhash_node ;
   kuid_t uid ;
   atomic_long_t locked_vm ;
};
struct backing_dev_info;
struct reclaim_state;
struct sched_info {
   unsigned long pcount ;
    klee_make_symbolic(&pcount, sizeof(long), "pcount");
   unsigned long long run_delay ;
    klee_make_symbolic(&run_delay, sizeof(long), "run_delay");
   unsigned long long last_arrival ;
    klee_make_symbolic(&last_arrival, sizeof(long), "last_arrival");
   unsigned long long last_queued ;
    klee_make_symbolic(&last_queued, sizeof(long), "last_queued");
};
struct task_delay_info {
   spinlock_t lock ;
   unsigned int flags ;
   u64 blkio_start ;
   u64 blkio_delay ;
   u64 swapin_delay ;
   u32 blkio_count ;
   u32 swapin_count ;
   u64 freepages_start ;
   u64 freepages_delay ;
   u32 freepages_count ;
};
struct wake_q_node {
   struct wake_q_node *next ;
};
struct io_context;
struct pipe_inode_info;
struct load_weight {
   unsigned long weight ;
    klee_make_symbolic(&weight, sizeof(long), "weight");
   u32 inv_weight ;
};
struct sched_avg {
   u64 last_runnable_update ;
   s64 decay_count ;
   unsigned long load_avg_contrib ;
    klee_make_symbolic(&load_avg_contrib, sizeof(long), "load_avg_contrib");
   unsigned long utilization_avg_contrib ;
    klee_make_symbolic(&utilization_avg_contrib, sizeof(long), "utilization_avg_contrib");
   u32 runnable_avg_sum ;
   u32 avg_period ;
   u32 running_avg_sum ;
};
struct sched_statistics {
   u64 wait_start ;
   u64 wait_max ;
   u64 wait_count ;
   u64 wait_sum ;
   u64 iowait_count ;
   u64 iowait_sum ;
   u64 sleep_start ;
   u64 sleep_max ;
   s64 sum_sleep_runtime ;
   u64 block_start ;
   u64 block_max ;
   u64 exec_max ;
   u64 slice_max ;
   u64 nr_migrations_cold ;
   u64 nr_failed_migrations_affine ;
   u64 nr_failed_migrations_running ;
   u64 nr_failed_migrations_hot ;
   u64 nr_forced_migrations ;
   u64 nr_wakeups ;
   u64 nr_wakeups_sync ;
   u64 nr_wakeups_migrate ;
   u64 nr_wakeups_local ;
   u64 nr_wakeups_remote ;
   u64 nr_wakeups_affine ;
   u64 nr_wakeups_affine_attempts ;
   u64 nr_wakeups_passive ;
   u64 nr_wakeups_idle ;
};
struct sched_entity {
   struct load_weight load ;
   struct rb_node run_node ;
   struct list_head group_node ;
   unsigned int on_rq ;
    klee_make_symbolic(&on_rq, sizeof(int), "on_rq");
   u64 exec_start ;
   u64 sum_exec_runtime ;
   u64 vruntime ;
   u64 prev_sum_exec_runtime ;
   u64 nr_migrations ;
   struct sched_statistics statistics ;
   int depth ;
   struct sched_entity *parent ;
   struct cfs_rq *cfs_rq ;
   struct cfs_rq *my_q ;
   struct sched_avg avg ;
};
struct rt_rq;
struct sched_rt_entity {
   struct list_head run_list ;
   unsigned long timeout ;
    klee_make_symbolic(&timeout, sizeof(long), "timeout");
   unsigned long watchdog_stamp ;
    klee_make_symbolic(&watchdog_stamp, sizeof(long), "watchdog_stamp");
   unsigned int time_slice ;
    klee_make_symbolic(&time_slice, sizeof(int), "time_slice");
   struct sched_rt_entity *back ;
   struct sched_rt_entity *parent ;
   struct rt_rq *rt_rq ;
   struct rt_rq *my_q ;
};
struct sched_dl_entity {
   struct rb_node rb_node ;
   u64 dl_runtime ;
   u64 dl_deadline ;
   u64 dl_period ;
   u64 dl_bw ;
   s64 runtime ;
   u64 deadline ;
   unsigned int flags ;
   int dl_throttled ;
    klee_make_symbolic(&dl_throttled, sizeof(int), "dl_throttled");
   int dl_new ;
    klee_make_symbolic(&dl_new, sizeof(int), "dl_new");
   int dl_boosted ;
    klee_make_symbolic(&dl_boosted, sizeof(int), "dl_boosted");
   int dl_yielded ;
    klee_make_symbolic(&dl_yielded, sizeof(int), "dl_yielded");
   struct hrtimer dl_timer ;
};
struct memcg_oom_info {
   struct mem_cgroup *memcg ;
   gfp_t gfp_mask ;
   int order ;
    klee_make_symbolic(&order, sizeof(int), "order");
   unsigned char may_oom : 1 ;
};
struct sched_class;
struct files_struct;
struct compat_robust_list_head;
struct numa_group;
struct task_struct {
   long volatile   state ;
   void *stack ;
   atomic_t usage ;
   unsigned int flags ;
   unsigned int ptrace ;
    klee_make_symbolic(&ptrace, sizeof(int), "ptrace");
   struct llist_node wake_entry ;
   int on_cpu ;
    klee_make_symbolic(&on_cpu, sizeof(int), "on_cpu");
   struct task_struct *last_wakee ;
   unsigned long wakee_flips ;
    klee_make_symbolic(&wakee_flips, sizeof(long), "wakee_flips");
   unsigned long wakee_flip_decay_ts ;
    klee_make_symbolic(&wakee_flip_decay_ts, sizeof(long), "wakee_flip_decay_ts");
   int wake_cpu ;
    klee_make_symbolic(&wake_cpu, sizeof(int), "wake_cpu");
   int on_rq ;
   int prio ;
   int static_prio ;
    klee_make_symbolic(&static_prio, sizeof(int), "static_prio");
   int normal_prio ;
    klee_make_symbolic(&normal_prio, sizeof(int), "normal_prio");
   unsigned int rt_priority ;
    klee_make_symbolic(&rt_priority, sizeof(int), "rt_priority");
   struct sched_class  const  *sched_class ;
   struct sched_entity se ;
   struct sched_rt_entity rt ;
   struct task_group *sched_task_group ;
   struct sched_dl_entity dl ;
   struct hlist_head preempt_notifiers ;
   unsigned int policy ;
    klee_make_symbolic(&policy, sizeof(int), "policy");
   int nr_cpus_allowed ;
    klee_make_symbolic(&nr_cpus_allowed, sizeof(int), "nr_cpus_allowed");
   cpumask_t cpus_allowed ;
   unsigned long rcu_tasks_nvcsw ;
    klee_make_symbolic(&rcu_tasks_nvcsw, sizeof(long), "rcu_tasks_nvcsw");
   bool rcu_tasks_holdout ;
   struct list_head rcu_tasks_holdout_list ;
   int rcu_tasks_idle_cpu ;
    klee_make_symbolic(&rcu_tasks_idle_cpu, sizeof(int), "rcu_tasks_idle_cpu");
   struct sched_info sched_info ;
   struct list_head tasks ;
   struct plist_node pushable_tasks ;
   struct rb_node pushable_dl_tasks ;
   struct mm_struct *mm ;
   struct mm_struct *active_mm ;
   u32 vmacache_seqnum ;
   struct vm_area_struct *vmacache[4U] ;
   struct task_rss_stat rss_stat ;
   int exit_state ;
    klee_make_symbolic(&exit_state, sizeof(int), "exit_state");
   int exit_code ;
    klee_make_symbolic(&exit_code, sizeof(int), "exit_code");
   int exit_signal ;
    klee_make_symbolic(&exit_signal, sizeof(int), "exit_signal");
   int pdeath_signal ;
    klee_make_symbolic(&pdeath_signal, sizeof(int), "pdeath_signal");
   unsigned long jobctl ;
    klee_make_symbolic(&jobctl, sizeof(long), "jobctl");
   unsigned int personality ;
    klee_make_symbolic(&personality, sizeof(int), "personality");
   unsigned char in_execve : 1 ;
   unsigned char in_iowait : 1 ;
   unsigned char sched_reset_on_fork : 1 ;
   unsigned char sched_contributes_to_load : 1 ;
   unsigned char sched_migrated : 1 ;
   unsigned char memcg_kmem_skip_account : 1 ;
   unsigned char brk_randomized : 1 ;
   unsigned long atomic_flags ;
    klee_make_symbolic(&atomic_flags, sizeof(long), "atomic_flags");
   struct restart_block restart_block ;
   pid_t pid ;
   pid_t tgid ;
   struct task_struct *real_parent ;
   struct task_struct *parent ;
   struct list_head children ;
   struct list_head sibling ;
   struct task_struct *group_leader ;
   struct list_head ptraced ;
   struct list_head ptrace_entry ;
   struct pid_link pids[3U] ;
   struct list_head thread_group ;
   struct list_head thread_node ;
   struct completion *vfork_done ;
   int *set_child_tid ;
   int *clear_child_tid ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t utimescaled ;
   cputime_t stimescaled ;
   cputime_t gtime ;
   struct cputime prev_cputime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   u64 start_time ;
   u64 real_start_time ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   struct task_cputime cputime_expires ;
   struct list_head cpu_timers[3U] ;
   struct cred  const  *real_cred ;
   struct cred  const  *cred ;
   char comm[16U] ;
   struct nameidata *nameidata ;
   struct sysv_sem sysvsem ;
   struct sysv_shm sysvshm ;
   unsigned long last_switch_count ;
    klee_make_symbolic(&last_switch_count, sizeof(long), "last_switch_count");
   struct thread_struct thread ;
   struct fs_struct *fs ;
   struct files_struct *files ;
   struct nsproxy *nsproxy ;
   struct signal_struct *signal ;
   struct sighand_struct *sighand ;
   sigset_t blocked ;
   sigset_t real_blocked ;
   sigset_t saved_sigmask ;
   struct sigpending pending ;
   unsigned long sas_ss_sp ;
    klee_make_symbolic(&sas_ss_sp, sizeof(long), "sas_ss_sp");
   size_t sas_ss_size ;
   int (*notifier)(void * ) ;
   void *notifier_data ;
   sigset_t *notifier_mask ;
   struct callback_head *task_works ;
   struct audit_context *audit_context ;
   kuid_t loginuid ;
   unsigned int sessionid ;
    klee_make_symbolic(&sessionid, sizeof(int), "sessionid");
   struct seccomp seccomp ;
   u32 parent_exec_id ;
   u32 self_exec_id ;
   spinlock_t alloc_lock ;
   raw_spinlock_t pi_lock ;
   struct wake_q_node wake_q ;
   struct rb_root pi_waiters ;
   struct rb_node *pi_waiters_leftmost ;
   struct rt_mutex_waiter *pi_blocked_on ;
   struct mutex_waiter *blocked_on ;
   unsigned int irq_events ;
    klee_make_symbolic(&irq_events, sizeof(int), "irq_events");
   unsigned long hardirq_enable_ip ;
    klee_make_symbolic(&hardirq_enable_ip, sizeof(long), "hardirq_enable_ip");
   unsigned long hardirq_disable_ip ;
    klee_make_symbolic(&hardirq_disable_ip, sizeof(long), "hardirq_disable_ip");
   unsigned int hardirq_enable_event ;
    klee_make_symbolic(&hardirq_enable_event, sizeof(int), "hardirq_enable_event");
   unsigned int hardirq_disable_event ;
    klee_make_symbolic(&hardirq_disable_event, sizeof(int), "hardirq_disable_event");
   int hardirqs_enabled ;
    klee_make_symbolic(&hardirqs_enabled, sizeof(int), "hardirqs_enabled");
   int hardirq_context ;
    klee_make_symbolic(&hardirq_context, sizeof(int), "hardirq_context");
   unsigned long softirq_disable_ip ;
    klee_make_symbolic(&softirq_disable_ip, sizeof(long), "softirq_disable_ip");
   unsigned long softirq_enable_ip ;
    klee_make_symbolic(&softirq_enable_ip, sizeof(long), "softirq_enable_ip");
   unsigned int softirq_disable_event ;
    klee_make_symbolic(&softirq_disable_event, sizeof(int), "softirq_disable_event");
   unsigned int softirq_enable_event ;
    klee_make_symbolic(&softirq_enable_event, sizeof(int), "softirq_enable_event");
   int softirqs_enabled ;
    klee_make_symbolic(&softirqs_enabled, sizeof(int), "softirqs_enabled");
   int softirq_context ;
    klee_make_symbolic(&softirq_context, sizeof(int), "softirq_context");
   u64 curr_chain_key ;
   int lockdep_depth ;
    klee_make_symbolic(&lockdep_depth, sizeof(int), "lockdep_depth");
   unsigned int lockdep_recursion ;
    klee_make_symbolic(&lockdep_recursion, sizeof(int), "lockdep_recursion");
   struct held_lock held_locks[48U] ;
   gfp_t lockdep_reclaim_gfp ;
   void *journal_info ;
   struct bio_list *bio_list ;
   struct blk_plug *plug ;
   struct reclaim_state *reclaim_state ;
   struct backing_dev_info *backing_dev_info ;
   struct io_context *io_context ;
   unsigned long ptrace_message ;
    klee_make_symbolic(&ptrace_message, sizeof(long), "ptrace_message");
   siginfo_t *last_siginfo ;
   struct task_io_accounting ioac ;
   u64 acct_rss_mem1 ;
   u64 acct_vm_mem1 ;
   cputime_t acct_timexpd ;
   nodemask_t mems_allowed ;
   seqcount_t mems_allowed_seq ;
   int cpuset_mem_spread_rotor ;
    klee_make_symbolic(&cpuset_mem_spread_rotor, sizeof(int), "cpuset_mem_spread_rotor");
   int cpuset_slab_spread_rotor ;
    klee_make_symbolic(&cpuset_slab_spread_rotor, sizeof(int), "cpuset_slab_spread_rotor");
   struct css_set *cgroups ;
   struct list_head cg_list ;
   struct robust_list_head *robust_list ;
   struct compat_robust_list_head *compat_robust_list ;
   struct list_head pi_state_list ;
   struct futex_pi_state *pi_state_cache ;
   struct perf_event_context *perf_event_ctxp[2U] ;
   struct mutex perf_event_mutex ;
   struct list_head perf_event_list ;
   struct mempolicy *mempolicy ;
   short il_next ;
    klee_make_symbolic(&il_next, sizeof(short), "il_next");
   short pref_node_fork ;
    klee_make_symbolic(&pref_node_fork, sizeof(short), "pref_node_fork");
   int numa_scan_seq ;
   unsigned int numa_scan_period ;
    klee_make_symbolic(&numa_scan_period, sizeof(int), "numa_scan_period");
   unsigned int numa_scan_period_max ;
    klee_make_symbolic(&numa_scan_period_max, sizeof(int), "numa_scan_period_max");
   int numa_preferred_nid ;
    klee_make_symbolic(&numa_preferred_nid, sizeof(int), "numa_preferred_nid");
   unsigned long numa_migrate_retry ;
    klee_make_symbolic(&numa_migrate_retry, sizeof(long), "numa_migrate_retry");
   u64 node_stamp ;
   u64 last_task_numa_placement ;
   u64 last_sum_exec_runtime ;
   struct callback_head numa_work ;
   struct list_head numa_entry ;
   struct numa_group *numa_group ;
   unsigned long *numa_faults ;
   unsigned long total_numa_faults ;
    klee_make_symbolic(&total_numa_faults, sizeof(long), "total_numa_faults");
   unsigned long numa_faults_locality[3U] ;
   unsigned long numa_pages_migrated ;
    klee_make_symbolic(&numa_pages_migrated, sizeof(long), "numa_pages_migrated");
   struct callback_head rcu ;
   struct pipe_inode_info *splice_pipe ;
   struct page_frag task_frag ;
   struct task_delay_info *delays ;
   int make_it_fail ;
    klee_make_symbolic(&make_it_fail, sizeof(int), "make_it_fail");
   int nr_dirtied ;
    klee_make_symbolic(&nr_dirtied, sizeof(int), "nr_dirtied");
   int nr_dirtied_pause ;
    klee_make_symbolic(&nr_dirtied_pause, sizeof(int), "nr_dirtied_pause");
   unsigned long dirty_paused_when ;
    klee_make_symbolic(&dirty_paused_when, sizeof(long), "dirty_paused_when");
   int latency_record_count ;
    klee_make_symbolic(&latency_record_count, sizeof(int), "latency_record_count");
   struct latency_record latency_record[32U] ;
   unsigned long timer_slack_ns ;
    klee_make_symbolic(&timer_slack_ns, sizeof(long), "timer_slack_ns");
   unsigned long default_timer_slack_ns ;
    klee_make_symbolic(&default_timer_slack_ns, sizeof(long), "default_timer_slack_ns");
   unsigned int kasan_depth ;
    klee_make_symbolic(&kasan_depth, sizeof(int), "kasan_depth");
   unsigned long trace ;
    klee_make_symbolic(&trace, sizeof(long), "trace");
   unsigned long trace_recursion ;
    klee_make_symbolic(&trace_recursion, sizeof(long), "trace_recursion");
   struct memcg_oom_info memcg_oom ;
   struct uprobe_task *utask ;
   unsigned int sequential_io ;
    klee_make_symbolic(&sequential_io, sizeof(int), "sequential_io");
   unsigned int sequential_io_avg ;
    klee_make_symbolic(&sequential_io_avg, sizeof(int), "sequential_io_avg");
   unsigned long task_state_change ;
    klee_make_symbolic(&task_state_change, sizeof(long), "task_state_change");
   int pagefault_disabled ;
    klee_make_symbolic(&pagefault_disabled, sizeof(int), "pagefault_disabled");
};
enum irqreturn {
    IRQ_NONE = 0,
    IRQ_HANDLED = 1,
    IRQ_WAKE_THREAD = 2
} ;
typedef enum irqreturn irqreturn_t;
struct Scsi_Host;
struct scsi_cmnd;
struct scsi_device;
struct device_type;
struct kobject;
struct class;
struct iattr;
struct super_block;
struct file_system_type;
struct kernfs_open_node;
struct kernfs_iattrs;
struct kernfs_elem_dir {
   unsigned long subdirs ;
    klee_make_symbolic(&subdirs, sizeof(long), "subdirs");
   struct rb_root children ;
   struct kernfs_root *root ;
};
struct kernfs_elem_symlink {
   struct kernfs_node *target_kn ;
};
struct kernfs_elem_attr {
   struct kernfs_ops  const  *ops ;
   struct kernfs_open_node *open ;
   loff_t size ;
   struct kernfs_node *notify_next ;
};
union __anonunion____missing_field_name_205 {
   struct kernfs_elem_dir dir ;
   struct kernfs_elem_symlink symlink ;
   struct kernfs_elem_attr attr ;
};
struct kernfs_node {
   atomic_t count ;
   atomic_t active ;
   struct lockdep_map dep_map ;
   struct kernfs_node *parent ;
   char const   *name ;
   struct rb_node rb ;
   void const   *ns ;
   unsigned int hash ;
    klee_make_symbolic(&hash, sizeof(int), "hash");
   union __anonunion____missing_field_name_205 __annonCompField56 ;
   void *priv ;
   unsigned short flags ;
   umode_t mode ;
   unsigned int ino ;
    klee_make_symbolic(&ino, sizeof(int), "ino");
   struct kernfs_iattrs *iattr ;
};
struct kernfs_syscall_ops {
   int (*remount_fs)(struct kernfs_root * , int * , char * ) ;
   int (*show_options)(struct seq_file * , struct kernfs_root * ) ;
   int (*mkdir)(struct kernfs_node * , char const   * , umode_t  ) ;
   int (*rmdir)(struct kernfs_node * ) ;
   int (*rename)(struct kernfs_node * , struct kernfs_node * , char const   * ) ;
};
struct kernfs_root {
   struct kernfs_node *kn ;
   unsigned int flags ;
   struct ida ino_ida ;
   struct kernfs_syscall_ops *syscall_ops ;
   struct list_head supers ;
   wait_queue_head_t deactivate_waitq ;
};
struct kernfs_open_file {
   struct kernfs_node *kn ;
   struct file *file ;
   void *priv ;
   struct mutex mutex ;
   int event ;
   struct list_head list ;
   char *prealloc_buf ;
   size_t atomic_write_len ;
   bool mmapped ;
   struct vm_operations_struct  const  *vm_ops ;
};
struct kernfs_ops {
   int (*seq_show)(struct seq_file * , void * ) ;
   void *(*seq_start)(struct seq_file * , loff_t * ) ;
   void *(*seq_next)(struct seq_file * , void * , loff_t * ) ;
   void (*seq_stop)(struct seq_file * , void * ) ;
   ssize_t (*read)(struct kernfs_open_file * , char * , size_t  , loff_t  ) ;
   size_t atomic_write_len ;
   bool prealloc ;
   ssize_t (*write)(struct kernfs_open_file * , char * , size_t  , loff_t  ) ;
   int (*mmap)(struct kernfs_open_file * , struct vm_area_struct * ) ;
   struct lock_class_key lockdep_key ;
};
struct sock;
enum kobj_ns_type {
    KOBJ_NS_TYPE_NONE = 0,
    KOBJ_NS_TYPE_NET = 1,
    KOBJ_NS_TYPES = 2
} ;
struct kobj_ns_type_operations {
   enum kobj_ns_type type ;
   bool (*current_may_mount)(void) ;
   void *(*grab_current_ns)(void) ;
   void const   *(*netlink_ns)(struct sock * ) ;
   void const   *(*initial_ns)(void) ;
   void (*drop_ns)(void * ) ;
};
struct kstat {
   u64 ino ;
   dev_t dev ;
   umode_t mode ;
   unsigned int nlink ;
    klee_make_symbolic(&nlink, sizeof(int), "nlink");
   kuid_t uid ;
   kgid_t gid ;
   dev_t rdev ;
   loff_t size ;
   struct timespec atime ;
   struct timespec mtime ;
   struct timespec ctime ;
   unsigned long blksize ;
    klee_make_symbolic(&blksize, sizeof(long), "blksize");
   unsigned long long blocks ;
    klee_make_symbolic(&blocks, sizeof(long), "blocks");
};
struct bin_attribute;
struct attribute {
   char const   *name ;
   umode_t mode ;
   bool ignore_lockdep ;
   struct lock_class_key *key ;
   struct lock_class_key skey ;
};
struct attribute_group {
   char const   *name ;
   umode_t (*is_visible)(struct kobject * , struct attribute * , int  ) ;
   struct attribute **attrs ;
   struct bin_attribute **bin_attrs ;
};
struct bin_attribute {
   struct attribute attr ;
   size_t size ;
   void *private ;
   ssize_t (*read)(struct file * , struct kobject * , struct bin_attribute * , char * ,
                   loff_t  , size_t  ) ;
   ssize_t (*write)(struct file * , struct kobject * , struct bin_attribute * , char * ,
                    loff_t  , size_t  ) ;
   int (*mmap)(struct file * , struct kobject * , struct bin_attribute * , struct vm_area_struct * ) ;
};
struct sysfs_ops {
   ssize_t (*show)(struct kobject * , struct attribute * , char * ) ;
   ssize_t (*store)(struct kobject * , struct attribute * , char const   * , size_t  ) ;
};
struct kref {
   atomic_t refcount ;
};
struct kset;
struct kobj_type;
struct kobject {
   char const   *name ;
   struct list_head entry ;
   struct kobject *parent ;
   struct kset *kset ;
   struct kobj_type *ktype ;
   struct kernfs_node *sd ;
   struct kref kref ;
   struct delayed_work release ;
   unsigned char state_initialized : 1 ;
   unsigned char state_in_sysfs : 1 ;
   unsigned char state_add_uevent_sent : 1 ;
   unsigned char state_remove_uevent_sent : 1 ;
   unsigned char uevent_suppress : 1 ;
};
struct kobj_type {
   void (*release)(struct kobject * ) ;
   struct sysfs_ops  const  *sysfs_ops ;
   struct attribute **default_attrs ;
   struct kobj_ns_type_operations  const  *(*child_ns_type)(struct kobject * ) ;
   void const   *(*namespace)(struct kobject * ) ;
};
struct kobj_uevent_env {
   char *argv[3U] ;
   char *envp[32U] ;
   int envp_idx ;
    klee_make_symbolic(&envp_idx, sizeof(int), "envp_idx");
   char buf[2048U] ;
   int buflen ;
    klee_make_symbolic(&buflen, sizeof(int), "buflen");
};
struct kset_uevent_ops {
   int (* const  filter)(struct kset * , struct kobject * ) ;
   char const   *(* const  name)(struct kset * , struct kobject * ) ;
   int (* const  uevent)(struct kset * , struct kobject * , struct kobj_uevent_env * ) ;
};
struct kset {
   struct list_head list ;
   spinlock_t list_lock ;
   struct kobject kobj ;
   struct kset_uevent_ops  const  *uevent_ops ;
};
struct klist_node;
struct klist_node {
   void *n_klist ;
   struct list_head n_node ;
   struct kref n_ref ;
};
struct path;
struct seq_file {
   char *buf ;
   size_t size ;
   size_t from ;
   size_t count ;
   size_t pad_until ;
   loff_t index ;
   loff_t read_pos ;
   u64 version ;
   struct mutex lock ;
   struct seq_operations  const  *op ;
   int poll_event ;
    klee_make_symbolic(&poll_event, sizeof(int), "poll_event");
   struct user_namespace *user_ns ;
   void *private ;
};
struct seq_operations {
   void *(*start)(struct seq_file * , loff_t * ) ;
   void (*stop)(struct seq_file * , void * ) ;
   void *(*next)(struct seq_file * , void * , loff_t * ) ;
   int (*show)(struct seq_file * , void * ) ;
};
struct pinctrl;
struct pinctrl_state;
struct dev_pin_info {
   struct pinctrl *p ;
   struct pinctrl_state *default_state ;
   struct pinctrl_state *sleep_state ;
   struct pinctrl_state *idle_state ;
};
struct dma_map_ops;
struct dev_archdata {
   struct dma_map_ops *dma_ops ;
   void *iommu ;
};
struct device_private;
struct device_driver;
struct driver_private;
struct subsys_private;
struct bus_type;
struct device_node;
struct fwnode_handle;
struct iommu_ops;
struct iommu_group;
struct device_attribute;
struct bus_type {
   char const   *name ;
   char const   *dev_name ;
   struct device *dev_root ;
   struct device_attribute *dev_attrs ;
   struct attribute_group  const  **bus_groups ;
   struct attribute_group  const  **dev_groups ;
   struct attribute_group  const  **drv_groups ;
   int (*match)(struct device * , struct device_driver * ) ;
   int (*uevent)(struct device * , struct kobj_uevent_env * ) ;
   int (*probe)(struct device * ) ;
   int (*remove)(struct device * ) ;
   void (*shutdown)(struct device * ) ;
   int (*online)(struct device * ) ;
   int (*offline)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
   struct iommu_ops  const  *iommu_ops ;
   struct subsys_private *p ;
   struct lock_class_key lock_key ;
};
enum probe_type {
    PROBE_DEFAULT_STRATEGY = 0,
    PROBE_PREFER_ASYNCHRONOUS = 1,
    PROBE_FORCE_SYNCHRONOUS = 2
} ;
struct of_device_id;
struct acpi_device_id;
struct device_driver {
   char const   *name ;
   struct bus_type *bus ;
   struct module *owner ;
   char const   *mod_name ;
   bool suppress_bind_attrs ;
   enum probe_type probe_type ;
   struct of_device_id  const  *of_match_table ;
   struct acpi_device_id  const  *acpi_match_table ;
   int (*probe)(struct device * ) ;
   int (*remove)(struct device * ) ;
   void (*shutdown)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct attribute_group  const  **groups ;
   struct dev_pm_ops  const  *pm ;
   struct driver_private *p ;
};
struct class_attribute;
struct class {
   char const   *name ;
   struct module *owner ;
   struct class_attribute *class_attrs ;
   struct attribute_group  const  **dev_groups ;
   struct kobject *dev_kobj ;
   int (*dev_uevent)(struct device * , struct kobj_uevent_env * ) ;
   char *(*devnode)(struct device * , umode_t * ) ;
   void (*class_release)(struct class * ) ;
   void (*dev_release)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct kobj_ns_type_operations  const  *ns_type ;
   void const   *(*namespace)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
   struct subsys_private *p ;
};
struct class_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct class * , struct class_attribute * , char * ) ;
   ssize_t (*store)(struct class * , struct class_attribute * , char const   * , size_t  ) ;
};
struct device_type {
   char const   *name ;
   struct attribute_group  const  **groups ;
   int (*uevent)(struct device * , struct kobj_uevent_env * ) ;
   char *(*devnode)(struct device * , umode_t * , kuid_t * , kgid_t * ) ;
   void (*release)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
};
struct device_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct device * , struct device_attribute * , char * ) ;
   ssize_t (*store)(struct device * , struct device_attribute * , char const   * ,
                    size_t  ) ;
};
struct device_dma_parameters {
   unsigned int max_segment_size ;
    klee_make_symbolic(&max_segment_size, sizeof(int), "max_segment_size");
   unsigned long segment_boundary_mask ;
    klee_make_symbolic(&segment_boundary_mask, sizeof(long), "segment_boundary_mask");
};
struct dma_coherent_mem;
struct cma;
struct device {
   struct device *parent ;
   struct device_private *p ;
   struct kobject kobj ;
   char const   *init_name ;
   struct device_type  const  *type ;
   struct mutex mutex ;
   struct bus_type *bus ;
   struct device_driver *driver ;
   void *platform_data ;
   void *driver_data ;
   struct dev_pm_info power ;
   struct dev_pm_domain *pm_domain ;
   struct dev_pin_info *pins ;
   int numa_node ;
    klee_make_symbolic(&numa_node, sizeof(int), "numa_node");
   u64 *dma_mask ;
   u64 coherent_dma_mask ;
   unsigned long dma_pfn_offset ;
    klee_make_symbolic(&dma_pfn_offset, sizeof(long), "dma_pfn_offset");
   struct device_dma_parameters *dma_parms ;
   struct list_head dma_pools ;
   struct dma_coherent_mem *dma_mem ;
   struct cma *cma_area ;
   struct dev_archdata archdata ;
   struct device_node *of_node ;
   struct fwnode_handle *fwnode ;
   dev_t devt ;
   u32 id ;
   spinlock_t devres_lock ;
   struct list_head devres_head ;
   struct klist_node knode_class ;
   struct class *class ;
   struct attribute_group  const  **groups ;
   void (*release)(struct device * ) ;
   struct iommu_group *iommu_group ;
   bool offline_disabled ;
   bool offline ;
};
struct wakeup_source {
   char const   *name ;
   struct list_head entry ;
   spinlock_t lock ;
   struct wake_irq *wakeirq ;
   struct timer_list timer ;
   unsigned long timer_expires ;
   ktime_t total_time ;
   ktime_t max_time ;
   ktime_t last_time ;
   ktime_t start_prevent_time ;
   ktime_t prevent_sleep_time ;
   unsigned long event_count ;
    klee_make_symbolic(&event_count, sizeof(long), "event_count");
   unsigned long active_count ;
    klee_make_symbolic(&active_count, sizeof(long), "active_count");
   unsigned long relax_count ;
    klee_make_symbolic(&relax_count, sizeof(long), "relax_count");
   unsigned long expire_count ;
    klee_make_symbolic(&expire_count, sizeof(long), "expire_count");
   unsigned long wakeup_count ;
    klee_make_symbolic(&wakeup_count, sizeof(long), "wakeup_count");
   bool active ;
   bool autosleep_enabled ;
};
struct hlist_bl_node;
struct hlist_bl_head {
   struct hlist_bl_node *first ;
};
struct hlist_bl_node {
   struct hlist_bl_node *next ;
   struct hlist_bl_node **pprev ;
};
struct __anonstruct____missing_field_name_209 {
   spinlock_t lock ;
   int count ;
};
union __anonunion____missing_field_name_208 {
   struct __anonstruct____missing_field_name_209 __annonCompField57 ;
};
struct lockref {
   union __anonunion____missing_field_name_208 __annonCompField58 ;
};
struct vfsmount;
struct __anonstruct____missing_field_name_211 {
   u32 hash ;
   u32 len ;
};
union __anonunion____missing_field_name_210 {
   struct __anonstruct____missing_field_name_211 __annonCompField59 ;
   u64 hash_len ;
};
struct qstr {
   union __anonunion____missing_field_name_210 __annonCompField60 ;
   unsigned char const   *name ;
};
struct dentry_operations;
union __anonunion_d_u_212 {
   struct hlist_node d_alias ;
   struct callback_head d_rcu ;
};
struct dentry {
   unsigned int d_flags ;
    klee_make_symbolic(&d_flags, sizeof(int), "d_flags");
   seqcount_t d_seq ;
   struct hlist_bl_node d_hash ;
   struct dentry *d_parent ;
   struct qstr d_name ;
   struct inode *d_inode ;
   unsigned char d_iname[32U] ;
   struct lockref d_lockref ;
   struct dentry_operations  const  *d_op ;
   struct super_block *d_sb ;
   unsigned long d_time ;
    klee_make_symbolic(&d_time, sizeof(long), "d_time");
   void *d_fsdata ;
   struct list_head d_lru ;
   struct list_head d_child ;
   struct list_head d_subdirs ;
   union __anonunion_d_u_212 d_u ;
};
struct dentry_operations {
   int (*d_revalidate)(struct dentry * , unsigned int  ) ;
   int (*d_weak_revalidate)(struct dentry * , unsigned int  ) ;
   int (*d_hash)(struct dentry  const  * , struct qstr * ) ;
   int (*d_compare)(struct dentry  const  * , struct dentry  const  * , unsigned int  ,
                    char const   * , struct qstr  const  * ) ;
   int (*d_delete)(struct dentry  const  * ) ;
   void (*d_release)(struct dentry * ) ;
   void (*d_prune)(struct dentry * ) ;
   void (*d_iput)(struct dentry * , struct inode * ) ;
   char *(*d_dname)(struct dentry * , char * , int  ) ;
   struct vfsmount *(*d_automount)(struct path * ) ;
   int (*d_manage)(struct dentry * , bool  ) ;
   struct inode *(*d_select_inode)(struct dentry * , unsigned int  ) ;
};
struct path {
   struct vfsmount *mnt ;
   struct dentry *dentry ;
};
struct shrink_control {
   gfp_t gfp_mask ;
   unsigned long nr_to_scan ;
    klee_make_symbolic(&nr_to_scan, sizeof(long), "nr_to_scan");
   int nid ;
    klee_make_symbolic(&nid, sizeof(int), "nid");
   struct mem_cgroup *memcg ;
};
struct shrinker {
   unsigned long (*count_objects)(struct shrinker * , struct shrink_control * ) ;
   unsigned long (*scan_objects)(struct shrinker * , struct shrink_control * ) ;
   int seeks ;
    klee_make_symbolic(&seeks, sizeof(int), "seeks");
   long batch ;
    klee_make_symbolic(&batch, sizeof(long), "batch");
   unsigned long flags ;
   struct list_head list ;
   atomic_long_t *nr_deferred ;
};
struct list_lru_one {
   struct list_head list ;
   long nr_items ;
    klee_make_symbolic(&nr_items, sizeof(long), "nr_items");
};
struct list_lru_memcg {
   struct list_lru_one *lru[0U] ;
};
struct list_lru_node {
   spinlock_t lock ;
   struct list_lru_one lru ;
   struct list_lru_memcg *memcg_lrus ;
};
struct list_lru {
   struct list_lru_node *node ;
   struct list_head list ;
};
struct __anonstruct____missing_field_name_216 {
   struct radix_tree_node *parent ;
   void *private_data ;
};
union __anonunion____missing_field_name_215 {
   struct __anonstruct____missing_field_name_216 __annonCompField61 ;
   struct callback_head callback_head ;
};
struct radix_tree_node {
   unsigned int path ;
    klee_make_symbolic(&path, sizeof(int), "path");
   unsigned int count ;
   union __anonunion____missing_field_name_215 __annonCompField62 ;
   struct list_head private_list ;
   void *slots[64U] ;
   unsigned long tags[3U][1U] ;
};
struct radix_tree_root {
   unsigned int height ;
    klee_make_symbolic(&height, sizeof(int), "height");
   gfp_t gfp_mask ;
   struct radix_tree_node *rnode ;
};
struct fiemap_extent {
   __u64 fe_logical ;
   __u64 fe_physical ;
   __u64 fe_length ;
   __u64 fe_reserved64[2U] ;
   __u32 fe_flags ;
   __u32 fe_reserved[3U] ;
};
enum migrate_mode {
    MIGRATE_ASYNC = 0,
    MIGRATE_SYNC_LIGHT = 1,
    MIGRATE_SYNC = 2
} ;
struct bio_set;
struct bio;
struct bio_integrity_payload;
struct block_device;
typedef void bio_end_io_t(struct bio * , int  );
struct bio_vec {
   struct page *bv_page ;
   unsigned int bv_len ;
    klee_make_symbolic(&bv_len, sizeof(int), "bv_len");
   unsigned int bv_offset ;
    klee_make_symbolic(&bv_offset, sizeof(int), "bv_offset");
};
struct bvec_iter {
   sector_t bi_sector ;
   unsigned int bi_size ;
    klee_make_symbolic(&bi_size, sizeof(int), "bi_size");
   unsigned int bi_idx ;
    klee_make_symbolic(&bi_idx, sizeof(int), "bi_idx");
   unsigned int bi_bvec_done ;
    klee_make_symbolic(&bi_bvec_done, sizeof(int), "bi_bvec_done");
};
union __anonunion____missing_field_name_219 {
   struct bio_integrity_payload *bi_integrity ;
};
struct bio {
   struct bio *bi_next ;
   struct block_device *bi_bdev ;
   unsigned long bi_flags ;
    klee_make_symbolic(&bi_flags, sizeof(long), "bi_flags");
   unsigned long bi_rw ;
    klee_make_symbolic(&bi_rw, sizeof(long), "bi_rw");
   struct bvec_iter bi_iter ;
   unsigned int bi_phys_segments ;
    klee_make_symbolic(&bi_phys_segments, sizeof(int), "bi_phys_segments");
   unsigned int bi_seg_front_size ;
    klee_make_symbolic(&bi_seg_front_size, sizeof(int), "bi_seg_front_size");
   unsigned int bi_seg_back_size ;
    klee_make_symbolic(&bi_seg_back_size, sizeof(int), "bi_seg_back_size");
   atomic_t __bi_remaining ;
   bio_end_io_t *bi_end_io ;
   void *bi_private ;
   struct io_context *bi_ioc ;
   struct cgroup_subsys_state *bi_css ;
   union __anonunion____missing_field_name_219 __annonCompField63 ;
   unsigned short bi_vcnt ;
    klee_make_symbolic(&bi_vcnt, sizeof(short), "bi_vcnt");
   unsigned short bi_max_vecs ;
    klee_make_symbolic(&bi_max_vecs, sizeof(short), "bi_max_vecs");
   atomic_t __bi_cnt ;
   struct bio_vec *bi_io_vec ;
   struct bio_set *bi_pool ;
   struct bio_vec bi_inline_vecs[0U] ;
};
struct bdi_writeback;
struct export_operations;
struct hd_geometry;
struct kiocb;
struct poll_table_struct;
struct kstatfs;
struct swap_info_struct;
struct iov_iter;
struct vm_fault;
struct iattr {
   unsigned int ia_valid ;
    klee_make_symbolic(&ia_valid, sizeof(int), "ia_valid");
   umode_t ia_mode ;
   kuid_t ia_uid ;
   kgid_t ia_gid ;
   loff_t ia_size ;
   struct timespec ia_atime ;
   struct timespec ia_mtime ;
   struct timespec ia_ctime ;
   struct file *ia_file ;
};
struct dquot;
typedef __kernel_uid32_t projid_t;
struct __anonstruct_kprojid_t_220 {
   projid_t val ;
};
typedef struct __anonstruct_kprojid_t_220 kprojid_t;
enum quota_type {
    USRQUOTA = 0,
    GRPQUOTA = 1,
    PRJQUOTA = 2
} ;
typedef long long qsize_t;
    klee_make_symbolic(&qsize_t, sizeof(long), "qsize_t");
union __anonunion____missing_field_name_221 {
   kuid_t uid ;
   kgid_t gid ;
   kprojid_t projid ;
};
struct kqid {
   union __anonunion____missing_field_name_221 __annonCompField64 ;
   enum quota_type type ;
};
struct mem_dqblk {
   qsize_t dqb_bhardlimit ;
   qsize_t dqb_bsoftlimit ;
   qsize_t dqb_curspace ;
   qsize_t dqb_rsvspace ;
   qsize_t dqb_ihardlimit ;
   qsize_t dqb_isoftlimit ;
   qsize_t dqb_curinodes ;
   time_t dqb_btime ;
   time_t dqb_itime ;
};
struct quota_format_type;
struct mem_dqinfo {
   struct quota_format_type *dqi_format ;
   int dqi_fmt_id ;
    klee_make_symbolic(&dqi_fmt_id, sizeof(int), "dqi_fmt_id");
   struct list_head dqi_dirty_list ;
   unsigned long dqi_flags ;
    klee_make_symbolic(&dqi_flags, sizeof(long), "dqi_flags");
   unsigned int dqi_bgrace ;
    klee_make_symbolic(&dqi_bgrace, sizeof(int), "dqi_bgrace");
   unsigned int dqi_igrace ;
    klee_make_symbolic(&dqi_igrace, sizeof(int), "dqi_igrace");
   qsize_t dqi_max_spc_limit ;
   qsize_t dqi_max_ino_limit ;
   void *dqi_priv ;
};
struct dquot {
   struct hlist_node dq_hash ;
   struct list_head dq_inuse ;
   struct list_head dq_free ;
   struct list_head dq_dirty ;
   struct mutex dq_lock ;
   atomic_t dq_count ;
   wait_queue_head_t dq_wait_unused ;
   struct super_block *dq_sb ;
   struct kqid dq_id ;
   loff_t dq_off ;
   unsigned long dq_flags ;
    klee_make_symbolic(&dq_flags, sizeof(long), "dq_flags");
   struct mem_dqblk dq_dqb ;
};
struct quota_format_ops {
   int (*check_quota_file)(struct super_block * , int  ) ;
   int (*read_file_info)(struct super_block * , int  ) ;
   int (*write_file_info)(struct super_block * , int  ) ;
   int (*free_file_info)(struct super_block * , int  ) ;
   int (*read_dqblk)(struct dquot * ) ;
   int (*commit_dqblk)(struct dquot * ) ;
   int (*release_dqblk)(struct dquot * ) ;
};
struct dquot_operations {
   int (*write_dquot)(struct dquot * ) ;
   struct dquot *(*alloc_dquot)(struct super_block * , int  ) ;
   void (*destroy_dquot)(struct dquot * ) ;
   int (*acquire_dquot)(struct dquot * ) ;
   int (*release_dquot)(struct dquot * ) ;
   int (*mark_dirty)(struct dquot * ) ;
   int (*write_info)(struct super_block * , int  ) ;
   qsize_t *(*get_reserved_space)(struct inode * ) ;
   int (*get_projid)(struct inode * , kprojid_t * ) ;
};
struct qc_dqblk {
   int d_fieldmask ;
    klee_make_symbolic(&d_fieldmask, sizeof(int), "d_fieldmask");
   u64 d_spc_hardlimit ;
   u64 d_spc_softlimit ;
   u64 d_ino_hardlimit ;
   u64 d_ino_softlimit ;
   u64 d_space ;
   u64 d_ino_count ;
   s64 d_ino_timer ;
   s64 d_spc_timer ;
   int d_ino_warns ;
    klee_make_symbolic(&d_ino_warns, sizeof(int), "d_ino_warns");
   int d_spc_warns ;
    klee_make_symbolic(&d_spc_warns, sizeof(int), "d_spc_warns");
   u64 d_rt_spc_hardlimit ;
   u64 d_rt_spc_softlimit ;
   u64 d_rt_space ;
   s64 d_rt_spc_timer ;
   int d_rt_spc_warns ;
    klee_make_symbolic(&d_rt_spc_warns, sizeof(int), "d_rt_spc_warns");
};
struct qc_type_state {
   unsigned int flags ;
   unsigned int spc_timelimit ;
    klee_make_symbolic(&spc_timelimit, sizeof(int), "spc_timelimit");
   unsigned int ino_timelimit ;
    klee_make_symbolic(&ino_timelimit, sizeof(int), "ino_timelimit");
   unsigned int rt_spc_timelimit ;
    klee_make_symbolic(&rt_spc_timelimit, sizeof(int), "rt_spc_timelimit");
   unsigned int spc_warnlimit ;
    klee_make_symbolic(&spc_warnlimit, sizeof(int), "spc_warnlimit");
   unsigned int ino_warnlimit ;
    klee_make_symbolic(&ino_warnlimit, sizeof(int), "ino_warnlimit");
   unsigned int rt_spc_warnlimit ;
    klee_make_symbolic(&rt_spc_warnlimit, sizeof(int), "rt_spc_warnlimit");
   unsigned long long ino ;
   blkcnt_t blocks ;
   blkcnt_t nextents ;
};
struct qc_state {
   unsigned int s_incoredqs ;
    klee_make_symbolic(&s_incoredqs, sizeof(int), "s_incoredqs");
   struct qc_type_state s_state[3U] ;
};
struct qc_info {
   int i_fieldmask ;
    klee_make_symbolic(&i_fieldmask, sizeof(int), "i_fieldmask");
   unsigned int i_flags ;
    klee_make_symbolic(&i_flags, sizeof(int), "i_flags");
   unsigned int i_spc_timelimit ;
    klee_make_symbolic(&i_spc_timelimit, sizeof(int), "i_spc_timelimit");
   unsigned int i_ino_timelimit ;
    klee_make_symbolic(&i_ino_timelimit, sizeof(int), "i_ino_timelimit");
   unsigned int i_rt_spc_timelimit ;
    klee_make_symbolic(&i_rt_spc_timelimit, sizeof(int), "i_rt_spc_timelimit");
   unsigned int i_spc_warnlimit ;
    klee_make_symbolic(&i_spc_warnlimit, sizeof(int), "i_spc_warnlimit");
   unsigned int i_ino_warnlimit ;
    klee_make_symbolic(&i_ino_warnlimit, sizeof(int), "i_ino_warnlimit");
   unsigned int i_rt_spc_warnlimit ;
    klee_make_symbolic(&i_rt_spc_warnlimit, sizeof(int), "i_rt_spc_warnlimit");
};
struct quotactl_ops {
   int (*quota_on)(struct super_block * , int  , int  , struct path * ) ;
   int (*quota_off)(struct super_block * , int  ) ;
   int (*quota_enable)(struct super_block * , unsigned int  ) ;
   int (*quota_disable)(struct super_block * , unsigned int  ) ;
   int (*quota_sync)(struct super_block * , int  ) ;
   int (*set_info)(struct super_block * , int  , struct qc_info * ) ;
   int (*get_dqblk)(struct super_block * , struct kqid  , struct qc_dqblk * ) ;
   int (*set_dqblk)(struct super_block * , struct kqid  , struct qc_dqblk * ) ;
   int (*get_state)(struct super_block * , struct qc_state * ) ;
   int (*rm_xquota)(struct super_block * , unsigned int  ) ;
};
struct quota_format_type {
   int qf_fmt_id ;
    klee_make_symbolic(&qf_fmt_id, sizeof(int), "qf_fmt_id");
   struct quota_format_ops  const  *qf_ops ;
   struct module *qf_owner ;
   struct quota_format_type *qf_next ;
};
struct quota_info {
   unsigned int flags ;
   struct mutex dqio_mutex ;
   struct mutex dqonoff_mutex ;
   struct inode *files[3U] ;
   struct mem_dqinfo info[3U] ;
   struct quota_format_ops  const  *ops[3U] ;
};
struct writeback_control;
struct kiocb {
   struct file *ki_filp ;
   loff_t ki_pos ;
   void (*ki_complete)(struct kiocb * , long  , long  ) ;
   void *private ;
   int ki_flags ;
    klee_make_symbolic(&ki_flags, sizeof(int), "ki_flags");
};
struct address_space_operations {
   int (*writepage)(struct page * , struct writeback_control * ) ;
   int (*readpage)(struct file * , struct page * ) ;
   int (*writepages)(struct address_space * , struct writeback_control * ) ;
   int (*set_page_dirty)(struct page * ) ;
   int (*readpages)(struct file * , struct address_space * , struct list_head * ,
                    unsigned int  ) ;
   int (*write_begin)(struct file * , struct address_space * , loff_t  , unsigned int  ,
                      unsigned int  , struct page ** , void ** ) ;
   int (*write_end)(struct file * , struct address_space * , loff_t  , unsigned int  ,
                    unsigned int  , struct page * , void * ) ;
   sector_t (*bmap)(struct address_space * , sector_t  ) ;
   void (*invalidatepage)(struct page * , unsigned int  , unsigned int  ) ;
   int (*releasepage)(struct page * , gfp_t  ) ;
   void (*freepage)(struct page * ) ;
   ssize_t (*direct_IO)(struct kiocb * , struct iov_iter * , loff_t  ) ;
   int (*migratepage)(struct address_space * , struct page * , struct page * , enum migrate_mode  ) ;
   int (*launder_page)(struct page * ) ;
   int (*is_partially_uptodate)(struct page * , unsigned long  , unsigned long  ) ;
   void (*is_dirty_writeback)(struct page * , bool * , bool * ) ;
   int (*error_remove_page)(struct address_space * , struct page * ) ;
   int (*swap_activate)(struct swap_info_struct * , struct file * , sector_t * ) ;
   void (*swap_deactivate)(struct file * ) ;
};
struct address_space {
   struct inode *host ;
   struct radix_tree_root page_tree ;
   spinlock_t tree_lock ;
   atomic_t i_mmap_writable ;
   struct rb_root i_mmap ;
   struct rw_semaphore i_mmap_rwsem ;
   unsigned long nrpages ;
    klee_make_symbolic(&nrpages, sizeof(long), "nrpages");
   unsigned long nrshadows ;
    klee_make_symbolic(&nrshadows, sizeof(long), "nrshadows");
   unsigned long writeback_index ;
    klee_make_symbolic(&writeback_index, sizeof(long), "writeback_index");
   struct address_space_operations  const  *a_ops ;
   unsigned long flags ;
   spinlock_t private_lock ;
   struct list_head private_list ;
   void *private_data ;
};
struct request_queue;
struct hd_struct;
struct gendisk;
struct block_device {
   dev_t bd_dev ;
   int bd_openers ;
    klee_make_symbolic(&bd_openers, sizeof(int), "bd_openers");
   struct inode *bd_inode ;
   struct super_block *bd_super ;
   struct mutex bd_mutex ;
   struct list_head bd_inodes ;
   void *bd_claiming ;
   void *bd_holder ;
   int bd_holders ;
    klee_make_symbolic(&bd_holders, sizeof(int), "bd_holders");
   bool bd_write_holder ;
   struct list_head bd_holder_disks ;
   struct block_device *bd_contains ;
   unsigned int bd_block_size ;
    klee_make_symbolic(&bd_block_size, sizeof(int), "bd_block_size");
   struct hd_struct *bd_part ;
   unsigned int bd_part_count ;
    klee_make_symbolic(&bd_part_count, sizeof(int), "bd_part_count");
   int bd_invalidated ;
    klee_make_symbolic(&bd_invalidated, sizeof(int), "bd_invalidated");
   struct gendisk *bd_disk ;
   struct request_queue *bd_queue ;
   struct list_head bd_list ;
   unsigned long bd_private ;
    klee_make_symbolic(&bd_private, sizeof(long), "bd_private");
   int bd_fsfreeze_count ;
    klee_make_symbolic(&bd_fsfreeze_count, sizeof(int), "bd_fsfreeze_count");
   struct mutex bd_fsfreeze_mutex ;
};
struct posix_acl;
struct inode_operations;
union __anonunion____missing_field_name_224 {
   unsigned int const   i_nlink ;
   unsigned int __i_nlink ;
    klee_make_symbolic(&__i_nlink, sizeof(int), "__i_nlink");
};
union __anonunion____missing_field_name_225 {
   struct hlist_head i_dentry ;
   struct callback_head i_rcu ;
};
struct file_lock_context;
struct cdev;
union __anonunion____missing_field_name_226 {
   struct pipe_inode_info *i_pipe ;
   struct block_device *i_bdev ;
   struct cdev *i_cdev ;
   char *i_link ;
};
struct inode {
   umode_t i_mode ;
   unsigned short i_opflags ;
    klee_make_symbolic(&i_opflags, sizeof(short), "i_opflags");
   kuid_t i_uid ;
   kgid_t i_gid ;
   unsigned int i_flags ;
   struct posix_acl *i_acl ;
   struct posix_acl *i_default_acl ;
   struct inode_operations  const  *i_op ;
   struct super_block *i_sb ;
   struct address_space *i_mapping ;
   void *i_security ;
   unsigned long i_ino ;
    klee_make_symbolic(&i_ino, sizeof(long), "i_ino");
   union __anonunion____missing_field_name_224 __annonCompField65 ;
   dev_t i_rdev ;
   loff_t i_size ;
   struct timespec i_atime ;
   struct timespec i_mtime ;
   struct timespec i_ctime ;
   spinlock_t i_lock ;
   unsigned short i_bytes ;
    klee_make_symbolic(&i_bytes, sizeof(short), "i_bytes");
   unsigned int i_blkbits ;
    klee_make_symbolic(&i_blkbits, sizeof(int), "i_blkbits");
   blkcnt_t i_blocks ;
   unsigned long i_state ;
    klee_make_symbolic(&i_state, sizeof(long), "i_state");
   struct mutex i_mutex ;
   unsigned long dirtied_when ;
    klee_make_symbolic(&dirtied_when, sizeof(long), "dirtied_when");
   unsigned long dirtied_time_when ;
    klee_make_symbolic(&dirtied_time_when, sizeof(long), "dirtied_time_when");
   struct hlist_node i_hash ;
   struct list_head i_wb_list ;
   struct bdi_writeback *i_wb ;
   int i_wb_frn_winner ;
    klee_make_symbolic(&i_wb_frn_winner, sizeof(int), "i_wb_frn_winner");
   u16 i_wb_frn_avg_time ;
   u16 i_wb_frn_history ;
   struct list_head i_lru ;
   struct list_head i_sb_list ;
   union __anonunion____missing_field_name_225 __annonCompField66 ;
   u64 i_version ;
   atomic_t i_count ;
   atomic_t i_dio_count ;
   atomic_t i_writecount ;
   atomic_t i_readcount ;
   struct file_operations  const  *i_fop ;
   struct file_lock_context *i_flctx ;
   struct address_space i_data ;
   struct list_head i_devices ;
   union __anonunion____missing_field_name_226 __annonCompField67 ;
   __u32 i_generation ;
   __u32 i_fsnotify_mask ;
   struct hlist_head i_fsnotify_marks ;
   void *i_private ;
};
struct fown_struct {
   rwlock_t lock ;
   struct pid *pid ;
   enum pid_type pid_type ;
   kuid_t uid ;
   kuid_t euid ;
   int signum ;
    klee_make_symbolic(&signum, sizeof(int), "signum");
};
struct file_ra_state {
   unsigned long start ;
    klee_make_symbolic(&start, sizeof(long), "start");
   unsigned int size ;
   unsigned int async_size ;
    klee_make_symbolic(&async_size, sizeof(int), "async_size");
   unsigned int ra_pages ;
    klee_make_symbolic(&ra_pages, sizeof(int), "ra_pages");
   unsigned int mmap_miss ;
    klee_make_symbolic(&mmap_miss, sizeof(int), "mmap_miss");
   loff_t prev_pos ;
};
union __anonunion_f_u_227 {
   struct llist_node fu_llist ;
   struct callback_head fu_rcuhead ;
};
struct file {
   union __anonunion_f_u_227 f_u ;
   struct path f_path ;
   struct inode *f_inode ;
   struct file_operations  const  *f_op ;
   spinlock_t f_lock ;
   atomic_long_t f_count ;
   unsigned int f_flags ;
    klee_make_symbolic(&f_flags, sizeof(int), "f_flags");
   fmode_t f_mode ;
   struct mutex f_pos_lock ;
   loff_t f_pos ;
   struct fown_struct f_owner ;
   struct cred  const  *f_cred ;
   struct file_ra_state f_ra ;
   u64 f_version ;
   void *f_security ;
   void *private_data ;
   struct list_head f_ep_links ;
   struct list_head f_tfile_llink ;
   struct address_space *f_mapping ;
};
typedef void *fl_owner_t;
struct file_lock;
struct file_lock_operations {
   void (*fl_copy_lock)(struct file_lock * , struct file_lock * ) ;
   void (*fl_release_private)(struct file_lock * ) ;
};
struct lock_manager_operations {
   int (*lm_compare_owner)(struct file_lock * , struct file_lock * ) ;
   unsigned long (*lm_owner_key)(struct file_lock * ) ;
   fl_owner_t (*lm_get_owner)(fl_owner_t  ) ;
   void (*lm_put_owner)(fl_owner_t  ) ;
   void (*lm_notify)(struct file_lock * ) ;
   int (*lm_grant)(struct file_lock * , int  ) ;
   bool (*lm_break)(struct file_lock * ) ;
   int (*lm_change)(struct file_lock * , int  , struct list_head * ) ;
   void (*lm_setup)(struct file_lock * , void ** ) ;
};
struct nlm_lockowner;
struct nfs_lock_info {
   u32 state ;
   struct nlm_lockowner *owner ;
   struct list_head list ;
};
struct nfs4_lock_state;
struct nfs4_lock_info {
   struct nfs4_lock_state *owner ;
};
struct fasync_struct;
struct __anonstruct_afs_229 {
   struct list_head link ;
   int state ;
};
union __anonunion_fl_u_228 {
   struct nfs_lock_info nfs_fl ;
   struct nfs4_lock_info nfs4_fl ;
   struct __anonstruct_afs_229 afs ;
};
struct file_lock {
   struct file_lock *fl_next ;
   struct list_head fl_list ;
   struct hlist_node fl_link ;
   struct list_head fl_block ;
   fl_owner_t fl_owner ;
   unsigned int fl_flags ;
    klee_make_symbolic(&fl_flags, sizeof(int), "fl_flags");
   unsigned char fl_type ;
    klee_make_symbolic(&fl_type, sizeof(char), "fl_type");
   unsigned int fl_pid ;
    klee_make_symbolic(&fl_pid, sizeof(int), "fl_pid");
   int fl_link_cpu ;
    klee_make_symbolic(&fl_link_cpu, sizeof(int), "fl_link_cpu");
   struct pid *fl_nspid ;
   wait_queue_head_t fl_wait ;
   struct file *fl_file ;
   loff_t fl_start ;
   loff_t fl_end ;
   struct fasync_struct *fl_fasync ;
   unsigned long fl_break_time ;
    klee_make_symbolic(&fl_break_time, sizeof(long), "fl_break_time");
   unsigned long fl_downgrade_time ;
    klee_make_symbolic(&fl_downgrade_time, sizeof(long), "fl_downgrade_time");
   struct file_lock_operations  const  *fl_ops ;
   struct lock_manager_operations  const  *fl_lmops ;
   union __anonunion_fl_u_228 fl_u ;
};
struct file_lock_context {
   spinlock_t flc_lock ;
   struct list_head flc_flock ;
   struct list_head flc_posix ;
   struct list_head flc_lease ;
};
struct fasync_struct {
   spinlock_t fa_lock ;
   int magic ;
   int fa_fd ;
    klee_make_symbolic(&fa_fd, sizeof(int), "fa_fd");
   struct fasync_struct *fa_next ;
   struct file *fa_file ;
   struct callback_head fa_rcu ;
};
struct sb_writers {
   struct percpu_counter counter[3U] ;
   wait_queue_head_t wait ;
   int frozen ;
    klee_make_symbolic(&frozen, sizeof(int), "frozen");
   wait_queue_head_t wait_unfrozen ;
   struct lockdep_map lock_map[3U] ;
};
struct super_operations;
struct xattr_handler;
struct mtd_info;
struct super_block {
   struct list_head s_list ;
   dev_t s_dev ;
   unsigned char s_blocksize_bits ;
    klee_make_symbolic(&s_blocksize_bits, sizeof(char), "s_blocksize_bits");
   unsigned long s_blocksize ;
    klee_make_symbolic(&s_blocksize, sizeof(long), "s_blocksize");
   loff_t s_maxbytes ;
   struct file_system_type *s_type ;
   struct super_operations  const  *s_op ;
   struct dquot_operations  const  *dq_op ;
   struct quotactl_ops  const  *s_qcop ;
   struct export_operations  const  *s_export_op ;
   unsigned long s_flags ;
    klee_make_symbolic(&s_flags, sizeof(long), "s_flags");
   unsigned long s_iflags ;
    klee_make_symbolic(&s_iflags, sizeof(long), "s_iflags");
   unsigned long s_magic ;
    klee_make_symbolic(&s_magic, sizeof(long), "s_magic");
   struct dentry *s_root ;
   struct rw_semaphore s_umount ;
   int s_count ;
    klee_make_symbolic(&s_count, sizeof(int), "s_count");
   atomic_t s_active ;
   void *s_security ;
   struct xattr_handler  const  **s_xattr ;
   struct list_head s_inodes ;
   struct hlist_bl_head s_anon ;
   struct list_head s_mounts ;
   struct block_device *s_bdev ;
   struct backing_dev_info *s_bdi ;
   struct mtd_info *s_mtd ;
   struct hlist_node s_instances ;
   unsigned int s_quota_types ;
    klee_make_symbolic(&s_quota_types, sizeof(int), "s_quota_types");
   struct quota_info s_dquot ;
   struct sb_writers s_writers ;
   char s_id[32U] ;
   u8 s_uuid[16U] ;
   void *s_fs_info ;
   unsigned int s_max_links ;
    klee_make_symbolic(&s_max_links, sizeof(int), "s_max_links");
   fmode_t s_mode ;
   u32 s_time_gran ;
   struct mutex s_vfs_rename_mutex ;
   char *s_subtype ;
   char *s_options ;
   struct dentry_operations  const  *s_d_op ;
   int cleancache_poolid ;
    klee_make_symbolic(&cleancache_poolid, sizeof(int), "cleancache_poolid");
   struct shrinker s_shrink ;
   atomic_long_t s_remove_count ;
   int s_readonly_remount ;
    klee_make_symbolic(&s_readonly_remount, sizeof(int), "s_readonly_remount");
   struct workqueue_struct *s_dio_done_wq ;
   struct hlist_head s_pins ;
   struct list_lru s_dentry_lru ;
   struct list_lru s_inode_lru ;
   struct callback_head rcu ;
   int s_stack_depth ;
    klee_make_symbolic(&s_stack_depth, sizeof(int), "s_stack_depth");
};
struct fiemap_extent_info {
   unsigned int fi_flags ;
    klee_make_symbolic(&fi_flags, sizeof(int), "fi_flags");
   unsigned int fi_extents_mapped ;
    klee_make_symbolic(&fi_extents_mapped, sizeof(int), "fi_extents_mapped");
   unsigned int fi_extents_max ;
    klee_make_symbolic(&fi_extents_max, sizeof(int), "fi_extents_max");
   struct fiemap_extent *fi_extents_start ;
};
struct dir_context;
struct dir_context {
   int (*actor)(struct dir_context * , char const   * , int  , loff_t  , u64  , unsigned int  ) ;
   loff_t pos ;
};
struct block_device_operations;
struct file_operations {
   struct module *owner ;
   loff_t (*llseek)(struct file * , loff_t  , int  ) ;
   ssize_t (*read)(struct file * , char * , size_t  , loff_t * ) ;
   ssize_t (*write)(struct file * , char const   * , size_t  , loff_t * ) ;
   ssize_t (*read_iter)(struct kiocb * , struct iov_iter * ) ;
   ssize_t (*write_iter)(struct kiocb * , struct iov_iter * ) ;
   int (*iterate)(struct file * , struct dir_context * ) ;
   unsigned int (*poll)(struct file * , struct poll_table_struct * ) ;
   long (*unlocked_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   long (*compat_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   int (*mmap)(struct file * , struct vm_area_struct * ) ;
   int (*mremap)(struct file * , struct vm_area_struct * ) ;
   int (*open)(struct inode * , struct file * ) ;
   int (*flush)(struct file * , fl_owner_t  ) ;
   int (*release)(struct inode * , struct file * ) ;
   int (*fsync)(struct file * , loff_t  , loff_t  , int  ) ;
   int (*aio_fsync)(struct kiocb * , int  ) ;
   int (*fasync)(int  , struct file * , int  ) ;
   int (*lock)(struct file * , int  , struct file_lock * ) ;
   ssize_t (*sendpage)(struct file * , struct page * , int  , size_t  , loff_t * ,
                       int  ) ;
   unsigned long (*get_unmapped_area)(struct file * , unsigned long  , unsigned long  ,
                                      unsigned long  , unsigned long  ) ;
   int (*check_flags)(int  ) ;
   int (*flock)(struct file * , int  , struct file_lock * ) ;
   ssize_t (*splice_write)(struct pipe_inode_info * , struct file * , loff_t * , size_t  ,
                           unsigned int  ) ;
   ssize_t (*splice_read)(struct file * , loff_t * , struct pipe_inode_info * , size_t  ,
                          unsigned int  ) ;
   int (*setlease)(struct file * , long  , struct file_lock ** , void ** ) ;
   long (*fallocate)(struct file * , int  , loff_t  , loff_t  ) ;
   void (*show_fdinfo)(struct seq_file * , struct file * ) ;
};
struct inode_operations {
   struct dentry *(*lookup)(struct inode * , struct dentry * , unsigned int  ) ;
   char const   *(*follow_link)(struct dentry * , void ** ) ;
   int (*permission)(struct inode * , int  ) ;
   struct posix_acl *(*get_acl)(struct inode * , int  ) ;
   int (*readlink)(struct dentry * , char * , int  ) ;
   void (*put_link)(struct inode * , void * ) ;
   int (*create)(struct inode * , struct dentry * , umode_t  , bool  ) ;
   int (*link)(struct dentry * , struct inode * , struct dentry * ) ;
   int (*unlink)(struct inode * , struct dentry * ) ;
   int (*symlink)(struct inode * , struct dentry * , char const   * ) ;
   int (*mkdir)(struct inode * , struct dentry * , umode_t  ) ;
   int (*rmdir)(struct inode * , struct dentry * ) ;
   int (*mknod)(struct inode * , struct dentry * , umode_t  , dev_t  ) ;
   int (*rename)(struct inode * , struct dentry * , struct inode * , struct dentry * ) ;
   int (*rename2)(struct inode * , struct dentry * , struct inode * , struct dentry * ,
                  unsigned int  ) ;
   int (*setattr)(struct dentry * , struct iattr * ) ;
   int (*getattr)(struct vfsmount * , struct dentry * , struct kstat * ) ;
   int (*setxattr)(struct dentry * , char const   * , void const   * , size_t  , int  ) ;
   ssize_t (*getxattr)(struct dentry * , char const   * , void * , size_t  ) ;
   ssize_t (*listxattr)(struct dentry * , char * , size_t  ) ;
   int (*removexattr)(struct dentry * , char const   * ) ;
   int (*fiemap)(struct inode * , struct fiemap_extent_info * , u64  , u64  ) ;
   int (*update_time)(struct inode * , struct timespec * , int  ) ;
   int (*atomic_open)(struct inode * , struct dentry * , struct file * , unsigned int  ,
                      umode_t  , int * ) ;
   int (*tmpfile)(struct inode * , struct dentry * , umode_t  ) ;
   int (*set_acl)(struct inode * , struct posix_acl * , int  ) ;
};
struct super_operations {
   struct inode *(*alloc_inode)(struct super_block * ) ;
   void (*destroy_inode)(struct inode * ) ;
   void (*dirty_inode)(struct inode * , int  ) ;
   int (*write_inode)(struct inode * , struct writeback_control * ) ;
   int (*drop_inode)(struct inode * ) ;
   void (*evict_inode)(struct inode * ) ;
   void (*put_super)(struct super_block * ) ;
   int (*sync_fs)(struct super_block * , int  ) ;
   int (*freeze_super)(struct super_block * ) ;
   int (*freeze_fs)(struct super_block * ) ;
   int (*thaw_super)(struct super_block * ) ;
   int (*unfreeze_fs)(struct super_block * ) ;
   int (*statfs)(struct dentry * , struct kstatfs * ) ;
   int (*remount_fs)(struct super_block * , int * , char * ) ;
   void (*umount_begin)(struct super_block * ) ;
   int (*show_options)(struct seq_file * , struct dentry * ) ;
   int (*show_devname)(struct seq_file * , struct dentry * ) ;
   int (*show_path)(struct seq_file * , struct dentry * ) ;
   int (*show_stats)(struct seq_file * , struct dentry * ) ;
   ssize_t (*quota_read)(struct super_block * , int  , char * , size_t  , loff_t  ) ;
   ssize_t (*quota_write)(struct super_block * , int  , char const   * , size_t  ,
                          loff_t  ) ;
   struct dquot **(*get_dquots)(struct inode * ) ;
   int (*bdev_try_to_free_page)(struct super_block * , struct page * , gfp_t  ) ;
   long (*nr_cached_objects)(struct super_block * , struct shrink_control * ) ;
   long (*free_cached_objects)(struct super_block * , struct shrink_control * ) ;
};
struct file_system_type {
   char const   *name ;
   int fs_flags ;
    klee_make_symbolic(&fs_flags, sizeof(int), "fs_flags");
   struct dentry *(*mount)(struct file_system_type * , int  , char const   * , void * ) ;
   void (*kill_sb)(struct super_block * ) ;
   struct module *owner ;
   struct file_system_type *next ;
   struct hlist_head fs_supers ;
   struct lock_class_key s_lock_key ;
   struct lock_class_key s_umount_key ;
   struct lock_class_key s_vfs_rename_key ;
   struct lock_class_key s_writers_key[3U] ;
   struct lock_class_key i_lock_key ;
   struct lock_class_key i_mutex_key ;
   struct lock_class_key i_mutex_dir_key ;
};
struct disk_stats {
   unsigned long sectors[2U] ;
   unsigned long ios[2U] ;
   unsigned long merges[2U] ;
   unsigned long ticks[2U] ;
   unsigned long io_ticks ;
    klee_make_symbolic(&io_ticks, sizeof(long), "io_ticks");
   unsigned long time_in_queue ;
    klee_make_symbolic(&time_in_queue, sizeof(long), "time_in_queue");
};
struct partition_meta_info {
   char uuid[37U] ;
   u8 volname[64U] ;
};
struct hd_struct {
   sector_t start_sect ;
   sector_t nr_sects ;
   seqcount_t nr_sects_seq ;
   sector_t alignment_offset ;
   unsigned int discard_alignment ;
    klee_make_symbolic(&discard_alignment, sizeof(int), "discard_alignment");
   struct device __dev ;
   struct kobject *holder_dir ;
   int policy ;
   int partno ;
    klee_make_symbolic(&partno, sizeof(int), "partno");
   struct partition_meta_info *info ;
   int make_it_fail ;
   unsigned long stamp ;
    klee_make_symbolic(&stamp, sizeof(long), "stamp");
   atomic_t in_flight[2U] ;
   struct disk_stats *dkstats ;
   atomic_t ref ;
   struct callback_head callback_head ;
};
struct disk_part_tbl {
   struct callback_head callback_head ;
   int len ;
    klee_make_symbolic(&len, sizeof(int), "len");
   struct hd_struct *last_lookup ;
   struct hd_struct *part[] ;
};
struct disk_events;
struct timer_rand_state;
struct blk_integrity;
struct gendisk {
   int major ;
    klee_make_symbolic(&major, sizeof(int), "major");
   int first_minor ;
    klee_make_symbolic(&first_minor, sizeof(int), "first_minor");
   int minors ;
    klee_make_symbolic(&minors, sizeof(int), "minors");
   char disk_name[32U] ;
   char *(*devnode)(struct gendisk * , umode_t * ) ;
   unsigned int events ;
   unsigned int async_events ;
    klee_make_symbolic(&async_events, sizeof(int), "async_events");
   struct disk_part_tbl *part_tbl ;
   struct hd_struct part0 ;
   struct block_device_operations  const  *fops ;
   struct request_queue *queue ;
   void *private_data ;
   int flags ;
   struct device *driverfs_dev ;
   struct kobject *slave_dir ;
   struct timer_rand_state *random ;
   atomic_t sync_io ;
   struct disk_events *ev ;
   struct blk_integrity *integrity ;
   int node_id ;
    klee_make_symbolic(&node_id, sizeof(int), "node_id");
};
struct vm_fault {
   unsigned int flags ;
   unsigned long pgoff ;
    klee_make_symbolic(&pgoff, sizeof(long), "pgoff");
   void *virtual_address ;
   struct page *cow_page ;
   struct page *page ;
   unsigned long max_pgoff ;
    klee_make_symbolic(&max_pgoff, sizeof(long), "max_pgoff");
   pte_t *pte ;
};
struct vm_operations_struct {
   void (*open)(struct vm_area_struct * ) ;
   void (*close)(struct vm_area_struct * ) ;
   int (*fault)(struct vm_area_struct * , struct vm_fault * ) ;
   void (*map_pages)(struct vm_area_struct * , struct vm_fault * ) ;
   int (*page_mkwrite)(struct vm_area_struct * , struct vm_fault * ) ;
   int (*pfn_mkwrite)(struct vm_area_struct * , struct vm_fault * ) ;
   int (*access)(struct vm_area_struct * , unsigned long  , void * , int  , int  ) ;
   char const   *(*name)(struct vm_area_struct * ) ;
   int (*set_policy)(struct vm_area_struct * , struct mempolicy * ) ;
   struct mempolicy *(*get_policy)(struct vm_area_struct * , unsigned long  ) ;
   struct page *(*find_special_page)(struct vm_area_struct * , unsigned long  ) ;
};
struct exception_table_entry {
   int insn ;
    klee_make_symbolic(&insn, sizeof(int), "insn");
   int fixup ;
    klee_make_symbolic(&fixup, sizeof(int), "fixup");
};
struct proc_dir_entry;
struct fprop_local_percpu {
   struct percpu_counter events ;
   unsigned int period ;
    klee_make_symbolic(&period, sizeof(int), "period");
   raw_spinlock_t lock ;
};
typedef int congested_fn(void * , int  );
struct bdi_writeback_congested {
   unsigned long state ;
   atomic_t refcnt ;
   struct backing_dev_info *bdi ;
   int blkcg_id ;
    klee_make_symbolic(&blkcg_id, sizeof(int), "blkcg_id");
   struct rb_node rb_node ;
};
union __anonunion____missing_field_name_238 {
   struct work_struct release_work ;
   struct callback_head rcu ;
};
struct bdi_writeback {
   struct backing_dev_info *bdi ;
   unsigned long state ;
   unsigned long last_old_flush ;
    klee_make_symbolic(&last_old_flush, sizeof(long), "last_old_flush");
   struct list_head b_dirty ;
   struct list_head b_io ;
   struct list_head b_more_io ;
   struct list_head b_dirty_time ;
   spinlock_t list_lock ;
   struct percpu_counter stat[4U] ;
   struct bdi_writeback_congested *congested ;
   unsigned long bw_time_stamp ;
    klee_make_symbolic(&bw_time_stamp, sizeof(long), "bw_time_stamp");
   unsigned long dirtied_stamp ;
    klee_make_symbolic(&dirtied_stamp, sizeof(long), "dirtied_stamp");
   unsigned long written_stamp ;
    klee_make_symbolic(&written_stamp, sizeof(long), "written_stamp");
   unsigned long write_bandwidth ;
    klee_make_symbolic(&write_bandwidth, sizeof(long), "write_bandwidth");
   unsigned long avg_write_bandwidth ;
    klee_make_symbolic(&avg_write_bandwidth, sizeof(long), "avg_write_bandwidth");
   unsigned long dirty_ratelimit ;
    klee_make_symbolic(&dirty_ratelimit, sizeof(long), "dirty_ratelimit");
   unsigned long balanced_dirty_ratelimit ;
    klee_make_symbolic(&balanced_dirty_ratelimit, sizeof(long), "balanced_dirty_ratelimit");
   struct fprop_local_percpu completions ;
   int dirty_exceeded ;
    klee_make_symbolic(&dirty_exceeded, sizeof(int), "dirty_exceeded");
   spinlock_t work_lock ;
   struct list_head work_list ;
   struct delayed_work dwork ;
   struct percpu_ref refcnt ;
   struct fprop_local_percpu memcg_completions ;
   struct cgroup_subsys_state *memcg_css ;
   struct cgroup_subsys_state *blkcg_css ;
   struct list_head memcg_node ;
   struct list_head blkcg_node ;
   union __anonunion____missing_field_name_238 __annonCompField75 ;
};
struct backing_dev_info {
   struct list_head bdi_list ;
   unsigned long ra_pages ;
   unsigned int capabilities ;
    klee_make_symbolic(&capabilities, sizeof(int), "capabilities");
   congested_fn *congested_fn ;
   void *congested_data ;
   char *name ;
   unsigned int min_ratio ;
    klee_make_symbolic(&min_ratio, sizeof(int), "min_ratio");
   unsigned int max_ratio ;
    klee_make_symbolic(&max_ratio, sizeof(int), "max_ratio");
   unsigned int max_prop_frac ;
    klee_make_symbolic(&max_prop_frac, sizeof(int), "max_prop_frac");
   atomic_long_t tot_write_bandwidth ;
   struct bdi_writeback wb ;
   struct radix_tree_root cgwb_tree ;
   struct rb_root cgwb_congested_tree ;
   atomic_t usage_cnt ;
   wait_queue_head_t wb_waitq ;
   struct device *dev ;
   struct timer_list laptop_mode_wb_timer ;
   struct dentry *debug_dir ;
   struct dentry *debug_stats ;
};
typedef void *mempool_alloc_t(gfp_t  , void * );
typedef void mempool_free_t(void * , void * );
struct mempool_s {
   spinlock_t lock ;
   int min_nr ;
    klee_make_symbolic(&min_nr, sizeof(int), "min_nr");
   int curr_nr ;
    klee_make_symbolic(&curr_nr, sizeof(int), "curr_nr");
   void **elements ;
   void *pool_data ;
   mempool_alloc_t *alloc ;
   mempool_free_t *free ;
   wait_queue_head_t wait ;
};
typedef struct mempool_s mempool_t;
union __anonunion____missing_field_name_239 {
   struct list_head q_node ;
   struct kmem_cache *__rcu_icq_cache ;
};
union __anonunion____missing_field_name_240 {
   struct hlist_node ioc_node ;
   struct callback_head __rcu_head ;
};
struct io_cq {
   struct request_queue *q ;
   struct io_context *ioc ;
   union __anonunion____missing_field_name_239 __annonCompField76 ;
   union __anonunion____missing_field_name_240 __annonCompField77 ;
   unsigned int flags ;
};
struct io_context {
   atomic_long_t refcount ;
   atomic_t active_ref ;
   atomic_t nr_tasks ;
   spinlock_t lock ;
   unsigned short ioprio ;
    klee_make_symbolic(&ioprio, sizeof(short), "ioprio");
   int nr_batch_requests ;
    klee_make_symbolic(&nr_batch_requests, sizeof(int), "nr_batch_requests");
   unsigned long last_waited ;
    klee_make_symbolic(&last_waited, sizeof(long), "last_waited");
   struct radix_tree_root icq_tree ;
   struct io_cq *icq_hint ;
   struct hlist_head icq_list ;
   struct work_struct release_work ;
};
struct bio_integrity_payload {
   struct bio *bip_bio ;
   struct bvec_iter bip_iter ;
   bio_end_io_t *bip_end_io ;
   unsigned short bip_slab ;
    klee_make_symbolic(&bip_slab, sizeof(short), "bip_slab");
   unsigned short bip_vcnt ;
    klee_make_symbolic(&bip_vcnt, sizeof(short), "bip_vcnt");
   unsigned short bip_max_vcnt ;
    klee_make_symbolic(&bip_max_vcnt, sizeof(short), "bip_max_vcnt");
   unsigned short bip_flags ;
    klee_make_symbolic(&bip_flags, sizeof(short), "bip_flags");
   struct work_struct bip_work ;
   struct bio_vec *bip_vec ;
   struct bio_vec bip_inline_vecs[0U] ;
};
struct bio_list {
   struct bio *head ;
   struct bio *tail ;
};
struct bio_set {
   struct kmem_cache *bio_slab ;
   unsigned int front_pad ;
    klee_make_symbolic(&front_pad, sizeof(int), "front_pad");
   mempool_t *bio_pool ;
   mempool_t *bvec_pool ;
   mempool_t *bio_integrity_pool ;
   mempool_t *bvec_integrity_pool ;
   spinlock_t rescue_lock ;
   struct bio_list rescue_list ;
   struct work_struct rescue_work ;
   struct workqueue_struct *rescue_workqueue ;
};
struct bsg_class_device {
   struct device *class_dev ;
   struct device *parent ;
   int minor ;
    klee_make_symbolic(&minor, sizeof(int), "minor");
   struct request_queue *queue ;
   struct kref ref ;
   void (*release)(struct device * ) ;
};
struct scatterlist {
   unsigned long sg_magic ;
    klee_make_symbolic(&sg_magic, sizeof(long), "sg_magic");
   unsigned long page_link ;
    klee_make_symbolic(&page_link, sizeof(long), "page_link");
   unsigned int offset ;
    klee_make_symbolic(&offset, sizeof(int), "offset");
   unsigned int length ;
    klee_make_symbolic(&length, sizeof(int), "length");
   dma_addr_t dma_address ;
   unsigned int dma_length ;
    klee_make_symbolic(&dma_length, sizeof(int), "dma_length");
};
struct sg_table {
   struct scatterlist *sgl ;
   unsigned int nents ;
    klee_make_symbolic(&nents, sizeof(int), "nents");
   unsigned int orig_nents ;
    klee_make_symbolic(&orig_nents, sizeof(int), "orig_nents");
};
struct elevator_queue;
struct request;
struct bsg_job;
struct blkcg_gq;
struct blk_flush_queue;
typedef void rq_end_io_fn(struct request * , int  );
struct request_list {
   struct request_queue *q ;
   struct blkcg_gq *blkg ;
   int count[2U] ;
   int starved[2U] ;
   mempool_t *rq_pool ;
   wait_queue_head_t wait[2U] ;
   unsigned int flags ;
};
union __anonunion____missing_field_name_241 {
   struct call_single_data csd ;
   unsigned long fifo_time ;
    klee_make_symbolic(&fifo_time, sizeof(long), "fifo_time");
};
struct blk_mq_ctx;
union __anonunion____missing_field_name_242 {
   struct hlist_node hash ;
   struct list_head ipi_list ;
};
union __anonunion____missing_field_name_243 {
   struct rb_node rb_node ;
   void *completion_data ;
};
struct __anonstruct_elv_245 {
   struct io_cq *icq ;
   void *priv[2U] ;
};
struct __anonstruct_flush_246 {
   unsigned int seq ;
    klee_make_symbolic(&seq, sizeof(int), "seq");
   struct list_head list ;
   rq_end_io_fn *saved_end_io ;
};
union __anonunion____missing_field_name_244 {
   struct __anonstruct_elv_245 elv ;
   struct __anonstruct_flush_246 flush ;
};
struct request {
   struct list_head queuelist ;
   union __anonunion____missing_field_name_241 __annonCompField78 ;
   struct request_queue *q ;
   struct blk_mq_ctx *mq_ctx ;
   u64 cmd_flags ;
   unsigned int cmd_type ;
    klee_make_symbolic(&cmd_type, sizeof(int), "cmd_type");
   unsigned long atomic_flags ;
   int cpu ;
   unsigned int __data_len ;
    klee_make_symbolic(&__data_len, sizeof(int), "__data_len");
   sector_t __sector ;
   struct bio *bio ;
   struct bio *biotail ;
   union __anonunion____missing_field_name_242 __annonCompField79 ;
   union __anonunion____missing_field_name_243 __annonCompField80 ;
   union __anonunion____missing_field_name_244 __annonCompField81 ;
   struct gendisk *rq_disk ;
   struct hd_struct *part ;
   unsigned long start_time ;
    klee_make_symbolic(&start_time, sizeof(long), "start_time");
   struct request_list *rl ;
   unsigned long long start_time_ns ;
    klee_make_symbolic(&start_time_ns, sizeof(long), "start_time_ns");
   unsigned long long io_start_time_ns ;
    klee_make_symbolic(&io_start_time_ns, sizeof(long), "io_start_time_ns");
   unsigned short nr_phys_segments ;
    klee_make_symbolic(&nr_phys_segments, sizeof(short), "nr_phys_segments");
   unsigned short nr_integrity_segments ;
    klee_make_symbolic(&nr_integrity_segments, sizeof(short), "nr_integrity_segments");
   unsigned short ioprio ;
   void *special ;
   int tag ;
    klee_make_symbolic(&tag, sizeof(int), "tag");
   int errors ;
    klee_make_symbolic(&errors, sizeof(int), "errors");
   unsigned char __cmd[16U] ;
   unsigned char *cmd ;
   unsigned short cmd_len ;
    klee_make_symbolic(&cmd_len, sizeof(short), "cmd_len");
   unsigned int extra_len ;
    klee_make_symbolic(&extra_len, sizeof(int), "extra_len");
   unsigned int sense_len ;
    klee_make_symbolic(&sense_len, sizeof(int), "sense_len");
   unsigned int resid_len ;
    klee_make_symbolic(&resid_len, sizeof(int), "resid_len");
   void *sense ;
   unsigned long deadline ;
    klee_make_symbolic(&deadline, sizeof(long), "deadline");
   struct list_head timeout_list ;
   unsigned int timeout ;
   int retries ;
    klee_make_symbolic(&retries, sizeof(int), "retries");
   rq_end_io_fn *end_io ;
   void *end_io_data ;
   struct request *next_rq ;
};
struct elevator_type;
typedef int elevator_merge_fn(struct request_queue * , struct request ** , struct bio * );
typedef void elevator_merge_req_fn(struct request_queue * , struct request * , struct request * );
typedef void elevator_merged_fn(struct request_queue * , struct request * , int  );
typedef int elevator_allow_merge_fn(struct request_queue * , struct request * , struct bio * );
typedef void elevator_bio_merged_fn(struct request_queue * , struct request * , struct bio * );
typedef int elevator_dispatch_fn(struct request_queue * , int  );
typedef void elevator_add_req_fn(struct request_queue * , struct request * );
typedef struct request *elevator_request_list_fn(struct request_queue * , struct request * );
typedef void elevator_completed_req_fn(struct request_queue * , struct request * );
typedef int elevator_may_queue_fn(struct request_queue * , int  );
typedef void elevator_init_icq_fn(struct io_cq * );
typedef void elevator_exit_icq_fn(struct io_cq * );
typedef int elevator_set_req_fn(struct request_queue * , struct request * , struct bio * ,
                                gfp_t  );
typedef void elevator_put_req_fn(struct request * );
typedef void elevator_activate_req_fn(struct request_queue * , struct request * );
typedef void elevator_deactivate_req_fn(struct request_queue * , struct request * );
typedef int elevator_init_fn(struct request_queue * , struct elevator_type * );
typedef void elevator_exit_fn(struct elevator_queue * );
typedef void elevator_registered_fn(struct request_queue * );
struct elevator_ops {
   elevator_merge_fn *elevator_merge_fn ;
   elevator_merged_fn *elevator_merged_fn ;
   elevator_merge_req_fn *elevator_merge_req_fn ;
   elevator_allow_merge_fn *elevator_allow_merge_fn ;
   elevator_bio_merged_fn *elevator_bio_merged_fn ;
   elevator_dispatch_fn *elevator_dispatch_fn ;
   elevator_add_req_fn *elevator_add_req_fn ;
   elevator_activate_req_fn *elevator_activate_req_fn ;
   elevator_deactivate_req_fn *elevator_deactivate_req_fn ;
   elevator_completed_req_fn *elevator_completed_req_fn ;
   elevator_request_list_fn *elevator_former_req_fn ;
   elevator_request_list_fn *elevator_latter_req_fn ;
   elevator_init_icq_fn *elevator_init_icq_fn ;
   elevator_exit_icq_fn *elevator_exit_icq_fn ;
   elevator_set_req_fn *elevator_set_req_fn ;
   elevator_put_req_fn *elevator_put_req_fn ;
   elevator_may_queue_fn *elevator_may_queue_fn ;
   elevator_init_fn *elevator_init_fn ;
   elevator_exit_fn *elevator_exit_fn ;
   elevator_registered_fn *elevator_registered_fn ;
};
struct elv_fs_entry {
   struct attribute attr ;
   ssize_t (*show)(struct elevator_queue * , char * ) ;
   ssize_t (*store)(struct elevator_queue * , char const   * , size_t  ) ;
};
struct elevator_type {
   struct kmem_cache *icq_cache ;
   struct elevator_ops ops ;
   size_t icq_size ;
   size_t icq_align ;
   struct elv_fs_entry *elevator_attrs ;
   char elevator_name[16U] ;
   struct module *elevator_owner ;
   char icq_cache_name[21U] ;
   struct list_head list ;
};
struct elevator_queue {
   struct elevator_type *type ;
   void *elevator_data ;
   struct kobject kobj ;
   struct mutex sysfs_lock ;
   unsigned char registered : 1 ;
   struct hlist_head hash[64U] ;
};
typedef void request_fn_proc(struct request_queue * );
typedef void make_request_fn(struct request_queue * , struct bio * );
typedef int prep_rq_fn(struct request_queue * , struct request * );
typedef void unprep_rq_fn(struct request_queue * , struct request * );
struct bvec_merge_data {
   struct block_device *bi_bdev ;
   sector_t bi_sector ;
   unsigned int bi_size ;
   unsigned long bi_rw ;
};
typedef int merge_bvec_fn(struct request_queue * , struct bvec_merge_data * , struct bio_vec * );
typedef void softirq_done_fn(struct request * );
typedef int dma_drain_needed_fn(struct request * );
typedef int lld_busy_fn(struct request_queue * );
typedef int bsg_job_fn(struct bsg_job * );
enum blk_eh_timer_return {
    BLK_EH_NOT_HANDLED = 0,
    BLK_EH_HANDLED = 1,
    BLK_EH_RESET_TIMER = 2
} ;
typedef enum blk_eh_timer_return rq_timed_out_fn(struct request * );
struct blk_queue_tag {
   struct request **tag_index ;
   unsigned long *tag_map ;
   int busy ;
    klee_make_symbolic(&busy, sizeof(int), "busy");
   int max_depth ;
    klee_make_symbolic(&max_depth, sizeof(int), "max_depth");
   int real_max_depth ;
    klee_make_symbolic(&real_max_depth, sizeof(int), "real_max_depth");
   atomic_t refcnt ;
   int alloc_policy ;
    klee_make_symbolic(&alloc_policy, sizeof(int), "alloc_policy");
   int next_tag ;
    klee_make_symbolic(&next_tag, sizeof(int), "next_tag");
};
struct queue_limits {
   unsigned long bounce_pfn ;
    klee_make_symbolic(&bounce_pfn, sizeof(long), "bounce_pfn");
   unsigned long seg_boundary_mask ;
    klee_make_symbolic(&seg_boundary_mask, sizeof(long), "seg_boundary_mask");
   unsigned int max_hw_sectors ;
    klee_make_symbolic(&max_hw_sectors, sizeof(int), "max_hw_sectors");
   unsigned int chunk_sectors ;
    klee_make_symbolic(&chunk_sectors, sizeof(int), "chunk_sectors");
   unsigned int max_sectors ;
    klee_make_symbolic(&max_sectors, sizeof(int), "max_sectors");
   unsigned int max_segment_size ;
   unsigned int physical_block_size ;
    klee_make_symbolic(&physical_block_size, sizeof(int), "physical_block_size");
   unsigned int alignment_offset ;
    klee_make_symbolic(&alignment_offset, sizeof(int), "alignment_offset");
   unsigned int io_min ;
    klee_make_symbolic(&io_min, sizeof(int), "io_min");
   unsigned int io_opt ;
    klee_make_symbolic(&io_opt, sizeof(int), "io_opt");
   unsigned int max_discard_sectors ;
    klee_make_symbolic(&max_discard_sectors, sizeof(int), "max_discard_sectors");
   unsigned int max_write_same_sectors ;
    klee_make_symbolic(&max_write_same_sectors, sizeof(int), "max_write_same_sectors");
   unsigned int discard_granularity ;
    klee_make_symbolic(&discard_granularity, sizeof(int), "discard_granularity");
   unsigned int discard_alignment ;
   unsigned short logical_block_size ;
    klee_make_symbolic(&logical_block_size, sizeof(short), "logical_block_size");
   unsigned short max_segments ;
    klee_make_symbolic(&max_segments, sizeof(short), "max_segments");
   unsigned short max_integrity_segments ;
    klee_make_symbolic(&max_integrity_segments, sizeof(short), "max_integrity_segments");
   unsigned char misaligned ;
    klee_make_symbolic(&misaligned, sizeof(char), "misaligned");
   unsigned char discard_misaligned ;
    klee_make_symbolic(&discard_misaligned, sizeof(char), "discard_misaligned");
   unsigned char cluster ;
    klee_make_symbolic(&cluster, sizeof(char), "cluster");
   unsigned char discard_zeroes_data ;
    klee_make_symbolic(&discard_zeroes_data, sizeof(char), "discard_zeroes_data");
   unsigned char raid_partial_stripes_expensive ;
    klee_make_symbolic(&raid_partial_stripes_expensive, sizeof(char), "raid_partial_stripes_expensive");
};
struct blk_mq_ops;
struct blk_mq_hw_ctx;
struct throtl_data;
struct blk_mq_tag_set;
struct request_queue {
   struct list_head queue_head ;
   struct request *last_merge ;
   struct elevator_queue *elevator ;
   int nr_rqs[2U] ;
   int nr_rqs_elvpriv ;
    klee_make_symbolic(&nr_rqs_elvpriv, sizeof(int), "nr_rqs_elvpriv");
   struct request_list root_rl ;
   request_fn_proc *request_fn ;
   make_request_fn *make_request_fn ;
   prep_rq_fn *prep_rq_fn ;
   unprep_rq_fn *unprep_rq_fn ;
   merge_bvec_fn *merge_bvec_fn ;
   softirq_done_fn *softirq_done_fn ;
   rq_timed_out_fn *rq_timed_out_fn ;
   dma_drain_needed_fn *dma_drain_needed ;
   lld_busy_fn *lld_busy_fn ;
   struct blk_mq_ops *mq_ops ;
   unsigned int *mq_map ;
   struct blk_mq_ctx *queue_ctx ;
   unsigned int nr_queues ;
    klee_make_symbolic(&nr_queues, sizeof(int), "nr_queues");
   struct blk_mq_hw_ctx **queue_hw_ctx ;
   unsigned int nr_hw_queues ;
    klee_make_symbolic(&nr_hw_queues, sizeof(int), "nr_hw_queues");
   sector_t end_sector ;
   struct request *boundary_rq ;
   struct delayed_work delay_work ;
   struct backing_dev_info backing_dev_info ;
   void *queuedata ;
   unsigned long queue_flags ;
    klee_make_symbolic(&queue_flags, sizeof(long), "queue_flags");
   int id ;
   gfp_t bounce_gfp ;
   spinlock_t __queue_lock ;
   spinlock_t *queue_lock ;
   struct kobject kobj ;
   struct kobject mq_kobj ;
   struct device *dev ;
   int rpm_status ;
    klee_make_symbolic(&rpm_status, sizeof(int), "rpm_status");
   unsigned int nr_pending ;
    klee_make_symbolic(&nr_pending, sizeof(int), "nr_pending");
   unsigned long nr_requests ;
    klee_make_symbolic(&nr_requests, sizeof(long), "nr_requests");
   unsigned int nr_congestion_on ;
    klee_make_symbolic(&nr_congestion_on, sizeof(int), "nr_congestion_on");
   unsigned int nr_congestion_off ;
    klee_make_symbolic(&nr_congestion_off, sizeof(int), "nr_congestion_off");
   unsigned int nr_batching ;
    klee_make_symbolic(&nr_batching, sizeof(int), "nr_batching");
   unsigned int dma_drain_size ;
    klee_make_symbolic(&dma_drain_size, sizeof(int), "dma_drain_size");
   void *dma_drain_buffer ;
   unsigned int dma_pad_mask ;
    klee_make_symbolic(&dma_pad_mask, sizeof(int), "dma_pad_mask");
   unsigned int dma_alignment ;
    klee_make_symbolic(&dma_alignment, sizeof(int), "dma_alignment");
   struct blk_queue_tag *queue_tags ;
   struct list_head tag_busy_list ;
   unsigned int nr_sorted ;
    klee_make_symbolic(&nr_sorted, sizeof(int), "nr_sorted");
   unsigned int in_flight[2U] ;
   unsigned int request_fn_active ;
    klee_make_symbolic(&request_fn_active, sizeof(int), "request_fn_active");
   unsigned int rq_timeout ;
    klee_make_symbolic(&rq_timeout, sizeof(int), "rq_timeout");
   struct timer_list timeout ;
   struct list_head timeout_list ;
   struct list_head icq_list ;
   unsigned long blkcg_pols[1U] ;
   struct blkcg_gq *root_blkg ;
   struct list_head blkg_list ;
   struct queue_limits limits ;
   unsigned int sg_timeout ;
    klee_make_symbolic(&sg_timeout, sizeof(int), "sg_timeout");
   unsigned int sg_reserved_size ;
    klee_make_symbolic(&sg_reserved_size, sizeof(int), "sg_reserved_size");
   int node ;
    klee_make_symbolic(&node, sizeof(int), "node");
   unsigned int flush_flags ;
    klee_make_symbolic(&flush_flags, sizeof(int), "flush_flags");
   unsigned char flush_not_queueable : 1 ;
   struct blk_flush_queue *fq ;
   struct list_head requeue_list ;
   spinlock_t requeue_lock ;
   struct work_struct requeue_work ;
   struct mutex sysfs_lock ;
   int bypass_depth ;
    klee_make_symbolic(&bypass_depth, sizeof(int), "bypass_depth");
   atomic_t mq_freeze_depth ;
   bsg_job_fn *bsg_job_fn ;
   int bsg_job_size ;
    klee_make_symbolic(&bsg_job_size, sizeof(int), "bsg_job_size");
   struct bsg_class_device bsg_dev ;
   struct throtl_data *td ;
   struct callback_head callback_head ;
   wait_queue_head_t mq_freeze_wq ;
   struct percpu_ref mq_usage_counter ;
   struct list_head all_q_node ;
   struct blk_mq_tag_set *tag_set ;
   struct list_head tag_set_list ;
};
struct blk_plug {
   struct list_head list ;
   struct list_head mq_list ;
   struct list_head cb_list ;
};
struct blk_integrity_iter {
   void *prot_buf ;
   void *data_buf ;
   sector_t seed ;
   unsigned int data_size ;
    klee_make_symbolic(&data_size, sizeof(int), "data_size");
   unsigned short interval ;
    klee_make_symbolic(&interval, sizeof(short), "interval");
   char const   *disk_name ;
};
typedef int integrity_processing_fn(struct blk_integrity_iter * );
struct blk_integrity {
   integrity_processing_fn *generate_fn ;
   integrity_processing_fn *verify_fn ;
   unsigned short flags ;
   unsigned short tuple_size ;
    klee_make_symbolic(&tuple_size, sizeof(short), "tuple_size");
   unsigned short interval ;
   unsigned short tag_size ;
    klee_make_symbolic(&tag_size, sizeof(short), "tag_size");
   char const   *name ;
   struct kobject kobj ;
};
struct block_device_operations {
   int (*open)(struct block_device * , fmode_t  ) ;
   void (*release)(struct gendisk * , fmode_t  ) ;
   int (*rw_page)(struct block_device * , sector_t  , struct page * , int  ) ;
   int (*ioctl)(struct block_device * , fmode_t  , unsigned int  , unsigned long  ) ;
   int (*compat_ioctl)(struct block_device * , fmode_t  , unsigned int  , unsigned long  ) ;
   long (*direct_access)(struct block_device * , sector_t  , void ** , unsigned long * ,
                         long  ) ;
   unsigned int (*check_events)(struct gendisk * , unsigned int  ) ;
   int (*media_changed)(struct gendisk * ) ;
   void (*unlock_native_capacity)(struct gendisk * ) ;
   int (*revalidate_disk)(struct gendisk * ) ;
   int (*getgeo)(struct block_device * , struct hd_geometry * ) ;
   void (*swap_slot_free_notify)(struct block_device * , unsigned long  ) ;
   struct module *owner ;
};
typedef __u64 Elf64_Addr;
typedef __u16 Elf64_Half;
typedef __u32 Elf64_Word;
typedef __u64 Elf64_Xword;
struct elf64_sym {
   Elf64_Word st_name ;
   unsigned char st_info ;
    klee_make_symbolic(&st_info, sizeof(char), "st_info");
   unsigned char st_other ;
    klee_make_symbolic(&st_other, sizeof(char), "st_other");
   Elf64_Half st_shndx ;
   Elf64_Addr st_value ;
   Elf64_Xword st_size ;
};
typedef struct elf64_sym Elf64_Sym;
struct kernel_param;
struct kernel_param_ops {
   unsigned int flags ;
   int (*set)(char const   * , struct kernel_param  const  * ) ;
   int (*get)(char * , struct kernel_param  const  * ) ;
   void (*free)(void * ) ;
};
struct kparam_string;
struct kparam_array;
union __anonunion____missing_field_name_252 {
   void *arg ;
   struct kparam_string  const  *str ;
   struct kparam_array  const  *arr ;
};
struct kernel_param {
   char const   *name ;
   struct module *mod ;
   struct kernel_param_ops  const  *ops ;
   u16 const   perm ;
   s8 level ;
   u8 flags ;
   union __anonunion____missing_field_name_252 __annonCompField82 ;
};
struct kparam_string {
   unsigned int maxlen ;
    klee_make_symbolic(&maxlen, sizeof(int), "maxlen");
   char *string ;
};
struct kparam_array {
   unsigned int max ;
   unsigned int elemsize ;
    klee_make_symbolic(&elemsize, sizeof(int), "elemsize");
   unsigned int *num ;
   struct kernel_param_ops  const  *ops ;
   void *elem ;
};
struct latch_tree_node {
   struct rb_node node[2U] ;
};
struct mod_arch_specific {

};
struct module_param_attrs;
struct module_kobject {
   struct kobject kobj ;
   struct module *mod ;
   struct kobject *drivers_dir ;
   struct module_param_attrs *mp ;
   struct completion *kobj_completion ;
};
struct module_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct module_attribute * , struct module_kobject * , char * ) ;
   ssize_t (*store)(struct module_attribute * , struct module_kobject * , char const   * ,
                    size_t  ) ;
   void (*setup)(struct module * , char const   * ) ;
   int (*test)(struct module * ) ;
   void (*free)(struct module * ) ;
};
enum module_state {
    MODULE_STATE_LIVE = 0,
    MODULE_STATE_COMING = 1,
    MODULE_STATE_GOING = 2,
    MODULE_STATE_UNFORMED = 3
} ;
struct mod_tree_node {
   struct module *mod ;
   struct latch_tree_node node ;
};
struct module_sect_attrs;
struct module_notes_attrs;
struct tracepoint;
struct trace_event_call;
struct trace_enum_map;
struct module {
   enum module_state state ;
   struct list_head list ;
   char name[56U] ;
   struct module_kobject mkobj ;
   struct module_attribute *modinfo_attrs ;
   char const   *version ;
   char const   *srcversion ;
   struct kobject *holders_dir ;
   struct kernel_symbol  const  *syms ;
   unsigned long const   *crcs ;
   unsigned int num_syms ;
    klee_make_symbolic(&num_syms, sizeof(int), "num_syms");
   struct mutex param_lock ;
   struct kernel_param *kp ;
   unsigned int num_kp ;
    klee_make_symbolic(&num_kp, sizeof(int), "num_kp");
   unsigned int num_gpl_syms ;
    klee_make_symbolic(&num_gpl_syms, sizeof(int), "num_gpl_syms");
   struct kernel_symbol  const  *gpl_syms ;
   unsigned long const   *gpl_crcs ;
   struct kernel_symbol  const  *unused_syms ;
   unsigned long const   *unused_crcs ;
   unsigned int num_unused_syms ;
    klee_make_symbolic(&num_unused_syms, sizeof(int), "num_unused_syms");
   unsigned int num_unused_gpl_syms ;
    klee_make_symbolic(&num_unused_gpl_syms, sizeof(int), "num_unused_gpl_syms");
   struct kernel_symbol  const  *unused_gpl_syms ;
   unsigned long const   *unused_gpl_crcs ;
   bool sig_ok ;
   bool async_probe_requested ;
   struct kernel_symbol  const  *gpl_future_syms ;
   unsigned long const   *gpl_future_crcs ;
   unsigned int num_gpl_future_syms ;
    klee_make_symbolic(&num_gpl_future_syms, sizeof(int), "num_gpl_future_syms");
   unsigned int num_exentries ;
    klee_make_symbolic(&num_exentries, sizeof(int), "num_exentries");
   struct exception_table_entry *extable ;
   int (*init)(void) ;
   void *module_init ;
   void *module_core ;
   unsigned int init_size ;
    klee_make_symbolic(&init_size, sizeof(int), "init_size");
   unsigned int core_size ;
    klee_make_symbolic(&core_size, sizeof(int), "core_size");
   unsigned int init_text_size ;
    klee_make_symbolic(&init_text_size, sizeof(int), "init_text_size");
   unsigned int core_text_size ;
    klee_make_symbolic(&core_text_size, sizeof(int), "core_text_size");
   struct mod_tree_node mtn_core ;
   struct mod_tree_node mtn_init ;
   unsigned int init_ro_size ;
    klee_make_symbolic(&init_ro_size, sizeof(int), "init_ro_size");
   unsigned int core_ro_size ;
    klee_make_symbolic(&core_ro_size, sizeof(int), "core_ro_size");
   struct mod_arch_specific arch ;
   unsigned int taints ;
    klee_make_symbolic(&taints, sizeof(int), "taints");
   unsigned int num_bugs ;
    klee_make_symbolic(&num_bugs, sizeof(int), "num_bugs");
   struct list_head bug_list ;
   struct bug_entry *bug_table ;
   Elf64_Sym *symtab ;
   Elf64_Sym *core_symtab ;
   unsigned int num_symtab ;
    klee_make_symbolic(&num_symtab, sizeof(int), "num_symtab");
   unsigned int core_num_syms ;
    klee_make_symbolic(&core_num_syms, sizeof(int), "core_num_syms");
   char *strtab ;
   char *core_strtab ;
   struct module_sect_attrs *sect_attrs ;
   struct module_notes_attrs *notes_attrs ;
   char *args ;
   void *percpu ;
   unsigned int percpu_size ;
    klee_make_symbolic(&percpu_size, sizeof(int), "percpu_size");
   unsigned int num_tracepoints ;
    klee_make_symbolic(&num_tracepoints, sizeof(int), "num_tracepoints");
   struct tracepoint * const  *tracepoints_ptrs ;
   unsigned int num_trace_bprintk_fmt ;
    klee_make_symbolic(&num_trace_bprintk_fmt, sizeof(int), "num_trace_bprintk_fmt");
   char const   **trace_bprintk_fmt_start ;
   struct trace_event_call **trace_events ;
   unsigned int num_trace_events ;
    klee_make_symbolic(&num_trace_events, sizeof(int), "num_trace_events");
   struct trace_enum_map **trace_enums ;
   unsigned int num_trace_enums ;
    klee_make_symbolic(&num_trace_enums, sizeof(int), "num_trace_enums");
   bool klp_alive ;
   struct list_head source_list ;
   struct list_head target_list ;
   void (*exit)(void) ;
   atomic_t refcnt ;
   ctor_fn_t (**ctors)(void) ;
   unsigned int num_ctors ;
    klee_make_symbolic(&num_ctors, sizeof(int), "num_ctors");
};
typedef unsigned long kernel_ulong_t;
    klee_make_symbolic(&kernel_ulong_t, sizeof(long), "kernel_ulong_t");
struct pci_device_id {
   __u32 vendor ;
   __u32 device ;
   __u32 subvendor ;
   __u32 subdevice ;
   __u32 class ;
   __u32 class_mask ;
   kernel_ulong_t driver_data ;
};
struct acpi_device_id {
   __u8 id[9U] ;
   kernel_ulong_t driver_data ;
};
struct of_device_id {
   char name[32U] ;
   char type[32U] ;
   char compatible[128U] ;
   void const   *data ;
};
struct hotplug_slot;
struct pci_slot {
   struct pci_bus *bus ;
   struct list_head list ;
   struct hotplug_slot *hotplug ;
   unsigned char number ;
    klee_make_symbolic(&number, sizeof(char), "number");
   struct kobject kobj ;
};
typedef int pci_power_t;
    klee_make_symbolic(&pci_power_t, sizeof(int), "pci_power_t");
typedef unsigned int pci_channel_state_t;
    klee_make_symbolic(&pci_channel_state_t, sizeof(int), "pci_channel_state_t");
enum pci_channel_state {
    pci_channel_io_normal = 1,
    pci_channel_io_frozen = 2,
    pci_channel_io_perm_failure = 3
} ;
typedef unsigned short pci_dev_flags_t;
    klee_make_symbolic(&pci_dev_flags_t, sizeof(short), "pci_dev_flags_t");
typedef unsigned short pci_bus_flags_t;
    klee_make_symbolic(&pci_bus_flags_t, sizeof(short), "pci_bus_flags_t");
struct pcie_link_state;
struct pci_vpd;
struct pci_sriov;
struct pci_ats;
struct pci_driver;
union __anonunion____missing_field_name_262 {
   struct pci_sriov *sriov ;
   struct pci_dev *physfn ;
};
struct pci_dev {
   struct list_head bus_list ;
   struct pci_bus *bus ;
   struct pci_bus *subordinate ;
   void *sysdata ;
   struct proc_dir_entry *procent ;
   struct pci_slot *slot ;
   unsigned int devfn ;
    klee_make_symbolic(&devfn, sizeof(int), "devfn");
   unsigned short vendor ;
    klee_make_symbolic(&vendor, sizeof(short), "vendor");
   unsigned short device ;
    klee_make_symbolic(&device, sizeof(short), "device");
   unsigned short subsystem_vendor ;
    klee_make_symbolic(&subsystem_vendor, sizeof(short), "subsystem_vendor");
   unsigned short subsystem_device ;
    klee_make_symbolic(&subsystem_device, sizeof(short), "subsystem_device");
   unsigned int class ;
    klee_make_symbolic(&class, sizeof(int), "class");
   u8 revision ;
   u8 hdr_type ;
   u8 pcie_cap ;
   u8 msi_cap ;
   u8 msix_cap ;
   unsigned char pcie_mpss : 3 ;
   u8 rom_base_reg ;
   u8 pin ;
   u16 pcie_flags_reg ;
   u8 dma_alias_devfn ;
   struct pci_driver *driver ;
   u64 dma_mask ;
   struct device_dma_parameters dma_parms ;
   pci_power_t current_state ;
   u8 pm_cap ;
   unsigned char pme_support : 5 ;
   unsigned char pme_interrupt : 1 ;
   unsigned char pme_poll : 1 ;
   unsigned char d1_support : 1 ;
   unsigned char d2_support : 1 ;
   unsigned char no_d1d2 : 1 ;
   unsigned char no_d3cold : 1 ;
   unsigned char d3cold_allowed : 1 ;
   unsigned char mmio_always_on : 1 ;
   unsigned char wakeup_prepared : 1 ;
   unsigned char runtime_d3cold : 1 ;
   unsigned char ignore_hotplug : 1 ;
   unsigned int d3_delay ;
    klee_make_symbolic(&d3_delay, sizeof(int), "d3_delay");
   unsigned int d3cold_delay ;
    klee_make_symbolic(&d3cold_delay, sizeof(int), "d3cold_delay");
   struct pcie_link_state *link_state ;
   pci_channel_state_t error_state ;
   struct device dev ;
   int cfg_size ;
    klee_make_symbolic(&cfg_size, sizeof(int), "cfg_size");
   unsigned int irq ;
    klee_make_symbolic(&irq, sizeof(int), "irq");
   struct resource resource[17U] ;
   bool match_driver ;
   unsigned char transparent : 1 ;
   unsigned char multifunction : 1 ;
   unsigned char is_added : 1 ;
   unsigned char is_busmaster : 1 ;
   unsigned char no_msi : 1 ;
   unsigned char no_64bit_msi : 1 ;
   unsigned char block_cfg_access : 1 ;
   unsigned char broken_parity_status : 1 ;
   unsigned char irq_reroute_variant : 2 ;
   unsigned char msi_enabled : 1 ;
   unsigned char msix_enabled : 1 ;
   unsigned char ari_enabled : 1 ;
   unsigned char is_managed : 1 ;
   unsigned char needs_freset : 1 ;
   unsigned char state_saved : 1 ;
   unsigned char is_physfn : 1 ;
   unsigned char is_virtfn : 1 ;
   unsigned char reset_fn : 1 ;
   unsigned char is_hotplug_bridge : 1 ;
   unsigned char __aer_firmware_first_valid : 1 ;
   unsigned char __aer_firmware_first : 1 ;
   unsigned char broken_intx_masking : 1 ;
   unsigned char io_window_1k : 1 ;
   unsigned char irq_managed : 1 ;
   unsigned char has_secondary_link : 1 ;
   pci_dev_flags_t dev_flags ;
   atomic_t enable_cnt ;
   u32 saved_config_space[16U] ;
   struct hlist_head saved_cap_space ;
   struct bin_attribute *rom_attr ;
   int rom_attr_enabled ;
    klee_make_symbolic(&rom_attr_enabled, sizeof(int), "rom_attr_enabled");
   struct bin_attribute *res_attr[17U] ;
   struct bin_attribute *res_attr_wc[17U] ;
   struct list_head msi_list ;
   struct attribute_group  const  **msi_irq_groups ;
   struct pci_vpd *vpd ;
   union __anonunion____missing_field_name_262 __annonCompField83 ;
   struct pci_ats *ats ;
   phys_addr_t rom ;
   size_t romlen ;
   char *driver_override ;
};
struct pci_ops;
struct msi_controller;
struct pci_bus {
   struct list_head node ;
   struct pci_bus *parent ;
   struct list_head children ;
   struct list_head devices ;
   struct pci_dev *self ;
   struct list_head slots ;
   struct resource *resource[4U] ;
   struct list_head resources ;
   struct resource busn_res ;
   struct pci_ops *ops ;
   struct msi_controller *msi ;
   void *sysdata ;
   struct proc_dir_entry *procdir ;
   unsigned char number ;
   unsigned char primary ;
    klee_make_symbolic(&primary, sizeof(char), "primary");
   unsigned char max_bus_speed ;
    klee_make_symbolic(&max_bus_speed, sizeof(char), "max_bus_speed");
   unsigned char cur_bus_speed ;
    klee_make_symbolic(&cur_bus_speed, sizeof(char), "cur_bus_speed");
   char name[48U] ;
   unsigned short bridge_ctl ;
    klee_make_symbolic(&bridge_ctl, sizeof(short), "bridge_ctl");
   pci_bus_flags_t bus_flags ;
   struct device *bridge ;
   struct device dev ;
   struct bin_attribute *legacy_io ;
   struct bin_attribute *legacy_mem ;
   unsigned char is_added : 1 ;
};
struct pci_ops {
   void *(*map_bus)(struct pci_bus * , unsigned int  , int  ) ;
   int (*read)(struct pci_bus * , unsigned int  , int  , int  , u32 * ) ;
   int (*write)(struct pci_bus * , unsigned int  , int  , int  , u32  ) ;
};
struct pci_dynids {
   spinlock_t lock ;
   struct list_head list ;
};
typedef unsigned int pci_ers_result_t;
    klee_make_symbolic(&pci_ers_result_t, sizeof(int), "pci_ers_result_t");
struct pci_error_handlers {
   pci_ers_result_t (*error_detected)(struct pci_dev * , enum pci_channel_state  ) ;
   pci_ers_result_t (*mmio_enabled)(struct pci_dev * ) ;
   pci_ers_result_t (*link_reset)(struct pci_dev * ) ;
   pci_ers_result_t (*slot_reset)(struct pci_dev * ) ;
   void (*reset_notify)(struct pci_dev * , bool  ) ;
   void (*resume)(struct pci_dev * ) ;
};
struct pci_driver {
   struct list_head node ;
   char const   *name ;
   struct pci_device_id  const  *id_table ;
   int (*probe)(struct pci_dev * , struct pci_device_id  const  * ) ;
   void (*remove)(struct pci_dev * ) ;
   int (*suspend)(struct pci_dev * , pm_message_t  ) ;
   int (*suspend_late)(struct pci_dev * , pm_message_t  ) ;
   int (*resume_early)(struct pci_dev * ) ;
   int (*resume)(struct pci_dev * ) ;
   void (*shutdown)(struct pci_dev * ) ;
   int (*sriov_configure)(struct pci_dev * , int  ) ;
   struct pci_error_handlers  const  *err_handler ;
   struct device_driver driver ;
   struct pci_dynids dynids ;
};
struct dma_attrs {
   unsigned long flags[1U] ;
};
enum dma_data_direction {
    DMA_BIDIRECTIONAL = 0,
    DMA_TO_DEVICE = 1,
    DMA_FROM_DEVICE = 2,
    DMA_NONE = 3
} ;
struct dma_map_ops {
   void *(*alloc)(struct device * , size_t  , dma_addr_t * , gfp_t  , struct dma_attrs * ) ;
   void (*free)(struct device * , size_t  , void * , dma_addr_t  , struct dma_attrs * ) ;
   int (*mmap)(struct device * , struct vm_area_struct * , void * , dma_addr_t  ,
               size_t  , struct dma_attrs * ) ;
   int (*get_sgtable)(struct device * , struct sg_table * , void * , dma_addr_t  ,
                      size_t  , struct dma_attrs * ) ;
   dma_addr_t (*map_page)(struct device * , struct page * , unsigned long  , size_t  ,
                          enum dma_data_direction  , struct dma_attrs * ) ;
   void (*unmap_page)(struct device * , dma_addr_t  , size_t  , enum dma_data_direction  ,
                      struct dma_attrs * ) ;
   int (*map_sg)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ,
                 struct dma_attrs * ) ;
   void (*unmap_sg)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ,
                    struct dma_attrs * ) ;
   void (*sync_single_for_cpu)(struct device * , dma_addr_t  , size_t  , enum dma_data_direction  ) ;
   void (*sync_single_for_device)(struct device * , dma_addr_t  , size_t  , enum dma_data_direction  ) ;
   void (*sync_sg_for_cpu)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ) ;
   void (*sync_sg_for_device)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ) ;
   int (*mapping_error)(struct device * , dma_addr_t  ) ;
   int (*dma_supported)(struct device * , u64  ) ;
   int (*set_dma_mask)(struct device * , u64  ) ;
   int is_phys ;
    klee_make_symbolic(&is_phys, sizeof(int), "is_phys");
};
struct scsi_sense_hdr {
   u8 response_code ;
   u8 sense_key ;
   u8 asc ;
   u8 ascq ;
   u8 byte4 ;
   u8 byte5 ;
   u8 byte6 ;
   u8 additional_length ;
};
enum scsi_device_state {
    SDEV_CREATED = 1,
    SDEV_RUNNING = 2,
    SDEV_CANCEL = 3,
    SDEV_DEL = 4,
    SDEV_QUIESCE = 5,
    SDEV_OFFLINE = 6,
    SDEV_TRANSPORT_OFFLINE = 7,
    SDEV_BLOCK = 8,
    SDEV_CREATED_BLOCK = 9
} ;
struct scsi_target;
struct scsi_dh_data;
struct scsi_device {
   struct Scsi_Host *host ;
   struct request_queue *request_queue ;
   struct list_head siblings ;
   struct list_head same_target_siblings ;
   atomic_t device_busy ;
   atomic_t device_blocked ;
   spinlock_t list_lock ;
   struct list_head cmd_list ;
   struct list_head starved_entry ;
   struct scsi_cmnd *current_cmnd ;
   unsigned short queue_depth ;
    klee_make_symbolic(&queue_depth, sizeof(short), "queue_depth");
   unsigned short max_queue_depth ;
    klee_make_symbolic(&max_queue_depth, sizeof(short), "max_queue_depth");
   unsigned short last_queue_full_depth ;
    klee_make_symbolic(&last_queue_full_depth, sizeof(short), "last_queue_full_depth");
   unsigned short last_queue_full_count ;
    klee_make_symbolic(&last_queue_full_count, sizeof(short), "last_queue_full_count");
   unsigned long last_queue_full_time ;
    klee_make_symbolic(&last_queue_full_time, sizeof(long), "last_queue_full_time");
   unsigned long queue_ramp_up_period ;
    klee_make_symbolic(&queue_ramp_up_period, sizeof(long), "queue_ramp_up_period");
   unsigned long last_queue_ramp_up ;
    klee_make_symbolic(&last_queue_ramp_up, sizeof(long), "last_queue_ramp_up");
   unsigned int id ;
   unsigned int channel ;
    klee_make_symbolic(&channel, sizeof(int), "channel");
   u64 lun ;
   unsigned int manufacturer ;
    klee_make_symbolic(&manufacturer, sizeof(int), "manufacturer");
   unsigned int sector_size ;
    klee_make_symbolic(&sector_size, sizeof(int), "sector_size");
   void *hostdata ;
   char type ;
    klee_make_symbolic(&type, sizeof(char), "type");
   char scsi_level ;
    klee_make_symbolic(&scsi_level, sizeof(char), "scsi_level");
   char inq_periph_qual ;
    klee_make_symbolic(&inq_periph_qual, sizeof(char), "inq_periph_qual");
   unsigned char inquiry_len ;
    klee_make_symbolic(&inquiry_len, sizeof(char), "inquiry_len");
   unsigned char *inquiry ;
   char const   *vendor ;
   char const   *model ;
   char const   *rev ;
   int vpd_pg83_len ;
    klee_make_symbolic(&vpd_pg83_len, sizeof(int), "vpd_pg83_len");
   unsigned char *vpd_pg83 ;
   int vpd_pg80_len ;
    klee_make_symbolic(&vpd_pg80_len, sizeof(int), "vpd_pg80_len");
   unsigned char *vpd_pg80 ;
   unsigned char current_tag ;
    klee_make_symbolic(&current_tag, sizeof(char), "current_tag");
   struct scsi_target *sdev_target ;
   unsigned int sdev_bflags ;
    klee_make_symbolic(&sdev_bflags, sizeof(int), "sdev_bflags");
   unsigned int eh_timeout ;
    klee_make_symbolic(&eh_timeout, sizeof(int), "eh_timeout");
   unsigned char removable : 1 ;
   unsigned char changed : 1 ;
   unsigned char busy : 1 ;
   unsigned char lockable : 1 ;
   unsigned char locked : 1 ;
   unsigned char borken : 1 ;
   unsigned char disconnect : 1 ;
   unsigned char soft_reset : 1 ;
   unsigned char sdtr : 1 ;
   unsigned char wdtr : 1 ;
   unsigned char ppr : 1 ;
   unsigned char tagged_supported : 1 ;
   unsigned char simple_tags : 1 ;
   unsigned char was_reset : 1 ;
   unsigned char expecting_cc_ua : 1 ;
   unsigned char use_10_for_rw : 1 ;
   unsigned char use_10_for_ms : 1 ;
   unsigned char no_report_opcodes : 1 ;
   unsigned char no_write_same : 1 ;
   unsigned char use_16_for_rw : 1 ;
   unsigned char skip_ms_page_8 : 1 ;
   unsigned char skip_ms_page_3f : 1 ;
   unsigned char skip_vpd_pages : 1 ;
   unsigned char try_vpd_pages : 1 ;
   unsigned char use_192_bytes_for_3f : 1 ;
   unsigned char no_start_on_add : 1 ;
   unsigned char allow_restart : 1 ;
   unsigned char manage_start_stop : 1 ;
   unsigned char start_stop_pwr_cond : 1 ;
   unsigned char no_uld_attach : 1 ;
   unsigned char select_no_atn : 1 ;
   unsigned char fix_capacity : 1 ;
   unsigned char guess_capacity : 1 ;
   unsigned char retry_hwerror : 1 ;
   unsigned char last_sector_bug : 1 ;
   unsigned char no_read_disc_info : 1 ;
   unsigned char no_read_capacity_16 : 1 ;
   unsigned char try_rc_10_first : 1 ;
   unsigned char is_visible : 1 ;
   unsigned char wce_default_on : 1 ;
   unsigned char no_dif : 1 ;
   unsigned char broken_fua : 1 ;
   unsigned char lun_in_cdb : 1 ;
   atomic_t disk_events_disable_depth ;
   unsigned long supported_events[1U] ;
   unsigned long pending_events[1U] ;
   struct list_head event_list ;
   struct work_struct event_work ;
   unsigned int max_device_blocked ;
    klee_make_symbolic(&max_device_blocked, sizeof(int), "max_device_blocked");
   atomic_t iorequest_cnt ;
   atomic_t iodone_cnt ;
   atomic_t ioerr_cnt ;
   struct device sdev_gendev ;
   struct device sdev_dev ;
   struct execute_work ew ;
   struct work_struct requeue_work ;
   struct scsi_dh_data *scsi_dh_data ;
   enum scsi_device_state sdev_state ;
   unsigned long sdev_data[0U] ;
};
struct scsi_device_handler {
   struct list_head list ;
   struct module *module ;
   char const   *name ;
   int (*check_sense)(struct scsi_device * , struct scsi_sense_hdr * ) ;
   struct scsi_dh_data *(*attach)(struct scsi_device * ) ;
   void (*detach)(struct scsi_device * ) ;
   int (*activate)(struct scsi_device * , void (*)(void * , int  ) , void * ) ;
   int (*prep_fn)(struct scsi_device * , struct request * ) ;
   int (*set_params)(struct scsi_device * , char const   * ) ;
   bool (*match)(struct scsi_device * ) ;
};
struct scsi_dh_data {
   struct scsi_device_handler *scsi_dh ;
   struct scsi_device *sdev ;
   struct kref kref ;
};
enum scsi_target_state {
    STARGET_CREATED = 1,
    STARGET_RUNNING = 2,
    STARGET_DEL = 3
} ;
struct scsi_target {
   struct scsi_device *starget_sdev_user ;
   struct list_head siblings ;
   struct list_head devices ;
   struct device dev ;
   struct kref reap_ref ;
   unsigned int channel ;
   unsigned int id ;
   unsigned char create : 1 ;
   unsigned char single_lun : 1 ;
   unsigned char pdt_1f_for_no_lun : 1 ;
   unsigned char no_report_luns : 1 ;
   unsigned char expecting_lun_change : 1 ;
   atomic_t target_busy ;
   atomic_t target_blocked ;
   unsigned int can_queue ;
    klee_make_symbolic(&can_queue, sizeof(int), "can_queue");
   unsigned int max_target_blocked ;
    klee_make_symbolic(&max_target_blocked, sizeof(int), "max_target_blocked");
   char scsi_level ;
   enum scsi_target_state state ;
   void *hostdata ;
   unsigned long starget_data[0U] ;
};
struct scsi_data_buffer {
   struct sg_table table ;
   unsigned int length ;
   int resid ;
    klee_make_symbolic(&resid, sizeof(int), "resid");
};
struct scsi_pointer {
   char *ptr ;
   int this_residual ;
    klee_make_symbolic(&this_residual, sizeof(int), "this_residual");
   struct scatterlist *buffer ;
   int buffers_residual ;
    klee_make_symbolic(&buffers_residual, sizeof(int), "buffers_residual");
   dma_addr_t dma_handle ;
   int volatile   Status ;
   int volatile   Message ;
   int volatile   have_data_in ;
   int volatile   sent_command ;
   int volatile   phase ;
};
struct scsi_cmnd {
   struct scsi_device *device ;
   struct list_head list ;
   struct list_head eh_entry ;
   struct delayed_work abort_work ;
   int eh_eflags ;
    klee_make_symbolic(&eh_eflags, sizeof(int), "eh_eflags");
   unsigned long serial_number ;
    klee_make_symbolic(&serial_number, sizeof(long), "serial_number");
   unsigned long jiffies_at_alloc ;
    klee_make_symbolic(&jiffies_at_alloc, sizeof(long), "jiffies_at_alloc");
   int retries ;
   int allowed ;
    klee_make_symbolic(&allowed, sizeof(int), "allowed");
   unsigned char prot_op ;
    klee_make_symbolic(&prot_op, sizeof(char), "prot_op");
   unsigned char prot_type ;
    klee_make_symbolic(&prot_type, sizeof(char), "prot_type");
   unsigned char prot_flags ;
    klee_make_symbolic(&prot_flags, sizeof(char), "prot_flags");
   unsigned short cmd_len ;
   enum dma_data_direction sc_data_direction ;
   unsigned char *cmnd ;
   struct scsi_data_buffer sdb ;
   struct scsi_data_buffer *prot_sdb ;
   unsigned int underflow ;
    klee_make_symbolic(&underflow, sizeof(int), "underflow");
   unsigned int transfersize ;
    klee_make_symbolic(&transfersize, sizeof(int), "transfersize");
   struct request *request ;
   unsigned char *sense_buffer ;
   void (*scsi_done)(struct scsi_cmnd * ) ;
   struct scsi_pointer SCp ;
   unsigned char *host_scribble ;
   int result ;
    klee_make_symbolic(&result, sizeof(int), "result");
   int flags ;
   unsigned char tag ;
};
struct blk_mq_tags;
struct blk_mq_cpu_notifier {
   struct list_head list ;
   void *data ;
   int (*notify)(void * , unsigned long  , unsigned int  ) ;
};
struct blk_align_bitmap;
struct blk_mq_ctxmap {
   unsigned int size ;
   unsigned int bits_per_word ;
    klee_make_symbolic(&bits_per_word, sizeof(int), "bits_per_word");
   struct blk_align_bitmap *map ;
};
struct __anonstruct____missing_field_name_270 {
   spinlock_t lock ;
   struct list_head dispatch ;
};
struct blk_mq_hw_ctx {
   struct __anonstruct____missing_field_name_270 __annonCompField84 ;
   unsigned long state ;
   struct delayed_work run_work ;
   struct delayed_work delay_work ;
   cpumask_var_t cpumask ;
   int next_cpu ;
    klee_make_symbolic(&next_cpu, sizeof(int), "next_cpu");
   int next_cpu_batch ;
    klee_make_symbolic(&next_cpu_batch, sizeof(int), "next_cpu_batch");
   unsigned long flags ;
   struct request_queue *queue ;
   struct blk_flush_queue *fq ;
   void *driver_data ;
   struct blk_mq_ctxmap ctx_map ;
   unsigned int nr_ctx ;
    klee_make_symbolic(&nr_ctx, sizeof(int), "nr_ctx");
   struct blk_mq_ctx **ctxs ;
   atomic_t wait_index ;
   struct blk_mq_tags *tags ;
   unsigned long queued ;
    klee_make_symbolic(&queued, sizeof(long), "queued");
   unsigned long run ;
    klee_make_symbolic(&run, sizeof(long), "run");
   unsigned long dispatched[10U] ;
   unsigned int numa_node ;
   unsigned int queue_num ;
    klee_make_symbolic(&queue_num, sizeof(int), "queue_num");
   atomic_t nr_active ;
   struct blk_mq_cpu_notifier cpu_notifier ;
   struct kobject kobj ;
};
struct blk_mq_tag_set {
   struct blk_mq_ops *ops ;
   unsigned int nr_hw_queues ;
   unsigned int queue_depth ;
   unsigned int reserved_tags ;
    klee_make_symbolic(&reserved_tags, sizeof(int), "reserved_tags");
   unsigned int cmd_size ;
    klee_make_symbolic(&cmd_size, sizeof(int), "cmd_size");
   int numa_node ;
   unsigned int timeout ;
   unsigned int flags ;
   void *driver_data ;
   struct blk_mq_tags **tags ;
   struct mutex tag_list_lock ;
   struct list_head tag_list ;
};
struct blk_mq_queue_data {
   struct request *rq ;
   struct list_head *list ;
   bool last ;
};
typedef int queue_rq_fn(struct blk_mq_hw_ctx * , struct blk_mq_queue_data  const  * );
typedef struct blk_mq_hw_ctx *map_queue_fn(struct request_queue * , int const    );
typedef enum blk_eh_timer_return timeout_fn(struct request * , bool  );
typedef int init_hctx_fn(struct blk_mq_hw_ctx * , void * , unsigned int  );
typedef void exit_hctx_fn(struct blk_mq_hw_ctx * , unsigned int  );
typedef int init_request_fn(void * , struct request * , unsigned int  , unsigned int  ,
                            unsigned int  );
typedef void exit_request_fn(void * , struct request * , unsigned int  , unsigned int  );
struct blk_mq_ops {
   queue_rq_fn *queue_rq ;
   map_queue_fn *map_queue ;
   timeout_fn *timeout ;
   softirq_done_fn *complete ;
   init_hctx_fn *init_hctx ;
   exit_hctx_fn *exit_hctx ;
   init_request_fn *init_request ;
   exit_request_fn *exit_request ;
};
struct scsi_host_cmd_pool;
struct scsi_transport_template;
struct scsi_host_template {
   struct module *module ;
   char const   *name ;
   int (*detect)(struct scsi_host_template * ) ;
   int (*release)(struct Scsi_Host * ) ;
   char const   *(*info)(struct Scsi_Host * ) ;
   int (*ioctl)(struct scsi_device * , int  , void * ) ;
   int (*compat_ioctl)(struct scsi_device * , int  , void * ) ;
   int (*queuecommand)(struct Scsi_Host * , struct scsi_cmnd * ) ;
   int (*eh_abort_handler)(struct scsi_cmnd * ) ;
   int (*eh_device_reset_handler)(struct scsi_cmnd * ) ;
   int (*eh_target_reset_handler)(struct scsi_cmnd * ) ;
   int (*eh_bus_reset_handler)(struct scsi_cmnd * ) ;
   int (*eh_host_reset_handler)(struct scsi_cmnd * ) ;
   int (*slave_alloc)(struct scsi_device * ) ;
   int (*slave_configure)(struct scsi_device * ) ;
   void (*slave_destroy)(struct scsi_device * ) ;
   int (*target_alloc)(struct scsi_target * ) ;
   void (*target_destroy)(struct scsi_target * ) ;
   int (*scan_finished)(struct Scsi_Host * , unsigned long  ) ;
   void (*scan_start)(struct Scsi_Host * ) ;
   int (*change_queue_depth)(struct scsi_device * , int  ) ;
   int (*bios_param)(struct scsi_device * , struct block_device * , sector_t  , int * ) ;
   void (*unlock_native_capacity)(struct scsi_device * ) ;
   int (*show_info)(struct seq_file * , struct Scsi_Host * ) ;
   int (*write_info)(struct Scsi_Host * , char * , int  ) ;
   enum blk_eh_timer_return (*eh_timed_out)(struct scsi_cmnd * ) ;
   int (*host_reset)(struct Scsi_Host * , int  ) ;
   char const   *proc_name ;
   struct proc_dir_entry *proc_dir ;
   int can_queue ;
   int this_id ;
    klee_make_symbolic(&this_id, sizeof(int), "this_id");
   unsigned short sg_tablesize ;
    klee_make_symbolic(&sg_tablesize, sizeof(short), "sg_tablesize");
   unsigned short sg_prot_tablesize ;
    klee_make_symbolic(&sg_prot_tablesize, sizeof(short), "sg_prot_tablesize");
   unsigned int max_sectors ;
   unsigned long dma_boundary ;
    klee_make_symbolic(&dma_boundary, sizeof(long), "dma_boundary");
   short cmd_per_lun ;
    klee_make_symbolic(&cmd_per_lun, sizeof(short), "cmd_per_lun");
   unsigned char present ;
    klee_make_symbolic(&present, sizeof(char), "present");
   int tag_alloc_policy ;
    klee_make_symbolic(&tag_alloc_policy, sizeof(int), "tag_alloc_policy");
   unsigned char use_blk_tags : 1 ;
   unsigned char track_queue_depth : 1 ;
   unsigned char supported_mode : 2 ;
   unsigned char unchecked_isa_dma : 1 ;
   unsigned char use_clustering : 1 ;
   unsigned char emulated : 1 ;
   unsigned char skip_settle_delay : 1 ;
   unsigned char no_write_same : 1 ;
   unsigned char no_async_abort : 1 ;
   unsigned int max_host_blocked ;
    klee_make_symbolic(&max_host_blocked, sizeof(int), "max_host_blocked");
   struct device_attribute **shost_attrs ;
   struct device_attribute **sdev_attrs ;
   struct list_head legacy_hosts ;
   u64 vendor_id ;
   unsigned int cmd_size ;
   struct scsi_host_cmd_pool *cmd_pool ;
   bool disable_blk_mq ;
};
enum scsi_host_state {
    SHOST_CREATED = 1,
    SHOST_RUNNING = 2,
    SHOST_CANCEL = 3,
    SHOST_DEL = 4,
    SHOST_RECOVERY = 5,
    SHOST_CANCEL_RECOVERY = 6,
    SHOST_DEL_RECOVERY = 7
} ;
union __anonunion____missing_field_name_271 {
   struct blk_queue_tag *bqt ;
   struct blk_mq_tag_set tag_set ;
};
struct Scsi_Host {
   struct list_head __devices ;
   struct list_head __targets ;
   struct scsi_host_cmd_pool *cmd_pool ;
   spinlock_t free_list_lock ;
   struct list_head free_list ;
   struct list_head starved_list ;
   spinlock_t default_lock ;
   spinlock_t *host_lock ;
   struct mutex scan_mutex ;
   struct list_head eh_cmd_q ;
   struct task_struct *ehandler ;
   struct completion *eh_action ;
   wait_queue_head_t host_wait ;
   struct scsi_host_template *hostt ;
   struct scsi_transport_template *transportt ;
   union __anonunion____missing_field_name_271 __annonCompField85 ;
   atomic_t host_busy ;
   atomic_t host_blocked ;
   unsigned int host_failed ;
    klee_make_symbolic(&host_failed, sizeof(int), "host_failed");
   unsigned int host_eh_scheduled ;
    klee_make_symbolic(&host_eh_scheduled, sizeof(int), "host_eh_scheduled");
   unsigned int host_no ;
    klee_make_symbolic(&host_no, sizeof(int), "host_no");
   int eh_deadline ;
    klee_make_symbolic(&eh_deadline, sizeof(int), "eh_deadline");
   unsigned long last_reset ;
    klee_make_symbolic(&last_reset, sizeof(long), "last_reset");
   unsigned int max_channel ;
    klee_make_symbolic(&max_channel, sizeof(int), "max_channel");
   unsigned int max_id ;
    klee_make_symbolic(&max_id, sizeof(int), "max_id");
   u64 max_lun ;
   unsigned int unique_id ;
    klee_make_symbolic(&unique_id, sizeof(int), "unique_id");
   unsigned short max_cmd_len ;
    klee_make_symbolic(&max_cmd_len, sizeof(short), "max_cmd_len");
   int this_id ;
   int can_queue ;
   short cmd_per_lun ;
   unsigned short sg_tablesize ;
   unsigned short sg_prot_tablesize ;
   unsigned int max_sectors ;
   unsigned long dma_boundary ;
   unsigned int nr_hw_queues ;
   unsigned long cmd_serial_number ;
    klee_make_symbolic(&cmd_serial_number, sizeof(long), "cmd_serial_number");
   unsigned char active_mode : 2 ;
   unsigned char unchecked_isa_dma : 1 ;
   unsigned char use_clustering : 1 ;
   unsigned char host_self_blocked : 1 ;
   unsigned char reverse_ordering : 1 ;
   unsigned char tmf_in_progress : 1 ;
   unsigned char async_scan : 1 ;
   unsigned char eh_noresume : 1 ;
   unsigned char no_write_same : 1 ;
   unsigned char use_blk_mq : 1 ;
   unsigned char use_cmd_list : 1 ;
   char work_q_name[20U] ;
   struct workqueue_struct *work_q ;
   struct workqueue_struct *tmf_work_q ;
   unsigned char no_scsi2_lun_in_cdb : 1 ;
   unsigned int max_host_blocked ;
   unsigned int prot_capabilities ;
    klee_make_symbolic(&prot_capabilities, sizeof(int), "prot_capabilities");
   unsigned char prot_guard_type ;
    klee_make_symbolic(&prot_guard_type, sizeof(char), "prot_guard_type");
   struct request_queue *uspace_req_q ;
   unsigned long base ;
    klee_make_symbolic(&base, sizeof(long), "base");
   unsigned long io_port ;
    klee_make_symbolic(&io_port, sizeof(long), "io_port");
   unsigned char n_io_port ;
    klee_make_symbolic(&n_io_port, sizeof(char), "n_io_port");
   unsigned char dma_channel ;
    klee_make_symbolic(&dma_channel, sizeof(char), "dma_channel");
   unsigned int irq ;
   enum scsi_host_state shost_state ;
   struct device shost_gendev ;
   struct device shost_dev ;
   struct list_head sht_legacy_list ;
   void *shost_data ;
   struct device *dma_dev ;
   unsigned long hostdata[0U] ;
};
struct rtsx_chip;
struct rtsx_dev {
   struct pci_dev *pci ;
   unsigned long addr ;
    klee_make_symbolic(&addr, sizeof(long), "addr");
   void *remap_addr ;
   int irq ;
   spinlock_t reg_lock ;
   struct task_struct *ctl_thread ;
   struct task_struct *polling_thread ;
   struct completion cmnd_ready ;
   struct completion control_exit ;
   struct completion polling_exit ;
   struct completion notify ;
   struct completion scanning_done ;
   wait_queue_head_t delay_wait ;
   struct mutex dev_mutex ;
   void *rtsx_resv_buf ;
   dma_addr_t rtsx_resv_buf_addr ;
   char trans_result ;
    klee_make_symbolic(&trans_result, sizeof(char), "trans_result");
   char trans_state ;
    klee_make_symbolic(&trans_state, sizeof(char), "trans_state");
   struct completion *done ;
   u32 check_card_cd ;
   struct rtsx_chip *chip ;
};
typedef struct rtsx_dev rtsx_dev_t;
struct sense_data_t {
   unsigned char err_code ;
    klee_make_symbolic(&err_code, sizeof(char), "err_code");
   unsigned char seg_no ;
    klee_make_symbolic(&seg_no, sizeof(char), "seg_no");
   unsigned char sense_key ;
    klee_make_symbolic(&sense_key, sizeof(char), "sense_key");
   unsigned char info[4U] ;
   unsigned char ad_sense_len ;
    klee_make_symbolic(&ad_sense_len, sizeof(char), "ad_sense_len");
   unsigned char cmd_info[4U] ;
   unsigned char asc ;
    klee_make_symbolic(&asc, sizeof(char), "asc");
   unsigned char ascq ;
    klee_make_symbolic(&ascq, sizeof(char), "ascq");
   unsigned char rfu ;
    klee_make_symbolic(&rfu, sizeof(char), "rfu");
   unsigned char sns_key_info[3U] ;
};
typedef int (*card_rw_func)(struct scsi_cmnd * , struct rtsx_chip * , u32  , u16  );
enum RTSX_STAT {
    RTSX_STAT_INIT = 0,
    RTSX_STAT_IDLE = 1,
    RTSX_STAT_RUN = 2,
    RTSX_STAT_SS = 3,
    RTSX_STAT_DELINK = 4,
    RTSX_STAT_SUSPEND = 5,
    RTSX_STAT_ABORT = 6,
    RTSX_STAT_DISCONNECT = 7
} ;
struct zone_entry {
   u16 *l2p_table ;
   u16 *free_table ;
   u16 defect_list[10U] ;
   int set_index ;
    klee_make_symbolic(&set_index, sizeof(int), "set_index");
   int get_index ;
    klee_make_symbolic(&get_index, sizeof(int), "get_index");
   int unused_blk_cnt ;
    klee_make_symbolic(&unused_blk_cnt, sizeof(int), "unused_blk_cnt");
   int disable_count ;
    klee_make_symbolic(&disable_count, sizeof(int), "disable_count");
   int build_flag ;
    klee_make_symbolic(&build_flag, sizeof(int), "build_flag");
};
struct sd_info {
   u16 sd_type ;
   u8 err_code ;
   u8 sd_data_buf_ready ;
   u32 sd_addr ;
   u32 capacity ;
   u8 raw_csd[16U] ;
   u8 raw_scr[8U] ;
   int seq_mode ;
    klee_make_symbolic(&seq_mode, sizeof(int), "seq_mode");
   enum dma_data_direction pre_dir ;
   u32 pre_sec_addr ;
   u16 pre_sec_cnt ;
   int cleanup_counter ;
    klee_make_symbolic(&cleanup_counter, sizeof(int), "cleanup_counter");
   int sd_clock ;
    klee_make_symbolic(&sd_clock, sizeof(int), "sd_clock");
   int mmc_dont_switch_bus ;
    klee_make_symbolic(&mmc_dont_switch_bus, sizeof(int), "mmc_dont_switch_bus");
   int sd_pass_thru_en ;
    klee_make_symbolic(&sd_pass_thru_en, sizeof(int), "sd_pass_thru_en");
   int pre_cmd_err ;
    klee_make_symbolic(&pre_cmd_err, sizeof(int), "pre_cmd_err");
   u8 last_rsp_type ;
   u8 rsp[17U] ;
   u8 func_group1_mask ;
   u8 func_group2_mask ;
   u8 func_group3_mask ;
   u8 func_group4_mask ;
   u8 sd_switch_fail ;
   u8 sd_read_phase ;
   u8 sd_lock_status ;
   u8 sd_erase_status ;
   u8 sd_lock_notify ;
   int need_retune ;
    klee_make_symbolic(&need_retune, sizeof(int), "need_retune");
};
struct xd_delay_write_tag {
   u32 old_phyblock ;
   u32 new_phyblock ;
   u32 logblock ;
   u8 pageoff ;
   u8 delay_write_flag ;
};
struct xd_info {
   u8 maker_code ;
   u8 device_code ;
   u8 block_shift ;
   u8 page_off ;
   u8 addr_cycle ;
   u16 cis_block ;
   u8 multi_flag ;
   u8 err_code ;
   u32 capacity ;
   struct zone_entry *zone ;
   int zone_cnt ;
    klee_make_symbolic(&zone_cnt, sizeof(int), "zone_cnt");
   struct xd_delay_write_tag delay_write ;
   int cleanup_counter ;
   int xd_clock ;
    klee_make_symbolic(&xd_clock, sizeof(int), "xd_clock");
};
struct ms_delay_write_tag {
   u16 old_phyblock ;
   u16 new_phyblock ;
   u16 logblock ;
   u8 pageoff ;
   u8 delay_write_flag ;
};
struct ms_info {
   u16 ms_type ;
   u8 block_shift ;
   u8 page_off ;
   u16 total_block ;
   u16 boot_block ;
   u32 capacity ;
   u8 check_ms_flow ;
   u8 switch_8bit_fail ;
   u8 err_code ;
   struct zone_entry *segment ;
   int segment_cnt ;
    klee_make_symbolic(&segment_cnt, sizeof(int), "segment_cnt");
   int pro_under_formatting ;
    klee_make_symbolic(&pro_under_formatting, sizeof(int), "pro_under_formatting");
   int format_status ;
    klee_make_symbolic(&format_status, sizeof(int), "format_status");
   u16 progress ;
   u8 raw_sys_info[96U] ;
   u8 raw_model_name[48U] ;
   u8 multi_flag ;
   u8 seq_mode ;
   enum dma_data_direction pre_dir ;
   u32 pre_sec_addr ;
   u16 pre_sec_cnt ;
   u32 total_sec_cnt ;
   struct ms_delay_write_tag delay_write ;
   int cleanup_counter ;
   int ms_clock ;
    klee_make_symbolic(&ms_clock, sizeof(int), "ms_clock");
   u8 magic_gate_id[16U] ;
   u8 mg_entry_num ;
   int mg_auth ;
    klee_make_symbolic(&mg_auth, sizeof(int), "mg_auth");
};
struct spi_info {
   u8 use_clk ;
   u8 write_en ;
   u16 clk_div ;
   u8 err_code ;
   int spi_clock ;
    klee_make_symbolic(&spi_clock, sizeof(int), "spi_clock");
};
struct trace_msg_t {
   u16 line ;
   char func[64U] ;
   char file[32U] ;
   u8 timeval_buf[16U] ;
   u8 valid ;
};
struct rtsx_chip {
   rtsx_dev_t *rtsx ;
   u32 int_reg ;
   char max_lun ;
    klee_make_symbolic(&max_lun, sizeof(char), "max_lun");
   void *context ;
   void *host_cmds_ptr ;
   dma_addr_t host_cmds_addr ;
   int ci ;
    klee_make_symbolic(&ci, sizeof(int), "ci");
   void *host_sg_tbl_ptr ;
   dma_addr_t host_sg_tbl_addr ;
   int sgi ;
    klee_make_symbolic(&sgi, sizeof(int), "sgi");
   struct scsi_cmnd *srb ;
   struct sense_data_t sense_buffer[8U] ;
   int cur_clk ;
    klee_make_symbolic(&cur_clk, sizeof(int), "cur_clk");
   int cur_card ;
    klee_make_symbolic(&cur_card, sizeof(int), "cur_card");
   unsigned long need_release ;
    klee_make_symbolic(&need_release, sizeof(long), "need_release");
   unsigned long need_reset ;
    klee_make_symbolic(&need_reset, sizeof(long), "need_reset");
   unsigned long need_reinit ;
    klee_make_symbolic(&need_reinit, sizeof(long), "need_reinit");
   int rw_need_retry ;
    klee_make_symbolic(&rw_need_retry, sizeof(int), "rw_need_retry");
   u32 ocp_int ;
   u8 ocp_stat ;
   u8 card_exist ;
   u8 card_ready ;
   u8 card_fail ;
   u8 card_ejected ;
   u8 card_wp ;
   u8 lun_mc ;
   int led_toggle_counter ;
    klee_make_symbolic(&led_toggle_counter, sizeof(int), "led_toggle_counter");
   int sd_reset_counter ;
    klee_make_symbolic(&sd_reset_counter, sizeof(int), "sd_reset_counter");
   int xd_reset_counter ;
    klee_make_symbolic(&xd_reset_counter, sizeof(int), "xd_reset_counter");
   int ms_reset_counter ;
    klee_make_symbolic(&ms_reset_counter, sizeof(int), "ms_reset_counter");
   u8 card_bus_width[8U] ;
   u32 capacity[8U] ;
   card_rw_func rw_card[8U] ;
   u32 rw_cap[8U] ;
   u8 card2lun[32U] ;
   u8 lun2card[8U] ;
   int rw_fail_cnt[8U] ;
   int sd_show_cnt ;
    klee_make_symbolic(&sd_show_cnt, sizeof(int), "sd_show_cnt");
   int xd_show_cnt ;
    klee_make_symbolic(&xd_show_cnt, sizeof(int), "xd_show_cnt");
   int ms_show_cnt ;
    klee_make_symbolic(&ms_show_cnt, sizeof(int), "ms_show_cnt");
   struct sd_info sd_card ;
   struct xd_info xd_card ;
   struct ms_info ms_card ;
   struct spi_info spi ;
   struct trace_msg_t trace_msg[64U] ;
   int msg_idx ;
    klee_make_symbolic(&msg_idx, sizeof(int), "msg_idx");
   int auto_delink_cnt ;
    klee_make_symbolic(&auto_delink_cnt, sizeof(int), "auto_delink_cnt");
   int auto_delink_allowed ;
    klee_make_symbolic(&auto_delink_allowed, sizeof(int), "auto_delink_allowed");
   int aspm_enabled ;
    klee_make_symbolic(&aspm_enabled, sizeof(int), "aspm_enabled");
   int sdio_aspm ;
    klee_make_symbolic(&sdio_aspm, sizeof(int), "sdio_aspm");
   int sdio_idle ;
    klee_make_symbolic(&sdio_idle, sizeof(int), "sdio_idle");
   int sdio_counter ;
    klee_make_symbolic(&sdio_counter, sizeof(int), "sdio_counter");
   u8 sdio_raw_data[12U] ;
   u8 sd_io ;
   u8 sd_int ;
   u8 rtsx_flag ;
   int ss_counter ;
    klee_make_symbolic(&ss_counter, sizeof(int), "ss_counter");
   int idle_counter ;
    klee_make_symbolic(&idle_counter, sizeof(int), "idle_counter");
   enum RTSX_STAT rtsx_stat ;
   u16 vendor_id ;
   u16 product_id ;
   u8 ic_version ;
   int driver_first_load ;
    klee_make_symbolic(&driver_first_load, sizeof(int), "driver_first_load");
   int sdio_in_charge ;
    klee_make_symbolic(&sdio_in_charge, sizeof(int), "sdio_in_charge");
   u8 aspm_level[2U] ;
   int chip_insert_with_sdio ;
    klee_make_symbolic(&chip_insert_with_sdio, sizeof(int), "chip_insert_with_sdio");
   int adma_mode ;
    klee_make_symbolic(&adma_mode, sizeof(int), "adma_mode");
   int auto_delink_en ;
    klee_make_symbolic(&auto_delink_en, sizeof(int), "auto_delink_en");
   int ss_en ;
    klee_make_symbolic(&ss_en, sizeof(int), "ss_en");
   u8 lun_mode ;
   u8 aspm_l0s_l1_en ;
   int power_down_in_ss ;
    klee_make_symbolic(&power_down_in_ss, sizeof(int), "power_down_in_ss");
   int sdr104_en ;
    klee_make_symbolic(&sdr104_en, sizeof(int), "sdr104_en");
   int ddr50_en ;
    klee_make_symbolic(&ddr50_en, sizeof(int), "ddr50_en");
   int sdr50_en ;
    klee_make_symbolic(&sdr50_en, sizeof(int), "sdr50_en");
   int baro_pkg ;
    klee_make_symbolic(&baro_pkg, sizeof(int), "baro_pkg");
   int asic_code ;
    klee_make_symbolic(&asic_code, sizeof(int), "asic_code");
   int phy_debug_mode ;
    klee_make_symbolic(&phy_debug_mode, sizeof(int), "phy_debug_mode");
   int hw_bypass_sd ;
    klee_make_symbolic(&hw_bypass_sd, sizeof(int), "hw_bypass_sd");
   int sdio_func_exist ;
    klee_make_symbolic(&sdio_func_exist, sizeof(int), "sdio_func_exist");
   int aux_pwr_exist ;
    klee_make_symbolic(&aux_pwr_exist, sizeof(int), "aux_pwr_exist");
   u8 ms_power_class_en ;
   int mspro_formatter_enable ;
    klee_make_symbolic(&mspro_formatter_enable, sizeof(int), "mspro_formatter_enable");
   int remote_wakeup_en ;
    klee_make_symbolic(&remote_wakeup_en, sizeof(int), "remote_wakeup_en");
   int ignore_sd ;
    klee_make_symbolic(&ignore_sd, sizeof(int), "ignore_sd");
   int use_hw_setting ;
    klee_make_symbolic(&use_hw_setting, sizeof(int), "use_hw_setting");
   int ss_idle_period ;
    klee_make_symbolic(&ss_idle_period, sizeof(int), "ss_idle_period");
   int dynamic_aspm ;
    klee_make_symbolic(&dynamic_aspm, sizeof(int), "dynamic_aspm");
   int fpga_sd_sdr104_clk ;
    klee_make_symbolic(&fpga_sd_sdr104_clk, sizeof(int), "fpga_sd_sdr104_clk");
   int fpga_sd_ddr50_clk ;
    klee_make_symbolic(&fpga_sd_ddr50_clk, sizeof(int), "fpga_sd_ddr50_clk");
   int fpga_sd_sdr50_clk ;
    klee_make_symbolic(&fpga_sd_sdr50_clk, sizeof(int), "fpga_sd_sdr50_clk");
   int fpga_sd_hs_clk ;
    klee_make_symbolic(&fpga_sd_hs_clk, sizeof(int), "fpga_sd_hs_clk");
   int fpga_mmc_52m_clk ;
    klee_make_symbolic(&fpga_mmc_52m_clk, sizeof(int), "fpga_mmc_52m_clk");
   int fpga_ms_hg_clk ;
    klee_make_symbolic(&fpga_ms_hg_clk, sizeof(int), "fpga_ms_hg_clk");
   int fpga_ms_4bit_clk ;
    klee_make_symbolic(&fpga_ms_4bit_clk, sizeof(int), "fpga_ms_4bit_clk");
   int fpga_ms_1bit_clk ;
    klee_make_symbolic(&fpga_ms_1bit_clk, sizeof(int), "fpga_ms_1bit_clk");
   int asic_sd_sdr104_clk ;
    klee_make_symbolic(&asic_sd_sdr104_clk, sizeof(int), "asic_sd_sdr104_clk");
   int asic_sd_ddr50_clk ;
    klee_make_symbolic(&asic_sd_ddr50_clk, sizeof(int), "asic_sd_ddr50_clk");
   int asic_sd_sdr50_clk ;
    klee_make_symbolic(&asic_sd_sdr50_clk, sizeof(int), "asic_sd_sdr50_clk");
   int asic_sd_hs_clk ;
    klee_make_symbolic(&asic_sd_hs_clk, sizeof(int), "asic_sd_hs_clk");
   int asic_mmc_52m_clk ;
    klee_make_symbolic(&asic_mmc_52m_clk, sizeof(int), "asic_mmc_52m_clk");
   int asic_ms_hg_clk ;
    klee_make_symbolic(&asic_ms_hg_clk, sizeof(int), "asic_ms_hg_clk");
   int asic_ms_4bit_clk ;
    klee_make_symbolic(&asic_ms_4bit_clk, sizeof(int), "asic_ms_4bit_clk");
   int asic_ms_1bit_clk ;
    klee_make_symbolic(&asic_ms_1bit_clk, sizeof(int), "asic_ms_1bit_clk");
   u8 ssc_depth_sd_sdr104 ;
   u8 ssc_depth_sd_ddr50 ;
   u8 ssc_depth_sd_sdr50 ;
   u8 ssc_depth_sd_hs ;
   u8 ssc_depth_mmc_52m ;
   u8 ssc_depth_ms_hg ;
   u8 ssc_depth_ms_4bit ;
   u8 ssc_depth_low_speed ;
   u8 card_drive_sel ;
   u8 sd30_drive_sel_1v8 ;
   u8 sd30_drive_sel_3v3 ;
   u8 sd_400mA_ocp_thd ;
   u8 sd_800mA_ocp_thd ;
   u8 ms_ocp_thd ;
   int ssc_en ;
    klee_make_symbolic(&ssc_en, sizeof(int), "ssc_en");
   int msi_en ;
    klee_make_symbolic(&msi_en, sizeof(int), "msi_en");
   int xd_timeout ;
    klee_make_symbolic(&xd_timeout, sizeof(int), "xd_timeout");
   int sd_timeout ;
    klee_make_symbolic(&sd_timeout, sizeof(int), "sd_timeout");
   int ms_timeout ;
    klee_make_symbolic(&ms_timeout, sizeof(int), "ms_timeout");
   int mspro_timeout ;
    klee_make_symbolic(&mspro_timeout, sizeof(int), "mspro_timeout");
   int auto_power_down ;
    klee_make_symbolic(&auto_power_down, sizeof(int), "auto_power_down");
   int sd_ddr_tx_phase ;
    klee_make_symbolic(&sd_ddr_tx_phase, sizeof(int), "sd_ddr_tx_phase");
   int mmc_ddr_tx_phase ;
    klee_make_symbolic(&mmc_ddr_tx_phase, sizeof(int), "mmc_ddr_tx_phase");
   int sd_default_tx_phase ;
    klee_make_symbolic(&sd_default_tx_phase, sizeof(int), "sd_default_tx_phase");
   int sd_default_rx_phase ;
    klee_make_symbolic(&sd_default_rx_phase, sizeof(int), "sd_default_rx_phase");
   int pmos_pwr_on_interval ;
    klee_make_symbolic(&pmos_pwr_on_interval, sizeof(int), "pmos_pwr_on_interval");
   int sd_voltage_switch_delay ;
    klee_make_symbolic(&sd_voltage_switch_delay, sizeof(int), "sd_voltage_switch_delay");
   int s3_pwr_off_delay ;
    klee_make_symbolic(&s3_pwr_off_delay, sizeof(int), "s3_pwr_off_delay");
   int force_clkreq_0 ;
    klee_make_symbolic(&force_clkreq_0, sizeof(int), "force_clkreq_0");
   int ft2_fast_mode ;
    klee_make_symbolic(&ft2_fast_mode, sizeof(int), "ft2_fast_mode");
   int do_delink_before_power_down ;
    klee_make_symbolic(&do_delink_before_power_down, sizeof(int), "do_delink_before_power_down");
   int polling_config ;
    klee_make_symbolic(&polling_config, sizeof(int), "polling_config");
   int sdio_retry_cnt ;
    klee_make_symbolic(&sdio_retry_cnt, sizeof(int), "sdio_retry_cnt");
   int delink_stage1_step ;
    klee_make_symbolic(&delink_stage1_step, sizeof(int), "delink_stage1_step");
   int delink_stage2_step ;
    klee_make_symbolic(&delink_stage2_step, sizeof(int), "delink_stage2_step");
   int delink_stage3_step ;
    klee_make_symbolic(&delink_stage3_step, sizeof(int), "delink_stage3_step");
   int auto_delink_in_L1 ;
    klee_make_symbolic(&auto_delink_in_L1, sizeof(int), "auto_delink_in_L1");
   int hp_watch_bios_hotplug ;
    klee_make_symbolic(&hp_watch_bios_hotplug, sizeof(int), "hp_watch_bios_hotplug");
   int support_ms_8bit ;
    klee_make_symbolic(&support_ms_8bit, sizeof(int), "support_ms_8bit");
   u8 blink_led ;
   u8 phy_voltage ;
   u8 max_payload ;
   u32 sd_speed_prior ;
   u32 sd_current_prior ;
   u32 sd_ctl ;
};
typedef int ldv_func_ret_type;
    klee_make_symbolic(&ldv_func_ret_type, sizeof(int), "ldv_func_ret_type");
typedef int ldv_func_ret_type___0;
    klee_make_symbolic(&ldv_func_ret_type___0, sizeof(int), "ldv_func_ret_type___0");
typedef int ldv_func_ret_type___1;
    klee_make_symbolic(&ldv_func_ret_type___1, sizeof(int), "ldv_func_ret_type___1");
typedef struct Scsi_Host *ldv_func_ret_type___2;
typedef int ldv_func_ret_type___3;
    klee_make_symbolic(&ldv_func_ret_type___3, sizeof(int), "ldv_func_ret_type___3");
enum hrtimer_restart;
enum hrtimer_restart;
enum xfer_buf_dir {
    TO_XFER_BUF = 0,
    FROM_XFER_BUF = 1
} ;
enum hrtimer_restart;
enum hrtimer_restart;
enum hrtimer_restart;
enum hrtimer_restart;
struct timing_phase_path {
   int start ;
   int end ;
    klee_make_symbolic(&end, sizeof(int), "end");
   int mid ;
    klee_make_symbolic(&mid, sizeof(int), "mid");
   int len ;
};
enum hrtimer_restart;
enum hrtimer_restart;
enum hrtimer_restart;
enum hrtimer_restart;
__inline static long ldv__builtin_expect(long exp , long c ) ;
extern struct module __this_module ;
extern void __dynamic_dev_dbg(struct _ddebug * , struct device  const  * , char const   * 
                              , ...) ;
extern void __might_sleep(char const   * , int  , int  ) ;
extern void complete_and_exit(struct completion * , long  ) ;
bool ldv_is_err(void const   *ptr ) ;
long ldv_ptr_err(void const   *ptr ) ;
extern void __bad_percpu_size(void) ;
extern struct task_struct *current_task ;
__inline static struct task_struct *get_current(void) 
{ 
  struct task_struct *pfo_ret__ ;

  {
  switch (8UL) {
  case 1UL: 
  __asm__  ("movb %%gs:%P1,%0": "=q" (pfo_ret__): "p" (& current_task));
  goto ldv_2696;
  case 2UL: 
  __asm__  ("movw %%gs:%P1,%0": "=r" (pfo_ret__): "p" (& current_task));
  goto ldv_2696;
  case 4UL: 
  __asm__  ("movl %%gs:%P1,%0": "=r" (pfo_ret__): "p" (& current_task));
  goto ldv_2696;
  case 8UL: 
  __asm__  ("movq %%gs:%P1,%0": "=r" (pfo_ret__): "p" (& current_task));
  goto ldv_2696;
  default: 
  __bad_percpu_size();
  }
  ldv_2696: ;
  return (pfo_ret__);
}
}
__inline static void INIT_LIST_HEAD(struct list_head *list ) 
{ 


  {
  list->next = list;
  list->prev = list;
  return;
}
}
extern void *memset(void * , int  , size_t  ) ;
__inline static long PTR_ERR(void const   *ptr ) ;
__inline static bool IS_ERR(void const   *ptr ) ;
extern void __xchg_wrong_size(void) ;
extern void __mutex_init(struct mutex * , char const   * , struct lock_class_key * ) ;
extern int mutex_trylock(struct mutex * ) ;
int ldv_mutex_trylock_8(struct mutex *ldv_func_arg1 ) ;
extern void mutex_unlock(struct mutex * ) ;
void ldv_mutex_unlock_6(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_9(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_10(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_16(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_18(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_19(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_20(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_23(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_24(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_26(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_27(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_29(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_32(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_34(struct mutex *ldv_func_arg1 ) ;
extern void *malloc(size_t  ) ;
extern void *calloc(size_t  , size_t  ) ;
extern int __VERIFIER_nondet_int(void) ;
extern unsigned long __VERIFIER_nondet_ulong(void) ;
extern void abort(void);
void assume_abort_if_not(int cond) {
  if(!cond) {abort();}
}
__inline static bool IS_ERR(void const *ptr ) ;

void *ldv_malloc(size_t size ) 
{ 
  void *p ;
  void *tmp ;
  int tmp___0 ;
    klee_make_symbolic(&tmp___0, sizeof(int), "tmp___0");

  {
  tmp___0 = __VERIFIER_nondet_int();
  if (tmp___0 != 0) {
    return ((void *)0);
  } else {
    tmp = malloc(size);
    p = tmp;
    assume_abort_if_not((unsigned long )p != (unsigned long )((void *)0));
    assume_abort_if_not(IS_ERR(p) == 0);
    return (p);
  }
}
}
void *ldv_zalloc(size_t size ) 
{ 
  void *p ;
  void *tmp ;
  int tmp___0 ;

  {
  tmp___0 = __VERIFIER_nondet_int();
  if (tmp___0 != 0) {
    return ((void *)0);
  } else {
    tmp = calloc(1UL, size);
    p = tmp;
    assume_abort_if_not((unsigned long )p != (unsigned long )((void *)0));
    assume_abort_if_not(IS_ERR(p) == 0);
    return (p);
  }
}
}
void *ldv_init_zalloc(size_t size ) 
{ 
  void *p ;
  void *tmp ;

  {
  tmp = calloc(1UL, size);
  p = tmp;
  assume_abort_if_not((unsigned long )p != (unsigned long )((void *)0));
  return (p);
}
}
void *ldv_memset(void *s , int c , size_t n ) 
{ 
  void *tmp ;

  {
  tmp = memset(s, c, n);
  return (tmp);
}
}
int ldv_undef_int(void) 
{ 
  int tmp ;

  {
  tmp = __VERIFIER_nondet_int();
  return (tmp);
}
}
unsigned long ldv_undef_ulong(void) 
{ 
  unsigned long tmp ;

  {
  tmp = __VERIFIER_nondet_ulong();
  return (tmp);
}
}
__inline static void ldv_stop(void) 
{ 


  {
  LDV_STOP: ;
  goto LDV_STOP;
}
}
__inline static long ldv__builtin_expect(long exp , long c ) 
{ 


  {
  return (exp);
}
}
extern void mutex_lock(struct mutex * ) ;
void ldv_mutex_lock_5(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_7(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_11(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_14(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_17(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_22(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_25(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_28(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_31(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_33(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_dev_mutex_of_rtsx_dev(struct mutex *lock ) ;
void ldv_mutex_unlock_dev_mutex_of_rtsx_dev(struct mutex *lock ) ;
void ldv_mutex_lock_i_mutex_of_inode(struct mutex *lock ) ;
void ldv_mutex_unlock_i_mutex_of_inode(struct mutex *lock ) ;
void ldv_mutex_lock_lock(struct mutex *lock ) ;
void ldv_mutex_unlock_lock(struct mutex *lock ) ;
void ldv_mutex_lock_mutex_of_device(struct mutex *lock ) ;
int ldv_mutex_trylock_mutex_of_device(struct mutex *lock ) ;
void ldv_mutex_unlock_mutex_of_device(struct mutex *lock ) ;
extern void __raw_spin_lock_init(raw_spinlock_t * , char const   * , struct lock_class_key * ) ;
extern void _raw_spin_lock(raw_spinlock_t * ) ;
extern void _raw_spin_lock_irq(raw_spinlock_t * ) ;
extern unsigned long _raw_spin_lock_irqsave(raw_spinlock_t * ) ;
extern void _raw_spin_unlock(raw_spinlock_t * ) ;
extern void _raw_spin_unlock_irq(raw_spinlock_t * ) ;
extern void _raw_spin_unlock_irqrestore(raw_spinlock_t * , unsigned long  ) ;
__inline static raw_spinlock_t *spinlock_check(spinlock_t *lock ) 
{ 


  {
  return (& lock->__annonCompField17.rlock);
}
}
__inline static void spin_lock(spinlock_t *lock ) 
{ 


  {
  _raw_spin_lock(& lock->__annonCompField17.rlock);
  return;
}
}
__inline static void spin_lock_irq(spinlock_t *lock ) 
{ 


  {
  _raw_spin_lock_irq(& lock->__annonCompField17.rlock);
  return;
}
}
__inline static void spin_unlock(spinlock_t *lock ) 
{ 


  {
  _raw_spin_unlock(& lock->__annonCompField17.rlock);
  return;
}
}
__inline static void spin_unlock_irq(spinlock_t *lock ) 
{ 


  {
  _raw_spin_unlock_irq(& lock->__annonCompField17.rlock);
  return;
}
}
__inline static void spin_unlock_irqrestore(spinlock_t *lock , unsigned long flags ) 
{ 


  {
  _raw_spin_unlock_irqrestore(& lock->__annonCompField17.rlock, flags);
  return;
}
}
extern void __init_waitqueue_head(wait_queue_head_t * , char const   * , struct lock_class_key * ) ;
extern void __wake_up(wait_queue_head_t * , unsigned int  , int  , void * ) ;
extern long prepare_to_wait_event(wait_queue_head_t * , wait_queue_t * , int  ) ;
extern void finish_wait(wait_queue_head_t * , wait_queue_t * ) ;
__inline static void init_completion(struct completion *x ) 
{ 
  struct lock_class_key __key ;

  {
  x->done = 0U;
  __init_waitqueue_head(& x->wait, "&x->wait", & __key);
  return;
}
}
extern void wait_for_completion(struct completion * ) ;
extern int wait_for_completion_interruptible(struct completion * ) ;
extern void complete(struct completion * ) ;
extern unsigned long __msecs_to_jiffies(unsigned int const    ) ;
__inline static unsigned long msecs_to_jiffies(unsigned int const   m ) 
{ 
  unsigned long tmp___0 ;

  {
  tmp___0 = __msecs_to_jiffies(m);
  return (tmp___0);
}
}
extern void *ioremap_nocache(resource_size_t  , unsigned long  ) ;
extern void iounmap(void volatile   * ) ;
extern long schedule_timeout(long  ) ;
extern int wake_up_process(struct task_struct * ) ;
extern void kfree(void const   * ) ;
extern void *ldv_malloc(size_t);
void *__kmalloc(size_t size, gfp_t t)
{
	return ldv_malloc(size);
}
void *ldv_malloc(size_t size ) ;
__inline static void *kmalloc(size_t size , gfp_t flags ) 
{ 
  void *tmp___2 ;

  {
  tmp___2 = __kmalloc(size, flags);
  return (tmp___2);
}
}
void *ldv_zalloc(size_t size ) ;
__inline static void *kzalloc(size_t size , gfp_t flags ) 
{ 
  void *tmp ;

  {
  tmp = kmalloc(size, flags | 32768U);
  return (tmp);
}
}
int ldv_irq_1_2  =    0;
int LDV_IN_INTERRUPT  =    1;
int ldv_irq_1_3  =    0;
void *ldv_irq_data_1_1  ;
int ldv_irq_1_1  =    0;
int pci_counter  ;
    klee_make_symbolic(&pci_counter, sizeof(int), "pci_counter");
int ldv_irq_1_0  =    0;
int ldv_irq_line_1_3  ;
    klee_make_symbolic(&ldv_irq_line_1_3, sizeof(int), "ldv_irq_line_1_3");
void *ldv_irq_data_1_0  ;
int ldv_state_variable_0  ;
    klee_make_symbolic(&ldv_state_variable_0, sizeof(int), "ldv_state_variable_0");
int ldv_state_variable_3  ;
    klee_make_symbolic(&ldv_state_variable_3, sizeof(int), "ldv_state_variable_3");
int ldv_irq_line_1_0  ;
    klee_make_symbolic(&ldv_irq_line_1_0, sizeof(int), "ldv_irq_line_1_0");
int ldv_state_variable_2  ;
    klee_make_symbolic(&ldv_state_variable_2, sizeof(int), "ldv_state_variable_2");
void *ldv_irq_data_1_3  ;
struct Scsi_Host *rtsx_host_template_group1  ;
int ref_cnt  ;
    klee_make_symbolic(&ref_cnt, sizeof(int), "ref_cnt");
int ldv_irq_line_1_1  ;
    klee_make_symbolic(&ldv_irq_line_1_1, sizeof(int), "ldv_irq_line_1_1");
struct scsi_cmnd *rtsx_host_template_group0  ;
void *ldv_irq_data_1_2  ;
int ldv_state_variable_1  ;
    klee_make_symbolic(&ldv_state_variable_1, sizeof(int), "ldv_state_variable_1");
struct pci_dev *rtsx_driver_group1  ;
int ldv_irq_line_1_2  ;
    klee_make_symbolic(&ldv_irq_line_1_2, sizeof(int), "ldv_irq_line_1_2");
struct scsi_device *rtsx_host_template_group2  ;
int ldv_irq_1(int state , int line , void *data ) ;
void activate_suitable_irq_1(int line , void *data ) ;
int reg_check_1(irqreturn_t (*handler)(int  , void * ) ) ;
void ldv_pci_driver_2(void) ;
void choose_interrupt_1(void) ;
void ldv_initialize_scsi_host_template_3(void) ;
void disable_suitable_irq_1(int line , void *data ) ;
__inline static void *dev_get_drvdata(struct device  const  *dev ) 
{ 


  {
  return ((void *)dev->driver_data);
}
}
__inline static void dev_set_drvdata(struct device *dev , void *data ) 
{ 


  {
  dev->driver_data = data;
  return;
}
}
extern void dev_err(struct device  const  * , char const   *  , ...) ;
extern void _dev_info(struct device  const  * , char const   *  , ...) ;
extern void synchronize_irq(unsigned int  ) ;
extern void blk_queue_dma_alignment(struct request_queue * , int  ) ;
extern struct task_struct *kthread_create_on_node(int (*)(void * ) , void * , int  ,
                                                  char const   *  , ...) ;
extern int request_threaded_irq(unsigned int  , irqreturn_t (*)(int  , void * ) ,
                                irqreturn_t (*)(int  , void * ) , unsigned long  ,
                                char const   * , void * ) ;
__inline static int request_irq(unsigned int irq , irqreturn_t (*handler)(int  , void * ) ,
                                unsigned long flags , char const   *name , void *dev ) 
{ 
  int tmp ;

  {
  tmp = request_threaded_irq(irq, handler, (irqreturn_t (*)(int  , void * ))0, flags,
                             name, dev);
  return (tmp);
}
}
__inline static int ldv_request_irq_13(unsigned int irq , irqreturn_t (*handler)(int  ,
                                                                                 void * ) ,
                                       unsigned long flags , char const   *name ,
                                       void *dev ) ;
extern void free_irq(unsigned int  , void * ) ;
void ldv_free_irq_15(unsigned int ldv_func_arg1 , void *ldv_func_arg2 ) ;
void ldv_free_irq_21(unsigned int ldv_func_arg1 , void *ldv_func_arg2 ) ;
void ldv_free_irq_30(unsigned int ldv_func_arg1 , void *ldv_func_arg2 ) ;
extern struct pci_dev *pci_get_domain_bus_and_slot(int  , unsigned int  , unsigned int  ) ;
__inline static struct pci_dev *pci_get_bus_and_slot(unsigned int bus , unsigned int devfn ) 
{ 
  struct pci_dev *tmp ;

  {
  tmp = pci_get_domain_bus_and_slot(0, bus, devfn);
  return (tmp);
}
}
extern int pci_bus_read_config_byte(struct pci_bus * , unsigned int  , int  , u8 * ) ;
__inline static int pci_read_config_byte(struct pci_dev  const  *dev , int where ,
                                         u8 *val ) 
{ 
  int tmp ;

  {
  tmp = pci_bus_read_config_byte(dev->bus, dev->devfn, where, val);
  return (tmp);
}
}
extern int pci_enable_device(struct pci_dev * ) ;
extern void pci_disable_device(struct pci_dev * ) ;
extern void pci_set_master(struct pci_dev * ) ;
extern void pci_intx(struct pci_dev * , int  ) ;
extern int pci_save_state(struct pci_dev * ) ;
extern void pci_restore_state(struct pci_dev * ) ;
extern int pci_set_power_state(struct pci_dev * , pci_power_t  ) ;
extern pci_power_t pci_choose_state(struct pci_dev * , pm_message_t  ) ;
extern int __pci_enable_wake(struct pci_dev * , pci_power_t  , bool  , bool  ) ;
__inline static int pci_enable_wake(struct pci_dev *dev , pci_power_t state , bool enable ) 
{ 
  int tmp ;

  {
  tmp = __pci_enable_wake(dev, state, 0, (int )enable);
  return (tmp);
}
}
extern int pci_request_regions(struct pci_dev * , char const   * ) ;
extern void pci_release_regions(struct pci_dev * ) ;
extern int __pci_register_driver(struct pci_driver * , struct module * , char const   * ) ;
int ldv___pci_register_driver_37(struct pci_driver *ldv_func_arg1 , struct module *ldv_func_arg2 ,
                                 char const   *ldv_func_arg3 ) ;
extern void pci_unregister_driver(struct pci_driver * ) ;
void ldv_pci_unregister_driver_38(struct pci_driver *ldv_func_arg1 ) ;
extern void pci_disable_msi(struct pci_dev * ) ;
extern int pci_enable_msi_range(struct pci_dev * , int  , int  ) ;
__inline static int pci_enable_msi_exact(struct pci_dev *dev , int nvec ) 
{ 
  int rc ;
    klee_make_symbolic(&rc, sizeof(int), "rc");
  int tmp ;

  {
  tmp = pci_enable_msi_range(dev, nvec, nvec);
  rc = tmp;
  if (rc < 0) {
    return (rc);
  } else {

  }
  return (0);
}
}
extern void *dma_alloc_attrs(struct device * , size_t  , dma_addr_t * , gfp_t  , struct dma_attrs * ) ;
extern void dma_free_attrs(struct device * , size_t  , void * , dma_addr_t  , struct dma_attrs * ) ;
__inline static void *pci_get_drvdata(struct pci_dev *pdev ) 
{ 
  void *tmp ;

  {
  tmp = dev_get_drvdata((struct device  const  *)(& pdev->dev));
  return (tmp);
}
}
__inline static void pci_set_drvdata(struct pci_dev *pdev , void *data ) 
{ 


  {
  dev_set_drvdata(& pdev->dev, data);
  return;
}
}
extern struct Scsi_Host *scsi_host_alloc(struct scsi_host_template * , int  ) ;
struct Scsi_Host *ldv_scsi_host_alloc_36(struct scsi_host_template *sht , int privsize ) ;
extern int scsi_add_host_with_dma(struct Scsi_Host * , struct device * , struct device * ) ;
int ldv_scsi_add_host_with_dma_12(struct Scsi_Host *shost , struct device *dev , struct device *dma_dev ) ;
extern void scsi_scan_host(struct Scsi_Host * ) ;
extern void scsi_remove_host(struct Scsi_Host * ) ;
void ldv_scsi_remove_host_35(struct Scsi_Host *shost ) ;
extern void scsi_host_put(struct Scsi_Host * ) ;
extern void scsi_cmd_get_serial(struct Scsi_Host * , struct scsi_cmnd * ) ;
__inline static int scsi_add_host(struct Scsi_Host *host , struct device *dev ) 
{ 
  int tmp ;

  {
  tmp = ldv_scsi_add_host_with_dma_12(host, dev, dev);
  return (tmp);
}
}
__inline static struct Scsi_Host *rtsx_to_host(struct rtsx_dev *dev ) 
{ 
  unsigned long const   (*__mptr)[0U] ;

  {
  __mptr = (unsigned long const   *)dev;
  return ((struct Scsi_Host *)__mptr + 0xfffffffffffff118UL);
}
}
__inline static struct rtsx_dev *host_to_rtsx(struct Scsi_Host *host ) 
{ 


  {
  return ((struct rtsx_dev *)(& host->hostdata));
}
}
int rtsx_read_pci_cfg_byte(u8 bus , u8 dev , u8 func , u8 offset , u8 *val ) ;
int rtsx_init_chip(struct rtsx_chip *chip ) ;
void rtsx_release_chip(struct rtsx_chip *chip ) ;
void rtsx_polling_func(struct rtsx_chip *chip ) ;
int rtsx_write_register(struct rtsx_chip *chip , u16 addr , u8 mask , u8 data ) ;
int rtsx_pre_handle_interrupt(struct rtsx_chip *chip ) ;
void rtsx_do_before_power_down(struct rtsx_chip *chip , int pm_stat ) ;
void rtsx_invoke_transport(struct scsi_cmnd *srb , struct rtsx_chip *chip ) ;
void scsi_show_command(struct rtsx_chip *chip ) ;
void mspro_polling_format_status(struct rtsx_chip *chip ) ;
static unsigned int delay_use  =    1U;
static int ss_en  ;
static int ss_interval  =    50;
static int auto_delink_en  ;
static unsigned char aspm_l0s_l1_en  ;
    klee_make_symbolic(&aspm_l0s_l1_en, sizeof(char), "aspm_l0s_l1_en");
static int msi_en  ;
static irqreturn_t rtsx_interrupt(int irq , void *dev_id ) ;
static char const   *host_info(struct Scsi_Host *host ) 
{ 


  {
  return ("SCSI emulation for PCI-Express Mass Storage devices");
}
}
static int slave_alloc(struct scsi_device *sdev ) 
{ 


  {
  sdev->inquiry_len = 36U;
  return (0);
}
}
static int slave_configure(struct scsi_device *sdev ) 
{ 
  char tmp ;

  {
  blk_queue_dma_alignment(sdev->request_queue, 511);
  if ((int )((signed char )sdev->scsi_level) <= 2) {
    tmp = 3;
    (sdev->sdev_target)->scsi_level = tmp;
    sdev->scsi_level = tmp;
  } else {

  }
  return (0);
}
}
static int queuecommand_lck(struct scsi_cmnd *srb , void (*done)(struct scsi_cmnd * ) ) 
{ 
  struct rtsx_dev *dev ;
  struct rtsx_dev *tmp ;
  struct rtsx_chip *chip ;

  {
  tmp = host_to_rtsx((srb->device)->host);
  dev = tmp;
  chip = dev->chip;
  if ((unsigned long )chip->srb != (unsigned long )((struct scsi_cmnd *)0)) {
    dev_err((struct device  const  *)(& (dev->pci)->dev), "Error: chip->srb = %p\n",
            chip->srb);
    return (4181);
  } else {

  }
  if ((unsigned int )chip->rtsx_stat == 7U) {
    _dev_info((struct device  const  *)(& (dev->pci)->dev), "Fail command during disconnect\n");
    srb->result = 65536;
    (*done)(srb);
    return (0);
  } else {

  }
  srb->scsi_done = done;
  chip->srb = srb;
  complete(& dev->cmnd_ready);
  return (0);
}
}
static int queuecommand(struct Scsi_Host *shost , struct scsi_cmnd *cmd ) 
{ 
  unsigned long irq_flags ;
    klee_make_symbolic(&irq_flags, sizeof(long), "irq_flags");
  int rc ;
  raw_spinlock_t *tmp ;

  {
  tmp = spinlock_check(shost->host_lock);
  irq_flags = _raw_spin_lock_irqsave(tmp);
  scsi_cmd_get_serial(shost, cmd);
  rc = queuecommand_lck(cmd, cmd->scsi_done);
  spin_unlock_irqrestore(shost->host_lock, irq_flags);
  return (rc);
}
}
static int command_abort(struct scsi_cmnd *srb ) 
{ 
  struct Scsi_Host *host ;
  struct rtsx_dev *dev ;
  struct rtsx_dev *tmp ;
  struct rtsx_chip *chip ;

  {
  host = (srb->device)->host;
  tmp = host_to_rtsx(host);
  dev = tmp;
  chip = dev->chip;
  _dev_info((struct device  const  *)(& (dev->pci)->dev), "%s called\n", "command_abort");
  spin_lock_irq(host->host_lock);
  if ((unsigned long )chip->srb != (unsigned long )srb) {
    spin_unlock_irq(host->host_lock);
    _dev_info((struct device  const  *)(& (dev->pci)->dev), "-- nothing to abort\n");
    return (8195);
  } else {

  }
  chip->idle_counter = 0;
  chip->rtsx_stat = 6;
  spin_unlock_irq(host->host_lock);
  wait_for_completion(& dev->notify);
  return (8194);
}
}
static int device_reset(struct scsi_cmnd *srb ) 
{ 
  int result ;
  struct rtsx_dev *dev ;
  struct rtsx_dev *tmp ;

  {
  result = 0;
  tmp = host_to_rtsx((srb->device)->host);
  dev = tmp;
  _dev_info((struct device  const  *)(& (dev->pci)->dev), "%s called\n", "device_reset");
  return (result < 0 ? 8195 : 8194);
}
}
static int bus_reset(struct scsi_cmnd *srb ) 
{ 
  int result ;
  struct rtsx_dev *dev ;
  struct rtsx_dev *tmp ;

  {
  result = 0;
  tmp = host_to_rtsx((srb->device)->host);
  dev = tmp;
  _dev_info((struct device  const  *)(& (dev->pci)->dev), "%s called\n", "bus_reset");
  return (result < 0 ? 8195 : 8194);
}
}
static struct scsi_host_template rtsx_host_template  = 
     {& __this_module, "rts5208", 0, 0, & host_info, 0, 0, & queuecommand, & command_abort,
    & device_reset, 0, & bus_reset, 0, & slave_alloc, & slave_configure, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, "rts5208", 0, 1, -1, 128U, (unsigned short)0, 240U,
    0UL, (short)0, (unsigned char)0, 0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
    (unsigned char)0, 1U, 1U, 1U, (unsigned char)0, (unsigned char)0, 0U, 0, 0, {0,
                                                                                 0},
    0ULL, 0U, 0, (_Bool)0};
static int rtsx_acquire_irq(struct rtsx_dev *dev ) 
{ 
  struct rtsx_chip *chip ;
  int tmp ;

  {
  chip = dev->chip;
  _dev_info((struct device  const  *)(& (dev->pci)->dev), "%s: chip->msi_en = %d, pci->irq = %d\n",
            "rtsx_acquire_irq", chip->msi_en, (dev->pci)->irq);
  tmp = ldv_request_irq_13((dev->pci)->irq, & rtsx_interrupt, chip->msi_en != 0 ? 0UL : 128UL,
                           "rts5208", (void *)dev);
  if (tmp != 0) {
    dev_err((struct device  const  *)(& (dev->pci)->dev), "rtsx: unable to grab IRQ %d, disabling device\n",
            (dev->pci)->irq);
    return (-1);
  } else {

  }
  dev->irq = (int )(dev->pci)->irq;
  pci_intx(dev->pci, chip->msi_en == 0);
  return (0);
}
}
int rtsx_read_pci_cfg_byte(u8 bus , u8 dev , u8 func , u8 offset , u8 *val ) 
{ 
  struct pci_dev *pdev ;
  u8 data ;
  u8 devfn ;

  {
  devfn = (u8 )((int )((signed char )((int )dev << 3)) | (int )((signed char )func));
  pdev = pci_get_bus_and_slot((unsigned int )bus, (unsigned int )devfn);
  if ((unsigned long )pdev == (unsigned long )((struct pci_dev *)0)) {
    return (-1);
  } else {

  }
  pci_read_config_byte((struct pci_dev  const  *)pdev, (int )offset, & data);
  if ((unsigned long )val != (unsigned long )((u8 *)0U)) {
    *val = data;
  } else {

  }
  return (0);
}
}
static int rtsx_suspend(struct pci_dev *pci , pm_message_t state ) 
{ 
  struct rtsx_dev *dev ;
  void *tmp ;
  struct rtsx_chip *chip ;
  pci_power_t tmp___0 ;
  pci_power_t tmp___1 ;

  {
  tmp = pci_get_drvdata(pci);
  dev = (struct rtsx_dev *)tmp;
  if ((unsigned long )dev == (unsigned long )((struct rtsx_dev *)0)) {
    return (0);
  } else {

  }
  ldv_mutex_lock_14(& dev->dev_mutex);
  chip = dev->chip;
  rtsx_do_before_power_down(chip, 3);
  if (dev->irq >= 0) {
    synchronize_irq((unsigned int )dev->irq);
    ldv_free_irq_15((unsigned int )dev->irq, (void *)dev);
    dev->irq = -1;
  } else {

  }
  if (chip->msi_en != 0) {
    pci_disable_msi(pci);
  } else {

  }
  pci_save_state(pci);
  tmp___0 = pci_choose_state(pci, state);
  pci_enable_wake(pci, tmp___0, 1);
  pci_disable_device(pci);
  tmp___1 = pci_choose_state(pci, state);
  pci_set_power_state(pci, tmp___1);
  ldv_mutex_unlock_16(& dev->dev_mutex);
  return (0);
}
}
static int rtsx_resume(struct pci_dev *pci ) 
{ 
  struct rtsx_dev *dev ;
  void *tmp ;
  struct rtsx_chip *chip ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  tmp = pci_get_drvdata(pci);
  dev = (struct rtsx_dev *)tmp;
  if ((unsigned long )dev == (unsigned long )((struct rtsx_dev *)0)) {
    return (0);
  } else {

  }
  chip = dev->chip;
  ldv_mutex_lock_17(& dev->dev_mutex);
  pci_set_power_state(pci, 0);
  pci_restore_state(pci);
  tmp___0 = pci_enable_device(pci);
  if (tmp___0 < 0) {
    dev_err((struct device  const  *)(& (dev->pci)->dev), "%s: pci_enable_device failed, disabling device\n",
            (char *)"rts5208");
    ldv_mutex_unlock_18(& dev->dev_mutex);
    return (-5);
  } else {

  }
  pci_set_master(pci);
  if (chip->msi_en != 0) {
    tmp___1 = pci_enable_msi_exact(pci, 1);
    if (tmp___1 < 0) {
      chip->msi_en = 0;
    } else {

    }
  } else {

  }
  tmp___2 = rtsx_acquire_irq(dev);
  if (tmp___2 < 0) {
    ldv_mutex_unlock_19(& dev->dev_mutex);
    return (-5);
  } else {

  }
  rtsx_write_register(chip, 65120, 3, 0);
  rtsx_init_chip(chip);
  ldv_mutex_unlock_20(& dev->dev_mutex);
  return (0);
}
}
static void rtsx_shutdown(struct pci_dev *pci ) 
{ 
  struct rtsx_dev *dev ;
  void *tmp ;
  struct rtsx_chip *chip ;

  {
  tmp = pci_get_drvdata(pci);
  dev = (struct rtsx_dev *)tmp;
  if ((unsigned long )dev == (unsigned long )((struct rtsx_dev *)0)) {
    return;
  } else {

  }
  chip = dev->chip;
  rtsx_do_before_power_down(chip, 1);
  if (dev->irq >= 0) {
    synchronize_irq((unsigned int )dev->irq);
    ldv_free_irq_21((unsigned int )dev->irq, (void *)dev);
    dev->irq = -1;
  } else {

  }
  if (chip->msi_en != 0) {
    pci_disable_msi(pci);
  } else {

  }
  pci_disable_device(pci);
  return;
}
}
static int rtsx_control_thread(void *__dev ) 
{ 
  struct rtsx_dev *dev ;
  struct rtsx_chip *chip ;
  struct Scsi_Host *host ;
  struct Scsi_Host *tmp ;
  int tmp___0 ;

  {
  dev = (struct rtsx_dev *)__dev;
  chip = dev->chip;
  tmp = rtsx_to_host(dev);
  host = tmp;
  ldv_38693: 
  tmp___0 = wait_for_completion_interruptible(& dev->cmnd_ready);
  if (tmp___0 != 0) {
    goto ldv_38691;
  } else {

  }
  ldv_mutex_lock_22(& dev->dev_mutex);
  if ((unsigned int )chip->rtsx_stat == 7U) {
    _dev_info((struct device  const  *)(& (dev->pci)->dev), "-- rtsx-control exiting\n");
    ldv_mutex_unlock_23(& dev->dev_mutex);
    goto ldv_38691;
  } else {

  }
  spin_lock_irq(host->host_lock);
  if ((unsigned int )chip->rtsx_stat == 6U) {
    (chip->srb)->result = 327680;
    goto SkipForAbort;
  } else {

  }
  spin_unlock_irq(host->host_lock);
  if ((unsigned int )(chip->srb)->sc_data_direction == 0U) {
    dev_err((struct device  const  *)(& (dev->pci)->dev), "UNKNOWN data direction\n");
    (chip->srb)->result = 458752;
  } else
  if (((chip->srb)->device)->id != 0U) {
    dev_err((struct device  const  *)(& (dev->pci)->dev), "Bad target number (%d:%d)\n",
            ((chip->srb)->device)->id, (int )((unsigned char )((chip->srb)->device)->lun));
    (chip->srb)->result = 262144;
  } else
  if (((chip->srb)->device)->lun > (u64 )chip->max_lun) {
    dev_err((struct device  const  *)(& (dev->pci)->dev), "Bad LUN (%d:%d)\n", ((chip->srb)->device)->id,
            (int )((unsigned char )((chip->srb)->device)->lun));
    (chip->srb)->result = 262144;
  } else {
    scsi_show_command(chip);
    rtsx_invoke_transport(chip->srb, chip);
  }
  spin_lock_irq(host->host_lock);
  if ((unsigned long )chip->srb == (unsigned long )((struct scsi_cmnd *)0)) {

  } else
  if ((chip->srb)->result != 327680) {
    (*((chip->srb)->scsi_done))(chip->srb);
  } else {
    SkipForAbort: 
    dev_err((struct device  const  *)(& (dev->pci)->dev), "scsi command aborted\n");
  }
  if ((unsigned int )chip->rtsx_stat == 6U) {
    complete(& dev->notify);
    chip->rtsx_stat = 1;
  } else {

  }
  chip->srb = (struct scsi_cmnd *)0;
  spin_unlock_irq(host->host_lock);
  ldv_mutex_unlock_24(& dev->dev_mutex);
  goto ldv_38693;
  ldv_38691: 
  complete_and_exit(& dev->control_exit, 0L);
  return (0);
}
}
static int rtsx_polling_thread(void *__dev ) 
{ 
  struct rtsx_dev *dev ;
  struct rtsx_chip *chip ;
  struct sd_info *sd_card ;
  struct xd_info *xd_card ;
  struct ms_info *ms_card ;
  struct task_struct *tmp ;
  long volatile   __ret ;
  struct task_struct *tmp___0 ;
  struct task_struct *tmp___1 ;
  struct task_struct *tmp___2 ;
  struct task_struct *tmp___3 ;
  struct task_struct *tmp___4 ;
  long volatile   __ret___0 ;
  struct task_struct *tmp___5 ;
  struct task_struct *tmp___6 ;
  struct task_struct *tmp___7 ;
  struct task_struct *tmp___8 ;
  unsigned long tmp___9 ;
    klee_make_symbolic(&tmp___9, sizeof(long), "tmp___9");

  {
  dev = (struct rtsx_dev *)__dev;
  chip = dev->chip;
  sd_card = & chip->sd_card;
  xd_card = & chip->xd_card;
  ms_card = & chip->ms_card;
  sd_card->cleanup_counter = 0;
  xd_card->cleanup_counter = 0;
  ms_card->cleanup_counter = 0;
  tmp = get_current();
  tmp->task_state_change = 0UL;
  __ret = 1L;
  switch (8UL) {
  case 1UL: 
  tmp___0 = get_current();
  __asm__  volatile   ("xchgb %b0, %1\n": "+q" (__ret), "+m" (tmp___0->state): : "memory",
                       "cc");
  goto ldv_38704;
  case 2UL: 
  tmp___1 = get_current();
  __asm__  volatile   ("xchgw %w0, %1\n": "+r" (__ret), "+m" (tmp___1->state): : "memory",
                       "cc");
  goto ldv_38704;
  case 4UL: 
  tmp___2 = get_current();
  __asm__  volatile   ("xchgl %0, %1\n": "+r" (__ret), "+m" (tmp___2->state): : "memory",
                       "cc");
  goto ldv_38704;
  case 8UL: 
  tmp___3 = get_current();
  __asm__  volatile   ("xchgq %q0, %1\n": "+r" (__ret), "+m" (tmp___3->state): : "memory",
                       "cc");
  goto ldv_38704;
  default: 
  __xchg_wrong_size();
  }
  ldv_38704: 
  schedule_timeout((long )((delay_use * 250000U + 1250000U) / 1000U));
  ldv_38719: 
  tmp___4 = get_current();
  tmp___4->task_state_change = 0UL;
  __ret___0 = 1L;
  switch (8UL) {
  case 1UL: 
  tmp___5 = get_current();
  __asm__  volatile   ("xchgb %b0, %1\n": "+q" (__ret___0), "+m" (tmp___5->state): : "memory",
                       "cc");
  goto ldv_38712;
  case 2UL: 
  tmp___6 = get_current();
  __asm__  volatile   ("xchgw %w0, %1\n": "+r" (__ret___0), "+m" (tmp___6->state): : "memory",
                       "cc");
  goto ldv_38712;
  case 4UL: 
  tmp___7 = get_current();
  __asm__  volatile   ("xchgl %0, %1\n": "+r" (__ret___0), "+m" (tmp___7->state): : "memory",
                       "cc");
  goto ldv_38712;
  case 8UL: 
  tmp___8 = get_current();
  __asm__  volatile   ("xchgq %q0, %1\n": "+r" (__ret___0), "+m" (tmp___8->state): : "memory",
                       "cc");
  goto ldv_38712;
  default: 
  __xchg_wrong_size();
  }
  ldv_38712: 
  tmp___9 = msecs_to_jiffies(30U);
  schedule_timeout((long )tmp___9);
  ldv_mutex_lock_25(& dev->dev_mutex);
  if ((unsigned int )chip->rtsx_stat == 7U) {
    _dev_info((struct device  const  *)(& (dev->pci)->dev), "-- rtsx-polling exiting\n");
    ldv_mutex_unlock_26(& dev->dev_mutex);
    goto ldv_38718;
  } else {

  }
  ldv_mutex_unlock_27(& dev->dev_mutex);
  mspro_polling_format_status(chip);
  ldv_mutex_lock_28(& dev->dev_mutex);
  rtsx_polling_func(chip);
  ldv_mutex_unlock_29(& dev->dev_mutex);
  goto ldv_38719;
  ldv_38718: 
  complete_and_exit(& dev->polling_exit, 0L);
  return (0);
}
}
static irqreturn_t rtsx_interrupt(int irq , void *dev_id ) 
{ 
  struct rtsx_dev *dev ;
  struct rtsx_chip *chip ;
  int retval ;
    klee_make_symbolic(&retval, sizeof(int), "retval");
  u32 status ;

  {
  dev = (struct rtsx_dev *)dev_id;
  if ((unsigned long )dev != (unsigned long )((struct rtsx_dev *)0)) {
    chip = dev->chip;
  } else {
    return (0);
  }
  if ((unsigned long )chip == (unsigned long )((struct rtsx_chip *)0)) {
    return (0);
  } else {

  }
  spin_lock(& dev->reg_lock);
  retval = rtsx_pre_handle_interrupt(chip);
  if (retval == 1) {
    spin_unlock(& dev->reg_lock);
    if (chip->int_reg == 4294967295U) {
      return (1);
    } else {

    }
    return (0);
  } else {

  }
  status = chip->int_reg;
  if (dev->check_card_cd != 0U) {
    if ((dev->check_card_cd & status) == 0U) {
      dev->trans_result = 2;
      if ((unsigned long )dev->done != (unsigned long )((struct completion *)0)) {
        complete(dev->done);
      } else {

      }
      goto Exit;
    } else {

    }
  } else {

  }
  if ((status & 1895825408U) != 0U) {
    if ((status & 285212672U) != 0U) {
      if ((status & 16777216U) != 0U) {
        chip->rtsx_flag = (u8 )((unsigned int )chip->rtsx_flag | 1U);
      } else {

      }
      dev->trans_result = 2;
      if ((unsigned long )dev->done != (unsigned long )((struct completion *)0)) {
        complete(dev->done);
      } else {

      }
    } else
    if ((status & 536870912U) != 0U) {
      dev->trans_result = 1;
      if ((unsigned long )dev->done != (unsigned long )((struct completion *)0)) {
        complete(dev->done);
      } else {

      }
    } else
    if ((status & 1073741824U) != 0U) {
      dev->trans_result = 0;
      if ((unsigned long )dev->done != (unsigned long )((struct completion *)0) && (int )((signed char )dev->trans_state) == 3) {
        complete(dev->done);
      } else {

      }
    } else {

    }
  } else {

  }
  Exit: 
  spin_unlock(& dev->reg_lock);
  return (1);
}
}
static void rtsx_release_resources(struct rtsx_dev *dev ) 
{ 
  struct task_struct *tmp ;
  long volatile   __ret ;
  struct task_struct *tmp___0 ;
  struct task_struct *tmp___1 ;
  struct task_struct *tmp___2 ;
  struct task_struct *tmp___3 ;

  {
  _dev_info((struct device  const  *)(& (dev->pci)->dev), "-- %s\n", "rtsx_release_resources");
  _dev_info((struct device  const  *)(& (dev->pci)->dev), "-- sending exit command to thread\n");
  complete(& dev->cmnd_ready);
  if ((unsigned long )dev->ctl_thread != (unsigned long )((struct task_struct *)0)) {
    wait_for_completion(& dev->control_exit);
  } else {

  }
  if ((unsigned long )dev->polling_thread != (unsigned long )((struct task_struct *)0)) {
    wait_for_completion(& dev->polling_exit);
  } else {

  }
  tmp = get_current();
  tmp->task_state_change = 0UL;
  __ret = 1L;
  switch (8UL) {
  case 1UL: 
  tmp___0 = get_current();
  __asm__  volatile   ("xchgb %b0, %1\n": "+q" (__ret), "+m" (tmp___0->state): : "memory",
                       "cc");
  goto ldv_38735;
  case 2UL: 
  tmp___1 = get_current();
  __asm__  volatile   ("xchgw %w0, %1\n": "+r" (__ret), "+m" (tmp___1->state): : "memory",
                       "cc");
  goto ldv_38735;
  case 4UL: 
  tmp___2 = get_current();
  __asm__  volatile   ("xchgl %0, %1\n": "+r" (__ret), "+m" (tmp___2->state): : "memory",
                       "cc");
  goto ldv_38735;
  case 8UL: 
  tmp___3 = get_current();
  __asm__  volatile   ("xchgq %q0, %1\n": "+r" (__ret), "+m" (tmp___3->state): : "memory",
                       "cc");
  goto ldv_38735;
  default: 
  __xchg_wrong_size();
  }
  ldv_38735: 
  schedule_timeout(50L);
  if ((unsigned long )dev->rtsx_resv_buf != (unsigned long )((void *)0)) {
    dma_free_attrs(& (dev->pci)->dev, 4096UL, dev->rtsx_resv_buf, dev->rtsx_resv_buf_addr,
                   (struct dma_attrs *)0);
    (dev->chip)->host_cmds_ptr = (void *)0;
    (dev->chip)->host_sg_tbl_ptr = (void *)0;
  } else {

  }
  if (dev->irq > 0) {
    ldv_free_irq_30((unsigned int )dev->irq, (void *)dev);
  } else {

  }
  if ((dev->chip)->msi_en != 0) {
    pci_disable_msi(dev->pci);
  } else {

  }
  if ((unsigned long )dev->remap_addr != (unsigned long )((void *)0)) {
    iounmap((void volatile   *)dev->remap_addr);
  } else {

  }
  pci_disable_device(dev->pci);
  pci_release_regions(dev->pci);
  rtsx_release_chip(dev->chip);
  kfree((void const   *)dev->chip);
  return;
}
}
static void quiesce_and_remove_host(struct rtsx_dev *dev ) 
{ 
  struct Scsi_Host *host ;
  struct Scsi_Host *tmp ;
  struct rtsx_chip *chip ;
  struct task_struct *tmp___0 ;
  long volatile   __ret ;
  struct task_struct *tmp___1 ;
  struct task_struct *tmp___2 ;
  struct task_struct *tmp___3 ;
  struct task_struct *tmp___4 ;

  {
  tmp = rtsx_to_host(dev);
  host = tmp;
  chip = dev->chip;
  ldv_mutex_lock_31(& dev->dev_mutex);
  spin_lock_irq(host->host_lock);
  chip->idle_counter = 0;
  chip->rtsx_stat = 7;
  spin_unlock_irq(host->host_lock);
  ldv_mutex_unlock_32(& dev->dev_mutex);
  __wake_up(& dev->delay_wait, 3U, 1, (void *)0);
  wait_for_completion(& dev->scanning_done);
  tmp___0 = get_current();
  tmp___0->task_state_change = 0UL;
  __ret = 1L;
  switch (8UL) {
  case 1UL: 
  tmp___1 = get_current();
  __asm__  volatile   ("xchgb %b0, %1\n": "+q" (__ret), "+m" (tmp___1->state): : "memory",
                       "cc");
  goto ldv_38748;
  case 2UL: 
  tmp___2 = get_current();
  __asm__  volatile   ("xchgw %w0, %1\n": "+r" (__ret), "+m" (tmp___2->state): : "memory",
                       "cc");
  goto ldv_38748;
  case 4UL: 
  tmp___3 = get_current();
  __asm__  volatile   ("xchgl %0, %1\n": "+r" (__ret), "+m" (tmp___3->state): : "memory",
                       "cc");
  goto ldv_38748;
  case 8UL: 
  tmp___4 = get_current();
  __asm__  volatile   ("xchgq %q0, %1\n": "+r" (__ret), "+m" (tmp___4->state): : "memory",
                       "cc");
  goto ldv_38748;
  default: 
  __xchg_wrong_size();
  }
  ldv_38748: 
  schedule_timeout(25L);
  ldv_mutex_lock_33(& dev->dev_mutex);
  if ((unsigned long )chip->srb != (unsigned long )((struct scsi_cmnd *)0)) {
    (chip->srb)->result = 65536;
    spin_lock_irq(host->host_lock);
    (*((chip->srb)->scsi_done))((dev->chip)->srb);
    chip->srb = (struct scsi_cmnd *)0;
    spin_unlock_irq(host->host_lock);
  } else {

  }
  ldv_mutex_unlock_34(& dev->dev_mutex);
  ldv_scsi_remove_host_35(host);
  return;
}
}
static void release_everything(struct rtsx_dev *dev ) 
{ 
  struct Scsi_Host *tmp ;

  {
  rtsx_release_resources(dev);
  tmp = rtsx_to_host(dev);
  scsi_host_put(tmp);
  return;
}
}
static int rtsx_scan_thread(void *__dev ) 
{ 
  struct rtsx_dev *dev ;
  struct rtsx_chip *chip ;
  long __ret ;
    klee_make_symbolic(&__ret, sizeof(long), "__ret");
  wait_queue_t __wait ;
  long __ret___0 ;
    klee_make_symbolic(&__ret___0, sizeof(long), "__ret___0");
  long __int ;
    klee_make_symbolic(&__int, sizeof(long), "__int");
  long tmp ;
    klee_make_symbolic(&tmp, sizeof(long), "tmp");
  bool __cond ;
  bool __cond___0 ;
  struct Scsi_Host *tmp___0 ;

  {
  dev = (struct rtsx_dev *)__dev;
  chip = dev->chip;
  if (delay_use != 0U) {
    _dev_info((struct device  const  *)(& (dev->pci)->dev), "%s: waiting for device to settle before scanning\n",
              (char *)"rts5208");
    __ret = (long )(delay_use * 250U);
    __might_sleep("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx.c",
                  730, 0);
    __cond___0 = (unsigned int )chip->rtsx_stat == 7U;
    if ((int )__cond___0 && __ret == 0L) {
      __ret = 1L;
    } else {

    }
    if (((int )__cond___0 || __ret == 0L) == 0) {
      __ret___0 = (long )(delay_use * 250U);
      INIT_LIST_HEAD(& __wait.task_list);
      __wait.flags = 0U;
      ldv_38772: 
      tmp = prepare_to_wait_event(& dev->delay_wait, & __wait, 1);
      __int = tmp;
      __cond = (unsigned int )chip->rtsx_stat == 7U;
      if ((int )__cond && __ret___0 == 0L) {
        __ret___0 = 1L;
      } else {

      }
      if (((int )__cond || __ret___0 == 0L) != 0) {
        goto ldv_38771;
      } else {

      }
      if (__int != 0L) {
        __ret___0 = __int;
        goto ldv_38771;
      } else {

      }
      __ret___0 = schedule_timeout(__ret___0);
      goto ldv_38772;
      ldv_38771: 
      finish_wait(& dev->delay_wait, & __wait);
      __ret = __ret___0;
    } else {

    }
  } else {

  }
  if ((unsigned int )chip->rtsx_stat != 7U) {
    tmp___0 = rtsx_to_host(dev);
    scsi_scan_host(tmp___0);
    _dev_info((struct device  const  *)(& (dev->pci)->dev), "%s: device scan complete\n",
              (char *)"rts5208");
  } else {

  }
  complete_and_exit(& dev->scanning_done, 0L);
  return (0);
}
}
static void rtsx_init_options(struct rtsx_chip *chip ) 
{ 


  {
  chip->vendor_id = ((chip->rtsx)->pci)->vendor;
  chip->product_id = ((chip->rtsx)->pci)->device;
  chip->adma_mode = 1;
  chip->lun_mc = 0U;
  chip->driver_first_load = 1;
  chip->sdio_in_charge = 0;
  chip->mspro_formatter_enable = 1;
  chip->ignore_sd = 0;
  chip->use_hw_setting = 0;
  chip->lun_mode = 0U;
  chip->auto_delink_en = auto_delink_en;
  chip->ss_en = ss_en;
  chip->ss_idle_period = ss_interval * 1000;
  chip->remote_wakeup_en = 0;
  chip->aspm_l0s_l1_en = aspm_l0s_l1_en;
  chip->dynamic_aspm = 1;
  chip->fpga_sd_sdr104_clk = 10;
  chip->fpga_sd_ddr50_clk = 7;
  chip->fpga_sd_sdr50_clk = 7;
  chip->fpga_sd_hs_clk = 7;
  chip->fpga_mmc_52m_clk = 6;
  chip->fpga_ms_hg_clk = 6;
  chip->fpga_ms_4bit_clk = 6;
  chip->fpga_ms_1bit_clk = 3;
  chip->asic_sd_sdr104_clk = 203;
  chip->asic_sd_sdr50_clk = 98;
  chip->asic_sd_ddr50_clk = 98;
  chip->asic_sd_hs_clk = 98;
  chip->asic_mmc_52m_clk = 98;
  chip->asic_ms_hg_clk = 117;
  chip->asic_ms_4bit_clk = 78;
  chip->asic_ms_1bit_clk = 39;
  chip->ssc_depth_sd_sdr104 = 2U;
  chip->ssc_depth_sd_sdr50 = 2U;
  chip->ssc_depth_sd_ddr50 = 3U;
  chip->ssc_depth_sd_hs = 3U;
  chip->ssc_depth_mmc_52m = 3U;
  chip->ssc_depth_ms_hg = 3U;
  chip->ssc_depth_ms_4bit = 4U;
  chip->ssc_depth_low_speed = 4U;
  chip->ssc_en = 1;
  chip->sd_speed_prior = 17039875U;
  chip->sd_current_prior = 66051U;
  chip->sd_ctl = 74U;
  chip->sd_ddr_tx_phase = 0;
  chip->mmc_ddr_tx_phase = 1;
  chip->sd_default_tx_phase = 15;
  chip->sd_default_rx_phase = 15;
  chip->pmos_pwr_on_interval = 200;
  chip->sd_voltage_switch_delay = 1000;
  chip->ms_power_class_en = 3U;
  chip->sd_400mA_ocp_thd = 1U;
  chip->sd_800mA_ocp_thd = 5U;
  chip->ms_ocp_thd = 2U;
  chip->card_drive_sel = 85U;
  chip->sd30_drive_sel_1v8 = 3U;
  chip->sd30_drive_sel_3v3 = 1U;
  chip->do_delink_before_power_down = 1;
  chip->auto_power_down = 1;
  chip->polling_config = 0;
  chip->force_clkreq_0 = 1;
  chip->ft2_fast_mode = 0;
  chip->sdio_retry_cnt = 1;
  chip->xd_timeout = 2000;
  chip->sd_timeout = 10000;
  chip->ms_timeout = 2000;
  chip->mspro_timeout = 15000;
  chip->power_down_in_ss = 1;
  chip->sdr104_en = 1;
  chip->sdr50_en = 1;
  chip->ddr50_en = 1;
  chip->delink_stage1_step = 100;
  chip->delink_stage2_step = 40;
  chip->delink_stage3_step = 20;
  chip->auto_delink_in_L1 = 1;
  chip->blink_led = 1U;
  chip->msi_en = msi_en;
  chip->hp_watch_bios_hotplug = 0;
  chip->max_payload = 0U;
  chip->phy_voltage = 0U;
  chip->support_ms_8bit = 1;
  chip->s3_pwr_off_delay = 1000;
  return;
}
}
static int rtsx_probe(struct pci_dev *pci , struct pci_device_id  const  *pci_id ) 
{ 
  struct Scsi_Host *host ;
  struct rtsx_dev *dev ;
  int err ;
    klee_make_symbolic(&err, sizeof(int), "err");
  struct task_struct *th ;
  struct _ddebug descriptor ;
  long tmp ;
  void *tmp___0 ;
  struct lock_class_key __key ;
  struct lock_class_key __key___0 ;
  struct lock_class_key __key___1 ;
  int tmp___1 ;
  int tmp___2 ;
  struct task_struct *__k ;
  struct task_struct *tmp___3 ;
  bool tmp___4 ;
  int tmp___5 ;
    klee_make_symbolic(&tmp___5, sizeof(int), "tmp___5");
  long tmp___6 ;
    klee_make_symbolic(&tmp___6, sizeof(long), "tmp___6");
  bool tmp___7 ;
  struct task_struct *__k___0 ;
  struct task_struct *tmp___8 ;
  bool tmp___9 ;
  int tmp___10 ;
    klee_make_symbolic(&tmp___10, sizeof(int), "tmp___10");
  long tmp___11 ;
    klee_make_symbolic(&tmp___11, sizeof(long), "tmp___11");
  bool tmp___12 ;
  struct task_struct *__k___1 ;
  struct task_struct *tmp___13 ;
  bool tmp___14 ;
  int tmp___15 ;
    klee_make_symbolic(&tmp___15, sizeof(int), "tmp___15");
  long tmp___16 ;
    klee_make_symbolic(&tmp___16, sizeof(long), "tmp___16");
  bool tmp___17 ;

  {
  err = 0;
  descriptor.modname = "rts5208";
  descriptor.function = "rtsx_probe";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx.c";
  descriptor.format = "Realtek PCI-E card reader detected\n";
  descriptor.lineno = 855U;
  descriptor.flags = 0U;
  tmp = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp != 0L) {
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)(& pci->dev), "Realtek PCI-E card reader detected\n");
  } else {

  }
  err = pci_enable_device(pci);
  if (err < 0) {
    dev_err((struct device  const  *)(& pci->dev), "PCI enable device failed!\n");
    return (err);
  } else {

  }
  err = pci_request_regions(pci, "rts5208");
  if (err < 0) {
    dev_err((struct device  const  *)(& pci->dev), "PCI request regions for %s failed!\n",
            (char *)"rts5208");
    pci_disable_device(pci);
    return (err);
  } else {

  }
  host = ldv_scsi_host_alloc_36(& rtsx_host_template, 896);
  if ((unsigned long )host == (unsigned long )((struct Scsi_Host *)0)) {
    dev_err((struct device  const  *)(& pci->dev), "Unable to allocate the scsi host\n");
    pci_release_regions(pci);
    pci_disable_device(pci);
    return (-12);
  } else {

  }
  dev = host_to_rtsx(host);
  memset((void *)dev, 0, 896UL);
  tmp___0 = kzalloc(8712UL, 208U);
  dev->chip = (struct rtsx_chip *)tmp___0;
  if ((unsigned long )dev->chip == (unsigned long )((struct rtsx_chip *)0)) {
    err = -12;
    goto errout;
  } else {

  }
  spinlock_check(& dev->reg_lock);
  __raw_spin_lock_init(& dev->reg_lock.__annonCompField17.rlock, "&(&dev->reg_lock)->rlock",
                       & __key);
  __mutex_init(& dev->dev_mutex, "&(dev->dev_mutex)", & __key___0);
  init_completion(& dev->cmnd_ready);
  init_completion(& dev->control_exit);
  init_completion(& dev->polling_exit);
  init_completion(& dev->notify);
  init_completion(& dev->scanning_done);
  __init_waitqueue_head(& dev->delay_wait, "&dev->delay_wait", & __key___1);
  dev->pci = pci;
  dev->irq = -1;
  _dev_info((struct device  const  *)(& pci->dev), "Resource length: 0x%x\n", pci->resource[0].start != 0ULL || pci->resource[0].end != pci->resource[0].start ? (unsigned int )((pci->resource[0].end - pci->resource[0].start) + 1ULL) : 0U);
  dev->addr = (unsigned long )pci->resource[0].start;
  dev->remap_addr = ioremap_nocache((resource_size_t )dev->addr, pci->resource[0].start != 0ULL || pci->resource[0].end != pci->resource[0].start ? (unsigned long )((pci->resource[0].end - pci->resource[0].start) + 1ULL) : 0UL);
  if ((unsigned long )dev->remap_addr == (unsigned long )((void *)0)) {
    dev_err((struct device  const  *)(& pci->dev), "ioremap error\n");
    err = -6;
    goto errout;
  } else {

  }
  _dev_info((struct device  const  *)(& pci->dev), "Original address: 0x%lx, remapped address: 0x%lx\n",
            dev->addr, (unsigned long )dev->remap_addr);
  dev->rtsx_resv_buf = dma_alloc_attrs(& pci->dev, 4096UL, & dev->rtsx_resv_buf_addr,
                                       208U, (struct dma_attrs *)0);
  if ((unsigned long )dev->rtsx_resv_buf == (unsigned long )((void *)0)) {
    dev_err((struct device  const  *)(& pci->dev), "alloc dma buffer fail\n");
    err = -6;
    goto errout;
  } else {

  }
  (dev->chip)->host_cmds_ptr = dev->rtsx_resv_buf;
  (dev->chip)->host_cmds_addr = dev->rtsx_resv_buf_addr;
  (dev->chip)->host_sg_tbl_ptr = dev->rtsx_resv_buf + 1024UL;
  (dev->chip)->host_sg_tbl_addr = dev->rtsx_resv_buf_addr + 1024ULL;
  (dev->chip)->rtsx = dev;
  rtsx_init_options(dev->chip);
  _dev_info((struct device  const  *)(& pci->dev), "pci->irq = %d\n", pci->irq);
  if ((dev->chip)->msi_en != 0) {
    tmp___1 = pci_enable_msi_exact(pci, 1);
    if (tmp___1 < 0) {
      (dev->chip)->msi_en = 0;
    } else {

    }
  } else {

  }
  tmp___2 = rtsx_acquire_irq(dev);
  if (tmp___2 < 0) {
    err = -16;
    goto errout;
  } else {

  }
  pci_set_master(pci);
  synchronize_irq((unsigned int )dev->irq);
  rtsx_init_chip(dev->chip);
  host->max_id = 1U;
  host->max_lun = (u64 )(dev->chip)->max_lun;
  tmp___3 = kthread_create_on_node(& rtsx_control_thread, (void *)dev, -1, "rts5208");
  __k = tmp___3;
  tmp___4 = IS_ERR((void const   *)__k);
  if (tmp___4) {
    tmp___5 = 0;
  } else {
    tmp___5 = 1;
  }
  if (tmp___5) {
    wake_up_process(__k);
  } else {

  }
  th = __k;
  tmp___7 = IS_ERR((void const   *)th);
  if ((int )tmp___7) {
    dev_err((struct device  const  *)(& pci->dev), "Unable to start control thread\n");
    tmp___6 = PTR_ERR((void const   *)th);
    err = (int )tmp___6;
    goto errout;
  } else {

  }
  dev->ctl_thread = th;
  err = scsi_add_host(host, & pci->dev);
  if (err != 0) {
    dev_err((struct device  const  *)(& pci->dev), "Unable to add the scsi host\n");
    goto errout;
  } else {

  }
  tmp___8 = kthread_create_on_node(& rtsx_scan_thread, (void *)dev, -1, "rtsx-scan");
  __k___0 = tmp___8;
  tmp___9 = IS_ERR((void const   *)__k___0);
  if (tmp___9) {
    tmp___10 = 0;
  } else {
    tmp___10 = 1;
  }
  if (tmp___10) {
    wake_up_process(__k___0);
  } else {

  }
  th = __k___0;
  tmp___12 = IS_ERR((void const   *)th);
  if ((int )tmp___12) {
    dev_err((struct device  const  *)(& pci->dev), "Unable to start the device-scanning thread\n");
    complete(& dev->scanning_done);
    quiesce_and_remove_host(dev);
    tmp___11 = PTR_ERR((void const   *)th);
    err = (int )tmp___11;
    goto errout;
  } else {

  }
  tmp___13 = kthread_create_on_node(& rtsx_polling_thread, (void *)dev, -1, "rtsx-polling");
  __k___1 = tmp___13;
  tmp___14 = IS_ERR((void const   *)__k___1);
  if (tmp___14) {
    tmp___15 = 0;
  } else {
    tmp___15 = 1;
  }
  if (tmp___15) {
    wake_up_process(__k___1);
  } else {

  }
  th = __k___1;
  tmp___17 = IS_ERR((void const   *)th);
  if ((int )tmp___17) {
    dev_err((struct device  const  *)(& pci->dev), "Unable to start the device-polling thread\n");
    quiesce_and_remove_host(dev);
    tmp___16 = PTR_ERR((void const   *)th);
    err = (int )tmp___16;
    goto errout;
  } else {

  }
  dev->polling_thread = th;
  pci_set_drvdata(pci, (void *)dev);
  return (0);
  errout: 
  dev_err((struct device  const  *)(& pci->dev), "rtsx_probe() failed\n");
  release_everything(dev);
  return (err);
}
}
static void rtsx_remove(struct pci_dev *pci ) 
{ 
  struct rtsx_dev *dev ;
  void *tmp ;

  {
  tmp = pci_get_drvdata(pci);
  dev = (struct rtsx_dev *)tmp;
  _dev_info((struct device  const  *)(& pci->dev), "rtsx_remove() called\n");
  quiesce_and_remove_host(dev);
  release_everything(dev);
  pci_set_drvdata(pci, (void *)0);
  return;
}
}
static struct pci_device_id  const  rtsx_ids[3U]  = {      {4332U, 21000U, 4294967295U, 4294967295U, 16711680U, 16711680U, 0UL}, 
        {4332U, 21128U, 4294967295U, 4294967295U, 16711680U, 16711680U, 0UL}, 
        {0U, 0U, 0U, 0U, 0U, 0U, 0UL}};
struct pci_device_id  const  __mod_pci__rtsx_ids_device_table[3U]  ;
static struct pci_driver rtsx_driver  = 
     {{0, 0}, "rts5208", (struct pci_device_id  const  *)(& rtsx_ids), & rtsx_probe,
    & rtsx_remove, & rtsx_suspend, 0, 0, & rtsx_resume, & rtsx_shutdown, 0, 0, {0,
                                                                                0,
                                                                                0,
                                                                                0,
                                                                                (_Bool)0,
                                                                                0,
                                                                                0,
                                                                                0,
                                                                                0,
                                                                                0,
                                                                                0,
                                                                                0,
                                                                                0,
                                                                                0,
                                                                                0,
                                                                                0},
    {{{{{{0}}, 0U, 0U, 0, {0, {0, 0}, 0, 0, 0UL}}}}, {0, 0}}};
static int rtsx_driver_init(void) 
{ 
  int tmp ;

  {
  tmp = ldv___pci_register_driver_37(& rtsx_driver, & __this_module, "rts5208");
  return (tmp);
}
}
static void rtsx_driver_exit(void) 
{ 


  {
  ldv_pci_unregister_driver_38(& rtsx_driver);
  return;
}
}
extern int ldv_suspend_late_2(void) ;
extern int ldv_resume_early_2(void) ;
int ldv_retval_2  ;
    klee_make_symbolic(&ldv_retval_2, sizeof(int), "ldv_retval_2");
int ldv_retval_5  ;
    klee_make_symbolic(&ldv_retval_5, sizeof(int), "ldv_retval_5");
int ldv_retval_0  ;
    klee_make_symbolic(&ldv_retval_0, sizeof(int), "ldv_retval_0");
int ldv_retval_4  ;
    klee_make_symbolic(&ldv_retval_4, sizeof(int), "ldv_retval_4");
extern void ldv_initialize(void) ;
int ldv_retval_1  ;
    klee_make_symbolic(&ldv_retval_1, sizeof(int), "ldv_retval_1");
void ldv_check_final_state(void) ;
int ldv_retval_3  ;
    klee_make_symbolic(&ldv_retval_3, sizeof(int), "ldv_retval_3");
int ldv_irq_1(int state , int line , void *data ) 
{ 
  irqreturn_t irq_retval ;
  int tmp ;
  int tmp___0 ;

  {
  tmp = __VERIFIER_nondet_int();
  irq_retval = (irqreturn_t )tmp;
  if (state != 0) {
    tmp___0 = __VERIFIER_nondet_int();
    switch (tmp___0) {
    case 0: ;
    if (state == 1) {
      LDV_IN_INTERRUPT = 2;
      irq_retval = rtsx_interrupt(line, data);
      LDV_IN_INTERRUPT = 1;
      return (state);
    } else {

    }
    goto ldv_38842;
    default: 
    ldv_stop();
    }
    ldv_38842: ;
  } else {

  }
  return (state);
}
}
void activate_suitable_irq_1(int line , void *data ) 
{ 


  {
  if (ldv_irq_1_0 == 0) {
    ldv_irq_line_1_0 = line;
    ldv_irq_data_1_0 = data;
    ldv_irq_1_0 = 1;
    return;
  } else {

  }
  if (ldv_irq_1_1 == 0) {
    ldv_irq_line_1_1 = line;
    ldv_irq_data_1_1 = data;
    ldv_irq_1_1 = 1;
    return;
  } else {

  }
  if (ldv_irq_1_2 == 0) {
    ldv_irq_line_1_2 = line;
    ldv_irq_data_1_2 = data;
    ldv_irq_1_2 = 1;
    return;
  } else {

  }
  if (ldv_irq_1_3 == 0) {
    ldv_irq_line_1_3 = line;
    ldv_irq_data_1_3 = data;
    ldv_irq_1_3 = 1;
    return;
  } else {

  }
  return;
}
}
int reg_check_1(irqreturn_t (*handler)(int  , void * ) ) 
{ 


  {
  if ((unsigned long )handler == (unsigned long )(& rtsx_interrupt)) {
    return (1);
  } else {

  }
  return (0);
}
}
void ldv_pci_driver_2(void) 
{ 
  void *tmp ;

  {
  tmp = ldv_init_zalloc(2976UL);
  rtsx_driver_group1 = (struct pci_dev *)tmp;
  return;
}
}
void choose_interrupt_1(void) 
{ 
  int tmp ;

  {
  tmp = __VERIFIER_nondet_int();
  switch (tmp) {
  case 0: 
  ldv_irq_1_0 = ldv_irq_1(ldv_irq_1_0, ldv_irq_line_1_0, ldv_irq_data_1_0);
  goto ldv_38862;
  case 1: 
  ldv_irq_1_0 = ldv_irq_1(ldv_irq_1_1, ldv_irq_line_1_1, ldv_irq_data_1_1);
  goto ldv_38862;
  case 2: 
  ldv_irq_1_0 = ldv_irq_1(ldv_irq_1_2, ldv_irq_line_1_2, ldv_irq_data_1_2);
  goto ldv_38862;
  case 3: 
  ldv_irq_1_0 = ldv_irq_1(ldv_irq_1_3, ldv_irq_line_1_3, ldv_irq_data_1_3);
  goto ldv_38862;
  default: 
  ldv_stop();
  }
  ldv_38862: ;
  return;
}
}
void ldv_initialize_scsi_host_template_3(void) 
{ 
  void *tmp___0 ;

  {
  rtsx_host_template_group0 = ldv_malloc(sizeof(struct scsi_cmnd));
  tmp___0 = ldv_init_zalloc(3816UL);
  rtsx_host_template_group1 = (struct Scsi_Host *)tmp___0;
  rtsx_host_template_group2 = ldv_malloc(sizeof(struct scsi_device));
  return;
}
}
void disable_suitable_irq_1(int line , void *data ) 
{ 


  {
  if (ldv_irq_1_0 != 0 && line == ldv_irq_line_1_0) {
    ldv_irq_1_0 = 0;
    return;
  } else {

  }
  if (ldv_irq_1_1 != 0 && line == ldv_irq_line_1_1) {
    ldv_irq_1_1 = 0;
    return;
  } else {

  }
  if (ldv_irq_1_2 != 0 && line == ldv_irq_line_1_2) {
    ldv_irq_1_2 = 0;
    return;
  } else {

  }
  if (ldv_irq_1_3 != 0 && line == ldv_irq_line_1_3) {
    ldv_irq_1_3 = 0;
    return;
  } else {

  }
  return;
}
}
int main(void) 
{ 
  struct pci_device_id *ldvarg1 ;
  void *tmp ;
  pm_message_t ldvarg0 ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  tmp = ldv_init_zalloc(32UL);
  ldvarg1 = (struct pci_device_id *)tmp;
  ldv_initialize();
  ldv_memset((void *)(& ldvarg0), 0, 4UL);
  ldv_state_variable_1 = 1;
  ref_cnt = 0;
  ldv_state_variable_0 = 1;
  ldv_state_variable_3 = 0;
  ldv_state_variable_2 = 0;
  ldv_38914: 
  tmp___0 = __VERIFIER_nondet_int();
  switch (tmp___0) {
  case 0: ;
  if (ldv_state_variable_1 != 0) {
    choose_interrupt_1();
  } else {

  }
  goto ldv_38886;
  case 1: ;
  if (ldv_state_variable_0 != 0) {
    tmp___1 = __VERIFIER_nondet_int();
    switch (tmp___1) {
    case 0: ;
    if (ldv_state_variable_0 == 3 && ref_cnt == 0) {
      rtsx_driver_exit();
      ldv_state_variable_0 = 2;
      goto ldv_final;
    } else {

    }
    goto ldv_38890;
    case 1: ;
    if (ldv_state_variable_0 == 1) {
      ldv_retval_0 = rtsx_driver_init();
      if (ldv_retval_0 == 0) {
        ldv_state_variable_0 = 3;
      } else {

      }
      if (ldv_retval_0 != 0) {
        ldv_state_variable_0 = 2;
        goto ldv_final;
      } else {

      }
    } else {

    }
    goto ldv_38890;
    default: 
    ldv_stop();
    }
    ldv_38890: ;
  } else {

  }
  goto ldv_38886;
  case 2: ;
  if (ldv_state_variable_3 != 0) {
    tmp___2 = __VERIFIER_nondet_int();
    switch (tmp___2) {
    case 0: ;
    if (ldv_state_variable_3 == 1) {
      slave_configure(rtsx_host_template_group2);
      ldv_state_variable_3 = 1;
    } else {

    }
    goto ldv_38895;
    case 1: ;
    if (ldv_state_variable_3 == 1) {
      command_abort(rtsx_host_template_group0);
      ldv_state_variable_3 = 1;
    } else {

    }
    goto ldv_38895;
    case 2: ;
    if (ldv_state_variable_3 == 1) {
      slave_alloc(rtsx_host_template_group2);
      ldv_state_variable_3 = 1;
    } else {

    }
    goto ldv_38895;
    case 3: ;
    if (ldv_state_variable_3 == 1) {
      queuecommand(rtsx_host_template_group1, rtsx_host_template_group0);
      ldv_state_variable_3 = 1;
    } else {

    }
    goto ldv_38895;
    case 4: ;
    if (ldv_state_variable_3 == 1) {
      bus_reset(rtsx_host_template_group0);
      ldv_state_variable_3 = 1;
    } else {

    }
    goto ldv_38895;
    case 5: ;
    if (ldv_state_variable_3 == 1) {
      device_reset(rtsx_host_template_group0);
      ldv_state_variable_3 = 1;
    } else {

    }
    goto ldv_38895;
    case 6: ;
    if (ldv_state_variable_3 == 1) {
      host_info(rtsx_host_template_group1);
      ldv_state_variable_3 = 1;
    } else {

    }
    goto ldv_38895;
    default: 
    ldv_stop();
    }
    ldv_38895: ;
  } else {

  }
  goto ldv_38886;
  case 3: ;
  if (ldv_state_variable_2 != 0) {
    tmp___3 = __VERIFIER_nondet_int();
    switch (tmp___3) {
    case 0: ;
    if (ldv_state_variable_2 == 1) {
      ldv_retval_5 = rtsx_probe(rtsx_driver_group1, (struct pci_device_id  const  *)ldvarg1);
      if (ldv_retval_5 == 0) {
        ldv_state_variable_2 = 2;
        ref_cnt = ref_cnt + 1;
      } else {

      }
    } else {

    }
    goto ldv_38905;
    case 1: ;
    if (ldv_state_variable_2 == 4) {
      rtsx_shutdown(rtsx_driver_group1);
      ldv_state_variable_2 = 4;
    } else {

    }
    if (ldv_state_variable_2 == 3) {
      rtsx_shutdown(rtsx_driver_group1);
      ldv_state_variable_2 = 3;
    } else {

    }
    if (ldv_state_variable_2 == 2) {
      rtsx_shutdown(rtsx_driver_group1);
      ldv_state_variable_2 = 2;
    } else {

    }
    if (ldv_state_variable_2 == 5) {
      rtsx_shutdown(rtsx_driver_group1);
      ldv_state_variable_2 = 5;
    } else {

    }
    goto ldv_38905;
    case 2: ;
    if (ldv_state_variable_2 == 2 && pci_counter == 0) {
      ldv_retval_4 = rtsx_suspend(rtsx_driver_group1, ldvarg0);
      if (ldv_retval_4 == 0) {
        ldv_state_variable_2 = 3;
      } else {

      }
    } else {

    }
    goto ldv_38905;
    case 3: ;
    if (ldv_state_variable_2 == 4) {
      rtsx_remove(rtsx_driver_group1);
      ldv_state_variable_2 = 1;
    } else {

    }
    if (ldv_state_variable_2 == 3) {
      rtsx_remove(rtsx_driver_group1);
      ldv_state_variable_2 = 1;
    } else {

    }
    if (ldv_state_variable_2 == 2) {
      rtsx_remove(rtsx_driver_group1);
      ldv_state_variable_2 = 1;
    } else {

    }
    if (ldv_state_variable_2 == 5) {
      rtsx_remove(rtsx_driver_group1);
      ldv_state_variable_2 = 1;
    } else {

    }
    goto ldv_38905;
    case 4: ;
    if (ldv_state_variable_2 == 4) {
      ldv_retval_3 = rtsx_resume(rtsx_driver_group1);
      if (ldv_retval_3 == 0) {
        ldv_state_variable_2 = 2;
      } else {

      }
    } else {

    }
    if (ldv_state_variable_2 == 3) {
      ldv_retval_3 = rtsx_resume(rtsx_driver_group1);
      if (ldv_retval_3 == 0) {
        ldv_state_variable_2 = 2;
      } else {

      }
    } else {

    }
    if (ldv_state_variable_2 == 5) {
      ldv_retval_3 = rtsx_resume(rtsx_driver_group1);
      if (ldv_retval_3 == 0) {
        ldv_state_variable_2 = 2;
      } else {

      }
    } else {

    }
    goto ldv_38905;
    case 5: ;
    if (ldv_state_variable_2 == 3) {
      ldv_retval_2 = ldv_suspend_late_2();
      if (ldv_retval_2 == 0) {
        ldv_state_variable_2 = 4;
      } else {

      }
    } else {

    }
    goto ldv_38905;
    case 6: ;
    if (ldv_state_variable_2 == 4) {
      ldv_retval_1 = ldv_resume_early_2();
      if (ldv_retval_1 == 0) {
        ldv_state_variable_2 = 5;
      } else {

      }
    } else {

    }
    if (ldv_state_variable_2 == 3) {
      ldv_retval_1 = ldv_resume_early_2();
      if (ldv_retval_1 == 0) {
        ldv_state_variable_2 = 5;
      } else {

      }
    } else {

    }
    goto ldv_38905;
    default: 
    ldv_stop();
    }
    ldv_38905: ;
  } else {

  }
  goto ldv_38886;
  default: 
  ldv_stop();
  }
  ldv_38886: ;
  goto ldv_38914;
  ldv_final: 
  ldv_check_final_state();
  return 0;
}
}
__inline static long PTR_ERR(void const   *ptr ) 
{ 
  long tmp ;

  {
  tmp = ldv_ptr_err(ptr);
  return (tmp);
}
}
__inline static bool IS_ERR(void const   *ptr ) 
{ 
  bool tmp ;

  {
  tmp = ldv_is_err(ptr);
  return (tmp);
}
}
void ldv_mutex_lock_5(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_lock_lock(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_6(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_unlock_lock(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_7(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
int ldv_mutex_trylock_8(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
  tmp = mutex_trylock(ldv_func_arg1);
  ldv_func_res = tmp;
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
  return (tmp___0);
  return (ldv_func_res);
}
}
void ldv_mutex_unlock_9(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_10(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_unlock_i_mutex_of_inode(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_11(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_lock_i_mutex_of_inode(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
int ldv_scsi_add_host_with_dma_12(struct Scsi_Host *shost , struct device *dev , struct device *dma_dev ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  int tmp ;

  {
  tmp = scsi_add_host_with_dma(shost, dev, dma_dev);
  ldv_func_res = tmp;
  if (ldv_func_res == 0) {
    ldv_state_variable_3 = 1;
    ldv_initialize_scsi_host_template_3();
  } else {

  }
  return (ldv_func_res);
}
}
__inline static int ldv_request_irq_13(unsigned int irq , irqreturn_t (*handler)(int  ,
                                                                                 void * ) ,
                                       unsigned long flags , char const   *name ,
                                       void *dev ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
  tmp = request_irq(irq, handler, flags, name, dev);
  ldv_func_res = tmp;
  tmp___0 = reg_check_1(handler);
  if (tmp___0 != 0 && ldv_func_res == 0) {
    activate_suitable_irq_1((int )irq, dev);
  } else {

  }
  return (ldv_func_res);
}
}
void ldv_mutex_lock_14(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_lock_dev_mutex_of_rtsx_dev(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_free_irq_15(unsigned int ldv_func_arg1 , void *ldv_func_arg2 ) 
{ 


  {
  free_irq(ldv_func_arg1, ldv_func_arg2);
  disable_suitable_irq_1((int )ldv_func_arg1, ldv_func_arg2);
  return;
}
}
void ldv_mutex_unlock_16(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_unlock_dev_mutex_of_rtsx_dev(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_17(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_lock_dev_mutex_of_rtsx_dev(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_18(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_unlock_dev_mutex_of_rtsx_dev(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_19(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_unlock_dev_mutex_of_rtsx_dev(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_20(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_unlock_dev_mutex_of_rtsx_dev(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_free_irq_21(unsigned int ldv_func_arg1 , void *ldv_func_arg2 ) 
{ 


  {
  free_irq(ldv_func_arg1, ldv_func_arg2);
  disable_suitable_irq_1((int )ldv_func_arg1, ldv_func_arg2);
  return;
}
}
void ldv_mutex_lock_22(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_lock_dev_mutex_of_rtsx_dev(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_23(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_unlock_dev_mutex_of_rtsx_dev(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_24(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_unlock_dev_mutex_of_rtsx_dev(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_25(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_lock_dev_mutex_of_rtsx_dev(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_26(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_unlock_dev_mutex_of_rtsx_dev(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_27(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_unlock_dev_mutex_of_rtsx_dev(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_28(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_lock_dev_mutex_of_rtsx_dev(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_29(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_unlock_dev_mutex_of_rtsx_dev(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_free_irq_30(unsigned int ldv_func_arg1 , void *ldv_func_arg2 ) 
{ 


  {
  free_irq(ldv_func_arg1, ldv_func_arg2);
  disable_suitable_irq_1((int )ldv_func_arg1, ldv_func_arg2);
  return;
}
}
void ldv_mutex_lock_31(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_lock_dev_mutex_of_rtsx_dev(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_32(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_unlock_dev_mutex_of_rtsx_dev(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_33(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_lock_dev_mutex_of_rtsx_dev(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_34(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_unlock_dev_mutex_of_rtsx_dev(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_scsi_remove_host_35(struct Scsi_Host *shost ) 
{ 


  {
  scsi_remove_host(shost);
  ldv_state_variable_3 = 0;
  return;
}
}
struct Scsi_Host *ldv_scsi_host_alloc_36(struct scsi_host_template *sht , int privsize ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  struct Scsi_Host *tmp ;

  {
  tmp = scsi_host_alloc(sht, privsize);
  ldv_func_res = tmp;
  if ((unsigned long )ldv_func_res != (unsigned long )((ldv_func_ret_type___2 )0)) {
    ldv_state_variable_3 = 1;
    ldv_initialize_scsi_host_template_3();
  } else {

  }
  return (ldv_func_res);
}
}
int ldv___pci_register_driver_37(struct pci_driver *ldv_func_arg1 , struct module *ldv_func_arg2 ,
                                 char const   *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;

  {
  tmp = __pci_register_driver(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  ldv_state_variable_2 = 1;
  ldv_pci_driver_2();
  return (ldv_func_res);
}
}
void ldv_pci_unregister_driver_38(struct pci_driver *ldv_func_arg1 ) 
{ 


  {
  pci_unregister_driver(ldv_func_arg1);
  ldv_state_variable_2 = 0;
  return;
}
}
__inline static long ldv__builtin_expect(long exp , long c ) ;
__inline static void set_bit(long nr , unsigned long volatile   *addr ) 
{ 


  {
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; bts %1,%0": "+m" (*((long volatile   *)addr)): "Ir" (nr): "memory");
  return;
}
}
__inline static void clear_bit(long nr , unsigned long volatile   *addr ) 
{ 


  {
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; btr %1,%0": "+m" (*((long volatile   *)addr)): "Ir" (nr));
  return;
}
}
extern void print_hex_dump(char const   * , char const   * , int  , int  , int  ,
                           void const   * , size_t  , bool  ) ;
extern void *memcpy(void * , void const   * , size_t  ) ;
int ldv_mutex_trylock_80(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_78(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_81(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_82(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_77(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_79(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_83(struct mutex *ldv_func_arg1 ) ;
extern unsigned int ioread32(void * ) ;
extern void iowrite32(u32  , void * ) ;
extern void *vmalloc(unsigned long  ) ;
extern void *vzalloc(unsigned long  ) ;
extern void vfree(void const   * ) ;
extern void __udelay(unsigned long  ) ;
extern void __const_udelay(unsigned long  ) ;
extern int pci_bus_write_config_byte(struct pci_bus * , unsigned int  , int  , u8  ) ;
__inline static int pci_write_config_byte(struct pci_dev  const  *dev , int where ,
                                          u8 val ) 
{ 
  int tmp ;

  {
  tmp = pci_bus_write_config_byte(dev->bus, dev->devfn, where, (int )val);
  return (tmp);
}
}
int ldv_scsi_add_host_with_dma_84(struct Scsi_Host *shost , struct device *dev , struct device *dma_dev ) ;
void _rtsx_trace(struct rtsx_chip *chip , char const   *file , char const   *func ,
                 int line ) ;
__inline static struct device *rtsx_dev(struct rtsx_chip  const  *chip ) 
{ 


  {
  return (& ((chip->rtsx)->pci)->dev);
}
}
int rtsx_force_power_on(struct rtsx_chip *chip , u8 ctl ) ;
int rtsx_force_power_down(struct rtsx_chip *chip , u8 ctl ) ;
void rtsx_disable_card_int(struct rtsx_chip *chip ) ;
void rtsx_enable_card_int(struct rtsx_chip *chip ) ;
void rtsx_enable_bus_int(struct rtsx_chip *chip ) ;
void rtsx_disable_bus_int(struct rtsx_chip *chip ) ;
int rtsx_reset_chip(struct rtsx_chip *chip ) ;
void rtsx_undo_delink(struct rtsx_chip *chip ) ;
void rtsx_stop_cmd(struct rtsx_chip *chip , int card ) ;
int rtsx_read_register(struct rtsx_chip *chip , u16 addr , u8 *data ) ;
int rtsx_write_cfg_dw(struct rtsx_chip *chip , u8 func_no , u16 addr , u32 mask ,
                      u32 val ) ;
int rtsx_read_cfg_dw(struct rtsx_chip *chip , u8 func_no , u16 addr , u32 *val ) ;
int rtsx_write_cfg_seq(struct rtsx_chip *chip , u8 func , u16 addr , u8 *buf , int len ) ;
int rtsx_read_cfg_seq(struct rtsx_chip *chip , u8 func , u16 addr , u8 *buf , int len ) ;
int rtsx_write_phy_register(struct rtsx_chip *chip , u8 addr , u16 val ) ;
int rtsx_read_phy_register(struct rtsx_chip *chip , u8 addr , u16 *val ) ;
int rtsx_read_efuse(struct rtsx_chip *chip , u8 addr , u8 *val ) ;
int rtsx_write_efuse(struct rtsx_chip *chip , u8 addr , u8 val ) ;
int rtsx_clr_phy_reg_bit(struct rtsx_chip *chip , u8 reg , u8 bit ) ;
int rtsx_set_phy_reg_bit(struct rtsx_chip *chip , u8 reg , u8 bit ) ;
int rtsx_check_link_ready(struct rtsx_chip *chip ) ;
void rtsx_enter_ss(struct rtsx_chip *chip ) ;
void rtsx_exit_ss(struct rtsx_chip *chip ) ;
void rtsx_enter_L1(struct rtsx_chip *chip ) ;
void rtsx_exit_L1(struct rtsx_chip *chip ) ;
void rtsx_enable_aspm(struct rtsx_chip *chip ) ;
void rtsx_disable_aspm(struct rtsx_chip *chip ) ;
int rtsx_read_ppbuf(struct rtsx_chip *chip , u8 *buf , int buf_len ) ;
int rtsx_write_ppbuf(struct rtsx_chip *chip , u8 *buf , int buf_len ) ;
int rtsx_check_chip_exist(struct rtsx_chip *chip ) ;
void rtsx_add_cmd(struct rtsx_chip *chip , u8 cmd_type , u16 reg_addr , u8 mask ,
                  u8 data ) ;
int rtsx_send_cmd(struct rtsx_chip *chip , u8 card , int timeout ) ;
__inline static u8 *rtsx_get_cmd_data(struct rtsx_chip *chip ) 
{ 


  {
  return ((u8 *)chip->host_cmds_ptr);
}
}
void set_sense_type(struct rtsx_chip *chip , unsigned int lun , int sense_type ) ;
int sd_pull_ctl_enable(struct rtsx_chip *chip ) ;
int sd_power_off_card3v3(struct rtsx_chip *chip ) ;
void do_remaining_work(struct rtsx_chip *chip ) ;
void try_to_switch_sdio_ctrl(struct rtsx_chip *chip ) ;
void rtsx_power_off_card(struct rtsx_chip *chip ) ;
void rtsx_release_cards(struct rtsx_chip *chip ) ;
void rtsx_reset_cards(struct rtsx_chip *chip ) ;
void rtsx_reinit_cards(struct rtsx_chip *chip , int reset_chip ) ;
void rtsx_init_cards(struct rtsx_chip *chip ) ;
void toggle_gpio(struct rtsx_chip *chip , u8 gpio ) ;
void turn_off_led(struct rtsx_chip *chip , u8 gpio ) ;
int card_share_mode(struct rtsx_chip *chip , int card ) ;
int card_power_off(struct rtsx_chip *chip , u8 card ) ;
void dynamic_configure_sdio_aspm(struct rtsx_chip *chip ) ;
__inline static void rtsx_exclusive_enter_ss(struct rtsx_chip *chip ) 
{ 
  struct rtsx_dev *dev ;

  {
  dev = chip->rtsx;
  spin_lock(& dev->reg_lock);
  rtsx_enter_ss(chip);
  spin_unlock(& dev->reg_lock);
  return;
}
}
__inline static void rtsx_reset_detected_cards(struct rtsx_chip *chip , int flag ) 
{ 


  {
  rtsx_reset_cards(chip);
  return;
}
}
void xd_free_l2p_tbl(struct rtsx_chip *chip ) ;
int xd_power_off_card3v3(struct rtsx_chip *chip ) ;
void ms_free_l2p_tbl(struct rtsx_chip *chip ) ;
int ms_power_off_card3v3(struct rtsx_chip *chip ) ;
static void rtsx_calibration(struct rtsx_chip *chip ) 
{ 
  struct task_struct *tmp ;
  long volatile   __ret ;
  struct task_struct *tmp___0 ;
  struct task_struct *tmp___1 ;
  struct task_struct *tmp___2 ;
  struct task_struct *tmp___3 ;

  {
  rtsx_write_phy_register(chip, 27, 4958);
  tmp = get_current();
  tmp->task_state_change = 0UL;
  __ret = 1L;
  switch (8UL) {
  case 1UL: 
  tmp___0 = get_current();
  __asm__  volatile   ("xchgb %b0, %1\n": "+q" (__ret), "+m" (tmp___0->state): : "memory",
                       "cc");
  goto ldv_38507;
  case 2UL: 
  tmp___1 = get_current();
  __asm__  volatile   ("xchgw %w0, %1\n": "+r" (__ret), "+m" (tmp___1->state): : "memory",
                       "cc");
  goto ldv_38507;
  case 4UL: 
  tmp___2 = get_current();
  __asm__  volatile   ("xchgl %0, %1\n": "+r" (__ret), "+m" (tmp___2->state): : "memory",
                       "cc");
  goto ldv_38507;
  case 8UL: 
  tmp___3 = get_current();
  __asm__  volatile   ("xchgq %q0, %1\n": "+r" (__ret), "+m" (tmp___3->state): : "memory",
                       "cc");
  goto ldv_38507;
  default: 
  __xchg_wrong_size();
  }
  ldv_38507: 
  schedule_timeout(2L);
  rtsx_write_phy_register(chip, 0, 640);
  rtsx_write_phy_register(chip, 1, 28946);
  rtsx_write_phy_register(chip, 1, 28944);
  rtsx_write_phy_register(chip, 1, 28946);
  rtsx_write_phy_register(chip, 1, 28947);
  rtsx_write_phy_register(chip, 0, 648);
  return;
}
}
void rtsx_disable_card_int(struct rtsx_chip *chip ) 
{ 
  u32 reg ;
  unsigned int tmp ;

  {
  tmp = ioread32((chip->rtsx)->remap_addr + 24UL);
  reg = tmp;
  reg = reg & 4060086271U;
  iowrite32(reg, (chip->rtsx)->remap_addr + 24UL);
  return;
}
}
void rtsx_enable_card_int(struct rtsx_chip *chip ) 
{ 
  u32 reg ;
  unsigned int tmp ;
  int i ;
    klee_make_symbolic(&i, sizeof(int), "i");

  {
  tmp = ioread32((chip->rtsx)->remap_addr + 24UL);
  reg = tmp;
  i = 0;
  goto ldv_38523;
  ldv_38522: ;
  if (((int )chip->lun2card[i] & 16) != 0) {
    reg = reg | 134217728U;
  } else {

  }
  if (((int )chip->lun2card[i] & 4) != 0) {
    reg = reg | 33554432U;
  } else {

  }
  if (((int )chip->lun2card[i] & 8) != 0) {
    reg = reg | 67108864U;
  } else {

  }
  i = i + 1;
  ldv_38523: ;
  if ((int )chip->max_lun >= i) {
    goto ldv_38522;
  } else {

  }

  if (chip->hw_bypass_sd != 0) {
    reg = reg & 4261412863U;
  } else {

  }
  iowrite32(reg, (chip->rtsx)->remap_addr + 24UL);
  return;
}
}
void rtsx_enable_bus_int(struct rtsx_chip *chip ) 
{ 
  u32 reg ;
  int i ;
  struct _ddebug descriptor ;
  struct device *tmp ;
  long tmp___0 ;
  struct _ddebug descriptor___0 ;
  struct device *tmp___1 ;
  long tmp___2 ;
    klee_make_symbolic(&tmp___2, sizeof(long), "tmp___2");

  {
  reg = 0U;
  reg = 805306368U;
  i = 0;
  goto ldv_38533;
  ldv_38532: 
  descriptor.modname = "rts5208";
  descriptor.function = "rtsx_enable_bus_int";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c";
  descriptor.format = "lun2card[%d] = 0x%02x\n";
  descriptor.lineno = 85U;
  descriptor.flags = 0U;
  tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp___0 != 0L) {
    tmp = rtsx_dev((struct rtsx_chip  const  *)chip);
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)tmp, "lun2card[%d] = 0x%02x\n",
                      i, (int )chip->lun2card[i]);
  } else {

  }
  if (((int )chip->lun2card[i] & 16) != 0) {
    reg = reg | 134217728U;
  } else {

  }
  if (((int )chip->lun2card[i] & 4) != 0) {
    reg = reg | 33554432U;
  } else {

  }
  if (((int )chip->lun2card[i] & 8) != 0) {
    reg = reg | 67108864U;
  } else {

  }
  i = i + 1;
  ldv_38533: ;
  if ((int )chip->max_lun >= i) {
    goto ldv_38532;
  } else {

  }

  if (chip->hw_bypass_sd != 0) {
    reg = reg & 4261412863U;
  } else {

  }
  if ((unsigned int )chip->ic_version > 1U) {
    reg = reg | 16777216U;
  } else {

  }
  reg = reg | 8388608U;
  if (chip->adma_mode == 0) {
    reg = reg | 1073741824U;
  } else {

  }
  iowrite32(reg, (chip->rtsx)->remap_addr + 24UL);
  descriptor___0.modname = "rts5208";
  descriptor___0.function = "rtsx_enable_bus_int";
  descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c";
  descriptor___0.format = "RTSX_BIER: 0x%08x\n";
  descriptor___0.lineno = 109U;
  descriptor___0.flags = 0U;
  tmp___2 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
  if (tmp___2 != 0L) {
    tmp___1 = rtsx_dev((struct rtsx_chip  const  *)chip);
    __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)tmp___1, "RTSX_BIER: 0x%08x\n",
                      reg);
  } else {

  }
  return;
}
}
void rtsx_disable_bus_int(struct rtsx_chip *chip ) 
{ 


  {
  iowrite32(0U, (chip->rtsx)->remap_addr + 24UL);
  return;
}
}
static int rtsx_pre_handle_sdio_old(struct rtsx_chip *chip ) 
{ 
  int retval ;

  {
  if (chip->ignore_sd != 0 && chip->sdio_func_exist & 1) {
    if (chip->asic_code != 0) {
      retval = rtsx_write_register(chip, 64868, 255, 216);
      if (retval != 0) {
        _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c",
                    "rtsx_pre_handle_sdio_old", 127);
        return (retval);
      } else {

      }
    } else {
      retval = rtsx_write_register(chip, 64541, 255, 247);
      if (retval != 0) {
        _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c",
                    "rtsx_pre_handle_sdio_old", 135);
        return (retval);
      } else {

      }
    }
    retval = rtsx_write_register(chip, 64850, 255, 4);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c",
                  "rtsx_pre_handle_sdio_old", 142);
      return (retval);
    } else {

    }
    retval = rtsx_write_register(chip, 65324, 1, 1);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c",
                  "rtsx_pre_handle_sdio_old", 149);
      return (retval);
    } else {

    }
    retval = rtsx_write_register(chip, 64875, 255, 3);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c",
                  "rtsx_pre_handle_sdio_old", 156);
      return (retval);
    } else {

    }
    chip->sd_int = 1U;
    chip->sd_io = 1U;
  } else {
    chip->need_reset = chip->need_reset | 4UL;
  }
  return (0);
}
}
static int rtsx_pre_handle_sdio_new(struct rtsx_chip *chip ) 
{ 
  u8 tmp ;
  bool sw_bypass_sd ;
  int retval ;
  struct _ddebug descriptor ;
  struct device *tmp___0 ;
  long tmp___1 ;
    klee_make_symbolic(&tmp___1, sizeof(long), "tmp___1");
  struct _ddebug descriptor___0 ;
  struct device *tmp___2 ;
  long tmp___3 ;
    klee_make_symbolic(&tmp___3, sizeof(long), "tmp___3");
  struct _ddebug descriptor___1 ;
  struct device *tmp___4 ;
  long tmp___5 ;
  u8 cd_toggle_mask ;
  struct _ddebug descriptor___2 ;
  struct device *tmp___6 ;
  long tmp___7 ;
    klee_make_symbolic(&tmp___7, sizeof(long), "tmp___7");

  {
  sw_bypass_sd = 0;
  if (chip->driver_first_load != 0) {
    if ((unsigned int )chip->product_id == 21128U) {
      retval = rtsx_read_register(chip, 65114, & tmp);
      if (retval != 0) {
        _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c",
                    "rtsx_pre_handle_sdio_new", 180);
        return (retval);
      } else {

      }
      if (((int )tmp & 8) != 0) {
        sw_bypass_sd = 1;
      } else {

      }
    } else
    if ((unsigned int )chip->product_id == 21000U) {
      retval = rtsx_read_register(chip, 65136, & tmp);
      if (retval != 0) {
        _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c",
                    "rtsx_pre_handle_sdio_new", 188);
        return (retval);
      } else {

      }
      if ((int )((signed char )tmp) < 0) {
        sw_bypass_sd = 1;
      } else {

      }
    } else {

    }
  } else
  if (chip->sdio_in_charge != 0) {
    sw_bypass_sd = 1;
  } else {

  }
  descriptor.modname = "rts5208";
  descriptor.function = "rtsx_pre_handle_sdio_new";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c";
  descriptor.format = "chip->sdio_in_charge = %d\n";
  descriptor.lineno = 199U;
  descriptor.flags = 0U;
  tmp___1 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp___1 != 0L) {
    tmp___0 = rtsx_dev((struct rtsx_chip  const  *)chip);
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)tmp___0, "chip->sdio_in_charge = %d\n",
                      chip->sdio_in_charge);
  } else {

  }
  descriptor___0.modname = "rts5208";
  descriptor___0.function = "rtsx_pre_handle_sdio_new";
  descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c";
  descriptor___0.format = "chip->driver_first_load = %d\n";
  descriptor___0.lineno = 201U;
  descriptor___0.flags = 0U;
  tmp___3 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
  if (tmp___3 != 0L) {
    tmp___2 = rtsx_dev((struct rtsx_chip  const  *)chip);
    __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)tmp___2, "chip->driver_first_load = %d\n",
                      chip->driver_first_load);
  } else {

  }
  descriptor___1.modname = "rts5208";
  descriptor___1.function = "rtsx_pre_handle_sdio_new";
  descriptor___1.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c";
  descriptor___1.format = "sw_bypass_sd = %d\n";
  descriptor___1.lineno = 203U;
  descriptor___1.flags = 0U;
  tmp___5 = ldv__builtin_expect((long )descriptor___1.flags & 1L, 0L);
  if (tmp___5 != 0L) {
    tmp___4 = rtsx_dev((struct rtsx_chip  const  *)chip);
    __dynamic_dev_dbg(& descriptor___1, (struct device  const  *)tmp___4, "sw_bypass_sd = %d\n",
                      (int )sw_bypass_sd);
  } else {

  }
  if ((int )sw_bypass_sd) {
    cd_toggle_mask = 0U;
    retval = rtsx_read_register(chip, 65063, & tmp);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c",
                  "rtsx_pre_handle_sdio_new", 210);
      return (retval);
    } else {

    }
    cd_toggle_mask = 8U;
    if ((unsigned int )((int )tmp & (int )cd_toggle_mask) != 0U) {
      if ((unsigned int )chip->product_id == 21128U) {
        retval = rtsx_write_register(chip, 65114, 8, 0);
        if (retval != 0) {
          _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c",
                      "rtsx_pre_handle_sdio_new", 221);
          return (retval);
        } else {

        }
      } else
      if ((unsigned int )chip->product_id == 21000U) {
        retval = rtsx_write_register(chip, 65136, 128, 0);
        if (retval != 0) {
          _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c",
                      "rtsx_pre_handle_sdio_new", 228);
          return (retval);
        } else {

        }
      } else {

      }
      retval = rtsx_write_register(chip, 65063, 255, (int )tmp);
      if (retval != 0) {
        _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c",
                    "rtsx_pre_handle_sdio_new", 236);
        return (retval);
      } else {

      }
      chip->need_reset = chip->need_reset | 4UL;
    } else {
      descriptor___2.modname = "rts5208";
      descriptor___2.function = "rtsx_pre_handle_sdio_new";
      descriptor___2.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c";
      descriptor___2.format = "Chip inserted with SDIO!\n";
      descriptor___2.lineno = 242U;
      descriptor___2.flags = 0U;
      tmp___7 = ldv__builtin_expect((long )descriptor___2.flags & 1L, 0L);
      if (tmp___7 != 0L) {
        tmp___6 = rtsx_dev((struct rtsx_chip  const  *)chip);
        __dynamic_dev_dbg(& descriptor___2, (struct device  const  *)tmp___6, "Chip inserted with SDIO!\n");
      } else {

      }
      if (chip->asic_code != 0) {
        retval = sd_pull_ctl_enable(chip);
        if (retval != 0) {
          _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c",
                      "rtsx_pre_handle_sdio_new", 247);
          return (1);
        } else {

        }
      } else {
        retval = rtsx_write_register(chip, 64541, 40, 0);
        if (retval != 0) {
          _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c",
                      "rtsx_pre_handle_sdio_new", 256);
          return (retval);
        } else {

        }
      }
      retval = card_share_mode(chip, 4);
      if (retval != 0) {
        _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c",
                    "rtsx_pre_handle_sdio_new", 262);
        return (1);
      } else {

      }
      if ((unsigned int )chip->product_id == 21128U) {
        retval = rtsx_write_register(chip, 65114, 8, 8);
        if (retval != 0) {
          _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c",
                      "rtsx_pre_handle_sdio_new", 271);
          return (retval);
        } else {

        }
      } else
      if ((unsigned int )chip->product_id == 21000U) {
        retval = rtsx_write_register(chip, 65136, 128, 128);
        if (retval != 0) {
          _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c",
                      "rtsx_pre_handle_sdio_new", 278);
          return (retval);
        } else {

        }
      } else {

      }
      chip->chip_insert_with_sdio = 1;
      chip->sd_io = 1U;
    }
  } else {
    retval = rtsx_write_register(chip, 65063, 8, 8);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c",
                  "rtsx_pre_handle_sdio_new", 289);
      return (retval);
    } else {

    }
    chip->need_reset = chip->need_reset | 4UL;
  }
  return (0);
}
}
static int rtsx_reset_aspm(struct rtsx_chip *chip ) 
{ 
  int ret ;
    klee_make_symbolic(&ret, sizeof(int), "ret");

  {
  if (chip->dynamic_aspm != 0) {
    if ((chip->sdio_func_exist & 1) == 0 || (unsigned int )chip->product_id != 21128U) {
      return (0);
    } else {

    }
    ret = rtsx_write_cfg_dw(chip, 2, 192, 255U, (u32 )chip->aspm_l0s_l1_en);
    if (ret != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c",
                  "rtsx_reset_aspm", 311);
      return (1);
    } else {

    }
    return (0);
  } else {

  }
  if ((unsigned int )chip->product_id == 21000U) {
    ret = rtsx_write_register(chip, 65111, 255, 63);
    if (ret != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c",
                  "rtsx_reset_aspm", 321);
      return (ret);
    } else {

    }
  } else {

  }
  ret = pci_write_config_byte((struct pci_dev  const  *)(chip->rtsx)->pci, 128, (int )chip->aspm_l0s_l1_en);
  if (ret != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c",
                "rtsx_reset_aspm", 327);
    return (1);
  } else {

  }
  chip->aspm_level[0] = chip->aspm_l0s_l1_en;
  if (chip->sdio_func_exist & 1) {
    chip->aspm_level[1] = chip->aspm_l0s_l1_en;
    ret = rtsx_write_cfg_dw(chip, (unsigned int )chip->product_id == 21128U ? 2 : 1,
                            192, 255U, (u32 )chip->aspm_l0s_l1_en);
    if (ret != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c",
                  "rtsx_reset_aspm", 337);
      return (1);
    } else {

    }
  } else {

  }
  chip->aspm_enabled = 1;
  return (0);
}
}
static int rtsx_enable_pcie_intr(struct rtsx_chip *chip ) 
{ 
  int ret ;
  u16 reg ;

  {
  if (chip->asic_code == 0 || (unsigned int )chip->product_id != 21000U) {
    rtsx_enable_bus_int(chip);
    return (0);
  } else {

  }
  if (chip->phy_debug_mode != 0) {
    ret = rtsx_write_register(chip, 65106, 119, 0);
    if (ret != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c",
                  "rtsx_enable_pcie_intr", 359);
      return (ret);
    } else {

    }
    rtsx_disable_bus_int(chip);
  } else {
    rtsx_enable_bus_int(chip);
  }
  if ((unsigned int )chip->ic_version > 2U) {
    ret = rtsx_read_phy_register(chip, 0, & reg);
    if (ret != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c",
                  "rtsx_enable_pcie_intr", 372);
      return (1);
    } else {

    }
    reg = (unsigned int )reg & 65151U;
    reg = (u16 )((unsigned int )reg | 128U);
    ret = rtsx_write_phy_register(chip, 0, (int )reg);
    if (ret != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c",
                  "rtsx_enable_pcie_intr", 380);
      return (1);
    } else {

    }
    ret = rtsx_read_phy_register(chip, 28, & reg);
    if (ret != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c",
                  "rtsx_enable_pcie_intr", 386);
      return (1);
    } else {

    }
    reg = (unsigned int )reg & 65527U;
    ret = rtsx_write_phy_register(chip, 28, (int )reg);
    if (ret != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c",
                  "rtsx_enable_pcie_intr", 393);
      return (1);
    } else {

    }
  } else {

  }
  if (chip->driver_first_load != 0 && (unsigned int )chip->ic_version <= 1U) {
    rtsx_calibration(chip);
  } else {

  }
  return (0);
}
}
int rtsx_reset_chip(struct rtsx_chip *chip ) 
{ 
  int retval ;
  struct _ddebug descriptor ;
  struct device *tmp ;
  long tmp___0 ;
  struct _ddebug descriptor___0 ;
  struct device *tmp___1 ;
  long tmp___2 ;
  struct _ddebug descriptor___1 ;
  struct device *tmp___3 ;
  long tmp___4 ;
    klee_make_symbolic(&tmp___4, sizeof(long), "tmp___4");
  struct task_struct *tmp___5 ;
  long volatile   __ret ;
  struct task_struct *tmp___6 ;
  struct task_struct *tmp___7 ;
  struct task_struct *tmp___8 ;
  struct task_struct *tmp___9 ;

  {
  iowrite32((u32 )chip->host_cmds_addr, (chip->rtsx)->remap_addr);
  rtsx_disable_aspm(chip);
  retval = rtsx_write_register(chip, 65120, 3, 0);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c",
                "rtsx_reset_chip", 414);
    return (retval);
  } else {

  }
  retval = rtsx_write_register(chip, 64873, 30, 0);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c",
                "rtsx_reset_chip", 421);
    return (retval);
  } else {

  }
  if ((unsigned int )chip->lun_mode == 1U) {
    retval = rtsx_write_register(chip, 64512, 6, 0);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c",
                  "rtsx_reset_chip", 430);
      return (retval);
    } else {

    }
  } else {
    retval = rtsx_write_register(chip, 64512, 6, 4);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c",
                  "rtsx_reset_chip", 437);
      return (retval);
    } else {

    }
  }
  retval = rtsx_write_register(chip, 64536, 56, 40);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c",
                "rtsx_reset_chip", 445);
    return (retval);
  } else {

  }
  retval = rtsx_write_register(chip, 64537, 192, 128);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c",
                "rtsx_reset_chip", 451);
    return (retval);
  } else {

  }
  retval = rtsx_write_register(chip, 64533, 255, 40);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c",
                "rtsx_reset_chip", 457);
    return (retval);
  } else {

  }
  if ((unsigned int )chip->product_id != 21128U) {
    retval = rtsx_write_register(chip, 64855, 255, 3);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c",
                  "rtsx_reset_chip", 473);
      return (retval);
    } else {

    }
  } else {

  }
  retval = rtsx_write_register(chip, 64856, 255, 3);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c",
                "rtsx_reset_chip", 481);
    return (retval);
  } else {

  }
  retval = rtsx_write_register(chip, 65115, 10, 0);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c",
                "rtsx_reset_chip", 488);
    return (retval);
  } else {

  }
  retval = rtsx_write_register(chip, 64851, 255, (int )chip->card_drive_sel);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c",
                "rtsx_reset_chip", 496);
    return (retval);
  } else {

  }
  if (chip->asic_code != 0) {
    retval = rtsx_write_register(chip, 64529, 255, 80);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c",
                  "rtsx_reset_chip", 514);
      return (retval);
    } else {

    }
    retval = rtsx_write_register(chip, 64530, 255, 18);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c",
                  "rtsx_reset_chip", 519);
      return (retval);
    } else {

    }
  } else {

  }
  retval = rtsx_write_register(chip, 65115, 22, 16);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c",
                "rtsx_reset_chip", 533);
    return (retval);
  } else {

  }
  if ((unsigned int )chip->aspm_l0s_l1_en != 0U) {
    retval = rtsx_reset_aspm(chip);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c",
                  "rtsx_reset_chip", 541);
      return (1);
    } else {

    }
  } else {
    if (chip->asic_code != 0 && (unsigned int )chip->product_id == 21000U) {
      retval = rtsx_write_phy_register(chip, 7, 297);
      if (retval != 0) {
        _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c",
                    "rtsx_reset_chip", 548);
        return (1);
      } else {

      }
    } else {

    }
    retval = pci_write_config_byte((struct pci_dev  const  *)(chip->rtsx)->pci, 128,
                                   (int )chip->aspm_l0s_l1_en);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c",
                  "rtsx_reset_chip", 555);
      return (1);
    } else {

    }
  }
  retval = pci_write_config_byte((struct pci_dev  const  *)(chip->rtsx)->pci, 129,
                                 1);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c",
                "rtsx_reset_chip", 562);
    return (1);
  } else {

  }
  if (chip->sdio_func_exist & 1) {
    retval = rtsx_write_cfg_dw(chip, (unsigned int )chip->product_id == 21128U ? 2 : 1,
                               192, 65280U, 256U);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c",
                  "rtsx_reset_chip", 572);
      return (1);
    } else {

    }
  } else {

  }
  if ((unsigned int )chip->product_id == 21128U && (chip->sdio_func_exist & 1) == 0) {
    retval = rtsx_write_cfg_dw(chip, 2, 192, 65535U, 259U);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c",
                  "rtsx_reset_chip", 580);
      return (1);
    } else {

    }
    retval = rtsx_write_cfg_dw(chip, 2, 132, 255U, 3U);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c",
                  "rtsx_reset_chip", 586);
      return (1);
    } else {

    }
  } else {

  }
  retval = rtsx_write_register(chip, 65057, 32, 32);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c",
                "rtsx_reset_chip", 594);
    return (retval);
  } else {

  }
  retval = rtsx_write_register(chip, 65116, 255, 128);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c",
                "rtsx_reset_chip", 600);
    return (retval);
  } else {

  }
  retval = rtsx_enable_pcie_intr(chip);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c",
                "rtsx_reset_chip", 606);
    return (1);
  } else {

  }
  chip->need_reset = 0UL;
  chip->int_reg = ioread32((chip->rtsx)->remap_addr + 20UL);
  if (chip->hw_bypass_sd != 0) {
    goto nextcard;
  } else {

  }
  descriptor.modname = "rts5208";
  descriptor.function = "rtsx_reset_chip";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c";
  descriptor.format = "In %s, chip->int_reg = 0x%x\n";
  descriptor.lineno = 617U;
  descriptor.flags = 0U;
  tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp___0 != 0L) {
    tmp = rtsx_dev((struct rtsx_chip  const  *)chip);
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)tmp, "In %s, chip->int_reg = 0x%x\n",
                      "rtsx_reset_chip", chip->int_reg);
  } else {

  }
  if ((chip->int_reg & 65536U) != 0U) {
    if ((unsigned int )chip->product_id == 21000U && (unsigned int )chip->ic_version <= 1U) {
      retval = rtsx_pre_handle_sdio_old(chip);
    } else {
      retval = rtsx_pre_handle_sdio_new(chip);
    }
    descriptor___0.modname = "rts5208";
    descriptor___0.function = "rtsx_reset_chip";
    descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c";
    descriptor___0.format = "chip->need_reset = 0x%x (rtsx_reset_chip)\n";
    descriptor___0.lineno = 626U;
    descriptor___0.flags = 0U;
    tmp___2 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
    if (tmp___2 != 0L) {
      tmp___1 = rtsx_dev((struct rtsx_chip  const  *)chip);
      __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)tmp___1, "chip->need_reset = 0x%x (rtsx_reset_chip)\n",
                        (unsigned int )chip->need_reset);
    } else {

    }
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c",
                  "rtsx_reset_chip", 631);
      return (1);
    } else {

    }
  } else {
    chip->sd_io = 0U;
    retval = rtsx_write_register(chip, 64875, 3, 0);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c",
                  "rtsx_reset_chip", 640);
      return (retval);
    } else {

    }
  }
  nextcard: ;
  if ((chip->int_reg & 262144U) != 0U) {
    chip->need_reset = chip->need_reset | 16UL;
  } else {

  }
  if ((chip->int_reg & 131072U) != 0U) {
    chip->need_reset = chip->need_reset | 8UL;
  } else {

  }
  if ((chip->int_reg & 458752U) != 0U) {
    retval = rtsx_write_register(chip, 64529, 128, 128);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c",
                  "rtsx_reset_chip", 654);
      return (retval);
    } else {

    }
  } else {

  }
  descriptor___1.modname = "rts5208";
  descriptor___1.function = "rtsx_reset_chip";
  descriptor___1.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c";
  descriptor___1.format = "In %s, chip->need_reset = 0x%x\n";
  descriptor___1.lineno = 660U;
  descriptor___1.flags = 0U;
  tmp___4 = ldv__builtin_expect((long )descriptor___1.flags & 1L, 0L);
  if (tmp___4 != 0L) {
    tmp___3 = rtsx_dev((struct rtsx_chip  const  *)chip);
    __dynamic_dev_dbg(& descriptor___1, (struct device  const  *)tmp___3, "In %s, chip->need_reset = 0x%x\n",
                      "rtsx_reset_chip", (unsigned int )chip->need_reset);
  } else {

  }
  retval = rtsx_write_register(chip, 64532, 1, 0);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c",
                "rtsx_reset_chip", 664);
    return (retval);
  } else {

  }
  if ((unsigned int )chip->product_id == 21000U || (unsigned int )chip->product_id == 21128U) {
    retval = rtsx_write_register(chip, 65136, 3, 3);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c",
                  "rtsx_reset_chip", 673);
      return (retval);
    } else {

    }
  } else {

  }
  if (chip->remote_wakeup_en != 0 && chip->auto_delink_en == 0) {
    retval = rtsx_write_register(chip, 65108, 7, 7);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c",
                  "rtsx_reset_chip", 681);
      return (retval);
    } else {

    }
    if (chip->aux_pwr_exist != 0) {
      retval = rtsx_write_register(chip, 65110, 255, 51);
      if (retval != 0) {
        _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c",
                    "rtsx_reset_chip", 688);
        return (retval);
      } else {

      }
    } else {

    }
  } else {
    retval = rtsx_write_register(chip, 65108, 7, 4);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c",
                  "rtsx_reset_chip", 695);
      return (retval);
    } else {

    }
    retval = rtsx_write_register(chip, 65110, 255, 48);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c",
                  "rtsx_reset_chip", 700);
      return (retval);
    } else {

    }
  }
  if ((unsigned int )chip->product_id == 21000U && (unsigned int )chip->ic_version > 2U) {
    retval = rtsx_write_register(chip, 65097, 28, 20);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c",
                  "rtsx_reset_chip", 708);
      return (retval);
    } else {

    }
  } else {

  }
  if (chip->asic_code != 0 && (unsigned int )chip->product_id == 21000U) {
    retval = rtsx_clr_phy_reg_bit(chip, 28, 2);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c",
                  "rtsx_reset_chip", 716);
      return (1);
    } else {

    }
  } else {

  }
  if (chip->ft2_fast_mode != 0) {
    retval = rtsx_write_register(chip, 64848, 255, 5);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c",
                  "rtsx_reset_chip", 725);
      return (retval);
    } else {

    }
    __udelay((unsigned long )chip->pmos_pwr_on_interval);
    retval = rtsx_write_register(chip, 64848, 255, 0);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c",
                  "rtsx_reset_chip", 732);
      return (retval);
    } else {

    }
    tmp___5 = get_current();
    tmp___5->task_state_change = 0UL;
    __ret = 1L;
    switch (8UL) {
    case 1UL: 
    tmp___6 = get_current();
    __asm__  volatile   ("xchgb %b0, %1\n": "+q" (__ret), "+m" (tmp___6->state): : "memory",
                         "cc");
    goto ldv_38578;
    case 2UL: 
    tmp___7 = get_current();
    __asm__  volatile   ("xchgw %w0, %1\n": "+r" (__ret), "+m" (tmp___7->state): : "memory",
                         "cc");
    goto ldv_38578;
    case 4UL: 
    tmp___8 = get_current();
    __asm__  volatile   ("xchgl %0, %1\n": "+r" (__ret), "+m" (tmp___8->state): : "memory",
                         "cc");
    goto ldv_38578;
    case 8UL: 
    tmp___9 = get_current();
    __asm__  volatile   ("xchgq %q0, %1\n": "+r" (__ret), "+m" (tmp___9->state): : "memory",
                         "cc");
    goto ldv_38578;
    default: 
    __xchg_wrong_size();
    }
    ldv_38578: 
    schedule_timeout(50L);
  } else {

  }
  rtsx_reset_detected_cards(chip, 0);
  chip->driver_first_load = 0;
  return (0);
}
}
__inline static int check_sd_speed_prior(u32 sd_speed_prior ) 
{ 
  bool fake_para ;
  int i ;
  u8 tmp ;

  {
  fake_para = 0;
  i = 0;
  goto ldv_38592;
  ldv_38591: 
  tmp = (unsigned char )(sd_speed_prior >> i * 8);
  if ((unsigned int )tmp == 0U || (unsigned int )tmp > 4U) {
    fake_para = 1;
    goto ldv_38590;
  } else {

  }
  i = i + 1;
  ldv_38592: ;
  if (i <= 3) {
    goto ldv_38591;
  } else {

  }
  ldv_38590: ;
  return (! fake_para);
}
}
__inline static int check_sd_current_prior(u32 sd_current_prior ) 
{ 
  bool fake_para ;
  int i ;
  u8 tmp ;

  {
  fake_para = 0;
  i = 0;
  goto ldv_38601;
  ldv_38600: 
  tmp = (unsigned char )(sd_current_prior >> i * 8);
  if ((unsigned int )tmp > 3U) {
    fake_para = 1;
    goto ldv_38599;
  } else {

  }
  i = i + 1;
  ldv_38601: ;
  if (i <= 3) {
    goto ldv_38600;
  } else {

  }
  ldv_38599: ;
  return (! fake_para);
}
}
static int rts5208_init(struct rtsx_chip *chip ) 
{ 
  int retval ;
  u16 reg ;
  u8 val ;
  struct _ddebug descriptor ;
  struct device *tmp ;
  long tmp___0 ;
  struct _ddebug descriptor___0 ;
  struct device *tmp___1 ;
  long tmp___2 ;

  {
  reg = 0U;
  val = 0U;
  retval = rtsx_write_register(chip, 64516, 3, 3);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c",
                "rts5208_init", 789);
    return (retval);
  } else {

  }
  retval = rtsx_read_register(chip, 64516, & val);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c",
                "rts5208_init", 794);
    return (retval);
  } else {

  }
  chip->asic_code = (unsigned int )val == 0U;
  if (chip->asic_code != 0) {
    retval = rtsx_read_phy_register(chip, 28, & reg);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c",
                  "rts5208_init", 802);
      return (1);
    } else {

    }
    descriptor.modname = "rts5208";
    descriptor.function = "rts5208_init";
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c";
    descriptor.format = "Value of phy register 0x1C is 0x%x\n";
    descriptor.lineno = 807U;
    descriptor.flags = 0U;
    tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
    if (tmp___0 != 0L) {
      tmp = rtsx_dev((struct rtsx_chip  const  *)chip);
      __dynamic_dev_dbg(& descriptor, (struct device  const  *)tmp, "Value of phy register 0x1C is 0x%x\n",
                        (int )reg);
    } else {

    }
    chip->ic_version = (unsigned int )((u8 )((int )reg >> 4)) & 7U;
    chip->phy_debug_mode = (int )reg & 1;
  } else {
    retval = rtsx_read_register(chip, 65152, & val);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c",
                  "rts5208_init", 814);
      return (retval);
    } else {

    }
    chip->ic_version = val;
    chip->phy_debug_mode = 0;
  }
  retval = rtsx_read_register(chip, 64513, & val);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c",
                "rts5208_init", 823);
    return (retval);
  } else {

  }
  descriptor___0.modname = "rts5208";
  descriptor___0.function = "rts5208_init";
  descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c";
  descriptor___0.format = "PDINFO: 0x%x\n";
  descriptor___0.lineno = 826U;
  descriptor___0.flags = 0U;
  tmp___2 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
  if (tmp___2 != 0L) {
    tmp___1 = rtsx_dev((struct rtsx_chip  const  *)chip);
    __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)tmp___1, "PDINFO: 0x%x\n",
                      (int )val);
  } else {

  }
  chip->aux_pwr_exist = (int )val & 1;
  retval = rtsx_read_register(chip, 65104, & val);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c",
                "rts5208_init", 831);
    return (retval);
  } else {

  }
  chip->hw_bypass_sd = (int )val & 1;
  pci_read_config_byte((struct pci_dev  const  *)(chip->rtsx)->pci, 14, & val);
  if ((int )((signed char )val) < 0) {
    chip->sdio_func_exist = chip->sdio_func_exist | 1;
  } else {
    chip->sdio_func_exist = chip->sdio_func_exist & -2;
  }
  if (chip->use_hw_setting != 0) {
    retval = rtsx_read_register(chip, 65115, & val);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c",
                  "rts5208_init", 845);
      return (retval);
    } else {

    }
    chip->auto_delink_en = (int )((signed char )val) < 0;
  } else {

  }
  return (0);
}
}
static int rts5288_init(struct rtsx_chip *chip ) 
{ 
  int retval ;
  u8 val ;
  u8 max_func ;
  u32 lval ;
  struct _ddebug descriptor ;
  struct device *tmp ;
  long tmp___0 ;
  struct _ddebug descriptor___0 ;
  struct device *tmp___1 ;
  long tmp___2 ;
  struct _ddebug descriptor___1 ;
  struct device *tmp___3 ;
  long tmp___4 ;

  {
  val = 0U;
  lval = 0U;
  retval = rtsx_write_register(chip, 64516, 3, 3);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c",
                "rts5288_init", 862);
    return (retval);
  } else {

  }
  retval = rtsx_read_register(chip, 64516, & val);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c",
                "rts5288_init", 867);
    return (retval);
  } else {

  }
  chip->asic_code = (unsigned int )val == 0U;
  chip->ic_version = 0U;
  chip->phy_debug_mode = 0;
  retval = rtsx_read_register(chip, 64513, & val);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c",
                "rts5288_init", 877);
    return (retval);
  } else {

  }
  descriptor.modname = "rts5208";
  descriptor.function = "rts5288_init";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c";
  descriptor.format = "PDINFO: 0x%x\n";
  descriptor.lineno = 880U;
  descriptor.flags = 0U;
  tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp___0 != 0L) {
    tmp = rtsx_dev((struct rtsx_chip  const  *)chip);
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)tmp, "PDINFO: 0x%x\n",
                      (int )val);
  } else {

  }
  chip->aux_pwr_exist = (int )val & 1;
  retval = rtsx_read_register(chip, 64850, & val);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c",
                "rts5288_init", 885);
    return (retval);
  } else {

  }
  descriptor___0.modname = "rts5208";
  descriptor___0.function = "rts5288_init";
  descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c";
  descriptor___0.format = "CARD_SHARE_MODE: 0x%x\n";
  descriptor___0.lineno = 888U;
  descriptor___0.flags = 0U;
  tmp___2 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
  if (tmp___2 != 0L) {
    tmp___1 = rtsx_dev((struct rtsx_chip  const  *)chip);
    __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)tmp___1, "CARD_SHARE_MODE: 0x%x\n",
                      (int )val);
  } else {

  }
  chip->baro_pkg = ((int )val & 4) == 0;
  retval = rtsx_read_register(chip, 65114, & val);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c",
                "rts5288_init", 893);
    return (retval);
  } else {

  }
  chip->hw_bypass_sd = ((int )val & 16) != 0;
  retval = rtsx_read_cfg_dw(chip, 0, 1816, & lval);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c",
                "rts5288_init", 900);
    return (1);
  } else {

  }
  max_func = (unsigned int )((unsigned char )(lval >> 29)) & 7U;
  descriptor___1.modname = "rts5208";
  descriptor___1.function = "rts5288_init";
  descriptor___1.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c";
  descriptor___1.format = "Max function number: %d\n";
  descriptor___1.lineno = 905U;
  descriptor___1.flags = 0U;
  tmp___4 = ldv__builtin_expect((long )descriptor___1.flags & 1L, 0L);
  if (tmp___4 != 0L) {
    tmp___3 = rtsx_dev((struct rtsx_chip  const  *)chip);
    __dynamic_dev_dbg(& descriptor___1, (struct device  const  *)tmp___3, "Max function number: %d\n",
                      (int )max_func);
  } else {

  }
  if ((unsigned int )max_func == 2U) {
    chip->sdio_func_exist = chip->sdio_func_exist | 1;
  } else {
    chip->sdio_func_exist = chip->sdio_func_exist & -2;
  }
  if (chip->use_hw_setting != 0) {
    retval = rtsx_read_register(chip, 65115, & val);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c",
                  "rts5288_init", 914);
      return (retval);
    } else {

    }
    chip->auto_delink_en = (int )((signed char )val) < 0;
    if (chip->baro_pkg == 1) {
      chip->lun_mode = 2U;
    } else {
      chip->lun_mode = 0U;
    }
  } else {

  }
  return (0);
}
}
int rtsx_init_chip(struct rtsx_chip *chip ) 
{ 
  struct sd_info *sd_card ;
  struct xd_info *xd_card ;
  struct ms_info *ms_card ;
  int retval ;
  unsigned int i ;
  struct _ddebug descriptor ;
  struct device *tmp ;
  long tmp___0 ;
  int tmp___1 ;
  struct _ddebug descriptor___0 ;
  struct device *tmp___2 ;
  long tmp___3 ;
  int tmp___4 ;
  struct _ddebug descriptor___1 ;
  struct device *tmp___5 ;
  long tmp___6 ;
  struct task_struct *tmp___7 ;
  long volatile   __ret ;
  struct task_struct *tmp___8 ;
  struct task_struct *tmp___9 ;
  struct task_struct *tmp___10 ;
  struct task_struct *tmp___11 ;
  struct _ddebug descriptor___2 ;
  struct device *tmp___12 ;
  long tmp___13 ;
    klee_make_symbolic(&tmp___13, sizeof(long), "tmp___13");
  struct _ddebug descriptor___3 ;
  struct device *tmp___14 ;
  long tmp___15 ;
  struct _ddebug descriptor___4 ;
  struct device *tmp___16 ;
  long tmp___17 ;
    klee_make_symbolic(&tmp___17, sizeof(long), "tmp___17");
  struct _ddebug descriptor___5 ;
  struct device *tmp___18 ;
  long tmp___19 ;
    klee_make_symbolic(&tmp___19, sizeof(long), "tmp___19");
  struct _ddebug descriptor___6 ;
  struct device *tmp___20 ;
  long tmp___21 ;
    klee_make_symbolic(&tmp___21, sizeof(long), "tmp___21");
  struct _ddebug descriptor___7 ;
  struct device *tmp___22 ;
  long tmp___23 ;
    klee_make_symbolic(&tmp___23, sizeof(long), "tmp___23");
  struct _ddebug descriptor___8 ;
  struct device *tmp___24 ;
  long tmp___25 ;
    klee_make_symbolic(&tmp___25, sizeof(long), "tmp___25");
  struct _ddebug descriptor___9 ;
  struct device *tmp___26 ;
  long tmp___27 ;
    klee_make_symbolic(&tmp___27, sizeof(long), "tmp___27");
  struct _ddebug descriptor___10 ;
  struct device *tmp___28 ;
  long tmp___29 ;
    klee_make_symbolic(&tmp___29, sizeof(long), "tmp___29");
  struct _ddebug descriptor___11 ;
  struct device *tmp___30 ;
  long tmp___31 ;
    klee_make_symbolic(&tmp___31, sizeof(long), "tmp___31");
  struct _ddebug descriptor___12 ;
  struct device *tmp___32 ;
  long tmp___33 ;
    klee_make_symbolic(&tmp___33, sizeof(long), "tmp___33");
  struct _ddebug descriptor___13 ;
  struct device *tmp___34 ;
  long tmp___35 ;
    klee_make_symbolic(&tmp___35, sizeof(long), "tmp___35");

  {
  sd_card = & chip->sd_card;
  xd_card = & chip->xd_card;
  ms_card = & chip->ms_card;
  descriptor.modname = "rts5208";
  descriptor.function = "rtsx_init_chip";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c";
  descriptor.format = "Vendor ID: 0x%04x, Product ID: 0x%04x\n";
  descriptor.lineno = 937U;
  descriptor.flags = 0U;
  tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp___0 != 0L) {
    tmp = rtsx_dev((struct rtsx_chip  const  *)chip);
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)tmp, "Vendor ID: 0x%04x, Product ID: 0x%04x\n",
                      (int )chip->vendor_id, (int )chip->product_id);
  } else {

  }
  chip->ic_version = 0U;
  chip->msg_idx = 0;
  memset((void *)xd_card, 0, 56UL);
  memset((void *)sd_card, 0, 104UL);
  memset((void *)ms_card, 0, 240UL);
  chip->xd_reset_counter = 0;
  chip->sd_reset_counter = 0;
  chip->ms_reset_counter = 0;
  chip->xd_show_cnt = 10;
  chip->sd_show_cnt = 10;
  chip->ms_show_cnt = 10;
  chip->sd_io = 0U;
  chip->auto_delink_cnt = 0;
  chip->auto_delink_allowed = 1;
  chip->idle_counter = 0;
  chip->rtsx_stat = 0;
  chip->aspm_enabled = 0;
  chip->chip_insert_with_sdio = 0;
  chip->sdio_aspm = 0;
  chip->sdio_idle = 0;
  chip->sdio_counter = 0;
  chip->cur_card = 0;
  chip->phy_debug_mode = 0;
  chip->sdio_func_exist = 0;
  memset((void *)(& chip->sdio_raw_data), 0, 12UL);
  i = 0U;
  goto ldv_38633;
  ldv_38632: 
  set_sense_type(chip, i, 0);
  chip->rw_fail_cnt[i] = 0;
  i = i + 1U;
  ldv_38633: ;
  if (i <= 7U) {
    goto ldv_38632;
  } else {

  }
  tmp___1 = check_sd_speed_prior(chip->sd_speed_prior);
  if (tmp___1 == 0) {
    chip->sd_speed_prior = 17039875U;
  } else {

  }
  descriptor___0.modname = "rts5208";
  descriptor___0.function = "rtsx_init_chip";
  descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c";
  descriptor___0.format = "sd_speed_prior = 0x%08x\n";
  descriptor___0.lineno = 981U;
  descriptor___0.flags = 0U;
  tmp___3 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
  if (tmp___3 != 0L) {
    tmp___2 = rtsx_dev((struct rtsx_chip  const  *)chip);
    __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)tmp___2, "sd_speed_prior = 0x%08x\n",
                      chip->sd_speed_prior);
  } else {

  }
  tmp___4 = check_sd_current_prior(chip->sd_current_prior);
  if (tmp___4 == 0) {
    chip->sd_current_prior = 66051U;
  } else {

  }
  descriptor___1.modname = "rts5208";
  descriptor___1.function = "rtsx_init_chip";
  descriptor___1.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c";
  descriptor___1.format = "sd_current_prior = 0x%08x\n";
  descriptor___1.lineno = 987U;
  descriptor___1.flags = 0U;
  tmp___6 = ldv__builtin_expect((long )descriptor___1.flags & 1L, 0L);
  if (tmp___6 != 0L) {
    tmp___5 = rtsx_dev((struct rtsx_chip  const  *)chip);
    __dynamic_dev_dbg(& descriptor___1, (struct device  const  *)tmp___5, "sd_current_prior = 0x%08x\n",
                      chip->sd_current_prior);
  } else {

  }
  if (chip->sd_ddr_tx_phase > 31 || chip->sd_ddr_tx_phase < 0) {
    chip->sd_ddr_tx_phase = 0;
  } else {

  }
  if (chip->mmc_ddr_tx_phase > 31 || chip->mmc_ddr_tx_phase < 0) {
    chip->mmc_ddr_tx_phase = 0;
  } else {

  }
  retval = rtsx_write_register(chip, 64512, 1, 0);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c",
                "rtsx_init_chip", 997);
    return (retval);
  } else {

  }
  tmp___7 = get_current();
  tmp___7->task_state_change = 0UL;
  __ret = 1L;
  switch (8UL) {
  case 1UL: 
  tmp___8 = get_current();
  __asm__  volatile   ("xchgb %b0, %1\n": "+q" (__ret), "+m" (tmp___8->state): : "memory",
                       "cc");
  goto ldv_38639;
  case 2UL: 
  tmp___9 = get_current();
  __asm__  volatile   ("xchgw %w0, %1\n": "+r" (__ret), "+m" (tmp___9->state): : "memory",
                       "cc");
  goto ldv_38639;
  case 4UL: 
  tmp___10 = get_current();
  __asm__  volatile   ("xchgl %0, %1\n": "+r" (__ret), "+m" (tmp___10->state): : "memory",
                       "cc");
  goto ldv_38639;
  case 8UL: 
  tmp___11 = get_current();
  __asm__  volatile   ("xchgq %q0, %1\n": "+r" (__ret), "+m" (tmp___11->state): : "memory",
                       "cc");
  goto ldv_38639;
  default: 
  __xchg_wrong_size();
  }
  ldv_38639: 
  schedule_timeout(50L);
  retval = rtsx_write_register(chip, 64515, 7, 7);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c",
                "rtsx_init_chip", 1003);
    return (retval);
  } else {

  }
  descriptor___2.modname = "rts5208";
  descriptor___2.function = "rtsx_init_chip";
  descriptor___2.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c";
  descriptor___2.format = "chip->use_hw_setting = %d\n";
  descriptor___2.lineno = 1007U;
  descriptor___2.flags = 0U;
  tmp___13 = ldv__builtin_expect((long )descriptor___2.flags & 1L, 0L);
  if (tmp___13 != 0L) {
    tmp___12 = rtsx_dev((struct rtsx_chip  const  *)chip);
    __dynamic_dev_dbg(& descriptor___2, (struct device  const  *)tmp___12, "chip->use_hw_setting = %d\n",
                      chip->use_hw_setting);
  } else {

  }
  if ((unsigned int )chip->product_id == 21000U) {
    retval = rts5208_init(chip);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c",
                  "rtsx_init_chip", 1012);
      return (1);
    } else {

    }
  } else
  if ((unsigned int )chip->product_id == 21128U) {
    retval = rts5288_init(chip);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c",
                  "rtsx_init_chip", 1019);
      return (1);
    } else {

    }
  } else {

  }
  if (chip->ss_en == 2) {
    chip->ss_en = 0;
  } else {

  }
  descriptor___3.modname = "rts5208";
  descriptor___3.function = "rtsx_init_chip";
  descriptor___3.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c";
  descriptor___3.format = "chip->asic_code = %d\n";
  descriptor___3.lineno = 1027U;
  descriptor___3.flags = 0U;
  tmp___15 = ldv__builtin_expect((long )descriptor___3.flags & 1L, 0L);
  if (tmp___15 != 0L) {
    tmp___14 = rtsx_dev((struct rtsx_chip  const  *)chip);
    __dynamic_dev_dbg(& descriptor___3, (struct device  const  *)tmp___14, "chip->asic_code = %d\n",
                      chip->asic_code);
  } else {

  }
  descriptor___4.modname = "rts5208";
  descriptor___4.function = "rtsx_init_chip";
  descriptor___4.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c";
  descriptor___4.format = "chip->ic_version = 0x%x\n";
  descriptor___4.lineno = 1028U;
  descriptor___4.flags = 0U;
  tmp___17 = ldv__builtin_expect((long )descriptor___4.flags & 1L, 0L);
  if (tmp___17 != 0L) {
    tmp___16 = rtsx_dev((struct rtsx_chip  const  *)chip);
    __dynamic_dev_dbg(& descriptor___4, (struct device  const  *)tmp___16, "chip->ic_version = 0x%x\n",
                      (int )chip->ic_version);
  } else {

  }
  descriptor___5.modname = "rts5208";
  descriptor___5.function = "rtsx_init_chip";
  descriptor___5.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c";
  descriptor___5.format = "chip->phy_debug_mode = %d\n";
  descriptor___5.lineno = 1030U;
  descriptor___5.flags = 0U;
  tmp___19 = ldv__builtin_expect((long )descriptor___5.flags & 1L, 0L);
  if (tmp___19 != 0L) {
    tmp___18 = rtsx_dev((struct rtsx_chip  const  *)chip);
    __dynamic_dev_dbg(& descriptor___5, (struct device  const  *)tmp___18, "chip->phy_debug_mode = %d\n",
                      chip->phy_debug_mode);
  } else {

  }
  descriptor___6.modname = "rts5208";
  descriptor___6.function = "rtsx_init_chip";
  descriptor___6.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c";
  descriptor___6.format = "chip->aux_pwr_exist = %d\n";
  descriptor___6.lineno = 1032U;
  descriptor___6.flags = 0U;
  tmp___21 = ldv__builtin_expect((long )descriptor___6.flags & 1L, 0L);
  if (tmp___21 != 0L) {
    tmp___20 = rtsx_dev((struct rtsx_chip  const  *)chip);
    __dynamic_dev_dbg(& descriptor___6, (struct device  const  *)tmp___20, "chip->aux_pwr_exist = %d\n",
                      chip->aux_pwr_exist);
  } else {

  }
  descriptor___7.modname = "rts5208";
  descriptor___7.function = "rtsx_init_chip";
  descriptor___7.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c";
  descriptor___7.format = "chip->sdio_func_exist = %d\n";
  descriptor___7.lineno = 1034U;
  descriptor___7.flags = 0U;
  tmp___23 = ldv__builtin_expect((long )descriptor___7.flags & 1L, 0L);
  if (tmp___23 != 0L) {
    tmp___22 = rtsx_dev((struct rtsx_chip  const  *)chip);
    __dynamic_dev_dbg(& descriptor___7, (struct device  const  *)tmp___22, "chip->sdio_func_exist = %d\n",
                      chip->sdio_func_exist);
  } else {

  }
  descriptor___8.modname = "rts5208";
  descriptor___8.function = "rtsx_init_chip";
  descriptor___8.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c";
  descriptor___8.format = "chip->hw_bypass_sd = %d\n";
  descriptor___8.lineno = 1036U;
  descriptor___8.flags = 0U;
  tmp___25 = ldv__builtin_expect((long )descriptor___8.flags & 1L, 0L);
  if (tmp___25 != 0L) {
    tmp___24 = rtsx_dev((struct rtsx_chip  const  *)chip);
    __dynamic_dev_dbg(& descriptor___8, (struct device  const  *)tmp___24, "chip->hw_bypass_sd = %d\n",
                      chip->hw_bypass_sd);
  } else {

  }
  descriptor___9.modname = "rts5208";
  descriptor___9.function = "rtsx_init_chip";
  descriptor___9.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c";
  descriptor___9.format = "chip->aspm_l0s_l1_en = %d\n";
  descriptor___9.lineno = 1038U;
  descriptor___9.flags = 0U;
  tmp___27 = ldv__builtin_expect((long )descriptor___9.flags & 1L, 0L);
  if (tmp___27 != 0L) {
    tmp___26 = rtsx_dev((struct rtsx_chip  const  *)chip);
    __dynamic_dev_dbg(& descriptor___9, (struct device  const  *)tmp___26, "chip->aspm_l0s_l1_en = %d\n",
                      (int )chip->aspm_l0s_l1_en);
  } else {

  }
  descriptor___10.modname = "rts5208";
  descriptor___10.function = "rtsx_init_chip";
  descriptor___10.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c";
  descriptor___10.format = "chip->lun_mode = %d\n";
  descriptor___10.lineno = 1039U;
  descriptor___10.flags = 0U;
  tmp___29 = ldv__builtin_expect((long )descriptor___10.flags & 1L, 0L);
  if (tmp___29 != 0L) {
    tmp___28 = rtsx_dev((struct rtsx_chip  const  *)chip);
    __dynamic_dev_dbg(& descriptor___10, (struct device  const  *)tmp___28, "chip->lun_mode = %d\n",
                      (int )chip->lun_mode);
  } else {

  }
  descriptor___11.modname = "rts5208";
  descriptor___11.function = "rtsx_init_chip";
  descriptor___11.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c";
  descriptor___11.format = "chip->auto_delink_en = %d\n";
  descriptor___11.lineno = 1041U;
  descriptor___11.flags = 0U;
  tmp___31 = ldv__builtin_expect((long )descriptor___11.flags & 1L, 0L);
  if (tmp___31 != 0L) {
    tmp___30 = rtsx_dev((struct rtsx_chip  const  *)chip);
    __dynamic_dev_dbg(& descriptor___11, (struct device  const  *)tmp___30, "chip->auto_delink_en = %d\n",
                      chip->auto_delink_en);
  } else {

  }
  descriptor___12.modname = "rts5208";
  descriptor___12.function = "rtsx_init_chip";
  descriptor___12.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c";
  descriptor___12.format = "chip->ss_en = %d\n";
  descriptor___12.lineno = 1042U;
  descriptor___12.flags = 0U;
  tmp___33 = ldv__builtin_expect((long )descriptor___12.flags & 1L, 0L);
  if (tmp___33 != 0L) {
    tmp___32 = rtsx_dev((struct rtsx_chip  const  *)chip);
    __dynamic_dev_dbg(& descriptor___12, (struct device  const  *)tmp___32, "chip->ss_en = %d\n",
                      chip->ss_en);
  } else {

  }
  descriptor___13.modname = "rts5208";
  descriptor___13.function = "rtsx_init_chip";
  descriptor___13.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c";
  descriptor___13.format = "chip->baro_pkg = %d\n";
  descriptor___13.lineno = 1043U;
  descriptor___13.flags = 0U;
  tmp___35 = ldv__builtin_expect((long )descriptor___13.flags & 1L, 0L);
  if (tmp___35 != 0L) {
    tmp___34 = rtsx_dev((struct rtsx_chip  const  *)chip);
    __dynamic_dev_dbg(& descriptor___13, (struct device  const  *)tmp___34, "chip->baro_pkg = %d\n",
                      chip->baro_pkg);
  } else {

  }
  if ((unsigned int )chip->lun_mode == 1U) {
    chip->card2lun[4] = 0U;
    chip->card2lun[8] = 1U;
    chip->card2lun[16] = 255U;
    chip->lun2card[0] = 4U;
    chip->lun2card[1] = 8U;
    chip->max_lun = 1;
    chip->sdio_func_exist = chip->sdio_func_exist | 2;
  } else
  if ((unsigned int )chip->lun_mode == 2U) {
    chip->card2lun[4] = 0U;
    chip->card2lun[8] = 0U;
    chip->card2lun[16] = 255U;
    chip->lun2card[0] = 12U;
    chip->max_lun = 0;
  } else {
    chip->card2lun[16] = 0U;
    chip->card2lun[4] = 0U;
    chip->card2lun[8] = 0U;
    chip->lun2card[0] = 28U;
    chip->max_lun = 0;
  }
  retval = rtsx_reset_chip(chip);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c",
                "rtsx_init_chip", 1069);
    return (1);
  } else {

  }
  return (0);
}
}
void rtsx_release_chip(struct rtsx_chip *chip ) 
{ 


  {
  xd_free_l2p_tbl(chip);
  ms_free_l2p_tbl(chip);
  chip->card_exist = 0U;
  chip->card_ready = 0U;
  return;
}
}
__inline static void rtsx_blink_led(struct rtsx_chip *chip ) 
{ 


  {
  if ((unsigned int )chip->card_exist != 0U && (unsigned int )chip->blink_led != 0U) {
    if (chip->led_toggle_counter <= 5) {
      chip->led_toggle_counter = chip->led_toggle_counter + 1;
    } else {
      chip->led_toggle_counter = 0;
      toggle_gpio(chip, 0);
    }
  } else {

  }
  return;
}
}
static void rtsx_monitor_aspm_config(struct rtsx_chip *chip ) 
{ 
  bool reg_changed ;
  bool maybe_support_aspm ;
  u32 tmp ;
  u8 reg0 ;
  u8 reg1 ;
  struct _ddebug descriptor ;
  struct device *tmp___0 ;
  long tmp___1 ;

  {
  tmp = 0U;
  reg0 = 0U;
  reg1 = 0U;
  maybe_support_aspm = 0;
  reg_changed = 0;
  pci_read_config_byte((struct pci_dev  const  *)(chip->rtsx)->pci, 128, & reg0);
  if ((int )chip->aspm_level[0] != (int )reg0) {
    reg_changed = 1;
    chip->aspm_level[0] = reg0;
  } else {

  }
  if (chip->sdio_func_exist & 1 && (chip->sdio_func_exist & 2) == 0) {
    rtsx_read_cfg_dw(chip, 1, 192, & tmp);
    reg1 = (unsigned char )tmp;
    if ((int )chip->aspm_level[1] != (int )reg1) {
      reg_changed = 1;
      chip->aspm_level[1] = reg1;
    } else {

    }
    if (((int )reg0 & 3) != 0 && ((int )reg1 & 3) != 0) {
      maybe_support_aspm = 1;
    } else {

    }
  } else
  if (((int )reg0 & 3) != 0) {
    maybe_support_aspm = 1;
  } else {

  }
  if ((int )reg_changed) {
    if ((int )maybe_support_aspm) {
      chip->aspm_l0s_l1_en = 3U;
    } else {

    }
    descriptor.modname = "rts5208";
    descriptor.function = "rtsx_monitor_aspm_config";
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c";
    descriptor.format = "aspm_level[0] = 0x%02x, aspm_level[1] = 0x%02x\n";
    descriptor.lineno = 1132U;
    descriptor.flags = 0U;
    tmp___1 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
    if (tmp___1 != 0L) {
      tmp___0 = rtsx_dev((struct rtsx_chip  const  *)chip);
      __dynamic_dev_dbg(& descriptor, (struct device  const  *)tmp___0, "aspm_level[0] = 0x%02x, aspm_level[1] = 0x%02x\n",
                        (int )chip->aspm_level[0], (int )chip->aspm_level[1]);
    } else {

    }
    if ((unsigned int )chip->aspm_l0s_l1_en != 0U) {
      chip->aspm_enabled = 1;
    } else {
      chip->aspm_enabled = 0;
      chip->sdio_aspm = 0;
    }
    rtsx_write_register(chip, 65111, 255, (int )((u8 )((int )((signed char )((unsigned int )chip->aspm_level[0] | 48U)) | (int )((signed char )((int )chip->aspm_level[1] << 2)))));
  } else {

  }
  return;
}
}
static void rtsx_manage_ocp(struct rtsx_chip *chip ) 
{ 


  {
  if (chip->ocp_int == 0U) {
    return;
  } else {

  }
  rtsx_read_register(chip, 64534, & chip->ocp_stat);
  if (((int )chip->card_exist & 4) != 0) {
    sd_power_off_card3v3(chip);
  } else
  if (((int )chip->card_exist & 8) != 0) {
    ms_power_off_card3v3(chip);
  } else
  if (((int )chip->card_exist & 16) != 0) {
    xd_power_off_card3v3(chip);
  } else {

  }
  chip->ocp_int = 0U;
  return;
}
}
static void rtsx_manage_sd_lock(struct rtsx_chip *chip ) 
{ 
  struct sd_info *sd_card ;
  u8 val ;

  {
  sd_card = & chip->sd_card;
  if ((unsigned int )sd_card->sd_erase_status == 0U) {
    return;
  } else {

  }
  if (((int )chip->card_exist & 4) != 0) {
    rtsx_read_register(chip, 64816, & val);
    if (((int )val & 2) != 0) {
      sd_card->sd_erase_status = 0U;
      sd_card->sd_lock_notify = 1U;
      chip->need_reinit = chip->need_reinit | 4UL;
    } else {

    }
  } else {
    sd_card->sd_erase_status = 0U;
  }
  return;
}
}
static bool rtsx_is_ss_allowed(struct rtsx_chip *chip ) 
{ 
  u32 val ;

  {
  if (chip->ss_en == 0 || (unsigned int )chip->product_id == 21128U) {
    return (0);
  } else {

  }
  if (chip->sdio_func_exist & 1 && (chip->sdio_func_exist & 2) == 0) {
    rtsx_read_cfg_dw(chip, 1, 4, & val);
    if ((val & 7U) != 0U) {
      return (0);
    } else {

    }
  } else {

  }
  return (1);
}
}
static void rtsx_manage_ss(struct rtsx_chip *chip ) 
{ 
  bool tmp ;
  int tmp___0 ;

  {
  tmp = rtsx_is_ss_allowed(chip);
  if (tmp) {
    tmp___0 = 0;
  } else {
    tmp___0 = 1;
  }
  if (tmp___0 || (unsigned int )chip->sd_io != 0U) {
    return;
  } else {

  }
  if ((unsigned int )chip->rtsx_stat != 1U) {
    chip->ss_counter = 0;
    return;
  } else {

  }
  if (chip->ss_counter < chip->ss_idle_period / 30) {
    chip->ss_counter = chip->ss_counter + 1;
  } else {
    rtsx_exclusive_enter_ss(chip);
  }
  return;
}
}
static void rtsx_manage_aspm(struct rtsx_chip *chip ) 
{ 
  u8 data ;
  struct _ddebug descriptor ;
  struct device *tmp ;
  long tmp___0 ;

  {
  if ((unsigned int )chip->product_id != 21000U) {
    return;
  } else {

  }
  rtsx_monitor_aspm_config(chip);
  if ((((chip->sdio_func_exist & 1) == 0 || (chip->sdio_func_exist & 2) != 0) || (unsigned int )chip->aspm_l0s_l1_en == 0U) || chip->dynamic_aspm == 0) {
    return;
  } else {

  }
  if ((unsigned int )chip->sd_io != 0U) {
    dynamic_configure_sdio_aspm(chip);
    return;
  } else {

  }
  if (chip->sdio_aspm != 0) {
    return;
  } else {

  }
  descriptor.modname = "rts5208";
  descriptor.function = "rtsx_manage_aspm";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c";
  descriptor.format = "SDIO enter ASPM!\n";
  descriptor.lineno = 1241U;
  descriptor.flags = 0U;
  tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp___0 != 0L) {
    tmp = rtsx_dev((struct rtsx_chip  const  *)chip);
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)tmp, "SDIO enter ASPM!\n");
  } else {

  }
  data = (u8 )((int )((signed char )((int )chip->aspm_level[1] << 2)) | 48);
  rtsx_write_register(chip, 65111, 252, (int )data);
  chip->sdio_aspm = 1;
  return;
}
}
static void rtsx_manage_idle(struct rtsx_chip *chip ) 
{ 
  struct _ddebug descriptor ;
  struct device *tmp ;
  long tmp___0 ;

  {
  if (chip->idle_counter <= 9) {
    chip->idle_counter = chip->idle_counter + 1;
    return;
  } else {

  }
  if ((unsigned int )chip->rtsx_stat == 1U) {
    return;
  } else {

  }
  descriptor.modname = "rts5208";
  descriptor.function = "rtsx_manage_idle";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c";
  descriptor.format = "Idle state!\n";
  descriptor.lineno = 1258U;
  descriptor.flags = 0U;
  tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp___0 != 0L) {
    tmp = rtsx_dev((struct rtsx_chip  const  *)chip);
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)tmp, "Idle state!\n");
  } else {

  }
  chip->rtsx_stat = 1;
  chip->led_toggle_counter = 0;
  rtsx_force_power_on(chip, 1);
  turn_off_led(chip, 0);
  if ((chip->auto_power_down != 0 && (unsigned int )chip->card_ready == 0U) && (unsigned int )chip->sd_io == 0U) {
    rtsx_force_power_down(chip, 3);
  } else {

  }
  return;
}
}
static void rtsx_manage_2lun_mode(struct rtsx_chip *chip ) 
{ 
  u8 sd_oc ;
  u8 ms_oc ;
  struct _ddebug descriptor ;
  struct device *tmp ;
  long tmp___0 ;

  {
  sd_oc = (unsigned int )chip->ocp_stat & 6U;
  ms_oc = (unsigned int )chip->ocp_stat & 96U;
  if ((unsigned int )sd_oc != 0U || (unsigned int )ms_oc != 0U) {
    descriptor.modname = "rts5208";
    descriptor.function = "rtsx_manage_2lun_mode";
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c";
    descriptor.format = "Over current, OCPSTAT is 0x%x\n";
    descriptor.lineno = 1282U;
    descriptor.flags = 0U;
    tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
    if (tmp___0 != 0L) {
      tmp = rtsx_dev((struct rtsx_chip  const  *)chip);
      __dynamic_dev_dbg(& descriptor, (struct device  const  *)tmp, "Over current, OCPSTAT is 0x%x\n",
                        (int )chip->ocp_stat);
    } else {

    }
  } else {

  }
  if ((unsigned int )sd_oc != 0U && ((int )chip->card_exist & 4) != 0) {
    rtsx_write_register(chip, 64853, 4, 0);
    card_power_off(chip, 4);
    chip->card_fail = (u8 )((unsigned int )chip->card_fail | 4U);
  } else {

  }
  if ((unsigned int )ms_oc != 0U && ((int )chip->card_exist & 8) != 0) {
    rtsx_write_register(chip, 64853, 8, 0);
    card_power_off(chip, 8);
    chip->card_fail = (u8 )((unsigned int )chip->card_fail | 8U);
  } else {

  }
  return;
}
}
static void rtsx_manage_1lun_mode(struct rtsx_chip *chip ) 
{ 
  struct _ddebug descriptor ;
  struct device *tmp ;
  long tmp___0 ;

  {
  if (((int )chip->ocp_stat & 6) == 0) {
    return;
  } else {

  }
  descriptor.modname = "rts5208";
  descriptor.function = "rtsx_manage_1lun_mode";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c";
  descriptor.format = "Over current, OCPSTAT is 0x%x\n";
  descriptor.lineno = 1305U;
  descriptor.flags = 0U;
  tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp___0 != 0L) {
    tmp = rtsx_dev((struct rtsx_chip  const  *)chip);
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)tmp, "Over current, OCPSTAT is 0x%x\n",
                      (int )chip->ocp_stat);
  } else {

  }
  if (((int )chip->card_exist & 4) != 0) {
    rtsx_write_register(chip, 64853, 4, 0);
    chip->card_fail = (u8 )((unsigned int )chip->card_fail | 4U);
  } else
  if (((int )chip->card_exist & 8) != 0) {
    rtsx_write_register(chip, 64853, 8, 0);
    chip->card_fail = (u8 )((unsigned int )chip->card_fail | 8U);
  } else
  if (((int )chip->card_exist & 16) != 0) {
    rtsx_write_register(chip, 64853, 2, 0);
    chip->card_fail = (u8 )((unsigned int )chip->card_fail | 16U);
  } else {

  }
  card_power_off(chip, 4);
  return;
}
}
static void rtsx_delink_stage1(struct rtsx_chip *chip , int enter_L1 , int stage3_cnt ) 
{ 
  u8 val ;
  struct _ddebug descriptor ;
  struct device *tmp ;
  long tmp___0 ;
  struct _ddebug descriptor___0 ;
  struct device *tmp___1 ;
  long tmp___2 ;

  {
  chip->idle_counter = 0;
  chip->rtsx_stat = 4;
  if (chip->asic_code != 0 && (unsigned int )chip->product_id == 21000U) {
    rtsx_set_phy_reg_bit(chip, 28, 2);
  } else {

  }
  if ((unsigned int )chip->card_exist != 0U) {
    descriptor.modname = "rts5208";
    descriptor.function = "rtsx_delink_stage1";
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c";
    descriptor.format = "False card inserted, do force delink\n";
    descriptor.lineno = 1332U;
    descriptor.flags = 0U;
    tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
    if (tmp___0 != 0L) {
      tmp = rtsx_dev((struct rtsx_chip  const  *)chip);
      __dynamic_dev_dbg(& descriptor, (struct device  const  *)tmp, "False card inserted, do force delink\n");
    } else {

    }
  } else {
    descriptor___0.modname = "rts5208";
    descriptor___0.function = "rtsx_delink_stage1";
    descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c";
    descriptor___0.format = "No card inserted, do delink\n";
    descriptor___0.lineno = 1334U;
    descriptor___0.flags = 0U;
    tmp___2 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
    if (tmp___2 != 0L) {
      tmp___1 = rtsx_dev((struct rtsx_chip  const  *)chip);
      __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)tmp___1, "No card inserted, do delink\n");
    } else {

    }
  }
  if (enter_L1 != 0) {
    rtsx_write_register(chip, 65120, 3, 1);
  } else {

  }
  if ((unsigned int )chip->card_exist != 0U) {
    val = 2U;
  } else {
    val = 10U;
  }
  rtsx_write_register(chip, 65115, (int )val, (int )val);
  if (enter_L1 != 0) {
    rtsx_enter_L1(chip);
  } else {

  }
  if ((unsigned int )chip->card_exist != 0U) {
    chip->auto_delink_cnt = stage3_cnt + 1;
  } else {

  }
  return;
}
}
static void rtsx_delink_stage(struct rtsx_chip *chip ) 
{ 
  int delink_stage1_cnt ;
    klee_make_symbolic(&delink_stage1_cnt, sizeof(int), "delink_stage1_cnt");
  int delink_stage2_cnt ;
    klee_make_symbolic(&delink_stage2_cnt, sizeof(int), "delink_stage2_cnt");
  int delink_stage3_cnt ;
    klee_make_symbolic(&delink_stage3_cnt, sizeof(int), "delink_stage3_cnt");
  int enter_L1 ;
    klee_make_symbolic(&enter_L1, sizeof(int), "enter_L1");
  struct _ddebug descriptor ;
  struct device *tmp ;
  long tmp___0 ;

  {
  if ((((chip->auto_delink_en == 0 || chip->auto_delink_allowed == 0) || (unsigned int )chip->card_ready != 0U) || (unsigned int )chip->card_ejected != 0U) || (unsigned int )chip->sd_io != 0U) {
    chip->auto_delink_cnt = 0;
    return;
  } else {

  }
  enter_L1 = chip->auto_delink_in_L1 != 0 && ((unsigned int )chip->aspm_l0s_l1_en != 0U || chip->ss_en != 0);
  delink_stage1_cnt = chip->delink_stage1_step;
  delink_stage2_cnt = chip->delink_stage2_step + delink_stage1_cnt;
  delink_stage3_cnt = chip->delink_stage3_step + delink_stage2_cnt;
  if (chip->auto_delink_cnt > delink_stage3_cnt) {
    return;
  } else {

  }
  if (chip->auto_delink_cnt == delink_stage1_cnt) {
    rtsx_delink_stage1(chip, enter_L1, delink_stage3_cnt);
  } else {

  }
  if (chip->auto_delink_cnt == delink_stage2_cnt) {
    descriptor.modname = "rts5208";
    descriptor.function = "rtsx_delink_stage";
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c";
    descriptor.format = "Try to do force delink\n";
    descriptor.lineno = 1378U;
    descriptor.flags = 0U;
    tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
    if (tmp___0 != 0L) {
      tmp = rtsx_dev((struct rtsx_chip  const  *)chip);
      __dynamic_dev_dbg(& descriptor, (struct device  const  *)tmp, "Try to do force delink\n");
    } else {

    }
    if (enter_L1 != 0) {
      rtsx_exit_L1(chip);
    } else {

    }
    if (chip->asic_code != 0 && (unsigned int )chip->product_id == 21000U) {
      rtsx_set_phy_reg_bit(chip, 28, 2);
    } else {

    }
    rtsx_write_register(chip, 65115, 10, 10);
  } else {

  }
  chip->auto_delink_cnt = chip->auto_delink_cnt + 1;
  return;
}
}
void rtsx_polling_func(struct rtsx_chip *chip ) 
{ 
  u8 val ;

  {
  if ((unsigned int )chip->rtsx_stat == 5U) {
    return;
  } else {

  }
  if ((unsigned int )chip->rtsx_stat == 4U) {
    goto delink_stage;
  } else {

  }
  if (chip->polling_config != 0) {
    pci_read_config_byte((struct pci_dev  const  *)(chip->rtsx)->pci, 0, & val);
  } else {

  }
  if ((unsigned int )chip->rtsx_stat == 3U) {
    return;
  } else {

  }
  rtsx_manage_ocp(chip);
  rtsx_manage_sd_lock(chip);
  rtsx_init_cards(chip);
  rtsx_manage_ss(chip);
  rtsx_manage_aspm(chip);
  rtsx_manage_idle(chip);
  switch ((unsigned int )chip->rtsx_stat) {
  case 2U: 
  rtsx_blink_led(chip);
  do_remaining_work(chip);
  goto ldv_38735;
  case 1U: ;
  if ((unsigned int )chip->sd_io != 0U && (unsigned int )chip->sd_int == 0U) {
    try_to_switch_sdio_ctrl(chip);
  } else {

  }
  rtsx_enable_aspm(chip);
  goto ldv_38735;
  default: ;
  goto ldv_38735;
  }
  ldv_38735: ;
  if ((unsigned int )chip->lun_mode == 1U) {
    rtsx_manage_2lun_mode(chip);
  } else {
    rtsx_manage_1lun_mode(chip);
  }
  delink_stage: 
  rtsx_delink_stage(chip);
  return;
}
}
void rtsx_undo_delink(struct rtsx_chip *chip ) 
{ 


  {
  chip->auto_delink_allowed = 0;
  rtsx_write_register(chip, 65115, 10, 0);
  return;
}
}
void rtsx_stop_cmd(struct rtsx_chip *chip , int card ) 
{ 
  int i ;
  int addr ;
  u32 reg ;
  struct _ddebug descriptor ;
  struct device *tmp ;
  long tmp___0 ;
  u16 addr___0 ;
  u8 val ;
  struct _ddebug descriptor___0 ;
  struct device *tmp___1 ;
  long tmp___2 ;

  {
  i = 0;
  goto ldv_38751;
  ldv_38750: 
  addr = i * 4;
  reg = ioread32((chip->rtsx)->remap_addr + (unsigned long )addr);
  descriptor.modname = "rts5208";
  descriptor.function = "rtsx_stop_cmd";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c";
  descriptor.format = "BAR (0x%02x): 0x%08x\n";
  descriptor.lineno = 1472U;
  descriptor.flags = 0U;
  tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp___0 != 0L) {
    tmp = rtsx_dev((struct rtsx_chip  const  *)chip);
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)tmp, "BAR (0x%02x): 0x%08x\n",
                      addr, reg);
  } else {

  }
  i = i + 1;
  ldv_38751: ;
  if (i <= 8) {
    goto ldv_38750;
  } else {

  }
  iowrite32(268435456U, (chip->rtsx)->remap_addr + 4UL);
  iowrite32(268435456U, (chip->rtsx)->remap_addr + 12UL);
  i = 0;
  goto ldv_38757;
  ldv_38756: 
  addr___0 = (unsigned int )((u16 )i) + 65056U;
  rtsx_read_register(chip, (int )addr___0, & val);
  descriptor___0.modname = "rts5208";
  descriptor___0.function = "rtsx_stop_cmd";
  descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c";
  descriptor___0.format = "0x%04X: 0x%02x\n";
  descriptor___0.lineno = 1482U;
  descriptor___0.flags = 0U;
  tmp___2 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
  if (tmp___2 != 0L) {
    tmp___1 = rtsx_dev((struct rtsx_chip  const  *)chip);
    __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)tmp___1, "0x%04X: 0x%02x\n",
                      (int )addr___0, (int )val);
  } else {

  }
  i = i + 1;
  ldv_38757: ;
  if (i <= 15) {
    goto ldv_38756;
  } else {

  }
  rtsx_write_register(chip, 65068, 128, 128);
  rtsx_write_register(chip, 65076, 128, 128);
  return;
}
}
int rtsx_write_register(struct rtsx_chip *chip , u16 addr , u8 mask , u8 data ) 
{ 
  int i ;
  u32 val ;

  {
  val = 3221225472U;
  val = (((unsigned int )addr & 16383U) << 16) | val;
  val = ((unsigned int )mask << 8) | val;
  val = (u32 )data | val;
  iowrite32(val, (chip->rtsx)->remap_addr + 16UL);
  i = 0;
  goto ldv_38769;
  ldv_38768: 
  val = ioread32((chip->rtsx)->remap_addr + 16UL);
  if ((int )val >= 0) {
    if ((int )((unsigned char )val) != (int )data) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c",
                  "rtsx_write_register", 1506);
      return (1);
    } else {

    }
    return (0);
  } else {

  }
  i = i + 1;
  ldv_38769: ;
  if (i <= 1023) {
    goto ldv_38768;
  } else {

  }
  _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c",
              "rtsx_write_register", 1514);
  return (2);
}
}
int rtsx_read_register(struct rtsx_chip *chip , u16 addr , u8 *data ) 
{ 
  u32 val ;
  int i ;

  {
  val = 2147483648U;
  if ((unsigned long )data != (unsigned long )((u8 *)0U)) {
    *data = 0U;
  } else {

  }
  val = (((unsigned int )addr & 16383U) << 16) | val;
  iowrite32(val, (chip->rtsx)->remap_addr + 16UL);
  i = 0;
  goto ldv_38780;
  ldv_38779: 
  val = ioread32((chip->rtsx)->remap_addr + 16UL);
  if ((int )val >= 0) {
    goto ldv_38778;
  } else {

  }
  i = i + 1;
  ldv_38780: ;
  if (i <= 1023) {
    goto ldv_38779;
  } else {

  }
  ldv_38778: ;
  if (i > 1023) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c",
                "rtsx_read_register", 1537);
    return (2);
  } else {

  }
  if ((unsigned long )data != (unsigned long )((u8 *)0U)) {
    *data = (unsigned char )val;
  } else {

  }
  return (0);
}
}
int rtsx_write_cfg_dw(struct rtsx_chip *chip , u8 func_no , u16 addr , u32 mask ,
                      u32 val ) 
{ 
  int retval ;
  u8 mode ;
  u8 tmp ;
  int i ;

  {
  mode = 0U;
  i = 0;
  goto ldv_38795;
  ldv_38794: ;
  if ((mask & 255U) != 0U) {
    retval = rtsx_write_register(chip, (int )((unsigned int )((u16 )i) + 65079U),
                                 255, (int )((unsigned char )val) & (int )((unsigned char )mask));
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c",
                  "rtsx_write_cfg_dw", 1560);
      return (retval);
    } else {

    }
    mode = (u8 )((int )((signed char )(1 << i)) | (int )((signed char )mode));
  } else {

  }
  mask = mask >> 8;
  val = val >> 8;
  i = i + 1;
  ldv_38795: ;
  if (i <= 3) {
    goto ldv_38794;
  } else {

  }

  if ((unsigned int )mode != 0U) {
    retval = rtsx_write_register(chip, 65077, 255, (int )((unsigned char )addr));
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c",
                  "rtsx_write_cfg_dw", 1572);
      return (retval);
    } else {

    }
    retval = rtsx_write_register(chip, 65078, 255, (int )((unsigned char )((int )addr >> 8)));
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c",
                  "rtsx_write_cfg_dw", 1578);
      return (retval);
    } else {

    }
    retval = rtsx_write_register(chip, 65083, 255, (int )((u8 )((int )((signed char )((unsigned int )mode | 128U)) | (int )((signed char )(((int )func_no & 3) << 4)))));
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c",
                  "rtsx_write_cfg_dw", 1585);
      return (retval);
    } else {

    }
    i = 0;
    goto ldv_38799;
    ldv_38798: 
    retval = rtsx_read_register(chip, 65083, & tmp);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c",
                  "rtsx_write_cfg_dw", 1592);
      return (retval);
    } else {

    }
    if ((int )((signed char )tmp) >= 0) {
      goto ldv_38797;
    } else {

    }
    i = i + 1;
    ldv_38799: ;
    if (i <= 1023) {
      goto ldv_38798;
    } else {

    }
    ldv_38797: ;
  } else {

  }
  return (0);
}
}
int rtsx_read_cfg_dw(struct rtsx_chip *chip , u8 func_no , u16 addr , u32 *val ) 
{ 
  int retval ;
  int i ;
  u8 tmp ;
  u32 data ;

  {
  data = 0U;
  retval = rtsx_write_register(chip, 65077, 255, (int )((unsigned char )addr));
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c",
                "rtsx_read_cfg_dw", 1612);
    return (retval);
  } else {

  }
  retval = rtsx_write_register(chip, 65078, 255, (int )((unsigned char )((int )addr >> 8)));
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c",
                "rtsx_read_cfg_dw", 1617);
    return (retval);
  } else {

  }
  retval = rtsx_write_register(chip, 65083, 255, (int )((u8 )((int )((signed char )(((int )func_no & 3) << 4)) | -128)));
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c",
                "rtsx_read_cfg_dw", 1623);
    return (retval);
  } else {

  }
  i = 0;
  goto ldv_38813;
  ldv_38812: 
  retval = rtsx_read_register(chip, 65083, & tmp);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c",
                "rtsx_read_cfg_dw", 1630);
    return (retval);
  } else {

  }
  if ((int )((signed char )tmp) >= 0) {
    goto ldv_38811;
  } else {

  }
  i = i + 1;
  ldv_38813: ;
  if (i <= 1023) {
    goto ldv_38812;
  } else {

  }
  ldv_38811: 
  i = 0;
  goto ldv_38815;
  ldv_38814: 
  retval = rtsx_read_register(chip, (int )((unsigned int )((u16 )i) + 65079U), & tmp);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c",
                "rtsx_read_cfg_dw", 1640);
    return (retval);
  } else {

  }
  data = ((unsigned int )tmp << i * 8) | data;
  i = i + 1;
  ldv_38815: ;
  if (i <= 3) {
    goto ldv_38814;
  } else {

  }

  if ((unsigned long )val != (unsigned long )((u32 *)0U)) {
    *val = data;
  } else {

  }
  return (0);
}
}
int rtsx_write_cfg_seq(struct rtsx_chip *chip , u8 func , u16 addr , u8 *buf , int len ) 
{ 
  u32 *data ;
  u32 *mask ;
  u16 offset ;
  u16 aligned_addr ;
  int dw_len ;
    klee_make_symbolic(&dw_len, sizeof(int), "dw_len");
  int i ;
  int j ;
    klee_make_symbolic(&j, sizeof(int), "j");
  int retval ;
  struct _ddebug descriptor ;
  struct device *tmp ;
  long tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  struct _ddebug descriptor___0 ;
  long tmp___3 ;
  struct _ddebug descriptor___1 ;
  long tmp___4 ;

  {
  offset = (unsigned int )addr & 3U;
  aligned_addr = (int )addr - (int )offset;
  if ((unsigned long )buf == (unsigned long )((u8 *)0U)) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c",
                "rtsx_write_cfg_seq", 1662);
    return (3);
  } else {

  }
  if (((unsigned int )((int )offset + len) & 3U) != 0U) {
    dw_len = ((int )offset + len) / 4 + 1;
  } else {
    dw_len = ((int )offset + len) / 4;
  }
  descriptor.modname = "rts5208";
  descriptor.function = "rtsx_write_cfg_seq";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c";
  descriptor.format = "dw_len = %d\n";
  descriptor.lineno = 1671U;
  descriptor.flags = 0U;
  tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp___0 != 0L) {
    tmp = rtsx_dev((struct rtsx_chip  const  *)chip);
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)tmp, "dw_len = %d\n",
                      dw_len);
  } else {

  }
  tmp___1 = vzalloc((unsigned long )(dw_len * 4));
  data = (u32 *)tmp___1;
  if ((unsigned long )data == (unsigned long )((u32 *)0U)) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c",
                "rtsx_write_cfg_seq", 1675);
    return (3);
  } else {

  }
  tmp___2 = vzalloc((unsigned long )(dw_len * 4));
  mask = (u32 *)tmp___2;
  if ((unsigned long )mask == (unsigned long )((u32 *)0U)) {
    vfree((void const   *)data);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c",
                "rtsx_write_cfg_seq", 1682);
    return (3);
  } else {

  }
  j = 0;
  i = 0;
  goto ldv_38835;
  ldv_38834: 
  *(mask + (unsigned long )j) = *(mask + (unsigned long )j) | (u32 )(255 << (int )offset * 8);
  *(data + (unsigned long )j) = *(data + (unsigned long )j) | (u32 )((int )*(buf + (unsigned long )i) << (int )offset * 8);
  offset = (u16 )((int )offset + 1);
  if ((unsigned int )offset == 4U) {
    j = j + 1;
    offset = 0U;
  } else {

  }
  i = i + 1;
  ldv_38835: ;
  if (i < len) {
    goto ldv_38834;
  } else {

  }
  descriptor___0.modname = "rts5208";
  descriptor___0.function = "rtsx_write_cfg_seq";
  descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c";
  descriptor___0.format = "rts5208: ";
  descriptor___0.lineno = 1697U;
  descriptor___0.flags = 0U;
  tmp___3 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
  if (tmp___3 != 0L) {
    print_hex_dump("\017", "rts5208: ", 0, 16, 1, (void const   *)mask, (size_t )(dw_len * 4),
                   1);
  } else {

  }
  descriptor___1.modname = "rts5208";
  descriptor___1.function = "rtsx_write_cfg_seq";
  descriptor___1.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c";
  descriptor___1.format = "rts5208: ";
  descriptor___1.lineno = 1699U;
  descriptor___1.flags = 0U;
  tmp___4 = ldv__builtin_expect((long )descriptor___1.flags & 1L, 0L);
  if (tmp___4 != 0L) {
    print_hex_dump("\017", "rts5208: ", 0, 16, 1, (void const   *)data, (size_t )(dw_len * 4),
                   1);
  } else {

  }
  i = 0;
  goto ldv_38840;
  ldv_38839: 
  retval = rtsx_write_cfg_dw(chip, (int )func, (int )((unsigned int )((u16 )i) * 4U + (unsigned int )aligned_addr),
                             *(mask + (unsigned long )i), *(data + (unsigned long )i));
  if (retval != 0) {
    vfree((void const   *)data);
    vfree((void const   *)mask);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c",
                "rtsx_write_cfg_seq", 1707);
    return (1);
  } else {

  }
  i = i + 1;
  ldv_38840: ;
  if (i < dw_len) {
    goto ldv_38839;
  } else {

  }
  vfree((void const   *)data);
  vfree((void const   *)mask);
  return (0);
}
}
int rtsx_read_cfg_seq(struct rtsx_chip *chip , u8 func , u16 addr , u8 *buf , int len ) 
{ 
  u32 *data ;
  u16 offset ;
  u16 aligned_addr ;
  int dw_len ;
  int i ;
  int j ;
  int retval ;
  struct _ddebug descriptor ;
  struct device *tmp ;
  long tmp___0 ;
  void *tmp___1 ;

  {
  offset = (unsigned int )addr & 3U;
  aligned_addr = (int )addr - (int )offset;
  if (((unsigned int )((int )offset + len) & 3U) != 0U) {
    dw_len = ((int )offset + len) / 4 + 1;
  } else {
    dw_len = ((int )offset + len) / 4;
  }
  descriptor.modname = "rts5208";
  descriptor.function = "rtsx_read_cfg_seq";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c";
  descriptor.format = "dw_len = %d\n";
  descriptor.lineno = 1732U;
  descriptor.flags = 0U;
  tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp___0 != 0L) {
    tmp = rtsx_dev((struct rtsx_chip  const  *)chip);
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)tmp, "dw_len = %d\n",
                      dw_len);
  } else {

  }
  tmp___1 = vmalloc((unsigned long )(dw_len * 4));
  data = (u32 *)tmp___1;
  if ((unsigned long )data == (unsigned long )((u32 *)0U)) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c",
                "rtsx_read_cfg_seq", 1736);
    return (3);
  } else {

  }
  i = 0;
  goto ldv_38859;
  ldv_38858: 
  retval = rtsx_read_cfg_dw(chip, (int )func, (int )((unsigned int )((u16 )i) * 4U + (unsigned int )aligned_addr),
                            data + (unsigned long )i);
  if (retval != 0) {
    vfree((void const   *)data);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c",
                "rtsx_read_cfg_seq", 1745);
    return (1);
  } else {

  }
  i = i + 1;
  ldv_38859: ;
  if (i < dw_len) {
    goto ldv_38858;
  } else {

  }

  if ((unsigned long )buf != (unsigned long )((u8 *)0U)) {
    j = 0;
    i = 0;
    goto ldv_38862;
    ldv_38861: 
    *(buf + (unsigned long )i) = (unsigned char )(*(data + (unsigned long )j) >> (int )offset * 8);
    offset = (u16 )((int )offset + 1);
    if ((unsigned int )offset == 4U) {
      j = j + 1;
      offset = 0U;
    } else {

    }
    i = i + 1;
    ldv_38862: ;
    if (i < len) {
      goto ldv_38861;
    } else {

    }

  } else {

  }
  vfree((void const   *)data);
  return (0);
}
}
int rtsx_write_phy_register(struct rtsx_chip *chip , u8 addr , u16 val ) 
{ 
  int retval ;
  bool finished ;
  int i ;
  u8 tmp ;

  {
  finished = 0;
  retval = rtsx_write_register(chip, 65085, 255, (int )((unsigned char )val));
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c",
                "rtsx_write_phy_register", 1776);
    return (retval);
  } else {

  }
  retval = rtsx_write_register(chip, 65086, 255, (int )((unsigned char )((int )val >> 8)));
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c",
                "rtsx_write_phy_register", 1781);
    return (retval);
  } else {

  }
  retval = rtsx_write_register(chip, 65087, 255, (int )addr);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c",
                "rtsx_write_phy_register", 1786);
    return (retval);
  } else {

  }
  retval = rtsx_write_register(chip, 65084, 255, 129);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c",
                "rtsx_write_phy_register", 1791);
    return (retval);
  } else {

  }
  i = 0;
  goto ldv_38876;
  ldv_38875: 
  retval = rtsx_read_register(chip, 65084, & tmp);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c",
                "rtsx_write_phy_register", 1798);
    return (retval);
  } else {

  }
  if ((int )((signed char )tmp) >= 0) {
    finished = 1;
    goto ldv_38874;
  } else {

  }
  i = i + 1;
  ldv_38876: ;
  if (i <= 99999) {
    goto ldv_38875;
  } else {

  }
  ldv_38874: ;
  if (! finished) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c",
                "rtsx_write_phy_register", 1808);
    return (1);
  } else {

  }
  return (0);
}
}
int rtsx_read_phy_register(struct rtsx_chip *chip , u8 addr , u16 *val ) 
{ 
  int retval ;
  bool finished ;
  int i ;
  u16 data ;
  u8 tmp ;

  {
  finished = 0;
  data = 0U;
  retval = rtsx_write_register(chip, 65087, 255, (int )addr);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c",
                "rtsx_read_phy_register", 1825);
    return (retval);
  } else {

  }
  retval = rtsx_write_register(chip, 65084, 255, 128);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c",
                "rtsx_read_phy_register", 1830);
    return (retval);
  } else {

  }
  i = 0;
  goto ldv_38890;
  ldv_38889: 
  retval = rtsx_read_register(chip, 65084, & tmp);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c",
                "rtsx_read_phy_register", 1837);
    return (retval);
  } else {

  }
  if ((int )((signed char )tmp) >= 0) {
    finished = 1;
    goto ldv_38888;
  } else {

  }
  i = i + 1;
  ldv_38890: ;
  if (i <= 99999) {
    goto ldv_38889;
  } else {

  }
  ldv_38888: ;
  if (! finished) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c",
                "rtsx_read_phy_register", 1847);
    return (1);
  } else {

  }
  retval = rtsx_read_register(chip, 65085, & tmp);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c",
                "rtsx_read_phy_register", 1853);
    return (retval);
  } else {

  }
  data = (u16 )tmp;
  retval = rtsx_read_register(chip, 65086, & tmp);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c",
                "rtsx_read_phy_register", 1859);
    return (retval);
  } else {

  }
  data = (u16 )((int )((short )((int )tmp << 8)) | (int )((short )data));
  if ((unsigned long )val != (unsigned long )((u16 *)0U)) {
    *val = data;
  } else {

  }
  return (0);
}
}
int rtsx_read_efuse(struct rtsx_chip *chip , u8 addr , u8 *val ) 
{ 
  int retval ;
  int i ;
  u8 data ;

  {
  data = 0U;
  retval = rtsx_write_register(chip, 64545, 255, (int )((unsigned int )addr | 128U));
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c",
                "rtsx_read_efuse", 1878);
    return (retval);
  } else {

  }
  i = 0;
  goto ldv_38902;
  ldv_38901: 
  retval = rtsx_read_register(chip, 64545, & data);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c",
                "rtsx_read_efuse", 1885);
    return (retval);
  } else {

  }
  if ((int )((signed char )data) >= 0) {
    goto ldv_38900;
  } else {

  }
  __const_udelay(4295UL);
  i = i + 1;
  ldv_38902: ;
  if (i <= 99) {
    goto ldv_38901;
  } else {

  }
  ldv_38900: ;
  if ((int )((signed char )data) < 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c",
                "rtsx_read_efuse", 1894);
    return (2);
  } else {

  }
  retval = rtsx_read_register(chip, 64546, & data);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c",
                "rtsx_read_efuse", 1900);
    return (retval);
  } else {

  }
  if ((unsigned long )val != (unsigned long )((u8 *)0U)) {
    *val = data;
  } else {

  }
  return (0);
}
}
int rtsx_write_efuse(struct rtsx_chip *chip , u8 addr , u8 val ) 
{ 
  int retval ;
  int i ;
  int j ;
  u8 data ;
  u8 tmp ;
  struct _ddebug descriptor ;
  struct device *tmp___0 ;
  long tmp___1 ;
  struct task_struct *tmp___2 ;
  long volatile   __ret ;
  struct task_struct *tmp___3 ;
  struct task_struct *tmp___4 ;
  struct task_struct *tmp___5 ;
  struct task_struct *tmp___6 ;
  struct task_struct *tmp___7 ;
  long volatile   __ret___0 ;
  struct task_struct *tmp___8 ;
  struct task_struct *tmp___9 ;
  struct task_struct *tmp___10 ;
  struct task_struct *tmp___11 ;

  {
  data = 0U;
  tmp = 255U;
  i = 0;
  goto ldv_38936;
  ldv_38935: ;
  if ((unsigned int )((int )((unsigned char )(1 << i)) & (int )val) != 0U) {
    goto ldv_38913;
  } else {

  }
  tmp = (u8 )(~ ((int )((signed char )(1 << i))) & (int )((signed char )tmp));
  descriptor.modname = "rts5208";
  descriptor.function = "rtsx_write_efuse";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c";
  descriptor.format = "Write 0x%x to 0x%x\n";
  descriptor.lineno = 1920U;
  descriptor.flags = 0U;
  tmp___1 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp___1 != 0L) {
    tmp___0 = rtsx_dev((struct rtsx_chip  const  *)chip);
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)tmp___0, "Write 0x%x to 0x%x\n",
                      (int )tmp, (int )addr);
  } else {

  }
  retval = rtsx_write_register(chip, 64546, 255, (int )tmp);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c",
                "rtsx_write_efuse", 1924);
    return (retval);
  } else {

  }
  retval = rtsx_write_register(chip, 64545, 255, (int )((unsigned int )addr | 160U));
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c",
                "rtsx_write_efuse", 1930);
    return (retval);
  } else {

  }
  j = 0;
  goto ldv_38926;
  ldv_38925: 
  retval = rtsx_read_register(chip, 64545, & data);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c",
                "rtsx_write_efuse", 1937);
    return (retval);
  } else {

  }
  if ((int )((signed char )data) >= 0) {
    goto ldv_38916;
  } else {

  }
  tmp___2 = get_current();
  tmp___2->task_state_change = 0UL;
  __ret = 1L;
  switch (8UL) {
  case 1UL: 
  tmp___3 = get_current();
  __asm__  volatile   ("xchgb %b0, %1\n": "+q" (__ret), "+m" (tmp___3->state): : "memory",
                       "cc");
  goto ldv_38919;
  case 2UL: 
  tmp___4 = get_current();
  __asm__  volatile   ("xchgw %w0, %1\n": "+r" (__ret), "+m" (tmp___4->state): : "memory",
                       "cc");
  goto ldv_38919;
  case 4UL: 
  tmp___5 = get_current();
  __asm__  volatile   ("xchgl %0, %1\n": "+r" (__ret), "+m" (tmp___5->state): : "memory",
                       "cc");
  goto ldv_38919;
  case 8UL: 
  tmp___6 = get_current();
  __asm__  volatile   ("xchgq %q0, %1\n": "+r" (__ret), "+m" (tmp___6->state): : "memory",
                       "cc");
  goto ldv_38919;
  default: 
  __xchg_wrong_size();
  }
  ldv_38919: 
  schedule_timeout(0L);
  j = j + 1;
  ldv_38926: ;
  if (j <= 99) {
    goto ldv_38925;
  } else {

  }
  ldv_38916: ;
  if ((int )((signed char )data) < 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c",
                "rtsx_write_efuse", 1946);
    return (2);
  } else {

  }
  tmp___7 = get_current();
  tmp___7->task_state_change = 0UL;
  __ret___0 = 1L;
  switch (8UL) {
  case 1UL: 
  tmp___8 = get_current();
  __asm__  volatile   ("xchgb %b0, %1\n": "+q" (__ret___0), "+m" (tmp___8->state): : "memory",
                       "cc");
  goto ldv_38929;
  case 2UL: 
  tmp___9 = get_current();
  __asm__  volatile   ("xchgw %w0, %1\n": "+r" (__ret___0), "+m" (tmp___9->state): : "memory",
                       "cc");
  goto ldv_38929;
  case 4UL: 
  tmp___10 = get_current();
  __asm__  volatile   ("xchgl %0, %1\n": "+r" (__ret___0), "+m" (tmp___10->state): : "memory",
                       "cc");
  goto ldv_38929;
  case 8UL: 
  tmp___11 = get_current();
  __asm__  volatile   ("xchgq %q0, %1\n": "+r" (__ret___0), "+m" (tmp___11->state): : "memory",
                       "cc");
  goto ldv_38929;
  default: 
  __xchg_wrong_size();
  }
  ldv_38929: 
  schedule_timeout(1L);
  ldv_38913: 
  i = i + 1;
  ldv_38936: ;
  if (i <= 7) {
    goto ldv_38935;
  } else {

  }

  return (0);
}
}
int rtsx_clr_phy_reg_bit(struct rtsx_chip *chip , u8 reg , u8 bit ) 
{ 
  int retval ;
  u16 value ;

  {
  retval = rtsx_read_phy_register(chip, (int )reg, & value);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c",
                "rtsx_clr_phy_reg_bit", 1963);
    return (1);
  } else {

  }
  if (((int )value >> (int )bit) & 1) {
    value = (u16 )(~ ((int )((short )(1 << (int )bit))) & (int )((short )value));
    retval = rtsx_write_phy_register(chip, (int )reg, (int )value);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c",
                  "rtsx_clr_phy_reg_bit", 1971);
      return (1);
    } else {

    }
  } else {

  }
  return (0);
}
}
int rtsx_set_phy_reg_bit(struct rtsx_chip *chip , u8 reg , u8 bit ) 
{ 
  int retval ;
  u16 value ;

  {
  retval = rtsx_read_phy_register(chip, (int )reg, & value);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c",
                "rtsx_set_phy_reg_bit", 1986);
    return (1);
  } else {

  }
  if ((((int )value >> (int )bit) & 1) == 0) {
    value = (u16 )((int )((short )(1 << (int )bit)) | (int )((short )value));
    retval = rtsx_write_phy_register(chip, (int )reg, (int )value);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c",
                  "rtsx_set_phy_reg_bit", 1994);
      return (1);
    } else {

    }
  } else {

  }
  return (0);
}
}
int rtsx_check_link_ready(struct rtsx_chip *chip ) 
{ 
  int retval ;
  u8 val ;
  struct _ddebug descriptor ;
  struct device *tmp ;
  long tmp___0 ;
  struct _ddebug descriptor___0 ;
  struct device *tmp___1 ;
  long tmp___2 ;

  {
  retval = rtsx_read_register(chip, 65057, & val);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c",
                "rtsx_check_link_ready", 2009);
    return (retval);
  } else {

  }
  descriptor.modname = "rts5208";
  descriptor.function = "rtsx_check_link_ready";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c";
  descriptor.format = "IRQSTAT0: 0x%x\n";
  descriptor.lineno = 2013U;
  descriptor.flags = 0U;
  tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp___0 != 0L) {
    tmp = rtsx_dev((struct rtsx_chip  const  *)chip);
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)tmp, "IRQSTAT0: 0x%x\n",
                      (int )val);
  } else {

  }
  if (((int )val & 32) != 0) {
    descriptor___0.modname = "rts5208";
    descriptor___0.function = "rtsx_check_link_ready";
    descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c";
    descriptor___0.format = "Delinked!\n";
    descriptor___0.lineno = 2015U;
    descriptor___0.flags = 0U;
    tmp___2 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
    if (tmp___2 != 0L) {
      tmp___1 = rtsx_dev((struct rtsx_chip  const  *)chip);
      __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)tmp___1, "Delinked!\n");
    } else {

    }
    rtsx_write_register(chip, 65057, 32, 32);
    return (1);
  } else {

  }
  return (0);
}
}
static void rtsx_handle_pm_dstate(struct rtsx_chip *chip , u8 dstate ) 
{ 
  u32 ultmp ;
  struct _ddebug descriptor ;
  struct device *tmp ;
  long tmp___0 ;
  u8 func_no ;
  struct _ddebug descriptor___0 ;
  struct device *tmp___1 ;
  long tmp___2 ;

  {
  descriptor.modname = "rts5208";
  descriptor.function = "rtsx_handle_pm_dstate";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c";
  descriptor.format = "%04x set pm_dstate to %d\n";
  descriptor.lineno = 2028U;
  descriptor.flags = 0U;
  tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp___0 != 0L) {
    tmp = rtsx_dev((struct rtsx_chip  const  *)chip);
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)tmp, "%04x set pm_dstate to %d\n",
                      (int )chip->product_id, (int )dstate);
  } else {

  }
  if (chip->sdio_func_exist & 1) {
    if ((unsigned int )chip->product_id == 21128U) {
      func_no = 2U;
    } else {
      func_no = 1U;
    }
    rtsx_read_cfg_dw(chip, (int )func_no, 132, & ultmp);
    descriptor___0.modname = "rts5208";
    descriptor___0.function = "rtsx_handle_pm_dstate";
    descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c";
    descriptor___0.format = "pm_dstate of function %d: 0x%x\n";
    descriptor___0.lineno = 2040U;
    descriptor___0.flags = 0U;
    tmp___2 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
    if (tmp___2 != 0L) {
      tmp___1 = rtsx_dev((struct rtsx_chip  const  *)chip);
      __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)tmp___1, "pm_dstate of function %d: 0x%x\n",
                        (int )func_no, ultmp);
    } else {

    }
    rtsx_write_cfg_dw(chip, (int )func_no, 132, 255U, (u32 )dstate);
  } else {

  }
  pci_write_config_byte((struct pci_dev  const  *)(chip->rtsx)->pci, 68, (int )dstate);
  pci_write_config_byte((struct pci_dev  const  *)(chip->rtsx)->pci, 69, 0);
  return;
}
}
void rtsx_enter_L1(struct rtsx_chip *chip ) 
{ 


  {
  rtsx_handle_pm_dstate(chip, 2);
  return;
}
}
void rtsx_exit_L1(struct rtsx_chip *chip ) 
{ 


  {
  pci_write_config_byte((struct pci_dev  const  *)(chip->rtsx)->pci, 68, 0);
  pci_write_config_byte((struct pci_dev  const  *)(chip->rtsx)->pci, 69, 0);
  return;
}
}
void rtsx_enter_ss(struct rtsx_chip *chip ) 
{ 
  struct _ddebug descriptor ;
  struct device *tmp ;
  long tmp___0 ;
  u32 tmp___1 ;

  {
  descriptor.modname = "rts5208";
  descriptor.function = "rtsx_enter_ss";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c";
  descriptor.format = "Enter Selective Suspend State!\n";
  descriptor.lineno = 2061U;
  descriptor.flags = 0U;
  tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp___0 != 0L) {
    tmp = rtsx_dev((struct rtsx_chip  const  *)chip);
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)tmp, "Enter Selective Suspend State!\n");
  } else {

  }
  rtsx_write_register(chip, 65057, 32, 32);
  if (chip->power_down_in_ss != 0) {
    rtsx_power_off_card(chip);
    rtsx_force_power_down(chip, 3);
  } else {

  }
  if (chip->sdio_func_exist & 1) {
    rtsx_write_cfg_dw(chip, (unsigned int )chip->product_id == 21128U ? 2 : 1, 192,
                      65280U, 256U);
  } else {

  }
  if (chip->auto_delink_en != 0) {
    rtsx_write_register(chip, 65120, 1, 1);
  } else {
    if (chip->phy_debug_mode == 0) {
      tmp___1 = ioread32((chip->rtsx)->remap_addr + 24UL);
      tmp___1 = tmp___1 | 234881024U;
      iowrite32(tmp___1, (chip->rtsx)->remap_addr + 24UL);
    } else {

    }
    rtsx_write_register(chip, 65115, 2, 0);
  }
  rtsx_enter_L1(chip);
  chip->rtsx_flag = (unsigned int )chip->rtsx_flag & 254U;
  chip->idle_counter = 0;
  chip->rtsx_stat = 3;
  return;
}
}
void rtsx_exit_ss(struct rtsx_chip *chip ) 
{ 
  struct _ddebug descriptor ;
  struct device *tmp ;
  long tmp___0 ;

  {
  descriptor.modname = "rts5208";
  descriptor.function = "rtsx_exit_ss";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c";
  descriptor.format = "Exit Selective Suspend State!\n";
  descriptor.lineno = 2096U;
  descriptor.flags = 0U;
  tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp___0 != 0L) {
    tmp = rtsx_dev((struct rtsx_chip  const  *)chip);
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)tmp, "Exit Selective Suspend State!\n");
  } else {

  }
  rtsx_exit_L1(chip);
  if (chip->power_down_in_ss != 0) {
    rtsx_force_power_on(chip, 3);
    __const_udelay(4295000UL);
  } else {

  }
  if ((int )chip->rtsx_flag & 1) {
    chip->need_reinit = 28UL;
    rtsx_reinit_cards(chip, 1);
    chip->rtsx_flag = (unsigned int )chip->rtsx_flag & 254U;
  } else
  if (chip->power_down_in_ss != 0) {
    chip->need_reinit = 28UL;
    rtsx_reinit_cards(chip, 0);
  } else {

  }
  return;
}
}
int rtsx_pre_handle_interrupt(struct rtsx_chip *chip ) 
{ 
  u32 status ;
  u32 int_enable ;
  bool exit_ss ;
  u32 ocp_int ;
  unsigned int tmp ;

  {
  exit_ss = 0;
  ocp_int = 0U;
  ocp_int = 8388608U;
  if (chip->ss_en != 0) {
    chip->ss_counter = 0;
    if ((unsigned int )chip->rtsx_stat == 3U) {
      exit_ss = 1;
      rtsx_exit_L1(chip);
      chip->idle_counter = 0;
      chip->rtsx_stat = 2;
    } else {

    }
  } else {

  }
  int_enable = ioread32((chip->rtsx)->remap_addr + 24UL);
  chip->int_reg = ioread32((chip->rtsx)->remap_addr + 20UL);
  if ((chip->int_reg & int_enable) == 0U || chip->int_reg == 4294967295U) {
    return (1);
  } else {

  }
  tmp = chip->int_reg & (int_enable | 8388607U);
  chip->int_reg = tmp;
  status = tmp;
  if ((status & 234881024U) != 0U) {
    chip->auto_delink_cnt = 0;
    if ((status & 33554432U) != 0U) {
      if ((status & 65536U) != 0U) {
        set_bit(2L, (unsigned long volatile   *)(& chip->need_reset));
      } else {
        set_bit(2L, (unsigned long volatile   *)(& chip->need_release));
        chip->sd_reset_counter = 0;
        chip->sd_show_cnt = 0;
        clear_bit(2L, (unsigned long volatile   *)(& chip->need_reset));
      }
    } else
    if ((int )exit_ss && (status & 65536U) != 0U) {
      set_bit(2L, (unsigned long volatile   *)(& chip->need_reinit));
    } else {

    }
    if ((unsigned int )chip->product_id != 21128U || chip->baro_pkg == 0) {
      if ((status & 134217728U) != 0U) {
        if ((status & 262144U) != 0U) {
          set_bit(4L, (unsigned long volatile   *)(& chip->need_reset));
        } else {
          set_bit(4L, (unsigned long volatile   *)(& chip->need_release));
          chip->xd_reset_counter = 0;
          chip->xd_show_cnt = 0;
          clear_bit(4L, (unsigned long volatile   *)(& chip->need_reset));
        }
      } else
      if ((int )exit_ss && (status & 262144U) != 0U) {
        set_bit(4L, (unsigned long volatile   *)(& chip->need_reinit));
      } else {

      }
    } else {

    }
    if ((status & 67108864U) != 0U) {
      if ((status & 131072U) != 0U) {
        set_bit(3L, (unsigned long volatile   *)(& chip->need_reset));
      } else {
        set_bit(3L, (unsigned long volatile   *)(& chip->need_release));
        chip->ms_reset_counter = 0;
        chip->ms_show_cnt = 0;
        clear_bit(3L, (unsigned long volatile   *)(& chip->need_reset));
      }
    } else
    if ((int )exit_ss && (status & 131072U) != 0U) {
      set_bit(3L, (unsigned long volatile   *)(& chip->need_reinit));
    } else {

    }
  } else {

  }
  chip->ocp_int = ocp_int & status;
  if ((unsigned int )chip->sd_io != 0U && (chip->int_reg & 1073741824U) != 0U) {
    chip->int_reg = chip->int_reg & 3221225471U;
  } else {

  }
  return (0);
}
}
void rtsx_do_before_power_down(struct rtsx_chip *chip , int pm_stat ) 
{ 
  int retval ;
  struct _ddebug descriptor ;
  struct device *tmp ;
  long tmp___0 ;
  struct _ddebug descriptor___0 ;
  struct device *tmp___1 ;
  long tmp___2 ;
  struct task_struct *tmp___3 ;
  long volatile   __ret ;
  struct task_struct *tmp___4 ;
  struct task_struct *tmp___5 ;
  struct task_struct *tmp___6 ;
  struct task_struct *tmp___7 ;
  struct _ddebug descriptor___1 ;
  struct device *tmp___8 ;
  long tmp___9 ;

  {
  descriptor.modname = "rts5208";
  descriptor.function = "rtsx_do_before_power_down";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c";
  descriptor.format = "%s, pm_stat = %d\n";
  descriptor.lineno = 2209U;
  descriptor.flags = 0U;
  tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp___0 != 0L) {
    tmp = rtsx_dev((struct rtsx_chip  const  *)chip);
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)tmp, "%s, pm_stat = %d\n",
                      "rtsx_do_before_power_down", pm_stat);
  } else {

  }
  chip->idle_counter = 0;
  chip->rtsx_stat = 5;
  retval = rtsx_force_power_on(chip, 1);
  if (retval != 0) {
    return;
  } else {

  }
  rtsx_release_cards(chip);
  rtsx_disable_bus_int(chip);
  turn_off_led(chip, 0);
  if ((unsigned int )chip->sd_io != 0U) {
    chip->sdio_in_charge = 1;
    if ((unsigned int )chip->product_id == 21000U) {
      rtsx_write_register(chip, 65063, 8, 8);
      rtsx_write_register(chip, 65136, 128, 128);
    } else
    if ((unsigned int )chip->product_id == 21128U) {
      rtsx_write_register(chip, 65063, 8, 8);
      rtsx_write_register(chip, 65114, 8, 8);
    } else {

    }
  } else {

  }
  if ((unsigned int )chip->product_id == 21000U && (unsigned int )chip->ic_version > 2U) {
    rtsx_write_register(chip, 65097, 8, 8);
  } else {

  }
  if (pm_stat == 1) {
    descriptor___0.modname = "rts5208";
    descriptor___0.function = "rtsx_do_before_power_down";
    descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c";
    descriptor___0.format = "Host enter S1\n";
    descriptor___0.lineno = 2242U;
    descriptor___0.flags = 0U;
    tmp___2 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
    if (tmp___2 != 0L) {
      tmp___1 = rtsx_dev((struct rtsx_chip  const  *)chip);
      __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)tmp___1, "Host enter S1\n");
    } else {

    }
    rtsx_write_register(chip, 65120, 3, 1);
  } else
  if (pm_stat == 3) {
    if (chip->s3_pwr_off_delay > 0) {
      tmp___3 = get_current();
      tmp___3->task_state_change = 0UL;
      __ret = 1L;
      switch (8UL) {
      case 1UL: 
      tmp___4 = get_current();
      __asm__  volatile   ("xchgb %b0, %1\n": "+q" (__ret), "+m" (tmp___4->state): : "memory",
                           "cc");
      goto ldv_39005;
      case 2UL: 
      tmp___5 = get_current();
      __asm__  volatile   ("xchgw %w0, %1\n": "+r" (__ret), "+m" (tmp___5->state): : "memory",
                           "cc");
      goto ldv_39005;
      case 4UL: 
      tmp___6 = get_current();
      __asm__  volatile   ("xchgl %0, %1\n": "+r" (__ret), "+m" (tmp___6->state): : "memory",
                           "cc");
      goto ldv_39005;
      case 8UL: 
      tmp___7 = get_current();
      __asm__  volatile   ("xchgq %q0, %1\n": "+r" (__ret), "+m" (tmp___7->state): : "memory",
                           "cc");
      goto ldv_39005;
      default: 
      __xchg_wrong_size();
      }
      ldv_39005: 
      schedule_timeout((long )((chip->s3_pwr_off_delay * 250) / 1000));
    } else {

    }
    descriptor___1.modname = "rts5208";
    descriptor___1.function = "rtsx_do_before_power_down";
    descriptor___1.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c";
    descriptor___1.format = "Host enter S3\n";
    descriptor___1.lineno = 2249U;
    descriptor___1.flags = 0U;
    tmp___9 = ldv__builtin_expect((long )descriptor___1.flags & 1L, 0L);
    if (tmp___9 != 0L) {
      tmp___8 = rtsx_dev((struct rtsx_chip  const  *)chip);
      __dynamic_dev_dbg(& descriptor___1, (struct device  const  *)tmp___8, "Host enter S3\n");
    } else {

    }
    rtsx_write_register(chip, 65120, 3, 2);
  } else {

  }
  if (chip->do_delink_before_power_down != 0 && chip->auto_delink_en != 0) {
    rtsx_write_register(chip, 65115, 2, 2);
  } else {

  }
  rtsx_force_power_down(chip, 3);
  chip->cur_clk = 0;
  chip->cur_card = 0;
  chip->card_exist = 0U;
  return;
}
}
void rtsx_enable_aspm(struct rtsx_chip *chip ) 
{ 
  struct _ddebug descriptor ;
  struct device *tmp ;
  long tmp___0 ;
  u16 val ;

  {
  if (((unsigned int )chip->aspm_l0s_l1_en != 0U && chip->dynamic_aspm != 0) && chip->aspm_enabled == 0) {
    descriptor.modname = "rts5208";
    descriptor.function = "rtsx_enable_aspm";
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c";
    descriptor.format = "Try to enable ASPM\n";
    descriptor.lineno = 2267U;
    descriptor.flags = 0U;
    tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
    if (tmp___0 != 0L) {
      tmp = rtsx_dev((struct rtsx_chip  const  *)chip);
      __dynamic_dev_dbg(& descriptor, (struct device  const  *)tmp, "Try to enable ASPM\n");
    } else {

    }
    chip->aspm_enabled = 1;
    if (chip->asic_code != 0 && (unsigned int )chip->product_id == 21000U) {
      rtsx_write_phy_register(chip, 7, 0);
    } else {

    }
    if ((unsigned int )chip->product_id == 21000U) {
      rtsx_write_register(chip, 65111, 243, (int )((unsigned int )chip->aspm_level[0] | 48U));
    } else {
      pci_write_config_byte((struct pci_dev  const  *)(chip->rtsx)->pci, 128, (int )chip->aspm_l0s_l1_en);
    }
    if (chip->sdio_func_exist & 1) {
      val = (unsigned int )((u16 )chip->aspm_l0s_l1_en) | 256U;
      rtsx_write_cfg_dw(chip, (unsigned int )chip->product_id == 21128U ? 2 : 1, 192,
                        4095U, (u32 )val);
    } else {

    }
  } else {

  }
  return;
}
}
void rtsx_disable_aspm(struct rtsx_chip *chip ) 
{ 
  struct _ddebug descriptor ;
  struct device *tmp ;
  long tmp___0 ;
  struct task_struct *tmp___1 ;
  long volatile   __ret ;
  struct task_struct *tmp___2 ;
  struct task_struct *tmp___3 ;
  struct task_struct *tmp___4 ;
  struct task_struct *tmp___5 ;

  {
  if ((unsigned int )chip->product_id == 21000U) {
    rtsx_monitor_aspm_config(chip);
  } else {

  }
  if (((unsigned int )chip->aspm_l0s_l1_en != 0U && chip->dynamic_aspm != 0) && chip->aspm_enabled != 0) {
    descriptor.modname = "rts5208";
    descriptor.function = "rtsx_disable_aspm";
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c";
    descriptor.format = "Try to disable ASPM\n";
    descriptor.lineno = 2295U;
    descriptor.flags = 0U;
    tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
    if (tmp___0 != 0L) {
      tmp = rtsx_dev((struct rtsx_chip  const  *)chip);
      __dynamic_dev_dbg(& descriptor, (struct device  const  *)tmp, "Try to disable ASPM\n");
    } else {

    }
    chip->aspm_enabled = 0;
    if (chip->asic_code != 0 && (unsigned int )chip->product_id == 21000U) {
      rtsx_write_phy_register(chip, 7, 297);
    } else {

    }
    if ((unsigned int )chip->product_id == 21000U) {
      rtsx_write_register(chip, 65111, 243, 48);
    } else {
      pci_write_config_byte((struct pci_dev  const  *)(chip->rtsx)->pci, 128, 0);
    }
    tmp___1 = get_current();
    tmp___1->task_state_change = 0UL;
    __ret = 1L;
    switch (8UL) {
    case 1UL: 
    tmp___2 = get_current();
    __asm__  volatile   ("xchgb %b0, %1\n": "+q" (__ret), "+m" (tmp___2->state): : "memory",
                         "cc");
    goto ldv_39025;
    case 2UL: 
    tmp___3 = get_current();
    __asm__  volatile   ("xchgw %w0, %1\n": "+r" (__ret), "+m" (tmp___3->state): : "memory",
                         "cc");
    goto ldv_39025;
    case 4UL: 
    tmp___4 = get_current();
    __asm__  volatile   ("xchgl %0, %1\n": "+r" (__ret), "+m" (tmp___4->state): : "memory",
                         "cc");
    goto ldv_39025;
    case 8UL: 
    tmp___5 = get_current();
    __asm__  volatile   ("xchgq %q0, %1\n": "+r" (__ret), "+m" (tmp___5->state): : "memory",
                         "cc");
    goto ldv_39025;
    default: 
    __xchg_wrong_size();
    }
    ldv_39025: 
    schedule_timeout(0L);
  } else {

  }
  return;
}
}
int rtsx_read_ppbuf(struct rtsx_chip *chip , u8 *buf , int buf_len ) 
{ 
  int retval ;
  int i ;
  int j ;
  u16 reg_addr ;
  u8 *ptr ;
  u16 tmp ;
  u8 *tmp___0 ;
  u16 tmp___1 ;
  u8 *tmp___2 ;

  {
  if ((unsigned long )buf == (unsigned long )((u8 *)0U)) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c",
                "rtsx_read_ppbuf", 2318);
    return (10);
  } else {

  }
  ptr = buf;
  reg_addr = 64000U;
  i = 0;
  goto ldv_39046;
  ldv_39045: 
  chip->ci = 0;
  j = 0;
  goto ldv_39043;
  ldv_39042: 
  tmp = reg_addr;
  reg_addr = (u16 )((int )reg_addr + 1);
  rtsx_add_cmd(chip, 0, (int )tmp, 0, 0);
  j = j + 1;
  ldv_39043: ;
  if (j <= 255) {
    goto ldv_39042;
  } else {

  }
  retval = rtsx_send_cmd(chip, 0, 250);
  if (retval < 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c",
                "rtsx_read_ppbuf", 2332);
    return (1);
  } else {

  }
  tmp___0 = rtsx_get_cmd_data(chip);
  memcpy((void *)ptr, (void const   *)tmp___0, 256UL);
  ptr = ptr + 256UL;
  i = i + 1;
  ldv_39046: ;
  if (buf_len / 256 > i) {
    goto ldv_39045;
  } else {

  }

  if (((unsigned int )buf_len & 255U) != 0U) {
    chip->ci = 0;
    j = 0;
    goto ldv_39049;
    ldv_39048: 
    tmp___1 = reg_addr;
    reg_addr = (u16 )((int )reg_addr + 1);
    rtsx_add_cmd(chip, 0, (int )tmp___1, 0, 0);
    j = j + 1;
    ldv_39049: ;
    if (buf_len % 256 > j) {
      goto ldv_39048;
    } else {

    }
    retval = rtsx_send_cmd(chip, 0, 250);
    if (retval < 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c",
                  "rtsx_read_ppbuf", 2348);
      return (1);
    } else {

    }
  } else {

  }
  tmp___2 = rtsx_get_cmd_data(chip);
  memcpy((void *)ptr, (void const   *)tmp___2, (size_t )(buf_len % 256));
  return (0);
}
}
int rtsx_write_ppbuf(struct rtsx_chip *chip , u8 *buf , int buf_len ) 
{ 
  int retval ;
  int i ;
  int j ;
  u16 reg_addr ;
  u8 *ptr ;
  u16 tmp ;
  u16 tmp___0 ;

  {
  if ((unsigned long )buf == (unsigned long )((u8 *)0U)) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c",
                "rtsx_write_ppbuf", 2366);
    return (10);
  } else {

  }
  ptr = buf;
  reg_addr = 64000U;
  i = 0;
  goto ldv_39066;
  ldv_39065: 
  chip->ci = 0;
  j = 0;
  goto ldv_39063;
  ldv_39062: 
  tmp = reg_addr;
  reg_addr = (u16 )((int )reg_addr + 1);
  rtsx_add_cmd(chip, 1, (int )tmp, 255, (int )*ptr);
  ptr = ptr + 1;
  j = j + 1;
  ldv_39063: ;
  if (j <= 255) {
    goto ldv_39062;
  } else {

  }
  retval = rtsx_send_cmd(chip, 0, 250);
  if (retval < 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c",
                "rtsx_write_ppbuf", 2383);
    return (1);
  } else {

  }
  i = i + 1;
  ldv_39066: ;
  if (buf_len / 256 > i) {
    goto ldv_39065;
  } else {

  }

  if (((unsigned int )buf_len & 255U) != 0U) {
    chip->ci = 0;
    j = 0;
    goto ldv_39069;
    ldv_39068: 
    tmp___0 = reg_addr;
    reg_addr = (u16 )((int )reg_addr + 1);
    rtsx_add_cmd(chip, 1, (int )tmp___0, 255, (int )*ptr);
    ptr = ptr + 1;
    j = j + 1;
    ldv_39069: ;
    if (buf_len % 256 > j) {
      goto ldv_39068;
    } else {

    }
    retval = rtsx_send_cmd(chip, 0, 250);
    if (retval < 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c",
                  "rtsx_write_ppbuf", 2399);
      return (1);
    } else {

    }
  } else {

  }
  return (0);
}
}
int rtsx_check_chip_exist(struct rtsx_chip *chip ) 
{ 
  unsigned int tmp ;

  {
  tmp = ioread32((chip->rtsx)->remap_addr);
  if (tmp == 4294967295U) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c",
                "rtsx_check_chip_exist", 2410);
    return (1);
  } else {

  }
  return (0);
}
}
int rtsx_force_power_on(struct rtsx_chip *chip , u8 ctl ) 
{ 
  int retval ;
  u8 mask ;
  struct task_struct *tmp ;
  long volatile   __ret ;
  struct task_struct *tmp___0 ;
  struct task_struct *tmp___1 ;
  struct task_struct *tmp___2 ;
  struct task_struct *tmp___3 ;

  {
  mask = 0U;
  if ((int )ctl & 1) {
    mask = (u8 )((unsigned int )mask | 1U);
  } else {

  }
  if (((int )ctl & 2) != 0) {
    mask = (u8 )((unsigned int )mask | 2U);
    if ((unsigned int )chip->lun_mode == 1U) {
      mask = (u8 )((unsigned int )mask | 4U);
    } else {

    }
  } else {

  }
  if ((unsigned int )mask != 0U) {
    retval = rtsx_write_register(chip, 64512, (int )mask, 0);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c",
                  "rtsx_force_power_on", 2436);
      return (1);
    } else {

    }
    if ((unsigned int )chip->product_id == 21128U) {
      tmp = get_current();
      tmp->task_state_change = 0UL;
      __ret = 1L;
      switch (8UL) {
      case 1UL: 
      tmp___0 = get_current();
      __asm__  volatile   ("xchgb %b0, %1\n": "+q" (__ret), "+m" (tmp___0->state): : "memory",
                           "cc");
      goto ldv_39084;
      case 2UL: 
      tmp___1 = get_current();
      __asm__  volatile   ("xchgw %w0, %1\n": "+r" (__ret), "+m" (tmp___1->state): : "memory",
                           "cc");
      goto ldv_39084;
      case 4UL: 
      tmp___2 = get_current();
      __asm__  volatile   ("xchgl %0, %1\n": "+r" (__ret), "+m" (tmp___2->state): : "memory",
                           "cc");
      goto ldv_39084;
      case 8UL: 
      tmp___3 = get_current();
      __asm__  volatile   ("xchgq %q0, %1\n": "+r" (__ret), "+m" (tmp___3->state): : "memory",
                           "cc");
      goto ldv_39084;
      default: 
      __xchg_wrong_size();
      }
      ldv_39084: 
      schedule_timeout(50L);
    } else {

    }
  } else {

  }
  return (0);
}
}
int rtsx_force_power_down(struct rtsx_chip *chip , u8 ctl ) 
{ 
  int retval ;
  u8 mask ;
  u8 val ;

  {
  mask = 0U;
  val = 0U;
  if ((int )ctl & 1) {
    mask = (u8 )((unsigned int )mask | 1U);
  } else {

  }
  if (((int )ctl & 2) != 0) {
    mask = (u8 )((unsigned int )mask | 2U);
    if ((unsigned int )chip->lun_mode == 1U) {
      mask = (u8 )((unsigned int )mask | 4U);
    } else {

    }
  } else {

  }
  if ((unsigned int )mask != 0U) {
    val = mask;
    retval = rtsx_write_register(chip, 64512, (int )mask, (int )val);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_chip.c",
                  "rtsx_force_power_down", 2467);
      return (1);
    } else {

    }
  } else {

  }
  return (0);
}
}
void ldv_mutex_lock_77(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_lock_lock(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_78(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_unlock_lock(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_79(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
int ldv_mutex_trylock_80(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
  tmp = mutex_trylock(ldv_func_arg1);
  ldv_func_res = tmp;
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
  return (tmp___0);
  return (ldv_func_res);
}
}
void ldv_mutex_unlock_81(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_82(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_unlock_i_mutex_of_inode(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_83(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_lock_i_mutex_of_inode(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
int ldv_scsi_add_host_with_dma_84(struct Scsi_Host *shost , struct device *dev , struct device *dma_dev ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  int tmp ;

  {
  tmp = scsi_add_host_with_dma(shost, dev, dma_dev);
  ldv_func_res = tmp;
  if (ldv_func_res == 0) {
    ldv_state_variable_3 = 1;
    ldv_initialize_scsi_host_template_3();
  } else {

  }
  return (ldv_func_res);
}
}
__inline static long ldv__builtin_expect(long exp , long c ) ;
extern unsigned long __phys_addr(unsigned long  ) ;
int ldv_mutex_trylock_100(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_98(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_101(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_102(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_97(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_99(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_103(struct mutex *ldv_func_arg1 ) ;
extern long wait_for_completion_interruptible_timeout(struct completion * , unsigned long  ) ;
__inline static void *lowmem_page_address(struct page  const  *page ) 
{ 


  {
  return ((void *)((unsigned long )((unsigned long long )(((long )page + 24189255811072L) / 64L) << 12) + 0xffff880000000000UL));
}
}
__inline static void *kmap(struct page *page ) 
{ 
  void *tmp ;

  {
  __might_sleep("include/linux/highmem.h", 58, 0);
  tmp = lowmem_page_address((struct page  const  *)page);
  return (tmp);
}
}
__inline static void kunmap(struct page *page ) 
{ 


  {
  return;
}
}
__inline static struct page *sg_page(struct scatterlist *sg ) 
{ 
  long tmp ;
  long tmp___0 ;

  {
  tmp = ldv__builtin_expect(sg->sg_magic != 2271560481UL, 0L);
  if (tmp != 0L) {
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/linux/scatterlist.h"),
                         "i" (123), "i" (12UL));
    ldv_30209: ;
    goto ldv_30209;
  } else {

  }
  tmp___0 = ldv__builtin_expect((long )((int )sg->page_link) & 1L, 0L);
  if (tmp___0 != 0L) {
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/linux/scatterlist.h"),
                         "i" (124), "i" (12UL));
    ldv_30210: ;
    goto ldv_30210;
  } else {

  }
  return ((struct page *)(sg->page_link & 0xfffffffffffffffcUL));
}
}
__inline static void *sg_virt(struct scatterlist *sg ) 
{ 
  struct page *tmp ;
  void *tmp___0 ;

  {
  tmp = sg_page(sg);
  tmp___0 = lowmem_page_address((struct page  const  *)tmp);
  return (tmp___0 + (unsigned long )sg->offset);
}
}
extern struct scatterlist *sg_next(struct scatterlist * ) ;
__inline static int valid_dma_direction(int dma_direction ) 
{ 


  {
  return ((dma_direction == 0 || dma_direction == 1) || dma_direction == 2);
}
}
__inline static void kmemcheck_mark_initialized(void *address , unsigned int n ) 
{ 


  {
  return;
}
}
extern void debug_dma_map_page(struct device * , struct page * , size_t  , size_t  ,
                               int  , dma_addr_t  , bool  ) ;
extern void debug_dma_unmap_page(struct device * , dma_addr_t  , size_t  , int  ,
                                 bool  ) ;
extern void debug_dma_map_sg(struct device * , struct scatterlist * , int  , int  ,
                             int  ) ;
extern void debug_dma_unmap_sg(struct device * , struct scatterlist * , int  , int  ) ;
extern struct dma_map_ops *dma_ops ;
__inline static struct dma_map_ops *get_dma_ops(struct device *dev ) 
{ 
  long tmp ;

  {
  tmp = ldv__builtin_expect((unsigned long )dev == (unsigned long )((struct device *)0),
                         0L);
  if (tmp != 0L || (unsigned long )dev->archdata.dma_ops == (unsigned long )((struct dma_map_ops *)0)) {
    return (dma_ops);
  } else {
    return (dev->archdata.dma_ops);
  }
}
}
__inline static dma_addr_t dma_map_single_attrs(struct device *dev , void *ptr , size_t size ,
                                                enum dma_data_direction dir , struct dma_attrs *attrs ) 
{ 
  struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  dma_addr_t addr ;
  int tmp___0 ;
  long tmp___1 ;
  unsigned long tmp___2 ;
  unsigned long tmp___3 ;

  {
  tmp = get_dma_ops(dev);
  ops = tmp;
  kmemcheck_mark_initialized(ptr, (unsigned int )size);
  tmp___0 = valid_dma_direction((int )dir);
  tmp___1 = ldv__builtin_expect(tmp___0 == 0, 0L);
  if (tmp___1 != 0L) {
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/asm-generic/dma-mapping-common.h"),
                         "i" (19), "i" (12UL));
    ldv_35020: ;
    goto ldv_35020;
  } else {

  }
  tmp___2 = __phys_addr((unsigned long )ptr);
  addr = (*(ops->map_page))(dev, (struct page *)-24189255811072L + (tmp___2 >> 12),
                            (unsigned long )ptr & 4095UL, size, dir, attrs);
  tmp___3 = __phys_addr((unsigned long )ptr);
  debug_dma_map_page(dev, (struct page *)-24189255811072L + (tmp___3 >> 12), (unsigned long )ptr & 4095UL,
                     size, (int )dir, addr, 1);
  return (addr);
}
}
__inline static void dma_unmap_single_attrs(struct device *dev , dma_addr_t addr ,
                                            size_t size , enum dma_data_direction dir ,
                                            struct dma_attrs *attrs ) 
{ 
  struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
  tmp = get_dma_ops(dev);
  ops = tmp;
  tmp___0 = valid_dma_direction((int )dir);
  tmp___1 = ldv__builtin_expect(tmp___0 == 0, 0L);
  if (tmp___1 != 0L) {
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/asm-generic/dma-mapping-common.h"),
                         "i" (36), "i" (12UL));
    ldv_35029: ;
    goto ldv_35029;
  } else {

  }
  if ((unsigned long )ops->unmap_page != (unsigned long )((void (*)(struct device * ,
                                                                    dma_addr_t  ,
                                                                    size_t  , enum dma_data_direction  ,
                                                                    struct dma_attrs * ))0)) {
    (*(ops->unmap_page))(dev, addr, size, dir, attrs);
  } else {

  }
  debug_dma_unmap_page(dev, addr, size, (int )dir, 1);
  return;
}
}
__inline static int dma_map_sg_attrs(struct device *dev , struct scatterlist *sg ,
                                     int nents , enum dma_data_direction dir , struct dma_attrs *attrs ) 
{ 
  struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  int i ;
  int ents ;
    klee_make_symbolic(&ents, sizeof(int), "ents");
  struct scatterlist *s ;
  void *tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;

  {
  tmp = get_dma_ops(dev);
  ops = tmp;
  i = 0;
  s = sg;
  goto ldv_35042;
  ldv_35041: 
  tmp___0 = sg_virt(s);
  kmemcheck_mark_initialized(tmp___0, s->length);
  i = i + 1;
  s = sg_next(s);
  ldv_35042: ;
  if (i < nents) {
    goto ldv_35041;
  } else {

  }
  tmp___1 = valid_dma_direction((int )dir);
  tmp___2 = ldv__builtin_expect(tmp___1 == 0, 0L);
  if (tmp___2 != 0L) {
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/asm-generic/dma-mapping-common.h"),
                         "i" (56), "i" (12UL));
    ldv_35044: ;
    goto ldv_35044;
  } else {

  }
  ents = (*(ops->map_sg))(dev, sg, nents, dir, attrs);
  tmp___3 = ldv__builtin_expect(ents < 0, 0L);
  if (tmp___3 != 0L) {
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/asm-generic/dma-mapping-common.h"),
                         "i" (58), "i" (12UL));
    ldv_35045: ;
    goto ldv_35045;
  } else {

  }
  debug_dma_map_sg(dev, sg, nents, ents, (int )dir);
  return (ents);
}
}
__inline static void dma_unmap_sg_attrs(struct device *dev , struct scatterlist *sg ,
                                        int nents , enum dma_data_direction dir ,
                                        struct dma_attrs *attrs ) 
{ 
  struct dma_map_ops *ops ;
  struct dma_map_ops *tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
  tmp = get_dma_ops(dev);
  ops = tmp;
  tmp___0 = valid_dma_direction((int )dir);
  tmp___1 = ldv__builtin_expect(tmp___0 == 0, 0L);
  if (tmp___1 != 0L) {
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/asm-generic/dma-mapping-common.h"),
                         "i" (70), "i" (12UL));
    ldv_35054: ;
    goto ldv_35054;
  } else {

  }
  debug_dma_unmap_sg(dev, sg, nents, (int )dir);
  if ((unsigned long )ops->unmap_sg != (unsigned long )((void (*)(struct device * ,
                                                                  struct scatterlist * ,
                                                                  int  , enum dma_data_direction  ,
                                                                  struct dma_attrs * ))0)) {
    (*(ops->unmap_sg))(dev, sg, nents, dir, attrs);
  } else {

  }
  return;
}
}
__inline static unsigned int scsi_sg_count(struct scsi_cmnd *cmd ) 
{ 


  {
  return (cmd->sdb.table.nents);
}
}
__inline static struct scatterlist *scsi_sglist(struct scsi_cmnd *cmd ) 
{ 


  {
  return (cmd->sdb.table.sgl);
}
}
__inline static unsigned int scsi_bufflen(struct scsi_cmnd *cmd ) 
{ 


  {
  return (cmd->sdb.length);
}
}
__inline static void scsi_set_resid(struct scsi_cmnd *cmd , int resid ) 
{ 


  {
  cmd->sdb.resid = resid;
  return;
}
}
int ldv_scsi_add_host_with_dma_104(struct Scsi_Host *shost , struct device *dev ,
                                   struct device *dma_dev ) ;
unsigned int rtsx_stor_access_xfer_buf(unsigned char *buffer , unsigned int buflen ,
                                       struct scsi_cmnd *srb , unsigned int *index ,
                                       unsigned int *offset , enum xfer_buf_dir dir ) ;
void rtsx_stor_set_xfer_buf(unsigned char *buffer , unsigned int buflen , struct scsi_cmnd *srb ) ;
void rtsx_stor_get_xfer_buf(unsigned char *buffer , unsigned int buflen , struct scsi_cmnd *srb ) ;
void rtsx_send_cmd_no_wait(struct rtsx_chip *chip ) ;
int rtsx_transfer_data(struct rtsx_chip *chip , u8 card , void *buf , size_t len ,
                       int use_sg , enum dma_data_direction dma_dir , int timeout ) ;
int rtsx_transfer_data_partial(struct rtsx_chip *chip , u8 card , void *buf , size_t len ,
                               int use_sg , unsigned int *index , unsigned int *offset ,
                               enum dma_data_direction dma_dir , int timeout ) ;
int rtsx_scsi_handler(struct scsi_cmnd *srb , struct rtsx_chip *chip ) ;
unsigned int rtsx_stor_access_xfer_buf(unsigned char *buffer , unsigned int buflen ,
                                       struct scsi_cmnd *srb , unsigned int *index ,
                                       unsigned int *offset , enum xfer_buf_dir dir ) 
{ 
  unsigned int cnt ;
    klee_make_symbolic(&cnt, sizeof(int), "cnt");
  unsigned int tmp ;
  unsigned int _min1 ;
    klee_make_symbolic(&_min1, sizeof(int), "_min1");
  unsigned int _min2 ;
    klee_make_symbolic(&_min2, sizeof(int), "_min2");
  unsigned int tmp___0 ;
  struct scatterlist *tmp___1 ;
  struct scatterlist *tmp___2 ;
  struct scatterlist *sg ;
  struct scatterlist *tmp___3 ;
  struct page *page ;
  struct page *tmp___4 ;
  unsigned int poff ;
    klee_make_symbolic(&poff, sizeof(int), "poff");
  unsigned int sglen ;
    klee_make_symbolic(&sglen, sizeof(int), "sglen");
  unsigned int plen ;
    klee_make_symbolic(&plen, sizeof(int), "plen");
  unsigned int _min1___0 ;
    klee_make_symbolic(&_min1___0, sizeof(int), "_min1___0");
  unsigned int _min2___0 ;
    klee_make_symbolic(&_min2___0, sizeof(int), "_min2___0");
  unsigned char *ptr ;
  void *tmp___5 ;
  unsigned int tmp___6 ;
  unsigned int tmp___7 ;

  {
  tmp___7 = scsi_sg_count(srb);
  if (tmp___7 == 0U) {
    tmp = scsi_bufflen(srb);
    if (*offset >= tmp) {
      return (0U);
    } else {

    }
    _min1 = buflen;
    tmp___0 = scsi_bufflen(srb);
    _min2 = tmp___0 - *offset;
    cnt = _min1 < _min2 ? _min1 : _min2;
    if ((unsigned int )dir == 0U) {
      tmp___1 = scsi_sglist(srb);
      memcpy((void *)tmp___1 + (unsigned long )*offset, (void const   *)buffer,
               (size_t )cnt);
    } else {
      tmp___2 = scsi_sglist(srb);
      memcpy((void *)buffer, (void const   *)tmp___2 + (unsigned long )*offset,
               (size_t )cnt);
    }
    *offset = *offset + cnt;
  } else {
    tmp___3 = scsi_sglist(srb);
    sg = tmp___3 + (unsigned long )*index;
    cnt = 0U;
    goto ldv_38207;
    ldv_38206: 
    tmp___4 = sg_page(sg);
    page = tmp___4 + (unsigned long )((sg->offset + *offset) >> 12);
    poff = (sg->offset + *offset) & 4095U;
    sglen = sg->length - *offset;
    if (buflen - cnt < sglen) {
      sglen = buflen - cnt;
      *offset = *offset + sglen;
    } else {
      *offset = 0U;
      *index = *index + 1U;
      sg = sg + 1;
    }
    goto ldv_38204;
    ldv_38203: 
    _min1___0 = sglen;
    _min2___0 = 4096U - poff;
    plen = _min1___0 < _min2___0 ? _min1___0 : _min2___0;
    tmp___5 = kmap(page);
    ptr = (unsigned char *)tmp___5;
    if ((unsigned int )dir == 0U) {
      memcpy((void *)ptr + (unsigned long )poff, (void const   *)buffer + (unsigned long )cnt,
               (size_t )plen);
    } else {
      memcpy((void *)buffer + (unsigned long )cnt, (void const   *)ptr + (unsigned long )poff,
               (size_t )plen);
    }
    kunmap(page);
    poff = 0U;
    page = page + 1;
    cnt = cnt + plen;
    sglen = sglen - plen;
    ldv_38204: ;
    if (sglen != 0U) {
      goto ldv_38203;
    } else {

    }

    ldv_38207: ;
    if (cnt < buflen) {
      tmp___6 = scsi_sg_count(srb);
      if (*index < tmp___6) {
        goto ldv_38206;
      } else {
        goto ldv_38208;
      }
    } else {

    }
    ldv_38208: ;
  }
  return (cnt);
}
}
void rtsx_stor_set_xfer_buf(unsigned char *buffer , unsigned int buflen , struct scsi_cmnd *srb ) 
{ 
  unsigned int index ;
  unsigned int offset ;
  unsigned int tmp ;
  unsigned int tmp___0 ;

  {
  index = 0U;
  offset = 0U;
  rtsx_stor_access_xfer_buf(buffer, buflen, srb, & index, & offset, 0);
  tmp___0 = scsi_bufflen(srb);
  if (tmp___0 > buflen) {
    tmp = scsi_bufflen(srb);
    scsi_set_resid(srb, (int )(tmp - buflen));
  } else {

  }
  return;
}
}
void rtsx_stor_get_xfer_buf(unsigned char *buffer , unsigned int buflen , struct scsi_cmnd *srb ) 
{ 
  unsigned int index ;
  unsigned int offset ;
  unsigned int tmp ;
  unsigned int tmp___0 ;

  {
  index = 0U;
  offset = 0U;
  rtsx_stor_access_xfer_buf(buffer, buflen, srb, & index, & offset, 1);
  tmp___0 = scsi_bufflen(srb);
  if (tmp___0 > buflen) {
    tmp = scsi_bufflen(srb);
    scsi_set_resid(srb, (int )(tmp - buflen));
  } else {

  }
  return;
}
}
void rtsx_invoke_transport(struct scsi_cmnd *srb , struct rtsx_chip *chip ) 
{ 
  int result ;
  struct _ddebug descriptor ;
  struct device *tmp ;
  long tmp___0 ;
  struct _ddebug descriptor___0 ;
  struct device *tmp___1 ;
  long tmp___2 ;

  {
  result = rtsx_scsi_handler(srb, chip);
  if ((unsigned int )chip->rtsx_stat == 6U) {
    descriptor.modname = "rts5208";
    descriptor.function = "rtsx_invoke_transport";
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_transport.c";
    descriptor.format = "-- command was aborted\n";
    descriptor.lineno = 168U;
    descriptor.flags = 0U;
    tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
    if (tmp___0 != 0L) {
      tmp = rtsx_dev((struct rtsx_chip  const  *)chip);
      __dynamic_dev_dbg(& descriptor, (struct device  const  *)tmp, "-- command was aborted\n");
    } else {

    }
    srb->result = 327680;
    goto Handle_Errors;
  } else {

  }
  if (result == 3) {
    descriptor___0.modname = "rts5208";
    descriptor___0.function = "rtsx_invoke_transport";
    descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_transport.c";
    descriptor___0.format = "-- transport indicates error, resetting\n";
    descriptor___0.lineno = 175U;
    descriptor___0.flags = 0U;
    tmp___2 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
    if (tmp___2 != 0L) {
      tmp___1 = rtsx_dev((struct rtsx_chip  const  *)chip);
      __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)tmp___1, "-- transport indicates error, resetting\n");
    } else {

    }
    srb->result = 458752;
    goto Handle_Errors;
  } else {

  }
  srb->result = 0;
  if (result == 1) {
    srb->result = 2;
    memcpy((void *)srb->sense_buffer, (void const   *)(& chip->sense_buffer) + (unsigned long )(srb->device)->lun,
             18UL);
  } else {

  }
  return;
  Handle_Errors: ;
  return;
}
}
void rtsx_add_cmd(struct rtsx_chip *chip , u8 cmd_type , u16 reg_addr , u8 mask ,
                  u8 data ) 
{ 
  u32 *cb ;
  u32 val ;
  int tmp ;

  {
  cb = (u32 *)chip->host_cmds_ptr;
  val = 0U;
  val = ((unsigned int )cmd_type << 30) | val;
  val = (((unsigned int )reg_addr & 16383U) << 16) | val;
  val = ((unsigned int )mask << 8) | val;
  val = (u32 )data | val;
  spin_lock_irq(& (chip->rtsx)->reg_lock);
  if (chip->ci <= 255) {
    tmp = chip->ci;
    chip->ci = chip->ci + 1;
    *(cb + (unsigned long )tmp) = val;
  } else {

  }
  spin_unlock_irq(& (chip->rtsx)->reg_lock);
  return;
}
}
void rtsx_send_cmd_no_wait(struct rtsx_chip *chip ) 
{ 
  u32 val ;

  {
  val = 2147483648U;
  iowrite32((u32 )chip->host_cmds_addr, (chip->rtsx)->remap_addr);
  val = ((u32 )(chip->ci * 4) & 16777215U) | val;
  val = val | 1073741824U;
  iowrite32(val, (chip->rtsx)->remap_addr + 4UL);
  return;
}
}
int rtsx_send_cmd(struct rtsx_chip *chip , u8 card , int timeout ) 
{ 
  struct rtsx_dev *rtsx ;
  struct completion trans_done ;
  u32 val ;
  long timeleft ;
    klee_make_symbolic(&timeleft, sizeof(long), "timeleft");
  int err ;
  unsigned long tmp ;
  struct _ddebug descriptor ;
  struct device *tmp___0 ;
  long tmp___1 ;

  {
  rtsx = chip->rtsx;
  val = 2147483648U;
  err = 0;
  if ((unsigned int )card == 4U) {
    rtsx->check_card_cd = 65536U;
  } else
  if ((unsigned int )card == 8U) {
    rtsx->check_card_cd = 131072U;
  } else
  if ((unsigned int )card == 16U) {
    rtsx->check_card_cd = 262144U;
  } else {
    rtsx->check_card_cd = 0U;
  }
  spin_lock_irq(& rtsx->reg_lock);
  rtsx->done = & trans_done;
  rtsx->trans_result = 0;
  init_completion(& trans_done);
  rtsx->trans_state = 1;
  iowrite32((u32 )chip->host_cmds_addr, (chip->rtsx)->remap_addr);
  val = ((u32 )(chip->ci * 4) & 16777215U) | val;
  val = val | 1073741824U;
  iowrite32(val, (chip->rtsx)->remap_addr + 4UL);
  spin_unlock_irq(& rtsx->reg_lock);
  tmp = msecs_to_jiffies((unsigned int const   )timeout);
  timeleft = wait_for_completion_interruptible_timeout(& trans_done, tmp);
  if (timeleft <= 0L) {
    descriptor.modname = "rts5208";
    descriptor.function = "rtsx_send_cmd";
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_transport.c";
    descriptor.format = "chip->int_reg = 0x%x\n";
    descriptor.lineno = 273U;
    descriptor.flags = 0U;
    tmp___1 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
    if (tmp___1 != 0L) {
      tmp___0 = rtsx_dev((struct rtsx_chip  const  *)chip);
      __dynamic_dev_dbg(& descriptor, (struct device  const  *)tmp___0, "chip->int_reg = 0x%x\n",
                        chip->int_reg);
    } else {

    }
    err = -110;
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_transport.c",
                "rtsx_send_cmd", 275);
    goto finish_send_cmd;
  } else {

  }
  spin_lock_irq(& rtsx->reg_lock);
  if ((int )((signed char )rtsx->trans_result) == 2) {
    err = -5;
  } else
  if ((int )((signed char )rtsx->trans_result) == 1) {
    err = 0;
  } else {

  }
  spin_unlock_irq(& rtsx->reg_lock);
  finish_send_cmd: 
  rtsx->done = (struct completion *)0;
  rtsx->trans_state = 0;
  if (err < 0) {
    rtsx_stop_cmd(chip, (int )card);
  } else {

  }
  return (err);
}
}
__inline static void rtsx_add_sg_tbl(struct rtsx_chip *chip , u32 addr , u32 len ,
                                     u8 option ) 
{ 
  u64 *sgb ;
  u64 val ;
  u32 temp_len ;
  u8 temp_opt ;
  int tmp ;

  {
  sgb = (u64 *)chip->host_sg_tbl_ptr;
  val = 0ULL;
  temp_len = 0U;
  temp_opt = 0U;
  ldv_38268: ;
  if (len > 524288U) {
    temp_len = 524288U;
    temp_opt = (unsigned int )option & 253U;
  } else {
    temp_len = len;
    temp_opt = option;
  }
  val = (((unsigned long long )addr << 32) | ((unsigned long long )temp_len << 12)) | (unsigned long long )temp_opt;
  if (chip->sgi <= 383) {
    tmp = chip->sgi;
    chip->sgi = chip->sgi + 1;
    *(sgb + (unsigned long )tmp) = val;
  } else {

  }
  len = len - temp_len;
  addr = addr + temp_len;
  if (len != 0U) {
    goto ldv_38268;
  } else {

  }

  return;
}
}
static int rtsx_transfer_sglist_adma_partial(struct rtsx_chip *chip , u8 card , struct scatterlist *sg ,
                                             int num_sg , unsigned int *index , unsigned int *offset ,
                                             int size , enum dma_data_direction dma_dir ,
                                             int timeout ) 
{ 
  struct rtsx_dev *rtsx ;
  struct completion trans_done ;
  u8 dir ;
  int sg_cnt ;
    klee_make_symbolic(&sg_cnt, sizeof(int), "sg_cnt");
  int i ;
  int resid ;
  int err ;
  long timeleft ;
  struct scatterlist *sg_ptr ;
  u32 val ;
  dma_addr_t addr ;
  unsigned int len ;
  u8 option ;
  struct _ddebug descriptor ;
  struct device *tmp ;
  long tmp___0 ;
  struct _ddebug descriptor___0 ;
  struct device *tmp___1 ;
  long tmp___2 ;
  struct _ddebug descriptor___1 ;
  struct device *tmp___3 ;
  long tmp___4 ;
  unsigned long tmp___5 ;
  struct _ddebug descriptor___2 ;
  struct device *tmp___6 ;
  long tmp___7 ;
  struct _ddebug descriptor___3 ;
  struct device *tmp___8 ;
  long tmp___9 ;
  unsigned long tmp___10 ;
  struct _ddebug descriptor___4 ;
  struct device *tmp___11 ;
  long tmp___12 ;
    klee_make_symbolic(&tmp___12, sizeof(long), "tmp___12");
  struct _ddebug descriptor___5 ;
  struct device *tmp___13 ;
  long tmp___14 ;
    klee_make_symbolic(&tmp___14, sizeof(long), "tmp___14");

  {
  rtsx = chip->rtsx;
  err = 0;
  val = 2147483648U;
  if ((((unsigned long )sg == (unsigned long )((struct scatterlist *)0) || num_sg <= 0) || (unsigned long )offset == (unsigned long )((unsigned int *)0U)) || (unsigned long )index == (unsigned long )((unsigned int *)0U)) {
    return (-5);
  } else {

  }
  if ((unsigned int )dma_dir == 1U) {
    dir = 0U;
  } else
  if ((unsigned int )dma_dir == 2U) {
    dir = 1U;
  } else {
    return (-6);
  }
  if ((unsigned int )card == 4U) {
    rtsx->check_card_cd = 65536U;
  } else
  if ((unsigned int )card == 8U) {
    rtsx->check_card_cd = 131072U;
  } else
  if ((unsigned int )card == 16U) {
    rtsx->check_card_cd = 262144U;
  } else {
    rtsx->check_card_cd = 0U;
  }
  spin_lock_irq(& rtsx->reg_lock);
  rtsx->done = & trans_done;
  rtsx->trans_state = 3;
  rtsx->trans_result = 0;
  spin_unlock_irq(& rtsx->reg_lock);
  sg_cnt = dma_map_sg_attrs(& (rtsx->pci)->dev, sg, num_sg, dma_dir, (struct dma_attrs *)0);
  resid = size;
  sg_ptr = sg;
  chip->sgi = 0;
  i = 0;
  goto ldv_38292;
  ldv_38291: 
  sg_ptr = sg_next(sg_ptr);
  i = i + 1;
  ldv_38292: ;
  if ((unsigned int )i < *index) {
    goto ldv_38291;
  } else {

  }
  i = (int )*index;
  goto ldv_38302;
  ldv_38301: 
  addr = sg_ptr->dma_address;
  len = sg_ptr->dma_length;
  descriptor.modname = "rts5208";
  descriptor.function = "rtsx_transfer_sglist_adma_partial";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_transport.c";
  descriptor.format = "DMA addr: 0x%x, Len: 0x%x\n";
  descriptor.lineno = 387U;
  descriptor.flags = 0U;
  tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp___0 != 0L) {
    tmp = rtsx_dev((struct rtsx_chip  const  *)chip);
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)tmp, "DMA addr: 0x%x, Len: 0x%x\n",
                      (unsigned int )addr, len);
  } else {

  }
  descriptor___0.modname = "rts5208";
  descriptor___0.function = "rtsx_transfer_sglist_adma_partial";
  descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_transport.c";
  descriptor___0.format = "*index = %d, *offset = %d\n";
  descriptor___0.lineno = 389U;
  descriptor___0.flags = 0U;
  tmp___2 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
  if (tmp___2 != 0L) {
    tmp___1 = rtsx_dev((struct rtsx_chip  const  *)chip);
    __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)tmp___1, "*index = %d, *offset = %d\n",
                      *index, *offset);
  } else {

  }
  addr = (dma_addr_t )*offset + addr;
  if (len - *offset > (unsigned int )resid) {
    *offset = *offset + (unsigned int )resid;
    len = (unsigned int )resid;
    resid = 0;
  } else {
    resid = (int )((*offset - len) + (unsigned int )resid);
    len = len - *offset;
    *offset = 0U;
    *index = *index + 1U;
  }
  if (sg_cnt + -1 == i || resid == 0) {
    option = 35U;
  } else {
    option = 33U;
  }
  rtsx_add_sg_tbl(chip, (unsigned int )addr, len, (int )option);
  if (resid == 0) {
    goto ldv_38300;
  } else {

  }
  sg_ptr = sg_next(sg_ptr);
  i = i + 1;
  ldv_38302: ;
  if (i < sg_cnt) {
    goto ldv_38301;
  } else {

  }
  ldv_38300: 
  descriptor___1.modname = "rts5208";
  descriptor___1.function = "rtsx_transfer_sglist_adma_partial";
  descriptor___1.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_transport.c";
  descriptor___1.format = "SG table count = %d\n";
  descriptor___1.lineno = 416U;
  descriptor___1.flags = 0U;
  tmp___4 = ldv__builtin_expect((long )descriptor___1.flags & 1L, 0L);
  if (tmp___4 != 0L) {
    tmp___3 = rtsx_dev((struct rtsx_chip  const  *)chip);
    __dynamic_dev_dbg(& descriptor___1, (struct device  const  *)tmp___3, "SG table count = %d\n",
                      chip->sgi);
  } else {

  }
  val = (((unsigned int )dir & 1U) << 29) | val;
  val = val | 134217728U;
  spin_lock_irq(& rtsx->reg_lock);
  init_completion(& trans_done);
  iowrite32((u32 )chip->host_sg_tbl_addr, (chip->rtsx)->remap_addr + 8UL);
  iowrite32(val, (chip->rtsx)->remap_addr + 12UL);
  spin_unlock_irq(& rtsx->reg_lock);
  tmp___5 = msecs_to_jiffies((unsigned int const   )timeout);
  timeleft = wait_for_completion_interruptible_timeout(& trans_done, tmp___5);
  if (timeleft <= 0L) {
    descriptor___2.modname = "rts5208";
    descriptor___2.function = "rtsx_transfer_sglist_adma_partial";
    descriptor___2.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_transport.c";
    descriptor___2.format = "Timeout (%s %d)\n";
    descriptor___2.lineno = 434U;
    descriptor___2.flags = 0U;
    tmp___7 = ldv__builtin_expect((long )descriptor___2.flags & 1L, 0L);
    if (tmp___7 != 0L) {
      tmp___6 = rtsx_dev((struct rtsx_chip  const  *)chip);
      __dynamic_dev_dbg(& descriptor___2, (struct device  const  *)tmp___6, "Timeout (%s %d)\n",
                        "rtsx_transfer_sglist_adma_partial", 434);
    } else {

    }
    descriptor___3.modname = "rts5208";
    descriptor___3.function = "rtsx_transfer_sglist_adma_partial";
    descriptor___3.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_transport.c";
    descriptor___3.format = "chip->int_reg = 0x%x\n";
    descriptor___3.lineno = 436U;
    descriptor___3.flags = 0U;
    tmp___9 = ldv__builtin_expect((long )descriptor___3.flags & 1L, 0L);
    if (tmp___9 != 0L) {
      tmp___8 = rtsx_dev((struct rtsx_chip  const  *)chip);
      __dynamic_dev_dbg(& descriptor___3, (struct device  const  *)tmp___8, "chip->int_reg = 0x%x\n",
                        chip->int_reg);
    } else {

    }
    err = -110;
    goto out;
  } else {

  }
  spin_lock_irq(& rtsx->reg_lock);
  if ((int )((signed char )rtsx->trans_result) == 2) {
    err = -5;
    spin_unlock_irq(& rtsx->reg_lock);
    goto out;
  } else {

  }
  spin_unlock_irq(& rtsx->reg_lock);
  spin_lock_irq(& rtsx->reg_lock);
  if ((int )((signed char )rtsx->trans_result) == 0) {
    init_completion(& trans_done);
    spin_unlock_irq(& rtsx->reg_lock);
    tmp___10 = msecs_to_jiffies((unsigned int const   )timeout);
    timeleft = wait_for_completion_interruptible_timeout(& trans_done, tmp___10);
    if (timeleft <= 0L) {
      descriptor___4.modname = "rts5208";
      descriptor___4.function = "rtsx_transfer_sglist_adma_partial";
      descriptor___4.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_transport.c";
      descriptor___4.format = "Timeout (%s %d)\n";
      descriptor___4.lineno = 458U;
      descriptor___4.flags = 0U;
      tmp___12 = ldv__builtin_expect((long )descriptor___4.flags & 1L, 0L);
      if (tmp___12 != 0L) {
        tmp___11 = rtsx_dev((struct rtsx_chip  const  *)chip);
        __dynamic_dev_dbg(& descriptor___4, (struct device  const  *)tmp___11, "Timeout (%s %d)\n",
                          "rtsx_transfer_sglist_adma_partial", 458);
      } else {

      }
      descriptor___5.modname = "rts5208";
      descriptor___5.function = "rtsx_transfer_sglist_adma_partial";
      descriptor___5.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_transport.c";
      descriptor___5.format = "chip->int_reg = 0x%x\n";
      descriptor___5.lineno = 460U;
      descriptor___5.flags = 0U;
      tmp___14 = ldv__builtin_expect((long )descriptor___5.flags & 1L, 0L);
      if (tmp___14 != 0L) {
        tmp___13 = rtsx_dev((struct rtsx_chip  const  *)chip);
        __dynamic_dev_dbg(& descriptor___5, (struct device  const  *)tmp___13, "chip->int_reg = 0x%x\n",
                          chip->int_reg);
      } else {

      }
      err = -110;
      goto out;
    } else {

    }
  } else {
    spin_unlock_irq(& rtsx->reg_lock);
  }
  spin_lock_irq(& rtsx->reg_lock);
  if ((int )((signed char )rtsx->trans_result) == 2) {
    err = -5;
  } else
  if ((int )((signed char )rtsx->trans_result) == 1) {
    err = 0;
  } else {

  }
  spin_unlock_irq(& rtsx->reg_lock);
  out: 
  rtsx->done = (struct completion *)0;
  rtsx->trans_state = 0;
  dma_unmap_sg_attrs(& (rtsx->pci)->dev, sg, num_sg, dma_dir, (struct dma_attrs *)0);
  if (err < 0) {
    rtsx_stop_cmd(chip, (int )card);
  } else {

  }
  return (err);
}
}
static int rtsx_transfer_sglist_adma(struct rtsx_chip *chip , u8 card , struct scatterlist *sg ,
                                     int num_sg , enum dma_data_direction dma_dir ,
                                     int timeout ) 
{ 
  struct rtsx_dev *rtsx ;
  struct completion trans_done ;
  u8 dir ;
  int buf_cnt ;
    klee_make_symbolic(&buf_cnt, sizeof(int), "buf_cnt");
  int i ;
  int err ;
  long timeleft ;
  struct scatterlist *sg_ptr ;
  u32 val ;
  int sg_cnt ;
  int j ;
  dma_addr_t addr ;
  unsigned int len ;
  u8 option ;
  struct _ddebug descriptor ;
  struct device *tmp ;
  long tmp___0 ;
  struct _ddebug descriptor___0 ;
  struct device *tmp___1 ;
  long tmp___2 ;
  unsigned long tmp___3 ;
  struct _ddebug descriptor___1 ;
  struct device *tmp___4 ;
  long tmp___5 ;
  struct _ddebug descriptor___2 ;
  struct device *tmp___6 ;
  long tmp___7 ;
  unsigned long tmp___8 ;
    klee_make_symbolic(&tmp___8, sizeof(long), "tmp___8");
  struct _ddebug descriptor___3 ;
  struct device *tmp___9 ;
  long tmp___10 ;
  struct _ddebug descriptor___4 ;
  struct device *tmp___11 ;
  long tmp___12 ;

  {
  rtsx = chip->rtsx;
  err = 0;
  if ((unsigned long )sg == (unsigned long )((struct scatterlist *)0) || num_sg <= 0) {
    return (-5);
  } else {

  }
  if ((unsigned int )dma_dir == 1U) {
    dir = 0U;
  } else
  if ((unsigned int )dma_dir == 2U) {
    dir = 1U;
  } else {
    return (-6);
  }
  if ((unsigned int )card == 4U) {
    rtsx->check_card_cd = 65536U;
  } else
  if ((unsigned int )card == 8U) {
    rtsx->check_card_cd = 131072U;
  } else
  if ((unsigned int )card == 16U) {
    rtsx->check_card_cd = 262144U;
  } else {
    rtsx->check_card_cd = 0U;
  }
  spin_lock_irq(& rtsx->reg_lock);
  rtsx->done = & trans_done;
  rtsx->trans_state = 3;
  rtsx->trans_result = 0;
  spin_unlock_irq(& rtsx->reg_lock);
  buf_cnt = dma_map_sg_attrs(& (rtsx->pci)->dev, sg, num_sg, dma_dir, (struct dma_attrs *)0);
  sg_ptr = sg;
  i = 0;
  goto ldv_38341;
  ldv_38340: 
  val = 2147483648U;
  if (buf_cnt / 384 == i) {
    sg_cnt = buf_cnt % 384;
  } else {
    sg_cnt = 384;
  }
  chip->sgi = 0;
  j = 0;
  goto ldv_38334;
  ldv_38333: 
  addr = sg_ptr->dma_address;
  len = sg_ptr->dma_length;
  descriptor.modname = "rts5208";
  descriptor.function = "rtsx_transfer_sglist_adma";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_transport.c";
  descriptor.format = "DMA addr: 0x%x, Len: 0x%x\n";
  descriptor.lineno = 548U;
  descriptor.flags = 0U;
  tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp___0 != 0L) {
    tmp = rtsx_dev((struct rtsx_chip  const  *)chip);
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)tmp, "DMA addr: 0x%x, Len: 0x%x\n",
                      (unsigned int )addr, len);
  } else {

  }
  if (sg_cnt + -1 == j) {
    option = 35U;
  } else {
    option = 33U;
  }
  rtsx_add_sg_tbl(chip, (unsigned int )addr, len, (int )option);
  sg_ptr = sg_next(sg_ptr);
  j = j + 1;
  ldv_38334: ;
  if (j < sg_cnt) {
    goto ldv_38333;
  } else {

  }
  descriptor___0.modname = "rts5208";
  descriptor___0.function = "rtsx_transfer_sglist_adma";
  descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_transport.c";
  descriptor___0.format = "SG table count = %d\n";
  descriptor___0.lineno = 560U;
  descriptor___0.flags = 0U;
  tmp___2 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
  if (tmp___2 != 0L) {
    tmp___1 = rtsx_dev((struct rtsx_chip  const  *)chip);
    __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)tmp___1, "SG table count = %d\n",
                      chip->sgi);
  } else {

  }
  val = (((unsigned int )dir & 1U) << 29) | val;
  val = val | 134217728U;
  spin_lock_irq(& rtsx->reg_lock);
  init_completion(& trans_done);
  iowrite32((u32 )chip->host_sg_tbl_addr, (chip->rtsx)->remap_addr + 8UL);
  iowrite32(val, (chip->rtsx)->remap_addr + 12UL);
  spin_unlock_irq(& rtsx->reg_lock);
  tmp___3 = msecs_to_jiffies((unsigned int const   )timeout);
  timeleft = wait_for_completion_interruptible_timeout(& trans_done, tmp___3);
  if (timeleft <= 0L) {
    descriptor___1.modname = "rts5208";
    descriptor___1.function = "rtsx_transfer_sglist_adma";
    descriptor___1.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_transport.c";
    descriptor___1.format = "Timeout (%s %d)\n";
    descriptor___1.lineno = 578U;
    descriptor___1.flags = 0U;
    tmp___5 = ldv__builtin_expect((long )descriptor___1.flags & 1L, 0L);
    if (tmp___5 != 0L) {
      tmp___4 = rtsx_dev((struct rtsx_chip  const  *)chip);
      __dynamic_dev_dbg(& descriptor___1, (struct device  const  *)tmp___4, "Timeout (%s %d)\n",
                        "rtsx_transfer_sglist_adma", 578);
    } else {

    }
    descriptor___2.modname = "rts5208";
    descriptor___2.function = "rtsx_transfer_sglist_adma";
    descriptor___2.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_transport.c";
    descriptor___2.format = "chip->int_reg = 0x%x\n";
    descriptor___2.lineno = 580U;
    descriptor___2.flags = 0U;
    tmp___7 = ldv__builtin_expect((long )descriptor___2.flags & 1L, 0L);
    if (tmp___7 != 0L) {
      tmp___6 = rtsx_dev((struct rtsx_chip  const  *)chip);
      __dynamic_dev_dbg(& descriptor___2, (struct device  const  *)tmp___6, "chip->int_reg = 0x%x\n",
                        chip->int_reg);
    } else {

    }
    err = -110;
    goto out;
  } else {

  }
  spin_lock_irq(& rtsx->reg_lock);
  if ((int )((signed char )rtsx->trans_result) == 2) {
    err = -5;
    spin_unlock_irq(& rtsx->reg_lock);
    goto out;
  } else {

  }
  spin_unlock_irq(& rtsx->reg_lock);
  sg_ptr = sg_ptr + (unsigned long )sg_cnt;
  i = i + 1;
  ldv_38341: ;
  if (buf_cnt / 384 >= i) {
    goto ldv_38340;
  } else {

  }
  spin_lock_irq(& rtsx->reg_lock);
  if ((int )((signed char )rtsx->trans_result) == 0) {
    init_completion(& trans_done);
    spin_unlock_irq(& rtsx->reg_lock);
    tmp___8 = msecs_to_jiffies((unsigned int const   )timeout);
    timeleft = wait_for_completion_interruptible_timeout(& trans_done, tmp___8);
    if (timeleft <= 0L) {
      descriptor___3.modname = "rts5208";
      descriptor___3.function = "rtsx_transfer_sglist_adma";
      descriptor___3.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_transport.c";
      descriptor___3.format = "Timeout (%s %d)\n";
      descriptor___3.lineno = 605U;
      descriptor___3.flags = 0U;
      tmp___10 = ldv__builtin_expect((long )descriptor___3.flags & 1L, 0L);
      if (tmp___10 != 0L) {
        tmp___9 = rtsx_dev((struct rtsx_chip  const  *)chip);
        __dynamic_dev_dbg(& descriptor___3, (struct device  const  *)tmp___9, "Timeout (%s %d)\n",
                          "rtsx_transfer_sglist_adma", 605);
      } else {

      }
      descriptor___4.modname = "rts5208";
      descriptor___4.function = "rtsx_transfer_sglist_adma";
      descriptor___4.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_transport.c";
      descriptor___4.format = "chip->int_reg = 0x%x\n";
      descriptor___4.lineno = 607U;
      descriptor___4.flags = 0U;
      tmp___12 = ldv__builtin_expect((long )descriptor___4.flags & 1L, 0L);
      if (tmp___12 != 0L) {
        tmp___11 = rtsx_dev((struct rtsx_chip  const  *)chip);
        __dynamic_dev_dbg(& descriptor___4, (struct device  const  *)tmp___11, "chip->int_reg = 0x%x\n",
                          chip->int_reg);
      } else {

      }
      err = -110;
      goto out;
    } else {

    }
  } else {
    spin_unlock_irq(& rtsx->reg_lock);
  }
  spin_lock_irq(& rtsx->reg_lock);
  if ((int )((signed char )rtsx->trans_result) == 2) {
    err = -5;
  } else
  if ((int )((signed char )rtsx->trans_result) == 1) {
    err = 0;
  } else {

  }
  spin_unlock_irq(& rtsx->reg_lock);
  out: 
  rtsx->done = (struct completion *)0;
  rtsx->trans_state = 0;
  dma_unmap_sg_attrs(& (rtsx->pci)->dev, sg, num_sg, dma_dir, (struct dma_attrs *)0);
  if (err < 0) {
    rtsx_stop_cmd(chip, (int )card);
  } else {

  }
  return (err);
}
}
static int rtsx_transfer_buf(struct rtsx_chip *chip , u8 card , void *buf , size_t len ,
                             enum dma_data_direction dma_dir , int timeout ) 
{ 
  struct rtsx_dev *rtsx ;
  struct completion trans_done ;
  dma_addr_t addr ;
  u8 dir ;
  int err ;
  u32 val ;
  long timeleft ;
  unsigned long tmp ;
  struct _ddebug descriptor ;
  struct device *tmp___0 ;
  long tmp___1 ;
  struct _ddebug descriptor___0 ;
  struct device *tmp___2 ;
  long tmp___3 ;

  {
  rtsx = chip->rtsx;
  err = 0;
  val = 2147483648U;
  if ((unsigned long )buf == (unsigned long )((void *)0) || len == 0UL) {
    return (-5);
  } else {

  }
  if ((unsigned int )dma_dir == 1U) {
    dir = 0U;
  } else
  if ((unsigned int )dma_dir == 2U) {
    dir = 1U;
  } else {
    return (-6);
  }
  addr = dma_map_single_attrs(& (rtsx->pci)->dev, buf, len, dma_dir, (struct dma_attrs *)0);
  if (addr == 0ULL) {
    return (-12);
  } else {

  }
  if ((unsigned int )card == 4U) {
    rtsx->check_card_cd = 65536U;
  } else
  if ((unsigned int )card == 8U) {
    rtsx->check_card_cd = 131072U;
  } else
  if ((unsigned int )card == 16U) {
    rtsx->check_card_cd = 262144U;
  } else {
    rtsx->check_card_cd = 0U;
  }
  val = (((unsigned int )dir & 1U) << 29) | val;
  val = ((u32 )len & 16777215U) | val;
  spin_lock_irq(& rtsx->reg_lock);
  rtsx->done = & trans_done;
  init_completion(& trans_done);
  rtsx->trans_state = 2;
  rtsx->trans_result = 0;
  iowrite32((u32 )addr, (chip->rtsx)->remap_addr + 8UL);
  iowrite32(val, (chip->rtsx)->remap_addr + 12UL);
  spin_unlock_irq(& rtsx->reg_lock);
  tmp = msecs_to_jiffies((unsigned int const   )timeout);
  timeleft = wait_for_completion_interruptible_timeout(& trans_done, tmp);
  if (timeleft <= 0L) {
    descriptor.modname = "rts5208";
    descriptor.function = "rtsx_transfer_buf";
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_transport.c";
    descriptor.format = "Timeout (%s %d)\n";
    descriptor.lineno = 691U;
    descriptor.flags = 0U;
    tmp___1 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
    if (tmp___1 != 0L) {
      tmp___0 = rtsx_dev((struct rtsx_chip  const  *)chip);
      __dynamic_dev_dbg(& descriptor, (struct device  const  *)tmp___0, "Timeout (%s %d)\n",
                        "rtsx_transfer_buf", 691);
    } else {

    }
    descriptor___0.modname = "rts5208";
    descriptor___0.function = "rtsx_transfer_buf";
    descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_transport.c";
    descriptor___0.format = "chip->int_reg = 0x%x\n";
    descriptor___0.lineno = 693U;
    descriptor___0.flags = 0U;
    tmp___3 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
    if (tmp___3 != 0L) {
      tmp___2 = rtsx_dev((struct rtsx_chip  const  *)chip);
      __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)tmp___2, "chip->int_reg = 0x%x\n",
                        chip->int_reg);
    } else {

    }
    err = -110;
    goto out;
  } else {

  }
  spin_lock_irq(& rtsx->reg_lock);
  if ((int )((signed char )rtsx->trans_result) == 2) {
    err = -5;
  } else
  if ((int )((signed char )rtsx->trans_result) == 1) {
    err = 0;
  } else {

  }
  spin_unlock_irq(& rtsx->reg_lock);
  out: 
  rtsx->done = (struct completion *)0;
  rtsx->trans_state = 0;
  dma_unmap_single_attrs(& (rtsx->pci)->dev, addr, len, dma_dir, (struct dma_attrs *)0);
  if (err < 0) {
    rtsx_stop_cmd(chip, (int )card);
  } else {

  }
  return (err);
}
}
int rtsx_transfer_data_partial(struct rtsx_chip *chip , u8 card , void *buf , size_t len ,
                               int use_sg , unsigned int *index , unsigned int *offset ,
                               enum dma_data_direction dma_dir , int timeout ) 
{ 
  int err ;

  {
  err = 0;
  if ((unsigned int )chip->rtsx_stat == 6U) {
    return (-5);
  } else {

  }
  if (use_sg != 0) {
    err = rtsx_transfer_sglist_adma_partial(chip, (int )card, (struct scatterlist *)buf,
                                            use_sg, index, offset, (int )len, dma_dir,
                                            timeout);
  } else {
    err = rtsx_transfer_buf(chip, (int )card, buf, len, dma_dir, timeout);
  }
  if (err < 0) {
    if ((int )chip->rtsx_flag & 1) {
      chip->rtsx_flag = (unsigned int )chip->rtsx_flag & 254U;
      chip->need_reinit = 28UL;
      rtsx_reinit_cards(chip, 1);
    } else {

    }
  } else {

  }
  return (err);
}
}
int rtsx_transfer_data(struct rtsx_chip *chip , u8 card , void *buf , size_t len ,
                       int use_sg , enum dma_data_direction dma_dir , int timeout ) 
{ 
  int err ;
  struct _ddebug descriptor ;
  struct device *tmp ;
  long tmp___0 ;

  {
  err = 0;
  descriptor.modname = "rts5208";
  descriptor.function = "rtsx_transfer_data";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_transport.c";
  descriptor.format = "use_sg = %d\n";
  descriptor.lineno = 751U;
  descriptor.flags = 0U;
  tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp___0 != 0L) {
    tmp = rtsx_dev((struct rtsx_chip  const  *)chip);
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)tmp, "use_sg = %d\n",
                      use_sg);
  } else {

  }
  if ((unsigned int )chip->rtsx_stat == 6U) {
    return (-5);
  } else {

  }
  if (use_sg != 0) {
    err = rtsx_transfer_sglist_adma(chip, (int )card, (struct scatterlist *)buf, use_sg,
                                    dma_dir, timeout);
  } else {
    err = rtsx_transfer_buf(chip, (int )card, buf, len, dma_dir, timeout);
  }
  if (err < 0) {
    if ((int )chip->rtsx_flag & 1) {
      chip->rtsx_flag = (unsigned int )chip->rtsx_flag & 254U;
      chip->need_reinit = 28UL;
      rtsx_reinit_cards(chip, 1);
    } else {

    }
  } else {

  }
  return (err);
}
}
void ldv_mutex_lock_97(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_lock_lock(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_98(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_unlock_lock(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_99(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
int ldv_mutex_trylock_100(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
  tmp = mutex_trylock(ldv_func_arg1);
  ldv_func_res = tmp;
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
  return (tmp___0);
  return (ldv_func_res);
}
}
void ldv_mutex_unlock_101(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_102(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_unlock_i_mutex_of_inode(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_103(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_lock_i_mutex_of_inode(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
int ldv_scsi_add_host_with_dma_104(struct Scsi_Host *shost , struct device *dev ,
                                   struct device *dma_dev ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  int tmp ;

  {
  tmp = scsi_add_host_with_dma(shost, dev, dma_dev);
  ldv_func_res = tmp;
  if (ldv_func_res == 0) {
    ldv_state_variable_3 = 1;
    ldv_initialize_scsi_host_template_3();
  } else {

  }
  return (ldv_func_res);
}
}
__inline static long ldv__builtin_expect(long exp , long c ) ;
int ldv_mutex_trylock_120(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_118(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_121(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_122(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_117(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_119(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_123(struct mutex *ldv_func_arg1 ) ;
int ldv_scsi_add_host_with_dma_124(struct Scsi_Host *shost , struct device *dev ,
                                   struct device *dma_dev ) ;
void set_sense_data(struct rtsx_chip *chip , unsigned int lun , u8 err_code , u8 sense_key ,
                    u32 info , u8 asc , u8 ascq , u8 sns_key_info0 , u16 sns_key_info1 ) ;
void sd_cleanup_work(struct rtsx_chip *chip ) ;
int sd_pass_thru_mode(struct scsi_cmnd *srb , struct rtsx_chip *chip ) ;
int sd_execute_no_data(struct scsi_cmnd *srb , struct rtsx_chip *chip ) ;
int sd_execute_read_data(struct scsi_cmnd *srb , struct rtsx_chip *chip ) ;
int sd_execute_write_data(struct scsi_cmnd *srb , struct rtsx_chip *chip ) ;
int sd_get_cmd_rsp(struct scsi_cmnd *srb , struct rtsx_chip *chip ) ;
int sd_hw_rst(struct scsi_cmnd *srb , struct rtsx_chip *chip ) ;
int card_rw(struct scsi_cmnd *srb , struct rtsx_chip *chip , u32 sec_addr , u16 sec_cnt ) ;
int check_card_exist(struct rtsx_chip *chip , unsigned int lun ) ;
int check_card_ready(struct rtsx_chip *chip , unsigned int lun ) ;
int check_card_wp(struct rtsx_chip *chip , unsigned int lun ) ;
void eject_card(struct rtsx_chip *chip , unsigned int lun ) ;
u8 get_lun_card(struct rtsx_chip *chip , unsigned int lun ) ;
__inline static u32 get_card_size(struct rtsx_chip *chip , unsigned int lun ) 
{ 
  struct sd_info *sd_card ;
  u8 tmp ;

  {
  sd_card = & chip->sd_card;
  tmp = get_lun_card(chip, lun);
  if ((unsigned int )tmp == 4U && (int )((signed char )sd_card->sd_lock_status) < 0) {
    return (0U);
  } else {

  }
  return (chip->capacity[lun]);
}
}
int card_power_on(struct rtsx_chip *chip , u8 card ) ;
int mspro_format(struct scsi_cmnd *srb , struct rtsx_chip *chip , int short_data_len ,
                 bool quick_format ) ;
void ms_cleanup_work(struct rtsx_chip *chip ) ;
int mg_set_leaf_id(struct scsi_cmnd *srb , struct rtsx_chip *chip ) ;
int mg_get_local_EKB(struct scsi_cmnd *srb , struct rtsx_chip *chip ) ;
int mg_chg(struct scsi_cmnd *srb , struct rtsx_chip *chip ) ;
int mg_get_rsp_chg(struct scsi_cmnd *srb , struct rtsx_chip *chip ) ;
int mg_rsp(struct scsi_cmnd *srb , struct rtsx_chip *chip ) ;
int mg_get_ICV(struct scsi_cmnd *srb , struct rtsx_chip *chip ) ;
int mg_set_ICV(struct scsi_cmnd *srb , struct rtsx_chip *chip ) ;
int spi_erase_eeprom_chip(struct rtsx_chip *chip ) ;
int spi_erase_eeprom_byte(struct rtsx_chip *chip , u16 addr ) ;
int spi_read_eeprom(struct rtsx_chip *chip , u16 addr , u8 *val ) ;
int spi_write_eeprom(struct rtsx_chip *chip , u16 addr , u8 val ) ;
int spi_get_status(struct scsi_cmnd *srb , struct rtsx_chip *chip ) ;
int spi_set_parameter(struct scsi_cmnd *srb , struct rtsx_chip *chip ) ;
int spi_read_flash_id(struct scsi_cmnd *srb , struct rtsx_chip *chip ) ;
int spi_read_flash(struct scsi_cmnd *srb , struct rtsx_chip *chip ) ;
int spi_write_flash(struct scsi_cmnd *srb , struct rtsx_chip *chip ) ;
int spi_erase_flash(struct scsi_cmnd *srb , struct rtsx_chip *chip ) ;
int spi_write_flash_status(struct scsi_cmnd *srb , struct rtsx_chip *chip ) ;
void scsi_show_command(struct rtsx_chip *chip ) 
{ 
  struct scsi_cmnd *srb ;
  char *what ;
  bool unknown_cmd ;
  int len ;
  struct _ddebug descriptor ;
  struct device *tmp ;
  long tmp___0 ;
  unsigned short __min1 ;
    klee_make_symbolic(&__min1, sizeof(short), "__min1");
  unsigned short __min2 ;
    klee_make_symbolic(&__min2, sizeof(short), "__min2");
  struct _ddebug descriptor___0 ;
  struct device *tmp___1 ;
  long tmp___2 ;

  {
  srb = chip->srb;
  what = (char *)0;
  unknown_cmd = 0;
  switch ((int )*(srb->cmnd)) {
  case 0: 
  what = (char *)"TEST_UNIT_READY";
  goto ldv_38527;
  case 1: 
  what = (char *)"REZERO_UNIT";
  goto ldv_38527;
  case 3: 
  what = (char *)"REQUEST_SENSE";
  goto ldv_38527;
  case 4: 
  what = (char *)"FORMAT_UNIT";
  goto ldv_38527;
  case 5: 
  what = (char *)"READ_BLOCK_LIMITS";
  goto ldv_38527;
  case 7: 
  what = (char *)"REASSIGN_BLOCKS";
  goto ldv_38527;
  case 8: 
  what = (char *)"READ_6";
  goto ldv_38527;
  case 10: 
  what = (char *)"WRITE_6";
  goto ldv_38527;
  case 11: 
  what = (char *)"SEEK_6";
  goto ldv_38527;
  case 15: 
  what = (char *)"READ_REVERSE";
  goto ldv_38527;
  case 16: 
  what = (char *)"WRITE_FILEMARKS";
  goto ldv_38527;
  case 17: 
  what = (char *)"SPACE";
  goto ldv_38527;
  case 18: 
  what = (char *)"INQUIRY";
  goto ldv_38527;
  case 20: 
  what = (char *)"RECOVER_BUFFERED_DATA";
  goto ldv_38527;
  case 21: 
  what = (char *)"MODE_SELECT";
  goto ldv_38527;
  case 22: 
  what = (char *)"RESERVE";
  goto ldv_38527;
  case 23: 
  what = (char *)"RELEASE";
  goto ldv_38527;
  case 24: 
  what = (char *)"COPY";
  goto ldv_38527;
  case 25: 
  what = (char *)"ERASE";
  goto ldv_38527;
  case 26: 
  what = (char *)"MODE_SENSE";
  goto ldv_38527;
  case 27: 
  what = (char *)"START_STOP";
  goto ldv_38527;
  case 28: 
  what = (char *)"RECEIVE_DIAGNOSTIC";
  goto ldv_38527;
  case 29: 
  what = (char *)"SEND_DIAGNOSTIC";
  goto ldv_38527;
  case 30: 
  what = (char *)"ALLOW_MEDIUM_REMOVAL";
  goto ldv_38527;
  case 36: 
  what = (char *)"SET_WINDOW";
  goto ldv_38527;
  case 37: 
  what = (char *)"READ_CAPACITY";
  goto ldv_38527;
  case 40: 
  what = (char *)"READ_10";
  goto ldv_38527;
  case 42: 
  what = (char *)"WRITE_10";
  goto ldv_38527;
  case 43: 
  what = (char *)"SEEK_10";
  goto ldv_38527;
  case 46: 
  what = (char *)"WRITE_VERIFY";
  goto ldv_38527;
  case 47: 
  what = (char *)"VERIFY";
  goto ldv_38527;
  case 48: 
  what = (char *)"SEARCH_HIGH";
  goto ldv_38527;
  case 49: 
  what = (char *)"SEARCH_EQUAL";
  goto ldv_38527;
  case 50: 
  what = (char *)"SEARCH_LOW";
  goto ldv_38527;
  case 51: 
  what = (char *)"SET_LIMITS";
  goto ldv_38527;
  case 52: 
  what = (char *)"READ_POSITION";
  goto ldv_38527;
  case 53: 
  what = (char *)"SYNCHRONIZE_CACHE";
  goto ldv_38527;
  case 54: 
  what = (char *)"LOCK_UNLOCK_CACHE";
  goto ldv_38527;
  case 55: 
  what = (char *)"READ_DEFECT_DATA";
  goto ldv_38527;
  case 56: 
  what = (char *)"MEDIUM_SCAN";
  goto ldv_38527;
  case 57: 
  what = (char *)"COMPARE";
  goto ldv_38527;
  case 58: 
  what = (char *)"COPY_VERIFY";
  goto ldv_38527;
  case 59: 
  what = (char *)"WRITE_BUFFER";
  goto ldv_38527;
  case 60: 
  what = (char *)"READ_BUFFER";
  goto ldv_38527;
  case 61: 
  what = (char *)"UPDATE_BLOCK";
  goto ldv_38527;
  case 62: 
  what = (char *)"READ_LONG";
  goto ldv_38527;
  case 63: 
  what = (char *)"WRITE_LONG";
  goto ldv_38527;
  case 64: 
  what = (char *)"CHANGE_DEFINITION";
  goto ldv_38527;
  case 65: 
  what = (char *)"WRITE_SAME";
  goto ldv_38527;
  case 66: 
  what = (char *)"READ SUBCHANNEL";
  goto ldv_38527;
  case 67: 
  what = (char *)"READ_TOC";
  goto ldv_38527;
  case 68: 
  what = (char *)"READ HEADER";
  goto ldv_38527;
  case 69: 
  what = (char *)"PLAY AUDIO (10)";
  goto ldv_38527;
  case 71: 
  what = (char *)"PLAY AUDIO MSF";
  goto ldv_38527;
  case 74: 
  what = (char *)"GET EVENT/STATUS NOTIFICATION";
  goto ldv_38527;
  case 75: 
  what = (char *)"PAUSE/RESUME";
  goto ldv_38527;
  case 76: 
  what = (char *)"LOG_SELECT";
  goto ldv_38527;
  case 77: 
  what = (char *)"LOG_SENSE";
  goto ldv_38527;
  case 78: 
  what = (char *)"STOP PLAY/SCAN";
  goto ldv_38527;
  case 81: 
  what = (char *)"READ DISC INFORMATION";
  goto ldv_38527;
  case 82: 
  what = (char *)"READ TRACK INFORMATION";
  goto ldv_38527;
  case 83: 
  what = (char *)"RESERVE TRACK";
  goto ldv_38527;
  case 84: 
  what = (char *)"SEND OPC";
  goto ldv_38527;
  case 85: 
  what = (char *)"MODE_SELECT_10";
  goto ldv_38527;
  case 88: 
  what = (char *)"REPAIR TRACK";
  goto ldv_38527;
  case 89: 
  what = (char *)"READ MASTER CUE";
  goto ldv_38527;
  case 90: 
  what = (char *)"MODE_SENSE_10";
  goto ldv_38527;
  case 91: 
  what = (char *)"CLOSE TRACK/SESSION";
  goto ldv_38527;
  case 92: 
  what = (char *)"READ BUFFER CAPACITY";
  goto ldv_38527;
  case 93: 
  what = (char *)"SEND CUE SHEET";
  goto ldv_38527;
  case 161: 
  what = (char *)"BLANK";
  goto ldv_38527;
  case 160: 
  what = (char *)"REPORT LUNS";
  goto ldv_38527;
  case 165: 
  what = (char *)"MOVE_MEDIUM or PLAY AUDIO (12)";
  goto ldv_38527;
  case 168: 
  what = (char *)"READ_12";
  goto ldv_38527;
  case 170: 
  what = (char *)"WRITE_12";
  goto ldv_38527;
  case 174: 
  what = (char *)"WRITE_VERIFY_12";
  goto ldv_38527;
  case 176: 
  what = (char *)"SEARCH_HIGH_12";
  goto ldv_38527;
  case 177: 
  what = (char *)"SEARCH_EQUAL_12";
  goto ldv_38527;
  case 178: 
  what = (char *)"SEARCH_LOW_12";
  goto ldv_38527;
  case 182: 
  what = (char *)"SEND_VOLUME_TAG";
  goto ldv_38527;
  case 184: 
  what = (char *)"READ_ELEMENT_STATUS";
  goto ldv_38527;
  case 185: 
  what = (char *)"READ CD MSF";
  goto ldv_38527;
  case 186: 
  what = (char *)"SCAN";
  goto ldv_38527;
  case 187: 
  what = (char *)"SET CD SPEED";
  goto ldv_38527;
  case 189: 
  what = (char *)"MECHANISM STATUS";
  goto ldv_38527;
  case 190: 
  what = (char *)"READ CD";
  goto ldv_38527;
  case 225: 
  what = (char *)"WRITE CONTINUE";
  goto ldv_38527;
  case 234: 
  what = (char *)"WRITE_LONG_2";
  goto ldv_38527;
  case 240: 
  what = (char *)"Realtek\'s vendor command";
  goto ldv_38527;
  default: 
  what = (char *)"(unknown command)";
  unknown_cmd = 1;
  goto ldv_38527;
  }
  ldv_38527: ;
  if ((unsigned int )*(srb->cmnd) != 0U) {
    descriptor.modname = "rts5208";
    descriptor.function = "scsi_show_command";
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_scsi.c";
    descriptor.format = "Command %s (%d bytes)\n";
    descriptor.lineno = 316U;
    descriptor.flags = 0U;
    tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
    if (tmp___0 != 0L) {
      tmp = rtsx_dev((struct rtsx_chip  const  *)chip);
      __dynamic_dev_dbg(& descriptor, (struct device  const  *)tmp, "Command %s (%d bytes)\n",
                        what, (int )srb->cmd_len);
    } else {

    }
  } else {

  }
  if ((int )unknown_cmd) {
    __min1 = srb->cmd_len;
    __min2 = 16U;
    len = (int )__min1 < (int )__min2 ? (int )__min1 : (int )__min2;
    descriptor___0.modname = "rts5208";
    descriptor___0.function = "scsi_show_command";
    descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_scsi.c";
    descriptor___0.format = "%*ph\n";
    descriptor___0.lineno = 320U;
    descriptor___0.flags = 0U;
    tmp___2 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
    if (tmp___2 != 0L) {
      tmp___1 = rtsx_dev((struct rtsx_chip  const  *)chip);
      __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)tmp___1, "%*ph\n",
                        len, srb->cmnd);
    } else {

    }
  } else {

  }
  return;
}
}
void set_sense_type(struct rtsx_chip *chip , unsigned int lun , int sense_type ) 
{ 


  {
  switch (sense_type) {
  case 1: 
  set_sense_data(chip, lun, 112, 6, 0U, 40, 0, 0, 0);
  goto ldv_38629;
  case 2: 
  set_sense_data(chip, lun, 112, 2, 0U, 58, 0, 0, 0);
  goto ldv_38629;
  case 3: 
  set_sense_data(chip, lun, 112, 5, 0U, 33, 0, 0, 0);
  goto ldv_38629;
  case 4: 
  set_sense_data(chip, lun, 112, 5, 0U, 37, 0, 0, 0);
  goto ldv_38629;
  case 5: 
  set_sense_data(chip, lun, 112, 7, 0U, 39, 0, 0, 0);
  goto ldv_38629;
  case 7: 
  set_sense_data(chip, lun, 112, 3, 0U, 17, 0, 0, 0);
  goto ldv_38629;
  case 8: 
  set_sense_data(chip, lun, 112, 3, 0U, 12, 2, 0, 0);
  goto ldv_38629;
  case 6: 
  set_sense_data(chip, lun, 112, 5, 0U, 36, 0, 64, 1);
  goto ldv_38629;
  case 9: 
  set_sense_data(chip, lun, 112, 2, 0U, 4, 4, 0, 0);
  goto ldv_38629;
  case 10: 
  set_sense_data(chip, lun, 112, 3, 0U, 49, 1, 0, 0);
  goto ldv_38629;
  case 11: 
  set_sense_data(chip, lun, 112, 5, 0U, 111, 2, 0, 0);
  goto ldv_38629;
  case 12: 
  set_sense_data(chip, lun, 112, 5, 0U, 111, 0, 0, 0);
  goto ldv_38629;
  case 13: 
  set_sense_data(chip, lun, 112, 2, 0U, 48, 0, 0, 0);
  goto ldv_38629;
  case 14: 
  set_sense_data(chip, lun, 112, 3, 0U, 12, 0, 0, 0);
  goto ldv_38629;
  case 16: 
  set_sense_data(chip, lun, 112, 7, 0U, 17, 19, 0, 0);
  goto ldv_38629;
  case 0: ;
  default: 
  set_sense_data(chip, lun, 112, 0, 0U, 0, 0, 0, 0);
  goto ldv_38629;
  }
  ldv_38629: ;
  return;
}
}
void set_sense_data(struct rtsx_chip *chip , unsigned int lun , u8 err_code , u8 sense_key ,
                    u32 info , u8 asc , u8 ascq , u8 sns_key_info0 , u16 sns_key_info1 ) 
{ 
  struct sense_data_t *sense ;

  {
  sense = (struct sense_data_t *)(& chip->sense_buffer) + (unsigned long )lun;
  sense->err_code = err_code;
  sense->sense_key = sense_key;
  sense->info[0] = (unsigned char )(info >> 24);
  sense->info[1] = (unsigned char )(info >> 16);
  sense->info[2] = (unsigned char )(info >> 8);
  sense->info[3] = (unsigned char )info;
  sense->ad_sense_len = 10U;
  sense->asc = asc;
  sense->ascq = ascq;
  if ((unsigned int )sns_key_info0 != 0U) {
    sense->sns_key_info[0] = (unsigned int )sns_key_info0 | 128U;
    sense->sns_key_info[1] = 0U;
    sense->sns_key_info[2] = (unsigned int )((unsigned char )sns_key_info1) & 15U;
  } else {

  }
  return;
}
}
static int test_unit_ready(struct scsi_cmnd *srb , struct rtsx_chip *chip ) 
{ 
  unsigned int lun ;
    klee_make_symbolic(&lun, sizeof(int), "lun");
  int tmp ;
  struct sd_info *sd_card ;
  u8 tmp___0 ;

  {
  lun = (unsigned int )(srb->device)->lun;
  tmp = check_card_ready(chip, lun);
  if (tmp == 0) {
    set_sense_type(chip, lun, 2);
    return (1);
  } else {

  }
  if ((((int )chip->lun_mc >> (int )lun) & 1) == 0) {
    chip->lun_mc = (u8 )((int )((signed char )chip->lun_mc) | (int )((signed char )(1 << (int )lun)));
    set_sense_type(chip, lun, 1);
    return (1);
  } else {

  }
  tmp___0 = get_lun_card(chip, (unsigned int )(srb->device)->lun);
  if ((unsigned int )tmp___0 == 4U) {
    sd_card = & chip->sd_card;
    if ((unsigned int )sd_card->sd_lock_notify != 0U) {
      sd_card->sd_lock_notify = 0U;
      set_sense_type(chip, lun, 1);
      return (1);
    } else
    if ((int )((signed char )sd_card->sd_lock_status) < 0) {
      set_sense_type(chip, lun, 16);
      return (1);
    } else {

    }
  } else {

  }
  return (0);
}
}
static unsigned char formatter_inquiry_str[20U]  = 
  {      77U,      69U,      77U,      79U, 
        82U,      89U,      83U,      84U, 
        73U,      67U,      75U,      45U, 
        77U,      71U,      11U,      0U, 
        0U,      32U,      32U,      32U};
static int inquiry(struct scsi_cmnd *srb , struct rtsx_chip *chip ) 
{ 
  unsigned int lun ;
  char *inquiry_default ;
  char *inquiry_sdms ;
  char *inquiry_sd ;
  char *inquiry_ms ;
  char *inquiry_string ;
  unsigned char sendbytes ;
    klee_make_symbolic(&sendbytes, sizeof(char), "sendbytes");
  unsigned char *buf ;
  u8 card ;
  u8 tmp ;
  bool pro_formatter_flag ;
  unsigned char inquiry_buf[8U] ;
  unsigned int tmp___0 ;
  void *tmp___1 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;
  unsigned int tmp___4 ;
  unsigned int tmp___5 ;
  unsigned int tmp___6 ;

  {
  lun = (unsigned int )(srb->device)->lun;
  inquiry_default = (char *)"Generic-xD/SD/M.S.      1.00 ";
  inquiry_sdms = (char *)"Generic-SD/MemoryStick  1.00 ";
  inquiry_sd = (char *)"Generic-SD/MMC          1.00 ";
  inquiry_ms = (char *)"Generic-MemoryStick     1.00 ";
  tmp = get_lun_card(chip, lun);
  card = tmp;
  pro_formatter_flag = 0;
  inquiry_buf[0] = 0U;
  inquiry_buf[1] = 141U;
  inquiry_buf[2] = 0U;
  inquiry_buf[3] = 1U;
  inquiry_buf[4] = 31U;
  inquiry_buf[5] = 2U;
  inquiry_buf[6] = 0U;
  inquiry_buf[7] = 0U;
  if ((unsigned int )chip->lun_mode == 1U) {
    if ((unsigned int )chip->lun2card[lun] == 4U) {
      inquiry_string = inquiry_sd;
    } else {
      inquiry_string = inquiry_ms;
    }
  } else
  if ((unsigned int )chip->lun_mode == 2U) {
    inquiry_string = inquiry_sdms;
  } else {
    inquiry_string = inquiry_default;
  }
  tmp___0 = scsi_bufflen(srb);
  tmp___1 = vmalloc((unsigned long )tmp___0);
  buf = (unsigned char *)tmp___1;
  if ((unsigned long )buf == (unsigned long )((unsigned char *)0U)) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_scsi.c",
                "inquiry", 511);
    return (3);
  } else {

  }
  if (chip->mspro_formatter_enable != 0 && ((int )chip->lun2card[lun] & 8) != 0) {
    if ((unsigned int )card == 0U || (unsigned int )card == 8U) {
      pro_formatter_flag = 1;
    } else {

    }
  } else {

  }
  if ((int )pro_formatter_flag) {
    tmp___3 = scsi_bufflen(srb);
    if (tmp___3 <= 55U) {
      tmp___2 = scsi_bufflen(srb);
      sendbytes = (unsigned char )tmp___2;
    } else {
      sendbytes = 56U;
    }
  } else {
    tmp___5 = scsi_bufflen(srb);
    if (tmp___5 <= 35U) {
      tmp___4 = scsi_bufflen(srb);
      sendbytes = (unsigned char )tmp___4;
    } else {
      sendbytes = 36U;
    }
  }
  if ((unsigned int )sendbytes > 8U) {
    memcpy((void *)buf, (void const   *)(& inquiry_buf), 8UL);
    memcpy((void *)buf + 8U, (void const   *)inquiry_string, (size_t )((int )sendbytes + -8));
    if ((int )pro_formatter_flag) {
      *(buf + 4UL) = 51U;
    } else {

    }
  } else {
    memcpy((void *)buf, (void const   *)(& inquiry_buf), (size_t )sendbytes);
  }
  if ((int )pro_formatter_flag) {
    if ((unsigned int )sendbytes > 36U) {
      memcpy((void *)buf + 36U, (void const   *)(& formatter_inquiry_str), (size_t )((int )sendbytes + -36));
    } else {

    }
  } else {

  }
  scsi_set_resid(srb, 0);
  tmp___6 = scsi_bufflen(srb);
  rtsx_stor_set_xfer_buf(buf, tmp___6, srb);
  vfree((void const   *)buf);
  return (0);
}
}
static int start_stop_unit(struct scsi_cmnd *srb , struct rtsx_chip *chip ) 
{ 
  unsigned int lun ;
  unsigned int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  lun = (unsigned int )(srb->device)->lun;
  tmp = scsi_bufflen(srb);
  scsi_set_resid(srb, (int )tmp);
  if ((unsigned int )*(srb->cmnd + 1UL) == 1U) {
    return (0);
  } else {

  }
  switch ((int )*(srb->cmnd + 4UL)) {
  case 0: ;
  return (0);
  case 2: 
  tmp___0 = check_card_ready(chip, lun);
  if (tmp___0 != 0) {
    eject_card(chip, lun);
  } else {

  }
  return (0);
  case 1: ;
  case 3: 
  tmp___1 = check_card_ready(chip, lun);
  if (tmp___1 != 0) {
    return (0);
  } else {

  }
  set_sense_type(chip, lun, 2);
  _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_scsi.c",
              "start_stop_unit", 587);
  return (1);
  }
  _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_scsi.c",
              "start_stop_unit", 593);
  return (3);
}
}
static int allow_medium_removal(struct scsi_cmnd *srb , struct rtsx_chip *chip ) 
{ 
  int prevent ;
    klee_make_symbolic(&prevent, sizeof(int), "prevent");

  {
  prevent = (int )*(srb->cmnd + 4UL) & 1;
  scsi_set_resid(srb, 0);
  if (prevent != 0) {
    set_sense_type(chip, (unsigned int )(srb->device)->lun, 6);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_scsi.c",
                "allow_medium_removal", 609);
    return (1);
  } else {

  }
  return (0);
}
}
static int request_sense(struct scsi_cmnd *srb , struct rtsx_chip *chip ) 
{ 
  struct sense_data_t *sense ;
  unsigned int lun ;
  struct ms_info *ms_card ;
  unsigned char *tmp ;
  unsigned char *buf ;
  u8 tmp___0 ;
  unsigned int tmp___1 ;
  void *tmp___2 ;
  unsigned int tmp___3 ;
  unsigned int tmp___4 ;

  {
  lun = (unsigned int )(srb->device)->lun;
  ms_card = & chip->ms_card;
  sense = (struct sense_data_t *)(& chip->sense_buffer) + (unsigned long )lun;
  tmp___0 = get_lun_card(chip, lun);
  if ((unsigned int )tmp___0 == 8U && ms_card->pro_under_formatting != 0) {
    if (ms_card->format_status == 0) {
      set_sense_type(chip, lun, 0);
      ms_card->pro_under_formatting = 0;
      ms_card->progress = 0U;
    } else
    if (ms_card->format_status == 2) {
      set_sense_data(chip, lun, 112, 2, 0U, 4, 4, 0, (int )ms_card->progress);
    } else {
      set_sense_type(chip, lun, 10);
      ms_card->pro_under_formatting = 0;
      ms_card->progress = 0U;
    }
    chip->idle_counter = 0;
    chip->rtsx_stat = 2;
  } else {

  }
  tmp___1 = scsi_bufflen(srb);
  tmp___2 = vmalloc((unsigned long )tmp___1);
  buf = (unsigned char *)tmp___2;
  if ((unsigned long )buf == (unsigned long )((unsigned char *)0U)) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_scsi.c",
                "request_sense", 648);
    return (3);
  } else {

  }
  tmp = (unsigned char *)sense;
  tmp___3 = scsi_bufflen(srb);
  memcpy((void *)buf, (void const   *)tmp, (size_t )tmp___3);
  tmp___4 = scsi_bufflen(srb);
  rtsx_stor_set_xfer_buf(buf, tmp___4, srb);
  vfree((void const   *)buf);
  scsi_set_resid(srb, 0);
  set_sense_type(chip, lun, 0);
  return (0);
}
}
static void ms_mode_sense(struct rtsx_chip *chip , u8 cmd , int lun , u8 *buf , int buf_len ) 
{ 
  struct ms_info *ms_card ;
  int sys_info_offset ;
    klee_make_symbolic(&sys_info_offset, sizeof(int), "sys_info_offset");
  int data_size ;
  bool support_format ;
  int i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
    klee_make_symbolic(&tmp___18, sizeof(int), "tmp___18");
  int tmp___19 ;
  int tmp___20 ;
    klee_make_symbolic(&tmp___20, sizeof(int), "tmp___20");
  int tmp___21 ;
  int tmp___22 ;
    klee_make_symbolic(&tmp___22, sizeof(int), "tmp___22");
  int tmp___23 ;
  int tmp___24 ;
    klee_make_symbolic(&tmp___24, sizeof(int), "tmp___24");
  int len ;

  {
  ms_card = & chip->ms_card;
  data_size = buf_len;
  support_format = 0;
  i = 0;
  if ((unsigned int )cmd == 26U) {
    sys_info_offset = 8;
    if (data_size > 104) {
      data_size = 104;
    } else {

    }
    tmp = i;
    i = i + 1;
    *(buf + (unsigned long )tmp) = 103U;
  } else {
    sys_info_offset = 12;
    if (data_size > 108) {
      data_size = 108;
    } else {

    }
    tmp___0 = i;
    i = i + 1;
    *(buf + (unsigned long )tmp___0) = 0U;
    tmp___1 = i;
    i = i + 1;
    *(buf + (unsigned long )tmp___1) = 106U;
  }
  tmp___10 = check_card_ready(chip, (unsigned int )lun);
  if (tmp___10 != 0) {
    if (((int )ms_card->ms_type & 255) == 1 && ((int )ms_card->ms_type & 2048) != 0) {
      support_format = 1;
      tmp___2 = i;
      i = i + 1;
      *(buf + (unsigned long )tmp___2) = 64U;
    } else
    if (((int )ms_card->ms_type & 255) == 1) {
      support_format = 1;
      tmp___3 = i;
      i = i + 1;
      *(buf + (unsigned long )tmp___3) = 32U;
    } else {
      tmp___4 = i;
      i = i + 1;
      *(buf + (unsigned long )tmp___4) = 16U;
    }
    tmp___7 = check_card_wp(chip, (unsigned int )lun);
    if (tmp___7 != 0) {
      tmp___5 = i;
      i = i + 1;
      *(buf + (unsigned long )tmp___5) = 128U;
    } else {
      tmp___6 = i;
      i = i + 1;
      *(buf + (unsigned long )tmp___6) = 0U;
    }
  } else {
    tmp___8 = i;
    i = i + 1;
    *(buf + (unsigned long )tmp___8) = 0U;
    tmp___9 = i;
    i = i + 1;
    *(buf + (unsigned long )tmp___9) = 0U;
  }
  tmp___11 = i;
  i = i + 1;
  *(buf + (unsigned long )tmp___11) = 0U;
  if ((unsigned int )cmd == 90U) {
    tmp___12 = i;
    i = i + 1;
    *(buf + (unsigned long )tmp___12) = 0U;
    tmp___13 = i;
    i = i + 1;
    *(buf + (unsigned long )tmp___13) = 0U;
    tmp___14 = i;
    i = i + 1;
    *(buf + (unsigned long )tmp___14) = 0U;
    if (data_size > 8) {
      tmp___15 = i;
      i = i + 1;
      *(buf + (unsigned long )tmp___15) = 32U;
    } else {

    }
    if (data_size > 9) {
      tmp___16 = i;
      i = i + 1;
      *(buf + (unsigned long )tmp___16) = 98U;
    } else {

    }
    if (data_size > 10) {
      tmp___17 = i;
      i = i + 1;
      *(buf + (unsigned long )tmp___17) = 0U;
    } else {

    }
    if (data_size > 11) {
      if ((int )support_format) {
        tmp___18 = i;
        i = i + 1;
        *(buf + (unsigned long )tmp___18) = 192U;
      } else {
        tmp___19 = i;
        i = i + 1;
        *(buf + (unsigned long )tmp___19) = 0U;
      }
    } else {

    }
  } else {
    if (data_size > 4) {
      tmp___20 = i;
      i = i + 1;
      *(buf + (unsigned long )tmp___20) = 32U;
    } else {

    }
    if (data_size > 5) {
      tmp___21 = i;
      i = i + 1;
      *(buf + (unsigned long )tmp___21) = 98U;
    } else {

    }
    if (data_size > 6) {
      tmp___22 = i;
      i = i + 1;
      *(buf + (unsigned long )tmp___22) = 0U;
    } else {

    }
    if (data_size > 7) {
      if ((int )support_format) {
        tmp___23 = i;
        i = i + 1;
        *(buf + (unsigned long )tmp___23) = 192U;
      } else {
        tmp___24 = i;
        i = i + 1;
        *(buf + (unsigned long )tmp___24) = 0U;
      }
    } else {

    }
  }
  if (data_size > sys_info_offset) {
    len = data_size - sys_info_offset;
    len = 96 < len ? 96 : len;
    memcpy((void *)buf + (unsigned long )sys_info_offset, (void const   *)(& ms_card->raw_sys_info),
             (size_t )len);
  } else {

  }
  return;
}
}
static int mode_sense(struct scsi_cmnd *srb , struct rtsx_chip *chip ) 
{ 
  unsigned int lun ;
  unsigned int dataSize ;
    klee_make_symbolic(&dataSize, sizeof(int), "dataSize");
  int status ;
    klee_make_symbolic(&status, sizeof(int), "status");
  bool pro_formatter_flag ;
  unsigned char pageCode ;
    klee_make_symbolic(&pageCode, sizeof(char), "pageCode");
  unsigned char *buf ;
  u8 card ;
  u8 tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  unsigned int tmp___3 ;
  unsigned int len ;
  unsigned int __min1 ;
  unsigned int tmp___4 ;
  unsigned int __min2 ;
  unsigned int tmp___5 ;

  {
  lun = (unsigned int )(srb->device)->lun;
  tmp = get_lun_card(chip, lun);
  card = tmp;
  pro_formatter_flag = 0;
  dataSize = 8U;
  if (((int )chip->lun2card[lun] & 8) != 0) {
    if ((unsigned int )card == 0U || (unsigned int )card == 8U) {
      dataSize = 108U;
      if (chip->mspro_formatter_enable != 0) {
        pro_formatter_flag = 1;
      } else {

      }
    } else {

    }
  } else {

  }
  tmp___0 = kmalloc((size_t )dataSize, 208U);
  buf = (unsigned char *)tmp___0;
  if ((unsigned long )buf == (unsigned long )((unsigned char *)0U)) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_scsi.c",
                "mode_sense", 796);
    return (3);
  } else {

  }
  pageCode = (unsigned int )*(srb->cmnd + 2UL) & 63U;
  if ((((unsigned int )pageCode == 63U || (unsigned int )pageCode == 28U) || (unsigned int )pageCode == 0U) || ((int )pro_formatter_flag && (unsigned int )pageCode == 32U)) {
    if ((unsigned int )*(srb->cmnd) == 26U) {
      if ((unsigned int )pageCode == 63U || (unsigned int )pageCode == 32U) {
        ms_mode_sense(chip, (int )*(srb->cmnd), (int )lun, buf, (int )dataSize);
      } else {
        dataSize = 4U;
        *buf = 3U;
        *(buf + 1UL) = 0U;
        tmp___1 = check_card_wp(chip, lun);
        if (tmp___1 != 0) {
          *(buf + 2UL) = 128U;
        } else {
          *(buf + 2UL) = 0U;
        }
        *(buf + 3UL) = 0U;
      }
    } else
    if ((unsigned int )pageCode == 63U || (unsigned int )pageCode == 32U) {
      ms_mode_sense(chip, (int )*(srb->cmnd), (int )lun, buf, (int )dataSize);
    } else {
      dataSize = 8U;
      *buf = 0U;
      *(buf + 1UL) = 6U;
      *(buf + 2UL) = 0U;
      tmp___2 = check_card_wp(chip, lun);
      if (tmp___2 != 0) {
        *(buf + 3UL) = 128U;
      } else {
        *(buf + 3UL) = 0U;
      }
      *(buf + 4UL) = 0U;
      *(buf + 5UL) = 0U;
      *(buf + 6UL) = 0U;
      *(buf + 7UL) = 0U;
    }
    status = 0;
  } else {
    set_sense_type(chip, lun, 6);
    tmp___3 = scsi_bufflen(srb);
    scsi_set_resid(srb, (int )tmp___3);
    status = 1;
  }
  if (status == 0) {
    tmp___4 = scsi_bufflen(srb);
    __min1 = tmp___4;
    __min2 = dataSize;
    len = __min1 < __min2 ? __min1 : __min2;
    rtsx_stor_set_xfer_buf(buf, len, srb);
    tmp___5 = scsi_bufflen(srb);
    scsi_set_resid(srb, (int )(tmp___5 - len));
  } else {

  }
  kfree((void const   *)buf);
  return (status);
}
}
static int read_write(struct scsi_cmnd *srb , struct rtsx_chip *chip ) 
{ 
  struct sd_info *sd_card ;
  unsigned int lun ;
  int retval ;
  u32 start_sec ;
  u16 sec_cnt ;
  struct task_struct *tmp ;
  long volatile   __ret ;
  struct task_struct *tmp___0 ;
  struct task_struct *tmp___1 ;
  struct task_struct *tmp___2 ;
  struct task_struct *tmp___3 ;
  int tmp___4 ;
  u32 tmp___5 ;
  struct _ddebug descriptor ;
  struct device *tmp___6 ;
  long tmp___7 ;
  struct _ddebug descriptor___0 ;
  struct device *tmp___8 ;
  long tmp___9 ;
  u8 tmp___10 ;
  u32 tmp___11 ;
  u32 tmp___12 ;
  struct _ddebug descriptor___1 ;
  struct device *tmp___13 ;
  long tmp___14 ;
  struct _ddebug descriptor___2 ;
  struct device *tmp___15 ;
  long tmp___16 ;
  int tmp___17 ;

  {
  sd_card = & chip->sd_card;
  lun = (unsigned int )(srb->device)->lun;
  rtsx_disable_aspm(chip);
  if (chip->ss_en != 0 && (unsigned int )chip->rtsx_stat == 3U) {
    rtsx_exit_ss(chip);
    tmp = get_current();
    tmp->task_state_change = 0UL;
    __ret = 1L;
    switch (8UL) {
    case 1UL: 
    tmp___0 = get_current();
    __asm__  volatile   ("xchgb %b0, %1\n": "+q" (__ret), "+m" (tmp___0->state): : "memory",
                         "cc");
    goto ldv_38747;
    case 2UL: 
    tmp___1 = get_current();
    __asm__  volatile   ("xchgw %w0, %1\n": "+r" (__ret), "+m" (tmp___1->state): : "memory",
                         "cc");
    goto ldv_38747;
    case 4UL: 
    tmp___2 = get_current();
    __asm__  volatile   ("xchgl %0, %1\n": "+r" (__ret), "+m" (tmp___2->state): : "memory",
                         "cc");
    goto ldv_38747;
    case 8UL: 
    tmp___3 = get_current();
    __asm__  volatile   ("xchgq %q0, %1\n": "+r" (__ret), "+m" (tmp___3->state): : "memory",
                         "cc");
    goto ldv_38747;
    default: 
    __xchg_wrong_size();
    }
    ldv_38747: 
    schedule_timeout(25L);
  } else {

  }
  chip->idle_counter = 0;
  chip->rtsx_stat = 2;
  tmp___4 = check_card_ready(chip, lun);
  if (tmp___4 == 0) {
    set_sense_type(chip, lun, 2);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_scsi.c",
                "read_write", 877);
    return (1);
  } else {
    tmp___5 = get_card_size(chip, lun);
    if (tmp___5 == 0U) {
      set_sense_type(chip, lun, 2);
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_scsi.c",
                  "read_write", 877);
      return (1);
    } else {

    }
  }
  if ((((int )chip->lun_mc >> (int )lun) & 1) == 0) {
    chip->lun_mc = (u8 )((int )((signed char )chip->lun_mc) | (int )((signed char )(1 << (int )lun)));
    set_sense_type(chip, lun, 1);
    return (1);
  } else {

  }
  if ((unsigned int )sd_card->sd_erase_status != 0U) {
    descriptor.modname = "rts5208";
    descriptor.function = "read_write";
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_scsi.c";
    descriptor.format = "SD card being erased!\n";
    descriptor.lineno = 892U;
    descriptor.flags = 0U;
    tmp___7 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
    if (tmp___7 != 0L) {
      tmp___6 = rtsx_dev((struct rtsx_chip  const  *)chip);
      __dynamic_dev_dbg(& descriptor, (struct device  const  *)tmp___6, "SD card being erased!\n");
    } else {

    }
    set_sense_type(chip, lun, 16);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_scsi.c",
                "read_write", 894);
    return (1);
  } else {

  }
  tmp___10 = get_lun_card(chip, lun);
  if ((unsigned int )tmp___10 == 4U) {
    if ((int )((signed char )sd_card->sd_lock_status) < 0) {
      descriptor___0.modname = "rts5208";
      descriptor___0.function = "read_write";
      descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_scsi.c";
      descriptor___0.format = "SD card locked!\n";
      descriptor___0.lineno = 900U;
      descriptor___0.flags = 0U;
      tmp___9 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
      if (tmp___9 != 0L) {
        tmp___8 = rtsx_dev((struct rtsx_chip  const  *)chip);
        __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)tmp___8, "SD card locked!\n");
      } else {

      }
      set_sense_type(chip, lun, 16);
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_scsi.c",
                  "read_write", 903);
      return (1);
    } else {

    }
  } else {

  }
  if ((unsigned int )*(srb->cmnd) == 40U || (unsigned int )*(srb->cmnd) == 42U) {
    start_sec = ((((unsigned int )*(srb->cmnd + 2UL) << 24) | ((unsigned int )*(srb->cmnd + 3UL) << 16)) | ((unsigned int )*(srb->cmnd + 4UL) << 8)) | (unsigned int )*(srb->cmnd + 5UL);
    sec_cnt = (u16 )((int )((short )((int )*(srb->cmnd + 7UL) << 8)) | (int )((short )*(srb->cmnd + 8UL)));
  } else
  if ((unsigned int )*(srb->cmnd) == 8U || (unsigned int )*(srb->cmnd) == 10U) {
    start_sec = ((((unsigned int )*(srb->cmnd + 1UL) & 31U) << 16) | ((unsigned int )*(srb->cmnd + 2UL) << 8)) | (unsigned int )*(srb->cmnd + 3UL);
    sec_cnt = (u16 )*(srb->cmnd + 4UL);
    if ((unsigned int )sec_cnt == 0U) {
      sec_cnt = 256U;
    } else {

    }
  } else
  if (((unsigned int )*(srb->cmnd) == 240U && (unsigned int )*(srb->cmnd + 1UL) == 16U) && ((unsigned int )*(srb->cmnd + 2UL) == 26U || (unsigned int )*(srb->cmnd + 2UL) == 10U)) {
    start_sec = ((((unsigned int )*(srb->cmnd + 4UL) << 24) | ((unsigned int )*(srb->cmnd + 5UL) << 16)) | ((unsigned int )*(srb->cmnd + 6UL) << 8)) | (unsigned int )*(srb->cmnd + 7UL);
    sec_cnt = (u16 )((int )((short )((int )*(srb->cmnd + 9UL) << 8)) | (int )((short )*(srb->cmnd + 10UL)));
  } else {
    set_sense_type(chip, lun, 6);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_scsi.c",
                "read_write", 929);
    return (1);
  }
  tmp___11 = get_card_size(chip, lun);
  if (tmp___11 < start_sec) {
    set_sense_type(chip, lun, 3);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_scsi.c",
                "read_write", 940);
    return (1);
  } else {
    tmp___12 = get_card_size(chip, lun);
    if ((u32 )sec_cnt + start_sec > tmp___12) {
      set_sense_type(chip, lun, 3);
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_scsi.c",
                  "read_write", 940);
      return (1);
    } else {

    }
  }
  if ((unsigned int )sec_cnt == 0U) {
    scsi_set_resid(srb, 0);
    return (0);
  } else {

  }
  if (chip->rw_fail_cnt[lun] == 3) {
    descriptor___1.modname = "rts5208";
    descriptor___1.function = "read_write";
    descriptor___1.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_scsi.c";
    descriptor___1.format = "read/write fail three times in succession\n";
    descriptor___1.lineno = 950U;
    descriptor___1.flags = 0U;
    tmp___14 = ldv__builtin_expect((long )descriptor___1.flags & 1L, 0L);
    if (tmp___14 != 0L) {
      tmp___13 = rtsx_dev((struct rtsx_chip  const  *)chip);
      __dynamic_dev_dbg(& descriptor___1, (struct device  const  *)tmp___13, "read/write fail three times in succession\n");
    } else {

    }
    if ((unsigned int )srb->sc_data_direction == 2U) {
      set_sense_type(chip, lun, 7);
    } else {
      set_sense_type(chip, lun, 8);
    }
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_scsi.c",
                "read_write", 957);
    return (1);
  } else {

  }
  if ((unsigned int )srb->sc_data_direction == 1U) {
    tmp___17 = check_card_wp(chip, lun);
    if (tmp___17 != 0) {
      descriptor___2.modname = "rts5208";
      descriptor___2.function = "read_write";
      descriptor___2.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_scsi.c";
      descriptor___2.format = "Write protected card!\n";
      descriptor___2.lineno = 963U;
      descriptor___2.flags = 0U;
      tmp___16 = ldv__builtin_expect((long )descriptor___2.flags & 1L, 0L);
      if (tmp___16 != 0L) {
        tmp___15 = rtsx_dev((struct rtsx_chip  const  *)chip);
        __dynamic_dev_dbg(& descriptor___2, (struct device  const  *)tmp___15, "Write protected card!\n");
      } else {

      }
      set_sense_type(chip, lun, 5);
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_scsi.c",
                  "read_write", 966);
      return (1);
    } else {

    }
  } else {

  }
  retval = card_rw(srb, chip, start_sec, (int )sec_cnt);
  if (retval != 0) {
    if ((chip->need_release & (unsigned long )chip->lun2card[lun]) != 0UL) {
      chip->rw_fail_cnt[lun] = 0;
      set_sense_type(chip, lun, 2);
    } else {
      chip->rw_fail_cnt[lun] = chip->rw_fail_cnt[lun] + 1;
      if ((unsigned int )srb->sc_data_direction == 2U) {
        set_sense_type(chip, lun, 7);
      } else {
        set_sense_type(chip, lun, 8);
      }
    }
    retval = 1;
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_scsi.c",
                "read_write", 986);
    goto Exit;
  } else {
    chip->rw_fail_cnt[lun] = 0;
    retval = 0;
  }
  scsi_set_resid(srb, 0);
  Exit: ;
  return (retval);
}
}
static int read_format_capacity(struct scsi_cmnd *srb , struct rtsx_chip *chip ) 
{ 
  unsigned char *buf ;
  unsigned int lun ;
  unsigned int buf_len ;
    klee_make_symbolic(&buf_len, sizeof(int), "buf_len");
  u8 card ;
  u8 tmp ;
  u32 card_size ;
  int desc_cnt ;
    klee_make_symbolic(&desc_cnt, sizeof(int), "desc_cnt");
  int i ;
  int tmp___0 ;
  unsigned int tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  unsigned int __min1 ;
  unsigned int tmp___24 ;
  unsigned int __min2 ;
  unsigned int tmp___25 ;

  {
  lun = (unsigned int )(srb->device)->lun;
  tmp = get_lun_card(chip, lun);
  card = tmp;
  i = 0;
  tmp___0 = check_card_ready(chip, lun);
  if (tmp___0 == 0) {
    if (chip->mspro_formatter_enable == 0) {
      set_sense_type(chip, lun, 2);
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_scsi.c",
                  "read_format_capacity", 1012);
      return (1);
    } else {

    }
  } else {

  }
  tmp___1 = scsi_bufflen(srb);
  buf_len = tmp___1 > 12U ? 20U : 12U;
  tmp___2 = kmalloc((size_t )buf_len, 208U);
  buf = (unsigned char *)tmp___2;
  if ((unsigned long )buf == (unsigned long )((unsigned char *)0U)) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_scsi.c",
                "read_format_capacity", 1021);
    return (3);
  } else {

  }
  tmp___3 = i;
  i = i + 1;
  *(buf + (unsigned long )tmp___3) = 0U;
  tmp___4 = i;
  i = i + 1;
  *(buf + (unsigned long )tmp___4) = 0U;
  tmp___5 = i;
  i = i + 1;
  *(buf + (unsigned long )tmp___5) = 0U;
  if (((buf_len > 12U && chip->mspro_formatter_enable != 0) && ((int )chip->lun2card[lun] & 8) != 0) && ((unsigned int )card == 0U || (unsigned int )card == 8U)) {
    tmp___6 = i;
    i = i + 1;
    *(buf + (unsigned long )tmp___6) = 16U;
    desc_cnt = 2;
  } else {
    tmp___7 = i;
    i = i + 1;
    *(buf + (unsigned long )tmp___7) = 8U;
    desc_cnt = 1;
  }
  goto ldv_38772;
  ldv_38771: 
  tmp___20 = check_card_ready(chip, lun);
  if (tmp___20 != 0) {
    card_size = get_card_size(chip, lun);
    tmp___8 = i;
    i = i + 1;
    *(buf + (unsigned long )tmp___8) = (unsigned char )(card_size >> 24);
    tmp___9 = i;
    i = i + 1;
    *(buf + (unsigned long )tmp___9) = (unsigned char )(card_size >> 16);
    tmp___10 = i;
    i = i + 1;
    *(buf + (unsigned long )tmp___10) = (unsigned char )(card_size >> 8);
    tmp___11 = i;
    i = i + 1;
    *(buf + (unsigned long )tmp___11) = (unsigned char )card_size;
    if (desc_cnt == 2) {
      tmp___12 = i;
      i = i + 1;
      *(buf + (unsigned long )tmp___12) = 2U;
    } else {
      tmp___13 = i;
      i = i + 1;
      *(buf + (unsigned long )tmp___13) = 0U;
    }
  } else {
    tmp___14 = i;
    i = i + 1;
    *(buf + (unsigned long )tmp___14) = 255U;
    tmp___15 = i;
    i = i + 1;
    *(buf + (unsigned long )tmp___15) = 255U;
    tmp___16 = i;
    i = i + 1;
    *(buf + (unsigned long )tmp___16) = 255U;
    tmp___17 = i;
    i = i + 1;
    *(buf + (unsigned long )tmp___17) = 255U;
    if (desc_cnt == 2) {
      tmp___18 = i;
      i = i + 1;
      *(buf + (unsigned long )tmp___18) = 3U;
    } else {
      tmp___19 = i;
      i = i + 1;
      *(buf + (unsigned long )tmp___19) = 0U;
    }
  }
  tmp___21 = i;
  i = i + 1;
  *(buf + (unsigned long )tmp___21) = 0U;
  tmp___22 = i;
  i = i + 1;
  *(buf + (unsigned long )tmp___22) = 2U;
  tmp___23 = i;
  i = i + 1;
  *(buf + (unsigned long )tmp___23) = 0U;
  desc_cnt = desc_cnt - 1;
  ldv_38772: ;
  if (desc_cnt != 0) {
    goto ldv_38771;
  } else {

  }
  tmp___24 = scsi_bufflen(srb);
  __min1 = tmp___24;
  __min2 = buf_len;
  buf_len = __min1 < __min2 ? __min1 : __min2;
  rtsx_stor_set_xfer_buf(buf, buf_len, srb);
  kfree((void const   *)buf);
  tmp___25 = scsi_bufflen(srb);
  scsi_set_resid(srb, (int )(tmp___25 - buf_len));
  return (0);
}
}
static int read_capacity(struct scsi_cmnd *srb , struct rtsx_chip *chip ) 
{ 
  unsigned char *buf ;
  unsigned int lun ;
  u32 card_size ;
  int tmp ;
  void *tmp___0 ;
  unsigned int tmp___1 ;

  {
  lun = (unsigned int )(srb->device)->lun;
  tmp = check_card_ready(chip, lun);
  if (tmp == 0) {
    set_sense_type(chip, lun, 2);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_scsi.c",
                "read_capacity", 1088);
    return (1);
  } else {

  }
  if ((((int )chip->lun_mc >> (int )lun) & 1) == 0) {
    chip->lun_mc = (u8 )((int )((signed char )chip->lun_mc) | (int )((signed char )(1 << (int )lun)));
    set_sense_type(chip, lun, 1);
    return (1);
  } else {

  }
  tmp___0 = kmalloc(8UL, 208U);
  buf = (unsigned char *)tmp___0;
  if ((unsigned long )buf == (unsigned long )((unsigned char *)0U)) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_scsi.c",
                "read_capacity", 1100);
    return (3);
  } else {

  }
  card_size = get_card_size(chip, lun);
  *buf = (unsigned char )((card_size - 1U) >> 24);
  *(buf + 1UL) = (unsigned char )((card_size - 1U) >> 16);
  *(buf + 2UL) = (unsigned char )((card_size - 1U) >> 8);
  *(buf + 3UL) = (unsigned int )((unsigned char )card_size) - 1U;
  *(buf + 4UL) = 0U;
  *(buf + 5UL) = 0U;
  *(buf + 6UL) = 2U;
  *(buf + 7UL) = 0U;
  tmp___1 = scsi_bufflen(srb);
  rtsx_stor_set_xfer_buf(buf, tmp___1, srb);
  kfree((void const   *)buf);
  scsi_set_resid(srb, 0);
  return (0);
}
}
static int read_eeprom(struct scsi_cmnd *srb , struct rtsx_chip *chip ) 
{ 
  unsigned short len ;
  unsigned short i ;
  int retval ;
  u8 *buf ;
  struct task_struct *tmp ;
  long volatile   __ret ;
  struct task_struct *tmp___0 ;
  struct task_struct *tmp___1 ;
  struct task_struct *tmp___2 ;
  struct task_struct *tmp___3 ;
  void *tmp___4 ;
  unsigned int __min1 ;
  unsigned int tmp___5 ;
  unsigned int __min2 ;
  unsigned int tmp___6 ;

  {
  rtsx_disable_aspm(chip);
  if (chip->ss_en != 0 && (unsigned int )chip->rtsx_stat == 3U) {
    rtsx_exit_ss(chip);
    tmp = get_current();
    tmp->task_state_change = 0UL;
    __ret = 1L;
    switch (8UL) {
    case 1UL: 
    tmp___0 = get_current();
    __asm__  volatile   ("xchgb %b0, %1\n": "+q" (__ret), "+m" (tmp___0->state): : "memory",
                         "cc");
    goto ldv_38795;
    case 2UL: 
    tmp___1 = get_current();
    __asm__  volatile   ("xchgw %w0, %1\n": "+r" (__ret), "+m" (tmp___1->state): : "memory",
                         "cc");
    goto ldv_38795;
    case 4UL: 
    tmp___2 = get_current();
    __asm__  volatile   ("xchgl %0, %1\n": "+r" (__ret), "+m" (tmp___2->state): : "memory",
                         "cc");
    goto ldv_38795;
    case 8UL: 
    tmp___3 = get_current();
    __asm__  volatile   ("xchgq %q0, %1\n": "+r" (__ret), "+m" (tmp___3->state): : "memory",
                         "cc");
    goto ldv_38795;
    default: 
    __xchg_wrong_size();
    }
    ldv_38795: 
    schedule_timeout(25L);
  } else {

  }
  chip->idle_counter = 0;
  chip->rtsx_stat = 2;
  len = (unsigned short )((int )((short )((int )*(srb->cmnd + 4UL) << 8)) | (int )((short )*(srb->cmnd + 5UL)));
  tmp___4 = vmalloc((unsigned long )len);
  buf = (u8 *)tmp___4;
  if ((unsigned long )buf == (unsigned long )((u8 *)0U)) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_scsi.c",
                "read_eeprom", 1141);
    return (3);
  } else {

  }
  retval = rtsx_force_power_on(chip, 1);
  if (retval != 0) {
    vfree((void const   *)buf);
    set_sense_type(chip, (unsigned int )(srb->device)->lun, 7);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_scsi.c",
                "read_eeprom", 1150);
    return (1);
  } else {

  }
  i = 0U;
  goto ldv_38803;
  ldv_38802: 
  retval = spi_read_eeprom(chip, (int )i, buf + (unsigned long )i);
  if (retval != 0) {
    vfree((void const   *)buf);
    set_sense_type(chip, (unsigned int )(srb->device)->lun, 7);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_scsi.c",
                "read_eeprom", 1160);
    return (1);
  } else {

  }
  i = (unsigned short )((int )i + 1);
  ldv_38803: ;
  if ((int )i < (int )len) {
    goto ldv_38802;
  } else {

  }
  tmp___5 = scsi_bufflen(srb);
  __min1 = tmp___5;
  __min2 = (unsigned int )len;
  len = (unsigned short )(__min1 < __min2 ? __min1 : __min2);
  rtsx_stor_set_xfer_buf(buf, (unsigned int )len, srb);
  tmp___6 = scsi_bufflen(srb);
  scsi_set_resid(srb, (int )(tmp___6 - (unsigned int )len));
  vfree((void const   *)buf);
  return (0);
}
}
static int write_eeprom(struct scsi_cmnd *srb , struct rtsx_chip *chip ) 
{ 
  unsigned short len ;
  unsigned short i ;
  int retval ;
  u8 *buf ;
  struct task_struct *tmp ;
  long volatile   __ret ;
  struct task_struct *tmp___0 ;
  struct task_struct *tmp___1 ;
  struct task_struct *tmp___2 ;
  struct task_struct *tmp___3 ;
  unsigned int __min1 ;
  unsigned int tmp___4 ;
  unsigned int __min2 ;
  void *tmp___5 ;
  unsigned int tmp___6 ;

  {
  rtsx_disable_aspm(chip);
  if (chip->ss_en != 0 && (unsigned int )chip->rtsx_stat == 3U) {
    rtsx_exit_ss(chip);
    tmp = get_current();
    tmp->task_state_change = 0UL;
    __ret = 1L;
    switch (8UL) {
    case 1UL: 
    tmp___0 = get_current();
    __asm__  volatile   ("xchgb %b0, %1\n": "+q" (__ret), "+m" (tmp___0->state): : "memory",
                         "cc");
    goto ldv_38818;
    case 2UL: 
    tmp___1 = get_current();
    __asm__  volatile   ("xchgw %w0, %1\n": "+r" (__ret), "+m" (tmp___1->state): : "memory",
                         "cc");
    goto ldv_38818;
    case 4UL: 
    tmp___2 = get_current();
    __asm__  volatile   ("xchgl %0, %1\n": "+r" (__ret), "+m" (tmp___2->state): : "memory",
                         "cc");
    goto ldv_38818;
    case 8UL: 
    tmp___3 = get_current();
    __asm__  volatile   ("xchgq %q0, %1\n": "+r" (__ret), "+m" (tmp___3->state): : "memory",
                         "cc");
    goto ldv_38818;
    default: 
    __xchg_wrong_size();
    }
    ldv_38818: 
    schedule_timeout(25L);
  } else {

  }
  chip->idle_counter = 0;
  chip->rtsx_stat = 2;
  len = (unsigned short )((int )((short )((int )*(srb->cmnd + 4UL) << 8)) | (int )((short )*(srb->cmnd + 5UL)));
  retval = rtsx_force_power_on(chip, 1);
  if (retval != 0) {
    set_sense_type(chip, (unsigned int )(srb->device)->lun, 8);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_scsi.c",
                "write_eeprom", 1193);
    return (1);
  } else {

  }
  if ((unsigned int )len == 511U) {
    retval = spi_erase_eeprom_chip(chip);
    if (retval != 0) {
      set_sense_type(chip, (unsigned int )(srb->device)->lun, 8);
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_scsi.c",
                  "write_eeprom", 1202);
      return (1);
    } else {

    }
  } else {
    tmp___4 = scsi_bufflen(srb);
    __min1 = tmp___4;
    __min2 = (unsigned int )len;
    len = (unsigned short )(__min1 < __min2 ? __min1 : __min2);
    tmp___5 = vmalloc((unsigned long )len);
    buf = (u8 *)tmp___5;
    if ((unsigned long )buf == (unsigned long )((u8 *)0U)) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_scsi.c",
                  "write_eeprom", 1210);
      return (3);
    } else {

    }
    rtsx_stor_get_xfer_buf(buf, (unsigned int )len, srb);
    tmp___6 = scsi_bufflen(srb);
    scsi_set_resid(srb, (int )(tmp___6 - (unsigned int )len));
    i = 0U;
    goto ldv_38829;
    ldv_38828: 
    retval = spi_write_eeprom(chip, (int )i, (int )*(buf + (unsigned long )i));
    if (retval != 0) {
      vfree((void const   *)buf);
      set_sense_type(chip, (unsigned int )(srb->device)->lun, 8);
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_scsi.c",
                  "write_eeprom", 1223);
      return (1);
    } else {

    }
    i = (unsigned short )((int )i + 1);
    ldv_38829: ;
    if ((int )i < (int )len) {
      goto ldv_38828;
    } else {

    }
    vfree((void const   *)buf);
  }
  return (0);
}
}
static int read_mem(struct scsi_cmnd *srb , struct rtsx_chip *chip ) 
{ 
  unsigned short addr ;
  unsigned short len ;
  unsigned short i ;
  int retval ;
  u8 *buf ;
  struct task_struct *tmp ;
  long volatile   __ret ;
  struct task_struct *tmp___0 ;
  struct task_struct *tmp___1 ;
  struct task_struct *tmp___2 ;
  struct task_struct *tmp___3 ;
  void *tmp___4 ;
  unsigned int __min1 ;
  unsigned int tmp___5 ;
  unsigned int __min2 ;
  unsigned int tmp___6 ;

  {
  rtsx_disable_aspm(chip);
  if (chip->ss_en != 0 && (unsigned int )chip->rtsx_stat == 3U) {
    rtsx_exit_ss(chip);
    tmp = get_current();
    tmp->task_state_change = 0UL;
    __ret = 1L;
    switch (8UL) {
    case 1UL: 
    tmp___0 = get_current();
    __asm__  volatile   ("xchgb %b0, %1\n": "+q" (__ret), "+m" (tmp___0->state): : "memory",
                         "cc");
    goto ldv_38842;
    case 2UL: 
    tmp___1 = get_current();
    __asm__  volatile   ("xchgw %w0, %1\n": "+r" (__ret), "+m" (tmp___1->state): : "memory",
                         "cc");
    goto ldv_38842;
    case 4UL: 
    tmp___2 = get_current();
    __asm__  volatile   ("xchgl %0, %1\n": "+r" (__ret), "+m" (tmp___2->state): : "memory",
                         "cc");
    goto ldv_38842;
    case 8UL: 
    tmp___3 = get_current();
    __asm__  volatile   ("xchgq %q0, %1\n": "+r" (__ret), "+m" (tmp___3->state): : "memory",
                         "cc");
    goto ldv_38842;
    default: 
    __xchg_wrong_size();
    }
    ldv_38842: 
    schedule_timeout(25L);
  } else {

  }
  chip->idle_counter = 0;
  chip->rtsx_stat = 2;
  addr = (unsigned short )((int )((short )((int )*(srb->cmnd + 2UL) << 8)) | (int )((short )*(srb->cmnd + 3UL)));
  len = (unsigned short )((int )((short )((int )*(srb->cmnd + 4UL) << 8)) | (int )((short )*(srb->cmnd + 5UL)));
  if ((unsigned int )addr <= 64511U) {
    set_sense_type(chip, (unsigned int )(srb->device)->lun, 6);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_scsi.c",
                "read_mem", 1254);
    return (1);
  } else {

  }
  tmp___4 = vmalloc((unsigned long )len);
  buf = (u8 *)tmp___4;
  if ((unsigned long )buf == (unsigned long )((u8 *)0U)) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_scsi.c",
                "read_mem", 1260);
    return (3);
  } else {

  }
  retval = rtsx_force_power_on(chip, 1);
  if (retval != 0) {
    vfree((void const   *)buf);
    set_sense_type(chip, (unsigned int )(srb->device)->lun, 8);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_scsi.c",
                "read_mem", 1268);
    return (1);
  } else {

  }
  i = 0U;
  goto ldv_38850;
  ldv_38849: 
  retval = rtsx_read_register(chip, (int )addr + (int )i, buf + (unsigned long )i);
  if (retval != 0) {
    vfree((void const   *)buf);
    set_sense_type(chip, (unsigned int )(srb->device)->lun, 7);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_scsi.c",
                "read_mem", 1278);
    return (1);
  } else {

  }
  i = (unsigned short )((int )i + 1);
  ldv_38850: ;
  if ((int )i < (int )len) {
    goto ldv_38849;
  } else {

  }
  tmp___5 = scsi_bufflen(srb);
  __min1 = tmp___5;
  __min2 = (unsigned int )len;
  len = (unsigned short )(__min1 < __min2 ? __min1 : __min2);
  rtsx_stor_set_xfer_buf(buf, (unsigned int )len, srb);
  tmp___6 = scsi_bufflen(srb);
  scsi_set_resid(srb, (int )(tmp___6 - (unsigned int )len));
  vfree((void const   *)buf);
  return (0);
}
}
static int write_mem(struct scsi_cmnd *srb , struct rtsx_chip *chip ) 
{ 
  unsigned short addr ;
  unsigned short len ;
  unsigned short i ;
  int retval ;
  u8 *buf ;
  struct task_struct *tmp ;
  long volatile   __ret ;
  struct task_struct *tmp___0 ;
  struct task_struct *tmp___1 ;
  struct task_struct *tmp___2 ;
  struct task_struct *tmp___3 ;
  unsigned int __min1 ;
  unsigned int tmp___4 ;
  unsigned int __min2 ;
  void *tmp___5 ;
  unsigned int tmp___6 ;

  {
  rtsx_disable_aspm(chip);
  if (chip->ss_en != 0 && (unsigned int )chip->rtsx_stat == 3U) {
    rtsx_exit_ss(chip);
    tmp = get_current();
    tmp->task_state_change = 0UL;
    __ret = 1L;
    switch (8UL) {
    case 1UL: 
    tmp___0 = get_current();
    __asm__  volatile   ("xchgb %b0, %1\n": "+q" (__ret), "+m" (tmp___0->state): : "memory",
                         "cc");
    goto ldv_38866;
    case 2UL: 
    tmp___1 = get_current();
    __asm__  volatile   ("xchgw %w0, %1\n": "+r" (__ret), "+m" (tmp___1->state): : "memory",
                         "cc");
    goto ldv_38866;
    case 4UL: 
    tmp___2 = get_current();
    __asm__  volatile   ("xchgl %0, %1\n": "+r" (__ret), "+m" (tmp___2->state): : "memory",
                         "cc");
    goto ldv_38866;
    case 8UL: 
    tmp___3 = get_current();
    __asm__  volatile   ("xchgq %q0, %1\n": "+r" (__ret), "+m" (tmp___3->state): : "memory",
                         "cc");
    goto ldv_38866;
    default: 
    __xchg_wrong_size();
    }
    ldv_38866: 
    schedule_timeout(25L);
  } else {

  }
  chip->idle_counter = 0;
  chip->rtsx_stat = 2;
  addr = (unsigned short )((int )((short )((int )*(srb->cmnd + 2UL) << 8)) | (int )((short )*(srb->cmnd + 3UL)));
  len = (unsigned short )((int )((short )((int )*(srb->cmnd + 4UL) << 8)) | (int )((short )*(srb->cmnd + 5UL)));
  if ((unsigned int )addr <= 64511U) {
    set_sense_type(chip, (unsigned int )(srb->device)->lun, 6);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_scsi.c",
                "write_mem", 1312);
    return (1);
  } else {

  }
  tmp___4 = scsi_bufflen(srb);
  __min1 = tmp___4;
  __min2 = (unsigned int )len;
  len = (unsigned short )(__min1 < __min2 ? __min1 : __min2);
  tmp___5 = vmalloc((unsigned long )len);
  buf = (u8 *)tmp___5;
  if ((unsigned long )buf == (unsigned long )((u8 *)0U)) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_scsi.c",
                "write_mem", 1319);
    return (3);
  } else {

  }
  rtsx_stor_get_xfer_buf(buf, (unsigned int )len, srb);
  tmp___6 = scsi_bufflen(srb);
  scsi_set_resid(srb, (int )(tmp___6 - (unsigned int )len));
  retval = rtsx_force_power_on(chip, 1);
  if (retval != 0) {
    vfree((void const   *)buf);
    set_sense_type(chip, (unsigned int )(srb->device)->lun, 8);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_scsi.c",
                "write_mem", 1330);
    return (1);
  } else {

  }
  i = 0U;
  goto ldv_38877;
  ldv_38876: 
  retval = rtsx_write_register(chip, (int )addr + (int )i, 255, (int )*(buf + (unsigned long )i));
  if (retval != 0) {
    vfree((void const   *)buf);
    set_sense_type(chip, (unsigned int )(srb->device)->lun, 8);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_scsi.c",
                "write_mem", 1340);
    return (1);
  } else {

  }
  i = (unsigned short )((int )i + 1);
  ldv_38877: ;
  if ((int )i < (int )len) {
    goto ldv_38876;
  } else {

  }
  vfree((void const   *)buf);
  return (0);
}
}
static int get_sd_csd(struct scsi_cmnd *srb , struct rtsx_chip *chip ) 
{ 
  struct sd_info *sd_card ;
  unsigned int lun ;
  int tmp ;
  u8 tmp___0 ;
  unsigned int tmp___1 ;

  {
  sd_card = & chip->sd_card;
  lun = (unsigned int )(srb->device)->lun;
  tmp = check_card_ready(chip, lun);
  if (tmp == 0) {
    set_sense_type(chip, lun, 2);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_scsi.c",
                "get_sd_csd", 1357);
    return (1);
  } else {

  }
  tmp___0 = get_lun_card(chip, lun);
  if ((unsigned int )tmp___0 != 4U) {
    set_sense_type(chip, lun, 7);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_scsi.c",
                "get_sd_csd", 1363);
    return (1);
  } else {

  }
  scsi_set_resid(srb, 0);
  tmp___1 = scsi_bufflen(srb);
  rtsx_stor_set_xfer_buf((unsigned char *)(& sd_card->raw_csd), tmp___1, srb);
  return (0);
}
}
static int toggle_gpio_cmd(struct scsi_cmnd *srb , struct rtsx_chip *chip ) 
{ 
  u8 gpio ;
  struct task_struct *tmp ;
  long volatile   __ret ;
  struct task_struct *tmp___0 ;
  struct task_struct *tmp___1 ;
  struct task_struct *tmp___2 ;
  struct task_struct *tmp___3 ;

  {
  gpio = *(srb->cmnd + 2UL);
  rtsx_disable_aspm(chip);
  if (chip->ss_en != 0 && (unsigned int )chip->rtsx_stat == 3U) {
    rtsx_exit_ss(chip);
    tmp = get_current();
    tmp->task_state_change = 0UL;
    __ret = 1L;
    switch (8UL) {
    case 1UL: 
    tmp___0 = get_current();
    __asm__  volatile   ("xchgb %b0, %1\n": "+q" (__ret), "+m" (tmp___0->state): : "memory",
                         "cc");
    goto ldv_38893;
    case 2UL: 
    tmp___1 = get_current();
    __asm__  volatile   ("xchgw %w0, %1\n": "+r" (__ret), "+m" (tmp___1->state): : "memory",
                         "cc");
    goto ldv_38893;
    case 4UL: 
    tmp___2 = get_current();
    __asm__  volatile   ("xchgl %0, %1\n": "+r" (__ret), "+m" (tmp___2->state): : "memory",
                         "cc");
    goto ldv_38893;
    case 8UL: 
    tmp___3 = get_current();
    __asm__  volatile   ("xchgq %q0, %1\n": "+r" (__ret), "+m" (tmp___3->state): : "memory",
                         "cc");
    goto ldv_38893;
    default: 
    __xchg_wrong_size();
    }
    ldv_38893: 
    schedule_timeout(25L);
  } else {

  }
  chip->idle_counter = 0;
  chip->rtsx_stat = 2;
  if ((unsigned int )gpio > 3U) {
    gpio = 1U;
  } else {

  }
  toggle_gpio(chip, (int )gpio);
  return (0);
}
}
static int trace_msg_cmd(struct scsi_cmnd *srb , struct rtsx_chip *chip ) 
{ 
  unsigned char *ptr ;
  unsigned char *buf ;
  int i ;
  int msg_cnt ;
    klee_make_symbolic(&msg_cnt, sizeof(int), "msg_cnt");
  u8 clear ;
  unsigned int buf_len ;
  unsigned int tmp ;
  struct scatterlist *tmp___0 ;
  unsigned int tmp___1 ;
  void *tmp___2 ;
  unsigned char *tmp___3 ;
  unsigned char *tmp___4 ;
  unsigned char *tmp___5 ;
  unsigned char *tmp___6 ;
  struct _ddebug descriptor ;
  struct device *tmp___7 ;
  long tmp___8 ;
  int j ;
  int idx ;
    klee_make_symbolic(&idx, sizeof(int), "idx");
  unsigned char *tmp___9 ;
  unsigned char *tmp___10 ;
  unsigned char *tmp___11 ;
  unsigned char *tmp___12 ;
  unsigned char *tmp___13 ;
  unsigned int tmp___14 ;

  {
  buf = (unsigned char *)0U;
  buf_len = 7300U;
  tmp = scsi_bufflen(srb);
  if (tmp < buf_len) {
    set_sense_type(chip, (unsigned int )(srb->device)->lun, 7);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_scsi.c",
                "trace_msg_cmd", 1406);
    return (1);
  } else {
    tmp___0 = scsi_sglist(srb);
    if ((unsigned long )tmp___0 == (unsigned long )((struct scatterlist *)0)) {
      set_sense_type(chip, (unsigned int )(srb->device)->lun, 7);
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_scsi.c",
                  "trace_msg_cmd", 1406);
      return (1);
    } else {

    }
  }
  clear = *(srb->cmnd + 2UL);
  tmp___1 = scsi_bufflen(srb);
  tmp___2 = vmalloc((unsigned long )tmp___1);
  buf = (unsigned char *)tmp___2;
  if ((unsigned long )buf == (unsigned long )((unsigned char *)0U)) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_scsi.c",
                "trace_msg_cmd", 1414);
    return (3);
  } else {

  }
  ptr = buf;
  if ((unsigned int )chip->trace_msg[chip->msg_idx].valid != 0U) {
    msg_cnt = 64;
  } else {
    msg_cnt = chip->msg_idx;
  }
  tmp___3 = ptr;
  ptr = ptr + 1;
  *tmp___3 = (unsigned char )(msg_cnt >> 24);
  tmp___4 = ptr;
  ptr = ptr + 1;
  *tmp___4 = (unsigned char )(msg_cnt >> 16);
  tmp___5 = ptr;
  ptr = ptr + 1;
  *tmp___5 = (unsigned char )(msg_cnt >> 8);
  tmp___6 = ptr;
  ptr = ptr + 1;
  *tmp___6 = (unsigned char )msg_cnt;
  descriptor.modname = "rts5208";
  descriptor.function = "trace_msg_cmd";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_scsi.c";
  descriptor.format = "Trace message count is %d\n";
  descriptor.lineno = 1428U;
  descriptor.flags = 0U;
  tmp___8 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp___8 != 0L) {
    tmp___7 = rtsx_dev((struct rtsx_chip  const  *)chip);
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)tmp___7, "Trace message count is %d\n",
                      msg_cnt);
  } else {

  }
  i = 1;
  goto ldv_38923;
  ldv_38922: 
  idx = chip->msg_idx - i;
  if (idx < 0) {
    idx = idx + 64;
  } else {

  }
  tmp___9 = ptr;
  ptr = ptr + 1;
  *tmp___9 = (unsigned char )((int )chip->trace_msg[idx].line >> 8);
  tmp___10 = ptr;
  ptr = ptr + 1;
  *tmp___10 = (unsigned char )chip->trace_msg[idx].line;
  j = 0;
  goto ldv_38914;
  ldv_38913: 
  tmp___11 = ptr;
  ptr = ptr + 1;
  *tmp___11 = (unsigned char )chip->trace_msg[idx].func[j];
  j = j + 1;
  ldv_38914: ;
  if (j <= 63) {
    goto ldv_38913;
  } else {

  }
  j = 0;
  goto ldv_38917;
  ldv_38916: 
  tmp___12 = ptr;
  ptr = ptr + 1;
  *tmp___12 = (unsigned char )chip->trace_msg[idx].file[j];
  j = j + 1;
  ldv_38917: ;
  if (j <= 31) {
    goto ldv_38916;
  } else {

  }
  j = 0;
  goto ldv_38920;
  ldv_38919: 
  tmp___13 = ptr;
  ptr = ptr + 1;
  *tmp___13 = chip->trace_msg[idx].timeval_buf[j];
  j = j + 1;
  ldv_38920: ;
  if (j <= 15) {
    goto ldv_38919;
  } else {

  }
  i = i + 1;
  ldv_38923: ;
  if (i <= msg_cnt) {
    goto ldv_38922;
  } else {

  }
  tmp___14 = scsi_bufflen(srb);
  rtsx_stor_set_xfer_buf(buf, tmp___14, srb);
  vfree((void const   *)buf);
  if ((unsigned int )clear != 0U) {
    chip->msg_idx = 0;
    i = 0;
    goto ldv_38926;
    ldv_38925: 
    chip->trace_msg[i].valid = 0U;
    i = i + 1;
    ldv_38926: ;
    if (i <= 63) {
      goto ldv_38925;
    } else {

    }

  } else {

  }
  scsi_set_resid(srb, 0);
  return (0);
}
}
static int read_host_reg(struct scsi_cmnd *srb , struct rtsx_chip *chip ) 
{ 
  u8 addr ;
  u8 buf[4U] ;
  u32 val ;
  unsigned int len ;
  struct task_struct *tmp ;
  long volatile   __ret ;
  struct task_struct *tmp___0 ;
  struct task_struct *tmp___1 ;
  struct task_struct *tmp___2 ;
  struct task_struct *tmp___3 ;
  struct _ddebug descriptor ;
  struct device *tmp___4 ;
  long tmp___5 ;
  unsigned int __min1 ;
  unsigned int tmp___6 ;
  unsigned int __min2 ;
  unsigned int tmp___7 ;

  {
  rtsx_disable_aspm(chip);
  if (chip->ss_en != 0 && (unsigned int )chip->rtsx_stat == 3U) {
    rtsx_exit_ss(chip);
    tmp = get_current();
    tmp->task_state_change = 0UL;
    __ret = 1L;
    switch (8UL) {
    case 1UL: 
    tmp___0 = get_current();
    __asm__  volatile   ("xchgb %b0, %1\n": "+q" (__ret), "+m" (tmp___0->state): : "memory",
                         "cc");
    goto ldv_38938;
    case 2UL: 
    tmp___1 = get_current();
    __asm__  volatile   ("xchgw %w0, %1\n": "+r" (__ret), "+m" (tmp___1->state): : "memory",
                         "cc");
    goto ldv_38938;
    case 4UL: 
    tmp___2 = get_current();
    __asm__  volatile   ("xchgl %0, %1\n": "+r" (__ret), "+m" (tmp___2->state): : "memory",
                         "cc");
    goto ldv_38938;
    case 8UL: 
    tmp___3 = get_current();
    __asm__  volatile   ("xchgq %q0, %1\n": "+r" (__ret), "+m" (tmp___3->state): : "memory",
                         "cc");
    goto ldv_38938;
    default: 
    __xchg_wrong_size();
    }
    ldv_38938: 
    schedule_timeout(25L);
  } else {

  }
  chip->idle_counter = 0;
  chip->rtsx_stat = 2;
  addr = *(srb->cmnd + 4UL);
  val = ioread32((chip->rtsx)->remap_addr + (unsigned long )addr);
  descriptor.modname = "rts5208";
  descriptor.function = "read_host_reg";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_scsi.c";
  descriptor.format = "Host register (0x%x): 0x%x\n";
  descriptor.lineno = 1480U;
  descriptor.flags = 0U;
  tmp___5 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp___5 != 0L) {
    tmp___4 = rtsx_dev((struct rtsx_chip  const  *)chip);
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)tmp___4, "Host register (0x%x): 0x%x\n",
                      (int )addr, val);
  } else {

  }
  buf[0] = (unsigned char )(val >> 24);
  buf[1] = (unsigned char )(val >> 16);
  buf[2] = (unsigned char )(val >> 8);
  buf[3] = (unsigned char )val;
  tmp___6 = scsi_bufflen(srb);
  __min1 = tmp___6;
  __min2 = 4U;
  len = __min1 < __min2 ? __min1 : __min2;
  rtsx_stor_set_xfer_buf((unsigned char *)(& buf), len, srb);
  tmp___7 = scsi_bufflen(srb);
  scsi_set_resid(srb, (int )(tmp___7 - len));
  return (0);
}
}
static int write_host_reg(struct scsi_cmnd *srb , struct rtsx_chip *chip ) 
{ 
  u8 addr ;
  u8 buf[4U] ;
  u32 val ;
  unsigned int len ;
  struct task_struct *tmp ;
  long volatile   __ret ;
  struct task_struct *tmp___0 ;
  struct task_struct *tmp___1 ;
  struct task_struct *tmp___2 ;
  struct task_struct *tmp___3 ;
  unsigned int __min1 ;
  unsigned int tmp___4 ;
  unsigned int __min2 ;
  unsigned int tmp___5 ;

  {
  rtsx_disable_aspm(chip);
  if (chip->ss_en != 0 && (unsigned int )chip->rtsx_stat == 3U) {
    rtsx_exit_ss(chip);
    tmp = get_current();
    tmp->task_state_change = 0UL;
    __ret = 1L;
    switch (8UL) {
    case 1UL: 
    tmp___0 = get_current();
    __asm__  volatile   ("xchgb %b0, %1\n": "+q" (__ret), "+m" (tmp___0->state): : "memory",
                         "cc");
    goto ldv_38959;
    case 2UL: 
    tmp___1 = get_current();
    __asm__  volatile   ("xchgw %w0, %1\n": "+r" (__ret), "+m" (tmp___1->state): : "memory",
                         "cc");
    goto ldv_38959;
    case 4UL: 
    tmp___2 = get_current();
    __asm__  volatile   ("xchgl %0, %1\n": "+r" (__ret), "+m" (tmp___2->state): : "memory",
                         "cc");
    goto ldv_38959;
    case 8UL: 
    tmp___3 = get_current();
    __asm__  volatile   ("xchgq %q0, %1\n": "+r" (__ret), "+m" (tmp___3->state): : "memory",
                         "cc");
    goto ldv_38959;
    default: 
    __xchg_wrong_size();
    }
    ldv_38959: 
    schedule_timeout(25L);
  } else {

  }
  chip->idle_counter = 0;
  chip->rtsx_stat = 2;
  addr = *(srb->cmnd + 4UL);
  tmp___4 = scsi_bufflen(srb);
  __min1 = tmp___4;
  __min2 = 4U;
  len = __min1 < __min2 ? __min1 : __min2;
  rtsx_stor_get_xfer_buf((unsigned char *)(& buf), len, srb);
  tmp___5 = scsi_bufflen(srb);
  scsi_set_resid(srb, (int )(tmp___5 - len));
  val = ((((unsigned int )buf[0] << 24) | ((unsigned int )buf[1] << 16)) | ((unsigned int )buf[2] << 8)) | (unsigned int )buf[3];
  iowrite32(val, (chip->rtsx)->remap_addr + (unsigned long )addr);
  return (0);
}
}
static int set_variable(struct scsi_cmnd *srb , struct rtsx_chip *chip ) 
{ 
  unsigned int lun ;
  struct xd_info *xd_card ;
  struct sd_info *sd_card ;
  struct ms_info *ms_card ;
  int retval ;
  struct task_struct *tmp ;
  long volatile   __ret ;
  struct task_struct *tmp___0 ;
  struct task_struct *tmp___1 ;
  struct task_struct *tmp___2 ;
  struct task_struct *tmp___3 ;

  {
  lun = (unsigned int )(srb->device)->lun;
  if ((unsigned int )*(srb->cmnd + 3UL) == 1U) {
    xd_card = & chip->xd_card;
    sd_card = & chip->sd_card;
    ms_card = & chip->ms_card;
    switch ((int )*(srb->cmnd + 4UL)) {
    case 16: 
    xd_card->xd_clock = (int )*(srb->cmnd + 5UL);
    goto ldv_38977;
    case 4: 
    sd_card->sd_clock = (int )*(srb->cmnd + 5UL);
    goto ldv_38977;
    case 8: 
    ms_card->ms_clock = (int )*(srb->cmnd + 5UL);
    goto ldv_38977;
    default: 
    set_sense_type(chip, lun, 6);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_scsi.c",
                "set_variable", 1548);
    return (1);
    }
    ldv_38977: ;
  } else
  if ((unsigned int )*(srb->cmnd + 3UL) == 2U) {
    if ((unsigned int )*(srb->cmnd + 4UL) != 0U) {
      chip->blink_led = 1U;
    } else {
      chip->blink_led = 0U;
      rtsx_disable_aspm(chip);
      if (chip->ss_en != 0 && (unsigned int )chip->rtsx_stat == 3U) {
        rtsx_exit_ss(chip);
        tmp = get_current();
        tmp->task_state_change = 0UL;
        __ret = 1L;
        switch (8UL) {
        case 1UL: 
        tmp___0 = get_current();
        __asm__  volatile   ("xchgb %b0, %1\n": "+q" (__ret), "+m" (tmp___0->state): : "memory",
                             "cc");
        goto ldv_38985;
        case 2UL: 
        tmp___1 = get_current();
        __asm__  volatile   ("xchgw %w0, %1\n": "+r" (__ret), "+m" (tmp___1->state): : "memory",
                             "cc");
        goto ldv_38985;
        case 4UL: 
        tmp___2 = get_current();
        __asm__  volatile   ("xchgl %0, %1\n": "+r" (__ret), "+m" (tmp___2->state): : "memory",
                             "cc");
        goto ldv_38985;
        case 8UL: 
        tmp___3 = get_current();
        __asm__  volatile   ("xchgq %q0, %1\n": "+r" (__ret), "+m" (tmp___3->state): : "memory",
                             "cc");
        goto ldv_38985;
        default: 
        __xchg_wrong_size();
        }
        ldv_38985: 
        schedule_timeout(25L);
      } else {

      }
      chip->idle_counter = 0;
      chip->rtsx_stat = 2;
      retval = rtsx_force_power_on(chip, 1);
      if (retval != 0) {
        set_sense_type(chip, (unsigned int )(srb->device)->lun, 8);
        _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_scsi.c",
                    "set_variable", 1572);
        return (1);
      } else {

      }
      turn_off_led(chip, 0);
    }
  } else {
    set_sense_type(chip, lun, 6);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_scsi.c",
                "set_variable", 1580);
    return (1);
  }
  return (0);
}
}
static int get_variable(struct scsi_cmnd *srb , struct rtsx_chip *chip ) 
{ 
  unsigned int lun ;
  struct xd_info *xd_card ;
  struct sd_info *sd_card ;
  struct ms_info *ms_card ;
  u8 tmp ;
  u8 tmp___0 ;

  {
  lun = (unsigned int )(srb->device)->lun;
  if ((unsigned int )*(srb->cmnd + 3UL) == 1U) {
    xd_card = & chip->xd_card;
    sd_card = & chip->sd_card;
    ms_card = & chip->ms_card;
    switch ((int )*(srb->cmnd + 4UL)) {
    case 16: 
    tmp = (unsigned char )xd_card->xd_clock;
    goto ldv_39001;
    case 4: 
    tmp = (unsigned char )sd_card->sd_clock;
    goto ldv_39001;
    case 8: 
    tmp = (unsigned char )ms_card->ms_clock;
    goto ldv_39001;
    default: 
    set_sense_type(chip, lun, 6);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_scsi.c",
                "get_variable", 1613);
    return (1);
    }
    ldv_39001: 
    rtsx_stor_set_xfer_buf(& tmp, 1U, srb);
  } else
  if ((unsigned int )*(srb->cmnd + 3UL) == 2U) {
    tmp___0 = chip->blink_led;
    rtsx_stor_set_xfer_buf(& tmp___0, 1U, srb);
  } else {
    set_sense_type(chip, lun, 6);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_scsi.c",
                "get_variable", 1624);
    return (1);
  }
  return (0);
}
}
static int dma_access_ring_buffer(struct scsi_cmnd *srb , struct rtsx_chip *chip ) 
{ 
  int retval ;
  unsigned int lun ;
  u16 len ;
  struct task_struct *tmp ;
  long volatile   __ret ;
  struct task_struct *tmp___0 ;
  struct task_struct *tmp___1 ;
  struct task_struct *tmp___2 ;
  struct task_struct *tmp___3 ;
  u16 __min1 ;
  u16 __min2 ;
  unsigned int tmp___4 ;
  struct _ddebug descriptor ;
  struct device *tmp___5 ;
  long tmp___6 ;
  struct _ddebug descriptor___0 ;
  struct device *tmp___7 ;
  long tmp___8 ;
  unsigned int tmp___9 ;
  struct scatterlist *tmp___10 ;

  {
  lun = (unsigned int )(srb->device)->lun;
  rtsx_disable_aspm(chip);
  if (chip->ss_en != 0 && (unsigned int )chip->rtsx_stat == 3U) {
    rtsx_exit_ss(chip);
    tmp = get_current();
    tmp->task_state_change = 0UL;
    __ret = 1L;
    switch (8UL) {
    case 1UL: 
    tmp___0 = get_current();
    __asm__  volatile   ("xchgb %b0, %1\n": "+q" (__ret), "+m" (tmp___0->state): : "memory",
                         "cc");
    goto ldv_39016;
    case 2UL: 
    tmp___1 = get_current();
    __asm__  volatile   ("xchgw %w0, %1\n": "+r" (__ret), "+m" (tmp___1->state): : "memory",
                         "cc");
    goto ldv_39016;
    case 4UL: 
    tmp___2 = get_current();
    __asm__  volatile   ("xchgl %0, %1\n": "+r" (__ret), "+m" (tmp___2->state): : "memory",
                         "cc");
    goto ldv_39016;
    case 8UL: 
    tmp___3 = get_current();
    __asm__  volatile   ("xchgq %q0, %1\n": "+r" (__ret), "+m" (tmp___3->state): : "memory",
                         "cc");
    goto ldv_39016;
    default: 
    __xchg_wrong_size();
    }
    ldv_39016: 
    schedule_timeout(25L);
  } else {

  }
  chip->idle_counter = 0;
  chip->rtsx_stat = 2;
  len = (u16 )((int )((short )((int )*(srb->cmnd + 4UL) << 8)) | (int )((short )*(srb->cmnd + 5UL)));
  __min1 = len;
  tmp___4 = scsi_bufflen(srb);
  __min2 = (u16 )tmp___4;
  len = (u16 )((int )__min1 < (int )__min2 ? __min1 : __min2);
  if ((unsigned int )srb->sc_data_direction == 2U) {
    descriptor.modname = "rts5208";
    descriptor.function = "dma_access_ring_buffer";
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_scsi.c";
    descriptor.format = "Read from device\n";
    descriptor.lineno = 1649U;
    descriptor.flags = 0U;
    tmp___6 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
    if (tmp___6 != 0L) {
      tmp___5 = rtsx_dev((struct rtsx_chip  const  *)chip);
      __dynamic_dev_dbg(& descriptor, (struct device  const  *)tmp___5, "Read from device\n");
    } else {

    }
  } else {
    descriptor___0.modname = "rts5208";
    descriptor___0.function = "dma_access_ring_buffer";
    descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_scsi.c";
    descriptor___0.format = "Write to device\n";
    descriptor___0.lineno = 1651U;
    descriptor___0.flags = 0U;
    tmp___8 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
    if (tmp___8 != 0L) {
      tmp___7 = rtsx_dev((struct rtsx_chip  const  *)chip);
      __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)tmp___7, "Write to device\n");
    } else {

    }
  }
  tmp___9 = scsi_sg_count(srb);
  tmp___10 = scsi_sglist(srb);
  retval = rtsx_transfer_data(chip, 0, (void *)tmp___10, (size_t )len, (int )tmp___9,
                              srb->sc_data_direction, 1000);
  if (retval < 0) {
    if ((unsigned int )srb->sc_data_direction == 2U) {
      set_sense_type(chip, lun, 7);
    } else {
      set_sense_type(chip, lun, 8);
    }
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_scsi.c",
                "dma_access_ring_buffer", 1663);
    return (1);
  } else {

  }
  scsi_set_resid(srb, 0);
  return (0);
}
}
static int get_dev_status(struct scsi_cmnd *srb , struct rtsx_chip *chip ) 
{ 
  struct sd_info *sd_card ;
  struct ms_info *ms_card ;
  int buf_len ;
  unsigned int lun ;
  u8 card ;
  u8 tmp ;
  u8 status[32U] ;
  u8 oc_now_mask ;
  u8 oc_ever_mask ;
  struct _ddebug descriptor ;
  struct device *tmp___0 ;
  long tmp___1 ;
  unsigned int __min1 ;
  unsigned int tmp___2 ;
  unsigned int __min2 ;
  unsigned int tmp___3 ;

  {
  sd_card = & chip->sd_card;
  ms_card = & chip->ms_card;
  lun = (unsigned int )(srb->device)->lun;
  tmp = get_lun_card(chip, lun);
  card = tmp;
  oc_now_mask = 0U;
  oc_ever_mask = 0U;
  memset((void *)(& status), 0, 32UL);
  status[0] = (unsigned char )chip->product_id;
  status[1] = chip->ic_version;
  if (chip->auto_delink_en != 0) {
    status[2] = 16U;
  } else {
    status[2] = 0U;
  }
  status[3] = 20U;
  status[4] = 10U;
  status[5] = 5U;
  status[6] = 21U;
  if ((unsigned int )chip->card_wp != 0U) {
    status[7] = 32U;
  } else {
    status[7] = 0U;
  }
  status[8] = 0U;
  if ((unsigned int )chip->lun_mode == 1U && (unsigned int )chip->lun2card[lun] == 8U) {
    oc_now_mask = 64U;
    oc_ever_mask = 32U;
  } else {
    oc_now_mask = 4U;
    oc_ever_mask = 2U;
  }
  if ((unsigned int )((int )chip->ocp_stat & (int )oc_now_mask) != 0U) {
    status[8] = (u8 )((unsigned int )status[8] | 2U);
  } else {

  }
  if ((unsigned int )((int )chip->ocp_stat & (int )oc_ever_mask) != 0U) {
    status[8] = (u8 )((unsigned int )status[8] | 1U);
  } else {

  }
  if ((unsigned int )card == 4U) {
    if (((int )sd_card->sd_type & 255) == 0) {
      if (((int )sd_card->sd_type & 255) == 0 && ((int )sd_card->sd_type & 4096) != 0) {
        if (sd_card->capacity > 67108864U) {
          status[14] = 2U;
        } else {
          status[14] = 1U;
        }
      } else {
        status[14] = 0U;
      }
      if (((int )sd_card->sd_type & 255) == 0 && ((int )sd_card->sd_type & 2048) != 0) {
        status[15] = 3U;
      } else
      if (((int )sd_card->sd_type & 255) == 0 && ((int )sd_card->sd_type & 1024) != 0) {
        status[15] = 4U;
      } else
      if (((int )sd_card->sd_type & 255) == 0 && ((int )sd_card->sd_type & 512) != 0) {
        status[15] = 2U;
      } else
      if (((int )sd_card->sd_type & 255) == 0 && ((int )sd_card->sd_type & 256) != 0) {
        status[15] = 1U;
      } else {
        status[15] = 0U;
      }
    } else {
      if (((int )sd_card->sd_type & 255) == 1 && ((int )sd_card->sd_type & 4096) != 0) {
        status[14] = 1U;
      } else {
        status[14] = 0U;
      }
      if (((int )sd_card->sd_type & 255) == 1 && ((int )sd_card->sd_type & 8192) != 0) {
        status[15] = 3U;
      } else
      if (((int )sd_card->sd_type & 255) == 1 && ((int )sd_card->sd_type & 512) != 0) {
        status[15] = 2U;
      } else
      if (((int )sd_card->sd_type & 255) == 1 && ((int )sd_card->sd_type & 256) != 0) {
        status[15] = 1U;
      } else {
        status[15] = 0U;
      }
    }
  } else
  if ((unsigned int )card == 8U) {
    if (((int )ms_card->ms_type & 255) == 1) {
      if (((int )ms_card->ms_type & 255) == 1 && ((int )ms_card->ms_type & 2048) != 0) {
        status[14] = 1U;
      } else {
        status[14] = 0U;
      }
      if (((int )ms_card->ms_type & 255) == 1 && ((int )ms_card->ms_type & 1536) == 1536) {
        status[15] = 1U;
      } else {
        status[15] = 0U;
      }
    } else {

    }
  } else {

  }
  if ((unsigned int )card == 4U) {
    status[23] = 128U;
    if ((unsigned int )sd_card->sd_erase_status != 0U) {
      status[23] = (u8 )((unsigned int )status[23] | 1U);
    } else {

    }
    if ((int )((signed char )sd_card->sd_lock_status) < 0) {
      status[23] = (u8 )((unsigned int )status[23] | 2U);
      status[7] = (u8 )((unsigned int )status[7] | 64U);
    } else {

    }
    if (((int )sd_card->sd_lock_status & 32) != 0) {
      status[23] = (u8 )((unsigned int )status[23] | 4U);
    } else {

    }
  } else {
    status[23] = 0U;
  }
  descriptor.modname = "rts5208";
  descriptor.function = "get_dev_status";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_scsi.c";
  descriptor.format = "status[0x17] = 0x%x\n";
  descriptor.lineno = 1786U;
  descriptor.flags = 0U;
  tmp___1 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp___1 != 0L) {
    tmp___0 = rtsx_dev((struct rtsx_chip  const  *)chip);
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)tmp___0, "status[0x17] = 0x%x\n",
                      (int )status[23]);
  } else {

  }
  status[24] = 138U;
  status[26] = 40U;
  status[31] = 1U;
  tmp___2 = scsi_bufflen(srb);
  __min1 = tmp___2;
  __min2 = 32U;
  buf_len = (int )(__min1 < __min2 ? __min1 : __min2);
  rtsx_stor_set_xfer_buf((unsigned char *)(& status), (unsigned int )buf_len, srb);
  tmp___3 = scsi_bufflen(srb);
  scsi_set_resid(srb, (int )(tmp___3 - (unsigned int )buf_len));
  return (0);
}
}
static int set_chip_mode(struct scsi_cmnd *srb , struct rtsx_chip *chip ) 
{ 
  int phy_debug_mode ;
  int retval ;
  u16 reg ;

  {
  if ((unsigned int )chip->product_id != 21000U) {
    set_sense_type(chip, (unsigned int )(srb->device)->lun, 6);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_scsi.c",
                "set_chip_mode", 1811);
    return (1);
  } else {

  }
  phy_debug_mode = (int )*(srb->cmnd + 3UL);
  if (phy_debug_mode != 0) {
    chip->phy_debug_mode = 1;
    retval = rtsx_write_register(chip, 65106, 119, 0);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_scsi.c",
                  "set_chip_mode", 1821);
      return (1);
    } else {

    }
    rtsx_disable_bus_int(chip);
    retval = rtsx_read_phy_register(chip, 28, & reg);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_scsi.c",
                  "set_chip_mode", 1829);
      return (1);
    } else {

    }
    reg = (u16 )((unsigned int )reg | 1U);
    retval = rtsx_write_phy_register(chip, 28, (int )reg);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_scsi.c",
                  "set_chip_mode", 1836);
      return (1);
    } else {

    }
  } else {
    chip->phy_debug_mode = 0;
    retval = rtsx_write_register(chip, 65106, 119, 119);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_scsi.c",
                  "set_chip_mode", 1843);
      return (1);
    } else {

    }
    rtsx_enable_bus_int(chip);
    retval = rtsx_read_phy_register(chip, 28, & reg);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_scsi.c",
                  "set_chip_mode", 1851);
      return (1);
    } else {

    }
    reg = (unsigned int )reg & 65534U;
    retval = rtsx_write_phy_register(chip, 28, (int )reg);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_scsi.c",
                  "set_chip_mode", 1858);
      return (1);
    } else {

    }
  }
  return (0);
}
}
static int rw_mem_cmd_buf(struct scsi_cmnd *srb , struct rtsx_chip *chip ) 
{ 
  int retval ;
  unsigned int lun ;
  u8 cmd_type ;
  u8 mask ;
  u8 value ;
  u8 idx ;
  u16 addr ;
  struct task_struct *tmp ;
  long volatile   __ret ;
  struct task_struct *tmp___0 ;
  struct task_struct *tmp___1 ;
  struct task_struct *tmp___2 ;
  struct task_struct *tmp___3 ;
  u8 *tmp___4 ;
  unsigned int tmp___5 ;

  {
  retval = 0;
  lun = (unsigned int )(srb->device)->lun;
  rtsx_disable_aspm(chip);
  if (chip->ss_en != 0 && (unsigned int )chip->rtsx_stat == 3U) {
    rtsx_exit_ss(chip);
    tmp = get_current();
    tmp->task_state_change = 0UL;
    __ret = 1L;
    switch (8UL) {
    case 1UL: 
    tmp___0 = get_current();
    __asm__  volatile   ("xchgb %b0, %1\n": "+q" (__ret), "+m" (tmp___0->state): : "memory",
                         "cc");
    goto ldv_39066;
    case 2UL: 
    tmp___1 = get_current();
    __asm__  volatile   ("xchgw %w0, %1\n": "+r" (__ret), "+m" (tmp___1->state): : "memory",
                         "cc");
    goto ldv_39066;
    case 4UL: 
    tmp___2 = get_current();
    __asm__  volatile   ("xchgl %0, %1\n": "+r" (__ret), "+m" (tmp___2->state): : "memory",
                         "cc");
    goto ldv_39066;
    case 8UL: 
    tmp___3 = get_current();
    __asm__  volatile   ("xchgq %q0, %1\n": "+r" (__ret), "+m" (tmp___3->state): : "memory",
                         "cc");
    goto ldv_39066;
    default: 
    __xchg_wrong_size();
    }
    ldv_39066: 
    schedule_timeout(25L);
  } else {

  }
  chip->idle_counter = 0;
  chip->rtsx_stat = 2;
  switch ((int )*(srb->cmnd + 3UL)) {
  case 65: 
  chip->ci = 0;
  goto ldv_39073;
  case 66: 
  cmd_type = *(srb->cmnd + 4UL);
  if ((unsigned int )cmd_type > 2U) {
    set_sense_type(chip, lun, 6);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_scsi.c",
                "rw_mem_cmd_buf", 1891);
    return (1);
  } else {

  }
  addr = (u16 )((int )((short )((int )*(srb->cmnd + 5UL) << 8)) | (int )((short )*(srb->cmnd + 6UL)));
  mask = *(srb->cmnd + 7UL);
  value = *(srb->cmnd + 8UL);
  rtsx_add_cmd(chip, (int )cmd_type, (int )addr, (int )mask, (int )value);
  goto ldv_39073;
  case 67: 
  retval = rtsx_send_cmd(chip, 0, 1000);
  goto ldv_39073;
  case 68: 
  idx = *(srb->cmnd + 4UL);
  tmp___4 = rtsx_get_cmd_data(chip);
  value = *(tmp___4 + (unsigned long )idx);
  tmp___5 = scsi_bufflen(srb);
  if (tmp___5 == 0U) {
    set_sense_type(chip, lun, 6);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_scsi.c",
                "rw_mem_cmd_buf", 1910);
    return (1);
  } else {

  }
  rtsx_stor_set_xfer_buf(& value, 1U, srb);
  scsi_set_resid(srb, 0);
  goto ldv_39073;
  default: 
  set_sense_type(chip, lun, 6);
  _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_scsi.c",
              "rw_mem_cmd_buf", 1919);
  return (1);
  }
  ldv_39073: ;
  if (retval != 0) {
    set_sense_type(chip, lun, 8);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_scsi.c",
                "rw_mem_cmd_buf", 1925);
    return (1);
  } else {

  }
  return (0);
}
}
static int suit_cmd(struct scsi_cmnd *srb , struct rtsx_chip *chip ) 
{ 
  int result ;

  {
  switch ((int )*(srb->cmnd + 3UL)) {
  case 65: ;
  case 66: ;
  case 67: ;
  case 68: 
  result = rw_mem_cmd_buf(srb, chip);
  goto ldv_39088;
  default: 
  result = 3;
  }
  ldv_39088: ;
  return (result);
}
}
static int read_phy_register(struct scsi_cmnd *srb , struct rtsx_chip *chip ) 
{ 
  unsigned short addr ;
  unsigned short len ;
  unsigned short i ;
  int retval ;
  u8 *buf ;
  u16 val ;
  struct task_struct *tmp ;
  long volatile   __ret ;
  struct task_struct *tmp___0 ;
  struct task_struct *tmp___1 ;
  struct task_struct *tmp___2 ;
  struct task_struct *tmp___3 ;
  void *tmp___4 ;
  unsigned int __min1 ;
  unsigned int tmp___5 ;
  unsigned int __min2 ;
  unsigned int tmp___6 ;

  {
  rtsx_disable_aspm(chip);
  if (chip->ss_en != 0 && (unsigned int )chip->rtsx_stat == 3U) {
    rtsx_exit_ss(chip);
    tmp = get_current();
    tmp->task_state_change = 0UL;
    __ret = 1L;
    switch (8UL) {
    case 1UL: 
    tmp___0 = get_current();
    __asm__  volatile   ("xchgb %b0, %1\n": "+q" (__ret), "+m" (tmp___0->state): : "memory",
                         "cc");
    goto ldv_39102;
    case 2UL: 
    tmp___1 = get_current();
    __asm__  volatile   ("xchgw %w0, %1\n": "+r" (__ret), "+m" (tmp___1->state): : "memory",
                         "cc");
    goto ldv_39102;
    case 4UL: 
    tmp___2 = get_current();
    __asm__  volatile   ("xchgl %0, %1\n": "+r" (__ret), "+m" (tmp___2->state): : "memory",
                         "cc");
    goto ldv_39102;
    case 8UL: 
    tmp___3 = get_current();
    __asm__  volatile   ("xchgq %q0, %1\n": "+r" (__ret), "+m" (tmp___3->state): : "memory",
                         "cc");
    goto ldv_39102;
    default: 
    __xchg_wrong_size();
    }
    ldv_39102: 
    schedule_timeout(25L);
  } else {

  }
  chip->idle_counter = 0;
  chip->rtsx_stat = 2;
  addr = (unsigned short )((int )((short )((int )*(srb->cmnd + 4UL) << 8)) | (int )((short )*(srb->cmnd + 5UL)));
  len = (unsigned short )((int )((short )((int )*(srb->cmnd + 6UL) << 8)) | (int )((short )*(srb->cmnd + 7UL)));
  if ((int )len & 1) {
    len = (unsigned int )len & 65534U;
  } else {

  }
  if ((unsigned int )len != 0U) {
    tmp___4 = vmalloc((unsigned long )len);
    buf = (u8 *)tmp___4;
    if ((unsigned long )buf == (unsigned long )((u8 *)0U)) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_scsi.c",
                  "read_phy_register", 1974);
      return (3);
    } else {

    }
    retval = rtsx_force_power_on(chip, 1);
    if (retval != 0) {
      vfree((void const   *)buf);
      set_sense_type(chip, (unsigned int )(srb->device)->lun, 7);
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_scsi.c",
                  "read_phy_register", 1983);
      return (1);
    } else {

    }
    i = 0U;
    goto ldv_39110;
    ldv_39109: 
    retval = rtsx_read_phy_register(chip, (int )((u8 )addr) + (int )((u8 )i), & val);
    if (retval != 0) {
      vfree((void const   *)buf);
      set_sense_type(chip, (unsigned int )(srb->device)->lun, 7);
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_scsi.c",
                  "read_phy_register", 1993);
      return (1);
    } else {

    }
    *(buf + (unsigned long )((int )i * 2)) = (unsigned char )((int )val >> 8);
    *(buf + ((unsigned long )((int )i * 2) + 1UL)) = (unsigned char )val;
    i = (unsigned short )((int )i + 1);
    ldv_39110: ;
    if ((unsigned int )len / 2U > (unsigned int )i) {
      goto ldv_39109;
    } else {

    }
    tmp___5 = scsi_bufflen(srb);
    __min1 = tmp___5;
    __min2 = (unsigned int )len;
    len = (unsigned short )(__min1 < __min2 ? __min1 : __min2);
    rtsx_stor_set_xfer_buf(buf, (unsigned int )len, srb);
    tmp___6 = scsi_bufflen(srb);
    scsi_set_resid(srb, (int )(tmp___6 - (unsigned int )len));
    vfree((void const   *)buf);
  } else {

  }
  return (0);
}
}
static int write_phy_register(struct scsi_cmnd *srb , struct rtsx_chip *chip ) 
{ 
  unsigned short addr ;
  unsigned short len ;
  unsigned short i ;
  int retval ;
  u8 *buf ;
  u16 val ;
  struct task_struct *tmp ;
  long volatile   __ret ;
  struct task_struct *tmp___0 ;
  struct task_struct *tmp___1 ;
  struct task_struct *tmp___2 ;
  struct task_struct *tmp___3 ;
  unsigned int __min1 ;
  unsigned int tmp___4 ;
  unsigned int __min2 ;
  void *tmp___5 ;
  unsigned int tmp___6 ;

  {
  rtsx_disable_aspm(chip);
  if (chip->ss_en != 0 && (unsigned int )chip->rtsx_stat == 3U) {
    rtsx_exit_ss(chip);
    tmp = get_current();
    tmp->task_state_change = 0UL;
    __ret = 1L;
    switch (8UL) {
    case 1UL: 
    tmp___0 = get_current();
    __asm__  volatile   ("xchgb %b0, %1\n": "+q" (__ret), "+m" (tmp___0->state): : "memory",
                         "cc");
    goto ldv_39127;
    case 2UL: 
    tmp___1 = get_current();
    __asm__  volatile   ("xchgw %w0, %1\n": "+r" (__ret), "+m" (tmp___1->state): : "memory",
                         "cc");
    goto ldv_39127;
    case 4UL: 
    tmp___2 = get_current();
    __asm__  volatile   ("xchgl %0, %1\n": "+r" (__ret), "+m" (tmp___2->state): : "memory",
                         "cc");
    goto ldv_39127;
    case 8UL: 
    tmp___3 = get_current();
    __asm__  volatile   ("xchgq %q0, %1\n": "+r" (__ret), "+m" (tmp___3->state): : "memory",
                         "cc");
    goto ldv_39127;
    default: 
    __xchg_wrong_size();
    }
    ldv_39127: 
    schedule_timeout(25L);
  } else {

  }
  chip->idle_counter = 0;
  chip->rtsx_stat = 2;
  addr = (unsigned short )((int )((short )((int )*(srb->cmnd + 4UL) << 8)) | (int )((short )*(srb->cmnd + 5UL)));
  len = (unsigned short )((int )((short )((int )*(srb->cmnd + 6UL) << 8)) | (int )((short )*(srb->cmnd + 7UL)));
  if ((int )len & 1) {
    len = (unsigned int )len & 65534U;
  } else {

  }
  if ((unsigned int )len != 0U) {
    tmp___4 = scsi_bufflen(srb);
    __min1 = tmp___4;
    __min2 = (unsigned int )len;
    len = (unsigned short )(__min1 < __min2 ? __min1 : __min2);
    tmp___5 = vmalloc((unsigned long )len);
    buf = (u8 *)tmp___5;
    if ((unsigned long )buf == (unsigned long )((u8 *)0U)) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_scsi.c",
                  "write_phy_register", 2039);
      return (3);
    } else {

    }
    rtsx_stor_get_xfer_buf(buf, (unsigned int )len, srb);
    tmp___6 = scsi_bufflen(srb);
    scsi_set_resid(srb, (int )(tmp___6 - (unsigned int )len));
    retval = rtsx_force_power_on(chip, 1);
    if (retval != 0) {
      vfree((void const   *)buf);
      set_sense_type(chip, (unsigned int )(srb->device)->lun, 8);
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_scsi.c",
                  "write_phy_register", 2051);
      return (1);
    } else {

    }
    i = 0U;
    goto ldv_39138;
    ldv_39137: 
    val = (u16 )((int )((short )((int )*(buf + (unsigned long )((int )i * 2)) << 8)) | (int )((short )*(buf + ((unsigned long )((int )i * 2) + 1UL))));
    retval = rtsx_write_phy_register(chip, (int )((u8 )addr) + (int )((u8 )i), (int )val);
    if (retval != 0) {
      vfree((void const   *)buf);
      set_sense_type(chip, (unsigned int )(srb->device)->lun, 8);
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_scsi.c",
                  "write_phy_register", 2062);
      return (1);
    } else {

    }
    i = (unsigned short )((int )i + 1);
    ldv_39138: ;
    if ((unsigned int )len / 2U > (unsigned int )i) {
      goto ldv_39137;
    } else {

    }
    vfree((void const   *)buf);
  } else {

  }
  return (0);
}
}
static int erase_eeprom2(struct scsi_cmnd *srb , struct rtsx_chip *chip ) 
{ 
  unsigned short addr ;
  int retval ;
  u8 mode ;
  struct task_struct *tmp ;
  long volatile   __ret ;
  struct task_struct *tmp___0 ;
  struct task_struct *tmp___1 ;
  struct task_struct *tmp___2 ;
  struct task_struct *tmp___3 ;

  {
  rtsx_disable_aspm(chip);
  if (chip->ss_en != 0 && (unsigned int )chip->rtsx_stat == 3U) {
    rtsx_exit_ss(chip);
    tmp = get_current();
    tmp->task_state_change = 0UL;
    __ret = 1L;
    switch (8UL) {
    case 1UL: 
    tmp___0 = get_current();
    __asm__  volatile   ("xchgb %b0, %1\n": "+q" (__ret), "+m" (tmp___0->state): : "memory",
                         "cc");
    goto ldv_39149;
    case 2UL: 
    tmp___1 = get_current();
    __asm__  volatile   ("xchgw %w0, %1\n": "+r" (__ret), "+m" (tmp___1->state): : "memory",
                         "cc");
    goto ldv_39149;
    case 4UL: 
    tmp___2 = get_current();
    __asm__  volatile   ("xchgl %0, %1\n": "+r" (__ret), "+m" (tmp___2->state): : "memory",
                         "cc");
    goto ldv_39149;
    case 8UL: 
    tmp___3 = get_current();
    __asm__  volatile   ("xchgq %q0, %1\n": "+r" (__ret), "+m" (tmp___3->state): : "memory",
                         "cc");
    goto ldv_39149;
    default: 
    __xchg_wrong_size();
    }
    ldv_39149: 
    schedule_timeout(25L);
  } else {

  }
  chip->idle_counter = 0;
  chip->rtsx_stat = 2;
  retval = rtsx_force_power_on(chip, 1);
  if (retval != 0) {
    set_sense_type(chip, (unsigned int )(srb->device)->lun, 8);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_scsi.c",
                "erase_eeprom2", 2090);
    return (1);
  } else {

  }
  mode = *(srb->cmnd + 3UL);
  addr = (unsigned short )((int )((short )((int )*(srb->cmnd + 4UL) << 8)) | (int )((short )*(srb->cmnd + 5UL)));
  if ((unsigned int )mode == 0U) {
    retval = spi_erase_eeprom_chip(chip);
    if (retval != 0) {
      set_sense_type(chip, (unsigned int )(srb->device)->lun, 8);
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_scsi.c",
                  "erase_eeprom2", 2102);
      return (1);
    } else {

    }
  } else
  if ((unsigned int )mode == 1U) {
    retval = spi_erase_eeprom_byte(chip, (int )addr);
    if (retval != 0) {
      set_sense_type(chip, (unsigned int )(srb->device)->lun, 8);
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_scsi.c",
                  "erase_eeprom2", 2110);
      return (1);
    } else {

    }
  } else {
    set_sense_type(chip, (unsigned int )(srb->device)->lun, 6);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_scsi.c",
                "erase_eeprom2", 2116);
    return (1);
  }
  return (0);
}
}
static int read_eeprom2(struct scsi_cmnd *srb , struct rtsx_chip *chip ) 
{ 
  unsigned short addr ;
  unsigned short len ;
  unsigned short i ;
  int retval ;
  u8 *buf ;
  struct task_struct *tmp ;
  long volatile   __ret ;
  struct task_struct *tmp___0 ;
  struct task_struct *tmp___1 ;
  struct task_struct *tmp___2 ;
  struct task_struct *tmp___3 ;
  void *tmp___4 ;
  unsigned int __min1 ;
  unsigned int tmp___5 ;
  unsigned int __min2 ;
  unsigned int tmp___6 ;

  {
  rtsx_disable_aspm(chip);
  if (chip->ss_en != 0 && (unsigned int )chip->rtsx_stat == 3U) {
    rtsx_exit_ss(chip);
    tmp = get_current();
    tmp->task_state_change = 0UL;
    __ret = 1L;
    switch (8UL) {
    case 1UL: 
    tmp___0 = get_current();
    __asm__  volatile   ("xchgb %b0, %1\n": "+q" (__ret), "+m" (tmp___0->state): : "memory",
                         "cc");
    goto ldv_39167;
    case 2UL: 
    tmp___1 = get_current();
    __asm__  volatile   ("xchgw %w0, %1\n": "+r" (__ret), "+m" (tmp___1->state): : "memory",
                         "cc");
    goto ldv_39167;
    case 4UL: 
    tmp___2 = get_current();
    __asm__  volatile   ("xchgl %0, %1\n": "+r" (__ret), "+m" (tmp___2->state): : "memory",
                         "cc");
    goto ldv_39167;
    case 8UL: 
    tmp___3 = get_current();
    __asm__  volatile   ("xchgq %q0, %1\n": "+r" (__ret), "+m" (tmp___3->state): : "memory",
                         "cc");
    goto ldv_39167;
    default: 
    __xchg_wrong_size();
    }
    ldv_39167: 
    schedule_timeout(25L);
  } else {

  }
  chip->idle_counter = 0;
  chip->rtsx_stat = 2;
  addr = (unsigned short )((int )((short )((int )*(srb->cmnd + 4UL) << 8)) | (int )((short )*(srb->cmnd + 5UL)));
  len = (unsigned short )((int )((short )((int )*(srb->cmnd + 6UL) << 8)) | (int )((short )*(srb->cmnd + 7UL)));
  tmp___4 = vmalloc((unsigned long )len);
  buf = (u8 *)tmp___4;
  if ((unsigned long )buf == (unsigned long )((u8 *)0U)) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_scsi.c",
                "read_eeprom2", 2142);
    return (3);
  } else {

  }
  retval = rtsx_force_power_on(chip, 1);
  if (retval != 0) {
    vfree((void const   *)buf);
    set_sense_type(chip, (unsigned int )(srb->device)->lun, 7);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_scsi.c",
                "read_eeprom2", 2151);
    return (1);
  } else {

  }
  i = 0U;
  goto ldv_39175;
  ldv_39174: 
  retval = spi_read_eeprom(chip, (int )addr + (int )i, buf + (unsigned long )i);
  if (retval != 0) {
    vfree((void const   *)buf);
    set_sense_type(chip, (unsigned int )(srb->device)->lun, 7);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_scsi.c",
                "read_eeprom2", 2161);
    return (1);
  } else {

  }
  i = (unsigned short )((int )i + 1);
  ldv_39175: ;
  if ((int )i < (int )len) {
    goto ldv_39174;
  } else {

  }
  tmp___5 = scsi_bufflen(srb);
  __min1 = tmp___5;
  __min2 = (unsigned int )len;
  len = (unsigned short )(__min1 < __min2 ? __min1 : __min2);
  rtsx_stor_set_xfer_buf(buf, (unsigned int )len, srb);
  tmp___6 = scsi_bufflen(srb);
  scsi_set_resid(srb, (int )(tmp___6 - (unsigned int )len));
  vfree((void const   *)buf);
  return (0);
}
}
static int write_eeprom2(struct scsi_cmnd *srb , struct rtsx_chip *chip ) 
{ 
  unsigned short addr ;
  unsigned short len ;
  unsigned short i ;
  int retval ;
  u8 *buf ;
  struct task_struct *tmp ;
  long volatile   __ret ;
  struct task_struct *tmp___0 ;
  struct task_struct *tmp___1 ;
  struct task_struct *tmp___2 ;
  struct task_struct *tmp___3 ;
  unsigned int __min1 ;
  unsigned int tmp___4 ;
  unsigned int __min2 ;
  void *tmp___5 ;
  unsigned int tmp___6 ;

  {
  rtsx_disable_aspm(chip);
  if (chip->ss_en != 0 && (unsigned int )chip->rtsx_stat == 3U) {
    rtsx_exit_ss(chip);
    tmp = get_current();
    tmp->task_state_change = 0UL;
    __ret = 1L;
    switch (8UL) {
    case 1UL: 
    tmp___0 = get_current();
    __asm__  volatile   ("xchgb %b0, %1\n": "+q" (__ret), "+m" (tmp___0->state): : "memory",
                         "cc");
    goto ldv_39191;
    case 2UL: 
    tmp___1 = get_current();
    __asm__  volatile   ("xchgw %w0, %1\n": "+r" (__ret), "+m" (tmp___1->state): : "memory",
                         "cc");
    goto ldv_39191;
    case 4UL: 
    tmp___2 = get_current();
    __asm__  volatile   ("xchgl %0, %1\n": "+r" (__ret), "+m" (tmp___2->state): : "memory",
                         "cc");
    goto ldv_39191;
    case 8UL: 
    tmp___3 = get_current();
    __asm__  volatile   ("xchgq %q0, %1\n": "+r" (__ret), "+m" (tmp___3->state): : "memory",
                         "cc");
    goto ldv_39191;
    default: 
    __xchg_wrong_size();
    }
    ldv_39191: 
    schedule_timeout(25L);
  } else {

  }
  chip->idle_counter = 0;
  chip->rtsx_stat = 2;
  addr = (unsigned short )((int )((short )((int )*(srb->cmnd + 4UL) << 8)) | (int )((short )*(srb->cmnd + 5UL)));
  len = (unsigned short )((int )((short )((int )*(srb->cmnd + 6UL) << 8)) | (int )((short )*(srb->cmnd + 7UL)));
  tmp___4 = scsi_bufflen(srb);
  __min1 = tmp___4;
  __min2 = (unsigned int )len;
  len = (unsigned short )(__min1 < __min2 ? __min1 : __min2);
  tmp___5 = vmalloc((unsigned long )len);
  buf = (u8 *)tmp___5;
  if ((unsigned long )buf == (unsigned long )((u8 *)0U)) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_scsi.c",
                "write_eeprom2", 2195);
    return (3);
  } else {

  }
  rtsx_stor_get_xfer_buf(buf, (unsigned int )len, srb);
  tmp___6 = scsi_bufflen(srb);
  scsi_set_resid(srb, (int )(tmp___6 - (unsigned int )len));
  retval = rtsx_force_power_on(chip, 1);
  if (retval != 0) {
    vfree((void const   *)buf);
    set_sense_type(chip, (unsigned int )(srb->device)->lun, 8);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_scsi.c",
                "write_eeprom2", 2206);
    return (1);
  } else {

  }
  i = 0U;
  goto ldv_39202;
  ldv_39201: 
  retval = spi_write_eeprom(chip, (int )addr + (int )i, (int )*(buf + (unsigned long )i));
  if (retval != 0) {
    vfree((void const   *)buf);
    set_sense_type(chip, (unsigned int )(srb->device)->lun, 8);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_scsi.c",
                "write_eeprom2", 2216);
    return (1);
  } else {

  }
  i = (unsigned short )((int )i + 1);
  ldv_39202: ;
  if ((int )i < (int )len) {
    goto ldv_39201;
  } else {

  }
  vfree((void const   *)buf);
  return (0);
}
}
static int read_efuse(struct scsi_cmnd *srb , struct rtsx_chip *chip ) 
{ 
  int retval ;
  u8 addr ;
  u8 len ;
  u8 i ;
  u8 *buf ;
  struct task_struct *tmp ;
  long volatile   __ret ;
  struct task_struct *tmp___0 ;
  struct task_struct *tmp___1 ;
  struct task_struct *tmp___2 ;
  struct task_struct *tmp___3 ;
  void *tmp___4 ;
  unsigned int __min1 ;
  unsigned int tmp___5 ;
  unsigned int __min2 ;
  unsigned int tmp___6 ;

  {
  rtsx_disable_aspm(chip);
  if (chip->ss_en != 0 && (unsigned int )chip->rtsx_stat == 3U) {
    rtsx_exit_ss(chip);
    tmp = get_current();
    tmp->task_state_change = 0UL;
    __ret = 1L;
    switch (8UL) {
    case 1UL: 
    tmp___0 = get_current();
    __asm__  volatile   ("xchgb %b0, %1\n": "+q" (__ret), "+m" (tmp___0->state): : "memory",
                         "cc");
    goto ldv_39215;
    case 2UL: 
    tmp___1 = get_current();
    __asm__  volatile   ("xchgw %w0, %1\n": "+r" (__ret), "+m" (tmp___1->state): : "memory",
                         "cc");
    goto ldv_39215;
    case 4UL: 
    tmp___2 = get_current();
    __asm__  volatile   ("xchgl %0, %1\n": "+r" (__ret), "+m" (tmp___2->state): : "memory",
                         "cc");
    goto ldv_39215;
    case 8UL: 
    tmp___3 = get_current();
    __asm__  volatile   ("xchgq %q0, %1\n": "+r" (__ret), "+m" (tmp___3->state): : "memory",
                         "cc");
    goto ldv_39215;
    default: 
    __xchg_wrong_size();
    }
    ldv_39215: 
    schedule_timeout(25L);
  } else {

  }
  chip->idle_counter = 0;
  chip->rtsx_stat = 2;
  addr = *(srb->cmnd + 4UL);
  len = *(srb->cmnd + 5UL);
  tmp___4 = vmalloc((unsigned long )len);
  buf = (u8 *)tmp___4;
  if ((unsigned long )buf == (unsigned long )((u8 *)0U)) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_scsi.c",
                "read_efuse", 2245);
    return (3);
  } else {

  }
  retval = rtsx_force_power_on(chip, 1);
  if (retval != 0) {
    vfree((void const   *)buf);
    set_sense_type(chip, (unsigned int )(srb->device)->lun, 7);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_scsi.c",
                "read_efuse", 2254);
    return (1);
  } else {

  }
  i = 0U;
  goto ldv_39223;
  ldv_39222: 
  retval = rtsx_read_efuse(chip, (int )addr + (int )i, buf + (unsigned long )i);
  if (retval != 0) {
    vfree((void const   *)buf);
    set_sense_type(chip, (unsigned int )(srb->device)->lun, 7);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_scsi.c",
                "read_efuse", 2264);
    return (1);
  } else {

  }
  i = (u8 )((int )i + 1);
  ldv_39223: ;
  if ((int )i < (int )len) {
    goto ldv_39222;
  } else {

  }
  tmp___5 = scsi_bufflen(srb);
  __min1 = tmp___5;
  __min2 = (unsigned int )len;
  len = (unsigned char )(__min1 < __min2 ? __min1 : __min2);
  rtsx_stor_set_xfer_buf(buf, (unsigned int )len, srb);
  tmp___6 = scsi_bufflen(srb);
  scsi_set_resid(srb, (int )(tmp___6 - (unsigned int )len));
  vfree((void const   *)buf);
  return (0);
}
}
static int write_efuse(struct scsi_cmnd *srb , struct rtsx_chip *chip ) 
{ 
  int retval ;
  int result ;
  u16 val ;
  u8 addr ;
  u8 len ;
  u8 i ;
  u8 *buf ;
  struct task_struct *tmp ;
  long volatile   __ret ;
  struct task_struct *tmp___0 ;
  struct task_struct *tmp___1 ;
  struct task_struct *tmp___2 ;
  struct task_struct *tmp___3 ;
  unsigned int __min1 ;
  unsigned int tmp___4 ;
  unsigned int __min2 ;
  void *tmp___5 ;
  unsigned int tmp___6 ;
  struct task_struct *tmp___7 ;
  long volatile   __ret___0 ;
  struct task_struct *tmp___8 ;
  struct task_struct *tmp___9 ;
  struct task_struct *tmp___10 ;
  struct task_struct *tmp___11 ;
  struct task_struct *tmp___12 ;
  long volatile   __ret___1 ;
  struct task_struct *tmp___13 ;
  struct task_struct *tmp___14 ;
  struct task_struct *tmp___15 ;
  struct task_struct *tmp___16 ;
  struct task_struct *tmp___17 ;
  long volatile   __ret___2 ;
  struct task_struct *tmp___18 ;
  struct task_struct *tmp___19 ;
  struct task_struct *tmp___20 ;
  struct task_struct *tmp___21 ;
  struct task_struct *tmp___22 ;
  long volatile   __ret___3 ;
  struct task_struct *tmp___23 ;
  struct task_struct *tmp___24 ;
  struct task_struct *tmp___25 ;
  struct task_struct *tmp___26 ;

  {
  result = 0;
  rtsx_disable_aspm(chip);
  if (chip->ss_en != 0 && (unsigned int )chip->rtsx_stat == 3U) {
    rtsx_exit_ss(chip);
    tmp = get_current();
    tmp->task_state_change = 0UL;
    __ret = 1L;
    switch (8UL) {
    case 1UL: 
    tmp___0 = get_current();
    __asm__  volatile   ("xchgb %b0, %1\n": "+q" (__ret), "+m" (tmp___0->state): : "memory",
                         "cc");
    goto ldv_39241;
    case 2UL: 
    tmp___1 = get_current();
    __asm__  volatile   ("xchgw %w0, %1\n": "+r" (__ret), "+m" (tmp___1->state): : "memory",
                         "cc");
    goto ldv_39241;
    case 4UL: 
    tmp___2 = get_current();
    __asm__  volatile   ("xchgl %0, %1\n": "+r" (__ret), "+m" (tmp___2->state): : "memory",
                         "cc");
    goto ldv_39241;
    case 8UL: 
    tmp___3 = get_current();
    __asm__  volatile   ("xchgq %q0, %1\n": "+r" (__ret), "+m" (tmp___3->state): : "memory",
                         "cc");
    goto ldv_39241;
    default: 
    __xchg_wrong_size();
    }
    ldv_39241: 
    schedule_timeout(25L);
  } else {

  }
  chip->idle_counter = 0;
  chip->rtsx_stat = 2;
  addr = *(srb->cmnd + 4UL);
  len = *(srb->cmnd + 5UL);
  tmp___4 = scsi_bufflen(srb);
  __min1 = tmp___4;
  __min2 = (unsigned int )len;
  len = (unsigned char )(__min1 < __min2 ? __min1 : __min2);
  tmp___5 = vmalloc((unsigned long )len);
  buf = (u8 *)tmp___5;
  if ((unsigned long )buf == (unsigned long )((u8 *)0U)) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_scsi.c",
                "write_efuse", 2299);
    return (3);
  } else {

  }
  rtsx_stor_get_xfer_buf(buf, (unsigned int )len, srb);
  tmp___6 = scsi_bufflen(srb);
  scsi_set_resid(srb, (int )(tmp___6 - (unsigned int )len));
  retval = rtsx_force_power_on(chip, 1);
  if (retval != 0) {
    vfree((void const   *)buf);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_scsi.c",
                "write_efuse", 2309);
    return (3);
  } else {

  }
  if (chip->asic_code != 0) {
    retval = rtsx_read_phy_register(chip, 8, & val);
    if (retval != 0) {
      vfree((void const   *)buf);
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_scsi.c",
                  "write_efuse", 2317);
      return (3);
    } else {

    }
    retval = rtsx_write_register(chip, 65141, 6, 6);
    if (retval != 0) {
      vfree((void const   *)buf);
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_scsi.c",
                  "write_efuse", 2325);
      return (3);
    } else {

    }
    tmp___7 = get_current();
    tmp___7->task_state_change = 0UL;
    __ret___0 = 1L;
    switch (8UL) {
    case 1UL: 
    tmp___8 = get_current();
    __asm__  volatile   ("xchgb %b0, %1\n": "+q" (__ret___0), "+m" (tmp___8->state): : "memory",
                         "cc");
    goto ldv_39253;
    case 2UL: 
    tmp___9 = get_current();
    __asm__  volatile   ("xchgw %w0, %1\n": "+r" (__ret___0), "+m" (tmp___9->state): : "memory",
                         "cc");
    goto ldv_39253;
    case 4UL: 
    tmp___10 = get_current();
    __asm__  volatile   ("xchgl %0, %1\n": "+r" (__ret___0), "+m" (tmp___10->state): : "memory",
                         "cc");
    goto ldv_39253;
    case 8UL: 
    tmp___11 = get_current();
    __asm__  volatile   ("xchgq %q0, %1\n": "+r" (__ret___0), "+m" (tmp___11->state): : "memory",
                         "cc");
    goto ldv_39253;
    default: 
    __xchg_wrong_size();
    }
    ldv_39253: 
    schedule_timeout(150L);
    retval = rtsx_write_phy_register(chip, 8, (int )((unsigned int )((u16 )chip->phy_voltage) | 19456U));
    if (retval != 0) {
      vfree((void const   *)buf);
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_scsi.c",
                  "write_efuse", 2335);
      return (3);
    } else {

    }
    retval = rtsx_write_register(chip, 65141, 6, 0);
    if (retval != 0) {
      vfree((void const   *)buf);
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_scsi.c",
                  "write_efuse", 2343);
      return (3);
    } else {

    }
    tmp___12 = get_current();
    tmp___12->task_state_change = 0UL;
    __ret___1 = 1L;
    switch (8UL) {
    case 1UL: 
    tmp___13 = get_current();
    __asm__  volatile   ("xchgb %b0, %1\n": "+q" (__ret___1), "+m" (tmp___13->state): : "memory",
                         "cc");
    goto ldv_39261;
    case 2UL: 
    tmp___14 = get_current();
    __asm__  volatile   ("xchgw %w0, %1\n": "+r" (__ret___1), "+m" (tmp___14->state): : "memory",
                         "cc");
    goto ldv_39261;
    case 4UL: 
    tmp___15 = get_current();
    __asm__  volatile   ("xchgl %0, %1\n": "+r" (__ret___1), "+m" (tmp___15->state): : "memory",
                         "cc");
    goto ldv_39261;
    case 8UL: 
    tmp___16 = get_current();
    __asm__  volatile   ("xchgq %q0, %1\n": "+r" (__ret___1), "+m" (tmp___16->state): : "memory",
                         "cc");
    goto ldv_39261;
    default: 
    __xchg_wrong_size();
    }
    ldv_39261: 
    schedule_timeout(150L);
  } else {

  }
  retval = card_power_on(chip, 128);
  if (retval != 0) {
    vfree((void const   *)buf);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_scsi.c",
                "write_efuse", 2353);
    return (3);
  } else {

  }
  tmp___17 = get_current();
  tmp___17->task_state_change = 0UL;
  __ret___2 = 1L;
  switch (8UL) {
  case 1UL: 
  tmp___18 = get_current();
  __asm__  volatile   ("xchgb %b0, %1\n": "+q" (__ret___2), "+m" (tmp___18->state): : "memory",
                       "cc");
  goto ldv_39269;
  case 2UL: 
  tmp___19 = get_current();
  __asm__  volatile   ("xchgw %w0, %1\n": "+r" (__ret___2), "+m" (tmp___19->state): : "memory",
                       "cc");
  goto ldv_39269;
  case 4UL: 
  tmp___20 = get_current();
  __asm__  volatile   ("xchgl %0, %1\n": "+r" (__ret___2), "+m" (tmp___20->state): : "memory",
                       "cc");
  goto ldv_39269;
  case 8UL: 
  tmp___21 = get_current();
  __asm__  volatile   ("xchgq %q0, %1\n": "+r" (__ret___2), "+m" (tmp___21->state): : "memory",
                       "cc");
  goto ldv_39269;
  default: 
  __xchg_wrong_size();
  }
  ldv_39269: 
  schedule_timeout(12L);
  i = 0U;
  goto ldv_39277;
  ldv_39276: 
  retval = rtsx_write_efuse(chip, (int )addr + (int )i, (int )*(buf + (unsigned long )i));
  if (retval != 0) {
    set_sense_type(chip, (unsigned int )(srb->device)->lun, 8);
    result = 1;
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_scsi.c",
                "write_efuse", 2365);
    goto Exit;
  } else {

  }
  i = (u8 )((int )i + 1);
  ldv_39277: ;
  if ((int )i < (int )len) {
    goto ldv_39276;
  } else {

  }

  Exit: 
  vfree((void const   *)buf);
  retval = card_power_off(chip, 128);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_scsi.c",
                "write_efuse", 2375);
    return (3);
  } else {

  }
  if (chip->asic_code != 0) {
    retval = rtsx_write_register(chip, 65141, 6, 6);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_scsi.c",
                  "write_efuse", 2383);
      return (3);
    } else {

    }
    tmp___22 = get_current();
    tmp___22->task_state_change = 0UL;
    __ret___3 = 1L;
    switch (8UL) {
    case 1UL: 
    tmp___23 = get_current();
    __asm__  volatile   ("xchgb %b0, %1\n": "+q" (__ret___3), "+m" (tmp___23->state): : "memory",
                         "cc");
    goto ldv_39281;
    case 2UL: 
    tmp___24 = get_current();
    __asm__  volatile   ("xchgw %w0, %1\n": "+r" (__ret___3), "+m" (tmp___24->state): : "memory",
                         "cc");
    goto ldv_39281;
    case 4UL: 
    tmp___25 = get_current();
    __asm__  volatile   ("xchgl %0, %1\n": "+r" (__ret___3), "+m" (tmp___25->state): : "memory",
                         "cc");
    goto ldv_39281;
    case 8UL: 
    tmp___26 = get_current();
    __asm__  volatile   ("xchgq %q0, %1\n": "+r" (__ret___3), "+m" (tmp___26->state): : "memory",
                         "cc");
    goto ldv_39281;
    default: 
    __xchg_wrong_size();
    }
    ldv_39281: 
    schedule_timeout(150L);
    retval = rtsx_write_phy_register(chip, 8, (int )val);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_scsi.c",
                  "write_efuse", 2391);
      return (3);
    } else {

    }
    retval = rtsx_write_register(chip, 65141, 6, 0);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_scsi.c",
                  "write_efuse", 2398);
      return (3);
    } else {

    }
  } else {

  }
  return (result);
}
}
static int read_cfg_byte(struct scsi_cmnd *srb , struct rtsx_chip *chip ) 
{ 
  int retval ;
  bool func_max ;
  u8 func ;
  u16 addr ;
  u16 len ;
  u8 *buf ;
  struct task_struct *tmp ;
  long volatile   __ret ;
  struct task_struct *tmp___0 ;
  struct task_struct *tmp___1 ;
  struct task_struct *tmp___2 ;
  struct task_struct *tmp___3 ;
  struct _ddebug descriptor ;
  struct device *tmp___4 ;
  long tmp___5 ;
  void *tmp___6 ;
  unsigned int __min1 ;
  unsigned int tmp___7 ;
  unsigned int __min2 ;
  unsigned int tmp___8 ;

  {
  rtsx_disable_aspm(chip);
  if (chip->ss_en != 0 && (unsigned int )chip->rtsx_stat == 3U) {
    rtsx_exit_ss(chip);
    tmp = get_current();
    tmp->task_state_change = 0UL;
    __ret = 1L;
    switch (8UL) {
    case 1UL: 
    tmp___0 = get_current();
    __asm__  volatile   ("xchgb %b0, %1\n": "+q" (__ret), "+m" (tmp___0->state): : "memory",
                         "cc");
    goto ldv_39299;
    case 2UL: 
    tmp___1 = get_current();
    __asm__  volatile   ("xchgw %w0, %1\n": "+r" (__ret), "+m" (tmp___1->state): : "memory",
                         "cc");
    goto ldv_39299;
    case 4UL: 
    tmp___2 = get_current();
    __asm__  volatile   ("xchgl %0, %1\n": "+r" (__ret), "+m" (tmp___2->state): : "memory",
                         "cc");
    goto ldv_39299;
    case 8UL: 
    tmp___3 = get_current();
    __asm__  volatile   ("xchgq %q0, %1\n": "+r" (__ret), "+m" (tmp___3->state): : "memory",
                         "cc");
    goto ldv_39299;
    default: 
    __xchg_wrong_size();
    }
    ldv_39299: 
    schedule_timeout(25L);
  } else {

  }
  chip->idle_counter = 0;
  chip->rtsx_stat = 2;
  func = *(srb->cmnd + 3UL);
  addr = (u16 )((int )((short )((int )*(srb->cmnd + 4UL) << 8)) | (int )((short )*(srb->cmnd + 5UL)));
  len = (u16 )((int )((short )((int )*(srb->cmnd + 6UL) << 8)) | (int )((short )*(srb->cmnd + 7UL)));
  descriptor.modname = "rts5208";
  descriptor.function = "read_cfg_byte";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_scsi.c";
  descriptor.format = "%s: func = %d, addr = 0x%x, len = %d\n";
  descriptor.lineno = 2427U;
  descriptor.flags = 0U;
  tmp___5 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp___5 != 0L) {
    tmp___4 = rtsx_dev((struct rtsx_chip  const  *)chip);
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)tmp___4, "%s: func = %d, addr = 0x%x, len = %d\n",
                      "read_cfg_byte", (int )func, (int )addr, (int )len);
  } else {

  }
  if (chip->sdio_func_exist & 1 && (chip->sdio_func_exist & 2) == 0) {
    func_max = 1;
  } else {
    func_max = 0;
  }
  if ((int )func > (int )func_max) {
    set_sense_type(chip, (unsigned int )(srb->device)->lun, 6);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_scsi.c",
                "read_cfg_byte", 2437);
    return (1);
  } else {

  }
  tmp___6 = vmalloc((unsigned long )len);
  buf = (u8 *)tmp___6;
  if ((unsigned long )buf == (unsigned long )((u8 *)0U)) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_scsi.c",
                "read_cfg_byte", 2443);
    return (3);
  } else {

  }
  retval = rtsx_read_cfg_seq(chip, (int )func, (int )addr, buf, (int )len);
  if (retval != 0) {
    set_sense_type(chip, (unsigned int )(srb->device)->lun, 7);
    vfree((void const   *)buf);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_scsi.c",
                "read_cfg_byte", 2452);
    return (1);
  } else {

  }
  tmp___7 = scsi_bufflen(srb);
  __min1 = tmp___7;
  __min2 = (unsigned int )len;
  len = (unsigned short )(__min1 < __min2 ? __min1 : __min2);
  rtsx_stor_set_xfer_buf(buf, (unsigned int )len, srb);
  tmp___8 = scsi_bufflen(srb);
  scsi_set_resid(srb, (int )(tmp___8 - (unsigned int )len));
  vfree((void const   *)buf);
  return (0);
}
}
static int write_cfg_byte(struct scsi_cmnd *srb , struct rtsx_chip *chip ) 
{ 
  int retval ;
  bool func_max ;
  u8 func ;
  u16 addr ;
  u16 len ;
  u8 *buf ;
  struct task_struct *tmp ;
  long volatile   __ret ;
  struct task_struct *tmp___0 ;
  struct task_struct *tmp___1 ;
  struct task_struct *tmp___2 ;
  struct task_struct *tmp___3 ;
  struct _ddebug descriptor ;
  struct device *tmp___4 ;
  long tmp___5 ;
  unsigned int __min1 ;
  unsigned int tmp___6 ;
  unsigned int __min2 ;
  void *tmp___7 ;
  unsigned int tmp___8 ;

  {
  rtsx_disable_aspm(chip);
  if (chip->ss_en != 0 && (unsigned int )chip->rtsx_stat == 3U) {
    rtsx_exit_ss(chip);
    tmp = get_current();
    tmp->task_state_change = 0UL;
    __ret = 1L;
    switch (8UL) {
    case 1UL: 
    tmp___0 = get_current();
    __asm__  volatile   ("xchgb %b0, %1\n": "+q" (__ret), "+m" (tmp___0->state): : "memory",
                         "cc");
    goto ldv_39322;
    case 2UL: 
    tmp___1 = get_current();
    __asm__  volatile   ("xchgw %w0, %1\n": "+r" (__ret), "+m" (tmp___1->state): : "memory",
                         "cc");
    goto ldv_39322;
    case 4UL: 
    tmp___2 = get_current();
    __asm__  volatile   ("xchgl %0, %1\n": "+r" (__ret), "+m" (tmp___2->state): : "memory",
                         "cc");
    goto ldv_39322;
    case 8UL: 
    tmp___3 = get_current();
    __asm__  volatile   ("xchgq %q0, %1\n": "+r" (__ret), "+m" (tmp___3->state): : "memory",
                         "cc");
    goto ldv_39322;
    default: 
    __xchg_wrong_size();
    }
    ldv_39322: 
    schedule_timeout(25L);
  } else {

  }
  chip->idle_counter = 0;
  chip->rtsx_stat = 2;
  func = *(srb->cmnd + 3UL);
  addr = (u16 )((int )((short )((int )*(srb->cmnd + 4UL) << 8)) | (int )((short )*(srb->cmnd + 5UL)));
  len = (u16 )((int )((short )((int )*(srb->cmnd + 6UL) << 8)) | (int )((short )*(srb->cmnd + 7UL)));
  descriptor.modname = "rts5208";
  descriptor.function = "write_cfg_byte";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_scsi.c";
  descriptor.format = "%s: func = %d, addr = 0x%x\n";
  descriptor.lineno = 2486U;
  descriptor.flags = 0U;
  tmp___5 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp___5 != 0L) {
    tmp___4 = rtsx_dev((struct rtsx_chip  const  *)chip);
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)tmp___4, "%s: func = %d, addr = 0x%x\n",
                      "write_cfg_byte", (int )func, (int )addr);
  } else {

  }
  if (chip->sdio_func_exist & 1 && (chip->sdio_func_exist & 2) == 0) {
    func_max = 1;
  } else {
    func_max = 0;
  }
  if ((int )func > (int )func_max) {
    set_sense_type(chip, (unsigned int )(srb->device)->lun, 6);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_scsi.c",
                "write_cfg_byte", 2496);
    return (1);
  } else {

  }
  tmp___6 = scsi_bufflen(srb);
  __min1 = tmp___6;
  __min2 = (unsigned int )len;
  len = (unsigned short )(__min1 < __min2 ? __min1 : __min2);
  tmp___7 = vmalloc((unsigned long )len);
  buf = (u8 *)tmp___7;
  if ((unsigned long )buf == (unsigned long )((u8 *)0U)) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_scsi.c",
                "write_cfg_byte", 2503);
    return (3);
  } else {

  }
  rtsx_stor_get_xfer_buf(buf, (unsigned int )len, srb);
  tmp___8 = scsi_bufflen(srb);
  scsi_set_resid(srb, (int )(tmp___8 - (unsigned int )len));
  retval = rtsx_write_cfg_seq(chip, (int )func, (int )addr, buf, (int )len);
  if (retval != 0) {
    set_sense_type(chip, (unsigned int )(srb->device)->lun, 8);
    vfree((void const   *)buf);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_scsi.c",
                "write_cfg_byte", 2514);
    return (1);
  } else {

  }
  vfree((void const   *)buf);
  return (0);
}
}
static int app_cmd(struct scsi_cmnd *srb , struct rtsx_chip *chip ) 
{ 
  int result ;

  {
  switch ((int )*(srb->cmnd + 2UL)) {
  case 26: ;
  case 10: 
  result = read_write(srb, chip);
  goto ldv_39340;
  case 29: 
  result = read_host_reg(srb, chip);
  goto ldv_39340;
  case 13: 
  result = write_host_reg(srb, chip);
  goto ldv_39340;
  case 21: 
  result = get_variable(srb, chip);
  goto ldv_39340;
  case 5: 
  result = set_variable(srb, chip);
  goto ldv_39340;
  case 22: ;
  case 6: 
  result = dma_access_ring_buffer(srb, chip);
  goto ldv_39340;
  case 23: 
  result = read_phy_register(srb, chip);
  goto ldv_39340;
  case 7: 
  result = write_phy_register(srb, chip);
  goto ldv_39340;
  case 35: 
  result = erase_eeprom2(srb, chip);
  goto ldv_39340;
  case 19: 
  result = read_eeprom2(srb, chip);
  goto ldv_39340;
  case 3: 
  result = write_eeprom2(srb, chip);
  goto ldv_39340;
  case 20: 
  result = read_efuse(srb, chip);
  goto ldv_39340;
  case 4: 
  result = write_efuse(srb, chip);
  goto ldv_39340;
  case 30: 
  result = read_cfg_byte(srb, chip);
  goto ldv_39340;
  case 14: 
  result = write_cfg_byte(srb, chip);
  goto ldv_39340;
  case 39: 
  result = set_chip_mode(srb, chip);
  goto ldv_39340;
  case 224: 
  result = suit_cmd(srb, chip);
  goto ldv_39340;
  case 16: 
  result = get_dev_status(srb, chip);
  goto ldv_39340;
  default: 
  set_sense_type(chip, (unsigned int )(srb->device)->lun, 6);
  _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_scsi.c",
              "app_cmd", 2605);
  return (1);
  }
  ldv_39340: ;
  return (result);
}
}
static int read_status(struct scsi_cmnd *srb , struct rtsx_chip *chip ) 
{ 
  u8 rtsx_status[16U] ;
  int buf_len ;
  unsigned int lun ;
  int tmp ;
  int tmp___0 ;
  struct sd_info *sd_card ;
  struct ms_info *ms_card ;
  u8 tmp___1 ;
  u8 tmp___2 ;
  u8 tmp___3 ;
  unsigned int __min1 ;
  unsigned int tmp___4 ;
  unsigned int __min2 ;
  unsigned int tmp___5 ;

  {
  lun = (unsigned int )(srb->device)->lun;
  rtsx_status[0] = (unsigned char )((int )chip->vendor_id >> 8);
  rtsx_status[1] = (unsigned char )chip->vendor_id;
  rtsx_status[2] = (unsigned char )((int )chip->product_id >> 8);
  rtsx_status[3] = (unsigned char )chip->product_id;
  rtsx_status[4] = (unsigned char )lun;
  if ((unsigned int )chip->lun_mode == 1U) {
    if ((unsigned int )chip->lun2card[lun] == 4U) {
      rtsx_status[5] = 2U;
    } else {
      rtsx_status[5] = 3U;
    }
  } else
  if ((unsigned int )chip->card_exist != 0U) {
    if (((int )chip->card_exist & 16) != 0) {
      rtsx_status[5] = 4U;
    } else
    if (((int )chip->card_exist & 4) != 0) {
      rtsx_status[5] = 2U;
    } else
    if (((int )chip->card_exist & 8) != 0) {
      rtsx_status[5] = 3U;
    } else {
      rtsx_status[5] = 7U;
    }
  } else {
    rtsx_status[5] = 7U;
  }
  if ((unsigned int )chip->lun_mode == 1U) {
    rtsx_status[6] = 2U;
  } else {
    rtsx_status[6] = 1U;
  }
  rtsx_status[7] = (unsigned char )chip->product_id;
  rtsx_status[8] = chip->ic_version;
  tmp = check_card_exist(chip, lun);
  if (tmp != 0) {
    rtsx_status[9] = 1U;
  } else {
    rtsx_status[9] = 0U;
  }
  if ((unsigned int )chip->lun_mode == 1U) {
    rtsx_status[10] = 0U;
  } else {
    rtsx_status[10] = 1U;
  }
  if ((unsigned int )chip->lun_mode == 1U) {
    if ((unsigned int )chip->lun2card[lun] == 4U) {
      rtsx_status[11] = 4U;
    } else {
      rtsx_status[11] = 8U;
    }
  } else {
    rtsx_status[11] = 28U;
  }
  tmp___0 = check_card_ready(chip, lun);
  if (tmp___0 != 0) {
    rtsx_status[12] = 1U;
  } else {
    rtsx_status[12] = 0U;
  }
  tmp___3 = get_lun_card(chip, lun);
  if ((unsigned int )tmp___3 == 16U) {
    rtsx_status[13] = 64U;
  } else {
    tmp___2 = get_lun_card(chip, lun);
    if ((unsigned int )tmp___2 == 4U) {
      sd_card = & chip->sd_card;
      rtsx_status[13] = 32U;
      if (((int )sd_card->sd_type & 255) == 0) {
        if (((int )sd_card->sd_type & 255) == 0 && ((int )sd_card->sd_type & 4096) != 0) {
          rtsx_status[13] = (u8 )((unsigned int )rtsx_status[13] | 4U);
        } else {

        }
        if (((int )sd_card->sd_type & 255) == 0 && ((int )sd_card->sd_type & 256) != 0) {
          rtsx_status[13] = (u8 )((unsigned int )rtsx_status[13] | 2U);
        } else {

        }
      } else {
        rtsx_status[13] = (u8 )((unsigned int )rtsx_status[13] | 8U);
        if (((int )sd_card->sd_type & 255) == 1 && ((int )sd_card->sd_type & 512) != 0) {
          rtsx_status[13] = (u8 )((unsigned int )rtsx_status[13] | 2U);
        } else {

        }
        if (((int )sd_card->sd_type & 255) == 1 && ((int )sd_card->sd_type & 4096) != 0) {
          rtsx_status[13] = (u8 )((unsigned int )rtsx_status[13] | 4U);
        } else {

        }
      }
    } else {
      tmp___1 = get_lun_card(chip, lun);
      if ((unsigned int )tmp___1 == 8U) {
        ms_card = & chip->ms_card;
        if (((int )ms_card->ms_type & 255) == 1) {
          rtsx_status[13] = 56U;
          if (((int )ms_card->ms_type & 255) == 1 && ((int )ms_card->ms_type & 1536) == 1536) {
            rtsx_status[13] = (u8 )((unsigned int )rtsx_status[13] | 4U);
          } else {

          }
          if (((int )ms_card->ms_type & 255) == 1 && ((int )ms_card->ms_type & 2048) != 0) {
            rtsx_status[13] = (u8 )((unsigned int )rtsx_status[13] | 1U);
          } else {

          }
        } else {
          rtsx_status[13] = 48U;
        }
      } else
      if ((unsigned int )chip->lun_mode == 0U) {
        rtsx_status[13] = 112U;
      } else
      if ((unsigned int )chip->lun2card[lun] == 4U) {
        rtsx_status[13] = 32U;
      } else {
        rtsx_status[13] = 48U;
      }
    }
  }
  rtsx_status[14] = 120U;
  if (chip->sdio_func_exist & 1 && (chip->sdio_func_exist & 2) == 0) {
    rtsx_status[15] = 131U;
  } else {
    rtsx_status[15] = 130U;
  }
  tmp___4 = scsi_bufflen(srb);
  __min1 = tmp___4;
  __min2 = 16U;
  buf_len = (int )(__min1 < __min2 ? __min1 : __min2);
  rtsx_stor_set_xfer_buf((unsigned char *)(& rtsx_status), (unsigned int )buf_len,
                         srb);
  tmp___5 = scsi_bufflen(srb);
  scsi_set_resid(srb, (int )(tmp___5 - (unsigned int )buf_len));
  return (0);
}
}
static int get_card_bus_width(struct scsi_cmnd *srb , struct rtsx_chip *chip ) 
{ 
  unsigned int lun ;
  u8 card ;
  u8 bus_width ;
  int tmp ;
  unsigned int tmp___0 ;

  {
  lun = (unsigned int )(srb->device)->lun;
  tmp = check_card_ready(chip, lun);
  if (tmp == 0) {
    set_sense_type(chip, lun, 2);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_scsi.c",
                "get_card_bus_width", 2749);
    return (1);
  } else {

  }
  card = get_lun_card(chip, lun);
  if ((unsigned int )card == 4U || (unsigned int )card == 8U) {
    bus_width = chip->card_bus_width[lun];
  } else {
    set_sense_type(chip, lun, 7);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_scsi.c",
                "get_card_bus_width", 2758);
    return (1);
  }
  scsi_set_resid(srb, 0);
  tmp___0 = scsi_bufflen(srb);
  rtsx_stor_set_xfer_buf(& bus_width, tmp___0, srb);
  return (0);
}
}
static int spi_vendor_cmd(struct scsi_cmnd *srb , struct rtsx_chip *chip ) 
{ 
  int result ;
  unsigned int lun ;
  u8 gpio_dir ;
  struct task_struct *tmp ;
  long volatile   __ret ;
  struct task_struct *tmp___0 ;
  struct task_struct *tmp___1 ;
  struct task_struct *tmp___2 ;
  struct task_struct *tmp___3 ;

  {
  lun = (unsigned int )(srb->device)->lun;
  if ((unsigned int )chip->product_id == 21000U || (unsigned int )chip->product_id == 21128U) {
    set_sense_type(chip, lun, 6);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_scsi.c",
                "spi_vendor_cmd", 2776);
    return (1);
  } else {

  }
  rtsx_disable_aspm(chip);
  if (chip->ss_en != 0 && (unsigned int )chip->rtsx_stat == 3U) {
    rtsx_exit_ss(chip);
    tmp = get_current();
    tmp->task_state_change = 0UL;
    __ret = 1L;
    switch (8UL) {
    case 1UL: 
    tmp___0 = get_current();
    __asm__  volatile   ("xchgb %b0, %1\n": "+q" (__ret), "+m" (tmp___0->state): : "memory",
                         "cc");
    goto ldv_39391;
    case 2UL: 
    tmp___1 = get_current();
    __asm__  volatile   ("xchgw %w0, %1\n": "+r" (__ret), "+m" (tmp___1->state): : "memory",
                         "cc");
    goto ldv_39391;
    case 4UL: 
    tmp___2 = get_current();
    __asm__  volatile   ("xchgl %0, %1\n": "+r" (__ret), "+m" (tmp___2->state): : "memory",
                         "cc");
    goto ldv_39391;
    case 8UL: 
    tmp___3 = get_current();
    __asm__  volatile   ("xchgq %q0, %1\n": "+r" (__ret), "+m" (tmp___3->state): : "memory",
                         "cc");
    goto ldv_39391;
    default: 
    __xchg_wrong_size();
    }
    ldv_39391: 
    schedule_timeout(25L);
  } else {

  }
  chip->idle_counter = 0;
  chip->rtsx_stat = 2;
  rtsx_force_power_on(chip, 1);
  rtsx_read_register(chip, 64855, & gpio_dir);
  rtsx_write_register(chip, 64855, 7, (int )gpio_dir & 6);
  switch ((int )*(srb->cmnd + 2UL)) {
  case 0: 
  result = spi_get_status(srb, chip);
  goto ldv_39398;
  case 1: 
  result = spi_set_parameter(srb, chip);
  goto ldv_39398;
  case 2: 
  result = spi_read_flash_id(srb, chip);
  goto ldv_39398;
  case 3: 
  result = spi_read_flash(srb, chip);
  goto ldv_39398;
  case 4: 
  result = spi_write_flash(srb, chip);
  goto ldv_39398;
  case 5: 
  result = spi_write_flash_status(srb, chip);
  goto ldv_39398;
  case 6: 
  result = spi_erase_flash(srb, chip);
  goto ldv_39398;
  default: 
  rtsx_write_register(chip, 64855, 7, (int )gpio_dir);
  set_sense_type(chip, lun, 6);
  _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_scsi.c",
              "spi_vendor_cmd", 2826);
  return (1);
  }
  ldv_39398: 
  rtsx_write_register(chip, 64855, 7, (int )gpio_dir);
  if (result != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_scsi.c",
                "spi_vendor_cmd", 2833);
    return (1);
  } else {

  }
  return (0);
}
}
static int vendor_cmnd(struct scsi_cmnd *srb , struct rtsx_chip *chip ) 
{ 
  int result ;

  {
  switch ((int )*(srb->cmnd + 1UL)) {
  case 9: 
  result = read_status(srb, chip);
  goto ldv_39412;
  case 13: 
  result = read_mem(srb, chip);
  goto ldv_39412;
  case 14: 
  result = write_mem(srb, chip);
  goto ldv_39412;
  case 4: 
  result = read_eeprom(srb, chip);
  goto ldv_39412;
  case 5: 
  result = write_eeprom(srb, chip);
  goto ldv_39412;
  case 21: 
  result = toggle_gpio_cmd(srb, chip);
  goto ldv_39412;
  case 20: 
  result = get_sd_csd(srb, chip);
  goto ldv_39412;
  case 19: 
  result = get_card_bus_width(srb, chip);
  goto ldv_39412;
  case 24: 
  result = trace_msg_cmd(srb, chip);
  goto ldv_39412;
  case 16: 
  result = app_cmd(srb, chip);
  goto ldv_39412;
  case 28: 
  result = spi_vendor_cmd(srb, chip);
  goto ldv_39412;
  default: 
  set_sense_type(chip, (unsigned int )(srb->device)->lun, 6);
  _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_scsi.c",
              "vendor_cmnd", 2894);
  return (1);
  }
  ldv_39412: ;
  return (result);
}
}
static int ms_format_cmnd(struct scsi_cmnd *srb , struct rtsx_chip *chip ) 
{ 
  struct ms_info *ms_card ;
  unsigned int lun ;
  bool quick_format ;
  int retval ;
  u8 tmp ;
  struct task_struct *tmp___0 ;
  long volatile   __ret ;
  struct task_struct *tmp___1 ;
  struct task_struct *tmp___2 ;
  struct task_struct *tmp___3 ;
  struct task_struct *tmp___4 ;
  int tmp___5 ;
  u32 tmp___6 ;

  {
  ms_card = & chip->ms_card;
  lun = (unsigned int )(srb->device)->lun;
  tmp = get_lun_card(chip, lun);
  if ((unsigned int )tmp != 8U) {
    set_sense_type(chip, lun, 4);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_scsi.c",
                "ms_format_cmnd", 2934);
    return (1);
  } else {

  }
  if (((((unsigned int )*(srb->cmnd + 3UL) != 77U || (unsigned int )*(srb->cmnd + 4UL) != 71U) || (unsigned int )*(srb->cmnd + 5UL) != 102U) || (unsigned int )*(srb->cmnd + 6UL) != 109U) || (unsigned int )*(srb->cmnd + 7UL) != 116U) {
    set_sense_type(chip, lun, 6);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_scsi.c",
                "ms_format_cmnd", 2942);
    return (1);
  } else {

  }
  rtsx_disable_aspm(chip);
  if (chip->ss_en != 0 && (unsigned int )chip->rtsx_stat == 3U) {
    rtsx_exit_ss(chip);
    tmp___0 = get_current();
    tmp___0->task_state_change = 0UL;
    __ret = 1L;
    switch (8UL) {
    case 1UL: 
    tmp___1 = get_current();
    __asm__  volatile   ("xchgb %b0, %1\n": "+q" (__ret), "+m" (tmp___1->state): : "memory",
                         "cc");
    goto ldv_39436;
    case 2UL: 
    tmp___2 = get_current();
    __asm__  volatile   ("xchgw %w0, %1\n": "+r" (__ret), "+m" (tmp___2->state): : "memory",
                         "cc");
    goto ldv_39436;
    case 4UL: 
    tmp___3 = get_current();
    __asm__  volatile   ("xchgl %0, %1\n": "+r" (__ret), "+m" (tmp___3->state): : "memory",
                         "cc");
    goto ldv_39436;
    case 8UL: 
    tmp___4 = get_current();
    __asm__  volatile   ("xchgq %q0, %1\n": "+r" (__ret), "+m" (tmp___4->state): : "memory",
                         "cc");
    goto ldv_39436;
    default: 
    __xchg_wrong_size();
    }
    ldv_39436: 
    schedule_timeout(25L);
    tmp___5 = check_card_ready(chip, lun);
    if (tmp___5 == 0) {
      set_sense_type(chip, lun, 2);
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_scsi.c",
                  "ms_format_cmnd", 2955);
      return (1);
    } else {
      tmp___6 = get_card_size(chip, lun);
      if (tmp___6 == 0U) {
        set_sense_type(chip, lun, 2);
        _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_scsi.c",
                    "ms_format_cmnd", 2955);
        return (1);
      } else {

      }
    }
  } else {

  }
  chip->idle_counter = 0;
  chip->rtsx_stat = 2;
  if ((int )*(srb->cmnd + 8UL) & 1) {
    quick_format = 0;
  } else {
    quick_format = 1;
  }
  if (((int )chip->card_ready & 8) == 0) {
    set_sense_type(chip, lun, 2);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_scsi.c",
                "ms_format_cmnd", 2968);
    return (1);
  } else {

  }
  if (((int )chip->card_wp & 8) != 0) {
    set_sense_type(chip, lun, 5);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_scsi.c",
                "ms_format_cmnd", 2974);
    return (1);
  } else {

  }
  if (((int )ms_card->ms_type & 255) != 1) {
    set_sense_type(chip, lun, 4);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_scsi.c",
                "ms_format_cmnd", 2980);
    return (1);
  } else {

  }
  retval = mspro_format(srb, chip, 32, (int )quick_format);
  if (retval != 0) {
    set_sense_type(chip, lun, 10);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_scsi.c",
                "ms_format_cmnd", 2987);
    return (1);
  } else {

  }
  scsi_set_resid(srb, 0);
  return (0);
}
}
static int get_ms_information(struct scsi_cmnd *srb , struct rtsx_chip *chip ) 
{ 
  struct ms_info *ms_card ;
  unsigned int lun ;
  u8 dev_info_id ;
  u8 data_len ;
  u8 *buf ;
  unsigned int buf_len ;
  int i ;
  int tmp ;
  u8 tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  unsigned int tmp___15 ;
  unsigned int tmp___16 ;

  {
  ms_card = & chip->ms_card;
  lun = (unsigned int )(srb->device)->lun;
  tmp = check_card_ready(chip, lun);
  if (tmp == 0) {
    set_sense_type(chip, lun, 2);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_scsi.c",
                "get_ms_information", 3007);
    return (1);
  } else {

  }
  tmp___0 = get_lun_card(chip, lun);
  if ((unsigned int )tmp___0 != 8U) {
    set_sense_type(chip, lun, 4);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_scsi.c",
                "get_ms_information", 3012);
    return (1);
  } else {

  }
  if (((((unsigned int )*(srb->cmnd + 2UL) != 176U || (unsigned int )*(srb->cmnd + 4UL) != 77U) || (unsigned int )*(srb->cmnd + 5UL) != 83U) || (unsigned int )*(srb->cmnd + 6UL) != 73U) || (unsigned int )*(srb->cmnd + 7UL) != 68U) {
    set_sense_type(chip, lun, 6);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_scsi.c",
                "get_ms_information", 3020);
    return (1);
  } else {

  }
  dev_info_id = *(srb->cmnd + 3UL);
  if ((((((int )ms_card->ms_type & 255) == 1 && ((int )ms_card->ms_type & 2048) != 0) && (unsigned int )dev_info_id == 16U) || ((((int )ms_card->ms_type & 255) != 1 || ((int )ms_card->ms_type & 2048) == 0) && (unsigned int )dev_info_id == 19U)) || ((int )ms_card->ms_type & 255) != 1) {
    set_sense_type(chip, lun, 6);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_scsi.c",
                "get_ms_information", 3029);
    return (1);
  } else {

  }
  if ((unsigned int )dev_info_id == 21U) {
    data_len = 58U;
    buf_len = 58U;
  } else {
    data_len = 106U;
    buf_len = 106U;
  }
  tmp___1 = kmalloc((size_t )buf_len, 208U);
  buf = (u8 *)tmp___1;
  if ((unsigned long )buf == (unsigned long )((u8 *)0U)) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_scsi.c",
                "get_ms_information", 3040);
    return (3);
  } else {

  }
  i = 0;
  tmp___2 = i;
  i = i + 1;
  *(buf + (unsigned long )tmp___2) = 0U;
  tmp___3 = i;
  i = i + 1;
  *(buf + (unsigned long )tmp___3) = data_len;
  if (((int )ms_card->ms_type & 255) == 1 && ((int )ms_card->ms_type & 2048) != 0) {
    tmp___4 = i;
    i = i + 1;
    *(buf + (unsigned long )tmp___4) = 3U;
  } else {
    tmp___5 = i;
    i = i + 1;
    *(buf + (unsigned long )tmp___5) = 2U;
  }
  tmp___6 = i;
  i = i + 1;
  *(buf + (unsigned long )tmp___6) = 1U;
  tmp___7 = i;
  i = i + 1;
  *(buf + (unsigned long )tmp___7) = 0U;
  tmp___8 = i;
  i = i + 1;
  *(buf + (unsigned long )tmp___8) = 0U;
  tmp___9 = i;
  i = i + 1;
  *(buf + (unsigned long )tmp___9) = 0U;
  tmp___10 = i;
  i = i + 1;
  *(buf + (unsigned long )tmp___10) = 1U;
  tmp___11 = i;
  i = i + 1;
  *(buf + (unsigned long )tmp___11) = dev_info_id;
  if ((unsigned int )dev_info_id == 21U) {
    data_len = 49U;
  } else {
    data_len = 97U;
  }
  tmp___12 = i;
  i = i + 1;
  *(buf + (unsigned long )tmp___12) = 0U;
  tmp___13 = i;
  i = i + 1;
  *(buf + (unsigned long )tmp___13) = data_len;
  tmp___14 = i;
  i = i + 1;
  *(buf + (unsigned long )tmp___14) = 128U;
  if ((unsigned int )dev_info_id == 16U || (unsigned int )dev_info_id == 19U) {
    memcpy((void *)buf + (unsigned long )i, (void const   *)(& ms_card->raw_sys_info),
             96UL);
  } else {
    memcpy((void *)buf + (unsigned long )i, (void const   *)(& ms_card->raw_model_name),
             48UL);
  }
  rtsx_stor_set_xfer_buf(buf, buf_len, srb);
  if ((unsigned int )dev_info_id == 21U) {
    tmp___15 = scsi_bufflen(srb);
    scsi_set_resid(srb, (int )(tmp___15 - 60U));
  } else {
    tmp___16 = scsi_bufflen(srb);
    scsi_set_resid(srb, (int )(tmp___16 - 108U));
  }
  kfree((void const   *)buf);
  return (0);
}
}
static int ms_sp_cmnd(struct scsi_cmnd *srb , struct rtsx_chip *chip ) 
{ 
  int retval ;

  {
  retval = 3;
  if ((unsigned int )*(srb->cmnd + 2UL) == 160U) {
    retval = ms_format_cmnd(srb, chip);
  } else
  if ((unsigned int )*(srb->cmnd + 2UL) == 176U) {
    retval = get_ms_information(srb, chip);
  } else {

  }
  return (retval);
}
}
static int sd_extention_cmnd(struct scsi_cmnd *srb , struct rtsx_chip *chip ) 
{ 
  unsigned int lun ;
  int result ;
  struct task_struct *tmp ;
  long volatile   __ret ;
  struct task_struct *tmp___0 ;
  struct task_struct *tmp___1 ;
  struct task_struct *tmp___2 ;
  struct task_struct *tmp___3 ;
  int tmp___4 ;
  u8 tmp___5 ;

  {
  lun = (unsigned int )(srb->device)->lun;
  rtsx_disable_aspm(chip);
  if (chip->ss_en != 0 && (unsigned int )chip->rtsx_stat == 3U) {
    rtsx_exit_ss(chip);
    tmp = get_current();
    tmp->task_state_change = 0UL;
    __ret = 1L;
    switch (8UL) {
    case 1UL: 
    tmp___0 = get_current();
    __asm__  volatile   ("xchgb %b0, %1\n": "+q" (__ret), "+m" (tmp___0->state): : "memory",
                         "cc");
    goto ldv_39467;
    case 2UL: 
    tmp___1 = get_current();
    __asm__  volatile   ("xchgw %w0, %1\n": "+r" (__ret), "+m" (tmp___1->state): : "memory",
                         "cc");
    goto ldv_39467;
    case 4UL: 
    tmp___2 = get_current();
    __asm__  volatile   ("xchgl %0, %1\n": "+r" (__ret), "+m" (tmp___2->state): : "memory",
                         "cc");
    goto ldv_39467;
    case 8UL: 
    tmp___3 = get_current();
    __asm__  volatile   ("xchgq %q0, %1\n": "+r" (__ret), "+m" (tmp___3->state): : "memory",
                         "cc");
    goto ldv_39467;
    default: 
    __xchg_wrong_size();
    }
    ldv_39467: 
    schedule_timeout(25L);
  } else {

  }
  chip->idle_counter = 0;
  chip->rtsx_stat = 2;
  sd_cleanup_work(chip);
  tmp___4 = check_card_ready(chip, lun);
  if (tmp___4 == 0) {
    set_sense_type(chip, lun, 2);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_scsi.c",
                "sd_extention_cmnd", 3129);
    return (1);
  } else {

  }
  tmp___5 = get_lun_card(chip, lun);
  if ((unsigned int )tmp___5 != 4U) {
    set_sense_type(chip, lun, 4);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_scsi.c",
                "sd_extention_cmnd", 3134);
    return (1);
  } else {

  }
  switch ((int )*(srb->cmnd)) {
  case 208: 
  result = sd_pass_thru_mode(srb, chip);
  goto ldv_39475;
  case 209: 
  result = sd_execute_no_data(srb, chip);
  goto ldv_39475;
  case 210: 
  result = sd_execute_read_data(srb, chip);
  goto ldv_39475;
  case 211: 
  result = sd_execute_write_data(srb, chip);
  goto ldv_39475;
  case 212: 
  result = sd_get_cmd_rsp(srb, chip);
  goto ldv_39475;
  case 214: 
  result = sd_hw_rst(srb, chip);
  goto ldv_39475;
  default: 
  set_sense_type(chip, lun, 6);
  _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_scsi.c",
              "sd_extention_cmnd", 3165);
  return (1);
  }
  ldv_39475: ;
  return (result);
}
}
static int mg_report_key(struct scsi_cmnd *srb , struct rtsx_chip *chip ) 
{ 
  struct ms_info *ms_card ;
  unsigned int lun ;
  int retval ;
  u8 key_format ;
  struct task_struct *tmp ;
  long volatile   __ret ;
  struct task_struct *tmp___0 ;
  struct task_struct *tmp___1 ;
  struct task_struct *tmp___2 ;
  struct task_struct *tmp___3 ;
  int tmp___4 ;
  u8 tmp___5 ;
  struct _ddebug descriptor ;
  struct device *tmp___6 ;
  long tmp___7 ;
  unsigned int tmp___8 ;
  unsigned int tmp___9 ;
  unsigned int tmp___10 ;

  {
  ms_card = & chip->ms_card;
  lun = (unsigned int )(srb->device)->lun;
  rtsx_disable_aspm(chip);
  if (chip->ss_en != 0 && (unsigned int )chip->rtsx_stat == 3U) {
    rtsx_exit_ss(chip);
    tmp = get_current();
    tmp->task_state_change = 0UL;
    __ret = 1L;
    switch (8UL) {
    case 1UL: 
    tmp___0 = get_current();
    __asm__  volatile   ("xchgb %b0, %1\n": "+q" (__ret), "+m" (tmp___0->state): : "memory",
                         "cc");
    goto ldv_39492;
    case 2UL: 
    tmp___1 = get_current();
    __asm__  volatile   ("xchgw %w0, %1\n": "+r" (__ret), "+m" (tmp___1->state): : "memory",
                         "cc");
    goto ldv_39492;
    case 4UL: 
    tmp___2 = get_current();
    __asm__  volatile   ("xchgl %0, %1\n": "+r" (__ret), "+m" (tmp___2->state): : "memory",
                         "cc");
    goto ldv_39492;
    case 8UL: 
    tmp___3 = get_current();
    __asm__  volatile   ("xchgq %q0, %1\n": "+r" (__ret), "+m" (tmp___3->state): : "memory",
                         "cc");
    goto ldv_39492;
    default: 
    __xchg_wrong_size();
    }
    ldv_39492: 
    schedule_timeout(25L);
  } else {

  }
  chip->idle_counter = 0;
  chip->rtsx_stat = 2;
  ms_cleanup_work(chip);
  tmp___4 = check_card_ready(chip, lun);
  if (tmp___4 == 0) {
    set_sense_type(chip, lun, 2);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_scsi.c",
                "mg_report_key", 3193);
    return (1);
  } else {

  }
  tmp___5 = get_lun_card(chip, lun);
  if ((unsigned int )tmp___5 != 8U) {
    set_sense_type(chip, lun, 4);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_scsi.c",
                "mg_report_key", 3198);
    return (1);
  } else {

  }
  if ((unsigned int )*(srb->cmnd + 7UL) != 190U) {
    set_sense_type(chip, lun, 6);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_scsi.c",
                "mg_report_key", 3204);
    return (1);
  } else {

  }
  if (((int )ms_card->ms_type & 255) != 1) {
    set_sense_type(chip, lun, 13);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_scsi.c",
                "mg_report_key", 3210);
    return (1);
  } else {

  }
  key_format = (unsigned int )*(srb->cmnd + 10UL) & 63U;
  descriptor.modname = "rts5208";
  descriptor.function = "mg_report_key";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_scsi.c";
  descriptor.format = "key_format = 0x%x\n";
  descriptor.lineno = 3215U;
  descriptor.flags = 0U;
  tmp___7 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp___7 != 0L) {
    tmp___6 = rtsx_dev((struct rtsx_chip  const  *)chip);
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)tmp___6, "key_format = 0x%x\n",
                      (int )key_format);
  } else {

  }
  switch ((int )key_format) {
  case 50: 
  tmp___8 = scsi_bufflen(srb);
  if ((tmp___8 == 1052U && (unsigned int )*(srb->cmnd + 8UL) == 4U) && (unsigned int )*(srb->cmnd + 9UL) == 28U) {
    retval = mg_get_local_EKB(srb, chip);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_scsi.c",
                  "mg_report_key", 3224);
      return (1);
    } else {

    }
  } else {
    set_sense_type(chip, lun, 6);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_scsi.c",
                "mg_report_key", 3231);
    return (1);
  }
  goto ldv_39501;
  case 52: 
  tmp___9 = scsi_bufflen(srb);
  if ((tmp___9 == 36U && (unsigned int )*(srb->cmnd + 8UL) == 0U) && (unsigned int )*(srb->cmnd + 9UL) == 36U) {
    retval = mg_get_rsp_chg(srb, chip);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_scsi.c",
                  "mg_report_key", 3242);
      return (1);
    } else {

    }
  } else {
    set_sense_type(chip, lun, 6);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_scsi.c",
                "mg_report_key", 3249);
    return (1);
  }
  goto ldv_39501;
  case 54: 
  ms_card->mg_entry_num = *(srb->cmnd + 5UL);
  tmp___10 = scsi_bufflen(srb);
  if ((((((tmp___10 == 1028U && (unsigned int )*(srb->cmnd + 8UL) == 4U) && (unsigned int )*(srb->cmnd + 9UL) == 4U) && (unsigned int )*(srb->cmnd + 2UL) == 0U) && (unsigned int )*(srb->cmnd + 3UL) == 0U) && (unsigned int )*(srb->cmnd + 4UL) == 0U) && (unsigned int )*(srb->cmnd + 5UL) <= 31U) {
    retval = mg_get_ICV(srb, chip);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_scsi.c",
                  "mg_report_key", 3265);
      return (1);
    } else {

    }
  } else {
    set_sense_type(chip, lun, 6);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_scsi.c",
                "mg_report_key", 3272);
    return (1);
  }
  goto ldv_39501;
  default: 
  set_sense_type(chip, lun, 6);
  _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_scsi.c",
              "mg_report_key", 3279);
  return (1);
  }
  ldv_39501: 
  scsi_set_resid(srb, 0);
  return (0);
}
}
static int mg_send_key(struct scsi_cmnd *srb , struct rtsx_chip *chip ) 
{ 
  struct ms_info *ms_card ;
  unsigned int lun ;
  int retval ;
  u8 key_format ;
  struct task_struct *tmp ;
  long volatile   __ret ;
  struct task_struct *tmp___0 ;
  struct task_struct *tmp___1 ;
  struct task_struct *tmp___2 ;
  struct task_struct *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  u8 tmp___6 ;
  struct _ddebug descriptor ;
  struct device *tmp___7 ;
  long tmp___8 ;
  unsigned int tmp___9 ;
  unsigned int tmp___10 ;
  unsigned int tmp___11 ;
  unsigned int tmp___12 ;

  {
  ms_card = & chip->ms_card;
  lun = (unsigned int )(srb->device)->lun;
  rtsx_disable_aspm(chip);
  if (chip->ss_en != 0 && (unsigned int )chip->rtsx_stat == 3U) {
    rtsx_exit_ss(chip);
    tmp = get_current();
    tmp->task_state_change = 0UL;
    __ret = 1L;
    switch (8UL) {
    case 1UL: 
    tmp___0 = get_current();
    __asm__  volatile   ("xchgb %b0, %1\n": "+q" (__ret), "+m" (tmp___0->state): : "memory",
                         "cc");
    goto ldv_39515;
    case 2UL: 
    tmp___1 = get_current();
    __asm__  volatile   ("xchgw %w0, %1\n": "+r" (__ret), "+m" (tmp___1->state): : "memory",
                         "cc");
    goto ldv_39515;
    case 4UL: 
    tmp___2 = get_current();
    __asm__  volatile   ("xchgl %0, %1\n": "+r" (__ret), "+m" (tmp___2->state): : "memory",
                         "cc");
    goto ldv_39515;
    case 8UL: 
    tmp___3 = get_current();
    __asm__  volatile   ("xchgq %q0, %1\n": "+r" (__ret), "+m" (tmp___3->state): : "memory",
                         "cc");
    goto ldv_39515;
    default: 
    __xchg_wrong_size();
    }
    ldv_39515: 
    schedule_timeout(25L);
  } else {

  }
  chip->idle_counter = 0;
  chip->rtsx_stat = 2;
  ms_cleanup_work(chip);
  tmp___4 = check_card_ready(chip, lun);
  if (tmp___4 == 0) {
    set_sense_type(chip, lun, 2);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_scsi.c",
                "mg_send_key", 3306);
    return (1);
  } else {

  }
  tmp___5 = check_card_wp(chip, lun);
  if (tmp___5 != 0) {
    set_sense_type(chip, lun, 5);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_scsi.c",
                "mg_send_key", 3311);
    return (1);
  } else {

  }
  tmp___6 = get_lun_card(chip, lun);
  if ((unsigned int )tmp___6 != 8U) {
    set_sense_type(chip, lun, 4);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_scsi.c",
                "mg_send_key", 3316);
    return (1);
  } else {

  }
  if ((unsigned int )*(srb->cmnd + 7UL) != 190U) {
    set_sense_type(chip, lun, 6);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_scsi.c",
                "mg_send_key", 3322);
    return (1);
  } else {

  }
  if (((int )ms_card->ms_type & 255) != 1) {
    set_sense_type(chip, lun, 13);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_scsi.c",
                "mg_send_key", 3328);
    return (1);
  } else {

  }
  key_format = (unsigned int )*(srb->cmnd + 10UL) & 63U;
  descriptor.modname = "rts5208";
  descriptor.function = "mg_send_key";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_scsi.c";
  descriptor.format = "key_format = 0x%x\n";
  descriptor.lineno = 3333U;
  descriptor.flags = 0U;
  tmp___8 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp___8 != 0L) {
    tmp___7 = rtsx_dev((struct rtsx_chip  const  *)chip);
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)tmp___7, "key_format = 0x%x\n",
                      (int )key_format);
  } else {

  }
  switch ((int )key_format) {
  case 49: 
  tmp___9 = scsi_bufflen(srb);
  if ((tmp___9 == 12U && (unsigned int )*(srb->cmnd + 8UL) == 0U) && (unsigned int )*(srb->cmnd + 9UL) == 12U) {
    retval = mg_set_leaf_id(srb, chip);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_scsi.c",
                  "mg_send_key", 3342);
      return (1);
    } else {

    }
  } else {
    set_sense_type(chip, lun, 6);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_scsi.c",
                "mg_send_key", 3349);
    return (1);
  }
  goto ldv_39524;
  case 51: 
  tmp___10 = scsi_bufflen(srb);
  if ((tmp___10 == 12U && (unsigned int )*(srb->cmnd + 8UL) == 0U) && (unsigned int )*(srb->cmnd + 9UL) == 12U) {
    retval = mg_chg(srb, chip);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_scsi.c",
                  "mg_send_key", 3360);
      return (1);
    } else {

    }
  } else {
    set_sense_type(chip, lun, 6);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_scsi.c",
                "mg_send_key", 3367);
    return (1);
  }
  goto ldv_39524;
  case 53: 
  tmp___11 = scsi_bufflen(srb);
  if ((tmp___11 == 12U && (unsigned int )*(srb->cmnd + 8UL) == 0U) && (unsigned int )*(srb->cmnd + 9UL) == 12U) {
    retval = mg_rsp(srb, chip);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_scsi.c",
                  "mg_send_key", 3378);
      return (1);
    } else {

    }
  } else {
    set_sense_type(chip, lun, 6);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_scsi.c",
                "mg_send_key", 3385);
    return (1);
  }
  goto ldv_39524;
  case 55: 
  ms_card->mg_entry_num = *(srb->cmnd + 5UL);
  tmp___12 = scsi_bufflen(srb);
  if ((((((tmp___12 == 1028U && (unsigned int )*(srb->cmnd + 8UL) == 4U) && (unsigned int )*(srb->cmnd + 9UL) == 4U) && (unsigned int )*(srb->cmnd + 2UL) == 0U) && (unsigned int )*(srb->cmnd + 3UL) == 0U) && (unsigned int )*(srb->cmnd + 4UL) == 0U) && (unsigned int )*(srb->cmnd + 5UL) <= 31U) {
    retval = mg_set_ICV(srb, chip);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_scsi.c",
                  "mg_send_key", 3401);
      return (1);
    } else {

    }
  } else {
    set_sense_type(chip, lun, 6);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_scsi.c",
                "mg_send_key", 3408);
    return (1);
  }
  goto ldv_39524;
  default: 
  set_sense_type(chip, lun, 6);
  _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_scsi.c",
              "mg_send_key", 3415);
  return (1);
  }
  ldv_39524: 
  scsi_set_resid(srb, 0);
  return (0);
}
}
int rtsx_scsi_handler(struct scsi_cmnd *srb , struct rtsx_chip *chip ) 
{ 
  struct sd_info *sd_card ;
  struct ms_info *ms_card ;
  unsigned int lun ;
  int result ;
  u8 tmp ;

  {
  sd_card = & chip->sd_card;
  ms_card = & chip->ms_card;
  lun = (unsigned int )(srb->device)->lun;
  if ((unsigned int )sd_card->sd_erase_status != 0U) {
    if ((((unsigned int )*(srb->cmnd) != 240U || (unsigned int )*(srb->cmnd + 1UL) != 16U) || (unsigned int )*(srb->cmnd + 2UL) != 16U) && (unsigned int )*(srb->cmnd) != 3U) {
      set_sense_data(chip, lun, 112, 2, 0U, 4, 4, 0, 0);
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_scsi.c",
                  "rtsx_scsi_handler", 3445);
      return (1);
    } else {

    }
  } else {

  }
  tmp = get_lun_card(chip, lun);
  if ((unsigned int )tmp == 8U && ms_card->format_status == 2) {
    if ((unsigned int )*(srb->cmnd) != 3U && (unsigned int )*(srb->cmnd) != 18U) {
      set_sense_data(chip, lun, 112, 2, 0U, 4, 4, 0, (int )ms_card->progress);
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_scsi.c",
                  "rtsx_scsi_handler", 3458);
      return (1);
    } else {

    }
  } else {

  }
  switch ((int )*(srb->cmnd)) {
  case 40: ;
  case 42: ;
  case 8: ;
  case 10: 
  result = read_write(srb, chip);
  goto ldv_39542;
  case 0: 
  result = test_unit_ready(srb, chip);
  goto ldv_39542;
  case 18: 
  result = inquiry(srb, chip);
  goto ldv_39542;
  case 37: 
  result = read_capacity(srb, chip);
  goto ldv_39542;
  case 27: 
  result = start_stop_unit(srb, chip);
  goto ldv_39542;
  case 30: 
  result = allow_medium_removal(srb, chip);
  goto ldv_39542;
  case 3: 
  result = request_sense(srb, chip);
  goto ldv_39542;
  case 26: ;
  case 90: 
  result = mode_sense(srb, chip);
  goto ldv_39542;
  case 35: 
  result = read_format_capacity(srb, chip);
  goto ldv_39542;
  case 240: 
  result = vendor_cmnd(srb, chip);
  goto ldv_39542;
  case 250: 
  result = ms_sp_cmnd(srb, chip);
  goto ldv_39542;
  case 208: ;
  case 209: ;
  case 210: ;
  case 211: ;
  case 212: ;
  case 214: 
  result = sd_extention_cmnd(srb, chip);
  goto ldv_39542;
  case 164: 
  result = mg_report_key(srb, chip);
  goto ldv_39542;
  case 163: 
  result = mg_send_key(srb, chip);
  goto ldv_39542;
  case 4: ;
  case 21: ;
  case 47: 
  result = 0;
  goto ldv_39542;
  default: 
  set_sense_type(chip, lun, 6);
  result = 1;
  }
  ldv_39542: ;
  return (result);
}
}
void ldv_mutex_lock_117(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_lock_lock(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_118(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_unlock_lock(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_119(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
int ldv_mutex_trylock_120(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
  tmp = mutex_trylock(ldv_func_arg1);
  ldv_func_res = tmp;
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
  return (tmp___0);
  return (ldv_func_res);
}
}
void ldv_mutex_unlock_121(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_122(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_unlock_i_mutex_of_inode(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_123(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_lock_i_mutex_of_inode(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
int ldv_scsi_add_host_with_dma_124(struct Scsi_Host *shost , struct device *dev ,
                                   struct device *dma_dev ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  int tmp ;

  {
  tmp = scsi_add_host_with_dma(shost, dev, dma_dev);
  ldv_func_res = tmp;
  if (ldv_func_res == 0) {
    ldv_state_variable_3 = 1;
    ldv_initialize_scsi_host_template_3();
  } else {

  }
  return (ldv_func_res);
}
}
__inline static long ldv__builtin_expect(long exp , long c ) ;
extern int memcmp(void const   * , void const   * , size_t  ) ;
int ldv_mutex_trylock_140(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_138(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_141(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_142(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_137(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_139(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_143(struct mutex *ldv_func_arg1 ) ;
int ldv_scsi_add_host_with_dma_144(struct Scsi_Host *shost , struct device *dev ,
                                   struct device *dma_dev ) ;
int reset_sd_card(struct rtsx_chip *chip ) ;
int sd_rw(struct scsi_cmnd *srb , struct rtsx_chip *chip , u32 start_sector , u16 sector_cnt ) ;
int release_sd_card(struct rtsx_chip *chip ) ;
void do_reset_sd_card(struct rtsx_chip *chip ) ;
void do_reset_xd_card(struct rtsx_chip *chip ) ;
void do_reset_ms_card(struct rtsx_chip *chip ) ;
int switch_ssc_clock(struct rtsx_chip *chip , int clk ) ;
int switch_normal_clock(struct rtsx_chip *chip , int clk ) ;
int enable_card_clock(struct rtsx_chip *chip , u8 card ) ;
int disable_card_clock(struct rtsx_chip *chip , u8 card ) ;
void trans_dma_enable(enum dma_data_direction dir , struct rtsx_chip *chip , u32 byte_cnt ,
                      u8 pack_size ) ;
void turn_on_led(struct rtsx_chip *chip , u8 gpio ) ;
int select_card(struct rtsx_chip *chip , int card ) ;
int detect_card_cd(struct rtsx_chip *chip , int card ) ;
int check_card_fail(struct rtsx_chip *chip , unsigned int lun ) ;
int check_card_ejected(struct rtsx_chip *chip , unsigned int lun ) ;
int reset_xd_card(struct rtsx_chip *chip ) ;
int xd_rw(struct scsi_cmnd *srb , struct rtsx_chip *chip , u32 start_sector , u16 sector_cnt ) ;
void xd_cleanup_work(struct rtsx_chip *chip ) ;
int release_xd_card(struct rtsx_chip *chip ) ;
int reset_ms_card(struct rtsx_chip *chip ) ;
int ms_rw(struct scsi_cmnd *srb , struct rtsx_chip *chip , u32 start_sector , u16 sector_cnt ) ;
int release_ms_card(struct rtsx_chip *chip ) ;
void do_remaining_work(struct rtsx_chip *chip ) 
{ 
  struct sd_info *sd_card ;
  struct xd_info *xd_card ;
  struct ms_info *ms_card ;

  {
  sd_card = & chip->sd_card;
  xd_card = & chip->xd_card;
  ms_card = & chip->ms_card;
  if (((int )chip->card_ready & 4) != 0) {
    if (sd_card->seq_mode != 0) {
      chip->idle_counter = 0;
      chip->rtsx_stat = 2;
      sd_card->cleanup_counter = sd_card->cleanup_counter + 1;
    } else {
      sd_card->cleanup_counter = 0;
    }
  } else {

  }
  if (((int )chip->card_ready & 16) != 0) {
    if ((unsigned int )xd_card->delay_write.delay_write_flag != 0U) {
      chip->idle_counter = 0;
      chip->rtsx_stat = 2;
      xd_card->cleanup_counter = xd_card->cleanup_counter + 1;
    } else {
      xd_card->cleanup_counter = 0;
    }
  } else {

  }
  if (((int )chip->card_ready & 8) != 0) {
    if (((int )ms_card->ms_type & 255) == 1) {
      if ((unsigned int )ms_card->seq_mode != 0U) {
        chip->idle_counter = 0;
        chip->rtsx_stat = 2;
        ms_card->cleanup_counter = ms_card->cleanup_counter + 1;
      } else {
        ms_card->cleanup_counter = 0;
      }
    } else
    if ((unsigned int )ms_card->delay_write.delay_write_flag != 0U) {
      chip->idle_counter = 0;
      chip->rtsx_stat = 2;
      ms_card->cleanup_counter = ms_card->cleanup_counter + 1;
    } else {
      ms_card->cleanup_counter = 0;
    }
  } else {

  }
  if (sd_card->cleanup_counter > 1) {
    sd_cleanup_work(chip);
  } else {

  }
  if (xd_card->cleanup_counter > 1) {
    xd_cleanup_work(chip);
  } else {

  }
  if (ms_card->cleanup_counter > 1) {
    ms_cleanup_work(chip);
  } else {

  }
  return;
}
}
void try_to_switch_sdio_ctrl(struct rtsx_chip *chip ) 
{ 
  u8 reg1 ;
  u8 reg2 ;
  struct _ddebug descriptor ;
  struct device *tmp ;
  long tmp___0 ;

  {
  reg1 = 0U;
  reg2 = 0U;
  rtsx_read_register(chip, 65332, & reg1);
  rtsx_read_register(chip, 65336, & reg2);
  descriptor.modname = "rts5208";
  descriptor.function = "try_to_switch_sdio_ctrl";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_card.c";
  descriptor.format = "reg 0xFF34: 0x%x, reg 0xFF38: 0x%x\n";
  descriptor.lineno = 99U;
  descriptor.flags = 0U;
  tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp___0 != 0L) {
    tmp = rtsx_dev((struct rtsx_chip  const  *)chip);
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)tmp, "reg 0xFF34: 0x%x, reg 0xFF38: 0x%x\n",
                      (int )reg1, (int )reg2);
  } else {

  }
  if (((int )reg1 & 192) != 0 && ((int )reg2 & 192) != 0) {
    chip->sd_int = 1U;
    rtsx_write_register(chip, 64875, 255, 3);
    rtsx_write_register(chip, 65141, 6, 0);
  } else {

  }
  return;
}
}
void dynamic_configure_sdio_aspm(struct rtsx_chip *chip ) 
{ 
  u8 buf[12U] ;
  u8 reg ;
  int i ;
  int tmp ;
  struct _ddebug descriptor ;
  struct device *tmp___0 ;
  long tmp___1 ;
  struct _ddebug descriptor___0 ;
  struct device *tmp___2 ;
  long tmp___3 ;

  {
  i = 0;
  goto ldv_38369;
  ldv_38368: 
  rtsx_read_register(chip, (int )((unsigned int )((u16 )i) + 65288U), (u8 *)(& buf) + (unsigned long )i);
  i = i + 1;
  ldv_38369: ;
  if (i <= 11) {
    goto ldv_38368;
  } else {

  }
  rtsx_read_register(chip, 65317, & reg);
  tmp = memcmp((void const   *)(& buf), (void const   *)(& chip->sdio_raw_data), 12UL);
  if (tmp != 0 || ((int )reg & 3) != 0) {
    chip->sdio_counter = 0;
    chip->sdio_idle = 0;
  } else
  if (chip->sdio_idle == 0) {
    chip->sdio_counter = chip->sdio_counter + 1;
    if (chip->sdio_counter > 9) {
      chip->sdio_counter = 0;
      chip->sdio_idle = 1;
    } else {

    }
  } else {

  }
  memcpy((void *)(& chip->sdio_raw_data), (void const   *)(& buf), 12UL);
  if (chip->sdio_idle != 0) {
    if (chip->sdio_aspm == 0) {
      descriptor.modname = "rts5208";
      descriptor.function = "dynamic_configure_sdio_aspm";
      descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_card.c";
      descriptor.format = "SDIO enter ASPM!\n";
      descriptor.lineno = 134U;
      descriptor.flags = 0U;
      tmp___1 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
      if (tmp___1 != 0L) {
        tmp___0 = rtsx_dev((struct rtsx_chip  const  *)chip);
        __dynamic_dev_dbg(& descriptor, (struct device  const  *)tmp___0, "SDIO enter ASPM!\n");
      } else {

      }
      rtsx_write_register(chip, 65111, 252, (int )((u8 )((int )((signed char )((int )chip->aspm_level[1] << 2)) | 48)));
      chip->sdio_aspm = 1;
    } else {

    }
  } else
  if (chip->sdio_aspm != 0) {
    descriptor___0.modname = "rts5208";
    descriptor___0.function = "dynamic_configure_sdio_aspm";
    descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_card.c";
    descriptor___0.format = "SDIO exit ASPM!\n";
    descriptor___0.lineno = 141U;
    descriptor___0.flags = 0U;
    tmp___3 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
    if (tmp___3 != 0L) {
      tmp___2 = rtsx_dev((struct rtsx_chip  const  *)chip);
      __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)tmp___2, "SDIO exit ASPM!\n");
    } else {

    }
    rtsx_write_register(chip, 65111, 252, 48);
    chip->sdio_aspm = 0;
  } else {

  }
  return;
}
}
void do_reset_sd_card(struct rtsx_chip *chip ) 
{ 
  int retval ;
  struct _ddebug descriptor ;
  struct device *tmp ;
  long tmp___0 ;

  {
  descriptor.modname = "rts5208";
  descriptor.function = "do_reset_sd_card";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_card.c";
  descriptor.format = "%s: %d, card2lun = 0x%x\n";
  descriptor.lineno = 154U;
  descriptor.flags = 0U;
  tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp___0 != 0L) {
    tmp = rtsx_dev((struct rtsx_chip  const  *)chip);
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)tmp, "%s: %d, card2lun = 0x%x\n",
                      "do_reset_sd_card", chip->sd_reset_counter, (int )chip->card2lun[4]);
  } else {

  }
  if ((unsigned int )chip->card2lun[4] > 7U) {
    clear_bit(2L, (unsigned long volatile   *)(& chip->need_reset));
    chip->sd_reset_counter = 0;
    chip->sd_show_cnt = 0;
    return;
  } else {

  }
  chip->rw_fail_cnt[(int )chip->card2lun[4]] = 0;
  chip->idle_counter = 0;
  chip->rtsx_stat = 2;
  rtsx_write_register(chip, 64875, 255, 0);
  retval = reset_sd_card(chip);
  if ((chip->need_release & 4UL) != 0UL) {
    return;
  } else {

  }
  if (retval == 0) {
    clear_bit(2L, (unsigned long volatile   *)(& chip->need_reset));
    chip->sd_reset_counter = 0;
    chip->sd_show_cnt = 0;
    chip->card_ready = (u8 )((unsigned int )chip->card_ready | 4U);
    chip->card_fail = (unsigned int )chip->card_fail & 251U;
    chip->rw_card[(int )chip->card2lun[4]] = & sd_rw;
  } else {
    if ((unsigned int )chip->sd_io != 0U || chip->sd_reset_counter > 2) {
      clear_bit(2L, (unsigned long volatile   *)(& chip->need_reset));
      chip->sd_reset_counter = 0;
      chip->sd_show_cnt = 0;
    } else {
      chip->sd_reset_counter = chip->sd_reset_counter + 1;
    }
    chip->card_ready = (unsigned int )chip->card_ready & 251U;
    chip->card_fail = (u8 )((unsigned int )chip->card_fail | 4U);
    chip->capacity[(int )chip->card2lun[4]] = 0U;
    chip->rw_card[(int )chip->card2lun[4]] = (int (*)(struct scsi_cmnd * , struct rtsx_chip * ,
                                                      u32  , u16  ))0;
    rtsx_write_register(chip, 64853, 4, 0);
    if (chip->ft2_fast_mode == 0) {
      card_power_off(chip, 4);
    } else {

    }
    if ((unsigned int )chip->sd_io != 0U) {
      chip->sd_int = 0U;
      try_to_switch_sdio_ctrl(chip);
    } else {
      disable_card_clock(chip, 4);
    }
  }
  return;
}
}
void do_reset_xd_card(struct rtsx_chip *chip ) 
{ 
  int retval ;
  struct _ddebug descriptor ;
  struct device *tmp ;
  long tmp___0 ;

  {
  descriptor.modname = "rts5208";
  descriptor.function = "do_reset_xd_card";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_card.c";
  descriptor.format = "%s: %d, card2lun = 0x%x\n";
  descriptor.lineno = 208U;
  descriptor.flags = 0U;
  tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp___0 != 0L) {
    tmp = rtsx_dev((struct rtsx_chip  const  *)chip);
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)tmp, "%s: %d, card2lun = 0x%x\n",
                      "do_reset_xd_card", chip->xd_reset_counter, (int )chip->card2lun[16]);
  } else {

  }
  if ((unsigned int )chip->card2lun[16] > 7U) {
    clear_bit(4L, (unsigned long volatile   *)(& chip->need_reset));
    chip->xd_reset_counter = 0;
    chip->xd_show_cnt = 0;
    return;
  } else {

  }
  chip->rw_fail_cnt[(int )chip->card2lun[16]] = 0;
  chip->idle_counter = 0;
  chip->rtsx_stat = 2;
  rtsx_write_register(chip, 64875, 255, 0);
  retval = reset_xd_card(chip);
  if ((chip->need_release & 16UL) != 0UL) {
    return;
  } else {

  }
  if (retval == 0) {
    clear_bit(4L, (unsigned long volatile   *)(& chip->need_reset));
    chip->xd_reset_counter = 0;
    chip->card_ready = (u8 )((unsigned int )chip->card_ready | 16U);
    chip->card_fail = (unsigned int )chip->card_fail & 239U;
    chip->rw_card[(int )chip->card2lun[16]] = & xd_rw;
  } else {
    if (chip->xd_reset_counter > 2) {
      clear_bit(4L, (unsigned long volatile   *)(& chip->need_reset));
      chip->xd_reset_counter = 0;
      chip->xd_show_cnt = 0;
    } else {
      chip->xd_reset_counter = chip->xd_reset_counter + 1;
    }
    chip->card_ready = (unsigned int )chip->card_ready & 239U;
    chip->card_fail = (u8 )((unsigned int )chip->card_fail | 16U);
    chip->capacity[(int )chip->card2lun[16]] = 0U;
    chip->rw_card[(int )chip->card2lun[16]] = (int (*)(struct scsi_cmnd * , struct rtsx_chip * ,
                                                       u32  , u16  ))0;
    rtsx_write_register(chip, 64853, 2, 0);
    if (chip->ft2_fast_mode == 0) {
      card_power_off(chip, 16);
    } else {

    }
    disable_card_clock(chip, 16);
  }
  return;
}
}
void do_reset_ms_card(struct rtsx_chip *chip ) 
{ 
  int retval ;
  struct _ddebug descriptor ;
  struct device *tmp ;
  long tmp___0 ;

  {
  descriptor.modname = "rts5208";
  descriptor.function = "do_reset_ms_card";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_card.c";
  descriptor.format = "%s: %d, card2lun = 0x%x\n";
  descriptor.lineno = 256U;
  descriptor.flags = 0U;
  tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp___0 != 0L) {
    tmp = rtsx_dev((struct rtsx_chip  const  *)chip);
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)tmp, "%s: %d, card2lun = 0x%x\n",
                      "do_reset_ms_card", chip->ms_reset_counter, (int )chip->card2lun[8]);
  } else {

  }
  if ((unsigned int )chip->card2lun[8] > 7U) {
    clear_bit(3L, (unsigned long volatile   *)(& chip->need_reset));
    chip->ms_reset_counter = 0;
    chip->ms_show_cnt = 0;
    return;
  } else {

  }
  chip->rw_fail_cnt[(int )chip->card2lun[8]] = 0;
  chip->idle_counter = 0;
  chip->rtsx_stat = 2;
  rtsx_write_register(chip, 64875, 255, 0);
  retval = reset_ms_card(chip);
  if ((chip->need_release & 8UL) != 0UL) {
    return;
  } else {

  }
  if (retval == 0) {
    clear_bit(3L, (unsigned long volatile   *)(& chip->need_reset));
    chip->ms_reset_counter = 0;
    chip->card_ready = (u8 )((unsigned int )chip->card_ready | 8U);
    chip->card_fail = (unsigned int )chip->card_fail & 247U;
    chip->rw_card[(int )chip->card2lun[8]] = & ms_rw;
  } else {
    if (chip->ms_reset_counter > 2) {
      clear_bit(3L, (unsigned long volatile   *)(& chip->need_reset));
      chip->ms_reset_counter = 0;
      chip->ms_show_cnt = 0;
    } else {
      chip->ms_reset_counter = chip->ms_reset_counter + 1;
    }
    chip->card_ready = (unsigned int )chip->card_ready & 247U;
    chip->card_fail = (u8 )((unsigned int )chip->card_fail | 8U);
    chip->capacity[(int )chip->card2lun[8]] = 0U;
    chip->rw_card[(int )chip->card2lun[8]] = (int (*)(struct scsi_cmnd * , struct rtsx_chip * ,
                                                      u32  , u16  ))0;
    rtsx_write_register(chip, 64853, 8, 0);
    if (chip->ft2_fast_mode == 0) {
      card_power_off(chip, 8);
    } else {

    }
    disable_card_clock(chip, 8);
  }
  return;
}
}
static void release_sdio(struct rtsx_chip *chip ) 
{ 


  {
  if ((unsigned int )chip->sd_io != 0U) {
    rtsx_write_register(chip, 64852, 68, 68);
    if (chip->chip_insert_with_sdio != 0) {
      chip->chip_insert_with_sdio = 0;
      if ((unsigned int )chip->product_id == 21128U) {
        rtsx_write_register(chip, 65114, 8, 0);
      } else {
        rtsx_write_register(chip, 65136, 128, 0);
      }
    } else {

    }
    rtsx_write_register(chip, 64875, 2, 0);
    chip->sd_io = 0U;
  } else {

  }
  return;
}
}
void rtsx_power_off_card(struct rtsx_chip *chip ) 
{ 


  {
  if (((int )chip->card_ready & 4) != 0 || (unsigned int )chip->sd_io != 0U) {
    sd_cleanup_work(chip);
    sd_power_off_card3v3(chip);
  } else {

  }
  if (((int )chip->card_ready & 16) != 0) {
    xd_cleanup_work(chip);
    xd_power_off_card3v3(chip);
  } else {

  }
  if (((int )chip->card_ready & 8) != 0) {
    ms_cleanup_work(chip);
    ms_power_off_card3v3(chip);
  } else {

  }
  return;
}
}
void rtsx_release_cards(struct rtsx_chip *chip ) 
{ 


  {
  chip->int_reg = ioread32((chip->rtsx)->remap_addr + 20UL);
  if (((int )chip->card_ready & 4) != 0 || (unsigned int )chip->sd_io != 0U) {
    if ((chip->int_reg & 65536U) != 0U) {
      sd_cleanup_work(chip);
    } else {

    }
    release_sd_card(chip);
  } else {

  }
  if (((int )chip->card_ready & 16) != 0) {
    if ((chip->int_reg & 262144U) != 0U) {
      xd_cleanup_work(chip);
    } else {

    }
    release_xd_card(chip);
  } else {

  }
  if (((int )chip->card_ready & 8) != 0) {
    if ((chip->int_reg & 131072U) != 0U) {
      ms_cleanup_work(chip);
    } else {

    }
    release_ms_card(chip);
  } else {

  }
  return;
}
}
void rtsx_reset_cards(struct rtsx_chip *chip ) 
{ 


  {
  if (chip->need_reset == 0UL) {
    return;
  } else {

  }
  chip->idle_counter = 0;
  chip->rtsx_stat = 2;
  rtsx_force_power_on(chip, 3);
  rtsx_disable_aspm(chip);
  if ((chip->need_reset & 4UL) != 0UL && chip->chip_insert_with_sdio != 0) {
    clear_bit(2L, (unsigned long volatile   *)(& chip->need_reset));
  } else {

  }
  if ((chip->need_reset & 16UL) != 0UL) {
    chip->card_exist = (u8 )((unsigned int )chip->card_exist | 16U);
    if (chip->xd_show_cnt > 9) {
      do_reset_xd_card(chip);
    } else {
      chip->xd_show_cnt = chip->xd_show_cnt + 1;
    }
  } else {

  }
  if ((unsigned int )chip->product_id == 21128U && chip->baro_pkg == 0) {
    if (((int )chip->card_exist & 16) != 0) {
      clear_bit(2L, (unsigned long volatile   *)(& chip->need_reset));
      clear_bit(3L, (unsigned long volatile   *)(& chip->need_reset));
    } else {

    }
  } else {

  }
  if ((chip->need_reset & 4UL) != 0UL) {
    chip->card_exist = (u8 )((unsigned int )chip->card_exist | 4U);
    if (chip->sd_show_cnt > 9) {
      rtsx_write_register(chip, 65076, 128, 128);
      do_reset_sd_card(chip);
    } else {
      chip->sd_show_cnt = chip->sd_show_cnt + 1;
    }
  } else {

  }
  if ((chip->need_reset & 8UL) != 0UL) {
    chip->card_exist = (u8 )((unsigned int )chip->card_exist | 8U);
    if (chip->ms_show_cnt > 9) {
      do_reset_ms_card(chip);
    } else {
      chip->ms_show_cnt = chip->ms_show_cnt + 1;
    }
  } else {

  }
  return;
}
}
void rtsx_reinit_cards(struct rtsx_chip *chip , int reset_chip ) 
{ 
  struct task_struct *tmp ;
  long volatile   __ret ;
  struct task_struct *tmp___0 ;
  struct task_struct *tmp___1 ;
  struct task_struct *tmp___2 ;
  struct task_struct *tmp___3 ;
  struct task_struct *tmp___4 ;
  long volatile   __ret___0 ;
  struct task_struct *tmp___5 ;
  struct task_struct *tmp___6 ;
  struct task_struct *tmp___7 ;
  struct task_struct *tmp___8 ;
  struct task_struct *tmp___9 ;
  long volatile   __ret___1 ;
  struct task_struct *tmp___10 ;
  struct task_struct *tmp___11 ;
  struct task_struct *tmp___12 ;
  struct task_struct *tmp___13 ;

  {
  chip->idle_counter = 0;
  chip->rtsx_stat = 2;
  rtsx_force_power_on(chip, 3);
  if (reset_chip != 0) {
    rtsx_reset_chip(chip);
  } else {

  }
  chip->int_reg = ioread32((chip->rtsx)->remap_addr + 20UL);
  if ((chip->int_reg & 65536U) != 0U && (chip->need_reinit & 4UL) != 0UL) {
    release_sdio(chip);
    release_sd_card(chip);
    tmp = get_current();
    tmp->task_state_change = 0UL;
    __ret = 1L;
    switch (8UL) {
    case 1UL: 
    tmp___0 = get_current();
    __asm__  volatile   ("xchgb %b0, %1\n": "+q" (__ret), "+m" (tmp___0->state): : "memory",
                         "cc");
    goto ldv_38410;
    case 2UL: 
    tmp___1 = get_current();
    __asm__  volatile   ("xchgw %w0, %1\n": "+r" (__ret), "+m" (tmp___1->state): : "memory",
                         "cc");
    goto ldv_38410;
    case 4UL: 
    tmp___2 = get_current();
    __asm__  volatile   ("xchgl %0, %1\n": "+r" (__ret), "+m" (tmp___2->state): : "memory",
                         "cc");
    goto ldv_38410;
    case 8UL: 
    tmp___3 = get_current();
    __asm__  volatile   ("xchgq %q0, %1\n": "+r" (__ret), "+m" (tmp___3->state): : "memory",
                         "cc");
    goto ldv_38410;
    default: 
    __xchg_wrong_size();
    }
    ldv_38410: 
    schedule_timeout(25L);
    chip->card_exist = (u8 )((unsigned int )chip->card_exist | 4U);
    do_reset_sd_card(chip);
  } else {

  }
  if ((chip->int_reg & 262144U) != 0U && (chip->need_reinit & 16UL) != 0UL) {
    release_xd_card(chip);
    tmp___4 = get_current();
    tmp___4->task_state_change = 0UL;
    __ret___0 = 1L;
    switch (8UL) {
    case 1UL: 
    tmp___5 = get_current();
    __asm__  volatile   ("xchgb %b0, %1\n": "+q" (__ret___0), "+m" (tmp___5->state): : "memory",
                         "cc");
    goto ldv_38418;
    case 2UL: 
    tmp___6 = get_current();
    __asm__  volatile   ("xchgw %w0, %1\n": "+r" (__ret___0), "+m" (tmp___6->state): : "memory",
                         "cc");
    goto ldv_38418;
    case 4UL: 
    tmp___7 = get_current();
    __asm__  volatile   ("xchgl %0, %1\n": "+r" (__ret___0), "+m" (tmp___7->state): : "memory",
                         "cc");
    goto ldv_38418;
    case 8UL: 
    tmp___8 = get_current();
    __asm__  volatile   ("xchgq %q0, %1\n": "+r" (__ret___0), "+m" (tmp___8->state): : "memory",
                         "cc");
    goto ldv_38418;
    default: 
    __xchg_wrong_size();
    }
    ldv_38418: 
    schedule_timeout(25L);
    chip->card_exist = (u8 )((unsigned int )chip->card_exist | 16U);
    do_reset_xd_card(chip);
  } else {

  }
  if ((chip->int_reg & 131072U) != 0U && (chip->need_reinit & 8UL) != 0UL) {
    release_ms_card(chip);
    tmp___9 = get_current();
    tmp___9->task_state_change = 0UL;
    __ret___1 = 1L;
    switch (8UL) {
    case 1UL: 
    tmp___10 = get_current();
    __asm__  volatile   ("xchgb %b0, %1\n": "+q" (__ret___1), "+m" (tmp___10->state): : "memory",
                         "cc");
    goto ldv_38426;
    case 2UL: 
    tmp___11 = get_current();
    __asm__  volatile   ("xchgw %w0, %1\n": "+r" (__ret___1), "+m" (tmp___11->state): : "memory",
                         "cc");
    goto ldv_38426;
    case 4UL: 
    tmp___12 = get_current();
    __asm__  volatile   ("xchgl %0, %1\n": "+r" (__ret___1), "+m" (tmp___12->state): : "memory",
                         "cc");
    goto ldv_38426;
    case 8UL: 
    tmp___13 = get_current();
    __asm__  volatile   ("xchgq %q0, %1\n": "+r" (__ret___1), "+m" (tmp___13->state): : "memory",
                         "cc");
    goto ldv_38426;
    default: 
    __xchg_wrong_size();
    }
    ldv_38426: 
    schedule_timeout(25L);
    chip->card_exist = (u8 )((unsigned int )chip->card_exist | 8U);
    do_reset_ms_card(chip);
  } else {

  }
  chip->need_reinit = 0UL;
  return;
}
}
void rtsx_init_cards(struct rtsx_chip *chip ) 
{ 
  struct _ddebug descriptor ;
  struct device *tmp ;
  long tmp___0 ;
  struct _ddebug descriptor___0 ;
  struct device *tmp___1 ;
  long tmp___2 ;
  struct _ddebug descriptor___1 ;
  struct device *tmp___3 ;
  long tmp___4 ;
  struct _ddebug descriptor___2 ;
  struct device *tmp___5 ;
  long tmp___6 ;
  struct _ddebug descriptor___3 ;
  struct device *tmp___7 ;
  long tmp___8 ;

  {
  if ((int )chip->rtsx_flag & 1 && (unsigned int )chip->rtsx_stat != 3U) {
    descriptor.modname = "rts5208";
    descriptor.function = "rtsx_init_cards";
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_card.c";
    descriptor.format = "Reset chip in polling thread!\n";
    descriptor.lineno = 528U;
    descriptor.flags = 0U;
    tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
    if (tmp___0 != 0L) {
      tmp = rtsx_dev((struct rtsx_chip  const  *)chip);
      __dynamic_dev_dbg(& descriptor, (struct device  const  *)tmp, "Reset chip in polling thread!\n");
    } else {

    }
    rtsx_reset_chip(chip);
    chip->rtsx_flag = (unsigned int )chip->rtsx_flag & 254U;
  } else {

  }
  if (chip->need_release != 0UL) {
    if ((unsigned int )chip->product_id == 21128U && chip->baro_pkg == 0) {
      if ((chip->int_reg & 262144U) != 0U) {
        clear_bit(2L, (unsigned long volatile   *)(& chip->need_release));
        clear_bit(3L, (unsigned long volatile   *)(& chip->need_release));
      } else {

      }
    } else {

    }
    if (((int )chip->card_exist & 4) == 0 && (unsigned int )chip->sd_io == 0U) {
      clear_bit(2L, (unsigned long volatile   *)(& chip->need_release));
    } else {

    }
    if (((int )chip->card_exist & 16) == 0) {
      clear_bit(4L, (unsigned long volatile   *)(& chip->need_release));
    } else {

    }
    if (((int )chip->card_exist & 8) == 0) {
      clear_bit(3L, (unsigned long volatile   *)(& chip->need_release));
    } else {

    }
    descriptor___0.modname = "rts5208";
    descriptor___0.function = "rtsx_init_cards";
    descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_card.c";
    descriptor___0.format = "chip->need_release = 0x%x\n";
    descriptor___0.lineno = 553U;
    descriptor___0.flags = 0U;
    tmp___2 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
    if (tmp___2 != 0L) {
      tmp___1 = rtsx_dev((struct rtsx_chip  const  *)chip);
      __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)tmp___1, "chip->need_release = 0x%x\n",
                        (unsigned int )chip->need_release);
    } else {

    }
    if (chip->need_release != 0UL) {
      if (((int )chip->ocp_stat & 12) != 0) {
        rtsx_write_register(chip, 64535, 10, 10);
      } else {

      }
      chip->ocp_stat = 0U;
    } else {

    }
    if (chip->need_release != 0UL) {
      chip->idle_counter = 0;
      chip->rtsx_stat = 2;
      rtsx_force_power_on(chip, 3);
    } else {

    }
    if ((chip->need_release & 4UL) != 0UL) {
      clear_bit(2L, (unsigned long volatile   *)(& chip->need_release));
      chip->card_exist = (unsigned int )chip->card_exist & 251U;
      chip->card_ejected = (unsigned int )chip->card_ejected & 251U;
      chip->card_fail = (unsigned int )chip->card_fail & 251U;
      chip->lun_mc = (u8 )((int )((signed char )chip->lun_mc) & ~ ((int )((signed char )(1 << (int )chip->card2lun[4]))));
      chip->rw_fail_cnt[(int )chip->card2lun[4]] = 0;
      rtsx_write_register(chip, 65076, 128, 128);
      release_sdio(chip);
      release_sd_card(chip);
    } else {

    }
    if ((chip->need_release & 16UL) != 0UL) {
      clear_bit(4L, (unsigned long volatile   *)(& chip->need_release));
      chip->card_exist = (unsigned int )chip->card_exist & 239U;
      chip->card_ejected = (unsigned int )chip->card_ejected & 239U;
      chip->card_fail = (unsigned int )chip->card_fail & 239U;
      chip->lun_mc = (u8 )((int )((signed char )chip->lun_mc) & ~ ((int )((signed char )(1 << (int )chip->card2lun[16]))));
      chip->rw_fail_cnt[(int )chip->card2lun[16]] = 0;
      release_xd_card(chip);
      if ((unsigned int )chip->product_id == 21128U && chip->baro_pkg == 0) {
        rtsx_write_register(chip, 65120, 192, 192);
      } else {

      }
    } else {

    }
    if ((chip->need_release & 8UL) != 0UL) {
      clear_bit(3L, (unsigned long volatile   *)(& chip->need_release));
      chip->card_exist = (unsigned int )chip->card_exist & 247U;
      chip->card_ejected = (unsigned int )chip->card_ejected & 247U;
      chip->card_fail = (unsigned int )chip->card_fail & 247U;
      chip->lun_mc = (u8 )((int )((signed char )chip->lun_mc) & ~ ((int )((signed char )(1 << (int )chip->card2lun[8]))));
      chip->rw_fail_cnt[(int )chip->card2lun[8]] = 0;
      release_ms_card(chip);
    } else {

    }
    descriptor___1.modname = "rts5208";
    descriptor___1.function = "rtsx_init_cards";
    descriptor___1.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_card.c";
    descriptor___1.format = "chip->card_exist = 0x%x\n";
    descriptor___1.lineno = 610U;
    descriptor___1.flags = 0U;
    tmp___4 = ldv__builtin_expect((long )descriptor___1.flags & 1L, 0L);
    if (tmp___4 != 0L) {
      tmp___3 = rtsx_dev((struct rtsx_chip  const  *)chip);
      __dynamic_dev_dbg(& descriptor___1, (struct device  const  *)tmp___3, "chip->card_exist = 0x%x\n",
                        (int )chip->card_exist);
    } else {

    }
    if ((unsigned int )chip->card_exist == 0U) {
      turn_off_led(chip, 0);
    } else {

    }
  } else {

  }
  if (chip->need_reset != 0UL) {
    descriptor___2.modname = "rts5208";
    descriptor___2.function = "rtsx_init_cards";
    descriptor___2.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_card.c";
    descriptor___2.format = "chip->need_reset = 0x%x\n";
    descriptor___2.lineno = 618U;
    descriptor___2.flags = 0U;
    tmp___6 = ldv__builtin_expect((long )descriptor___2.flags & 1L, 0L);
    if (tmp___6 != 0L) {
      tmp___5 = rtsx_dev((struct rtsx_chip  const  *)chip);
      __dynamic_dev_dbg(& descriptor___2, (struct device  const  *)tmp___5, "chip->need_reset = 0x%x\n",
                        (unsigned int )chip->need_reset);
    } else {

    }
    rtsx_reset_cards(chip);
  } else {

  }
  if (chip->need_reinit != 0UL) {
    descriptor___3.modname = "rts5208";
    descriptor___3.function = "rtsx_init_cards";
    descriptor___3.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_card.c";
    descriptor___3.format = "chip->need_reinit = 0x%x\n";
    descriptor___3.lineno = 625U;
    descriptor___3.flags = 0U;
    tmp___8 = ldv__builtin_expect((long )descriptor___3.flags & 1L, 0L);
    if (tmp___8 != 0L) {
      tmp___7 = rtsx_dev((struct rtsx_chip  const  *)chip);
      __dynamic_dev_dbg(& descriptor___3, (struct device  const  *)tmp___7, "chip->need_reinit = 0x%x\n",
                        (unsigned int )chip->need_reinit);
    } else {

    }
    rtsx_reinit_cards(chip, 0);
  } else {

  }
  return;
}
}
int switch_ssc_clock(struct rtsx_chip *chip , int clk ) 
{ 
  int retval ;
  u8 N ;
  u8 min_N ;
  u8 max_N ;
  u8 mcu_cnt ;
  u8 div ;
  u8 max_div ;
  u8 ssc_depth ;
  u8 ssc_depth_mask ;
  int sd_vpclk_phase_reset ;
    klee_make_symbolic(&sd_vpclk_phase_reset, sizeof(int), "sd_vpclk_phase_reset");
  struct _ddebug descriptor ;
  struct device *tmp ;
  long tmp___0 ;
  struct _ddebug descriptor___0 ;
  struct device *tmp___1 ;
  long tmp___2 ;
  struct _ddebug descriptor___1 ;
  struct device *tmp___3 ;
  long tmp___4 ;

  {
  N = (unsigned int )((unsigned char )clk) - 2U;
  sd_vpclk_phase_reset = 0;
  if (chip->cur_clk == clk) {
    return (0);
  } else {

  }
  min_N = 60U;
  max_N = 120U;
  max_div = 3U;
  descriptor.modname = "rts5208";
  descriptor.function = "switch_ssc_clock";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_card.c";
  descriptor.format = "Switch SSC clock to %dMHz (cur_clk = %d)\n";
  descriptor.lineno = 651U;
  descriptor.flags = 0U;
  tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp___0 != 0L) {
    tmp = rtsx_dev((struct rtsx_chip  const  *)chip);
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)tmp, "Switch SSC clock to %dMHz (cur_clk = %d)\n",
                      clk, chip->cur_clk);
  } else {

  }
  if (clk <= 2 || (int )N > (int )max_N) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_card.c",
                "switch_ssc_clock", 654);
    return (1);
  } else {

  }
  mcu_cnt = (unsigned int )((unsigned char )(125 / clk)) + 3U;
  if ((unsigned int )mcu_cnt > 7U) {
    mcu_cnt = 7U;
  } else {

  }
  div = 1U;
  goto ldv_38461;
  ldv_38460: 
  N = (unsigned int )((u8 )((int )N + 1)) * 2U;
  div = (u8 )((int )div + 1);
  ldv_38461: ;
  if ((int )N < (int )min_N && (int )div < (int )max_div) {
    goto ldv_38460;
  } else {

  }
  descriptor___0.modname = "rts5208";
  descriptor___0.function = "switch_ssc_clock";
  descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_card.c";
  descriptor___0.format = "N = %d, div = %d\n";
  descriptor___0.lineno = 667U;
  descriptor___0.flags = 0U;
  tmp___2 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
  if (tmp___2 != 0L) {
    tmp___1 = rtsx_dev((struct rtsx_chip  const  *)chip);
    __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)tmp___1, "N = %d, div = %d\n",
                      (int )N, (int )div);
  } else {

  }
  if (chip->ssc_en != 0) {
    ssc_depth = 1U;
    N = (unsigned int )N + 254U;
  } else {
    ssc_depth = 0U;
  }
  ssc_depth_mask = 3U;
  descriptor___1.modname = "rts5208";
  descriptor___1.function = "switch_ssc_clock";
  descriptor___1.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_card.c";
  descriptor___1.format = "ssc_depth = %d\n";
  descriptor___1.lineno = 678U;
  descriptor___1.flags = 0U;
  tmp___4 = ldv__builtin_expect((long )descriptor___1.flags & 1L, 0L);
  if (tmp___4 != 0L) {
    tmp___3 = rtsx_dev((struct rtsx_chip  const  *)chip);
    __dynamic_dev_dbg(& descriptor___1, (struct device  const  *)tmp___3, "ssc_depth = %d\n",
                      (int )ssc_depth);
  } else {

  }
  chip->ci = 0;
  rtsx_add_cmd(chip, 1, 64514, 1, 1);
  rtsx_add_cmd(chip, 1, 64515, 255, (int )((u8 )((int )((signed char )((int )div << 4)) | (int )((signed char )mcu_cnt))));
  rtsx_add_cmd(chip, 1, 64529, 128, 0);
  rtsx_add_cmd(chip, 1, 64530, (int )ssc_depth_mask, (int )ssc_depth);
  rtsx_add_cmd(chip, 1, 64527, 255, (int )N);
  rtsx_add_cmd(chip, 1, 64529, 128, 128);
  if (sd_vpclk_phase_reset != 0) {
    rtsx_add_cmd(chip, 1, 64554, 64, 0);
    rtsx_add_cmd(chip, 1, 64554, 64, 64);
  } else {

  }
  retval = rtsx_send_cmd(chip, 0, 2000);
  if (retval < 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_card.c",
                "switch_ssc_clock", 696);
    return (10);
  } else {

  }
  __const_udelay(42950UL);
  retval = rtsx_write_register(chip, 64514, 1, 0);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_card.c",
                "switch_ssc_clock", 703);
    return (retval);
  } else {

  }
  chip->cur_clk = clk;
  return (0);
}
}
int switch_normal_clock(struct rtsx_chip *chip , int clk ) 
{ 
  int retval ;
  u8 sel ;
  u8 div ;
  u8 mcu_cnt ;
  int sd_vpclk_phase_reset ;
  struct _ddebug descriptor ;
  struct device *tmp ;
  long tmp___0 ;
  struct _ddebug descriptor___0 ;
  struct device *tmp___1 ;
  long tmp___2 ;
  struct _ddebug descriptor___1 ;
  struct device *tmp___3 ;
  long tmp___4 ;
  struct _ddebug descriptor___2 ;
  struct device *tmp___5 ;
  long tmp___6 ;
  struct _ddebug descriptor___3 ;
  struct device *tmp___7 ;
  long tmp___8 ;
  struct _ddebug descriptor___4 ;
  struct device *tmp___9 ;
  long tmp___10 ;
  struct _ddebug descriptor___5 ;
  struct device *tmp___11 ;
  long tmp___12 ;
  struct _ddebug descriptor___6 ;
  struct device *tmp___13 ;
  long tmp___14 ;
  struct _ddebug descriptor___7 ;
  struct device *tmp___15 ;
  long tmp___16 ;
  struct _ddebug descriptor___8 ;
  struct device *tmp___17 ;
  long tmp___18 ;
  struct _ddebug descriptor___9 ;
  struct device *tmp___19 ;
  long tmp___20 ;

  {
  sd_vpclk_phase_reset = 0;
  if (chip->cur_clk == clk) {
    return (0);
  } else {

  }
  switch (clk) {
  case 1: 
  descriptor.modname = "rts5208";
  descriptor.function = "switch_normal_clock";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_card.c";
  descriptor.format = "Switch clock to 20MHz\n";
  descriptor.lineno = 723U;
  descriptor.flags = 0U;
  tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp___0 != 0L) {
    tmp = rtsx_dev((struct rtsx_chip  const  *)chip);
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)tmp, "Switch clock to 20MHz\n");
  } else {

  }
  sel = 0U;
  div = 3U;
  mcu_cnt = 7U;
  goto ldv_38477;
  case 2: 
  descriptor___0.modname = "rts5208";
  descriptor___0.function = "switch_normal_clock";
  descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_card.c";
  descriptor___0.format = "Switch clock to 30MHz\n";
  descriptor___0.lineno = 730U;
  descriptor___0.flags = 0U;
  tmp___2 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
  if (tmp___2 != 0L) {
    tmp___1 = rtsx_dev((struct rtsx_chip  const  *)chip);
    __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)tmp___1, "Switch clock to 30MHz\n");
  } else {

  }
  sel = 2U;
  div = 3U;
  mcu_cnt = 7U;
  goto ldv_38477;
  case 3: 
  descriptor___1.modname = "rts5208";
  descriptor___1.function = "switch_normal_clock";
  descriptor___1.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_card.c";
  descriptor___1.format = "Switch clock to 40MHz\n";
  descriptor___1.lineno = 737U;
  descriptor___1.flags = 0U;
  tmp___4 = ldv__builtin_expect((long )descriptor___1.flags & 1L, 0L);
  if (tmp___4 != 0L) {
    tmp___3 = rtsx_dev((struct rtsx_chip  const  *)chip);
    __dynamic_dev_dbg(& descriptor___1, (struct device  const  *)tmp___3, "Switch clock to 40MHz\n");
  } else {

  }
  sel = 0U;
  div = 2U;
  mcu_cnt = 7U;
  goto ldv_38477;
  case 4: 
  descriptor___2.modname = "rts5208";
  descriptor___2.function = "switch_normal_clock";
  descriptor___2.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_card.c";
  descriptor___2.format = "Switch clock to 50MHz\n";
  descriptor___2.lineno = 744U;
  descriptor___2.flags = 0U;
  tmp___6 = ldv__builtin_expect((long )descriptor___2.flags & 1L, 0L);
  if (tmp___6 != 0L) {
    tmp___5 = rtsx_dev((struct rtsx_chip  const  *)chip);
    __dynamic_dev_dbg(& descriptor___2, (struct device  const  *)tmp___5, "Switch clock to 50MHz\n");
  } else {

  }
  sel = 1U;
  div = 2U;
  mcu_cnt = 6U;
  goto ldv_38477;
  case 5: 
  descriptor___3.modname = "rts5208";
  descriptor___3.function = "switch_normal_clock";
  descriptor___3.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_card.c";
  descriptor___3.format = "Switch clock to 60MHz\n";
  descriptor___3.lineno = 751U;
  descriptor___3.flags = 0U;
  tmp___8 = ldv__builtin_expect((long )descriptor___3.flags & 1L, 0L);
  if (tmp___8 != 0L) {
    tmp___7 = rtsx_dev((struct rtsx_chip  const  *)chip);
    __dynamic_dev_dbg(& descriptor___3, (struct device  const  *)tmp___7, "Switch clock to 60MHz\n");
  } else {

  }
  sel = 2U;
  div = 2U;
  mcu_cnt = 6U;
  goto ldv_38477;
  case 6: 
  descriptor___4.modname = "rts5208";
  descriptor___4.function = "switch_normal_clock";
  descriptor___4.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_card.c";
  descriptor___4.format = "Switch clock to 80MHz\n";
  descriptor___4.lineno = 758U;
  descriptor___4.flags = 0U;
  tmp___10 = ldv__builtin_expect((long )descriptor___4.flags & 1L, 0L);
  if (tmp___10 != 0L) {
    tmp___9 = rtsx_dev((struct rtsx_chip  const  *)chip);
    __dynamic_dev_dbg(& descriptor___4, (struct device  const  *)tmp___9, "Switch clock to 80MHz\n");
  } else {

  }
  sel = 0U;
  div = 1U;
  mcu_cnt = 5U;
  goto ldv_38477;
  case 7: 
  descriptor___5.modname = "rts5208";
  descriptor___5.function = "switch_normal_clock";
  descriptor___5.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_card.c";
  descriptor___5.format = "Switch clock to 100MHz\n";
  descriptor___5.lineno = 765U;
  descriptor___5.flags = 0U;
  tmp___12 = ldv__builtin_expect((long )descriptor___5.flags & 1L, 0L);
  if (tmp___12 != 0L) {
    tmp___11 = rtsx_dev((struct rtsx_chip  const  *)chip);
    __dynamic_dev_dbg(& descriptor___5, (struct device  const  *)tmp___11, "Switch clock to 100MHz\n");
  } else {

  }
  sel = 1U;
  div = 1U;
  mcu_cnt = 5U;
  goto ldv_38477;
  case 8: 
  descriptor___6.modname = "rts5208";
  descriptor___6.function = "switch_normal_clock";
  descriptor___6.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_card.c";
  descriptor___6.format = "Switch clock to 120MHz\n";
  descriptor___6.lineno = 772U;
  descriptor___6.flags = 0U;
  tmp___14 = ldv__builtin_expect((long )descriptor___6.flags & 1L, 0L);
  if (tmp___14 != 0L) {
    tmp___13 = rtsx_dev((struct rtsx_chip  const  *)chip);
    __dynamic_dev_dbg(& descriptor___6, (struct device  const  *)tmp___13, "Switch clock to 120MHz\n");
  } else {

  }
  sel = 2U;
  div = 1U;
  mcu_cnt = 5U;
  goto ldv_38477;
  case 9: 
  descriptor___7.modname = "rts5208";
  descriptor___7.function = "switch_normal_clock";
  descriptor___7.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_card.c";
  descriptor___7.format = "Switch clock to 150MHz\n";
  descriptor___7.lineno = 779U;
  descriptor___7.flags = 0U;
  tmp___16 = ldv__builtin_expect((long )descriptor___7.flags & 1L, 0L);
  if (tmp___16 != 0L) {
    tmp___15 = rtsx_dev((struct rtsx_chip  const  *)chip);
    __dynamic_dev_dbg(& descriptor___7, (struct device  const  *)tmp___15, "Switch clock to 150MHz\n");
  } else {

  }
  sel = 3U;
  div = 1U;
  mcu_cnt = 4U;
  goto ldv_38477;
  case 10: 
  descriptor___8.modname = "rts5208";
  descriptor___8.function = "switch_normal_clock";
  descriptor___8.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_card.c";
  descriptor___8.format = "Switch clock to 200MHz\n";
  descriptor___8.lineno = 786U;
  descriptor___8.flags = 0U;
  tmp___18 = ldv__builtin_expect((long )descriptor___8.flags & 1L, 0L);
  if (tmp___18 != 0L) {
    tmp___17 = rtsx_dev((struct rtsx_chip  const  *)chip);
    __dynamic_dev_dbg(& descriptor___8, (struct device  const  *)tmp___17, "Switch clock to 200MHz\n");
  } else {

  }
  sel = 4U;
  div = 1U;
  mcu_cnt = 4U;
  goto ldv_38477;
  default: 
  descriptor___9.modname = "rts5208";
  descriptor___9.function = "switch_normal_clock";
  descriptor___9.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_card.c";
  descriptor___9.format = "Try to switch to an illegal clock (%d)\n";
  descriptor___9.lineno = 794U;
  descriptor___9.flags = 0U;
  tmp___20 = ldv__builtin_expect((long )descriptor___9.flags & 1L, 0L);
  if (tmp___20 != 0L) {
    tmp___19 = rtsx_dev((struct rtsx_chip  const  *)chip);
    __dynamic_dev_dbg(& descriptor___9, (struct device  const  *)tmp___19, "Try to switch to an illegal clock (%d)\n",
                      clk);
  } else {

  }
  _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_card.c",
              "switch_normal_clock", 795);
  return (1);
  }
  ldv_38477: 
  retval = rtsx_write_register(chip, 64514, 255, 1);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_card.c",
                "switch_normal_clock", 801);
    return (retval);
  } else {

  }
  if (sd_vpclk_phase_reset != 0) {
    retval = rtsx_write_register(chip, 64554, 64, 0);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_card.c",
                  "switch_normal_clock", 808);
      return (retval);
    } else {

    }
    retval = rtsx_write_register(chip, 64555, 64, 0);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_card.c",
                  "switch_normal_clock", 814);
      return (retval);
    } else {

    }
  } else {

  }
  retval = rtsx_write_register(chip, 64515, 255, (int )((u8 )((int )((signed char )((int )div << 4)) | (int )((signed char )mcu_cnt))));
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_card.c",
                "switch_normal_clock", 821);
    return (retval);
  } else {

  }
  retval = rtsx_write_register(chip, 64516, 255, (int )sel);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_card.c",
                "switch_normal_clock", 826);
    return (retval);
  } else {

  }
  if (sd_vpclk_phase_reset != 0) {
    __const_udelay(859000UL);
    retval = rtsx_write_register(chip, 64554, 64, 64);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_card.c",
                  "switch_normal_clock", 835);
      return (retval);
    } else {

    }
    retval = rtsx_write_register(chip, 64555, 64, 64);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_card.c",
                  "switch_normal_clock", 841);
      return (retval);
    } else {

    }
    __const_udelay(859000UL);
  } else {

  }
  retval = rtsx_write_register(chip, 64514, 255, 0);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_card.c",
                "switch_normal_clock", 848);
    return (retval);
  } else {

  }
  chip->cur_clk = clk;
  return (0);
}
}
void trans_dma_enable(enum dma_data_direction dir , struct rtsx_chip *chip , u32 byte_cnt ,
                      u8 pack_size ) 
{ 


  {
  if ((unsigned int )pack_size > 48U) {
    pack_size = 32U;
  } else {

  }
  rtsx_add_cmd(chip, 1, 65057, 128, 128);
  rtsx_add_cmd(chip, 1, 65067, 255, (int )((unsigned char )(byte_cnt >> 24)));
  rtsx_add_cmd(chip, 1, 65066, 255, (int )((unsigned char )(byte_cnt >> 16)));
  rtsx_add_cmd(chip, 1, 65065, 255, (int )((unsigned char )(byte_cnt >> 8)));
  rtsx_add_cmd(chip, 1, 65064, 255, (int )((unsigned char )byte_cnt));
  if ((unsigned int )dir == 2U) {
    rtsx_add_cmd(chip, 1, 65068, 51, (int )((unsigned int )pack_size | 3U));
  } else {
    rtsx_add_cmd(chip, 1, 65068, 51, (int )((unsigned int )pack_size | 1U));
  }
  rtsx_add_cmd(chip, 1, 64859, 1, 0);
  return;
}
}
int enable_card_clock(struct rtsx_chip *chip , u8 card ) 
{ 
  int retval ;
  u8 clk_en ;

  {
  clk_en = 0U;
  if (((int )card & 16) != 0) {
    clk_en = (u8 )((unsigned int )clk_en | 2U);
  } else {

  }
  if (((int )card & 4) != 0) {
    clk_en = (u8 )((unsigned int )clk_en | 4U);
  } else {

  }
  if (((int )card & 8) != 0) {
    clk_en = (u8 )((unsigned int )clk_en | 8U);
  } else {

  }
  retval = rtsx_write_register(chip, 64873, (int )clk_en, (int )clk_en);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_card.c",
                "enable_card_clock", 897);
    return (retval);
  } else {

  }
  return (0);
}
}
int disable_card_clock(struct rtsx_chip *chip , u8 card ) 
{ 
  int retval ;
  u8 clk_en ;

  {
  clk_en = 0U;
  if (((int )card & 16) != 0) {
    clk_en = (u8 )((unsigned int )clk_en | 2U);
  } else {

  }
  if (((int )card & 4) != 0) {
    clk_en = (u8 )((unsigned int )clk_en | 4U);
  } else {

  }
  if (((int )card & 8) != 0) {
    clk_en = (u8 )((unsigned int )clk_en | 8U);
  } else {

  }
  retval = rtsx_write_register(chip, 64873, (int )clk_en, 0);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_card.c",
                "disable_card_clock", 918);
    return (retval);
  } else {

  }
  return (0);
}
}
int card_power_on(struct rtsx_chip *chip , u8 card ) 
{ 
  int retval ;
  u8 mask ;
  u8 val1 ;
  u8 val2 ;

  {
  if ((unsigned int )chip->lun_mode == 1U && (unsigned int )card == 8U) {
    mask = 12U;
    val1 = 4U;
    val2 = 0U;
  } else {
    mask = 3U;
    val1 = 1U;
    val2 = 0U;
  }
  chip->ci = 0;
  rtsx_add_cmd(chip, 1, 64848, (int )mask, (int )val1);
  retval = rtsx_send_cmd(chip, 0, 100);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_card.c",
                "card_power_on", 945);
    return (1);
  } else {

  }
  __udelay((unsigned long )chip->pmos_pwr_on_interval);
  chip->ci = 0;
  rtsx_add_cmd(chip, 1, 64848, (int )mask, (int )val2);
  retval = rtsx_send_cmd(chip, 0, 100);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_card.c",
                "card_power_on", 956);
    return (1);
  } else {

  }
  return (0);
}
}
int card_power_off(struct rtsx_chip *chip , u8 card ) 
{ 
  int retval ;
  u8 mask ;
  u8 val ;

  {
  if ((unsigned int )chip->lun_mode == 1U && (unsigned int )card == 8U) {
    mask = 12U;
    val = 12U;
  } else {
    mask = 3U;
    val = 3U;
  }
  retval = rtsx_write_register(chip, 64848, (int )mask, (int )val);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_card.c",
                "card_power_off", 978);
    return (retval);
  } else {

  }
  return (0);
}
}
int card_rw(struct scsi_cmnd *srb , struct rtsx_chip *chip , u32 sec_addr , u16 sec_cnt ) 
{ 
  int retval ;
  unsigned int lun ;
  int i ;
  int tmp ;
  int tmp___0 ;
  struct _ddebug descriptor ;
  struct device *tmp___1 ;
  long tmp___2 ;
  struct _ddebug descriptor___0 ;
  struct device *tmp___3 ;
  long tmp___4 ;

  {
  lun = (unsigned int )(srb->device)->lun;
  if ((unsigned long )chip->rw_card[lun] == (unsigned long )((int (*)(struct scsi_cmnd * ,
                                                                      struct rtsx_chip * ,
                                                                      u32  , u16  ))0)) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_card.c",
                "card_rw", 993);
    return (1);
  } else {

  }
  i = 0;
  goto ldv_38549;
  ldv_38548: 
  chip->rw_need_retry = 0;
  retval = (*(chip->rw_card[lun]))(srb, chip, sec_addr, (int )sec_cnt);
  if (retval != 0) {
    tmp = rtsx_check_chip_exist(chip);
    if (tmp != 0) {
      rtsx_release_chip(chip);
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_card.c",
                  "card_rw", 1004);
      return (1);
    } else {

    }
    tmp___0 = detect_card_cd(chip, chip->cur_card);
    if (tmp___0 != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_card.c",
                  "card_rw", 1009);
      return (1);
    } else {

    }
    if (chip->rw_need_retry == 0) {
      descriptor.modname = "rts5208";
      descriptor.function = "card_rw";
      descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_card.c";
      descriptor.format = "RW fail, but no need to retry\n";
      descriptor.lineno = 1014U;
      descriptor.flags = 0U;
      tmp___2 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
      if (tmp___2 != 0L) {
        tmp___1 = rtsx_dev((struct rtsx_chip  const  *)chip);
        __dynamic_dev_dbg(& descriptor, (struct device  const  *)tmp___1, "RW fail, but no need to retry\n");
      } else {

      }
      goto ldv_38546;
    } else {

    }
  } else {
    chip->rw_need_retry = 0;
    goto ldv_38546;
  }
  descriptor___0.modname = "rts5208";
  descriptor___0.function = "card_rw";
  descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_card.c";
  descriptor___0.format = "Retry RW, (i = %d)\n";
  descriptor___0.lineno = 1022U;
  descriptor___0.flags = 0U;
  tmp___4 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
  if (tmp___4 != 0L) {
    tmp___3 = rtsx_dev((struct rtsx_chip  const  *)chip);
    __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)tmp___3, "Retry RW, (i = %d)\n",
                      i);
  } else {

  }
  i = i + 1;
  ldv_38549: ;
  if (i <= 2) {
    goto ldv_38548;
  } else {

  }
  ldv_38546: ;
  return (retval);
}
}
int card_share_mode(struct rtsx_chip *chip , int card ) 
{ 
  int retval ;
  u8 mask ;
  u8 value ;

  {
  if ((unsigned int )chip->product_id == 21000U) {
    mask = 15U;
    if (card == 4) {
      value = 4U;
    } else
    if (card == 8) {
      value = 8U;
    } else
    if (card == 16) {
      value = 2U;
    } else {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_card.c",
                  "card_share_mode", 1042);
      return (1);
    }
  } else
  if ((unsigned int )chip->product_id == 21128U) {
    mask = 3U;
    if (card == 4) {
      value = 1U;
    } else
    if (card == 8) {
      value = 2U;
    } else
    if (card == 16) {
      value = 0U;
    } else {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_card.c",
                  "card_share_mode", 1055);
      return (1);
    }
  } else {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_card.c",
                "card_share_mode", 1060);
    return (1);
  }
  retval = rtsx_write_register(chip, 64850, (int )mask, (int )value);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_card.c",
                "card_share_mode", 1066);
    return (retval);
  } else {

  }
  return (0);
}
}
int select_card(struct rtsx_chip *chip , int card ) 
{ 
  int retval ;
  u8 mod ;

  {
  if (chip->cur_card != card) {
    if (card == 4) {
      mod = 2U;
    } else
    if (card == 8) {
      mod = 3U;
    } else
    if (card == 16) {
      mod = 1U;
    } else
    if (card == 128) {
      mod = 4U;
    } else {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_card.c",
                  "select_card", 1090);
      return (1);
    }
    retval = rtsx_write_register(chip, 64860, 7, (int )mod);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_card.c",
                  "select_card", 1096);
      return (retval);
    } else {

    }
    chip->cur_card = card;
    retval = card_share_mode(chip, card);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_card.c",
                  "select_card", 1103);
      return (1);
    } else {

    }
  } else {

  }
  return (0);
}
}
void toggle_gpio(struct rtsx_chip *chip , u8 gpio ) 
{ 
  u8 temp_reg ;

  {
  rtsx_read_register(chip, 64856, & temp_reg);
  temp_reg = (u8 )((int )((signed char )(1 << (int )gpio)) ^ (int )((signed char )temp_reg));
  rtsx_write_register(chip, 64856, 255, (int )temp_reg);
  return;
}
}
void turn_on_led(struct rtsx_chip *chip , u8 gpio ) 
{ 


  {
  if ((unsigned int )chip->product_id == 21128U) {
    rtsx_write_register(chip, 64856, (int )((unsigned char )(1 << (int )gpio)), (int )((unsigned char )(1 << (int )gpio)));
  } else {
    rtsx_write_register(chip, 64856, (int )((unsigned char )(1 << (int )gpio)), 0);
  }
  return;
}
}
void turn_off_led(struct rtsx_chip *chip , u8 gpio ) 
{ 


  {
  if ((unsigned int )chip->product_id == 21128U) {
    rtsx_write_register(chip, 64856, (int )((unsigned char )(1 << (int )gpio)), 0);
  } else {
    rtsx_write_register(chip, 64856, (int )((unsigned char )(1 << (int )gpio)), (int )((unsigned char )(1 << (int )gpio)));
  }
  return;
}
}
int detect_card_cd(struct rtsx_chip *chip , int card ) 
{ 
  u32 card_cd ;
  u32 status ;
  struct _ddebug descriptor ;
  struct device *tmp ;
  long tmp___0 ;

  {
  if (card == 4) {
    card_cd = 65536U;
  } else
  if (card == 8) {
    card_cd = 131072U;
  } else
  if (card == 16) {
    card_cd = 262144U;
  } else {
    descriptor.modname = "rts5208";
    descriptor.function = "detect_card_cd";
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_card.c";
    descriptor.format = "Wrong card type: 0x%x\n";
    descriptor.lineno = 1149U;
    descriptor.flags = 0U;
    tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
    if (tmp___0 != 0L) {
      tmp = rtsx_dev((struct rtsx_chip  const  *)chip);
      __dynamic_dev_dbg(& descriptor, (struct device  const  *)tmp, "Wrong card type: 0x%x\n",
                        card);
    } else {

    }
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_card.c",
                "detect_card_cd", 1150);
    return (1);
  }
  status = ioread32((chip->rtsx)->remap_addr + 20UL);
  if ((status & card_cd) == 0U) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/rtsx_card.c",
                "detect_card_cd", 1156);
    return (1);
  } else {

  }
  return (0);
}
}
int check_card_exist(struct rtsx_chip *chip , unsigned int lun ) 
{ 


  {
  if ((unsigned int )((int )chip->card_exist & (int )chip->lun2card[lun]) != 0U) {
    return (1);
  } else {

  }
  return (0);
}
}
int check_card_ready(struct rtsx_chip *chip , unsigned int lun ) 
{ 


  {
  if ((unsigned int )((int )chip->card_ready & (int )chip->lun2card[lun]) != 0U) {
    return (1);
  } else {

  }
  return (0);
}
}
int check_card_wp(struct rtsx_chip *chip , unsigned int lun ) 
{ 


  {
  if ((unsigned int )((int )chip->card_wp & (int )chip->lun2card[lun]) != 0U) {
    return (1);
  } else {

  }
  return (0);
}
}
int check_card_fail(struct rtsx_chip *chip , unsigned int lun ) 
{ 


  {
  if ((unsigned int )((int )chip->card_fail & (int )chip->lun2card[lun]) != 0U) {
    return (1);
  } else {

  }
  return (0);
}
}
int check_card_ejected(struct rtsx_chip *chip , unsigned int lun ) 
{ 


  {
  if ((unsigned int )((int )chip->card_ejected & (int )chip->lun2card[lun]) != 0U) {
    return (1);
  } else {

  }
  return (0);
}
}
u8 get_lun_card(struct rtsx_chip *chip , unsigned int lun ) 
{ 


  {
  if ((unsigned int )((int )chip->card_ready & (int )chip->lun2card[lun]) == 16U) {
    return (16U);
  } else
  if ((unsigned int )((int )chip->card_ready & (int )chip->lun2card[lun]) == 4U) {
    return (4U);
  } else
  if ((unsigned int )((int )chip->card_ready & (int )chip->lun2card[lun]) == 8U) {
    return (8U);
  } else {

  }
  return (0U);
}
}
void eject_card(struct rtsx_chip *chip , unsigned int lun ) 
{ 


  {
  do_remaining_work(chip);
  if ((unsigned int )((int )chip->card_ready & (int )chip->lun2card[lun]) == 4U) {
    release_sd_card(chip);
    chip->card_ejected = (u8 )((unsigned int )chip->card_ejected | 4U);
    chip->card_ready = (unsigned int )chip->card_ready & 251U;
    chip->capacity[lun] = 0U;
  } else
  if ((unsigned int )((int )chip->card_ready & (int )chip->lun2card[lun]) == 16U) {
    release_xd_card(chip);
    chip->card_ejected = (u8 )((unsigned int )chip->card_ejected | 16U);
    chip->card_ready = (unsigned int )chip->card_ready & 239U;
    chip->capacity[lun] = 0U;
  } else
  if ((unsigned int )((int )chip->card_ready & (int )chip->lun2card[lun]) == 8U) {
    release_ms_card(chip);
    chip->card_ejected = (u8 )((unsigned int )chip->card_ejected | 8U);
    chip->card_ready = (unsigned int )chip->card_ready & 247U;
    chip->capacity[lun] = 0U;
  } else {

  }
  return;
}
}
void ldv_mutex_lock_137(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_lock_lock(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_138(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_unlock_lock(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_139(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
int ldv_mutex_trylock_140(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
  tmp = mutex_trylock(ldv_func_arg1);
  ldv_func_res = tmp;
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
  return (tmp___0);
  return (ldv_func_res);
}
}
void ldv_mutex_unlock_141(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_142(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_unlock_i_mutex_of_inode(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_143(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_lock_i_mutex_of_inode(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
int ldv_scsi_add_host_with_dma_144(struct Scsi_Host *shost , struct device *dev ,
                                   struct device *dma_dev ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  int tmp ;

  {
  tmp = scsi_add_host_with_dma(shost, dev, dma_dev);
  ldv_func_res = tmp;
  if (ldv_func_res == 0) {
    ldv_state_variable_3 = 1;
    ldv_initialize_scsi_host_template_3();
  } else {

  }
  return (ldv_func_res);
}
}
int ldv_mutex_trylock_160(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_158(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_161(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_162(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_157(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_159(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_163(struct mutex *ldv_func_arg1 ) ;
int ldv_scsi_add_host_with_dma_164(struct Scsi_Host *shost , struct device *dev ,
                                   struct device *dma_dev ) ;
int bit1cnt_long(u32 data ) ;
int bit1cnt_long(u32 data ) 
{ 
  int i ;
  int cnt ;

  {
  cnt = 0;
  i = 0;
  goto ldv_38126;
  ldv_38125: ;
  if ((int )data & 1) {
    cnt = cnt + 1;
  } else {

  }
  data = data >> 1;
  i = i + 1;
  ldv_38126: ;
  if (i <= 31) {
    goto ldv_38125;
  } else {

  }

  return (cnt);
}
}
void ldv_mutex_lock_157(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_lock_lock(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_158(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_unlock_lock(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_159(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
int ldv_mutex_trylock_160(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
  tmp = mutex_trylock(ldv_func_arg1);
  ldv_func_res = tmp;
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
  return (tmp___0);
  return (ldv_func_res);
}
}
void ldv_mutex_unlock_161(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_162(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_unlock_i_mutex_of_inode(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_163(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_lock_i_mutex_of_inode(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
int ldv_scsi_add_host_with_dma_164(struct Scsi_Host *shost , struct device *dev ,
                                   struct device *dma_dev ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  int tmp ;

  {
  tmp = scsi_add_host_with_dma(shost, dev, dma_dev);
  ldv_func_res = tmp;
  if (ldv_func_res == 0) {
    ldv_state_variable_3 = 1;
    ldv_initialize_scsi_host_template_3();
  } else {

  }
  return (ldv_func_res);
}
}
__inline static long ldv__builtin_expect(long exp , long c ) ;
int ldv_mutex_trylock_180(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_178(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_181(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_182(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_177(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_179(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_183(struct mutex *ldv_func_arg1 ) ;
int ldv_scsi_add_host_with_dma_184(struct Scsi_Host *shost , struct device *dev ,
                                   struct device *dma_dev ) ;
int sd_select_card(struct rtsx_chip *chip , int select ) ;
int sd_switch_clock(struct rtsx_chip *chip ) ;
void sd_stop_seq_mode(struct rtsx_chip *chip ) ;
int soft_reset_sd_card(struct rtsx_chip *chip ) ;
int ext_sd_send_cmd_get_rsp(struct rtsx_chip *chip , u8 cmd_idx , u32 arg , u8 rsp_type ,
                            u8 *rsp , int rsp_len , bool special_check ) ;
int ext_sd_get_rsp(struct rtsx_chip *chip , int len , u8 *rsp , u8 rsp_type ) ;
__inline static int switch_clock(struct rtsx_chip *chip , int clk ) 
{ 
  int retval ;

  {
  retval = 0;
  if (chip->asic_code != 0) {
    retval = switch_ssc_clock(chip, clk);
  } else {
    retval = switch_normal_clock(chip, clk);
  }
  return (retval);
}
}
__inline static void rtsx_clear_sd_error(struct rtsx_chip *chip ) 
{ 


  {
  rtsx_write_register(chip, 64852, 68, 68);
  return;
}
}
static u16 REG_SD_CFG1  ;
static u16 REG_SD_CFG2  ;
static u16 REG_SD_CFG3  ;
static u16 REG_SD_STAT1  ;
static u16 REG_SD_STAT2  ;
static u16 REG_SD_BUS_STAT  ;
static u16 REG_SD_PAD_CTL  ;
static u16 REG_SD_SAMPLE_POINT_CTL  ;
static u16 REG_SD_PUSH_POINT_CTL  ;
static u16 REG_SD_CMD0  ;
static u16 REG_SD_CMD1  ;
static u16 REG_SD_CMD2  ;
static u16 REG_SD_CMD3  ;
static u16 REG_SD_CMD4  ;
static u16 REG_SD_CMD5  ;
static u16 REG_SD_BYTE_CNT_L  ;
static u16 REG_SD_BYTE_CNT_H  ;
static u16 REG_SD_BLOCK_CNT_L  ;
static u16 REG_SD_BLOCK_CNT_H  ;
static u16 REG_SD_TRANSFER  ;
static u16 REG_SD_VPCLK0_CTL  ;
static u16 REG_SD_VPCLK1_CTL  ;
static u16 REG_SD_DCMPS0_CTL  ;
static u16 REG_SD_DCMPS1_CTL  ;
__inline static void sd_set_err_code(struct rtsx_chip *chip , u8 err_code ) 
{ 
  struct sd_info *sd_card ;

  {
  sd_card = & chip->sd_card;
  sd_card->err_code = (u8 )((int )sd_card->err_code | (int )err_code);
  return;
}
}
__inline static void sd_clr_err_code(struct rtsx_chip *chip ) 
{ 
  struct sd_info *sd_card ;

  {
  sd_card = & chip->sd_card;
  sd_card->err_code = 0U;
  return;
}
}
__inline static int sd_check_err_code(struct rtsx_chip *chip , u8 err_code ) 
{ 
  struct sd_info *sd_card ;

  {
  sd_card = & chip->sd_card;
  return ((int )sd_card->err_code & (int )err_code);
}
}
static void sd_init_reg_addr(struct rtsx_chip *chip ) 
{ 


  {
  REG_SD_CFG1 = 64817U;
  REG_SD_CFG2 = 64819U;
  REG_SD_CFG3 = 64830U;
  REG_SD_STAT1 = 64816U;
  REG_SD_STAT2 = 0U;
  REG_SD_BUS_STAT = 0U;
  REG_SD_PAD_CTL = 0U;
  REG_SD_SAMPLE_POINT_CTL = 0U;
  REG_SD_PUSH_POINT_CTL = 0U;
  REG_SD_CMD0 = 64820U;
  REG_SD_CMD1 = 64821U;
  REG_SD_CMD2 = 64822U;
  REG_SD_CMD3 = 64823U;
  REG_SD_CMD4 = 64824U;
  REG_SD_CMD5 = 64858U;
  REG_SD_BYTE_CNT_L = 64825U;
  REG_SD_BYTE_CNT_H = 64826U;
  REG_SD_BLOCK_CNT_L = 64827U;
  REG_SD_BLOCK_CNT_H = 64828U;
  REG_SD_TRANSFER = 64818U;
  REG_SD_VPCLK0_CTL = 0U;
  REG_SD_VPCLK1_CTL = 0U;
  REG_SD_DCMPS0_CTL = 0U;
  REG_SD_DCMPS1_CTL = 0U;
  return;
}
}
static int sd_check_data0_status(struct rtsx_chip *chip ) 
{ 
  int retval ;
  u8 stat ;

  {
  retval = rtsx_read_register(chip, (int )REG_SD_STAT1, & stat);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "sd_check_data0_status", 113);
    return (retval);
  } else {

  }
  if (((int )stat & 2) == 0) {
    sd_set_err_code(chip, 16);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "sd_check_data0_status", 119);
    return (1);
  } else {

  }
  return (0);
}
}
static int sd_send_cmd_get_rsp(struct rtsx_chip *chip , u8 cmd_idx , u32 arg , u8 rsp_type ,
                               u8 *rsp , int rsp_len ) 
{ 
  struct sd_info *sd_card ;
  int retval ;
  int timeout ;
  u16 reg_addr ;
  u8 *ptr ;
  int stat_idx ;
    klee_make_symbolic(&stat_idx, sizeof(int), "stat_idx");
  int rty_cnt ;
    klee_make_symbolic(&rty_cnt, sizeof(int), "rty_cnt");
  struct _ddebug descriptor ;
  struct device *tmp ;
  long tmp___0 ;
  u8 val ;
  struct _ddebug descriptor___0 ;
  struct device *tmp___1 ;
  long tmp___2 ;
  struct _ddebug descriptor___1 ;
  struct device *tmp___3 ;
  long tmp___4 ;
  u8 *tmp___5 ;
  struct task_struct *tmp___6 ;
  long volatile   __ret ;
  struct task_struct *tmp___7 ;
  struct task_struct *tmp___8 ;
  struct task_struct *tmp___9 ;
  struct task_struct *tmp___10 ;
  struct _ddebug descriptor___2 ;
  struct device *tmp___11 ;
  long tmp___12 ;
  struct _ddebug descriptor___3 ;
  struct device *tmp___13 ;
  long tmp___14 ;
  struct _ddebug descriptor___4 ;
  struct device *tmp___15 ;
  long tmp___16 ;

  {
  sd_card = & chip->sd_card;
  timeout = 100;
  stat_idx = 0;
  rty_cnt = 0;
  sd_clr_err_code(chip);
  descriptor.modname = "rts5208";
  descriptor.function = "sd_send_cmd_get_rsp";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c";
  descriptor.format = "SD/MMC CMD %d, arg = 0x%08x\n";
  descriptor.lineno = 139U;
  descriptor.flags = 0U;
  tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp___0 != 0L) {
    tmp = rtsx_dev((struct rtsx_chip  const  *)chip);
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)tmp, "SD/MMC CMD %d, arg = 0x%08x\n",
                      (int )cmd_idx, arg);
  } else {

  }
  if ((unsigned int )rsp_type == 9U) {
    timeout = 3000;
  } else {

  }
  RTY_SEND_CMD: 
  chip->ci = 0;
  rtsx_add_cmd(chip, 1, (int )REG_SD_CMD0, 255, (int )((unsigned int )cmd_idx | 64U));
  rtsx_add_cmd(chip, 1, (int )REG_SD_CMD1, 255, (int )((unsigned char )(arg >> 24)));
  rtsx_add_cmd(chip, 1, (int )REG_SD_CMD2, 255, (int )((unsigned char )(arg >> 16)));
  rtsx_add_cmd(chip, 1, (int )REG_SD_CMD3, 255, (int )((unsigned char )(arg >> 8)));
  rtsx_add_cmd(chip, 1, (int )REG_SD_CMD4, 255, (int )((unsigned char )arg));
  rtsx_add_cmd(chip, 1, (int )REG_SD_CFG2, 255, (int )rsp_type);
  rtsx_add_cmd(chip, 1, 64859, 1, 1);
  rtsx_add_cmd(chip, 1, (int )REG_SD_TRANSFER, 255, 136);
  rtsx_add_cmd(chip, 2, (int )REG_SD_TRANSFER, 96, 96);
  if ((unsigned int )rsp_type == 2U) {
    reg_addr = 64000U;
    goto ldv_38351;
    ldv_38350: 
    rtsx_add_cmd(chip, 0, (int )reg_addr, 0, 0);
    reg_addr = (u16 )((int )reg_addr + 1);
    ldv_38351: ;
    if ((unsigned int )reg_addr <= 64015U) {
      goto ldv_38350;
    } else {

    }
    stat_idx = 16;
  } else
  if ((unsigned int )rsp_type != 4U) {
    reg_addr = REG_SD_CMD0;
    goto ldv_38354;
    ldv_38353: 
    rtsx_add_cmd(chip, 0, (int )reg_addr, 0, 0);
    reg_addr = (u16 )((int )reg_addr + 1);
    ldv_38354: ;
    if ((int )reg_addr <= (int )REG_SD_CMD4) {
      goto ldv_38353;
    } else {

    }
    stat_idx = 5;
  } else {

  }
  rtsx_add_cmd(chip, 0, (int )REG_SD_STAT1, 0, 0);
  retval = rtsx_send_cmd(chip, 4, timeout);
  if (retval < 0) {
    rtsx_read_register(chip, (int )REG_SD_STAT1, & val);
    descriptor___0.modname = "rts5208";
    descriptor___0.function = "sd_send_cmd_get_rsp";
    descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c";
    descriptor___0.format = "SD_STAT1: 0x%x\n";
    descriptor___0.lineno = 183U;
    descriptor___0.flags = 0U;
    tmp___2 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
    if (tmp___2 != 0L) {
      tmp___1 = rtsx_dev((struct rtsx_chip  const  *)chip);
      __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)tmp___1, "SD_STAT1: 0x%x\n",
                        (int )val);
    } else {

    }
    rtsx_read_register(chip, (int )REG_SD_CFG3, & val);
    descriptor___1.modname = "rts5208";
    descriptor___1.function = "sd_send_cmd_get_rsp";
    descriptor___1.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c";
    descriptor___1.format = "SD_CFG3: 0x%x\n";
    descriptor___1.lineno = 186U;
    descriptor___1.flags = 0U;
    tmp___4 = ldv__builtin_expect((long )descriptor___1.flags & 1L, 0L);
    if (tmp___4 != 0L) {
      tmp___3 = rtsx_dev((struct rtsx_chip  const  *)chip);
      __dynamic_dev_dbg(& descriptor___1, (struct device  const  *)tmp___3, "SD_CFG3: 0x%x\n",
                        (int )val);
    } else {

    }
    if (retval == -110) {
      if (((int )rsp_type & 8) != 0) {
        retval = sd_check_data0_status(chip);
        if (retval != 0) {
          rtsx_clear_sd_error(chip);
          _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                      "sd_send_cmd_get_rsp", 193);
          return (retval);
        } else {

        }
      } else {
        sd_set_err_code(chip, 64);
      }
      retval = 2;
    } else {
      retval = 1;
    }
    rtsx_clear_sd_error(chip);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "sd_send_cmd_get_rsp", 205);
    return (retval);
  } else {

  }
  if ((unsigned int )rsp_type == 4U) {
    return (0);
  } else {

  }
  tmp___5 = rtsx_get_cmd_data(chip);
  ptr = tmp___5 + 1UL;
  if (((int )*ptr & 192) != 0) {
    sd_set_err_code(chip, 8);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "sd_send_cmd_get_rsp", 216);
    return (1);
  } else {

  }
  if (((int )rsp_type & 4) == 0) {
    if ((int )((signed char )*(ptr + (unsigned long )stat_idx)) < 0) {
      if ((unsigned int )cmd_idx == 25U) {
        sd_set_err_code(chip, 128);
        _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                    "sd_send_cmd_get_rsp", 224);
        return (1);
      } else {

      }
      if (rty_cnt <= 2) {
        tmp___6 = get_current();
        tmp___6->task_state_change = 0UL;
        __ret = 1L;
        switch (8UL) {
        case 1UL: 
        tmp___7 = get_current();
        __asm__  volatile   ("xchgb %b0, %1\n": "+q" (__ret), "+m" (tmp___7->state): : "memory",
                             "cc");
        goto ldv_38361;
        case 2UL: 
        tmp___8 = get_current();
        __asm__  volatile   ("xchgw %w0, %1\n": "+r" (__ret), "+m" (tmp___8->state): : "memory",
                             "cc");
        goto ldv_38361;
        case 4UL: 
        tmp___9 = get_current();
        __asm__  volatile   ("xchgl %0, %1\n": "+r" (__ret), "+m" (tmp___9->state): : "memory",
                             "cc");
        goto ldv_38361;
        case 8UL: 
        tmp___10 = get_current();
        __asm__  volatile   ("xchgq %q0, %1\n": "+r" (__ret), "+m" (tmp___10->state): : "memory",
                             "cc");
        goto ldv_38361;
        default: 
        __xchg_wrong_size();
        }
        ldv_38361: 
        schedule_timeout(5L);
        rty_cnt = rty_cnt + 1;
        goto RTY_SEND_CMD;
      } else {
        sd_set_err_code(chip, 128);
        _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                    "sd_send_cmd_get_rsp", 233);
        return (1);
      }
    } else {

    }
  } else {

  }
  if ((unsigned int )rsp_type == 1U || (unsigned int )rsp_type == 9U) {
    if ((unsigned int )cmd_idx != 3U && (unsigned int )cmd_idx != 8U) {
      if ((unsigned int )cmd_idx != 12U) {
        if ((int )((signed char )*(ptr + 1UL)) < 0) {
          _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                      "sd_send_cmd_get_rsp", 244);
          return (1);
        } else {

        }
      } else {

      }
      if (((int )*(ptr + 1UL) & 125) != 0) {
        descriptor___2.modname = "rts5208";
        descriptor___2.function = "sd_send_cmd_get_rsp";
        descriptor___2.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c";
        descriptor___2.format = "ptr[1]: 0x%02x\n";
        descriptor___2.lineno = 255U;
        descriptor___2.flags = 0U;
        tmp___12 = ldv__builtin_expect((long )descriptor___2.flags & 1L, 0L);
        if (tmp___12 != 0L) {
          tmp___11 = rtsx_dev((struct rtsx_chip  const  *)chip);
          __dynamic_dev_dbg(& descriptor___2, (struct device  const  *)tmp___11, "ptr[1]: 0x%02x\n",
                            (int )*(ptr + 1UL));
        } else {

        }
        _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                    "sd_send_cmd_get_rsp", 256);
        return (1);
      } else {

      }
      if ((unsigned int )*(ptr + 2UL) != 0U) {
        descriptor___3.modname = "rts5208";
        descriptor___3.function = "sd_send_cmd_get_rsp";
        descriptor___3.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c";
        descriptor___3.format = "ptr[2]: 0x%02x\n";
        descriptor___3.lineno = 261U;
        descriptor___3.flags = 0U;
        tmp___14 = ldv__builtin_expect((long )descriptor___3.flags & 1L, 0L);
        if (tmp___14 != 0L) {
          tmp___13 = rtsx_dev((struct rtsx_chip  const  *)chip);
          __dynamic_dev_dbg(& descriptor___3, (struct device  const  *)tmp___13, "ptr[2]: 0x%02x\n",
                            (int )*(ptr + 2UL));
        } else {

        }
        _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                    "sd_send_cmd_get_rsp", 262);
        return (1);
      } else {

      }
      if ((int )((signed char )*(ptr + 3UL)) < 0) {
        descriptor___4.modname = "rts5208";
        descriptor___4.function = "sd_send_cmd_get_rsp";
        descriptor___4.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c";
        descriptor___4.format = "ptr[3]: 0x%02x\n";
        descriptor___4.lineno = 267U;
        descriptor___4.flags = 0U;
        tmp___16 = ldv__builtin_expect((long )descriptor___4.flags & 1L, 0L);
        if (tmp___16 != 0L) {
          tmp___15 = rtsx_dev((struct rtsx_chip  const  *)chip);
          __dynamic_dev_dbg(& descriptor___4, (struct device  const  *)tmp___15, "ptr[3]: 0x%02x\n",
                            (int )*(ptr + 3UL));
        } else {

        }
        _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                    "sd_send_cmd_get_rsp", 268);
        return (1);
      } else {

      }
      if ((int )*(ptr + 3UL) & 1) {
        sd_card->sd_data_buf_ready = 1U;
      } else {
        sd_card->sd_data_buf_ready = 0U;
      }
    } else {

    }
  } else {

  }
  if ((unsigned long )rsp != (unsigned long )((u8 *)0U) && rsp_len != 0) {
    memcpy((void *)rsp, (void const   *)ptr, (size_t )rsp_len);
  } else {

  }
  return (0);
}
}
static int sd_read_data(struct rtsx_chip *chip , u8 trans_mode , u8 *cmd , int cmd_len ,
                        u16 byte_cnt , u16 blk_cnt , u8 bus_width , u8 *buf , int buf_len ,
                        int timeout ) 
{ 
  struct sd_info *sd_card ;
  int retval ;
  int i ;
  struct _ddebug descriptor ;
  struct device *tmp ;
  long tmp___0 ;

  {
  sd_card = & chip->sd_card;
  sd_clr_err_code(chip);
  if ((unsigned long )buf == (unsigned long )((u8 *)0U)) {
    buf_len = 0;
  } else {

  }
  if (buf_len > 512) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "sd_read_data", 299);
    return (1);
  } else {

  }
  chip->ci = 0;
  if (cmd_len != 0) {
    descriptor.modname = "rts5208";
    descriptor.function = "sd_read_data";
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c";
    descriptor.format = "SD/MMC CMD %d\n";
    descriptor.lineno = 306U;
    descriptor.flags = 0U;
    tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
    if (tmp___0 != 0L) {
      tmp = rtsx_dev((struct rtsx_chip  const  *)chip);
      __dynamic_dev_dbg(& descriptor, (struct device  const  *)tmp, "SD/MMC CMD %d\n",
                        (int )*cmd + -64);
    } else {

    }
    i = 0;
    goto ldv_38388;
    ldv_38387: 
    rtsx_add_cmd(chip, 1, (int )((u16 )i) + (int )REG_SD_CMD0, 255, (int )*(cmd + (unsigned long )i));
    i = i + 1;
    ldv_38388: ;
    if ((6 < cmd_len ? 6 : cmd_len) > i) {
      goto ldv_38387;
    } else {

    }

  } else {

  }
  rtsx_add_cmd(chip, 1, (int )REG_SD_BYTE_CNT_L, 255, (int )((unsigned char )byte_cnt));
  rtsx_add_cmd(chip, 1, (int )REG_SD_BYTE_CNT_H, 255, (int )((unsigned char )((int )byte_cnt >> 8)));
  rtsx_add_cmd(chip, 1, (int )REG_SD_BLOCK_CNT_L, 255, (int )((unsigned char )blk_cnt));
  rtsx_add_cmd(chip, 1, (int )REG_SD_BLOCK_CNT_H, 255, (int )((unsigned char )((int )blk_cnt >> 8)));
  rtsx_add_cmd(chip, 1, (int )REG_SD_CFG1, 3, (int )bus_width);
  rtsx_add_cmd(chip, 1, (int )REG_SD_CFG2, 255, 1);
  if ((unsigned int )trans_mode != 15U) {
    rtsx_add_cmd(chip, 1, 64859, 1, 1);
  } else {

  }
  rtsx_add_cmd(chip, 1, (int )REG_SD_TRANSFER, 255, (int )((unsigned int )trans_mode | 128U));
  rtsx_add_cmd(chip, 2, (int )REG_SD_TRANSFER, 64, 64);
  retval = rtsx_send_cmd(chip, 4, timeout);
  if (retval < 0) {
    if (retval == -110) {
      sd_send_cmd_get_rsp(chip, 13, sd_card->sd_addr, 1, (u8 *)0U, 0);
    } else {

    }
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "sd_read_data", 341);
    return (1);
  } else {

  }
  if ((unsigned long )buf != (unsigned long )((u8 *)0U) && buf_len != 0) {
    retval = rtsx_read_ppbuf(chip, buf, buf_len);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                  "sd_read_data", 348);
      return (1);
    } else {

    }
  } else {

  }
  return (0);
}
}
static int sd_write_data(struct rtsx_chip *chip , u8 trans_mode , u8 *cmd , int cmd_len ,
                         u16 byte_cnt , u16 blk_cnt , u8 bus_width , u8 *buf , int buf_len ,
                         int timeout ) 
{ 
  struct sd_info *sd_card ;
  int retval ;
  int i ;
  struct _ddebug descriptor ;
  struct device *tmp ;
  long tmp___0 ;

  {
  sd_card = & chip->sd_card;
  sd_clr_err_code(chip);
  if ((unsigned long )buf == (unsigned long )((u8 *)0U)) {
    buf_len = 0;
  } else {

  }
  if (buf_len > 512) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "sd_write_data", 371);
    return (1);
  } else {

  }
  if ((unsigned long )buf != (unsigned long )((u8 *)0U) && buf_len != 0) {
    retval = rtsx_write_ppbuf(chip, buf, buf_len);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                  "sd_write_data", 378);
      return (1);
    } else {

    }
  } else {

  }
  chip->ci = 0;
  if (cmd_len != 0) {
    descriptor.modname = "rts5208";
    descriptor.function = "sd_write_data";
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c";
    descriptor.format = "SD/MMC CMD %d\n";
    descriptor.lineno = 386U;
    descriptor.flags = 0U;
    tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
    if (tmp___0 != 0L) {
      tmp = rtsx_dev((struct rtsx_chip  const  *)chip);
      __dynamic_dev_dbg(& descriptor, (struct device  const  *)tmp, "SD/MMC CMD %d\n",
                        (int )*cmd + -64);
    } else {

    }
    i = 0;
    goto ldv_38408;
    ldv_38407: 
    rtsx_add_cmd(chip, 1, (int )((u16 )i) + (int )REG_SD_CMD0, 255, (int )*(cmd + (unsigned long )i));
    i = i + 1;
    ldv_38408: ;
    if ((6 < cmd_len ? 6 : cmd_len) > i) {
      goto ldv_38407;
    } else {

    }

  } else {

  }
  rtsx_add_cmd(chip, 1, (int )REG_SD_BYTE_CNT_L, 255, (int )((unsigned char )byte_cnt));
  rtsx_add_cmd(chip, 1, (int )REG_SD_BYTE_CNT_H, 255, (int )((unsigned char )((int )byte_cnt >> 8)));
  rtsx_add_cmd(chip, 1, (int )REG_SD_BLOCK_CNT_L, 255, (int )((unsigned char )blk_cnt));
  rtsx_add_cmd(chip, 1, (int )REG_SD_BLOCK_CNT_H, 255, (int )((unsigned char )((int )blk_cnt >> 8)));
  rtsx_add_cmd(chip, 1, (int )REG_SD_CFG1, 3, (int )bus_width);
  rtsx_add_cmd(chip, 1, (int )REG_SD_CFG2, 255, 1);
  rtsx_add_cmd(chip, 1, (int )REG_SD_TRANSFER, 255, (int )((unsigned int )trans_mode | 128U));
  rtsx_add_cmd(chip, 2, (int )REG_SD_TRANSFER, 64, 64);
  retval = rtsx_send_cmd(chip, 4, timeout);
  if (retval < 0) {
    if (retval == -110) {
      sd_send_cmd_get_rsp(chip, 13, sd_card->sd_addr, 1, (u8 *)0U, 0);
    } else {

    }
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "sd_write_data", 419);
    return (1);
  } else {

  }
  return (0);
}
}
static int sd_check_csd(struct rtsx_chip *chip , char check_wp ) 
{ 
  struct sd_info *sd_card ;
  int retval ;
  int i ;
  u8 csd_ver ;
  u8 trans_speed ;
  u8 rsp[16U] ;
  int tmp ;
  struct _ddebug descriptor ;
  struct device *tmp___0 ;
  long tmp___1 ;
  struct _ddebug descriptor___0 ;
  struct device *tmp___2 ;
  long tmp___3 ;
  struct _ddebug descriptor___1 ;
  struct device *tmp___4 ;
  long tmp___5 ;
  u8 blk_size ;
  u8 c_size_mult ;
  u16 c_size ;
  u32 total_sector ;
  struct _ddebug descriptor___2 ;
  struct device *tmp___6 ;
  long tmp___7 ;

  {
  sd_card = & chip->sd_card;
  i = 0;
  goto ldv_38423;
  ldv_38422: 
  tmp = detect_card_cd(chip, 4);
  if (tmp != 0) {
    sd_set_err_code(chip, 32);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "sd_check_csd", 437);
    return (1);
  } else {

  }
  retval = sd_send_cmd_get_rsp(chip, 9, sd_card->sd_addr, 2, (u8 *)(& rsp), 16);
  if (retval == 0) {
    goto ldv_38421;
  } else {

  }
  i = i + 1;
  ldv_38423: ;
  if (i <= 5) {
    goto ldv_38422;
  } else {

  }
  ldv_38421: ;
  if (i == 6) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "sd_check_csd", 448);
    return (1);
  } else {

  }
  memcpy((void *)(& sd_card->raw_csd), (void const   *)(& rsp) + 1U, 15UL);
  descriptor.modname = "rts5208";
  descriptor.function = "sd_check_csd";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c";
  descriptor.format = "CSD Response:\n";
  descriptor.lineno = 454U;
  descriptor.flags = 0U;
  tmp___1 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp___1 != 0L) {
    tmp___0 = rtsx_dev((struct rtsx_chip  const  *)chip);
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)tmp___0, "CSD Response:\n");
  } else {

  }
  descriptor___0.modname = "rts5208";
  descriptor___0.function = "sd_check_csd";
  descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c";
  descriptor___0.format = "%*ph\n";
  descriptor___0.lineno = 455U;
  descriptor___0.flags = 0U;
  tmp___3 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
  if (tmp___3 != 0L) {
    tmp___2 = rtsx_dev((struct rtsx_chip  const  *)chip);
    __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)tmp___2, "%*ph\n",
                      16, (u8 *)(& sd_card->raw_csd));
  } else {

  }
  csd_ver = (int )rsp[1] >> 6;
  descriptor___1.modname = "rts5208";
  descriptor___1.function = "sd_check_csd";
  descriptor___1.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c";
  descriptor___1.format = "csd_ver = %d\n";
  descriptor___1.lineno = 458U;
  descriptor___1.flags = 0U;
  tmp___5 = ldv__builtin_expect((long )descriptor___1.flags & 1L, 0L);
  if (tmp___5 != 0L) {
    tmp___4 = rtsx_dev((struct rtsx_chip  const  *)chip);
    __dynamic_dev_dbg(& descriptor___1, (struct device  const  *)tmp___4, "csd_ver = %d\n",
                      (int )csd_ver);
  } else {

  }
  trans_speed = rsp[4];
  if (((int )trans_speed & 7) == 2) {
    if (((int )trans_speed & 248) > 47) {
      if (chip->asic_code != 0) {
        sd_card->sd_clock = 47;
      } else {
        sd_card->sd_clock = 4;
      }
    } else
    if (((int )trans_speed & 248) == 40) {
      if (chip->asic_code != 0) {
        sd_card->sd_clock = 39;
      } else {
        sd_card->sd_clock = 3;
      }
    } else
    if (((int )trans_speed & 248) == 32) {
      if (chip->asic_code != 0) {
        sd_card->sd_clock = 29;
      } else {
        sd_card->sd_clock = 2;
      }
    } else
    if (((int )trans_speed & 248) > 15) {
      if (chip->asic_code != 0) {
        sd_card->sd_clock = 23;
      } else {
        sd_card->sd_clock = 1;
      }
    } else
    if (((int )trans_speed & 8) > 7) {
      if (chip->asic_code != 0) {
        sd_card->sd_clock = 19;
      } else {
        sd_card->sd_clock = 1;
      }
    } else {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                  "sd_check_csd", 492);
      return (1);
    }
  } else {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "sd_check_csd", 496);
    return (1);
  }
  if (((int )sd_card->sd_type & 255) == 1 && ((int )sd_card->sd_type & 4096) != 0) {
    sd_card->capacity = 0U;
  } else
  if ((((int )sd_card->sd_type & 255) != 0 || ((int )sd_card->sd_type & 4096) == 0) || (unsigned int )csd_ver == 0U) {
    blk_size = (unsigned int )rsp[6] & 15U;
    c_size = ((((unsigned int )((u16 )rsp[7]) & 3U) << 10U) + (unsigned int )((int )((u16 )rsp[8]) << 2U)) + (unsigned int )((u16 )((int )rsp[9] >> 6));
    c_size_mult = ((unsigned int )rsp[10] & 3U) << 1U;
    c_size_mult = ((int )rsp[11] >> 7) + (int )c_size_mult;
    sd_card->capacity = ((unsigned int )((int )c_size + 1) << ((int )c_size_mult + 2)) << ((int )blk_size + -9);
  } else {
    total_sector = 0U;
    total_sector = ((((unsigned int )rsp[8] & 63U) << 16) | ((unsigned int )rsp[9] << 8)) | (unsigned int )rsp[10];
    sd_card->capacity = (total_sector + 1U) << 10;
  }
  if ((int )((signed char )check_wp) != 0) {
    if (((int )rsp[15] & 48) != 0) {
      chip->card_wp = (u8 )((unsigned int )chip->card_wp | 4U);
    } else {

    }
    descriptor___2.modname = "rts5208";
    descriptor___2.function = "sd_check_csd";
    descriptor___2.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c";
    descriptor___2.format = "CSD WP Status: 0x%x\n";
    descriptor___2.lineno = 529U;
    descriptor___2.flags = 0U;
    tmp___7 = ldv__builtin_expect((long )descriptor___2.flags & 1L, 0L);
    if (tmp___7 != 0L) {
      tmp___6 = rtsx_dev((struct rtsx_chip  const  *)chip);
      __dynamic_dev_dbg(& descriptor___2, (struct device  const  *)tmp___6, "CSD WP Status: 0x%x\n",
                        (int )rsp[15]);
    } else {

    }
  } else {

  }
  return (0);
}
}
static int sd_set_sample_push_timing(struct rtsx_chip *chip ) 
{ 
  int retval ;
  struct sd_info *sd_card ;
  u8 val ;

  {
  sd_card = & chip->sd_card;
  val = 0U;
  if ((chip->sd_ctl & 3U) == 1U) {
    val = (u8 )((unsigned int )val | 16U);
  } else {

  }
  if ((chip->sd_ctl & 12U) == 8U) {
    if (chip->asic_code != 0) {
      if ((((int )sd_card->sd_type & 255) == 0 && ((int )sd_card->sd_type & 256) != 0) || (((int )sd_card->sd_type & 255) == 1 && ((int )sd_card->sd_type & 512) != 0)) {
        if (((int )val & 16) != 0) {
          val = (u8 )((unsigned int )val | 4U);
        } else {
          val = (u8 )((unsigned int )val | 8U);
        }
      } else {

      }
    } else
    if (((int )val & 16) != 0) {
      val = (u8 )((unsigned int )val | 4U);
    } else {
      val = (u8 )((unsigned int )val | 8U);
    }
  } else
  if ((chip->sd_ctl & 12U) == 4U) {
    if (((int )val & 16) != 0) {
      val = (u8 )((unsigned int )val | 4U);
    } else {
      val = (u8 )((unsigned int )val | 8U);
    }
  } else {

  }
  retval = rtsx_write_register(chip, (int )REG_SD_CFG1, 28, (int )val);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "sd_set_sample_push_timing", 568);
    return (retval);
  } else {

  }
  return (0);
}
}
static void sd_choose_proper_clock(struct rtsx_chip *chip ) 
{ 
  struct sd_info *sd_card ;

  {
  sd_card = & chip->sd_card;
  if (((int )sd_card->sd_type & 255) == 0 && ((int )sd_card->sd_type & 2048) != 0) {
    if (chip->asic_code != 0) {
      sd_card->sd_clock = chip->asic_sd_sdr104_clk;
    } else {
      sd_card->sd_clock = chip->fpga_sd_sdr104_clk;
    }
  } else
  if (((int )sd_card->sd_type & 255) == 0 && ((int )sd_card->sd_type & 1024) != 0) {
    if (chip->asic_code != 0) {
      sd_card->sd_clock = chip->asic_sd_ddr50_clk;
    } else {
      sd_card->sd_clock = chip->fpga_sd_ddr50_clk;
    }
  } else
  if (((int )sd_card->sd_type & 255) == 0 && ((int )sd_card->sd_type & 512) != 0) {
    if (chip->asic_code != 0) {
      sd_card->sd_clock = chip->asic_sd_sdr50_clk;
    } else {
      sd_card->sd_clock = chip->fpga_sd_sdr50_clk;
    }
  } else
  if (((int )sd_card->sd_type & 255) == 0 && ((int )sd_card->sd_type & 256) != 0) {
    if (chip->asic_code != 0) {
      sd_card->sd_clock = chip->asic_sd_hs_clk;
    } else {
      sd_card->sd_clock = chip->fpga_sd_hs_clk;
    }
  } else
  if ((((int )sd_card->sd_type & 255) == 1 && ((int )sd_card->sd_type & 512) != 0) || (((int )sd_card->sd_type & 255) == 1 && ((int )sd_card->sd_type & 8192) != 0)) {
    if (chip->asic_code != 0) {
      sd_card->sd_clock = chip->asic_mmc_52m_clk;
    } else {
      sd_card->sd_clock = chip->fpga_mmc_52m_clk;
    }
  } else
  if (((int )sd_card->sd_type & 255) == 1 && ((int )sd_card->sd_type & 256) != 0) {
    if (chip->asic_code != 0) {
      sd_card->sd_clock = 48;
    } else {
      sd_card->sd_clock = 4;
    }
  } else {

  }
  return;
}
}
static int sd_set_clock_divider(struct rtsx_chip *chip , u8 clk_div ) 
{ 
  int retval ;
  u8 mask ;
  u8 val ;

  {
  mask = 0U;
  val = 0U;
  mask = 96U;
  if ((unsigned int )clk_div == 0U) {
    val = 0U;
  } else
  if ((unsigned int )clk_div == 128U) {
    val = 64U;
  } else
  if ((unsigned int )clk_div == 192U) {
    val = 32U;
  } else {

  }
  retval = rtsx_write_register(chip, (int )REG_SD_CFG1, (int )mask, (int )val);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "sd_set_clock_divider", 632);
    return (retval);
  } else {

  }
  return (0);
}
}
static int sd_set_init_para(struct rtsx_chip *chip ) 
{ 
  struct sd_info *sd_card ;
  int retval ;

  {
  sd_card = & chip->sd_card;
  retval = sd_set_sample_push_timing(chip);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "sd_set_init_para", 646);
    return (1);
  } else {

  }
  sd_choose_proper_clock(chip);
  retval = switch_clock(chip, sd_card->sd_clock);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "sd_set_init_para", 654);
    return (1);
  } else {

  }
  return (0);
}
}
int sd_select_card(struct rtsx_chip *chip , int select ) 
{ 
  struct sd_info *sd_card ;
  int retval ;
  u8 cmd_idx ;
  u8 cmd_type ;
  u32 addr ;

  {
  sd_card = & chip->sd_card;
  if (select != 0) {
    cmd_idx = 7U;
    cmd_type = 1U;
    addr = sd_card->sd_addr;
  } else {
    cmd_idx = 7U;
    cmd_type = 4U;
    addr = 0U;
  }
  retval = sd_send_cmd_get_rsp(chip, (int )cmd_idx, addr, (int )cmd_type, (u8 *)0U,
                               0);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "sd_select_card", 680);
    return (1);
  } else {

  }
  return (0);
}
}
static int sd_update_lock_status(struct rtsx_chip *chip ) 
{ 
  struct sd_info *sd_card ;
  int retval ;
  u8 rsp[5U] ;
  struct _ddebug descriptor ;
  struct device *tmp ;
  long tmp___0 ;

  {
  sd_card = & chip->sd_card;
  retval = sd_send_cmd_get_rsp(chip, 13, sd_card->sd_addr, 1, (u8 *)(& rsp), 5);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "sd_update_lock_status", 697);
    return (1);
  } else {

  }
  if (((int )rsp[1] & 2) != 0) {
    sd_card->sd_lock_status = (u8 )((unsigned int )sd_card->sd_lock_status | 128U);
  } else {
    sd_card->sd_lock_status = (unsigned int )sd_card->sd_lock_status & 127U;
  }
  descriptor.modname = "rts5208";
  descriptor.function = "sd_update_lock_status";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c";
  descriptor.format = "sd_card->sd_lock_status = 0x%x\n";
  descriptor.lineno = 707U;
  descriptor.flags = 0U;
  tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp___0 != 0L) {
    tmp = rtsx_dev((struct rtsx_chip  const  *)chip);
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)tmp, "sd_card->sd_lock_status = 0x%x\n",
                      (int )sd_card->sd_lock_status);
  } else {

  }
  if ((int )rsp[1] & 1) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "sd_update_lock_status", 710);
    return (1);
  } else {

  }
  return (0);
}
}
static int sd_wait_state_data_ready(struct rtsx_chip *chip , u8 state , u8 data_ready ,
                                    int polling_cnt ) 
{ 
  struct sd_info *sd_card ;
  int retval ;
  int i ;
  u8 rsp[5U] ;

  {
  sd_card = & chip->sd_card;
  i = 0;
  goto ldv_38487;
  ldv_38486: 
  retval = sd_send_cmd_get_rsp(chip, 13, sd_card->sd_addr, 1, (u8 *)(& rsp), 5);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "sd_wait_state_data_ready", 730);
    return (1);
  } else {

  }
  if (((int )rsp[3] & 30) == (int )state && ((int )rsp[3] & 1) == (int )data_ready) {
    return (0);
  } else {

  }
  i = i + 1;
  ldv_38487: ;
  if (i < polling_cnt) {
    goto ldv_38486;
  } else {

  }
  _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
              "sd_wait_state_data_ready", 739);
  return (1);
}
}
static int sd_change_bank_voltage(struct rtsx_chip *chip , u8 voltage ) 
{ 
  int retval ;

  {
  if ((unsigned int )voltage == 0U) {
    if (chip->asic_code != 0) {
      retval = rtsx_write_phy_register(chip, 8, (int )((unsigned int )((u16 )chip->phy_voltage) | 20416U));
      if (retval != 0) {
        _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                    "sd_change_bank_voltage", 753);
        return (1);
      } else {

      }
    } else {
      retval = rtsx_write_register(chip, 64934, 128, 0);
      if (retval != 0) {
        _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                    "sd_change_bank_voltage", 760);
        return (retval);
      } else {

      }
    }
  } else
  if ((unsigned int )voltage == 1U) {
    if (chip->asic_code != 0) {
      retval = rtsx_write_phy_register(chip, 8, (int )((unsigned int )((u16 )chip->phy_voltage) | 19520U));
      if (retval != 0) {
        _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                    "sd_change_bank_voltage", 770);
        return (1);
      } else {

      }
    } else {
      retval = rtsx_write_register(chip, 64934, 128, 128);
      if (retval != 0) {
        _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                    "sd_change_bank_voltage", 778);
        return (retval);
      } else {

      }
    }
  } else {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "sd_change_bank_voltage", 783);
    return (1);
  }
  return (0);
}
}
static int sd_voltage_switch(struct rtsx_chip *chip ) 
{ 
  int retval ;
  u8 stat ;
  struct task_struct *tmp ;
  long volatile   __ret ;
  struct task_struct *tmp___0 ;
  struct task_struct *tmp___1 ;
  struct task_struct *tmp___2 ;
  struct task_struct *tmp___3 ;
  struct task_struct *tmp___4 ;
  long volatile   __ret___0 ;
  struct task_struct *tmp___5 ;
  struct task_struct *tmp___6 ;
  struct task_struct *tmp___7 ;
  struct task_struct *tmp___8 ;
  struct _ddebug descriptor ;
  struct device *tmp___9 ;
  long tmp___10 ;

  {
  retval = rtsx_write_register(chip, 64933, 192, 128);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "sd_voltage_switch", 799);
    return (retval);
  } else {

  }
  retval = sd_send_cmd_get_rsp(chip, 11, 0U, 1, (u8 *)0U, 0);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "sd_voltage_switch", 806);
    return (1);
  } else {

  }
  __udelay((unsigned long )chip->sd_voltage_switch_delay);
  retval = rtsx_read_register(chip, 64933, & stat);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "sd_voltage_switch", 814);
    return (retval);
  } else {

  }
  if (((int )stat & 31) != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "sd_voltage_switch", 819);
    return (1);
  } else {

  }
  retval = rtsx_write_register(chip, 64933, 255, 64);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "sd_voltage_switch", 826);
    return (retval);
  } else {

  }
  retval = sd_change_bank_voltage(chip, 1);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "sd_voltage_switch", 831);
    return (1);
  } else {

  }
  tmp = get_current();
  tmp->task_state_change = 0UL;
  __ret = 1L;
  switch (8UL) {
  case 1UL: 
  tmp___0 = get_current();
  __asm__  volatile   ("xchgb %b0, %1\n": "+q" (__ret), "+m" (tmp___0->state): : "memory",
                       "cc");
  goto ldv_38503;
  case 2UL: 
  tmp___1 = get_current();
  __asm__  volatile   ("xchgw %w0, %1\n": "+r" (__ret), "+m" (tmp___1->state): : "memory",
                       "cc");
  goto ldv_38503;
  case 4UL: 
  tmp___2 = get_current();
  __asm__  volatile   ("xchgl %0, %1\n": "+r" (__ret), "+m" (tmp___2->state): : "memory",
                       "cc");
  goto ldv_38503;
  case 8UL: 
  tmp___3 = get_current();
  __asm__  volatile   ("xchgq %q0, %1\n": "+r" (__ret), "+m" (tmp___3->state): : "memory",
                       "cc");
  goto ldv_38503;
  default: 
  __xchg_wrong_size();
  }
  ldv_38503: 
  schedule_timeout(12L);
  retval = rtsx_write_register(chip, 64933, 255, 128);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "sd_voltage_switch", 840);
    return (retval);
  } else {

  }
  tmp___4 = get_current();
  tmp___4->task_state_change = 0UL;
  __ret___0 = 1L;
  switch (8UL) {
  case 1UL: 
  tmp___5 = get_current();
  __asm__  volatile   ("xchgb %b0, %1\n": "+q" (__ret___0), "+m" (tmp___5->state): : "memory",
                       "cc");
  goto ldv_38511;
  case 2UL: 
  tmp___6 = get_current();
  __asm__  volatile   ("xchgw %w0, %1\n": "+r" (__ret___0), "+m" (tmp___6->state): : "memory",
                       "cc");
  goto ldv_38511;
  case 4UL: 
  tmp___7 = get_current();
  __asm__  volatile   ("xchgl %0, %1\n": "+r" (__ret___0), "+m" (tmp___7->state): : "memory",
                       "cc");
  goto ldv_38511;
  case 8UL: 
  tmp___8 = get_current();
  __asm__  volatile   ("xchgq %q0, %1\n": "+r" (__ret___0), "+m" (tmp___8->state): : "memory",
                       "cc");
  goto ldv_38511;
  default: 
  __xchg_wrong_size();
  }
  ldv_38511: 
  schedule_timeout(2L);
  retval = rtsx_read_register(chip, 64933, & stat);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "sd_voltage_switch", 847);
    return (retval);
  } else {

  }
  if (((int )stat & 31) != 31) {
    descriptor.modname = "rts5208";
    descriptor.function = "sd_voltage_switch";
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c";
    descriptor.format = "SD_BUS_STAT: 0x%x\n";
    descriptor.lineno = 854U;
    descriptor.flags = 0U;
    tmp___10 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
    if (tmp___10 != 0L) {
      tmp___9 = rtsx_dev((struct rtsx_chip  const  *)chip);
      __dynamic_dev_dbg(& descriptor, (struct device  const  *)tmp___9, "SD_BUS_STAT: 0x%x\n",
                        (int )stat);
    } else {

    }
    rtsx_write_register(chip, 64933, 192, 0);
    rtsx_write_register(chip, 64873, 255, 0);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "sd_voltage_switch", 858);
    return (1);
  } else {

  }
  retval = rtsx_write_register(chip, 64933, 192, 0);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "sd_voltage_switch", 865);
    return (retval);
  } else {

  }
  return (0);
}
}
static int sd_reset_dcm(struct rtsx_chip *chip , u8 tune_dir ) 
{ 
  int retval ;

  {
  if ((unsigned int )tune_dir == 1U) {
    retval = rtsx_write_register(chip, 64547, 255, 10);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                  "sd_reset_dcm", 880);
      return (retval);
    } else {

    }
    retval = rtsx_write_register(chip, 64547, 255, 2);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                  "sd_reset_dcm", 885);
      return (retval);
    } else {

    }
  } else {
    retval = rtsx_write_register(chip, 64547, 255, 9);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                  "sd_reset_dcm", 892);
      return (retval);
    } else {

    }
    retval = rtsx_write_register(chip, 64547, 255, 1);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                  "sd_reset_dcm", 897);
      return (retval);
    } else {

    }
  }
  return (0);
}
}
static int sd_change_phase(struct rtsx_chip *chip , u8 sample_point , u8 tune_dir ) 
{ 
  struct sd_info *sd_card ;
  u16 SD_VP_CTL ;
  u16 SD_DCMPS_CTL ;
  u8 val ;
  int retval ;
  bool ddr_rx ;
  struct _ddebug descriptor ;
  struct device *tmp ;
  long tmp___0 ;
  struct _ddebug descriptor___0 ;
  struct device *tmp___1 ;
  long tmp___2 ;
  struct _ddebug descriptor___1 ;
  struct device *tmp___3 ;
  long tmp___4 ;
  u8 *tmp___5 ;
  struct _ddebug descriptor___2 ;
  struct device *tmp___6 ;
  long tmp___7 ;
  struct _ddebug descriptor___3 ;
  struct device *tmp___8 ;
  long tmp___9 ;
  struct task_struct *tmp___10 ;
  long volatile   __ret ;
  struct task_struct *tmp___11 ;
  struct task_struct *tmp___12 ;
  struct task_struct *tmp___13 ;
  struct task_struct *tmp___14 ;

  {
  sd_card = & chip->sd_card;
  ddr_rx = 0;
  descriptor.modname = "rts5208";
  descriptor.function = "sd_change_phase";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c";
  descriptor.format = "sd_change_phase (sample_point = %d, tune_dir = %d)\n";
  descriptor.lineno = 914U;
  descriptor.flags = 0U;
  tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp___0 != 0L) {
    tmp = rtsx_dev((struct rtsx_chip  const  *)chip);
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)tmp, "sd_change_phase (sample_point = %d, tune_dir = %d)\n",
                      (int )sample_point, (int )tune_dir);
  } else {

  }
  if ((unsigned int )tune_dir == 1U) {
    SD_VP_CTL = 64555U;
    SD_DCMPS_CTL = 64557U;
    if (((int )sd_card->sd_type & 255) == 0 && ((int )sd_card->sd_type & 1024) != 0) {
      ddr_rx = 1;
    } else {

    }
  } else {
    SD_VP_CTL = 64554U;
    SD_DCMPS_CTL = 64556U;
  }
  if (chip->asic_code != 0) {
    retval = rtsx_write_register(chip, 64514, 1, 1);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                  "sd_change_phase", 930);
      return (retval);
    } else {

    }
    retval = rtsx_write_register(chip, (int )SD_VP_CTL, 31, (int )sample_point);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                  "sd_change_phase", 936);
      return (retval);
    } else {

    }
    retval = rtsx_write_register(chip, 64554, 64, 0);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                  "sd_change_phase", 942);
      return (retval);
    } else {

    }
    retval = rtsx_write_register(chip, 64554, 64, 64);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                  "sd_change_phase", 948);
      return (retval);
    } else {

    }
    retval = rtsx_write_register(chip, 64514, 1, 0);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                  "sd_change_phase", 953);
      return (retval);
    } else {

    }
  } else {
    rtsx_read_register(chip, (int )SD_VP_CTL, & val);
    descriptor___0.modname = "rts5208";
    descriptor___0.function = "sd_change_phase";
    descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c";
    descriptor___0.format = "SD_VP_CTL: 0x%x\n";
    descriptor___0.lineno = 958U;
    descriptor___0.flags = 0U;
    tmp___2 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
    if (tmp___2 != 0L) {
      tmp___1 = rtsx_dev((struct rtsx_chip  const  *)chip);
      __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)tmp___1, "SD_VP_CTL: 0x%x\n",
                        (int )val);
    } else {

    }
    rtsx_read_register(chip, (int )SD_DCMPS_CTL, & val);
    descriptor___1.modname = "rts5208";
    descriptor___1.function = "sd_change_phase";
    descriptor___1.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c";
    descriptor___1.format = "SD_DCMPS_CTL: 0x%x\n";
    descriptor___1.lineno = 960U;
    descriptor___1.flags = 0U;
    tmp___4 = ldv__builtin_expect((long )descriptor___1.flags & 1L, 0L);
    if (tmp___4 != 0L) {
      tmp___3 = rtsx_dev((struct rtsx_chip  const  *)chip);
      __dynamic_dev_dbg(& descriptor___1, (struct device  const  *)tmp___3, "SD_DCMPS_CTL: 0x%x\n",
                        (int )val);
    } else {

    }
    if ((int )ddr_rx) {
      retval = rtsx_write_register(chip, (int )SD_VP_CTL, 128, 128);
      if (retval != 0) {
        _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                    "sd_change_phase", 967);
        return (retval);
      } else {

      }
      __const_udelay(214750UL);
      retval = rtsx_write_register(chip, (int )SD_VP_CTL, 255, (int )((unsigned int )sample_point | 192U));
      if (retval != 0) {
        _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                    "sd_change_phase", 974);
        return (retval);
      } else {

      }
    } else {
      retval = rtsx_write_register(chip, 64514, 1, 1);
      if (retval != 0) {
        _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                    "sd_change_phase", 981);
        return (retval);
      } else {

      }
      __const_udelay(214750UL);
      retval = rtsx_write_register(chip, (int )SD_VP_CTL, 255, (int )((unsigned int )sample_point | 64U));
      if (retval != 0) {
        _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                    "sd_change_phase", 988);
        return (retval);
      } else {

      }
    }
    __const_udelay(429500UL);
    chip->ci = 0;
    rtsx_add_cmd(chip, 1, (int )SD_DCMPS_CTL, 128, 128);
    rtsx_add_cmd(chip, 2, (int )SD_DCMPS_CTL, 64, 64);
    retval = rtsx_send_cmd(chip, 4, 100);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                  "sd_change_phase", 1001);
      goto Fail;
    } else {

    }
    tmp___5 = rtsx_get_cmd_data(chip);
    val = *tmp___5;
    if (((int )val & 32) != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                  "sd_change_phase", 1007);
      goto Fail;
    } else {

    }
    if (((int )val & 31) != (int )sample_point) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                  "sd_change_phase", 1012);
      goto Fail;
    } else {

    }
    retval = rtsx_write_register(chip, (int )SD_DCMPS_CTL, 128, 0);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                  "sd_change_phase", 1019);
      return (retval);
    } else {

    }
    if ((int )ddr_rx) {
      retval = rtsx_write_register(chip, (int )SD_VP_CTL, 128, 0);
      if (retval != 0) {
        _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                    "sd_change_phase", 1026);
        return (retval);
      } else {

      }
    } else {
      retval = rtsx_write_register(chip, 64514, 1, 0);
      if (retval != 0) {
        _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                    "sd_change_phase", 1033);
        return (retval);
      } else {

      }
    }
    __const_udelay(214750UL);
  }
  retval = rtsx_write_register(chip, 64928, 16, 0);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "sd_change_phase", 1043);
    return (retval);
  } else {

  }
  return (0);
  Fail: 
  rtsx_read_register(chip, (int )SD_VP_CTL, & val);
  descriptor___2.modname = "rts5208";
  descriptor___2.function = "sd_change_phase";
  descriptor___2.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c";
  descriptor___2.format = "SD_VP_CTL: 0x%x\n";
  descriptor___2.lineno = 1051U;
  descriptor___2.flags = 0U;
  tmp___7 = ldv__builtin_expect((long )descriptor___2.flags & 1L, 0L);
  if (tmp___7 != 0L) {
    tmp___6 = rtsx_dev((struct rtsx_chip  const  *)chip);
    __dynamic_dev_dbg(& descriptor___2, (struct device  const  *)tmp___6, "SD_VP_CTL: 0x%x\n",
                      (int )val);
  } else {

  }
  rtsx_read_register(chip, (int )SD_DCMPS_CTL, & val);
  descriptor___3.modname = "rts5208";
  descriptor___3.function = "sd_change_phase";
  descriptor___3.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c";
  descriptor___3.format = "SD_DCMPS_CTL: 0x%x\n";
  descriptor___3.lineno = 1053U;
  descriptor___3.flags = 0U;
  tmp___9 = ldv__builtin_expect((long )descriptor___3.flags & 1L, 0L);
  if (tmp___9 != 0L) {
    tmp___8 = rtsx_dev((struct rtsx_chip  const  *)chip);
    __dynamic_dev_dbg(& descriptor___3, (struct device  const  *)tmp___8, "SD_DCMPS_CTL: 0x%x\n",
                      (int )val);
  } else {

  }
  rtsx_write_register(chip, (int )SD_DCMPS_CTL, 128, 0);
  rtsx_write_register(chip, (int )SD_VP_CTL, 128, 0);
  tmp___10 = get_current();
  tmp___10->task_state_change = 0UL;
  __ret = 1L;
  switch (8UL) {
  case 1UL: 
  tmp___11 = get_current();
  __asm__  volatile   ("xchgb %b0, %1\n": "+q" (__ret), "+m" (tmp___11->state): : "memory",
                       "cc");
  goto ldv_38544;
  case 2UL: 
  tmp___12 = get_current();
  __asm__  volatile   ("xchgw %w0, %1\n": "+r" (__ret), "+m" (tmp___12->state): : "memory",
                       "cc");
  goto ldv_38544;
  case 4UL: 
  tmp___13 = get_current();
  __asm__  volatile   ("xchgl %0, %1\n": "+r" (__ret), "+m" (tmp___13->state): : "memory",
                       "cc");
  goto ldv_38544;
  case 8UL: 
  tmp___14 = get_current();
  __asm__  volatile   ("xchgq %q0, %1\n": "+r" (__ret), "+m" (tmp___14->state): : "memory",
                       "cc");
  goto ldv_38544;
  default: 
  __xchg_wrong_size();
  }
  ldv_38544: 
  schedule_timeout(2L);
  sd_reset_dcm(chip, (int )tune_dir);
  return (1);
}
}
static int sd_check_spec(struct rtsx_chip *chip , u8 bus_width ) 
{ 
  struct sd_info *sd_card ;
  int retval ;
  u8 cmd[5U] ;
  u8 buf[8U] ;

  {
  sd_card = & chip->sd_card;
  retval = sd_send_cmd_get_rsp(chip, 55, sd_card->sd_addr, 1, (u8 *)0U, 0);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "sd_check_spec", 1071);
    return (1);
  } else {

  }
  cmd[0] = 115U;
  cmd[1] = 0U;
  cmd[2] = 0U;
  cmd[3] = 0U;
  cmd[4] = 0U;
  retval = sd_read_data(chip, 12, (u8 *)(& cmd), 5, 8, 1, (int )bus_width, (u8 *)(& buf),
                        8, 250);
  if (retval != 0) {
    rtsx_clear_sd_error(chip);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "sd_check_spec", 1085);
    return (1);
  } else {

  }
  memcpy((void *)(& sd_card->raw_scr), (void const   *)(& buf), 8UL);
  if (((int )buf[0] & 15) == 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "sd_check_spec", 1092);
    return (1);
  } else {

  }
  return (0);
}
}
static int sd_query_switch_result(struct rtsx_chip *chip , u8 func_group , u8 func_to_switch ,
                                  u8 *buf , int buf_len ) 
{ 
  u8 support_mask ;
  u8 query_switch ;
  u8 switch_busy ;
  int support_offset ;
    klee_make_symbolic(&support_offset, sizeof(int), "support_offset");
  int query_switch_offset ;
    klee_make_symbolic(&query_switch_offset, sizeof(int), "query_switch_offset");
  int check_busy_offset ;
    klee_make_symbolic(&check_busy_offset, sizeof(int), "check_busy_offset");

  {
  support_mask = 0U;
  query_switch = 0U;
  switch_busy = 0U;
  support_offset = 0;
  query_switch_offset = 0;
  check_busy_offset = 0;
  if ((unsigned int )func_group == 1U) {
    support_offset = 13;
    query_switch_offset = 16;
    check_busy_offset = 29;
    switch ((int )func_to_switch) {
    case 1: 
    support_mask = 2U;
    query_switch = 1U;
    switch_busy = 2U;
    goto ldv_38573;
    case 2: 
    support_mask = 4U;
    query_switch = 2U;
    switch_busy = 4U;
    goto ldv_38573;
    case 3: 
    support_mask = 8U;
    query_switch = 3U;
    switch_busy = 8U;
    goto ldv_38573;
    case 4: 
    support_mask = 16U;
    query_switch = 4U;
    switch_busy = 16U;
    goto ldv_38573;
    default: 
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "sd_query_switch_result", 1136);
    return (1);
    }
    ldv_38573: ;
  } else
  if ((unsigned int )func_group == 3U) {
    support_offset = 9;
    query_switch_offset = 15;
    check_busy_offset = 25;
    switch ((int )func_to_switch) {
    case 1: 
    support_mask = 2U;
    query_switch = 1U;
    switch_busy = 2U;
    goto ldv_38580;
    case 2: 
    support_mask = 4U;
    query_switch = 2U;
    switch_busy = 4U;
    goto ldv_38580;
    case 3: 
    support_mask = 8U;
    query_switch = 3U;
    switch_busy = 8U;
    goto ldv_38580;
    default: 
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "sd_query_switch_result", 1164);
    return (1);
    }
    ldv_38580: ;
  } else
  if ((unsigned int )func_group == 4U) {
    support_offset = 7;
    query_switch_offset = 15;
    check_busy_offset = 23;
    switch ((int )func_to_switch) {
    case 1: 
    support_mask = 2U;
    query_switch = 1U;
    switch_busy = 2U;
    goto ldv_38585;
    case 2: 
    support_mask = 4U;
    query_switch = 2U;
    switch_busy = 4U;
    goto ldv_38585;
    case 3: 
    support_mask = 8U;
    query_switch = 3U;
    switch_busy = 8U;
    goto ldv_38585;
    default: 
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "sd_query_switch_result", 1192);
    return (1);
    }
    ldv_38585: ;
  } else {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "sd_query_switch_result", 1196);
    return (1);
  }
  if ((unsigned int )func_group == 1U) {
    if ((unsigned int )((int )*(buf + (unsigned long )support_offset) & (int )support_mask) == 0U || ((int )*(buf + (unsigned long )query_switch_offset) & 15) != (int )query_switch) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                  "sd_query_switch_result", 1203);
      return (1);
    } else {

    }
  } else {

  }
  if ((unsigned int )*(buf + 17UL) == 1U && ((int )*(buf + (unsigned long )check_busy_offset) & (int )switch_busy) == (int )switch_busy) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "sd_query_switch_result", 1211);
    return (1);
  } else {

  }
  return (0);
}
}
static int sd_check_switch_mode(struct rtsx_chip *chip , u8 mode , u8 func_group ,
                                u8 func_to_switch , u8 bus_width ) 
{ 
  struct sd_info *sd_card ;
  int retval ;
  u8 cmd[5U] ;
  u8 buf[64U] ;
  struct _ddebug descriptor ;
  struct device *tmp ;
  long tmp___0 ;
  struct _ddebug descriptor___0 ;
  struct device *tmp___1 ;
  long tmp___2 ;
  struct _ddebug descriptor___1 ;
  struct device *tmp___3 ;
  long tmp___4 ;
  struct _ddebug descriptor___2 ;
  struct device *tmp___5 ;
  long tmp___6 ;
  struct _ddebug descriptor___3 ;
  struct device *tmp___7 ;
  long tmp___8 ;
  struct _ddebug descriptor___4 ;
  struct device *tmp___9 ;
  long tmp___10 ;
  u16 cc ;
  struct _ddebug descriptor___5 ;
  struct device *tmp___11 ;
  long tmp___12 ;

  {
  sd_card = & chip->sd_card;
  descriptor.modname = "rts5208";
  descriptor.function = "sd_check_switch_mode";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c";
  descriptor.format = "sd_check_switch_mode (mode = %d, func_group = %d, func_to_switch = %d)\n";
  descriptor.lineno = 1226U;
  descriptor.flags = 0U;
  tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp___0 != 0L) {
    tmp = rtsx_dev((struct rtsx_chip  const  *)chip);
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)tmp, "sd_check_switch_mode (mode = %d, func_group = %d, func_to_switch = %d)\n",
                      (int )mode, (int )func_group, (int )func_to_switch);
  } else {

  }
  cmd[0] = 70U;
  cmd[1] = mode;
  if ((unsigned int )func_group == 1U) {
    cmd[2] = 255U;
    cmd[3] = 255U;
    cmd[4] = (unsigned int )func_to_switch + 240U;
  } else
  if ((unsigned int )func_group == 3U) {
    cmd[2] = 255U;
    cmd[3] = (unsigned int )func_to_switch + 240U;
    cmd[4] = 255U;
  } else
  if ((unsigned int )func_group == 4U) {
    cmd[2] = 255U;
    cmd[3] = (unsigned int )((int )func_to_switch << 4U) + 15U;
    cmd[4] = 255U;
  } else {
    cmd[1] = 0U;
    cmd[2] = 255U;
    cmd[3] = 255U;
    cmd[4] = 255U;
  }
  retval = sd_read_data(chip, 12, (u8 *)(& cmd), 5, 64, 1, (int )bus_width, (u8 *)(& buf),
                        64, 250);
  if (retval != 0) {
    rtsx_clear_sd_error(chip);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "sd_check_switch_mode", 1254);
    return (1);
  } else {

  }
  descriptor___0.modname = "rts5208";
  descriptor___0.function = "sd_check_switch_mode";
  descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c";
  descriptor___0.format = "%*ph\n";
  descriptor___0.lineno = 1258U;
  descriptor___0.flags = 0U;
  tmp___2 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
  if (tmp___2 != 0L) {
    tmp___1 = rtsx_dev((struct rtsx_chip  const  *)chip);
    __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)tmp___1, "%*ph\n",
                      64, (u8 *)(& buf));
  } else {

  }
  if ((unsigned int )func_group == 0U) {
    sd_card->func_group1_mask = buf[13];
    sd_card->func_group2_mask = buf[11];
    sd_card->func_group3_mask = buf[9];
    sd_card->func_group4_mask = buf[7];
    descriptor___1.modname = "rts5208";
    descriptor___1.function = "sd_check_switch_mode";
    descriptor___1.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c";
    descriptor___1.format = "func_group1_mask = 0x%02x\n";
    descriptor___1.lineno = 1267U;
    descriptor___1.flags = 0U;
    tmp___4 = ldv__builtin_expect((long )descriptor___1.flags & 1L, 0L);
    if (tmp___4 != 0L) {
      tmp___3 = rtsx_dev((struct rtsx_chip  const  *)chip);
      __dynamic_dev_dbg(& descriptor___1, (struct device  const  *)tmp___3, "func_group1_mask = 0x%02x\n",
                        (int )buf[13]);
    } else {

    }
    descriptor___2.modname = "rts5208";
    descriptor___2.function = "sd_check_switch_mode";
    descriptor___2.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c";
    descriptor___2.format = "func_group2_mask = 0x%02x\n";
    descriptor___2.lineno = 1269U;
    descriptor___2.flags = 0U;
    tmp___6 = ldv__builtin_expect((long )descriptor___2.flags & 1L, 0L);
    if (tmp___6 != 0L) {
      tmp___5 = rtsx_dev((struct rtsx_chip  const  *)chip);
      __dynamic_dev_dbg(& descriptor___2, (struct device  const  *)tmp___5, "func_group2_mask = 0x%02x\n",
                        (int )buf[11]);
    } else {

    }
    descriptor___3.modname = "rts5208";
    descriptor___3.function = "sd_check_switch_mode";
    descriptor___3.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c";
    descriptor___3.format = "func_group3_mask = 0x%02x\n";
    descriptor___3.lineno = 1271U;
    descriptor___3.flags = 0U;
    tmp___8 = ldv__builtin_expect((long )descriptor___3.flags & 1L, 0L);
    if (tmp___8 != 0L) {
      tmp___7 = rtsx_dev((struct rtsx_chip  const  *)chip);
      __dynamic_dev_dbg(& descriptor___3, (struct device  const  *)tmp___7, "func_group3_mask = 0x%02x\n",
                        (int )buf[9]);
    } else {

    }
    descriptor___4.modname = "rts5208";
    descriptor___4.function = "sd_check_switch_mode";
    descriptor___4.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c";
    descriptor___4.format = "func_group4_mask = 0x%02x\n";
    descriptor___4.lineno = 1273U;
    descriptor___4.flags = 0U;
    tmp___10 = ldv__builtin_expect((long )descriptor___4.flags & 1L, 0L);
    if (tmp___10 != 0L) {
      tmp___9 = rtsx_dev((struct rtsx_chip  const  *)chip);
      __dynamic_dev_dbg(& descriptor___4, (struct device  const  *)tmp___9, "func_group4_mask = 0x%02x\n",
                        (int )buf[7]);
    } else {

    }
  } else {
    cc = (u16 )((int )((short )((int )buf[0] << 8)) | (int )((short )buf[1]));
    descriptor___5.modname = "rts5208";
    descriptor___5.function = "sd_check_switch_mode";
    descriptor___5.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c";
    descriptor___5.format = "Maximum current consumption: %dmA\n";
    descriptor___5.lineno = 1281U;
    descriptor___5.flags = 0U;
    tmp___12 = ldv__builtin_expect((long )descriptor___5.flags & 1L, 0L);
    if (tmp___12 != 0L) {
      tmp___11 = rtsx_dev((struct rtsx_chip  const  *)chip);
      __dynamic_dev_dbg(& descriptor___5, (struct device  const  *)tmp___11, "Maximum current consumption: %dmA\n",
                        (int )cc);
    } else {

    }
    if ((unsigned int )cc == 0U || (unsigned int )cc > 800U) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                  "sd_check_switch_mode", 1283);
      return (1);
    } else {

    }
    retval = sd_query_switch_result(chip, (int )func_group, (int )func_to_switch,
                                    (u8 *)(& buf), 64);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                  "sd_check_switch_mode", 1290);
      return (1);
    } else {

    }
    if ((unsigned int )cc > 400U || (unsigned int )func_to_switch > 1U) {
      retval = rtsx_write_register(chip, 64537, 7, (int )chip->sd_800mA_ocp_thd);
      if (retval != 0) {
        _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                    "sd_check_switch_mode", 1299);
        return (retval);
      } else {

      }
      retval = rtsx_write_register(chip, 64848, 16, 16);
      if (retval != 0) {
        _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                    "sd_check_switch_mode", 1306);
        return (retval);
      } else {

      }
    } else {

    }
  }
  return (0);
}
}
static u8 downgrade_switch_mode(u8 func_group , u8 func_to_switch ) 
{ 


  {
  if ((unsigned int )func_group == 1U) {
    if ((unsigned int )func_to_switch > 1U) {
      func_to_switch = (u8 )((int )func_to_switch - 1);
    } else {

    }
  } else
  if ((unsigned int )func_group == 4U) {
    if ((unsigned int )func_to_switch != 0U) {
      func_to_switch = (u8 )((int )func_to_switch - 1);
    } else {

    }
  } else {

  }
  return (func_to_switch);
}
}
static int sd_check_switch(struct rtsx_chip *chip , u8 func_group , u8 func_to_switch ,
                           u8 bus_width ) 
{ 
  int retval ;
  int i ;
  bool switch_good ;
  int tmp ;
  u8 stat ;
  struct _ddebug descriptor ;
  struct device *tmp___0 ;
  long tmp___1 ;
  struct task_struct *tmp___2 ;
  long volatile   __ret ;
  struct task_struct *tmp___3 ;
  struct task_struct *tmp___4 ;
  struct task_struct *tmp___5 ;
  struct task_struct *tmp___6 ;

  {
  switch_good = 0;
  i = 0;
  goto ldv_38635;
  ldv_38634: 
  tmp = detect_card_cd(chip, 4);
  if (tmp != 0) {
    sd_set_err_code(chip, 32);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "sd_check_switch", 1339);
    return (1);
  } else {

  }
  retval = sd_check_switch_mode(chip, 0, (int )func_group, (int )func_to_switch, (int )bus_width);
  if (retval == 0) {
    retval = sd_check_switch_mode(chip, 128, (int )func_group, (int )func_to_switch,
                                  (int )bus_width);
    if (retval == 0) {
      switch_good = 1;
      goto ldv_38624;
    } else {

    }
    retval = rtsx_read_register(chip, 64931, & stat);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                  "sd_check_switch", 1357);
      return (retval);
    } else {

    }
    if (((int )stat & 64) != 0) {
      descriptor.modname = "rts5208";
      descriptor.function = "sd_check_switch";
      descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c";
      descriptor.format = "SD CRC16 error when switching mode\n";
      descriptor.lineno = 1361U;
      descriptor.flags = 0U;
      tmp___1 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
      if (tmp___1 != 0L) {
        tmp___0 = rtsx_dev((struct rtsx_chip  const  *)chip);
        __dynamic_dev_dbg(& descriptor, (struct device  const  *)tmp___0, "SD CRC16 error when switching mode\n");
      } else {

      }
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                  "sd_check_switch", 1362);
      return (1);
    } else {

    }
  } else {

  }
  func_to_switch = downgrade_switch_mode((int )func_group, (int )func_to_switch);
  tmp___2 = get_current();
  tmp___2->task_state_change = 0UL;
  __ret = 1L;
  switch (8UL) {
  case 1UL: 
  tmp___3 = get_current();
  __asm__  volatile   ("xchgb %b0, %1\n": "+q" (__ret), "+m" (tmp___3->state): : "memory",
                       "cc");
  goto ldv_38628;
  case 2UL: 
  tmp___4 = get_current();
  __asm__  volatile   ("xchgw %w0, %1\n": "+r" (__ret), "+m" (tmp___4->state): : "memory",
                       "cc");
  goto ldv_38628;
  case 4UL: 
  tmp___5 = get_current();
  __asm__  volatile   ("xchgl %0, %1\n": "+r" (__ret), "+m" (tmp___5->state): : "memory",
                       "cc");
  goto ldv_38628;
  case 8UL: 
  tmp___6 = get_current();
  __asm__  volatile   ("xchgq %q0, %1\n": "+r" (__ret), "+m" (tmp___6->state): : "memory",
                       "cc");
  goto ldv_38628;
  default: 
  __xchg_wrong_size();
  }
  ldv_38628: 
  schedule_timeout(5L);
  i = i + 1;
  ldv_38635: ;
  if (i <= 2) {
    goto ldv_38634;
  } else {

  }
  ldv_38624: ;
  if (! switch_good) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "sd_check_switch", 1374);
    return (1);
  } else {

  }
  return (0);
}
}
static int sd_switch_function(struct rtsx_chip *chip , u8 bus_width ) 
{ 
  struct sd_info *sd_card ;
  int retval ;
  int i ;
  u8 func_to_switch ;
  struct _ddebug descriptor ;
  struct device *tmp ;
  long tmp___0 ;
  struct _ddebug descriptor___0 ;
  struct device *tmp___1 ;
  long tmp___2 ;
  struct _ddebug descriptor___1 ;
  struct device *tmp___3 ;
  long tmp___4 ;
  int tmp___5 ;
  struct _ddebug descriptor___2 ;
  struct device *tmp___6 ;
  long tmp___7 ;

  {
  sd_card = & chip->sd_card;
  func_to_switch = 0U;
  retval = sd_check_switch_mode(chip, 0, 0, 0, (int )bus_width);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "sd_switch_function", 1392);
    return (1);
  } else {

  }
  sd_card->func_group1_mask = (u8 )((int )((signed char )sd_card->func_group1_mask) & ~ ((int )((signed char )sd_card->sd_switch_fail)));
  i = 0;
  goto ldv_38654;
  ldv_38653: ;
  switch ((int )((unsigned char )(chip->sd_speed_prior >> i * 8))) {
  case 3: ;
  if (((int )sd_card->func_group1_mask & 8) != 0 && chip->sdr104_en != 0) {
    func_to_switch = 3U;
  } else {

  }
  goto ldv_38646;
  case 4: ;
  if (((int )sd_card->func_group1_mask & 16) != 0 && chip->ddr50_en != 0) {
    func_to_switch = 4U;
  } else {

  }
  goto ldv_38646;
  case 2: ;
  if (((int )sd_card->func_group1_mask & 4) != 0 && chip->sdr50_en != 0) {
    func_to_switch = 2U;
  } else {

  }
  goto ldv_38646;
  case 1: ;
  if (((int )sd_card->func_group1_mask & 2) != 0) {
    func_to_switch = 1U;
  } else {

  }
  goto ldv_38646;
  default: ;
  goto ldv_38651;
  }
  ldv_38646: ;
  if ((unsigned int )func_to_switch != 0U) {
    goto ldv_38652;
  } else {

  }
  ldv_38651: 
  i = i + 1;
  ldv_38654: ;
  if (i <= 3) {
    goto ldv_38653;
  } else {

  }
  ldv_38652: 
  descriptor.modname = "rts5208";
  descriptor.function = "sd_switch_function";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c";
  descriptor.format = "SD_FUNC_GROUP_1: func_to_switch = 0x%02x";
  descriptor.lineno = 1438U;
  descriptor.flags = 0U;
  tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp___0 != 0L) {
    tmp = rtsx_dev((struct rtsx_chip  const  *)chip);
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)tmp, "SD_FUNC_GROUP_1: func_to_switch = 0x%02x",
                      (int )func_to_switch);
  } else {

  }
  if ((((int )sd_card->sd_lock_status & 2) != 0 && (unsigned int )func_to_switch == 4U) && ((int )sd_card->func_group1_mask & 4) != 0) {
    func_to_switch = 2U;
    descriptor___0.modname = "rts5208";
    descriptor___0.function = "sd_switch_function";
    descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c";
    descriptor___0.format = "Using SDR50 instead of DDR50 for SD Lock\n";
    descriptor___0.lineno = 1445U;
    descriptor___0.flags = 0U;
    tmp___2 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
    if (tmp___2 != 0L) {
      tmp___1 = rtsx_dev((struct rtsx_chip  const  *)chip);
      __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)tmp___1, "Using SDR50 instead of DDR50 for SD Lock\n");
    } else {

    }
  } else {

  }
  if ((unsigned int )func_to_switch != 0U) {
    retval = sd_check_switch(chip, 1, (int )func_to_switch, (int )bus_width);
    if (retval != 0) {
      if ((unsigned int )func_to_switch == 3U) {
        sd_card->sd_switch_fail = 8U;
      } else
      if ((unsigned int )func_to_switch == 4U) {
        sd_card->sd_switch_fail = 24U;
      } else
      if ((unsigned int )func_to_switch == 2U) {
        sd_card->sd_switch_fail = 28U;
      } else {

      }
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                  "sd_switch_function", 1462);
      return (1);
    } else {

    }
    if ((unsigned int )func_to_switch == 3U) {
      sd_card->sd_type = (u16 )((unsigned int )sd_card->sd_type | 2048U);
    } else
    if ((unsigned int )func_to_switch == 4U) {
      sd_card->sd_type = (u16 )((unsigned int )sd_card->sd_type | 1024U);
    } else
    if ((unsigned int )func_to_switch == 2U) {
      sd_card->sd_type = (u16 )((unsigned int )sd_card->sd_type | 512U);
    } else {
      sd_card->sd_type = (u16 )((unsigned int )sd_card->sd_type | 256U);
    }
  } else {

  }
  if (((int )sd_card->sd_type & 255) == 0 && ((int )sd_card->sd_type & 1024) != 0) {
    retval = rtsx_write_register(chip, 64936, 6, 4);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                  "sd_switch_function", 1480);
      return (retval);
    } else {

    }
    retval = sd_set_sample_push_timing(chip);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                  "sd_switch_function", 1485);
      return (1);
    } else {

    }
  } else {

  }
  if ((unsigned int )func_to_switch == 0U || (unsigned int )func_to_switch == 1U) {
    return (0);
  } else {

  }
  func_to_switch = 255U;
  i = 0;
  goto ldv_38666;
  ldv_38665: ;
  switch ((int )((unsigned char )(chip->sd_current_prior >> i * 8))) {
  case 3: ;
  if (((int )sd_card->func_group4_mask & 8) != 0) {
    func_to_switch = 3U;
  } else {

  }
  goto ldv_38658;
  case 2: ;
  if (((int )sd_card->func_group4_mask & 4) != 0) {
    func_to_switch = 2U;
  } else {

  }
  goto ldv_38658;
  case 1: ;
  if (((int )sd_card->func_group4_mask & 2) != 0) {
    func_to_switch = 1U;
  } else {

  }
  goto ldv_38658;
  case 0: ;
  if ((int )sd_card->func_group4_mask & 1) {
    func_to_switch = 0U;
  } else {

  }
  goto ldv_38658;
  default: ;
  goto ldv_38663;
  }
  ldv_38658: ;
  if ((unsigned int )func_to_switch != 255U) {
    goto ldv_38664;
  } else {

  }
  ldv_38663: 
  i = i + 1;
  ldv_38666: ;
  if (i <= 3) {
    goto ldv_38665;
  } else {

  }
  ldv_38664: 
  descriptor___1.modname = "rts5208";
  descriptor___1.function = "sd_switch_function";
  descriptor___1.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c";
  descriptor___1.format = "SD_FUNC_GROUP_4: func_to_switch = 0x%02x";
  descriptor___1.lineno = 1535U;
  descriptor___1.flags = 0U;
  tmp___4 = ldv__builtin_expect((long )descriptor___1.flags & 1L, 0L);
  if (tmp___4 != 0L) {
    tmp___3 = rtsx_dev((struct rtsx_chip  const  *)chip);
    __dynamic_dev_dbg(& descriptor___1, (struct device  const  *)tmp___3, "SD_FUNC_GROUP_4: func_to_switch = 0x%02x",
                      (int )func_to_switch);
  } else {

  }
  if ((unsigned int )func_to_switch <= 3U) {
    retval = sd_check_switch(chip, 4, (int )func_to_switch, (int )bus_width);
    if (retval != 0) {
      tmp___5 = sd_check_err_code(chip, 32);
      if (tmp___5 != 0) {
        _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                    "sd_switch_function", 1542);
        return (1);
      } else {

      }
    } else {

    }
    descriptor___2.modname = "rts5208";
    descriptor___2.function = "sd_switch_function";
    descriptor___2.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c";
    descriptor___2.format = "Switch current limit finished! (%d)\n";
    descriptor___2.lineno = 1547U;
    descriptor___2.flags = 0U;
    tmp___7 = ldv__builtin_expect((long )descriptor___2.flags & 1L, 0L);
    if (tmp___7 != 0L) {
      tmp___6 = rtsx_dev((struct rtsx_chip  const  *)chip);
      __dynamic_dev_dbg(& descriptor___2, (struct device  const  *)tmp___6, "Switch current limit finished! (%d)\n",
                        retval);
    } else {

    }
  } else {

  }
  if (((int )sd_card->sd_type & 255) == 0 && ((int )sd_card->sd_type & 1024) != 0) {
    retval = rtsx_write_register(chip, 64936, 6, 0);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                  "sd_switch_function", 1553);
      return (retval);
    } else {

    }
  } else {

  }
  return (0);
}
}
static int sd_wait_data_idle(struct rtsx_chip *chip ) 
{ 
  int retval ;
  int i ;
  u8 val ;
  struct _ddebug descriptor ;
  struct device *tmp ;
  long tmp___0 ;

  {
  retval = 2;
  val = 0U;
  i = 0;
  goto ldv_38678;
  ldv_38677: 
  retval = rtsx_read_register(chip, 64950, & val);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "sd_wait_data_idle", 1570);
    return (retval);
  } else {

  }
  if ((int )((signed char )val) < 0) {
    retval = 0;
    goto ldv_38676;
  } else {

  }
  __const_udelay(429500UL);
  i = i + 1;
  ldv_38678: ;
  if (i <= 99) {
    goto ldv_38677;
  } else {

  }
  ldv_38676: 
  descriptor.modname = "rts5208";
  descriptor.function = "sd_wait_data_idle";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c";
  descriptor.format = "SD_DATA_STATE: 0x%02x\n";
  descriptor.lineno = 1579U;
  descriptor.flags = 0U;
  tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp___0 != 0L) {
    tmp = rtsx_dev((struct rtsx_chip  const  *)chip);
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)tmp, "SD_DATA_STATE: 0x%02x\n",
                      (int )val);
  } else {

  }
  return (retval);
}
}
static int sd_sdr_tuning_rx_cmd(struct rtsx_chip *chip , u8 sample_point ) 
{ 
  int retval ;
  u8 cmd[5U] ;

  {
  retval = sd_change_phase(chip, (int )sample_point, 1);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "sd_sdr_tuning_rx_cmd", 1591);
    return (1);
  } else {

  }
  cmd[0] = 83U;
  cmd[1] = 0U;
  cmd[2] = 0U;
  cmd[3] = 0U;
  cmd[4] = 0U;
  retval = sd_read_data(chip, 15, (u8 *)(& cmd), 5, 64, 1, 1, (u8 *)0U, 0, 100);
  if (retval != 0) {
    sd_wait_data_idle(chip);
    rtsx_clear_sd_error(chip);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "sd_sdr_tuning_rx_cmd", 1607);
    return (1);
  } else {

  }
  return (0);
}
}
static int sd_ddr_tuning_rx_cmd(struct rtsx_chip *chip , u8 sample_point ) 
{ 
  struct sd_info *sd_card ;
  int retval ;
  u8 cmd[5U] ;
  struct _ddebug descriptor ;
  struct device *tmp ;
  long tmp___0 ;

  {
  sd_card = & chip->sd_card;
  retval = sd_change_phase(chip, (int )sample_point, 1);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "sd_ddr_tuning_rx_cmd", 1622);
    return (1);
  } else {

  }
  descriptor.modname = "rts5208";
  descriptor.function = "sd_ddr_tuning_rx_cmd";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c";
  descriptor.format = "sd ddr tuning rx\n";
  descriptor.lineno = 1626U;
  descriptor.flags = 0U;
  tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp___0 != 0L) {
    tmp = rtsx_dev((struct rtsx_chip  const  *)chip);
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)tmp, "sd ddr tuning rx\n");
  } else {

  }
  retval = sd_send_cmd_get_rsp(chip, 55, sd_card->sd_addr, 1, (u8 *)0U, 0);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "sd_ddr_tuning_rx_cmd", 1631);
    return (1);
  } else {

  }
  cmd[0] = 77U;
  cmd[1] = 0U;
  cmd[2] = 0U;
  cmd[3] = 0U;
  cmd[4] = 0U;
  retval = sd_read_data(chip, 12, (u8 *)(& cmd), 5, 64, 1, 1, (u8 *)0U, 0, 100);
  if (retval != 0) {
    sd_wait_data_idle(chip);
    rtsx_clear_sd_error(chip);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "sd_ddr_tuning_rx_cmd", 1647);
    return (1);
  } else {

  }
  return (0);
}
}
static int mmc_ddr_tunning_rx_cmd(struct rtsx_chip *chip , u8 sample_point ) 
{ 
  struct sd_info *sd_card ;
  int retval ;
  u8 cmd[5U] ;
  u8 bus_width ;
  struct _ddebug descriptor ;
  struct device *tmp ;
  long tmp___0 ;

  {
  sd_card = & chip->sd_card;
  if (((int )sd_card->sd_type & 255) == 1 && ((int )sd_card->sd_type & 2048) != 0) {
    bus_width = 2U;
  } else
  if (((int )sd_card->sd_type & 255) == 1 && ((int )sd_card->sd_type & 1024) != 0) {
    bus_width = 1U;
  } else {
    bus_width = 0U;
  }
  retval = sd_change_phase(chip, (int )sample_point, 1);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "mmc_ddr_tunning_rx_cmd", 1669);
    return (1);
  } else {

  }
  descriptor.modname = "rts5208";
  descriptor.function = "mmc_ddr_tunning_rx_cmd";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c";
  descriptor.format = "mmc ddr tuning rx\n";
  descriptor.lineno = 1673U;
  descriptor.flags = 0U;
  tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp___0 != 0L) {
    tmp = rtsx_dev((struct rtsx_chip  const  *)chip);
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)tmp, "mmc ddr tuning rx\n");
  } else {

  }
  cmd[0] = 72U;
  cmd[1] = 0U;
  cmd[2] = 0U;
  cmd[3] = 0U;
  cmd[4] = 0U;
  retval = sd_read_data(chip, 12, (u8 *)(& cmd), 5, 512, 1, (int )bus_width, (u8 *)0U,
                        0, 100);
  if (retval != 0) {
    sd_wait_data_idle(chip);
    rtsx_clear_sd_error(chip);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "mmc_ddr_tunning_rx_cmd", 1687);
    return (1);
  } else {

  }
  return (0);
}
}
static int sd_sdr_tuning_tx_cmd(struct rtsx_chip *chip , u8 sample_point ) 
{ 
  struct sd_info *sd_card ;
  int retval ;
  int tmp ;

  {
  sd_card = & chip->sd_card;
  retval = sd_change_phase(chip, (int )sample_point, 0);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "sd_sdr_tuning_tx_cmd", 1701);
    return (1);
  } else {

  }
  retval = rtsx_write_register(chip, 64930, 1, 1);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "sd_sdr_tuning_tx_cmd", 1708);
    return (retval);
  } else {

  }
  retval = sd_send_cmd_get_rsp(chip, 13, sd_card->sd_addr, 1, (u8 *)0U, 0);
  if (retval != 0) {
    tmp = sd_check_err_code(chip, 4);
    if (tmp != 0) {
      rtsx_write_register(chip, 64930, 1, 0);
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                  "sd_sdr_tuning_tx_cmd", 1718);
      return (1);
    } else {

    }
  } else {

  }
  retval = rtsx_write_register(chip, 64930, 1, 0);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "sd_sdr_tuning_tx_cmd", 1726);
    return (retval);
  } else {

  }
  return (0);
}
}
static int sd_ddr_tuning_tx_cmd(struct rtsx_chip *chip , u8 sample_point ) 
{ 
  struct sd_info *sd_card ;
  int retval ;
  u8 cmd[5U] ;
  u8 bus_width ;

  {
  sd_card = & chip->sd_card;
  retval = sd_change_phase(chip, (int )sample_point, 0);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "sd_ddr_tuning_tx_cmd", 1741);
    return (1);
  } else {

  }
  if (((int )sd_card->sd_type & 255) == 0) {
    bus_width = 1U;
  } else
  if (((int )sd_card->sd_type & 255) == 1 && ((int )sd_card->sd_type & 2048) != 0) {
    bus_width = 2U;
  } else
  if (((int )sd_card->sd_type & 255) == 1 && ((int )sd_card->sd_type & 1024) != 0) {
    bus_width = 1U;
  } else {
    bus_width = 0U;
  }
  retval = sd_wait_state_data_ready(chip, 8, 1, 1000);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "sd_ddr_tuning_tx_cmd", 1758);
    return (1);
  } else {

  }
  retval = rtsx_write_register(chip, 64930, 1, 1);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "sd_ddr_tuning_tx_cmd", 1765);
    return (retval);
  } else {

  }
  cmd[0] = 91U;
  cmd[1] = 0U;
  cmd[2] = 0U;
  cmd[3] = 0U;
  cmd[4] = 0U;
  retval = sd_write_data(chip, 10, (u8 *)(& cmd), 5, 16, 1, (int )bus_width, (u8 *)(& sd_card->raw_csd),
                         16, 100);
  if (retval != 0) {
    rtsx_clear_sd_error(chip);
    rtsx_write_register(chip, 64930, 1, 0);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "sd_ddr_tuning_tx_cmd", 1780);
    return (1);
  } else {

  }
  retval = rtsx_write_register(chip, 64930, 1, 0);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "sd_ddr_tuning_tx_cmd", 1787);
    return (retval);
  } else {

  }
  sd_send_cmd_get_rsp(chip, 13, sd_card->sd_addr, 1, (u8 *)0U, 0);
  return (0);
}
}
static u8 sd_search_final_phase(struct rtsx_chip *chip , u32 phase_map , u8 tune_dir ) 
{ 
  struct sd_info *sd_card ;
  struct timing_phase_path path[32U] ;
  int i ;
  int j ;
  int cont_path_cnt ;
    klee_make_symbolic(&cont_path_cnt, sizeof(int), "cont_path_cnt");
  bool new_block ;
  int max_len ;
    klee_make_symbolic(&max_len, sizeof(int), "max_len");
  int final_path_idx ;
    klee_make_symbolic(&final_path_idx, sizeof(int), "final_path_idx");
  u8 final_phase ;
  int tmp ;
  int idx ;
  struct _ddebug descriptor ;
  struct device *tmp___0 ;
  long tmp___1 ;
  int idx___0 ;
    klee_make_symbolic(&idx___0, sizeof(int), "idx___0");
  struct _ddebug descriptor___0 ;
  struct device *tmp___2 ;
  long tmp___3 ;
  struct _ddebug descriptor___1 ;
  struct device *tmp___4 ;
  long tmp___5 ;
  struct _ddebug descriptor___2 ;
  struct device *tmp___6 ;
  long tmp___7 ;
  struct _ddebug descriptor___3 ;
  struct device *tmp___8 ;
  long tmp___9 ;
  struct _ddebug descriptor___4 ;
  struct device *tmp___10 ;
  long tmp___11 ;
  int temp_mid ;
    klee_make_symbolic(&temp_mid, sizeof(int), "temp_mid");
  int temp_final_phase ;
    klee_make_symbolic(&temp_final_phase, sizeof(int), "temp_final_phase");
  int temp_mid___0 ;
    klee_make_symbolic(&temp_mid___0, sizeof(int), "temp_mid___0");
  int temp_final_phase___0 ;
    klee_make_symbolic(&temp_final_phase___0, sizeof(int), "temp_final_phase___0");
  struct _ddebug descriptor___5 ;
  struct device *tmp___12 ;
  long tmp___13 ;

  {
  sd_card = & chip->sd_card;
  final_phase = 255U;
  if (phase_map == 4294967295U) {
    if ((unsigned int )tune_dir == 1U) {
      final_phase = (unsigned char )chip->sd_default_rx_phase;
    } else {
      final_phase = (unsigned char )chip->sd_default_tx_phase;
    }
    goto Search_Finish;
  } else {

  }
  cont_path_cnt = 0;
  new_block = 1;
  j = 0;
  i = 0;
  goto ldv_38739;
  ldv_38738: ;
  if (((u32 )(1 << i) & phase_map) != 0U) {
    if ((int )new_block) {
      new_block = 0;
      tmp = cont_path_cnt;
      cont_path_cnt = cont_path_cnt + 1;
      j = tmp;
      path[j].start = i;
      path[j].end = i;
    } else {
      path[j].end = i;
    }
  } else {
    new_block = 1;
    if (cont_path_cnt != 0) {
      idx = cont_path_cnt + -1;
      path[idx].len = (path[idx].end - path[idx].start) + 1;
      path[idx].mid = path[idx].start + path[idx].len / 2;
    } else {

    }
  }
  i = i + 1;
  ldv_38739: ;
  if (i <= 31) {
    goto ldv_38738;
  } else {

  }

  if (cont_path_cnt == 0) {
    descriptor.modname = "rts5208";
    descriptor.function = "sd_search_final_phase";
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c";
    descriptor.format = "No continuous phase path\n";
    descriptor.lineno = 1843U;
    descriptor.flags = 0U;
    tmp___1 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
    if (tmp___1 != 0L) {
      tmp___0 = rtsx_dev((struct rtsx_chip  const  *)chip);
      __dynamic_dev_dbg(& descriptor, (struct device  const  *)tmp___0, "No continuous phase path\n");
    } else {

    }
    goto Search_Finish;
  } else {
    idx___0 = cont_path_cnt + -1;
    path[idx___0].len = (path[idx___0].end - path[idx___0].start) + 1;
    path[idx___0].mid = path[idx___0].start + path[idx___0].len / 2;
  }
  if (path[0].start == 0 && path[cont_path_cnt + -1].end == 31) {
    path[0].start = path[cont_path_cnt + -1].start + -32;
    path[0].len = path[0].len + path[cont_path_cnt + -1].len;
    path[0].mid = path[0].start + path[0].len / 2;
    if (path[0].mid < 0) {
      path[0].mid = path[0].mid + 32;
    } else {

    }
    cont_path_cnt = cont_path_cnt - 1;
  } else {

  }
  max_len = 0;
  final_phase = 0U;
  final_path_idx = 0;
  i = 0;
  goto ldv_38750;
  ldv_38749: ;
  if (path[i].len > max_len) {
    max_len = path[i].len;
    final_phase = (unsigned char )path[i].mid;
    final_path_idx = i;
  } else {

  }
  descriptor___0.modname = "rts5208";
  descriptor___0.function = "sd_search_final_phase";
  descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c";
  descriptor___0.format = "path[%d].start = %d\n";
  descriptor___0.lineno = 1874U;
  descriptor___0.flags = 0U;
  tmp___3 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
  if (tmp___3 != 0L) {
    tmp___2 = rtsx_dev((struct rtsx_chip  const  *)chip);
    __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)tmp___2, "path[%d].start = %d\n",
                      i, path[i].start);
  } else {

  }
  descriptor___1.modname = "rts5208";
  descriptor___1.function = "sd_search_final_phase";
  descriptor___1.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c";
  descriptor___1.format = "path[%d].end = %d\n";
  descriptor___1.lineno = 1875U;
  descriptor___1.flags = 0U;
  tmp___5 = ldv__builtin_expect((long )descriptor___1.flags & 1L, 0L);
  if (tmp___5 != 0L) {
    tmp___4 = rtsx_dev((struct rtsx_chip  const  *)chip);
    __dynamic_dev_dbg(& descriptor___1, (struct device  const  *)tmp___4, "path[%d].end = %d\n",
                      i, path[i].end);
  } else {

  }
  descriptor___2.modname = "rts5208";
  descriptor___2.function = "sd_search_final_phase";
  descriptor___2.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c";
  descriptor___2.format = "path[%d].len = %d\n";
  descriptor___2.lineno = 1876U;
  descriptor___2.flags = 0U;
  tmp___7 = ldv__builtin_expect((long )descriptor___2.flags & 1L, 0L);
  if (tmp___7 != 0L) {
    tmp___6 = rtsx_dev((struct rtsx_chip  const  *)chip);
    __dynamic_dev_dbg(& descriptor___2, (struct device  const  *)tmp___6, "path[%d].len = %d\n",
                      i, path[i].len);
  } else {

  }
  descriptor___3.modname = "rts5208";
  descriptor___3.function = "sd_search_final_phase";
  descriptor___3.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c";
  descriptor___3.format = "path[%d].mid = %d\n";
  descriptor___3.lineno = 1877U;
  descriptor___3.flags = 0U;
  tmp___9 = ldv__builtin_expect((long )descriptor___3.flags & 1L, 0L);
  if (tmp___9 != 0L) {
    tmp___8 = rtsx_dev((struct rtsx_chip  const  *)chip);
    __dynamic_dev_dbg(& descriptor___3, (struct device  const  *)tmp___8, "path[%d].mid = %d\n",
                      i, path[i].mid);
  } else {

  }
  descriptor___4.modname = "rts5208";
  descriptor___4.function = "sd_search_final_phase";
  descriptor___4.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c";
  descriptor___4.format = "\n";
  descriptor___4.lineno = 1878U;
  descriptor___4.flags = 0U;
  tmp___11 = ldv__builtin_expect((long )descriptor___4.flags & 1L, 0L);
  if (tmp___11 != 0L) {
    tmp___10 = rtsx_dev((struct rtsx_chip  const  *)chip);
    __dynamic_dev_dbg(& descriptor___4, (struct device  const  *)tmp___10, "\n");
  } else {

  }
  i = i + 1;
  ldv_38750: ;
  if (i < cont_path_cnt) {
    goto ldv_38749;
  } else {

  }

  if ((unsigned int )tune_dir == 0U) {
    if (((int )sd_card->sd_type & 255) == 0 && ((int )sd_card->sd_type & 2048) != 0) {
      if (max_len > 15) {
        temp_mid = (max_len + -16) / 2;
        temp_final_phase = path[final_path_idx].end + ((temp_mid + 6) - max_len);
        if (temp_final_phase < 0) {
          final_phase = (unsigned int )((unsigned char )temp_final_phase) + 32U;
        } else {
          final_phase = (unsigned char )temp_final_phase;
        }
      } else {

      }
    } else
    if (((int )sd_card->sd_type & 255) == 0 && ((int )sd_card->sd_type & 512) != 0) {
      if (max_len > 12) {
        temp_mid___0 = (max_len + -13) / 2;
        temp_final_phase___0 = path[final_path_idx].end + ((temp_mid___0 + 3) - max_len);
        if (temp_final_phase___0 < 0) {
          final_phase = (unsigned int )((unsigned char )temp_final_phase___0) + 32U;
        } else {
          final_phase = (unsigned char )temp_final_phase___0;
        }
      } else {

      }
    } else {

    }
  } else {

  }
  Search_Finish: 
  descriptor___5.modname = "rts5208";
  descriptor___5.function = "sd_search_final_phase";
  descriptor___5.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c";
  descriptor___5.format = "Final chosen phase: %d\n";
  descriptor___5.lineno = 1912U;
  descriptor___5.flags = 0U;
  tmp___13 = ldv__builtin_expect((long )descriptor___5.flags & 1L, 0L);
  if (tmp___13 != 0L) {
    tmp___12 = rtsx_dev((struct rtsx_chip  const  *)chip);
    __dynamic_dev_dbg(& descriptor___5, (struct device  const  *)tmp___12, "Final chosen phase: %d\n",
                      (int )final_phase);
  } else {

  }
  return (final_phase);
}
}
static int sd_tuning_rx(struct rtsx_chip *chip ) 
{ 
  struct sd_info *sd_card ;
  int retval ;
  int i ;
  int j ;
  u32 raw_phase_map[3U] ;
  u32 phase_map ;
  u8 final_phase ;
  int (*tuning_cmd)(struct rtsx_chip * , u8  ) ;
  int tmp ;
  struct _ddebug descriptor ;
  struct device *tmp___0 ;
  long tmp___1 ;
  struct _ddebug descriptor___0 ;
  struct device *tmp___2 ;
  long tmp___3 ;

  {
  sd_card = & chip->sd_card;
  if (((int )sd_card->sd_type & 255) == 0) {
    if (((int )sd_card->sd_type & 255) == 0 && ((int )sd_card->sd_type & 1024) != 0) {
      tuning_cmd = & sd_ddr_tuning_rx_cmd;
    } else {
      tuning_cmd = & sd_sdr_tuning_rx_cmd;
    }
  } else
  if (((int )sd_card->sd_type & 255) == 1 && ((int )sd_card->sd_type & 8192) != 0) {
    tuning_cmd = & mmc_ddr_tunning_rx_cmd;
  } else {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "sd_tuning_rx", 1935);
    return (1);
  }
  i = 0;
  goto ldv_38775;
  ldv_38774: 
  raw_phase_map[i] = 0U;
  j = 31;
  goto ldv_38772;
  ldv_38771: 
  tmp = detect_card_cd(chip, 4);
  if (tmp != 0) {
    sd_set_err_code(chip, 32);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "sd_tuning_rx", 1945);
    return (1);
  } else {

  }
  retval = (*tuning_cmd)(chip, (int )((unsigned char )j));
  if (retval == 0) {
    raw_phase_map[i] = raw_phase_map[i] | (u32 )(1 << j);
  } else {

  }
  j = j - 1;
  ldv_38772: ;
  if (j >= 0) {
    goto ldv_38771;
  } else {

  }
  i = i + 1;
  ldv_38775: ;
  if (i <= 2) {
    goto ldv_38774;
  } else {

  }
  phase_map = (raw_phase_map[0] & raw_phase_map[1]) & raw_phase_map[2];
  i = 0;
  goto ldv_38779;
  ldv_38778: 
  descriptor.modname = "rts5208";
  descriptor.function = "sd_tuning_rx";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c";
  descriptor.format = "RX raw_phase_map[%d] = 0x%08x\n";
  descriptor.lineno = 1958U;
  descriptor.flags = 0U;
  tmp___1 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp___1 != 0L) {
    tmp___0 = rtsx_dev((struct rtsx_chip  const  *)chip);
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)tmp___0, "RX raw_phase_map[%d] = 0x%08x\n",
                      i, raw_phase_map[i]);
  } else {

  }
  i = i + 1;
  ldv_38779: ;
  if (i <= 2) {
    goto ldv_38778;
  } else {

  }
  descriptor___0.modname = "rts5208";
  descriptor___0.function = "sd_tuning_rx";
  descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c";
  descriptor___0.format = "RX phase_map = 0x%08x\n";
  descriptor___0.lineno = 1960U;
  descriptor___0.flags = 0U;
  tmp___3 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
  if (tmp___3 != 0L) {
    tmp___2 = rtsx_dev((struct rtsx_chip  const  *)chip);
    __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)tmp___2, "RX phase_map = 0x%08x\n",
                      phase_map);
  } else {

  }
  final_phase = sd_search_final_phase(chip, phase_map, 1);
  if ((unsigned int )final_phase == 255U) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "sd_tuning_rx", 1964);
    return (1);
  } else {

  }
  retval = sd_change_phase(chip, (int )final_phase, 1);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "sd_tuning_rx", 1970);
    return (1);
  } else {

  }
  return (0);
}
}
static int sd_ddr_pre_tuning_tx(struct rtsx_chip *chip ) 
{ 
  struct sd_info *sd_card ;
  int retval ;
  int i ;
  u32 phase_map ;
  u8 final_phase ;
  int tmp ;
  int tmp___0 ;
  struct _ddebug descriptor ;
  struct device *tmp___1 ;
  long tmp___2 ;
  struct _ddebug descriptor___0 ;
  struct device *tmp___3 ;
  long tmp___4 ;

  {
  sd_card = & chip->sd_card;
  retval = rtsx_write_register(chip, 64930, 1, 1);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "sd_ddr_pre_tuning_tx", 1988);
    return (retval);
  } else {

  }
  phase_map = 0U;
  i = 31;
  goto ldv_38793;
  ldv_38792: 
  tmp = detect_card_cd(chip, 4);
  if (tmp != 0) {
    sd_set_err_code(chip, 32);
    rtsx_write_register(chip, 64930, 1, 0);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "sd_ddr_pre_tuning_tx", 1998);
    return (1);
  } else {

  }
  retval = sd_change_phase(chip, (int )((unsigned char )i), 0);
  if (retval != 0) {
    goto ldv_38791;
  } else {

  }
  retval = sd_send_cmd_get_rsp(chip, 13, sd_card->sd_addr, 1, (u8 *)0U, 0);
  if (retval == 0) {
    phase_map = (u32 )(1 << i) | phase_map;
  } else {
    tmp___0 = sd_check_err_code(chip, 4);
    if (tmp___0 == 0) {
      phase_map = (u32 )(1 << i) | phase_map;
    } else {

    }
  }
  ldv_38791: 
  i = i - 1;
  ldv_38793: ;
  if (i >= 0) {
    goto ldv_38792;
  } else {

  }
  retval = rtsx_write_register(chip, 64930, 1, 0);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "sd_ddr_pre_tuning_tx", 2017);
    return (retval);
  } else {

  }
  descriptor.modname = "rts5208";
  descriptor.function = "sd_ddr_pre_tuning_tx";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c";
  descriptor.format = "DDR TX pre tune phase_map = 0x%08x\n";
  descriptor.lineno = 2022U;
  descriptor.flags = 0U;
  tmp___2 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp___2 != 0L) {
    tmp___1 = rtsx_dev((struct rtsx_chip  const  *)chip);
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)tmp___1, "DDR TX pre tune phase_map = 0x%08x\n",
                      phase_map);
  } else {

  }
  final_phase = sd_search_final_phase(chip, phase_map, 0);
  if ((unsigned int )final_phase == 255U) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "sd_ddr_pre_tuning_tx", 2026);
    return (1);
  } else {

  }
  retval = sd_change_phase(chip, (int )final_phase, 0);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "sd_ddr_pre_tuning_tx", 2032);
    return (1);
  } else {

  }
  descriptor___0.modname = "rts5208";
  descriptor___0.function = "sd_ddr_pre_tuning_tx";
  descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c";
  descriptor___0.format = "DDR TX pre tune phase: %d\n";
  descriptor___0.lineno = 2037U;
  descriptor___0.flags = 0U;
  tmp___4 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
  if (tmp___4 != 0L) {
    tmp___3 = rtsx_dev((struct rtsx_chip  const  *)chip);
    __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)tmp___3, "DDR TX pre tune phase: %d\n",
                      (int )final_phase);
  } else {

  }
  return (0);
}
}
static int sd_tuning_tx(struct rtsx_chip *chip ) 
{ 
  struct sd_info *sd_card ;
  int retval ;
  int i ;
  int j ;
  u32 raw_phase_map[3U] ;
  u32 phase_map ;
  u8 final_phase ;
  int (*tuning_cmd)(struct rtsx_chip * , u8  ) ;
  int tmp ;
  struct _ddebug descriptor ;
  struct device *tmp___0 ;
  long tmp___1 ;
  struct _ddebug descriptor___0 ;
  struct device *tmp___2 ;
  long tmp___3 ;

  {
  sd_card = & chip->sd_card;
  if (((int )sd_card->sd_type & 255) == 0) {
    if (((int )sd_card->sd_type & 255) == 0 && ((int )sd_card->sd_type & 1024) != 0) {
      tuning_cmd = & sd_ddr_tuning_tx_cmd;
    } else {
      tuning_cmd = & sd_sdr_tuning_tx_cmd;
    }
  } else
  if (((int )sd_card->sd_type & 255) == 1 && ((int )sd_card->sd_type & 8192) != 0) {
    tuning_cmd = & sd_ddr_tuning_tx_cmd;
  } else {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "sd_tuning_tx", 2061);
    return (1);
  }
  i = 0;
  goto ldv_38815;
  ldv_38814: 
  raw_phase_map[i] = 0U;
  j = 31;
  goto ldv_38812;
  ldv_38811: 
  tmp = detect_card_cd(chip, 4);
  if (tmp != 0) {
    sd_set_err_code(chip, 32);
    rtsx_write_register(chip, 64930, 1, 0);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "sd_tuning_tx", 2073);
    return (1);
  } else {

  }
  retval = (*tuning_cmd)(chip, (int )((unsigned char )j));
  if (retval == 0) {
    raw_phase_map[i] = raw_phase_map[i] | (u32 )(1 << j);
  } else {

  }
  j = j - 1;
  ldv_38812: ;
  if (j >= 0) {
    goto ldv_38811;
  } else {

  }
  i = i + 1;
  ldv_38815: ;
  if (i <= 2) {
    goto ldv_38814;
  } else {

  }
  phase_map = (raw_phase_map[0] & raw_phase_map[1]) & raw_phase_map[2];
  i = 0;
  goto ldv_38819;
  ldv_38818: 
  descriptor.modname = "rts5208";
  descriptor.function = "sd_tuning_tx";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c";
  descriptor.format = "TX raw_phase_map[%d] = 0x%08x\n";
  descriptor.lineno = 2086U;
  descriptor.flags = 0U;
  tmp___1 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp___1 != 0L) {
    tmp___0 = rtsx_dev((struct rtsx_chip  const  *)chip);
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)tmp___0, "TX raw_phase_map[%d] = 0x%08x\n",
                      i, raw_phase_map[i]);
  } else {

  }
  i = i + 1;
  ldv_38819: ;
  if (i <= 2) {
    goto ldv_38818;
  } else {

  }
  descriptor___0.modname = "rts5208";
  descriptor___0.function = "sd_tuning_tx";
  descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c";
  descriptor___0.format = "TX phase_map = 0x%08x\n";
  descriptor___0.lineno = 2088U;
  descriptor___0.flags = 0U;
  tmp___3 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
  if (tmp___3 != 0L) {
    tmp___2 = rtsx_dev((struct rtsx_chip  const  *)chip);
    __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)tmp___2, "TX phase_map = 0x%08x\n",
                      phase_map);
  } else {

  }
  final_phase = sd_search_final_phase(chip, phase_map, 0);
  if ((unsigned int )final_phase == 255U) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "sd_tuning_tx", 2092);
    return (1);
  } else {

  }
  retval = sd_change_phase(chip, (int )final_phase, 0);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "sd_tuning_tx", 2098);
    return (1);
  } else {

  }
  return (0);
}
}
static int sd_sdr_tuning(struct rtsx_chip *chip ) 
{ 
  int retval ;

  {
  retval = sd_tuning_tx(chip);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "sd_sdr_tuning", 2111);
    return (1);
  } else {

  }
  retval = sd_tuning_rx(chip);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "sd_sdr_tuning", 2117);
    return (1);
  } else {

  }
  return (0);
}
}
static int sd_ddr_tuning(struct rtsx_chip *chip ) 
{ 
  int retval ;

  {
  if ((chip->sd_ctl & 16U) == 0U) {
    retval = sd_ddr_pre_tuning_tx(chip);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                  "sd_ddr_tuning", 2131);
      return (1);
    } else {

    }
  } else {
    retval = sd_change_phase(chip, (int )((unsigned char )chip->sd_ddr_tx_phase),
                             0);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                  "sd_ddr_tuning", 2138);
      return (1);
    } else {

    }
  }
  retval = sd_tuning_rx(chip);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "sd_ddr_tuning", 2145);
    return (1);
  } else {

  }
  if ((chip->sd_ctl & 16U) == 0U) {
    retval = sd_tuning_tx(chip);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                  "sd_ddr_tuning", 2152);
      return (1);
    } else {

    }
  } else {

  }
  return (0);
}
}
static int mmc_ddr_tuning(struct rtsx_chip *chip ) 
{ 
  int retval ;

  {
  if ((chip->sd_ctl & 32U) == 0U) {
    retval = sd_ddr_pre_tuning_tx(chip);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                  "mmc_ddr_tuning", 2167);
      return (1);
    } else {

    }
  } else {
    retval = sd_change_phase(chip, (int )((unsigned char )chip->mmc_ddr_tx_phase),
                             0);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                  "mmc_ddr_tuning", 2174);
      return (1);
    } else {

    }
  }
  retval = sd_tuning_rx(chip);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "mmc_ddr_tuning", 2181);
    return (1);
  } else {

  }
  if ((chip->sd_ctl & 32U) == 0U) {
    retval = sd_tuning_tx(chip);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                  "mmc_ddr_tuning", 2188);
      return (1);
    } else {

    }
  } else {

  }
  return (0);
}
}
int sd_switch_clock(struct rtsx_chip *chip ) 
{ 
  struct sd_info *sd_card ;
  int retval ;
  int re_tuning ;
    klee_make_symbolic(&re_tuning, sizeof(int), "re_tuning");

  {
  sd_card = & chip->sd_card;
  re_tuning = 0;
  retval = select_card(chip, 4);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "sd_switch_clock", 2204);
    return (1);
  } else {

  }
  retval = switch_clock(chip, sd_card->sd_clock);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "sd_switch_clock", 2210);
    return (1);
  } else {

  }
  if (re_tuning != 0) {
    if (((int )sd_card->sd_type & 255) == 0) {
      if (((int )sd_card->sd_type & 255) == 0 && ((int )sd_card->sd_type & 1024) != 0) {
        retval = sd_ddr_tuning(chip);
      } else {
        retval = sd_sdr_tuning(chip);
      }
    } else
    if (((int )sd_card->sd_type & 255) == 1 && ((int )sd_card->sd_type & 8192) != 0) {
      retval = mmc_ddr_tuning(chip);
    } else {

    }
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                  "sd_switch_clock", 2226);
      return (1);
    } else {

    }
  } else {

  }
  return (0);
}
}
static int sd_prepare_reset(struct rtsx_chip *chip ) 
{ 
  struct sd_info *sd_card ;
  int retval ;

  {
  sd_card = & chip->sd_card;
  if (chip->asic_code != 0) {
    sd_card->sd_clock = 29;
  } else {
    sd_card->sd_clock = 2;
  }
  sd_card->sd_type = 0U;
  sd_card->seq_mode = 0;
  sd_card->sd_data_buf_ready = 0U;
  sd_card->capacity = 0U;
  sd_card->sd_lock_status = 0U;
  sd_card->sd_erase_status = 0U;
  chip->capacity[(int )chip->card2lun[4]] = 0U;
  chip->sd_io = 0U;
  retval = sd_set_init_para(chip);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "sd_prepare_reset", 2259);
    return (retval);
  } else {

  }
  retval = rtsx_write_register(chip, (int )REG_SD_CFG1, 255, 64);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "sd_prepare_reset", 2265);
    return (retval);
  } else {

  }
  retval = rtsx_write_register(chip, 64852, 68, 68);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "sd_prepare_reset", 2272);
    return (retval);
  } else {

  }
  retval = select_card(chip, 4);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "sd_prepare_reset", 2278);
    return (1);
  } else {

  }
  return (0);
}
}
static int sd_pull_ctl_disable(struct rtsx_chip *chip ) 
{ 
  int retval ;

  {
  if ((unsigned int )chip->product_id == 21000U) {
    retval = rtsx_write_register(chip, 64864, 255, 85);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                  "sd_pull_ctl_disable", 2293);
      return (retval);
    } else {

    }
    retval = rtsx_write_register(chip, 64865, 255, 85);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                  "sd_pull_ctl_disable", 2299);
      return (retval);
    } else {

    }
    retval = rtsx_write_register(chip, 64866, 255, 75);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                  "sd_pull_ctl_disable", 2305);
      return (retval);
    } else {

    }
    retval = rtsx_write_register(chip, 64867, 255, 85);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                  "sd_pull_ctl_disable", 2311);
      return (retval);
    } else {

    }
    retval = rtsx_write_register(chip, 64868, 255, 180);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                  "sd_pull_ctl_disable", 2317);
      return (retval);
    } else {

    }
    retval = rtsx_write_register(chip, 64869, 255, 5);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                  "sd_pull_ctl_disable", 2323);
      return (retval);
    } else {

    }
  } else
  if ((unsigned int )chip->product_id == 21128U) {
    if (chip->baro_pkg == 0) {
      retval = rtsx_write_register(chip, 64864, 255, 85);
      if (retval != 0) {
        _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                    "sd_pull_ctl_disable", 2331);
        return (retval);
      } else {

      }
      retval = rtsx_write_register(chip, 64865, 255, 85);
      if (retval != 0) {
        _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                    "sd_pull_ctl_disable", 2337);
        return (retval);
      } else {

      }
      retval = rtsx_write_register(chip, 64866, 255, 75);
      if (retval != 0) {
        _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                    "sd_pull_ctl_disable", 2343);
        return (retval);
      } else {

      }
      retval = rtsx_write_register(chip, 64867, 255, 105);
      if (retval != 0) {
        _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                    "sd_pull_ctl_disable", 2349);
        return (retval);
      } else {

      }
    } else {

    }
  } else {

  }
  return (0);
}
}
int sd_pull_ctl_enable(struct rtsx_chip *chip ) 
{ 
  int retval ;

  {
  chip->ci = 0;
  if ((unsigned int )chip->product_id == 21000U) {
    rtsx_add_cmd(chip, 1, 64864, 255, 98);
    rtsx_add_cmd(chip, 1, 64865, 255, 166);
    rtsx_add_cmd(chip, 1, 64866, 255, 139);
    rtsx_add_cmd(chip, 1, 64867, 255, 105);
    rtsx_add_cmd(chip, 1, 64868, 255, 216);
    rtsx_add_cmd(chip, 1, 64869, 255, 5);
  } else
  if ((unsigned int )chip->product_id == 21128U) {
    if (chip->baro_pkg == 0) {
      rtsx_add_cmd(chip, 1, 64864, 255, 168);
      rtsx_add_cmd(chip, 1, 64865, 255, 90);
      rtsx_add_cmd(chip, 1, 64866, 255, 149);
      rtsx_add_cmd(chip, 1, 64867, 255, 170);
    } else {

    }
  } else {

  }
  retval = rtsx_send_cmd(chip, 4, 100);
  if (retval < 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "sd_pull_ctl_enable", 2392);
    return (1);
  } else {

  }
  return (0);
}
}
static int sd_init_power(struct rtsx_chip *chip ) 
{ 
  int retval ;
  struct task_struct *tmp ;
  long volatile   __ret ;
  struct task_struct *tmp___0 ;
  struct task_struct *tmp___1 ;
  struct task_struct *tmp___2 ;
  struct task_struct *tmp___3 ;
  struct task_struct *tmp___4 ;
  long volatile   __ret___0 ;
  struct task_struct *tmp___5 ;
  struct task_struct *tmp___6 ;
  struct task_struct *tmp___7 ;
  struct task_struct *tmp___8 ;
  struct _ddebug descriptor ;
  struct device *tmp___9 ;
  long tmp___10 ;

  {
  retval = sd_power_off_card3v3(chip);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "sd_init_power", 2405);
    return (1);
  } else {

  }
  if (chip->ft2_fast_mode == 0) {
    tmp = get_current();
    tmp->task_state_change = 0UL;
    __ret = 1L;
    switch (8UL) {
    case 1UL: 
    tmp___0 = get_current();
    __asm__  volatile   ("xchgb %b0, %1\n": "+q" (__ret), "+m" (tmp___0->state): : "memory",
                         "cc");
    goto ldv_38867;
    case 2UL: 
    tmp___1 = get_current();
    __asm__  volatile   ("xchgw %w0, %1\n": "+r" (__ret), "+m" (tmp___1->state): : "memory",
                         "cc");
    goto ldv_38867;
    case 4UL: 
    tmp___2 = get_current();
    __asm__  volatile   ("xchgl %0, %1\n": "+r" (__ret), "+m" (tmp___2->state): : "memory",
                         "cc");
    goto ldv_38867;
    case 8UL: 
    tmp___3 = get_current();
    __asm__  volatile   ("xchgq %q0, %1\n": "+r" (__ret), "+m" (tmp___3->state): : "memory",
                         "cc");
    goto ldv_38867;
    default: 
    __xchg_wrong_size();
    }
    ldv_38867: 
    schedule_timeout(62L);
  } else {

  }
  retval = enable_card_clock(chip, 4);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "sd_init_power", 2414);
    return (1);
  } else {

  }
  if (chip->asic_code != 0) {
    retval = sd_pull_ctl_enable(chip);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                  "sd_init_power", 2421);
      return (1);
    } else {

    }
  } else {
    retval = rtsx_write_register(chip, 64541, 40, 0);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                  "sd_init_power", 2428);
      return (retval);
    } else {

    }
  }
  if (chip->ft2_fast_mode == 0) {
    retval = card_power_on(chip, 4);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                  "sd_init_power", 2436);
      return (1);
    } else {

    }
    tmp___4 = get_current();
    tmp___4->task_state_change = 0UL;
    __ret___0 = 1L;
    switch (8UL) {
    case 1UL: 
    tmp___5 = get_current();
    __asm__  volatile   ("xchgb %b0, %1\n": "+q" (__ret___0), "+m" (tmp___5->state): : "memory",
                         "cc");
    goto ldv_38875;
    case 2UL: 
    tmp___6 = get_current();
    __asm__  volatile   ("xchgw %w0, %1\n": "+r" (__ret___0), "+m" (tmp___6->state): : "memory",
                         "cc");
    goto ldv_38875;
    case 4UL: 
    tmp___7 = get_current();
    __asm__  volatile   ("xchgl %0, %1\n": "+r" (__ret___0), "+m" (tmp___7->state): : "memory",
                         "cc");
    goto ldv_38875;
    case 8UL: 
    tmp___8 = get_current();
    __asm__  volatile   ("xchgq %q0, %1\n": "+r" (__ret___0), "+m" (tmp___8->state): : "memory",
                         "cc");
    goto ldv_38875;
    default: 
    __xchg_wrong_size();
    }
    ldv_38875: 
    schedule_timeout(65L);
    if (((int )chip->ocp_stat & 6) != 0) {
      descriptor.modname = "rts5208";
      descriptor.function = "sd_init_power";
      descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c";
      descriptor.format = "Over current, OCPSTAT is 0x%x\n";
      descriptor.lineno = 2445U;
      descriptor.flags = 0U;
      tmp___10 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
      if (tmp___10 != 0L) {
        tmp___9 = rtsx_dev((struct rtsx_chip  const  *)chip);
        __dynamic_dev_dbg(& descriptor, (struct device  const  *)tmp___9, "Over current, OCPSTAT is 0x%x\n",
                          (int )chip->ocp_stat);
      } else {

      }
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                  "sd_init_power", 2446);
      return (1);
    } else {

    }
  } else {

  }
  retval = rtsx_write_register(chip, 64853, 4, 4);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "sd_init_power", 2455);
    return (retval);
  } else {

  }
  return (0);
}
}
static int sd_dummy_clock(struct rtsx_chip *chip ) 
{ 
  int retval ;
  struct task_struct *tmp ;
  long volatile   __ret ;
  struct task_struct *tmp___0 ;
  struct task_struct *tmp___1 ;
  struct task_struct *tmp___2 ;
  struct task_struct *tmp___3 ;

  {
  retval = rtsx_write_register(chip, (int )REG_SD_CFG3, 1, 1);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "sd_dummy_clock", 2468);
    return (retval);
  } else {

  }
  tmp = get_current();
  tmp->task_state_change = 0UL;
  __ret = 1L;
  switch (8UL) {
  case 1UL: 
  tmp___0 = get_current();
  __asm__  volatile   ("xchgb %b0, %1\n": "+q" (__ret), "+m" (tmp___0->state): : "memory",
                       "cc");
  goto ldv_38889;
  case 2UL: 
  tmp___1 = get_current();
  __asm__  volatile   ("xchgw %w0, %1\n": "+r" (__ret), "+m" (tmp___1->state): : "memory",
                       "cc");
  goto ldv_38889;
  case 4UL: 
  tmp___2 = get_current();
  __asm__  volatile   ("xchgl %0, %1\n": "+r" (__ret), "+m" (tmp___2->state): : "memory",
                       "cc");
  goto ldv_38889;
  case 8UL: 
  tmp___3 = get_current();
  __asm__  volatile   ("xchgq %q0, %1\n": "+r" (__ret), "+m" (tmp___3->state): : "memory",
                       "cc");
  goto ldv_38889;
  default: 
  __xchg_wrong_size();
  }
  ldv_38889: 
  schedule_timeout(1L);
  retval = rtsx_write_register(chip, (int )REG_SD_CFG3, 1, 0);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "sd_dummy_clock", 2474);
    return (retval);
  } else {

  }
  return (0);
}
}
static int sd_read_lba0(struct rtsx_chip *chip ) 
{ 
  struct sd_info *sd_card ;
  int retval ;
  u8 cmd[5U] ;
  u8 bus_width ;

  {
  sd_card = & chip->sd_card;
  cmd[0] = 81U;
  cmd[1] = 0U;
  cmd[2] = 0U;
  cmd[3] = 0U;
  cmd[4] = 0U;
  if (((int )sd_card->sd_type & 255) == 0) {
    bus_width = 1U;
  } else
  if (((int )sd_card->sd_type & 255) == 1 && ((int )sd_card->sd_type & 2048) != 0) {
    bus_width = 2U;
  } else
  if (((int )sd_card->sd_type & 255) == 1 && ((int )sd_card->sd_type & 1024) != 0) {
    bus_width = 1U;
  } else {
    bus_width = 0U;
  }
  retval = sd_read_data(chip, 12, (u8 *)(& cmd), 5, 512, 1, (int )bus_width, (u8 *)0U,
                        0, 100);
  if (retval != 0) {
    rtsx_clear_sd_error(chip);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "sd_read_lba0", 2508);
    return (1);
  } else {

  }
  return (0);
}
}
static int sd_check_wp_state(struct rtsx_chip *chip ) 
{ 
  struct sd_info *sd_card ;
  int retval ;
  u32 val ;
  u16 sd_card_type ;
  u8 cmd[5U] ;
  u8 buf[64U] ;
  struct _ddebug descriptor ;
  struct device *tmp ;
  long tmp___0 ;
  struct _ddebug descriptor___0 ;
  struct device *tmp___1 ;
  long tmp___2 ;
  struct _ddebug descriptor___1 ;
  struct device *tmp___3 ;
  long tmp___4 ;

  {
  sd_card = & chip->sd_card;
  retval = sd_send_cmd_get_rsp(chip, 55, sd_card->sd_addr, 1, (u8 *)0U, 0);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "sd_check_wp_state", 2526);
    return (1);
  } else {

  }
  cmd[0] = 77U;
  cmd[1] = 0U;
  cmd[2] = 0U;
  cmd[3] = 0U;
  cmd[4] = 0U;
  retval = sd_read_data(chip, 12, (u8 *)(& cmd), 5, 64, 1, 1, (u8 *)(& buf), 64, 250);
  if (retval != 0) {
    rtsx_clear_sd_error(chip);
    sd_send_cmd_get_rsp(chip, 13, sd_card->sd_addr, 1, (u8 *)0U, 0);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "sd_check_wp_state", 2543);
    return (1);
  } else {

  }
  descriptor.modname = "rts5208";
  descriptor.function = "sd_check_wp_state";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c";
  descriptor.format = "ACMD13:\n";
  descriptor.lineno = 2547U;
  descriptor.flags = 0U;
  tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp___0 != 0L) {
    tmp = rtsx_dev((struct rtsx_chip  const  *)chip);
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)tmp, "ACMD13:\n");
  } else {

  }
  descriptor___0.modname = "rts5208";
  descriptor___0.function = "sd_check_wp_state";
  descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c";
  descriptor___0.format = "%*ph\n";
  descriptor___0.lineno = 2548U;
  descriptor___0.flags = 0U;
  tmp___2 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
  if (tmp___2 != 0L) {
    tmp___1 = rtsx_dev((struct rtsx_chip  const  *)chip);
    __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)tmp___1, "%*ph\n",
                      64, (u8 *)(& buf));
  } else {

  }
  sd_card_type = (u16 )((int )((short )((int )buf[2] << 8)) | (int )((short )buf[3]));
  descriptor___1.modname = "rts5208";
  descriptor___1.function = "sd_check_wp_state";
  descriptor___1.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c";
  descriptor___1.format = "sd_card_type = 0x%04x\n";
  descriptor___1.lineno = 2551U;
  descriptor___1.flags = 0U;
  tmp___4 = ldv__builtin_expect((long )descriptor___1.flags & 1L, 0L);
  if (tmp___4 != 0L) {
    tmp___3 = rtsx_dev((struct rtsx_chip  const  *)chip);
    __dynamic_dev_dbg(& descriptor___1, (struct device  const  *)tmp___3, "sd_card_type = 0x%04x\n",
                      (int )sd_card_type);
  } else {

  }
  if ((unsigned int )sd_card_type == 1U || (unsigned int )sd_card_type == 2U) {
    chip->card_wp = (u8 )((unsigned int )chip->card_wp | 4U);
  } else {

  }
  val = ioread32((chip->rtsx)->remap_addr + 20UL);
  if ((val & 524288U) != 0U) {
    chip->card_wp = (u8 )((unsigned int )chip->card_wp | 4U);
  } else {

  }
  return (0);
}
}
static int reset_sd(struct rtsx_chip *chip ) 
{ 
  struct sd_info *sd_card ;
  bool hi_cap_flow ;
  int retval ;
  int i ;
  int j ;
  int k ;
    klee_make_symbolic(&k, sizeof(int), "k");
  bool sd_dont_switch ;
  bool support_1v8 ;
  bool try_sdio ;
  u8 rsp[16U] ;
  u8 switch_bus_width ;
  u32 voltage ;
  bool sd20_mode ;
  int rty_cnt ;
  int tmp ;
  int func_num ;
    klee_make_symbolic(&func_num, sizeof(int), "func_num");
  struct _ddebug descriptor ;
  struct device *tmp___0 ;
  long tmp___1 ;
  struct _ddebug descriptor___0 ;
  struct device *tmp___2 ;
  long tmp___3 ;
  struct task_struct *tmp___4 ;
  long volatile   __ret ;
  struct task_struct *tmp___5 ;
  struct task_struct *tmp___6 ;
  struct task_struct *tmp___7 ;
  struct task_struct *tmp___8 ;
  struct task_struct *tmp___9 ;
  long volatile   __ret___0 ;
  struct task_struct *tmp___10 ;
  struct task_struct *tmp___11 ;
  struct task_struct *tmp___12 ;
  struct task_struct *tmp___13 ;
  int tmp___14 ;
  struct task_struct *tmp___15 ;
  long volatile   __ret___1 ;
  struct task_struct *tmp___16 ;
  struct task_struct *tmp___17 ;
  struct task_struct *tmp___18 ;
  struct task_struct *tmp___19 ;
  struct _ddebug descriptor___1 ;
  struct device *tmp___20 ;
  long tmp___21 ;
  int read_lba0 ;
    klee_make_symbolic(&read_lba0, sizeof(int), "read_lba0");

  {
  sd_card = & chip->sd_card;
  hi_cap_flow = 0;
  i = 0;
  j = 0;
  k = 0;
  sd_dont_switch = 0;
  support_1v8 = 0;
  try_sdio = 1;
  voltage = 0U;
  sd20_mode = 0;
  sd_card->sd_type = 0U;
  Switch_Fail: 
  i = 0;
  j = 0;
  k = 0;
  hi_cap_flow = 0;
  if ((int )sd_card->sd_lock_status & 1) {
    goto SD_UNLOCK_ENTRY;
  } else {

  }
  retval = sd_prepare_reset(chip);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "reset_sd", 2594);
    return (1);
  } else {

  }
  retval = sd_dummy_clock(chip);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "reset_sd", 2600);
    return (1);
  } else {

  }
  if ((chip->sdio_func_exist & 1 && (chip->sdio_func_exist & 2) == 0) && (int )try_sdio) {
    rty_cnt = 0;
    goto ldv_38940;
    ldv_38939: 
    tmp = detect_card_cd(chip, 4);
    if (tmp != 0) {
      sd_set_err_code(chip, 32);
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                  "reset_sd", 2610);
      return (1);
    } else {

    }
    retval = sd_send_cmd_get_rsp(chip, 5, 0U, 5, (u8 *)(& rsp), 5);
    if (retval == 0) {
      func_num = ((int )rsp[1] >> 4) & 7;
      if (func_num != 0) {
        descriptor.modname = "rts5208";
        descriptor.function = "reset_sd";
        descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c";
        descriptor.format = "SD_IO card (Function number: %d)!\n";
        descriptor.lineno = 2621U;
        descriptor.flags = 0U;
        tmp___1 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
        if (tmp___1 != 0L) {
          tmp___0 = rtsx_dev((struct rtsx_chip  const  *)chip);
          __dynamic_dev_dbg(& descriptor, (struct device  const  *)tmp___0, "SD_IO card (Function number: %d)!\n",
                            func_num);
        } else {

        }
        chip->sd_io = 1U;
        _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                    "reset_sd", 2623);
        return (1);
      } else {

      }
      goto ldv_38938;
    } else {

    }
    sd_init_power(chip);
    sd_dummy_clock(chip);
    rty_cnt = rty_cnt + 1;
    ldv_38940: ;
    if (chip->sdio_retry_cnt > rty_cnt) {
      goto ldv_38939;
    } else {

    }
    ldv_38938: 
    descriptor___0.modname = "rts5208";
    descriptor___0.function = "reset_sd";
    descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c";
    descriptor___0.format = "Normal card!\n";
    descriptor___0.lineno = 2635U;
    descriptor___0.flags = 0U;
    tmp___3 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
    if (tmp___3 != 0L) {
      tmp___2 = rtsx_dev((struct rtsx_chip  const  *)chip);
      __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)tmp___2, "Normal card!\n");
    } else {

    }
  } else {

  }
  RTY_SD_RST: 
  retval = sd_send_cmd_get_rsp(chip, 0, 0U, 4, (u8 *)0U, 0);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "reset_sd", 2643);
    return (1);
  } else {

  }
  tmp___4 = get_current();
  tmp___4->task_state_change = 0UL;
  __ret = 1L;
  switch (8UL) {
  case 1UL: 
  tmp___5 = get_current();
  __asm__  volatile   ("xchgb %b0, %1\n": "+q" (__ret), "+m" (tmp___5->state): : "memory",
                       "cc");
  goto ldv_38945;
  case 2UL: 
  tmp___6 = get_current();
  __asm__  volatile   ("xchgw %w0, %1\n": "+r" (__ret), "+m" (tmp___6->state): : "memory",
                       "cc");
  goto ldv_38945;
  case 4UL: 
  tmp___7 = get_current();
  __asm__  volatile   ("xchgl %0, %1\n": "+r" (__ret), "+m" (tmp___7->state): : "memory",
                       "cc");
  goto ldv_38945;
  case 8UL: 
  tmp___8 = get_current();
  __asm__  volatile   ("xchgq %q0, %1\n": "+r" (__ret), "+m" (tmp___8->state): : "memory",
                       "cc");
  goto ldv_38945;
  default: 
  __xchg_wrong_size();
  }
  ldv_38945: 
  schedule_timeout(5L);
  retval = sd_send_cmd_get_rsp(chip, 8, 426U, 1, (u8 *)(& rsp), 5);
  if (retval == 0) {
    if ((unsigned int )rsp[4] == 170U && ((int )rsp[3] & 15) == 1) {
      hi_cap_flow = 1;
      voltage = 1077673984U;
    } else {

    }
  } else {

  }
  if (! hi_cap_flow) {
    voltage = 3932160U;
    retval = sd_send_cmd_get_rsp(chip, 0, 0U, 4, (u8 *)0U, 0);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                  "reset_sd", 2664);
      return (1);
    } else {

    }
    tmp___9 = get_current();
    tmp___9->task_state_change = 0UL;
    __ret___0 = 1L;
    switch (8UL) {
    case 1UL: 
    tmp___10 = get_current();
    __asm__  volatile   ("xchgb %b0, %1\n": "+q" (__ret___0), "+m" (tmp___10->state): : "memory",
                         "cc");
    goto ldv_38953;
    case 2UL: 
    tmp___11 = get_current();
    __asm__  volatile   ("xchgw %w0, %1\n": "+r" (__ret___0), "+m" (tmp___11->state): : "memory",
                         "cc");
    goto ldv_38953;
    case 4UL: 
    tmp___12 = get_current();
    __asm__  volatile   ("xchgl %0, %1\n": "+r" (__ret___0), "+m" (tmp___12->state): : "memory",
                         "cc");
    goto ldv_38953;
    case 8UL: 
    tmp___13 = get_current();
    __asm__  volatile   ("xchgq %q0, %1\n": "+r" (__ret___0), "+m" (tmp___13->state): : "memory",
                         "cc");
    goto ldv_38953;
    default: 
    __xchg_wrong_size();
    }
    ldv_38953: 
    schedule_timeout(5L);
  } else {

  }
  ldv_38967: 
  retval = sd_send_cmd_get_rsp(chip, 55, 0U, 1, (u8 *)0U, 0);
  if (retval != 0) {
    tmp___14 = detect_card_cd(chip, 4);
    if (tmp___14 != 0) {
      sd_set_err_code(chip, 32);
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                  "reset_sd", 2677);
      return (1);
    } else {

    }
    j = j + 1;
    if (j <= 2) {
      goto RTY_SD_RST;
    } else {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                  "reset_sd", 2685);
      return (1);
    }
  } else {

  }
  retval = sd_send_cmd_get_rsp(chip, 41, voltage, 5, (u8 *)(& rsp), 5);
  if (retval != 0) {
    k = k + 1;
    if (k <= 2) {
      goto RTY_SD_RST;
    } else {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                  "reset_sd", 2697);
      return (1);
    }
  } else {

  }
  i = i + 1;
  tmp___15 = get_current();
  tmp___15->task_state_change = 0UL;
  __ret___1 = 1L;
  switch (8UL) {
  case 1UL: 
  tmp___16 = get_current();
  __asm__  volatile   ("xchgb %b0, %1\n": "+q" (__ret___1), "+m" (tmp___16->state): : "memory",
                       "cc");
  goto ldv_38961;
  case 2UL: 
  tmp___17 = get_current();
  __asm__  volatile   ("xchgw %w0, %1\n": "+r" (__ret___1), "+m" (tmp___17->state): : "memory",
                       "cc");
  goto ldv_38961;
  case 4UL: 
  tmp___18 = get_current();
  __asm__  volatile   ("xchgl %0, %1\n": "+r" (__ret___1), "+m" (tmp___18->state): : "memory",
                       "cc");
  goto ldv_38961;
  case 8UL: 
  tmp___19 = get_current();
  __asm__  volatile   ("xchgq %q0, %1\n": "+r" (__ret___1), "+m" (tmp___19->state): : "memory",
                       "cc");
  goto ldv_38961;
  default: 
  __xchg_wrong_size();
  }
  ldv_38961: 
  schedule_timeout(5L);
  if ((int )((signed char )rsp[1]) >= 0 && i <= 254) {
    goto ldv_38967;
  } else {

  }

  if (i == 255) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "reset_sd", 2707);
    return (1);
  } else {

  }
  if ((int )hi_cap_flow) {
    if (((int )rsp[1] & 64) != 0) {
      sd_card->sd_type = (u16 )((unsigned int )sd_card->sd_type | 4096U);
    } else {
      sd_card->sd_type = (unsigned int )sd_card->sd_type & 61439U;
    }
    support_1v8 = 0;
  } else {
    sd_card->sd_type = (unsigned int )sd_card->sd_type & 61439U;
    support_1v8 = 0;
  }
  descriptor___1.modname = "rts5208";
  descriptor___1.function = "reset_sd";
  descriptor___1.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c";
  descriptor___1.format = "support_1v8 = %d\n";
  descriptor___1.lineno = 2722U;
  descriptor___1.flags = 0U;
  tmp___21 = ldv__builtin_expect((long )descriptor___1.flags & 1L, 0L);
  if (tmp___21 != 0L) {
    tmp___20 = rtsx_dev((struct rtsx_chip  const  *)chip);
    __dynamic_dev_dbg(& descriptor___1, (struct device  const  *)tmp___20, "support_1v8 = %d\n",
                      (int )support_1v8);
  } else {

  }
  if ((int )support_1v8) {
    retval = sd_voltage_switch(chip);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                  "reset_sd", 2727);
      return (1);
    } else {

    }
  } else {

  }
  retval = sd_send_cmd_get_rsp(chip, 2, 0U, 2, (u8 *)0U, 0);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "reset_sd", 2735);
    return (1);
  } else {

  }
  i = 0;
  goto ldv_38972;
  ldv_38971: 
  retval = sd_send_cmd_get_rsp(chip, 3, 0U, 1, (u8 *)(& rsp), 5);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "reset_sd", 2743);
    return (1);
  } else {

  }
  sd_card->sd_addr = (unsigned int )rsp[1] << 24;
  sd_card->sd_addr = sd_card->sd_addr + ((unsigned int )rsp[2] << 16);
  if (sd_card->sd_addr != 0U) {
    goto ldv_38970;
  } else {

  }
  i = i + 1;
  ldv_38972: ;
  if (i <= 2) {
    goto ldv_38971;
  } else {

  }
  ldv_38970: 
  retval = sd_check_csd(chip, 1);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "reset_sd", 2756);
    return (1);
  } else {

  }
  retval = sd_select_card(chip, 1);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "reset_sd", 2762);
    return (1);
  } else {

  }
  SD_UNLOCK_ENTRY: 
  retval = sd_update_lock_status(chip);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "reset_sd", 2770);
    return (1);
  } else {

  }
  if ((int )((signed char )sd_card->sd_lock_status) < 0) {
    sd_card->sd_lock_status = (u8 )((unsigned int )sd_card->sd_lock_status | 96U);
    return (0);
  } else
  if (((int )sd_card->sd_lock_status & 1) == 0) {
    sd_card->sd_lock_status = (unsigned int )sd_card->sd_lock_status & 223U;
  } else {

  }
  retval = sd_send_cmd_get_rsp(chip, 55, sd_card->sd_addr, 1, (u8 *)0U, 0);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "reset_sd", 2785);
    return (1);
  } else {

  }
  retval = sd_send_cmd_get_rsp(chip, 42, 0U, 1, (u8 *)0U, 0);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "reset_sd", 2792);
    return (1);
  } else {

  }
  if ((int )support_1v8) {
    retval = sd_send_cmd_get_rsp(chip, 55, sd_card->sd_addr, 1, (u8 *)0U, 0);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                  "reset_sd", 2800);
      return (1);
    } else {

    }
    retval = sd_send_cmd_get_rsp(chip, 6, 2U, 1, (u8 *)0U, 0);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                  "reset_sd", 2807);
      return (1);
    } else {

    }
    switch_bus_width = 1U;
  } else {
    switch_bus_width = 0U;
  }
  retval = sd_send_cmd_get_rsp(chip, 16, 512U, 1, (u8 *)0U, 0);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "reset_sd", 2819);
    return (1);
  } else {

  }
  retval = sd_set_clock_divider(chip, 0);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "reset_sd", 2825);
    return (1);
  } else {

  }
  if (((int )sd_card->raw_csd[4] & 64) == 0) {
    sd_dont_switch = 1;
  } else {

  }
  if (! sd_dont_switch) {
    if ((int )sd20_mode) {
      sd_card->sd_switch_fail = 28U;
    } else {

    }
    retval = sd_check_spec(chip, (int )switch_bus_width);
    if (retval == 0) {
      retval = sd_switch_function(chip, (int )switch_bus_width);
      if (retval != 0) {
        sd_init_power(chip);
        sd_dont_switch = 1;
        try_sdio = 0;
        goto Switch_Fail;
      } else {

      }
    } else
    if ((int )support_1v8) {
      sd_init_power(chip);
      sd_dont_switch = 1;
      try_sdio = 0;
      goto Switch_Fail;
    } else {

    }
  } else {

  }
  if (! support_1v8) {
    retval = sd_send_cmd_get_rsp(chip, 55, sd_card->sd_addr, 1, (u8 *)0U, 0);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                  "reset_sd", 2867);
      return (1);
    } else {

    }
    retval = sd_send_cmd_get_rsp(chip, 6, 2U, 1, (u8 *)0U, 0);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                  "reset_sd", 2874);
      return (1);
    } else {

    }
  } else {

  }
  sd_card->sd_lock_status = (unsigned int )sd_card->sd_lock_status & 191U;
  if (! sd20_mode && (((((int )sd_card->sd_type & 255) == 0 && ((int )sd_card->sd_type & 512) != 0) || (((int )sd_card->sd_type & 255) == 0 && ((int )sd_card->sd_type & 1024) != 0)) || (((int )sd_card->sd_type & 255) == 0 && ((int )sd_card->sd_type & 2048) != 0))) {
    read_lba0 = 1;
    retval = rtsx_write_register(chip, 64862, 7, (int )chip->sd30_drive_sel_1v8);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                  "reset_sd", 2889);
      return (retval);
    } else {

    }
    retval = sd_set_init_para(chip);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                  "reset_sd", 2895);
      return (1);
    } else {

    }
    if (((int )sd_card->sd_type & 255) == 0 && ((int )sd_card->sd_type & 1024) != 0) {
      retval = sd_ddr_tuning(chip);
    } else {
      retval = sd_sdr_tuning(chip);
    }
    if (retval != 0) {
      if ((int )sd20_mode) {
        _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                    "reset_sd", 2906);
        return (1);
      } else {
        retval = sd_init_power(chip);
        if (retval != 0) {
          _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                      "reset_sd", 2911);
          return (1);
        } else {

        }
        try_sdio = 0;
        sd20_mode = 1;
        goto Switch_Fail;
      }
    } else {

    }
    sd_send_cmd_get_rsp(chip, 13, sd_card->sd_addr, 1, (u8 *)0U, 0);
    if (((int )sd_card->sd_type & 255) == 0 && ((int )sd_card->sd_type & 1024) != 0) {
      retval = sd_wait_state_data_ready(chip, 8, 1, 1000);
      if (retval != 0) {
        read_lba0 = 0;
      } else {

      }
    } else {

    }
    if (read_lba0 != 0) {
      retval = sd_read_lba0(chip);
      if (retval != 0) {
        if ((int )sd20_mode) {
          _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                      "reset_sd", 2934);
          return (1);
        } else {
          retval = sd_init_power(chip);
          if (retval != 0) {
            _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                        "reset_sd", 2939);
            return (1);
          } else {

          }
          try_sdio = 0;
          sd20_mode = 1;
          goto Switch_Fail;
        }
      } else {

      }
    } else {

    }
  } else {

  }
  retval = sd_check_wp_state(chip);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "reset_sd", 2953);
    return (1);
  } else {

  }
  chip->card_bus_width[(int )chip->card2lun[4]] = 4U;
  if ((int )sd_card->sd_lock_status & 1) {
    retval = rtsx_write_register(chip, (int )REG_SD_BLOCK_CNT_H, 255, 2);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                  "reset_sd", 2964);
      return (retval);
    } else {

    }
    retval = rtsx_write_register(chip, (int )REG_SD_BLOCK_CNT_L, 255, 0);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                  "reset_sd", 2970);
      return (retval);
    } else {

    }
  } else {

  }
  return (0);
}
}
static int mmc_test_switch_bus(struct rtsx_chip *chip , u8 width ) 
{ 
  struct sd_info *sd_card ;
  int retval ;
  u8 buf[8U] ;
  unsigned int tmp ;
  u8 bus_width ;
  u8 *ptr ;
  u16 byte_cnt ;
  int len ;
  struct _ddebug descriptor ;
  struct device *tmp___0 ;
  long tmp___1 ;
  u8 *tmp___2 ;
  struct _ddebug descriptor___0 ;
  struct device *tmp___3 ;
  long tmp___4 ;
  u8 rsp[5U] ;
  u32 arg ;
  struct _ddebug descriptor___1 ;
  struct device *tmp___5 ;
  long tmp___6 ;
  u8 rsp___0[5U] ;
  u32 arg___0 ;

  {
  sd_card = & chip->sd_card;
  buf[0] = 0U;
  tmp = 1U;
  while (1) {
    if (tmp >= 8U) {
      break;
    } else {

    }
    buf[tmp] = (unsigned char)0;
    tmp = tmp + 1U;
  }
  retval = sd_send_cmd_get_rsp(chip, 19, 0U, 1, (u8 *)0U, 0);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "mmc_test_switch_bus", 2991);
    return (2);
  } else {

  }
  if ((unsigned int )width == 16U) {
    buf[0] = 85U;
    buf[1] = 170U;
    len = 8;
    byte_cnt = 8U;
    bus_width = 2U;
  } else {
    buf[0] = 90U;
    len = 4;
    byte_cnt = 4U;
    bus_width = 1U;
  }
  retval = rtsx_write_register(chip, (int )REG_SD_CFG3, 2, 2);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "mmc_test_switch_bus", 3010);
    return (1);
  } else {

  }
  retval = sd_write_data(chip, 1, (u8 *)0U, 0, (int )byte_cnt, 1, (int )bus_width,
                         (u8 *)(& buf), len, 100);
  if (retval != 0) {
    rtsx_clear_sd_error(chip);
    rtsx_write_register(chip, (int )REG_SD_CFG3, 2, 0);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "mmc_test_switch_bus", 3019);
    return (1);
  } else {

  }
  retval = rtsx_write_register(chip, (int )REG_SD_CFG3, 2, 0);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "mmc_test_switch_bus", 3025);
    return (1);
  } else {

  }
  descriptor.modname = "rts5208";
  descriptor.function = "mmc_test_switch_bus";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c";
  descriptor.format = "SD/MMC CMD %d\n";
  descriptor.lineno = 3029U;
  descriptor.flags = 0U;
  tmp___1 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp___1 != 0L) {
    tmp___0 = rtsx_dev((struct rtsx_chip  const  *)chip);
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)tmp___0, "SD/MMC CMD %d\n",
                      14);
  } else {

  }
  chip->ci = 0;
  rtsx_add_cmd(chip, 1, (int )REG_SD_CMD0, 255, 78);
  if ((unsigned int )width == 16U) {
    rtsx_add_cmd(chip, 1, (int )REG_SD_BYTE_CNT_L, 255, 8);
  } else {
    rtsx_add_cmd(chip, 1, (int )REG_SD_BYTE_CNT_L, 255, 4);
  }
  rtsx_add_cmd(chip, 1, (int )REG_SD_BLOCK_CNT_L, 255, 1);
  rtsx_add_cmd(chip, 1, (int )REG_SD_BLOCK_CNT_H, 255, 0);
  rtsx_add_cmd(chip, 1, (int )REG_SD_CFG2, 255, 65);
  rtsx_add_cmd(chip, 1, 64859, 1, 1);
  rtsx_add_cmd(chip, 1, (int )REG_SD_TRANSFER, 255, 140);
  rtsx_add_cmd(chip, 2, (int )REG_SD_TRANSFER, 64, 64);
  rtsx_add_cmd(chip, 0, 64000, 0, 0);
  if ((unsigned int )width == 16U) {
    rtsx_add_cmd(chip, 0, 64001, 0, 0);
  } else {

  }
  retval = rtsx_send_cmd(chip, 4, 100);
  if (retval < 0) {
    rtsx_clear_sd_error(chip);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "mmc_test_switch_bus", 3062);
    return (1);
  } else {

  }
  tmp___2 = rtsx_get_cmd_data(chip);
  ptr = tmp___2 + 1UL;
  if ((unsigned int )width == 16U) {
    descriptor___0.modname = "rts5208";
    descriptor___0.function = "mmc_test_switch_bus";
    descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c";
    descriptor___0.format = "BUSTEST_R [8bits]: 0x%02x 0x%02x\n";
    descriptor___0.lineno = 3070U;
    descriptor___0.flags = 0U;
    tmp___4 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
    if (tmp___4 != 0L) {
      tmp___3 = rtsx_dev((struct rtsx_chip  const  *)chip);
      __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)tmp___3, "BUSTEST_R [8bits]: 0x%02x 0x%02x\n",
                        (int )*ptr, (int )*(ptr + 1UL));
    } else {

    }
    if ((unsigned int )*ptr == 170U && (unsigned int )*(ptr + 1UL) == 85U) {
      if (((int )sd_card->sd_type & 255) == 1 && ((int )sd_card->sd_type & 8192) != 0) {
        arg = 62326272U;
      } else {
        arg = 62325248U;
      }
      retval = sd_send_cmd_get_rsp(chip, 6, arg, 9, (u8 *)(& rsp), 5);
      if (retval == 0 && (int )((signed char )rsp[4]) >= 0) {
        return (0);
      } else {

      }
    } else {

    }
  } else {
    descriptor___1.modname = "rts5208";
    descriptor___1.function = "mmc_test_switch_bus";
    descriptor___1.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c";
    descriptor___1.format = "BUSTEST_R [4bits]: 0x%02x\n";
    descriptor___1.lineno = 3087U;
    descriptor___1.flags = 0U;
    tmp___6 = ldv__builtin_expect((long )descriptor___1.flags & 1L, 0L);
    if (tmp___6 != 0L) {
      tmp___5 = rtsx_dev((struct rtsx_chip  const  *)chip);
      __dynamic_dev_dbg(& descriptor___1, (struct device  const  *)tmp___5, "BUSTEST_R [4bits]: 0x%02x\n",
                        (int )*ptr);
    } else {

    }
    if ((unsigned int )*ptr == 165U) {
      if (((int )sd_card->sd_type & 255) == 1 && ((int )sd_card->sd_type & 8192) != 0) {
        arg___0 = 62326016U;
      } else {
        arg___0 = 62324992U;
      }
      retval = sd_send_cmd_get_rsp(chip, 6, arg___0, 9, (u8 *)(& rsp___0), 5);
      if (retval == 0 && (int )((signed char )rsp___0[4]) >= 0) {
        return (0);
      } else {

      }
    } else {

    }
  }
  _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
              "mmc_test_switch_bus", 3105);
  return (2);
}
}
static int mmc_switch_timing_bus(struct rtsx_chip *chip , bool switch_ddr ) 
{ 
  struct sd_info *sd_card ;
  int retval ;
  u8 *ptr ;
  u8 card_type ;
  u8 card_type_mask ;
  struct _ddebug descriptor ;
  struct device *tmp ;
  long tmp___0 ;
  u8 rsp[5U] ;

  {
  sd_card = & chip->sd_card;
  card_type_mask = 0U;
  sd_card->sd_type = (unsigned int )sd_card->sd_type & 57343U;
  sd_card->sd_type = (unsigned int )sd_card->sd_type & 65023U;
  sd_card->sd_type = (unsigned int )sd_card->sd_type & 65279U;
  descriptor.modname = "rts5208";
  descriptor.function = "mmc_switch_timing_bus";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c";
  descriptor.format = "SD/MMC CMD %d\n";
  descriptor.lineno = 3118U;
  descriptor.flags = 0U;
  tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp___0 != 0L) {
    tmp = rtsx_dev((struct rtsx_chip  const  *)chip);
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)tmp, "SD/MMC CMD %d\n",
                      8);
  } else {

  }
  chip->ci = 0;
  rtsx_add_cmd(chip, 1, (int )REG_SD_CMD0, 255, 72);
  rtsx_add_cmd(chip, 1, (int )REG_SD_CMD1, 255, 0);
  rtsx_add_cmd(chip, 1, (int )REG_SD_CMD2, 255, 0);
  rtsx_add_cmd(chip, 1, (int )REG_SD_CMD3, 255, 0);
  rtsx_add_cmd(chip, 1, (int )REG_SD_CMD4, 255, 0);
  rtsx_add_cmd(chip, 1, (int )REG_SD_BYTE_CNT_L, 255, 0);
  rtsx_add_cmd(chip, 1, (int )REG_SD_BYTE_CNT_H, 255, 2);
  rtsx_add_cmd(chip, 1, (int )REG_SD_BLOCK_CNT_L, 255, 1);
  rtsx_add_cmd(chip, 1, (int )REG_SD_BLOCK_CNT_H, 255, 0);
  rtsx_add_cmd(chip, 1, (int )REG_SD_CFG2, 255, 1);
  rtsx_add_cmd(chip, 1, 64859, 1, 1);
  rtsx_add_cmd(chip, 1, (int )REG_SD_TRANSFER, 255, 140);
  rtsx_add_cmd(chip, 2, (int )REG_SD_TRANSFER, 64, 64);
  rtsx_add_cmd(chip, 0, 64196, 255, 0);
  rtsx_add_cmd(chip, 0, 64212, 255, 0);
  rtsx_add_cmd(chip, 0, 64213, 255, 0);
  rtsx_add_cmd(chip, 0, 64214, 255, 0);
  rtsx_add_cmd(chip, 0, 64215, 255, 0);
  retval = rtsx_send_cmd(chip, 4, 1000);
  if (retval < 0) {
    if (retval == -110) {
      rtsx_clear_sd_error(chip);
      sd_send_cmd_get_rsp(chip, 13, sd_card->sd_addr, 1, (u8 *)0U, 0);
    } else {

    }
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "mmc_switch_timing_bus", 3157);
    return (1);
  } else {

  }
  ptr = rtsx_get_cmd_data(chip);
  if (((int )*ptr & 16) != 0) {
    sd_send_cmd_get_rsp(chip, 13, sd_card->sd_addr, 1, (u8 *)0U, 0);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "mmc_switch_timing_bus", 3165);
    return (1);
  } else {

  }
  if (((int )sd_card->sd_type & 255) == 1 && ((int )sd_card->sd_type & 4096) != 0) {
    sd_card->capacity = ((((unsigned int )*(ptr + 5UL) << 24) | ((unsigned int )*(ptr + 4UL) << 16)) | ((unsigned int )*(ptr + 3UL) << 8)) | (unsigned int )*(ptr + 2UL);
  } else {

  }
  card_type_mask = 3U;
  card_type = (u8 )((int )*(ptr + 1UL) & (int )card_type_mask);
  if ((unsigned int )card_type != 0U) {
    if (((int )card_type & 4) != 0) {
      if ((int )switch_ddr) {
        sd_card->sd_type = (u16 )((unsigned int )sd_card->sd_type | 8192U);
      } else {
        sd_card->sd_type = (u16 )((unsigned int )sd_card->sd_type | 512U);
      }
    } else
    if (((int )card_type & 2) != 0) {
      sd_card->sd_type = (u16 )((unsigned int )sd_card->sd_type | 512U);
    } else {
      sd_card->sd_type = (u16 )((unsigned int )sd_card->sd_type | 256U);
    }
    retval = sd_send_cmd_get_rsp(chip, 6, 62456064U, 9, (u8 *)(& rsp), 5);
    if (retval != 0 || (int )((signed char )rsp[4]) < 0) {
      sd_card->sd_type = (unsigned int )sd_card->sd_type & 57343U;
      sd_card->sd_type = (unsigned int )sd_card->sd_type & 65023U;
      sd_card->sd_type = (unsigned int )sd_card->sd_type & 65279U;
    } else {

    }
  } else {

  }
  sd_choose_proper_clock(chip);
  retval = switch_clock(chip, sd_card->sd_clock);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "mmc_switch_timing_bus", 3199);
    return (1);
  } else {

  }
  retval = mmc_test_switch_bus(chip, 16);
  if (retval == 0) {
    sd_card->sd_type = (u16 )((unsigned int )sd_card->sd_type | 2048U);
    chip->card_bus_width[(int )chip->card2lun[4]] = 8U;
    sd_card->sd_lock_status = (unsigned int )sd_card->sd_lock_status & 191U;
  } else
  if (retval == 2) {
    retval = mmc_test_switch_bus(chip, 32);
    if (retval == 0) {
      sd_card->sd_type = (u16 )((unsigned int )sd_card->sd_type | 1024U);
      chip->card_bus_width[(int )chip->card2lun[4]] = 4U;
      sd_card->sd_lock_status = (unsigned int )sd_card->sd_lock_status & 191U;
    } else
    if (retval == 2) {
      sd_card->sd_type = (unsigned int )sd_card->sd_type & 63487U;
      sd_card->sd_type = (unsigned int )sd_card->sd_type & 64511U;
    } else {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                  "mmc_switch_timing_bus", 3223);
      return (1);
    }
  } else {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "mmc_switch_timing_bus", 3227);
    return (1);
  }
  return (0);
}
}
static int reset_mmc(struct rtsx_chip *chip ) 
{ 
  struct sd_info *sd_card ;
  int retval ;
  int i ;
  int j ;
  int k ;
  bool switch_ddr ;
  u8 rsp[16U] ;
  u8 spec_ver ;
  u32 temp ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  struct task_struct *tmp___2 ;
  long volatile   __ret ;
  struct task_struct *tmp___3 ;
  struct task_struct *tmp___4 ;
  struct task_struct *tmp___5 ;
  struct task_struct *tmp___6 ;

  {
  sd_card = & chip->sd_card;
  i = 0;
  j = 0;
  k = 0;
  switch_ddr = 1;
  spec_ver = 0U;
  if ((int )sd_card->sd_lock_status & 1) {
    goto MMC_UNLOCK_ENTRY;
  } else {

  }
  Switch_Fail: 
  retval = sd_prepare_reset(chip);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "reset_mmc", 3252);
    return (retval);
  } else {

  }
  sd_card->sd_type = 1U;
  RTY_MMC_RST: 
  retval = sd_send_cmd_get_rsp(chip, 0, 0U, 4, (u8 *)0U, 0);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "reset_mmc", 3262);
    return (1);
  } else {

  }
  ldv_39029: 
  tmp = detect_card_cd(chip, 4);
  if (tmp != 0) {
    sd_set_err_code(chip, 32);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "reset_mmc", 3269);
    return (1);
  } else {

  }
  retval = sd_send_cmd_get_rsp(chip, 1, 1077673984U, 5, (u8 *)(& rsp), 5);
  if (retval != 0) {
    tmp___0 = sd_check_err_code(chip, 16);
    if (tmp___0 != 0) {
      goto _L;
    } else {
      tmp___1 = sd_check_err_code(chip, 64);
      if (tmp___1 != 0) {
        _L: /* CIL Label */ 
        k = k + 1;
        if (k <= 19) {
          sd_clr_err_code(chip);
          goto RTY_MMC_RST;
        } else {
          _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                      "reset_mmc", 3284);
          return (1);
        }
      } else {
        j = j + 1;
        if (j <= 99) {
          sd_clr_err_code(chip);
          goto RTY_MMC_RST;
        } else {
          _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                      "reset_mmc", 3293);
          return (1);
        }
      }
    }
  } else {

  }
  tmp___2 = get_current();
  tmp___2->task_state_change = 0UL;
  __ret = 1L;
  switch (8UL) {
  case 1UL: 
  tmp___3 = get_current();
  __asm__  volatile   ("xchgb %b0, %1\n": "+q" (__ret), "+m" (tmp___3->state): : "memory",
                       "cc");
  goto ldv_39023;
  case 2UL: 
  tmp___4 = get_current();
  __asm__  volatile   ("xchgw %w0, %1\n": "+r" (__ret), "+m" (tmp___4->state): : "memory",
                       "cc");
  goto ldv_39023;
  case 4UL: 
  tmp___5 = get_current();
  __asm__  volatile   ("xchgl %0, %1\n": "+r" (__ret), "+m" (tmp___5->state): : "memory",
                       "cc");
  goto ldv_39023;
  case 8UL: 
  tmp___6 = get_current();
  __asm__  volatile   ("xchgq %q0, %1\n": "+r" (__ret), "+m" (tmp___6->state): : "memory",
                       "cc");
  goto ldv_39023;
  default: 
  __xchg_wrong_size();
  }
  ldv_39023: 
  schedule_timeout(5L);
  i = i + 1;
  if ((int )((signed char )rsp[1]) >= 0 && i <= 254) {
    goto ldv_39029;
  } else {

  }

  if (i == 255) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "reset_mmc", 3304);
    return (1);
  } else {

  }
  if (((int )rsp[1] & 96) == 64) {
    sd_card->sd_type = (u16 )((unsigned int )sd_card->sd_type | 4096U);
  } else {
    sd_card->sd_type = (unsigned int )sd_card->sd_type & 61439U;
  }
  retval = sd_send_cmd_get_rsp(chip, 2, 0U, 2, (u8 *)0U, 0);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "reset_mmc", 3316);
    return (1);
  } else {

  }
  sd_card->sd_addr = 1048576U;
  retval = sd_send_cmd_get_rsp(chip, 3, sd_card->sd_addr, 1, (u8 *)(& rsp), 5);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "reset_mmc", 3324);
    return (1);
  } else {

  }
  retval = sd_check_csd(chip, 1);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "reset_mmc", 3330);
    return (1);
  } else {

  }
  spec_ver = (u8 )(((int )sd_card->raw_csd[0] & 60) >> 2);
  retval = sd_select_card(chip, 1);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "reset_mmc", 3338);
    return (1);
  } else {

  }
  retval = sd_send_cmd_get_rsp(chip, 16, 512U, 1, (u8 *)0U, 0);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "reset_mmc", 3345);
    return (1);
  } else {

  }
  MMC_UNLOCK_ENTRY: 
  retval = sd_update_lock_status(chip);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "reset_mmc", 3353);
    return (1);
  } else {

  }
  retval = sd_set_clock_divider(chip, 0);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "reset_mmc", 3360);
    return (1);
  } else {

  }
  chip->card_bus_width[(int )chip->card2lun[4]] = 1U;
  if (sd_card->mmc_dont_switch_bus == 0) {
    if ((unsigned int )spec_ver == 4U) {
      retval = mmc_switch_timing_bus(chip, (int )switch_ddr);
      if (retval != 0) {
        retval = sd_init_power(chip);
        if (retval != 0) {
          _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                      "reset_mmc", 3373);
          return (1);
        } else {

        }
        sd_card->mmc_dont_switch_bus = 1;
        _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                    "reset_mmc", 3377);
        goto Switch_Fail;
      } else {

      }
    } else {

    }
    if ((((int )sd_card->sd_type & 255) == 1 && ((int )sd_card->sd_type & 4096) != 0) && sd_card->capacity == 0U) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                  "reset_mmc", 3383);
      return (1);
    } else {

    }
    if ((int )switch_ddr && (((int )sd_card->sd_type & 255) == 1 && ((int )sd_card->sd_type & 8192) != 0)) {
      retval = sd_set_init_para(chip);
      if (retval != 0) {
        _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                    "reset_mmc", 3390);
        return (1);
      } else {

      }
      retval = mmc_ddr_tuning(chip);
      if (retval != 0) {
        retval = sd_init_power(chip);
        if (retval != 0) {
          _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                      "reset_mmc", 3398);
          return (1);
        } else {

        }
        switch_ddr = 0;
        _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                    "reset_mmc", 3403);
        goto Switch_Fail;
      } else {

      }
      retval = sd_wait_state_data_ready(chip, 8, 1, 1000);
      if (retval == 0) {
        retval = sd_read_lba0(chip);
        if (retval != 0) {
          retval = sd_init_power(chip);
          if (retval != 0) {
            _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                        "reset_mmc", 3413);
            return (1);
          } else {

          }
          switch_ddr = 0;
          _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                      "reset_mmc", 3418);
          goto Switch_Fail;
        } else {

        }
      } else {

      }
    } else {

    }
  } else {

  }
  if ((int )sd_card->sd_lock_status & 1) {
    retval = rtsx_write_register(chip, (int )REG_SD_BLOCK_CNT_H, 255, 2);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                  "reset_mmc", 3430);
      return (retval);
    } else {

    }
    retval = rtsx_write_register(chip, (int )REG_SD_BLOCK_CNT_L, 255, 0);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                  "reset_mmc", 3436);
      return (retval);
    } else {

    }
  } else {

  }
  temp = ioread32((chip->rtsx)->remap_addr + 20UL);
  if ((temp & 524288U) != 0U) {
    chip->card_wp = (u8 )((unsigned int )chip->card_wp | 4U);
  } else {

  }
  return (0);
}
}
int reset_sd_card(struct rtsx_chip *chip ) 
{ 
  struct sd_info *sd_card ;
  int retval ;
  int tmp ;
  int tmp___0 ;
  struct _ddebug descriptor ;
  struct device *tmp___1 ;
  long tmp___2 ;

  {
  sd_card = & chip->sd_card;
  sd_init_reg_addr(chip);
  memset((void *)sd_card, 0, 104UL);
  chip->capacity[(int )chip->card2lun[4]] = 0U;
  retval = enable_card_clock(chip, 4);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "reset_sd_card", 3461);
    return (1);
  } else {

  }
  if ((chip->ignore_sd != 0 && chip->sdio_func_exist & 1) && (chip->sdio_func_exist & 2) == 0) {
    if (chip->asic_code != 0) {
      retval = sd_pull_ctl_enable(chip);
      if (retval != 0) {
        _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                    "reset_sd_card", 3470);
        return (1);
      } else {

      }
    } else {
      retval = rtsx_write_register(chip, 64541, 40, 0);
      if (retval != 0) {
        _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                    "reset_sd_card", 3477);
        return (1);
      } else {

      }
    }
    retval = card_share_mode(chip, 4);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                  "reset_sd_card", 3483);
      return (1);
    } else {

    }
    chip->sd_io = 1U;
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "reset_sd_card", 3488);
    return (1);
  } else {

  }
  retval = sd_init_power(chip);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "reset_sd_card", 3494);
    return (1);
  } else {

  }
  if ((chip->sd_ctl & 128U) != 0U) {
    retval = reset_mmc(chip);
    if (retval != 0) {
      tmp = sd_check_err_code(chip, 32);
      if (tmp != 0) {
        _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                    "reset_sd_card", 3502);
        return (1);
      } else {

      }
      retval = reset_sd(chip);
      if (retval != 0) {
        _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                    "reset_sd_card", 3508);
        return (1);
      } else {

      }
    } else {

    }
  } else {
    retval = reset_sd(chip);
    if (retval != 0) {
      tmp___0 = sd_check_err_code(chip, 32);
      if (tmp___0 != 0) {
        _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                    "reset_sd_card", 3516);
        return (1);
      } else {

      }
      if ((unsigned int )chip->sd_io != 0U) {
        _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                    "reset_sd_card", 3521);
        return (1);
      } else {
        retval = reset_mmc(chip);
        if (retval != 0) {
          _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                      "reset_sd_card", 3526);
          return (1);
        } else {

        }
      }
    } else {

    }
  }
  retval = sd_set_clock_divider(chip, 0);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "reset_sd_card", 3535);
    return (1);
  } else {

  }
  retval = rtsx_write_register(chip, (int )REG_SD_BYTE_CNT_L, 255, 0);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "reset_sd_card", 3541);
    return (retval);
  } else {

  }
  retval = rtsx_write_register(chip, (int )REG_SD_BYTE_CNT_H, 255, 2);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "reset_sd_card", 3546);
    return (retval);
  } else {

  }
  chip->capacity[(int )chip->card2lun[4]] = sd_card->capacity;
  retval = sd_set_init_para(chip);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "reset_sd_card", 3554);
    return (1);
  } else {

  }
  descriptor.modname = "rts5208";
  descriptor.function = "reset_sd_card";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c";
  descriptor.format = "sd_card->sd_type = 0x%x\n";
  descriptor.lineno = 3558U;
  descriptor.flags = 0U;
  tmp___2 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp___2 != 0L) {
    tmp___1 = rtsx_dev((struct rtsx_chip  const  *)chip);
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)tmp___1, "sd_card->sd_type = 0x%x\n",
                      (int )sd_card->sd_type);
  } else {

  }
  return (0);
}
}
static int reset_mmc_only(struct rtsx_chip *chip ) 
{ 
  struct sd_info *sd_card ;
  int retval ;
  u32 tmp ;
  struct _ddebug descriptor ;
  struct device *tmp___0 ;
  long tmp___1 ;

  {
  sd_card = & chip->sd_card;
  sd_card->sd_type = 0U;
  sd_card->seq_mode = 0;
  sd_card->sd_data_buf_ready = 0U;
  sd_card->capacity = 0U;
  sd_card->sd_switch_fail = 0U;
  sd_card->sd_lock_status = 0U;
  sd_card->sd_erase_status = 0U;
  tmp = 0U;
  sd_card->capacity = tmp;
  chip->capacity[(int )chip->card2lun[4]] = tmp;
  retval = enable_card_clock(chip, 4);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "reset_mmc_only", 3583);
    return (1);
  } else {

  }
  retval = sd_init_power(chip);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "reset_mmc_only", 3589);
    return (1);
  } else {

  }
  retval = reset_mmc(chip);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "reset_mmc_only", 3595);
    return (1);
  } else {

  }
  retval = sd_set_clock_divider(chip, 0);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "reset_mmc_only", 3601);
    return (1);
  } else {

  }
  retval = rtsx_write_register(chip, (int )REG_SD_BYTE_CNT_L, 255, 0);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "reset_mmc_only", 3607);
    return (retval);
  } else {

  }
  retval = rtsx_write_register(chip, (int )REG_SD_BYTE_CNT_H, 255, 2);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "reset_mmc_only", 3612);
    return (retval);
  } else {

  }
  chip->capacity[(int )chip->card2lun[4]] = sd_card->capacity;
  retval = sd_set_init_para(chip);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "reset_mmc_only", 3620);
    return (1);
  } else {

  }
  descriptor.modname = "rts5208";
  descriptor.function = "reset_mmc_only";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c";
  descriptor.format = "In reset_mmc_only, sd_card->sd_type = 0x%x\n";
  descriptor.lineno = 3625U;
  descriptor.flags = 0U;
  tmp___1 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp___1 != 0L) {
    tmp___0 = rtsx_dev((struct rtsx_chip  const  *)chip);
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)tmp___0, "In reset_mmc_only, sd_card->sd_type = 0x%x\n",
                      (int )sd_card->sd_type);
  } else {

  }
  return (0);
}
}
static int wait_data_buf_ready(struct rtsx_chip *chip ) 
{ 
  struct sd_info *sd_card ;
  int i ;
  int retval ;
  int tmp ;
  int tmp___0 ;

  {
  sd_card = & chip->sd_card;
  i = 0;
  goto ldv_39053;
  ldv_39052: 
  tmp = detect_card_cd(chip, 4);
  if (tmp != 0) {
    sd_set_err_code(chip, 32);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "wait_data_buf_ready", 3640);
    return (1);
  } else {

  }
  sd_card->sd_data_buf_ready = 0U;
  retval = sd_send_cmd_get_rsp(chip, 13, sd_card->sd_addr, 1, (u8 *)0U, 0);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "wait_data_buf_ready", 3649);
    return (1);
  } else {

  }
  if ((unsigned int )sd_card->sd_data_buf_ready != 0U) {
    tmp___0 = sd_send_cmd_get_rsp(chip, 13, sd_card->sd_addr, 1, (u8 *)0U, 0);
    return (tmp___0);
  } else {

  }
  i = i + 1;
  ldv_39053: ;
  if (i <= 254) {
    goto ldv_39052;
  } else {

  }
  sd_set_err_code(chip, 64);
  _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
              "wait_data_buf_ready", 3661);
  return (1);
}
}
void sd_stop_seq_mode(struct rtsx_chip *chip ) 
{ 
  struct sd_info *sd_card ;
  int retval ;

  {
  sd_card = & chip->sd_card;
  if (sd_card->seq_mode != 0) {
    retval = sd_switch_clock(chip);
    if (retval != 0) {
      return;
    } else {

    }
    retval = sd_send_cmd_get_rsp(chip, 12, 0U, 9, (u8 *)0U, 0);
    if (retval != 0) {
      sd_set_err_code(chip, 8);
    } else {

    }
    retval = sd_wait_state_data_ready(chip, 8, 1, 1000);
    if (retval != 0) {
      sd_set_err_code(chip, 8);
    } else {

    }
    sd_card->seq_mode = 0;
    rtsx_write_register(chip, 65076, 128, 128);
  } else {

  }
  return;
}
}
__inline static int sd_auto_tune_clock(struct rtsx_chip *chip ) 
{ 
  struct sd_info *sd_card ;
  int retval ;

  {
  sd_card = & chip->sd_card;
  if (chip->asic_code != 0) {
    if (sd_card->sd_clock > 30) {
      sd_card->sd_clock = sd_card->sd_clock + -20;
    } else {

    }
  } else {
    switch (sd_card->sd_clock) {
    case 10: 
    sd_card->sd_clock = 9;
    goto ldv_39066;
    case 9: 
    sd_card->sd_clock = 8;
    goto ldv_39066;
    case 8: 
    sd_card->sd_clock = 7;
    goto ldv_39066;
    case 7: 
    sd_card->sd_clock = 6;
    goto ldv_39066;
    case 6: 
    sd_card->sd_clock = 5;
    goto ldv_39066;
    case 5: 
    sd_card->sd_clock = 4;
    goto ldv_39066;
    default: ;
    goto ldv_39066;
    }
    ldv_39066: ;
  }
  retval = sd_switch_clock(chip);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "sd_auto_tune_clock", 3731);
    return (1);
  } else {

  }
  return (0);
}
}
int sd_rw(struct scsi_cmnd *srb , struct rtsx_chip *chip , u32 start_sector , u16 sector_cnt ) 
{ 
  struct sd_info *sd_card ;
  u32 data_addr ;
  u8 cfg2 ;
  int retval ;
  struct _ddebug descriptor ;
  struct device *tmp ;
  long tmp___0 ;
  struct _ddebug descriptor___0 ;
  struct device *tmp___1 ;
  long tmp___2 ;
  struct _ddebug descriptor___1 ;
  struct device *tmp___3 ;
  long tmp___4 ;
  unsigned int tmp___5 ;
  unsigned int tmp___6 ;
  struct scatterlist *tmp___7 ;
  u8 stat ;
  int err ;
  struct _ddebug descriptor___2 ;
  struct device *tmp___8 ;
  long tmp___9 ;
  int tmp___10 ;
  struct _ddebug descriptor___3 ;
  struct device *tmp___11 ;
  long tmp___12 ;
  struct _ddebug descriptor___4 ;
  struct device *tmp___13 ;
  long tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;

  {
  sd_card = & chip->sd_card;
  if ((unsigned int )srb->sc_data_direction == 2U) {
    descriptor.modname = "rts5208";
    descriptor.function = "sd_rw";
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c";
    descriptor.format = "sd_rw: Read %d %s from 0x%x\n";
    descriptor.lineno = 3749U;
    descriptor.flags = 0U;
    tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
    if (tmp___0 != 0L) {
      tmp = rtsx_dev((struct rtsx_chip  const  *)chip);
      __dynamic_dev_dbg(& descriptor, (struct device  const  *)tmp, "sd_rw: Read %d %s from 0x%x\n",
                        (int )sector_cnt, (unsigned int )sector_cnt > 1U ? (char *)"sectors" : (char *)"sector",
                        start_sector);
    } else {

    }
  } else {
    descriptor___0.modname = "rts5208";
    descriptor___0.function = "sd_rw";
    descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c";
    descriptor___0.format = "sd_rw: Write %d %s to 0x%x\n";
    descriptor___0.lineno = 3753U;
    descriptor___0.flags = 0U;
    tmp___2 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
    if (tmp___2 != 0L) {
      tmp___1 = rtsx_dev((struct rtsx_chip  const  *)chip);
      __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)tmp___1, "sd_rw: Write %d %s to 0x%x\n",
                        (int )sector_cnt, (unsigned int )sector_cnt > 1U ? (char *)"sectors" : (char *)"sector",
                        start_sector);
    } else {

    }
  }
  sd_card->cleanup_counter = 0;
  if (((int )chip->card_ready & 4) == 0) {
    sd_card->seq_mode = 0;
    retval = reset_sd_card(chip);
    if (retval == 0) {
      chip->card_ready = (u8 )((unsigned int )chip->card_ready | 4U);
      chip->card_fail = (unsigned int )chip->card_fail & 251U;
    } else {
      chip->card_ready = (unsigned int )chip->card_ready & 251U;
      chip->card_fail = (u8 )((unsigned int )chip->card_fail | 4U);
      chip->capacity[(int )chip->card2lun[4]] = 0U;
      chip->rw_need_retry = 1;
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                  "sd_rw", 3770);
      return (1);
    }
  } else {

  }
  if ((((int )sd_card->sd_type & 255) != 0 || ((int )sd_card->sd_type & 4096) == 0) && (((int )sd_card->sd_type & 255) != 1 || ((int )sd_card->sd_type & 4096) == 0)) {
    data_addr = start_sector << 9;
  } else {
    data_addr = start_sector;
  }
  sd_clr_err_code(chip);
  retval = sd_switch_clock(chip);
  if (retval != 0) {
    sd_set_err_code(chip, 2);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "sd_rw", 3785);
    goto RW_FAIL;
  } else {

  }
  if (sd_card->seq_mode != 0 && ((unsigned int )sd_card->pre_dir != (unsigned int )srb->sc_data_direction || sd_card->pre_sec_addr + (u32 )sd_card->pre_sec_cnt != start_sector)) {
    if (((((unsigned int )sd_card->pre_sec_cnt <= 127U && (unsigned int )sd_card->pre_dir == 2U) && (((((int )sd_card->sd_type & 255) != 0 || ((int )sd_card->sd_type & 512) == 0) && (((int )sd_card->sd_type & 255) != 0 || ((int )sd_card->sd_type & 1024) == 0)) && (((int )sd_card->sd_type & 255) != 0 || ((int )sd_card->sd_type & 2048) == 0))) && (((int )sd_card->sd_type & 255) != 0 || ((int )sd_card->sd_type & 256) == 0)) && ((((int )sd_card->sd_type & 255) != 1 || ((int )sd_card->sd_type & 512) == 0) || (((int )sd_card->sd_type & 255) != 1 || ((int )sd_card->sd_type & 256) == 0))) {
      sd_send_cmd_get_rsp(chip, 13, sd_card->sd_addr, 1, (u8 *)0U, 0);
    } else {

    }
    retval = sd_send_cmd_get_rsp(chip, 12, 0U, 9, (u8 *)0U, 0);
    if (retval != 0) {
      chip->rw_need_retry = 1;
      sd_set_err_code(chip, 8);
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                  "sd_rw", 3807);
      goto RW_FAIL;
    } else {

    }
    sd_card->seq_mode = 0;
    retval = rtsx_write_register(chip, 65076, 128, 128);
    if (retval != 0) {
      sd_set_err_code(chip, 2);
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                  "sd_rw", 3816);
      goto RW_FAIL;
    } else {

    }
    if ((((unsigned int )sd_card->pre_sec_cnt <= 127U && (((((int )sd_card->sd_type & 255) != 0 || ((int )sd_card->sd_type & 512) == 0) && (((int )sd_card->sd_type & 255) != 0 || ((int )sd_card->sd_type & 1024) == 0)) && (((int )sd_card->sd_type & 255) != 0 || ((int )sd_card->sd_type & 2048) == 0))) && (((int )sd_card->sd_type & 255) != 0 || ((int )sd_card->sd_type & 256) == 0)) && ((((int )sd_card->sd_type & 255) != 1 || ((int )sd_card->sd_type & 512) == 0) || (((int )sd_card->sd_type & 255) != 1 || ((int )sd_card->sd_type & 256) == 0))) {
      sd_send_cmd_get_rsp(chip, 13, sd_card->sd_addr, 1, (u8 *)0U, 0);
    } else {

    }
  } else {

  }
  chip->ci = 0;
  rtsx_add_cmd(chip, 1, (int )REG_SD_BYTE_CNT_L, 255, 0);
  rtsx_add_cmd(chip, 1, (int )REG_SD_BYTE_CNT_H, 255, 2);
  rtsx_add_cmd(chip, 1, (int )REG_SD_BLOCK_CNT_L, 255, (int )((unsigned char )sector_cnt));
  rtsx_add_cmd(chip, 1, (int )REG_SD_BLOCK_CNT_H, 255, (int )((unsigned char )((int )sector_cnt >> 8)));
  rtsx_add_cmd(chip, 1, 64859, 1, 0);
  if (((int )sd_card->sd_type & 255) == 1 && ((int )sd_card->sd_type & 2048) != 0) {
    rtsx_add_cmd(chip, 1, (int )REG_SD_CFG1, 3, 2);
  } else
  if ((((int )sd_card->sd_type & 255) == 1 && ((int )sd_card->sd_type & 1024) != 0) || ((int )sd_card->sd_type & 255) == 0) {
    rtsx_add_cmd(chip, 1, (int )REG_SD_CFG1, 3, 1);
  } else {
    rtsx_add_cmd(chip, 1, (int )REG_SD_CFG1, 3, 0);
  }
  if (sd_card->seq_mode != 0) {
    cfg2 = 132U;
    rtsx_add_cmd(chip, 1, (int )REG_SD_CFG2, 255, (int )cfg2);
    trans_dma_enable(srb->sc_data_direction, chip, (u32 )((int )sector_cnt * 512),
                     32);
    if ((unsigned int )srb->sc_data_direction == 2U) {
      rtsx_add_cmd(chip, 1, (int )REG_SD_TRANSFER, 255, 133);
    } else {
      rtsx_add_cmd(chip, 1, (int )REG_SD_TRANSFER, 255, 129);
    }
    rtsx_add_cmd(chip, 2, (int )REG_SD_TRANSFER, 64, 64);
    rtsx_send_cmd_no_wait(chip);
  } else {
    if ((unsigned int )srb->sc_data_direction == 2U) {
      descriptor___1.modname = "rts5208";
      descriptor___1.function = "sd_rw";
      descriptor___1.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c";
      descriptor___1.format = "SD/MMC CMD %d\n";
      descriptor___1.lineno = 3874U;
      descriptor___1.flags = 0U;
      tmp___4 = ldv__builtin_expect((long )descriptor___1.flags & 1L, 0L);
      if (tmp___4 != 0L) {
        tmp___3 = rtsx_dev((struct rtsx_chip  const  *)chip);
        __dynamic_dev_dbg(& descriptor___1, (struct device  const  *)tmp___3, "SD/MMC CMD %d\n",
                          18);
      } else {

      }
      rtsx_add_cmd(chip, 1, (int )REG_SD_CMD0, 255, 82);
      rtsx_add_cmd(chip, 1, (int )REG_SD_CMD1, 255, (int )((unsigned char )(data_addr >> 24)));
      rtsx_add_cmd(chip, 1, (int )REG_SD_CMD2, 255, (int )((unsigned char )(data_addr >> 16)));
      rtsx_add_cmd(chip, 1, (int )REG_SD_CMD3, 255, (int )((unsigned char )(data_addr >> 8)));
      rtsx_add_cmd(chip, 1, (int )REG_SD_CMD4, 255, (int )((unsigned char )data_addr));
      cfg2 = 1U;
      rtsx_add_cmd(chip, 1, (int )REG_SD_CFG2, 255, (int )cfg2);
      trans_dma_enable(srb->sc_data_direction, chip, (u32 )((int )sector_cnt * 512),
                       32);
      rtsx_add_cmd(chip, 1, (int )REG_SD_TRANSFER, 255, 142);
      rtsx_add_cmd(chip, 2, (int )REG_SD_TRANSFER, 64, 64);
      rtsx_send_cmd_no_wait(chip);
    } else {
      retval = rtsx_send_cmd(chip, 4, 50);
      if (retval < 0) {
        rtsx_clear_sd_error(chip);
        chip->rw_need_retry = 1;
        sd_set_err_code(chip, 64);
        _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                    "sd_rw", 3908);
        goto RW_FAIL;
      } else {

      }
      retval = wait_data_buf_ready(chip);
      if (retval != 0) {
        chip->rw_need_retry = 1;
        sd_set_err_code(chip, 64);
        _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                    "sd_rw", 3916);
        goto RW_FAIL;
      } else {

      }
      retval = sd_send_cmd_get_rsp(chip, 25, data_addr, 1, (u8 *)0U, 0);
      if (retval != 0) {
        chip->rw_need_retry = 1;
        _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                    "sd_rw", 3924);
        goto RW_FAIL;
      } else {

      }
      chip->ci = 0;
      cfg2 = 132U;
      rtsx_add_cmd(chip, 1, (int )REG_SD_CFG2, 255, (int )cfg2);
      trans_dma_enable(srb->sc_data_direction, chip, (u32 )((int )sector_cnt * 512),
                       32);
      rtsx_add_cmd(chip, 1, (int )REG_SD_TRANSFER, 255, 129);
      rtsx_add_cmd(chip, 2, (int )REG_SD_TRANSFER, 64, 64);
      rtsx_send_cmd_no_wait(chip);
    }
    sd_card->seq_mode = 1;
  }
  tmp___5 = scsi_sg_count(srb);
  tmp___6 = scsi_bufflen(srb);
  tmp___7 = scsi_sglist(srb);
  retval = rtsx_transfer_data(chip, 4, (void *)tmp___7, (size_t )tmp___6, (int )tmp___5,
                              srb->sc_data_direction, chip->sd_timeout);
  if (retval < 0) {
    stat = 0U;
    sd_card->seq_mode = 0;
    if (retval == -110) {
      err = 2;
    } else {
      err = 1;
    }
    rtsx_read_register(chip, (int )REG_SD_STAT1, & stat);
    rtsx_clear_sd_error(chip);
    tmp___10 = detect_card_cd(chip, 4);
    if (tmp___10 != 0) {
      chip->rw_need_retry = 0;
      descriptor___2.modname = "rts5208";
      descriptor___2.function = "sd_rw";
      descriptor___2.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c";
      descriptor___2.format = "No card exist, exit sd_rw\n";
      descriptor___2.lineno = 3968U;
      descriptor___2.flags = 0U;
      tmp___9 = ldv__builtin_expect((long )descriptor___2.flags & 1L, 0L);
      if (tmp___9 != 0L) {
        tmp___8 = rtsx_dev((struct rtsx_chip  const  *)chip);
        __dynamic_dev_dbg(& descriptor___2, (struct device  const  *)tmp___8, "No card exist, exit sd_rw\n");
      } else {

      }
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                  "sd_rw", 3969);
      return (1);
    } else {

    }
    chip->rw_need_retry = 1;
    retval = sd_send_cmd_get_rsp(chip, 12, 0U, 9, (u8 *)0U, 0);
    if (retval != 0) {
      sd_set_err_code(chip, 8);
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                  "sd_rw", 3979);
      goto RW_FAIL;
    } else {

    }
    if (((int )stat & 224) != 0) {
      descriptor___3.modname = "rts5208";
      descriptor___3.function = "sd_rw";
      descriptor___3.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c";
      descriptor___3.format = "SD CRC error, tune clock!\n";
      descriptor___3.lineno = 3984U;
      descriptor___3.flags = 0U;
      tmp___12 = ldv__builtin_expect((long )descriptor___3.flags & 1L, 0L);
      if (tmp___12 != 0L) {
        tmp___11 = rtsx_dev((struct rtsx_chip  const  *)chip);
        __dynamic_dev_dbg(& descriptor___3, (struct device  const  *)tmp___11, "SD CRC error, tune clock!\n");
      } else {

      }
      sd_set_err_code(chip, 128);
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                  "sd_rw", 3986);
      goto RW_FAIL;
    } else {

    }
    if (err == 2) {
      sd_set_err_code(chip, 64);
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                  "sd_rw", 3992);
      goto RW_FAIL;
    } else {

    }
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "sd_rw", 3996);
    return (err);
  } else {

  }
  sd_card->pre_sec_addr = start_sector;
  sd_card->pre_sec_cnt = sector_cnt;
  sd_card->pre_dir = srb->sc_data_direction;
  return (0);
  RW_FAIL: 
  sd_card->seq_mode = 0;
  tmp___15 = detect_card_cd(chip, 4);
  if (tmp___15 != 0) {
    chip->rw_need_retry = 0;
    descriptor___4.modname = "rts5208";
    descriptor___4.function = "sd_rw";
    descriptor___4.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c";
    descriptor___4.format = "No card exist, exit sd_rw\n";
    descriptor___4.lineno = 4011U;
    descriptor___4.flags = 0U;
    tmp___14 = ldv__builtin_expect((long )descriptor___4.flags & 1L, 0L);
    if (tmp___14 != 0L) {
      tmp___13 = rtsx_dev((struct rtsx_chip  const  *)chip);
      __dynamic_dev_dbg(& descriptor___4, (struct device  const  *)tmp___13, "No card exist, exit sd_rw\n");
    } else {

    }
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "sd_rw", 4012);
    return (1);
  } else {

  }
  tmp___17 = sd_check_err_code(chip, 128);
  if (tmp___17 != 0) {
    if ((((int )sd_card->sd_type & 255) == 1 && ((int )sd_card->sd_type & 1024) != 0) || (((int )sd_card->sd_type & 255) == 1 && ((int )sd_card->sd_type & 2048) != 0)) {
      sd_card->mmc_dont_switch_bus = 1;
      reset_mmc_only(chip);
      sd_card->mmc_dont_switch_bus = 0;
    } else {
      sd_card->need_retune = 1;
      sd_auto_tune_clock(chip);
    }
  } else {
    tmp___16 = sd_check_err_code(chip, 72);
    if (tmp___16 != 0) {
      retval = reset_sd_card(chip);
      if (retval != 0) {
        chip->card_ready = (unsigned int )chip->card_ready & 251U;
        chip->card_fail = (u8 )((unsigned int )chip->card_fail | 4U);
        chip->capacity[(int )chip->card2lun[4]] = 0U;
      } else {

      }
    } else {

    }
  }
  _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
              "sd_rw", 4034);
  return (1);
}
}
int soft_reset_sd_card(struct rtsx_chip *chip ) 
{ 
  int tmp ;

  {
  tmp = reset_sd(chip);
  return (tmp);
}
}
int ext_sd_send_cmd_get_rsp(struct rtsx_chip *chip , u8 cmd_idx , u32 arg , u8 rsp_type ,
                            u8 *rsp , int rsp_len , bool special_check ) 
{ 
  int retval ;
  int timeout ;
  u16 reg_addr ;
  u8 *ptr ;
  int stat_idx ;
  int rty_cnt ;
  struct _ddebug descriptor ;
  struct device *tmp ;
  long tmp___0 ;
  u8 *tmp___1 ;
  struct task_struct *tmp___2 ;
  long volatile   __ret ;
  struct task_struct *tmp___3 ;
  struct task_struct *tmp___4 ;
  struct task_struct *tmp___5 ;
  struct task_struct *tmp___6 ;

  {
  timeout = 100;
  stat_idx = 0;
  rty_cnt = 0;
  descriptor.modname = "rts5208";
  descriptor.function = "ext_sd_send_cmd_get_rsp";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c";
  descriptor.format = "EXT SD/MMC CMD %d\n";
  descriptor.lineno = 4054U;
  descriptor.flags = 0U;
  tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp___0 != 0L) {
    tmp = rtsx_dev((struct rtsx_chip  const  *)chip);
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)tmp, "EXT SD/MMC CMD %d\n",
                      (int )cmd_idx);
  } else {

  }
  if ((unsigned int )rsp_type == 9U) {
    timeout = 3000;
  } else {

  }
  RTY_SEND_CMD: 
  chip->ci = 0;
  rtsx_add_cmd(chip, 1, (int )REG_SD_CMD0, 255, (int )((unsigned int )cmd_idx | 64U));
  rtsx_add_cmd(chip, 1, (int )REG_SD_CMD1, 255, (int )((unsigned char )(arg >> 24)));
  rtsx_add_cmd(chip, 1, (int )REG_SD_CMD2, 255, (int )((unsigned char )(arg >> 16)));
  rtsx_add_cmd(chip, 1, (int )REG_SD_CMD3, 255, (int )((unsigned char )(arg >> 8)));
  rtsx_add_cmd(chip, 1, (int )REG_SD_CMD4, 255, (int )((unsigned char )arg));
  rtsx_add_cmd(chip, 1, (int )REG_SD_CFG2, 255, (int )rsp_type);
  rtsx_add_cmd(chip, 1, 64859, 1, 1);
  rtsx_add_cmd(chip, 1, (int )REG_SD_TRANSFER, 255, 136);
  rtsx_add_cmd(chip, 2, (int )REG_SD_TRANSFER, 64, 64);
  if ((unsigned int )rsp_type == 2U) {
    reg_addr = 64000U;
    goto ldv_39116;
    ldv_39115: 
    rtsx_add_cmd(chip, 0, (int )reg_addr, 0, 0);
    reg_addr = (u16 )((int )reg_addr + 1);
    ldv_39116: ;
    if ((unsigned int )reg_addr <= 64015U) {
      goto ldv_39115;
    } else {

    }
    stat_idx = 17;
  } else
  if ((unsigned int )rsp_type != 4U) {
    reg_addr = REG_SD_CMD0;
    goto ldv_39119;
    ldv_39118: 
    rtsx_add_cmd(chip, 0, (int )reg_addr, 0, 0);
    reg_addr = (u16 )((int )reg_addr + 1);
    ldv_39119: ;
    if ((int )reg_addr <= (int )REG_SD_CMD4) {
      goto ldv_39118;
    } else {

    }
    stat_idx = 6;
  } else {

  }
  rtsx_add_cmd(chip, 0, (int )REG_SD_CMD5, 0, 0);
  rtsx_add_cmd(chip, 0, (int )REG_SD_STAT1, 0, 0);
  retval = rtsx_send_cmd(chip, 4, timeout);
  if (retval < 0) {
    if (retval == -110) {
      rtsx_clear_sd_error(chip);
      if (((int )rsp_type & 8) != 0) {
        retval = sd_check_data0_status(chip);
        if (retval != 0) {
          _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                      "ext_sd_send_cmd_get_rsp", 4102);
          return (retval);
        } else {

        }
      } else {
        sd_set_err_code(chip, 64);
      }
    } else {

    }
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "ext_sd_send_cmd_get_rsp", 4109);
    return (1);
  } else {

  }
  if ((unsigned int )rsp_type == 4U) {
    return (0);
  } else {

  }
  tmp___1 = rtsx_get_cmd_data(chip);
  ptr = tmp___1 + 1UL;
  if (((int )*ptr & 192) != 0) {
    sd_set_err_code(chip, 8);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "ext_sd_send_cmd_get_rsp", 4120);
    return (1);
  } else {

  }
  if (((int )rsp_type & 4) == 0) {
    if ((int )((signed char )*(ptr + (unsigned long )stat_idx)) < 0) {
      if ((unsigned int )cmd_idx == 25U) {
        sd_set_err_code(chip, 128);
        _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                    "ext_sd_send_cmd_get_rsp", 4128);
        return (1);
      } else {

      }
      if (rty_cnt <= 2) {
        tmp___2 = get_current();
        tmp___2->task_state_change = 0UL;
        __ret = 1L;
        switch (8UL) {
        case 1UL: 
        tmp___3 = get_current();
        __asm__  volatile   ("xchgb %b0, %1\n": "+q" (__ret), "+m" (tmp___3->state): : "memory",
                             "cc");
        goto ldv_39123;
        case 2UL: 
        tmp___4 = get_current();
        __asm__  volatile   ("xchgw %w0, %1\n": "+r" (__ret), "+m" (tmp___4->state): : "memory",
                             "cc");
        goto ldv_39123;
        case 4UL: 
        tmp___5 = get_current();
        __asm__  volatile   ("xchgl %0, %1\n": "+r" (__ret), "+m" (tmp___5->state): : "memory",
                             "cc");
        goto ldv_39123;
        case 8UL: 
        tmp___6 = get_current();
        __asm__  volatile   ("xchgq %q0, %1\n": "+r" (__ret), "+m" (tmp___6->state): : "memory",
                             "cc");
        goto ldv_39123;
        default: 
        __xchg_wrong_size();
        }
        ldv_39123: 
        schedule_timeout(5L);
        rty_cnt = rty_cnt + 1;
        goto RTY_SEND_CMD;
      } else {
        sd_set_err_code(chip, 128);
        _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                    "ext_sd_send_cmd_get_rsp", 4137);
        return (1);
      }
    } else {

    }
  } else {

  }
  if ((((unsigned int )cmd_idx == 7U || (unsigned int )cmd_idx == 55U) || (unsigned int )cmd_idx == 13U) || (unsigned int )cmd_idx == 12U) {
    if ((unsigned int )cmd_idx != 12U && ! special_check) {
      if ((int )((signed char )*(ptr + 1UL)) < 0) {
        _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                    "ext_sd_send_cmd_get_rsp", 4147);
        return (1);
      } else {

      }
    } else {

    }
    if (((int )*(ptr + 1UL) & 125) != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                  "ext_sd_send_cmd_get_rsp", 4157);
      return (1);
    } else {

    }
    if (((int )*(ptr + 2UL) & 248) != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                  "ext_sd_send_cmd_get_rsp", 4161);
      return (1);
    } else {

    }
    if ((unsigned int )cmd_idx == 7U) {
      if ((unsigned int )rsp_type == 2U) {
        if (((int )*(ptr + 3UL) & 30) != 4) {
          _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                      "ext_sd_send_cmd_get_rsp", 4168);
          return (1);
        } else {

        }
      } else
      if ((unsigned int )rsp_type == 4U) {
        _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                    "ext_sd_send_cmd_get_rsp", 4174);
        return (1);
      } else {

      }
    } else {

    }
  } else {

  }
  if ((unsigned long )rsp != (unsigned long )((u8 *)0U) && rsp_len != 0) {
    memcpy((void *)rsp, (void const   *)ptr, (size_t )rsp_len);
  } else {

  }
  return (0);
}
}
int ext_sd_get_rsp(struct rtsx_chip *chip , int len , u8 *rsp , u8 rsp_type ) 
{ 
  int retval ;
  int rsp_len ;
    klee_make_symbolic(&rsp_len, sizeof(int), "rsp_len");
  u16 reg_addr ;
  int min_len ;
    klee_make_symbolic(&min_len, sizeof(int), "min_len");
  u8 *tmp ;
  struct _ddebug descriptor ;
  struct device *tmp___0 ;
  long tmp___1 ;
  struct _ddebug descriptor___0 ;
  struct device *tmp___2 ;
  long tmp___3 ;

  {
  if ((unsigned int )rsp_type == 4U) {
    return (0);
  } else {

  }
  chip->ci = 0;
  if ((unsigned int )rsp_type == 2U) {
    reg_addr = 64000U;
    goto ldv_39139;
    ldv_39138: 
    rtsx_add_cmd(chip, 0, (int )reg_addr, 255, 0);
    reg_addr = (u16 )((int )reg_addr + 1);
    ldv_39139: ;
    if ((unsigned int )reg_addr <= 64015U) {
      goto ldv_39138;
    } else {

    }
    rsp_len = 17;
  } else
  if ((unsigned int )rsp_type != 4U) {
    reg_addr = REG_SD_CMD0;
    goto ldv_39142;
    ldv_39141: 
    rtsx_add_cmd(chip, 0, (int )reg_addr, 255, 0);
    reg_addr = (u16 )((int )reg_addr + 1);
    ldv_39142: ;
    if ((int )reg_addr <= (int )REG_SD_CMD4) {
      goto ldv_39141;
    } else {

    }
    rsp_len = 6;
  } else {

  }
  rtsx_add_cmd(chip, 0, (int )REG_SD_CMD5, 255, 0);
  retval = rtsx_send_cmd(chip, 4, 100);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "ext_sd_get_rsp", 4214);
    return (1);
  } else {

  }
  if ((unsigned long )rsp != (unsigned long )((u8 *)0U)) {
    min_len = rsp_len < len ? rsp_len : len;
    tmp = rtsx_get_cmd_data(chip);
    memcpy((void *)rsp, (void const   *)tmp, (size_t )min_len);
    descriptor.modname = "rts5208";
    descriptor.function = "ext_sd_get_rsp";
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c";
    descriptor.format = "min_len = %d\n";
    descriptor.lineno = 4223U;
    descriptor.flags = 0U;
    tmp___1 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
    if (tmp___1 != 0L) {
      tmp___0 = rtsx_dev((struct rtsx_chip  const  *)chip);
      __dynamic_dev_dbg(& descriptor, (struct device  const  *)tmp___0, "min_len = %d\n",
                        min_len);
    } else {

    }
    descriptor___0.modname = "rts5208";
    descriptor___0.function = "ext_sd_get_rsp";
    descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c";
    descriptor___0.format = "Response in cmd buf: 0x%x 0x%x 0x%x 0x%x\n";
    descriptor___0.lineno = 4225U;
    descriptor___0.flags = 0U;
    tmp___3 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
    if (tmp___3 != 0L) {
      tmp___2 = rtsx_dev((struct rtsx_chip  const  *)chip);
      __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)tmp___2, "Response in cmd buf: 0x%x 0x%x 0x%x 0x%x\n",
                        (int )*rsp, (int )*(rsp + 1UL), (int )*(rsp + 2UL), (int )*(rsp + 3UL));
    } else {

    }
  } else {

  }
  return (0);
}
}
int sd_pass_thru_mode(struct scsi_cmnd *srb , struct rtsx_chip *chip ) 
{ 
  struct sd_info *sd_card ;
  unsigned int lun ;
  int len ;
  u8 buf[18U] ;
  int __min1 ;
  int __min2 ;
  unsigned int tmp ;

  {
  sd_card = & chip->sd_card;
  lun = (unsigned int )(srb->device)->lun;
  buf[0] = 0U;
  buf[1] = 0U;
  buf[2] = 0U;
  buf[3] = 14U;
  buf[4] = 0U;
  buf[5] = 0U;
  buf[6] = 0U;
  buf[7] = 0U;
  buf[8] = 83U;
  buf[9] = 68U;
  buf[10] = 32U;
  buf[11] = 67U;
  buf[12] = 97U;
  buf[13] = 114U;
  buf[14] = 100U;
  buf[15] = 0U;
  buf[16] = 0U;
  buf[17] = 0U;
  sd_card->pre_cmd_err = 0;
  if ((((int )chip->lun_mc >> (int )lun) & 1) == 0) {
    chip->lun_mc = (u8 )((int )((signed char )chip->lun_mc) | (int )((signed char )(1 << (int )lun)));
    set_sense_type(chip, lun, 1);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "sd_pass_thru_mode", 4262);
    return (1);
  } else {

  }
  if (((((((unsigned int )*(srb->cmnd + 2UL) != 83U || (unsigned int )*(srb->cmnd + 3UL) != 68U) || (unsigned int )*(srb->cmnd + 4UL) != 32U) || (unsigned int )*(srb->cmnd + 5UL) != 67U) || (unsigned int )*(srb->cmnd + 6UL) != 97U) || (unsigned int )*(srb->cmnd + 7UL) != 114U) || (unsigned int )*(srb->cmnd + 8UL) != 100U) {
    set_sense_type(chip, lun, 6);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "sd_pass_thru_mode", 4271);
    return (1);
  } else {

  }
  switch ((int )*(srb->cmnd + 1UL) & 15) {
  case 0: 
  sd_card->sd_pass_thru_en = 0;
  goto ldv_39158;
  case 1: 
  sd_card->sd_pass_thru_en = 1;
  goto ldv_39158;
  default: 
  set_sense_type(chip, lun, 6);
  _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
              "sd_pass_thru_mode", 4286);
  return (1);
  }
  ldv_39158: 
  buf[5] = ((int )sd_card->sd_type & 255) == 0 ? 1U : 2U;
  if (((int )chip->card_wp & 4) != 0) {
    buf[5] = (u8 )((unsigned int )buf[5] | 128U);
  } else {

  }
  buf[6] = (unsigned char )(sd_card->sd_addr >> 16);
  buf[7] = (unsigned char )(sd_card->sd_addr >> 24);
  buf[15] = (u8 )chip->max_lun;
  __min1 = 18;
  tmp = scsi_bufflen(srb);
  __min2 = (int )tmp;
  len = __min1 < __min2 ? __min1 : __min2;
  rtsx_stor_set_xfer_buf((unsigned char *)(& buf), (unsigned int )len, srb);
  return (0);
}
}
__inline static int get_rsp_type(struct scsi_cmnd *srb , u8 *rsp_type , int *rsp_len ) 
{ 


  {
  if ((unsigned long )rsp_type == (unsigned long )((u8 *)0U) || (unsigned long )rsp_len == (unsigned long )((int *)0)) {
    return (1);
  } else {

  }
  switch ((int )*(srb->cmnd + 10UL)) {
  case 3: 
  *rsp_type = 4U;
  *rsp_len = 0;
  goto ldv_39170;
  case 4: 
  *rsp_type = 1U;
  *rsp_len = 6;
  goto ldv_39170;
  case 5: 
  *rsp_type = 9U;
  *rsp_len = 6;
  goto ldv_39170;
  case 6: 
  *rsp_type = 2U;
  *rsp_len = 17;
  goto ldv_39170;
  case 7: 
  *rsp_type = 5U;
  *rsp_len = 6;
  goto ldv_39170;
  default: ;
  return (1);
  }
  ldv_39170: ;
  return (0);
}
}
int sd_execute_no_data(struct scsi_cmnd *srb , struct rtsx_chip *chip ) 
{ 
  struct sd_info *sd_card ;
  unsigned int lun ;
  int retval ;
  int rsp_len ;
  u8 cmd_idx ;
  u8 rsp_type ;
  bool standby ;
  bool acmd ;
  u32 arg ;

  {
  sd_card = & chip->sd_card;
  lun = (unsigned int )(srb->device)->lun;
  standby = 0;
  acmd = 0;
  if (sd_card->sd_pass_thru_en == 0) {
    set_sense_type(chip, lun, 6);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "sd_execute_no_data", 4355);
    return (1);
  } else {

  }
  retval = sd_switch_clock(chip);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "sd_execute_no_data", 4361);
    return (1);
  } else {

  }
  if (sd_card->pre_cmd_err != 0) {
    sd_card->pre_cmd_err = 0;
    set_sense_type(chip, lun, 1);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "sd_execute_no_data", 4368);
    return (1);
  } else {

  }
  cmd_idx = (unsigned int )*(srb->cmnd + 2UL) & 63U;
  if (((int )*(srb->cmnd + 1UL) & 2) != 0) {
    standby = 1;
  } else {

  }
  if ((int )*(srb->cmnd + 1UL) & 1) {
    acmd = 1;
  } else {

  }
  arg = ((((unsigned int )*(srb->cmnd + 3UL) << 24) | ((unsigned int )*(srb->cmnd + 4UL) << 16)) | ((unsigned int )*(srb->cmnd + 5UL) << 8)) | (unsigned int )*(srb->cmnd + 6UL);
  retval = get_rsp_type(srb, & rsp_type, & rsp_len);
  if (retval != 0) {
    set_sense_type(chip, lun, 6);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "sd_execute_no_data", 4385);
    return (1);
  } else {

  }
  sd_card->last_rsp_type = rsp_type;
  retval = sd_switch_clock(chip);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "sd_execute_no_data", 4392);
    return (1);
  } else {

  }
  if (((int )sd_card->sd_lock_status & 64) == 0) {
    if (((int )sd_card->sd_type & 255) == 1 && ((int )sd_card->sd_type & 2048) != 0) {
      retval = rtsx_write_register(chip, (int )REG_SD_CFG1, 3, 2);
      if (retval != 0) {
        _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                    "sd_execute_no_data", 4402);
        return (1);
      } else {

      }
    } else
    if (((int )sd_card->sd_type & 255) == 0 || (((int )sd_card->sd_type & 255) == 1 && ((int )sd_card->sd_type & 1024) != 0)) {
      retval = rtsx_write_register(chip, (int )REG_SD_CFG1, 3, 1);
      if (retval != 0) {
        _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                    "sd_execute_no_data", 4410);
        return (1);
      } else {

      }
    } else {

    }
  } else {

  }
  if ((int )standby) {
    retval = sd_select_card(chip, 0);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                  "sd_execute_no_data", 4426);
      goto SD_Execute_Cmd_Failed;
    } else {

    }
  } else {

  }
  if ((int )acmd) {
    retval = ext_sd_send_cmd_get_rsp(chip, 55, sd_card->sd_addr, 1, (u8 *)0U, 0, 0);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                  "sd_execute_no_data", 4436);
      goto SD_Execute_Cmd_Failed;
    } else {

    }
  } else {

  }
  retval = ext_sd_send_cmd_get_rsp(chip, (int )cmd_idx, arg, (int )rsp_type, (u8 *)(& sd_card->rsp),
                                   rsp_len, 0);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "sd_execute_no_data", 4444);
    goto SD_Execute_Cmd_Failed;
  } else {

  }
  if ((int )standby) {
    retval = sd_select_card(chip, 1);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                  "sd_execute_no_data", 4451);
      goto SD_Execute_Cmd_Failed;
    } else {

    }
  } else {

  }
  retval = sd_update_lock_status(chip);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "sd_execute_no_data", 4459);
    goto SD_Execute_Cmd_Failed;
  } else {

  }
  scsi_set_resid(srb, 0);
  return (0);
  SD_Execute_Cmd_Failed: 
  sd_card->pre_cmd_err = 1;
  set_sense_type(chip, lun, 0);
  release_sd_card(chip);
  do_reset_sd_card(chip);
  if (((int )chip->card_ready & 4) == 0) {
    set_sense_type(chip, lun, 2);
  } else {

  }
  _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
              "sd_execute_no_data", 4475);
  return (1);
}
}
int sd_execute_read_data(struct scsi_cmnd *srb , struct rtsx_chip *chip ) 
{ 
  struct sd_info *sd_card ;
  unsigned int lun ;
  int retval ;
  int rsp_len ;
  int i ;
  bool read_err ;
  bool cmd13_checkbit ;
  u8 cmd_idx ;
  u8 rsp_type ;
  u8 bus_width ;
  bool standby ;
  bool send_cmd12 ;
  bool acmd ;
  u32 data_len ;
  struct _ddebug descriptor ;
  struct device *tmp ;
  long tmp___0 ;
  int min_len ;
  u8 *buf ;
  u16 byte_cnt ;
  u16 blk_cnt ;
  u8 cmd[5U] ;
  void *tmp___1 ;
  u32 _min1 ;
  unsigned int _min2 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;
  unsigned int tmp___4 ;
  struct scatterlist *tmp___5 ;

  {
  sd_card = & chip->sd_card;
  lun = (unsigned int )(srb->device)->lun;
  read_err = 0;
  cmd13_checkbit = 0;
  standby = 0;
  send_cmd12 = 0;
  acmd = 0;
  if (sd_card->sd_pass_thru_en == 0) {
    set_sense_type(chip, lun, 6);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "sd_execute_read_data", 4491);
    return (1);
  } else {

  }
  if (sd_card->pre_cmd_err != 0) {
    sd_card->pre_cmd_err = 0;
    set_sense_type(chip, lun, 1);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "sd_execute_read_data", 4498);
    return (1);
  } else {

  }
  retval = sd_switch_clock(chip);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "sd_execute_read_data", 4504);
    return (1);
  } else {

  }
  cmd_idx = (unsigned int )*(srb->cmnd + 2UL) & 63U;
  if (((int )*(srb->cmnd + 1UL) & 4) != 0) {
    send_cmd12 = 1;
  } else {

  }
  if (((int )*(srb->cmnd + 1UL) & 2) != 0) {
    standby = 1;
  } else {

  }
  if ((int )*(srb->cmnd + 1UL) & 1) {
    acmd = 1;
  } else {

  }
  data_len = (((unsigned int )*(srb->cmnd + 7UL) << 16) | ((unsigned int )*(srb->cmnd + 8UL) << 8)) | (unsigned int )*(srb->cmnd + 9UL);
  retval = get_rsp_type(srb, & rsp_type, & rsp_len);
  if (retval != 0) {
    set_sense_type(chip, lun, 6);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "sd_execute_read_data", 4524);
    return (1);
  } else {

  }
  sd_card->last_rsp_type = rsp_type;
  retval = sd_switch_clock(chip);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "sd_execute_read_data", 4531);
    return (1);
  } else {

  }
  if (((int )sd_card->sd_lock_status & 64) == 0) {
    if (((int )sd_card->sd_type & 255) == 1 && ((int )sd_card->sd_type & 2048) != 0) {
      bus_width = 2U;
    } else
    if (((int )sd_card->sd_type & 255) == 0 || (((int )sd_card->sd_type & 255) == 1 && ((int )sd_card->sd_type & 1024) != 0)) {
      bus_width = 1U;
    } else {
      bus_width = 0U;
    }
  } else {
    bus_width = 1U;
  }
  descriptor.modname = "rts5208";
  descriptor.function = "sd_execute_read_data";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c";
  descriptor.format = "bus_width = %d\n";
  descriptor.lineno = 4546U;
  descriptor.flags = 0U;
  tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp___0 != 0L) {
    tmp = rtsx_dev((struct rtsx_chip  const  *)chip);
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)tmp, "bus_width = %d\n",
                      (int )bus_width);
  } else {

  }
  if (data_len <= 511U) {
    retval = ext_sd_send_cmd_get_rsp(chip, 16, data_len, 1, (u8 *)0U, 0, 0);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                  "sd_execute_read_data", 4555);
      goto SD_Execute_Read_Cmd_Failed;
    } else {

    }
  } else {

  }
  if ((int )standby) {
    retval = sd_select_card(chip, 0);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                  "sd_execute_read_data", 4563);
      goto SD_Execute_Read_Cmd_Failed;
    } else {

    }
  } else {

  }
  if ((int )acmd) {
    retval = ext_sd_send_cmd_get_rsp(chip, 55, sd_card->sd_addr, 1, (u8 *)0U, 0, 0);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                  "sd_execute_read_data", 4573);
      goto SD_Execute_Read_Cmd_Failed;
    } else {

    }
  } else {

  }
  if (data_len <= 512U) {
    byte_cnt = (u16 )((int )((short )(((int )*(srb->cmnd + 8UL) & 3) << 8)) | (int )((short )*(srb->cmnd + 9UL)));
    blk_cnt = 1U;
    cmd[0] = (u8 )((unsigned int )cmd_idx | 64U);
    cmd[1] = *(srb->cmnd + 3UL);
    cmd[2] = *(srb->cmnd + 4UL);
    cmd[3] = *(srb->cmnd + 5UL);
    cmd[4] = *(srb->cmnd + 6UL);
    tmp___1 = kmalloc((size_t )data_len, 208U);
    buf = (u8 *)tmp___1;
    if ((unsigned long )buf == (unsigned long )((u8 *)0U)) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                  "sd_execute_read_data", 4595);
      return (3);
    } else {

    }
    retval = sd_read_data(chip, 12, (u8 *)(& cmd), 5, (int )byte_cnt, (int )blk_cnt,
                          (int )bus_width, buf, (int )data_len, 2000);
    if (retval != 0) {
      read_err = 1;
      kfree((void const   *)buf);
      rtsx_clear_sd_error(chip);
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                  "sd_execute_read_data", 4605);
      goto SD_Execute_Read_Cmd_Failed;
    } else {

    }
    _min1 = data_len;
    tmp___2 = scsi_bufflen(srb);
    _min2 = tmp___2;
    min_len = (int )(_min1 < _min2 ? _min1 : _min2);
    rtsx_stor_set_xfer_buf(buf, (unsigned int )min_len, srb);
    kfree((void const   *)buf);
  } else
  if ((data_len & 511U) == 0U) {
    chip->ci = 0;
    trans_dma_enable(2, chip, data_len, 32);
    rtsx_add_cmd(chip, 1, (int )REG_SD_BYTE_CNT_H, 255, 2);
    rtsx_add_cmd(chip, 1, (int )REG_SD_BYTE_CNT_L, 255, 0);
    rtsx_add_cmd(chip, 1, (int )REG_SD_BLOCK_CNT_H, 255, (int )*(srb->cmnd + 7UL) >> 1);
    rtsx_add_cmd(chip, 1, (int )REG_SD_BLOCK_CNT_L, 255, (int )((unsigned char )((data_len & 130560U) >> 9)));
    rtsx_add_cmd(chip, 1, (int )REG_SD_CMD0, 255, (int )((unsigned int )cmd_idx | 64U));
    rtsx_add_cmd(chip, 1, (int )REG_SD_CMD1, 255, (int )*(srb->cmnd + 3UL));
    rtsx_add_cmd(chip, 1, (int )REG_SD_CMD2, 255, (int )*(srb->cmnd + 4UL));
    rtsx_add_cmd(chip, 1, (int )REG_SD_CMD3, 255, (int )*(srb->cmnd + 5UL));
    rtsx_add_cmd(chip, 1, (int )REG_SD_CMD4, 255, (int )*(srb->cmnd + 6UL));
    rtsx_add_cmd(chip, 1, (int )REG_SD_CFG1, 3, (int )bus_width);
    rtsx_add_cmd(chip, 1, (int )REG_SD_CFG2, 255, (int )rsp_type);
    rtsx_add_cmd(chip, 1, (int )REG_SD_TRANSFER, 255, 142);
    rtsx_add_cmd(chip, 2, (int )REG_SD_TRANSFER, 64, 64);
    rtsx_send_cmd_no_wait(chip);
    tmp___3 = scsi_sg_count(srb);
    tmp___4 = scsi_bufflen(srb);
    tmp___5 = scsi_sglist(srb);
    retval = rtsx_transfer_data(chip, 4, (void *)tmp___5, (size_t )tmp___4, (int )tmp___3,
                                2, 10000);
    if (retval < 0) {
      read_err = 1;
      rtsx_clear_sd_error(chip);
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                  "sd_execute_read_data", 4654);
      goto SD_Execute_Read_Cmd_Failed;
    } else {

    }
  } else {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "sd_execute_read_data", 4659);
    goto SD_Execute_Read_Cmd_Failed;
  }
  retval = ext_sd_get_rsp(chip, rsp_len, (u8 *)(& sd_card->rsp), (int )rsp_type);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "sd_execute_read_data", 4665);
    goto SD_Execute_Read_Cmd_Failed;
  } else {

  }
  if ((int )standby) {
    retval = sd_select_card(chip, 1);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                  "sd_execute_read_data", 4672);
      goto SD_Execute_Read_Cmd_Failed;
    } else {

    }
  } else {

  }
  if ((int )send_cmd12) {
    retval = ext_sd_send_cmd_get_rsp(chip, 12, 0U, 9, (u8 *)0U, 0, 0);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                  "sd_execute_read_data", 4681);
      goto SD_Execute_Read_Cmd_Failed;
    } else {

    }
  } else {

  }
  if (data_len <= 511U) {
    retval = ext_sd_send_cmd_get_rsp(chip, 16, 512U, 1, (u8 *)0U, 0, 0);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                  "sd_execute_read_data", 4690);
      goto SD_Execute_Read_Cmd_Failed;
    } else {

    }
    retval = rtsx_write_register(chip, 64944, 255, 2);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                  "sd_execute_read_data", 4696);
      goto SD_Execute_Read_Cmd_Failed;
    } else {

    }
    retval = rtsx_write_register(chip, 64943, 255, 0);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                  "sd_execute_read_data", 4702);
      goto SD_Execute_Read_Cmd_Failed;
    } else {

    }
  } else {

  }
  if (((int )*(srb->cmnd + 1UL) & 2) != 0 || ((int )*(srb->cmnd + 1UL) & 4) != 0) {
    cmd13_checkbit = 1;
  } else {

  }
  i = 0;
  goto ldv_39222;
  ldv_39221: 
  retval = ext_sd_send_cmd_get_rsp(chip, 13, sd_card->sd_addr, 1, (u8 *)0U, 0, (int )cmd13_checkbit);
  if (retval == 0) {
    goto ldv_39220;
  } else {

  }
  i = i + 1;
  ldv_39222: ;
  if (i <= 2) {
    goto ldv_39221;
  } else {

  }
  ldv_39220: ;
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "sd_execute_read_data", 4719);
    goto SD_Execute_Read_Cmd_Failed;
  } else {

  }
  scsi_set_resid(srb, 0);
  return (0);
  SD_Execute_Read_Cmd_Failed: 
  sd_card->pre_cmd_err = 1;
  set_sense_type(chip, lun, 0);
  if ((int )read_err) {
    set_sense_type(chip, lun, 7);
  } else {

  }
  release_sd_card(chip);
  do_reset_sd_card(chip);
  if (((int )chip->card_ready & 4) == 0) {
    set_sense_type(chip, lun, 2);
  } else {

  }
  _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
              "sd_execute_read_data", 4737);
  return (1);
}
}
int sd_execute_write_data(struct scsi_cmnd *srb , struct rtsx_chip *chip ) 
{ 
  struct sd_info *sd_card ;
  unsigned int lun ;
  int retval ;
  int rsp_len ;
  int i ;
  bool write_err ;
  bool cmd13_checkbit ;
  u8 cmd_idx ;
  u8 rsp_type ;
  bool standby ;
  bool send_cmd12 ;
  bool acmd ;
  u32 data_len ;
  u32 arg ;
  int lock_cmd_fail ;
    klee_make_symbolic(&lock_cmd_fail, sizeof(int), "lock_cmd_fail");
  u8 sd_lock_state ;
  u8 lock_cmd_type ;
  u16 i___0 ;
  u8 *buf ;
  void *tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  struct scatterlist *tmp___2 ;
  struct _ddebug descriptor ;
  struct device *tmp___3 ;
  long tmp___4 ;
  struct _ddebug descriptor___0 ;
  struct device *tmp___5 ;
  long tmp___6 ;
  struct _ddebug descriptor___1 ;
  struct device *tmp___7 ;
  long tmp___8 ;

  {
  sd_card = & chip->sd_card;
  lun = (unsigned int )(srb->device)->lun;
  write_err = 0;
  cmd13_checkbit = 0;
  standby = 0;
  send_cmd12 = 0;
  acmd = 0;
  lock_cmd_fail = 0;
  sd_lock_state = 0U;
  lock_cmd_type = 0U;
  if (sd_card->sd_pass_thru_en == 0) {
    set_sense_type(chip, lun, 6);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "sd_execute_write_data", 4758);
    return (1);
  } else {

  }
  if (sd_card->pre_cmd_err != 0) {
    sd_card->pre_cmd_err = 0;
    set_sense_type(chip, lun, 1);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "sd_execute_write_data", 4765);
    return (1);
  } else {

  }
  retval = sd_switch_clock(chip);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "sd_execute_write_data", 4771);
    return (1);
  } else {

  }
  cmd_idx = (unsigned int )*(srb->cmnd + 2UL) & 63U;
  if (((int )*(srb->cmnd + 1UL) & 4) != 0) {
    send_cmd12 = 1;
  } else {

  }
  if (((int )*(srb->cmnd + 1UL) & 2) != 0) {
    standby = 1;
  } else {

  }
  if ((int )*(srb->cmnd + 1UL) & 1) {
    acmd = 1;
  } else {

  }
  data_len = (((unsigned int )*(srb->cmnd + 7UL) << 16) | ((unsigned int )*(srb->cmnd + 8UL) << 8)) | (unsigned int )*(srb->cmnd + 9UL);
  arg = ((((unsigned int )*(srb->cmnd + 3UL) << 24) | ((unsigned int )*(srb->cmnd + 4UL) << 16)) | ((unsigned int )*(srb->cmnd + 5UL) << 8)) | (unsigned int )*(srb->cmnd + 6UL);
  if ((unsigned int )cmd_idx == 42U) {
    sd_lock_state = sd_card->sd_lock_status;
    sd_lock_state = (unsigned int )sd_lock_state & 128U;
  } else {

  }
  retval = get_rsp_type(srb, & rsp_type, & rsp_len);
  if (retval != 0) {
    set_sense_type(chip, lun, 6);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "sd_execute_write_data", 4800);
    return (1);
  } else {

  }
  sd_card->last_rsp_type = rsp_type;
  retval = sd_switch_clock(chip);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "sd_execute_write_data", 4807);
    return (1);
  } else {

  }
  if (((int )sd_card->sd_lock_status & 64) == 0) {
    if (((int )sd_card->sd_type & 255) == 1 && ((int )sd_card->sd_type & 2048) != 0) {
      retval = rtsx_write_register(chip, (int )REG_SD_CFG1, 3, 2);
      if (retval != 0) {
        _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                    "sd_execute_write_data", 4817);
        return (1);
      } else {

      }
    } else
    if (((int )sd_card->sd_type & 255) == 0 || (((int )sd_card->sd_type & 255) == 1 && ((int )sd_card->sd_type & 1024) != 0)) {
      retval = rtsx_write_register(chip, (int )REG_SD_CFG1, 3, 1);
      if (retval != 0) {
        _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                    "sd_execute_write_data", 4825);
        return (1);
      } else {

      }
    } else {

    }
  } else {

  }
  if (data_len <= 511U) {
    retval = ext_sd_send_cmd_get_rsp(chip, 16, data_len, 1, (u8 *)0U, 0, 0);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                  "sd_execute_write_data", 4842);
      goto SD_Execute_Write_Cmd_Failed;
    } else {

    }
  } else {

  }
  if ((int )standby) {
    retval = sd_select_card(chip, 0);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                  "sd_execute_write_data", 4850);
      goto SD_Execute_Write_Cmd_Failed;
    } else {

    }
  } else {

  }
  if ((int )acmd) {
    retval = ext_sd_send_cmd_get_rsp(chip, 55, sd_card->sd_addr, 1, (u8 *)0U, 0, 0);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                  "sd_execute_write_data", 4860);
      goto SD_Execute_Write_Cmd_Failed;
    } else {

    }
  } else {

  }
  retval = ext_sd_send_cmd_get_rsp(chip, (int )cmd_idx, arg, (int )rsp_type, (u8 *)(& sd_card->rsp),
                                   rsp_len, 0);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "sd_execute_write_data", 4868);
    goto SD_Execute_Write_Cmd_Failed;
  } else {

  }
  if (data_len <= 512U) {
    tmp = kmalloc((size_t )data_len, 208U);
    buf = (u8 *)tmp;
    if ((unsigned long )buf == (unsigned long )((u8 *)0U)) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                  "sd_execute_write_data", 4878);
      return (3);
    } else {

    }
    rtsx_stor_get_xfer_buf(buf, data_len, srb);
    if ((unsigned int )cmd_idx == 42U) {
      lock_cmd_type = (unsigned int )*buf & 15U;
    } else {

    }
    if (data_len > 256U) {
      chip->ci = 0;
      i___0 = 0U;
      goto ldv_39249;
      ldv_39248: 
      rtsx_add_cmd(chip, 1, (int )((unsigned int )i___0 + 64000U), 255, (int )*(buf + (unsigned long )i___0));
      i___0 = (u16 )((int )i___0 + 1);
      ldv_39249: ;
      if ((unsigned int )i___0 <= 255U) {
        goto ldv_39248;
      } else {

      }
      retval = rtsx_send_cmd(chip, 0, 250);
      if (retval != 0) {
        kfree((void const   *)buf);
        _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                    "sd_execute_write_data", 4898);
        goto SD_Execute_Write_Cmd_Failed;
      } else {

      }
      chip->ci = 0;
      i___0 = 256U;
      goto ldv_39252;
      ldv_39251: 
      rtsx_add_cmd(chip, 1, (int )((unsigned int )i___0 + 64000U), 255, (int )*(buf + (unsigned long )i___0));
      i___0 = (u16 )((int )i___0 + 1);
      ldv_39252: ;
      if ((u32 )i___0 < data_len) {
        goto ldv_39251;
      } else {

      }
      retval = rtsx_send_cmd(chip, 0, 250);
      if (retval != 0) {
        kfree((void const   *)buf);
        _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                    "sd_execute_write_data", 4910);
        goto SD_Execute_Write_Cmd_Failed;
      } else {

      }
    } else {
      chip->ci = 0;
      i___0 = 0U;
      goto ldv_39255;
      ldv_39254: 
      rtsx_add_cmd(chip, 1, (int )((unsigned int )i___0 + 64000U), 255, (int )*(buf + (unsigned long )i___0));
      i___0 = (u16 )((int )i___0 + 1);
      ldv_39255: ;
      if ((u32 )i___0 < data_len) {
        goto ldv_39254;
      } else {

      }
      retval = rtsx_send_cmd(chip, 0, 250);
      if (retval != 0) {
        kfree((void const   *)buf);
        _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                    "sd_execute_write_data", 4922);
        goto SD_Execute_Write_Cmd_Failed;
      } else {

      }
    }
    kfree((void const   *)buf);
    chip->ci = 0;
    rtsx_add_cmd(chip, 1, (int )REG_SD_BYTE_CNT_H, 255, (int )*(srb->cmnd + 8UL) & 3);
    rtsx_add_cmd(chip, 1, (int )REG_SD_BYTE_CNT_L, 255, (int )*(srb->cmnd + 9UL));
    rtsx_add_cmd(chip, 1, (int )REG_SD_BLOCK_CNT_H, 255, 0);
    rtsx_add_cmd(chip, 1, (int )REG_SD_BLOCK_CNT_L, 255, 1);
    rtsx_add_cmd(chip, 1, 64859, 1, 1);
    rtsx_add_cmd(chip, 1, (int )REG_SD_TRANSFER, 255, 129);
    rtsx_add_cmd(chip, 2, (int )REG_SD_TRANSFER, 64, 64);
    retval = rtsx_send_cmd(chip, 4, 250);
  } else
  if ((data_len & 511U) == 0U) {
    chip->ci = 0;
    trans_dma_enable(1, chip, data_len, 32);
    rtsx_add_cmd(chip, 1, (int )REG_SD_BYTE_CNT_H, 255, 2);
    rtsx_add_cmd(chip, 1, (int )REG_SD_BYTE_CNT_L, 255, 0);
    rtsx_add_cmd(chip, 1, (int )REG_SD_BLOCK_CNT_H, 255, (int )*(srb->cmnd + 7UL) >> 1);
    rtsx_add_cmd(chip, 1, (int )REG_SD_BLOCK_CNT_L, 255, (int )((unsigned char )((data_len & 130560U) >> 9)));
    rtsx_add_cmd(chip, 1, (int )REG_SD_TRANSFER, 255, 129);
    rtsx_add_cmd(chip, 2, (int )REG_SD_TRANSFER, 64, 64);
    rtsx_send_cmd_no_wait(chip);
    tmp___0 = scsi_sg_count(srb);
    tmp___1 = scsi_bufflen(srb);
    tmp___2 = scsi_sglist(srb);
    retval = rtsx_transfer_data(chip, 4, (void *)tmp___2, (size_t )tmp___1, (int )tmp___0,
                                1, 10000);
  } else {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "sd_execute_write_data", 4974);
    goto SD_Execute_Write_Cmd_Failed;
  }
  if (retval < 0) {
    write_err = 1;
    rtsx_clear_sd_error(chip);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "sd_execute_write_data", 4981);
    goto SD_Execute_Write_Cmd_Failed;
  } else {

  }
  if ((unsigned int )cmd_idx == 42U) {
    if ((unsigned int )lock_cmd_type == 8U) {
      sd_card->sd_erase_status = 1U;
      scsi_set_resid(srb, 0);
      return (0);
    } else {

    }
    chip->ci = 0;
    rtsx_add_cmd(chip, 2, 64816, 2, 2);
    rtsx_send_cmd(chip, 4, 250);
    retval = sd_update_lock_status(chip);
    if (retval != 0) {
      descriptor.modname = "rts5208";
      descriptor.function = "sd_execute_write_data";
      descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c";
      descriptor.format = "Lock command fail!\n";
      descriptor.lineno = 5000U;
      descriptor.flags = 0U;
      tmp___4 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
      if (tmp___4 != 0L) {
        tmp___3 = rtsx_dev((struct rtsx_chip  const  *)chip);
        __dynamic_dev_dbg(& descriptor, (struct device  const  *)tmp___3, "Lock command fail!\n");
      } else {

      }
      lock_cmd_fail = 1;
    } else {

    }
  } else {

  }
  if ((int )standby) {
    retval = sd_select_card(chip, 1);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                  "sd_execute_write_data", 5009);
      goto SD_Execute_Write_Cmd_Failed;
    } else {

    }
  } else {

  }
  if ((int )send_cmd12) {
    retval = ext_sd_send_cmd_get_rsp(chip, 12, 0U, 9, (u8 *)0U, 0, 0);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                  "sd_execute_write_data", 5018);
      goto SD_Execute_Write_Cmd_Failed;
    } else {

    }
  } else {

  }
  if (data_len <= 511U) {
    retval = ext_sd_send_cmd_get_rsp(chip, 16, 512U, 1, (u8 *)0U, 0, 0);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                  "sd_execute_write_data", 5027);
      goto SD_Execute_Write_Cmd_Failed;
    } else {

    }
    retval = rtsx_write_register(chip, 64944, 255, 2);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                  "sd_execute_write_data", 5033);
      goto SD_Execute_Write_Cmd_Failed;
    } else {

    }
    rtsx_write_register(chip, 64943, 255, 0);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                  "sd_execute_write_data", 5039);
      goto SD_Execute_Write_Cmd_Failed;
    } else {

    }
  } else {

  }
  if (((int )*(srb->cmnd + 1UL) & 2) != 0 || ((int )*(srb->cmnd + 1UL) & 4) != 0) {
    cmd13_checkbit = 1;
  } else {

  }
  i = 0;
  goto ldv_39260;
  ldv_39259: 
  retval = ext_sd_send_cmd_get_rsp(chip, 13, sd_card->sd_addr, 1, (u8 *)0U, 0, (int )cmd13_checkbit);
  if (retval == 0) {
    goto ldv_39258;
  } else {

  }
  i = i + 1;
  ldv_39260: ;
  if (i <= 2) {
    goto ldv_39259;
  } else {

  }
  ldv_39258: ;
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "sd_execute_write_data", 5056);
    goto SD_Execute_Write_Cmd_Failed;
  } else {

  }
  if ((unsigned int )cmd_idx == 42U) {
    if (lock_cmd_fail == 0) {
      descriptor___0.modname = "rts5208";
      descriptor___0.function = "sd_execute_write_data";
      descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c";
      descriptor___0.format = "lock_cmd_type = 0x%x\n";
      descriptor___0.lineno = 5064U;
      descriptor___0.flags = 0U;
      tmp___6 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
      if (tmp___6 != 0L) {
        tmp___5 = rtsx_dev((struct rtsx_chip  const  *)chip);
        __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)tmp___5, "lock_cmd_type = 0x%x\n",
                          (int )lock_cmd_type);
      } else {

      }
      if (((int )lock_cmd_type & 2) != 0) {
        sd_card->sd_lock_status = (unsigned int )sd_card->sd_lock_status & 223U;
      } else {

      }
      if ((int )lock_cmd_type & 1) {
        sd_card->sd_lock_status = (u8 )((unsigned int )sd_card->sd_lock_status | 32U);
      } else {

      }
    } else {

    }
    descriptor___1.modname = "rts5208";
    descriptor___1.function = "sd_execute_write_data";
    descriptor___1.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c";
    descriptor___1.format = "sd_lock_state = 0x%x, sd_card->sd_lock_status = 0x%x\n";
    descriptor___1.lineno = 5073U;
    descriptor___1.flags = 0U;
    tmp___8 = ldv__builtin_expect((long )descriptor___1.flags & 1L, 0L);
    if (tmp___8 != 0L) {
      tmp___7 = rtsx_dev((struct rtsx_chip  const  *)chip);
      __dynamic_dev_dbg(& descriptor___1, (struct device  const  *)tmp___7, "sd_lock_state = 0x%x, sd_card->sd_lock_status = 0x%x\n",
                        (int )sd_lock_state, (int )sd_card->sd_lock_status);
    } else {

    }
    if ((int )sd_lock_state != ((int )sd_card->sd_lock_status & 128)) {
      sd_card->sd_lock_notify = 1U;
      if ((unsigned int )sd_lock_state != 0U) {
        if (((int )sd_card->sd_lock_status & 64) != 0) {
          sd_card->sd_lock_status = (u8 )((unsigned int )sd_card->sd_lock_status | 3U);
          if (((int )sd_card->sd_type & 255) == 0) {
            retval = reset_sd(chip);
            if (retval != 0) {
              sd_card->sd_lock_status = (unsigned int )sd_card->sd_lock_status & 252U;
              _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                          "sd_execute_write_data", 5084);
              goto SD_Execute_Write_Cmd_Failed;
            } else {

            }
          } else {

          }
          sd_card->sd_lock_status = (unsigned int )sd_card->sd_lock_status & 252U;
        } else {

        }
      } else {

      }
    } else {

    }
  } else {

  }
  if (lock_cmd_fail != 0) {
    scsi_set_resid(srb, 0);
    set_sense_type(chip, lun, 0);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "sd_execute_write_data", 5098);
    return (1);
  } else {

  }
  scsi_set_resid(srb, 0);
  return (0);
  SD_Execute_Write_Cmd_Failed: 
  sd_card->pre_cmd_err = 1;
  set_sense_type(chip, lun, 0);
  if ((int )write_err) {
    set_sense_type(chip, lun, 8);
  } else {

  }
  release_sd_card(chip);
  do_reset_sd_card(chip);
  if (((int )chip->card_ready & 4) == 0) {
    set_sense_type(chip, lun, 2);
  } else {

  }
  _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
              "sd_execute_write_data", 5117);
  return (1);
}
}
int sd_get_cmd_rsp(struct scsi_cmnd *srb , struct rtsx_chip *chip ) 
{ 
  struct sd_info *sd_card ;
  unsigned int lun ;
  int count ;
  u16 data_len ;
  struct _ddebug descriptor ;
  struct device *tmp ;
  long tmp___0 ;
  struct _ddebug descriptor___0 ;
  struct device *tmp___1 ;
  long tmp___2 ;

  {
  sd_card = & chip->sd_card;
  lun = (unsigned int )(srb->device)->lun;
  if (sd_card->sd_pass_thru_en == 0) {
    set_sense_type(chip, lun, 6);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "sd_get_cmd_rsp", 5130);
    return (1);
  } else {

  }
  if (sd_card->pre_cmd_err != 0) {
    sd_card->pre_cmd_err = 0;
    set_sense_type(chip, lun, 1);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "sd_get_cmd_rsp", 5137);
    return (1);
  } else {

  }
  data_len = (u16 )((int )((short )((int )*(srb->cmnd + 7UL) << 8)) | (int )((short )*(srb->cmnd + 8UL)));
  if ((unsigned int )sd_card->last_rsp_type == 4U) {
    set_sense_type(chip, lun, 6);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "sd_get_cmd_rsp", 5145);
    return (1);
  } else
  if ((unsigned int )sd_card->last_rsp_type == 2U) {
    count = (unsigned int )data_len <= 16U ? (int )data_len : 17;
  } else {
    count = (unsigned int )data_len <= 5U ? (int )data_len : 6;
  }
  rtsx_stor_set_xfer_buf((unsigned char *)(& sd_card->rsp), (unsigned int )count,
                         srb);
  descriptor.modname = "rts5208";
  descriptor.function = "sd_get_cmd_rsp";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c";
  descriptor.format = "Response length: %d\n";
  descriptor.lineno = 5154U;
  descriptor.flags = 0U;
  tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp___0 != 0L) {
    tmp = rtsx_dev((struct rtsx_chip  const  *)chip);
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)tmp, "Response length: %d\n",
                      (int )data_len);
  } else {

  }
  descriptor___0.modname = "rts5208";
  descriptor___0.function = "sd_get_cmd_rsp";
  descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c";
  descriptor___0.format = "Response: 0x%x 0x%x 0x%x 0x%x\n";
  descriptor___0.lineno = 5157U;
  descriptor___0.flags = 0U;
  tmp___2 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
  if (tmp___2 != 0L) {
    tmp___1 = rtsx_dev((struct rtsx_chip  const  *)chip);
    __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)tmp___1, "Response: 0x%x 0x%x 0x%x 0x%x\n",
                      (int )sd_card->rsp[0], (int )sd_card->rsp[1], (int )sd_card->rsp[2],
                      (int )sd_card->rsp[3]);
  } else {

  }
  scsi_set_resid(srb, 0);
  return (0);
}
}
int sd_hw_rst(struct scsi_cmnd *srb , struct rtsx_chip *chip ) 
{ 
  struct sd_info *sd_card ;
  unsigned int lun ;
  int retval ;

  {
  sd_card = & chip->sd_card;
  lun = (unsigned int )(srb->device)->lun;
  if (sd_card->sd_pass_thru_en == 0) {
    set_sense_type(chip, lun, 6);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "sd_hw_rst", 5171);
    return (1);
  } else {

  }
  if (sd_card->pre_cmd_err != 0) {
    sd_card->pre_cmd_err = 0;
    set_sense_type(chip, lun, 1);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "sd_hw_rst", 5178);
    return (1);
  } else {

  }
  if (((((((unsigned int )*(srb->cmnd + 2UL) != 83U || (unsigned int )*(srb->cmnd + 3UL) != 68U) || (unsigned int )*(srb->cmnd + 4UL) != 32U) || (unsigned int )*(srb->cmnd + 5UL) != 67U) || (unsigned int )*(srb->cmnd + 6UL) != 97U) || (unsigned int )*(srb->cmnd + 7UL) != 114U) || (unsigned int )*(srb->cmnd + 8UL) != 100U) {
    set_sense_type(chip, lun, 6);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "sd_hw_rst", 5187);
    return (1);
  } else {

  }
  switch ((int )*(srb->cmnd + 1UL) & 15) {
  case 0: ;
  if ((unsigned int )*(srb->cmnd + 9UL) == 100U) {
    sd_card->sd_lock_status = (u8 )((unsigned int )sd_card->sd_lock_status | 2U);
  } else {

  }
  retval = reset_sd_card(chip);
  if (retval != 0) {
    sd_card->sd_lock_status = (unsigned int )sd_card->sd_lock_status & 253U;
    set_sense_type(chip, lun, 2);
    sd_card->pre_cmd_err = 1;
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "sd_hw_rst", 5204);
    return (1);
  } else {

  }
  sd_card->sd_lock_status = (unsigned int )sd_card->sd_lock_status & 253U;
  goto ldv_39283;
  case 1: 
  retval = soft_reset_sd_card(chip);
  if (retval != 0) {
    set_sense_type(chip, lun, 2);
    sd_card->pre_cmd_err = 1;
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "sd_hw_rst", 5217);
    return (1);
  } else {

  }
  goto ldv_39283;
  default: 
  set_sense_type(chip, lun, 6);
  _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
              "sd_hw_rst", 5224);
  return (1);
  }
  ldv_39283: 
  scsi_set_resid(srb, 0);
  return (0);
}
}
void sd_cleanup_work(struct rtsx_chip *chip ) 
{ 
  struct sd_info *sd_card ;
  struct _ddebug descriptor ;
  struct device *tmp ;
  long tmp___0 ;

  {
  sd_card = & chip->sd_card;
  if (sd_card->seq_mode != 0) {
    descriptor.modname = "rts5208";
    descriptor.function = "sd_cleanup_work";
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c";
    descriptor.format = "SD: stop transmission\n";
    descriptor.lineno = 5238U;
    descriptor.flags = 0U;
    tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
    if (tmp___0 != 0L) {
      tmp = rtsx_dev((struct rtsx_chip  const  *)chip);
      __dynamic_dev_dbg(& descriptor, (struct device  const  *)tmp, "SD: stop transmission\n");
    } else {

    }
    sd_stop_seq_mode(chip);
    sd_card->cleanup_counter = 0;
  } else {

  }
  return;
}
}
int sd_power_off_card3v3(struct rtsx_chip *chip ) 
{ 
  int retval ;
  struct task_struct *tmp ;
  long volatile   __ret ;
  struct task_struct *tmp___0 ;
  struct task_struct *tmp___1 ;
  struct task_struct *tmp___2 ;
  struct task_struct *tmp___3 ;

  {
  retval = disable_card_clock(chip, 4);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "sd_power_off_card3v3", 5250);
    return (1);
  } else {

  }
  retval = rtsx_write_register(chip, 64853, 4, 0);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "sd_power_off_card3v3", 5256);
    return (retval);
  } else {

  }
  if (chip->ft2_fast_mode == 0) {
    retval = card_power_off(chip, 4);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                  "sd_power_off_card3v3", 5263);
      return (1);
    } else {

    }
    tmp = get_current();
    tmp->task_state_change = 0UL;
    __ret = 1L;
    switch (8UL) {
    case 1UL: 
    tmp___0 = get_current();
    __asm__  volatile   ("xchgb %b0, %1\n": "+q" (__ret), "+m" (tmp___0->state): : "memory",
                         "cc");
    goto ldv_39299;
    case 2UL: 
    tmp___1 = get_current();
    __asm__  volatile   ("xchgw %w0, %1\n": "+r" (__ret), "+m" (tmp___1->state): : "memory",
                         "cc");
    goto ldv_39299;
    case 4UL: 
    tmp___2 = get_current();
    __asm__  volatile   ("xchgl %0, %1\n": "+r" (__ret), "+m" (tmp___2->state): : "memory",
                         "cc");
    goto ldv_39299;
    case 8UL: 
    tmp___3 = get_current();
    __asm__  volatile   ("xchgq %q0, %1\n": "+r" (__ret), "+m" (tmp___3->state): : "memory",
                         "cc");
    goto ldv_39299;
    default: 
    __xchg_wrong_size();
    }
    ldv_39299: 
    schedule_timeout(12L);
  } else {

  }
  if (chip->asic_code != 0) {
    retval = sd_pull_ctl_disable(chip);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                  "sd_power_off_card3v3", 5273);
      return (1);
    } else {

    }
  } else {
    retval = rtsx_write_register(chip, 64541, 40, 8);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                  "sd_power_off_card3v3", 5281);
      return (retval);
    } else {

    }
  }
  return (0);
}
}
int release_sd_card(struct rtsx_chip *chip ) 
{ 
  struct sd_info *sd_card ;
  int retval ;

  {
  sd_card = & chip->sd_card;
  chip->card_ready = (unsigned int )chip->card_ready & 251U;
  chip->card_fail = (unsigned int )chip->card_fail & 251U;
  chip->card_wp = (unsigned int )chip->card_wp & 251U;
  chip->sd_io = 0U;
  chip->sd_int = 0U;
  sd_card->sd_lock_status = 0U;
  sd_card->sd_erase_status = 0U;
  memset((void *)(& sd_card->raw_csd), 0, 16UL);
  memset((void *)(& sd_card->raw_scr), 0, 8UL);
  retval = sd_power_off_card3v3(chip);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/sd.c",
                "release_sd_card", 5311);
    return (1);
  } else {

  }
  return (0);
}
}
void ldv_mutex_lock_177(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_lock_lock(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_178(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_unlock_lock(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_179(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
int ldv_mutex_trylock_180(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
  tmp = mutex_trylock(ldv_func_arg1);
  ldv_func_res = tmp;
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
  return (tmp___0);
  return (ldv_func_res);
}
}
void ldv_mutex_unlock_181(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_182(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_unlock_i_mutex_of_inode(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_183(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_lock_i_mutex_of_inode(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
int ldv_scsi_add_host_with_dma_184(struct Scsi_Host *shost , struct device *dev ,
                                   struct device *dma_dev ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  int tmp ;

  {
  tmp = scsi_add_host_with_dma(shost, dev, dma_dev);
  ldv_func_res = tmp;
  if (ldv_func_res == 0) {
    ldv_state_variable_3 = 1;
    ldv_initialize_scsi_host_template_3();
  } else {

  }
  return (ldv_func_res);
}
}
__inline static long ldv__builtin_expect(long exp , long c ) ;
int ldv_mutex_trylock_200(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_198(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_201(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_202(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_197(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_199(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_203(struct mutex *ldv_func_arg1 ) ;
int ldv_scsi_add_host_with_dma_204(struct Scsi_Host *shost , struct device *dev ,
                                   struct device *dma_dev ) ;
__inline static void rtsx_clear_xd_error(struct rtsx_chip *chip ) 
{ 


  {
  rtsx_write_register(chip, 64852, 34, 34);
  return;
}
}
int xd_delay_write(struct rtsx_chip *chip ) ;
static int xd_build_l2p_tbl(struct rtsx_chip *chip , int zone_no ) ;
static int xd_init_page(struct rtsx_chip *chip , u32 phy_blk , u16 logoff , u8 start_page ,
                        u8 end_page ) ;
__inline static void xd_set_err_code(struct rtsx_chip *chip , u8 err_code ) 
{ 
  struct xd_info *xd_card ;

  {
  xd_card = & chip->xd_card;
  xd_card->err_code = err_code;
  return;
}
}
static int xd_set_init_para(struct rtsx_chip *chip ) 
{ 
  struct xd_info *xd_card ;
  int retval ;

  {
  xd_card = & chip->xd_card;
  if (chip->asic_code != 0) {
    xd_card->xd_clock = 47;
  } else {
    xd_card->xd_clock = 4;
  }
  retval = switch_clock(chip, xd_card->xd_clock);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/xd.c",
                "xd_set_init_para", 64);
    return (1);
  } else {

  }
  return (0);
}
}
static int xd_switch_clock(struct rtsx_chip *chip ) 
{ 
  struct xd_info *xd_card ;
  int retval ;

  {
  xd_card = & chip->xd_card;
  retval = select_card(chip, 16);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/xd.c",
                "xd_switch_clock", 78);
    return (1);
  } else {

  }
  retval = switch_clock(chip, xd_card->xd_clock);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/xd.c",
                "xd_switch_clock", 84);
    return (1);
  } else {

  }
  return (0);
}
}
static int xd_read_id(struct rtsx_chip *chip , u8 id_cmd , u8 *id_buf , u8 buf_len ) 
{ 
  int retval ;
  int i ;
  u8 *ptr ;
  u8 *tmp ;

  {
  chip->ci = 0;
  rtsx_add_cmd(chip, 1, 64794, 255, (int )id_cmd);
  rtsx_add_cmd(chip, 1, 64787, 255, 131);
  rtsx_add_cmd(chip, 2, 64787, 64, 64);
  i = 0;
  goto ldv_38393;
  ldv_38392: 
  rtsx_add_cmd(chip, 0, (int )((unsigned int )((unsigned short )i) + 64790U), 0, 0);
  i = i + 1;
  ldv_38393: ;
  if (i <= 3) {
    goto ldv_38392;
  } else {

  }
  retval = rtsx_send_cmd(chip, 16, 20);
  if (retval < 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/xd.c",
                "xd_read_id", 109);
    return (1);
  } else {

  }
  tmp = rtsx_get_cmd_data(chip);
  ptr = tmp + 1UL;
  if ((unsigned long )id_buf != (unsigned long )((u8 *)0U) && (unsigned int )buf_len != 0U) {
    if ((unsigned int )buf_len > 4U) {
      buf_len = 4U;
    } else {

    }
    memcpy((void *)id_buf, (void const   *)ptr, (size_t )buf_len);
  } else {

  }
  return (0);
}
}
static void xd_assign_phy_addr(struct rtsx_chip *chip , u32 addr , u8 mode ) 
{ 
  struct xd_info *xd_card ;

  {
  xd_card = & chip->xd_card;
  switch ((int )mode) {
  case 1: 
  rtsx_add_cmd(chip, 1, 64789, 255, 0);
  rtsx_add_cmd(chip, 1, 64790, 255, (int )((unsigned char )addr));
  rtsx_add_cmd(chip, 1, 64791, 255, (int )((unsigned char )(addr >> 8)));
  rtsx_add_cmd(chip, 1, 64792, 255, (int )((unsigned char )(addr >> 16)));
  rtsx_add_cmd(chip, 1, 64788, 255, (int )xd_card->addr_cycle);
  goto ldv_38403;
  case 2: 
  rtsx_add_cmd(chip, 1, 64789, 255, (int )((unsigned char )addr));
  rtsx_add_cmd(chip, 1, 64790, 255, (int )((unsigned char )(addr >> 8)));
  rtsx_add_cmd(chip, 1, 64791, 255, (int )((unsigned char )(addr >> 16)));
  rtsx_add_cmd(chip, 1, 64788, 255, (int )((unsigned int )xd_card->addr_cycle + 255U));
  goto ldv_38403;
  default: ;
  goto ldv_38403;
  }
  ldv_38403: ;
  return;
}
}
static int xd_read_redundant(struct rtsx_chip *chip , u32 page_addr , u8 *buf , int buf_len ) 
{ 
  int retval ;
  int i ;
  u8 *ptr ;
  u8 *tmp ;

  {
  chip->ci = 0;
  xd_assign_phy_addr(chip, page_addr, 1);
  rtsx_add_cmd(chip, 1, 64787, 255, 132);
  rtsx_add_cmd(chip, 2, 64787, 64, 64);
  i = 0;
  goto ldv_38415;
  ldv_38414: 
  rtsx_add_cmd(chip, 0, (int )((unsigned int )((unsigned short )i) + 64796U), 0, 0);
  i = i + 1;
  ldv_38415: ;
  if (i <= 5) {
    goto ldv_38414;
  } else {

  }
  i = 0;
  goto ldv_38418;
  ldv_38417: 
  rtsx_add_cmd(chip, 0, (int )((unsigned int )((unsigned short )i) + 64809U), 0, 0);
  i = i + 1;
  ldv_38418: ;
  if (i <= 3) {
    goto ldv_38417;
  } else {

  }
  rtsx_add_cmd(chip, 0, 64804, 0, 0);
  retval = rtsx_send_cmd(chip, 16, 500);
  if (retval < 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/xd.c",
                "xd_read_redundant", 179);
    return (1);
  } else {

  }
  if ((unsigned long )buf != (unsigned long )((u8 *)0U) && buf_len != 0) {
    tmp = rtsx_get_cmd_data(chip);
    ptr = tmp + 1UL;
    if (buf_len > 11) {
      buf_len = 11;
    } else {

    }
    memcpy((void *)buf, (void const   *)ptr, (size_t )buf_len);
  } else {

  }
  return (0);
}
}
static int xd_read_data_from_ppb(struct rtsx_chip *chip , int offset , u8 *buf , int buf_len ) 
{ 
  int retval ;
  int i ;
  u8 *tmp ;

  {
  if ((unsigned long )buf == (unsigned long )((u8 *)0U) || buf_len < 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/xd.c",
                "xd_read_data_from_ppb", 200);
    return (1);
  } else {

  }
  chip->ci = 0;
  i = 0;
  goto ldv_38432;
  ldv_38431: 
  rtsx_add_cmd(chip, 0, (int )((unsigned int )((int )((u16 )offset) + (int )((u16 )i)) + 64000U),
               0, 0);
  i = i + 1;
  ldv_38432: ;
  if (i < buf_len) {
    goto ldv_38431;
  } else {

  }
  retval = rtsx_send_cmd(chip, 0, 250);
  if (retval < 0) {
    rtsx_clear_xd_error(chip);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/xd.c",
                "xd_read_data_from_ppb", 213);
    return (1);
  } else {

  }
  tmp = rtsx_get_cmd_data(chip);
  memcpy((void *)buf, (void const   *)tmp, (size_t )buf_len);
  return (0);
}
}
static int xd_read_cis(struct rtsx_chip *chip , u32 page_addr , u8 *buf , int buf_len ) 
{ 
  int retval ;
  u8 reg ;
  u8 ecc_bit ;
  u8 ecc_byte ;
  struct _ddebug descriptor ;
  struct device *tmp ;
  long tmp___0 ;
  struct _ddebug descriptor___0 ;
  struct device *tmp___1 ;
  long tmp___2 ;
  struct _ddebug descriptor___1 ;
  struct device *tmp___3 ;
  long tmp___4 ;
  u8 ecc_bit___0 ;
  u8 ecc_byte___0 ;
  struct _ddebug descriptor___2 ;
  struct device *tmp___5 ;
  long tmp___6 ;
  struct _ddebug descriptor___3 ;
  struct device *tmp___7 ;
  long tmp___8 ;
  struct _ddebug descriptor___4 ;
  struct device *tmp___9 ;
  long tmp___10 ;

  {
  if ((unsigned long )buf == (unsigned long )((u8 *)0U) || buf_len <= 9) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/xd.c",
                "xd_read_cis", 229);
    return (1);
  } else {

  }
  chip->ci = 0;
  xd_assign_phy_addr(chip, page_addr, 1);
  rtsx_add_cmd(chip, 1, 64859, 1, 1);
  rtsx_add_cmd(chip, 1, 64795, 255, 1);
  rtsx_add_cmd(chip, 1, 64813, 1, 1);
  rtsx_add_cmd(chip, 1, 64787, 255, 133);
  rtsx_add_cmd(chip, 2, 64787, 64, 64);
  retval = rtsx_send_cmd(chip, 16, 250);
  if (retval == -110) {
    rtsx_clear_xd_error(chip);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/xd.c",
                "xd_read_cis", 251);
    return (1);
  } else {

  }
  retval = rtsx_read_register(chip, 64796, & reg);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/xd.c",
                "xd_read_cis", 257);
    return (retval);
  } else {

  }
  if ((unsigned int )reg != 255U) {
    rtsx_clear_xd_error(chip);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/xd.c",
                "xd_read_cis", 262);
    return (1);
  } else {

  }
  retval = rtsx_read_register(chip, 64786, & reg);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/xd.c",
                "xd_read_cis", 268);
    return (retval);
  } else {

  }
  if (((int )reg & 16) == 0 || ((int )reg & 32) == 0) {
    retval = xd_read_data_from_ppb(chip, 0, buf, buf_len);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/xd.c",
                  "xd_read_cis", 274);
      return (1);
    } else {

    }
    if (((int )reg & 16) != 0) {
      retval = rtsx_read_register(chip, 64805, & ecc_bit);
      if (retval != 0) {
        _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/xd.c",
                    "xd_read_cis", 283);
        return (retval);
      } else {

      }
      retval = rtsx_read_register(chip, 64806, & ecc_byte);
      if (retval != 0) {
        _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/xd.c",
                    "xd_read_cis", 289);
        return (retval);
      } else {

      }
      descriptor.modname = "rts5208";
      descriptor.function = "xd_read_cis";
      descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/xd.c";
      descriptor.format = "ECC_BIT1 = 0x%x, ECC_BYTE1 = 0x%x\n";
      descriptor.lineno = 294U;
      descriptor.flags = 0U;
      tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
      if (tmp___0 != 0L) {
        tmp = rtsx_dev((struct rtsx_chip  const  *)chip);
        __dynamic_dev_dbg(& descriptor, (struct device  const  *)tmp, "ECC_BIT1 = 0x%x, ECC_BYTE1 = 0x%x\n",
                          (int )ecc_bit, (int )ecc_byte);
      } else {

      }
      if ((int )ecc_byte < buf_len) {
        descriptor___0.modname = "rts5208";
        descriptor___0.function = "xd_read_cis";
        descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/xd.c";
        descriptor___0.format = "Before correct: 0x%x\n";
        descriptor___0.lineno = 297U;
        descriptor___0.flags = 0U;
        tmp___2 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
        if (tmp___2 != 0L) {
          tmp___1 = rtsx_dev((struct rtsx_chip  const  *)chip);
          __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)tmp___1, "Before correct: 0x%x\n",
                            (int )*(buf + (unsigned long )ecc_byte));
        } else {

        }
        *(buf + (unsigned long )ecc_byte) = (u8 )((int )((signed char )*(buf + (unsigned long )ecc_byte)) ^ (int )((signed char )(1 << (int )ecc_bit)));
        descriptor___1.modname = "rts5208";
        descriptor___1.function = "xd_read_cis";
        descriptor___1.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/xd.c";
        descriptor___1.format = "After correct: 0x%x\n";
        descriptor___1.lineno = 300U;
        descriptor___1.flags = 0U;
        tmp___4 = ldv__builtin_expect((long )descriptor___1.flags & 1L, 0L);
        if (tmp___4 != 0L) {
          tmp___3 = rtsx_dev((struct rtsx_chip  const  *)chip);
          __dynamic_dev_dbg(& descriptor___1, (struct device  const  *)tmp___3, "After correct: 0x%x\n",
                            (int )*(buf + (unsigned long )ecc_byte));
        } else {

        }
      } else {

      }
    } else {

    }
  } else
  if (((int )reg & 64) == 0 || (int )((signed char )reg) >= 0) {
    rtsx_clear_xd_error(chip);
    retval = xd_read_data_from_ppb(chip, 256, buf, buf_len);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/xd.c",
                  "xd_read_cis", 308);
      return (1);
    } else {

    }
    if (((int )reg & 64) != 0) {
      retval = rtsx_read_register(chip, 64807, & ecc_bit___0);
      if (retval != 0) {
        _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/xd.c",
                    "xd_read_cis", 317);
        return (retval);
      } else {

      }
      retval = rtsx_read_register(chip, 64808, & ecc_byte___0);
      if (retval != 0) {
        _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/xd.c",
                    "xd_read_cis", 323);
        return (retval);
      } else {

      }
      descriptor___2.modname = "rts5208";
      descriptor___2.function = "xd_read_cis";
      descriptor___2.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/xd.c";
      descriptor___2.format = "ECC_BIT2 = 0x%x, ECC_BYTE2 = 0x%x\n";
      descriptor___2.lineno = 328U;
      descriptor___2.flags = 0U;
      tmp___6 = ldv__builtin_expect((long )descriptor___2.flags & 1L, 0L);
      if (tmp___6 != 0L) {
        tmp___5 = rtsx_dev((struct rtsx_chip  const  *)chip);
        __dynamic_dev_dbg(& descriptor___2, (struct device  const  *)tmp___5, "ECC_BIT2 = 0x%x, ECC_BYTE2 = 0x%x\n",
                          (int )ecc_bit___0, (int )ecc_byte___0);
      } else {

      }
      if ((int )ecc_byte___0 < buf_len) {
        descriptor___3.modname = "rts5208";
        descriptor___3.function = "xd_read_cis";
        descriptor___3.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/xd.c";
        descriptor___3.format = "Before correct: 0x%x\n";
        descriptor___3.lineno = 331U;
        descriptor___3.flags = 0U;
        tmp___8 = ldv__builtin_expect((long )descriptor___3.flags & 1L, 0L);
        if (tmp___8 != 0L) {
          tmp___7 = rtsx_dev((struct rtsx_chip  const  *)chip);
          __dynamic_dev_dbg(& descriptor___3, (struct device  const  *)tmp___7, "Before correct: 0x%x\n",
                            (int )*(buf + (unsigned long )ecc_byte___0));
        } else {

        }
        *(buf + (unsigned long )ecc_byte___0) = (u8 )((int )((signed char )*(buf + (unsigned long )ecc_byte___0)) ^ (int )((signed char )(1 << (int )ecc_bit___0)));
        descriptor___4.modname = "rts5208";
        descriptor___4.function = "xd_read_cis";
        descriptor___4.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/xd.c";
        descriptor___4.format = "After correct: 0x%x\n";
        descriptor___4.lineno = 334U;
        descriptor___4.flags = 0U;
        tmp___10 = ldv__builtin_expect((long )descriptor___4.flags & 1L, 0L);
        if (tmp___10 != 0L) {
          tmp___9 = rtsx_dev((struct rtsx_chip  const  *)chip);
          __dynamic_dev_dbg(& descriptor___4, (struct device  const  *)tmp___9, "After correct: 0x%x\n",
                            (int )*(buf + (unsigned long )ecc_byte___0));
        } else {

        }
      } else {

      }
    } else {

    }
  } else {
    rtsx_clear_xd_error(chip);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/xd.c",
                "xd_read_cis", 339);
    return (1);
  }
  return (0);
}
}
static void xd_fill_pull_ctl_disable(struct rtsx_chip *chip ) 
{ 


  {
  if ((unsigned int )chip->product_id == 21000U) {
    rtsx_add_cmd(chip, 1, 64864, 255, 85);
    rtsx_add_cmd(chip, 1, 64865, 255, 85);
    rtsx_add_cmd(chip, 1, 64866, 255, 75);
    rtsx_add_cmd(chip, 1, 64867, 255, 85);
    rtsx_add_cmd(chip, 1, 64868, 255, 180);
    rtsx_add_cmd(chip, 1, 64869, 255, 5);
  } else
  if ((unsigned int )chip->product_id == 21128U) {
    if (chip->baro_pkg == 0) {
      rtsx_add_cmd(chip, 1, 64864, 255, 85);
      rtsx_add_cmd(chip, 1, 64865, 255, 85);
      rtsx_add_cmd(chip, 1, 64866, 255, 75);
      rtsx_add_cmd(chip, 1, 64867, 255, 105);
    } else {

    }
  } else {

  }
  return;
}
}
static void xd_fill_pull_ctl_stage1_barossa(struct rtsx_chip *chip ) 
{ 


  {
  if (chip->baro_pkg == 0) {
    rtsx_add_cmd(chip, 1, 64864, 255, 85);
    rtsx_add_cmd(chip, 1, 64865, 255, 85);
    rtsx_add_cmd(chip, 1, 64866, 255, 75);
    rtsx_add_cmd(chip, 1, 64867, 255, 85);
  } else {

  }
  return;
}
}
static void xd_fill_pull_ctl_enable(struct rtsx_chip *chip ) 
{ 


  {
  if ((unsigned int )chip->product_id == 21000U) {
    rtsx_add_cmd(chip, 1, 64864, 255, 85);
    rtsx_add_cmd(chip, 1, 64865, 255, 85);
    rtsx_add_cmd(chip, 1, 64866, 255, 83);
    rtsx_add_cmd(chip, 1, 64867, 255, 169);
    rtsx_add_cmd(chip, 1, 64868, 255, 180);
    rtsx_add_cmd(chip, 1, 64869, 255, 5);
  } else
  if ((unsigned int )chip->product_id == 21128U) {
    if (chip->baro_pkg == 0) {
      rtsx_add_cmd(chip, 1, 64864, 255, 85);
      rtsx_add_cmd(chip, 1, 64865, 255, 85);
      rtsx_add_cmd(chip, 1, 64866, 255, 83);
      rtsx_add_cmd(chip, 1, 64867, 255, 169);
    } else {

    }
  } else {

  }
  return;
}
}
static int xd_pull_ctl_disable(struct rtsx_chip *chip ) 
{ 
  int retval ;

  {
  if ((unsigned int )chip->product_id == 21000U) {
    retval = rtsx_write_register(chip, 64864, 255, 85);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/xd.c",
                  "xd_pull_ctl_disable", 422);
      return (retval);
    } else {

    }
    retval = rtsx_write_register(chip, 64865, 255, 85);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/xd.c",
                  "xd_pull_ctl_disable", 428);
      return (retval);
    } else {

    }
    retval = rtsx_write_register(chip, 64866, 255, 75);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/xd.c",
                  "xd_pull_ctl_disable", 434);
      return (retval);
    } else {

    }
    retval = rtsx_write_register(chip, 64867, 255, 85);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/xd.c",
                  "xd_pull_ctl_disable", 440);
      return (retval);
    } else {

    }
    retval = rtsx_write_register(chip, 64868, 255, 180);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/xd.c",
                  "xd_pull_ctl_disable", 446);
      return (retval);
    } else {

    }
    retval = rtsx_write_register(chip, 64869, 255, 5);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/xd.c",
                  "xd_pull_ctl_disable", 452);
      return (retval);
    } else {

    }
  } else
  if ((unsigned int )chip->product_id == 21128U) {
    if (chip->baro_pkg == 0) {
      retval = rtsx_write_register(chip, 64864, 255, 85);
      if (retval != 0) {
        _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/xd.c",
                    "xd_pull_ctl_disable", 460);
        return (retval);
      } else {

      }
      retval = rtsx_write_register(chip, 64865, 255, 85);
      if (retval != 0) {
        _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/xd.c",
                    "xd_pull_ctl_disable", 466);
        return (retval);
      } else {

      }
      retval = rtsx_write_register(chip, 64866, 255, 75);
      if (retval != 0) {
        _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/xd.c",
                    "xd_pull_ctl_disable", 472);
        return (retval);
      } else {

      }
      retval = rtsx_write_register(chip, 64867, 255, 105);
      if (retval != 0) {
        _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/xd.c",
                    "xd_pull_ctl_disable", 478);
        return (retval);
      } else {

      }
    } else {

    }
  } else {

  }
  return (0);
}
}
static int reset_xd(struct rtsx_chip *chip ) 
{ 
  struct xd_info *xd_card ;
  int retval ;
  int i ;
  int j ;
  u8 *ptr ;
  u8 id_buf[4U] ;
  u8 redunt[11U] ;
  struct task_struct *tmp ;
  long volatile   __ret ;
  struct task_struct *tmp___0 ;
  struct task_struct *tmp___1 ;
  struct task_struct *tmp___2 ;
  struct task_struct *tmp___3 ;
  struct task_struct *tmp___4 ;
  long volatile   __ret___0 ;
  struct task_struct *tmp___5 ;
  struct task_struct *tmp___6 ;
  struct task_struct *tmp___7 ;
  struct task_struct *tmp___8 ;
  struct _ddebug descriptor ;
  struct device *tmp___9 ;
  long tmp___10 ;
  struct task_struct *tmp___11 ;
  long volatile   __ret___1 ;
  struct task_struct *tmp___12 ;
  struct task_struct *tmp___13 ;
  struct task_struct *tmp___14 ;
  struct task_struct *tmp___15 ;
  u8 *tmp___16 ;
  struct _ddebug descriptor___0 ;
  struct device *tmp___17 ;
  long tmp___18 ;
  struct _ddebug descriptor___1 ;
  struct device *tmp___19 ;
  long tmp___20 ;
  struct _ddebug descriptor___2 ;
  struct device *tmp___21 ;
  long tmp___22 ;
  u32 page_addr ;
  int tmp___23 ;
  u8 buf[10U] ;
  struct _ddebug descriptor___3 ;
  struct device *tmp___24 ;
  long tmp___25 ;

  {
  xd_card = & chip->xd_card;
  retval = select_card(chip, 16);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/xd.c",
                "reset_xd", 495);
    return (1);
  } else {

  }
  chip->ci = 0;
  rtsx_add_cmd(chip, 1, 64813, 255, 2);
  if (chip->asic_code != 0) {
    if ((unsigned int )chip->product_id != 21128U) {
      xd_fill_pull_ctl_disable(chip);
    } else {
      xd_fill_pull_ctl_stage1_barossa(chip);
    }
  } else {
    rtsx_add_cmd(chip, 1, 64541, 255, 250);
  }
  if (chip->ft2_fast_mode == 0) {
    rtsx_add_cmd(chip, 1, 64784, 8, 0);
  } else {

  }
  rtsx_add_cmd(chip, 1, 64853, 2, 0);
  retval = rtsx_send_cmd(chip, 16, 100);
  if (retval < 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/xd.c",
                "reset_xd", 521);
    return (1);
  } else {

  }
  if (chip->ft2_fast_mode == 0) {
    retval = card_power_off(chip, 16);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/xd.c",
                  "reset_xd", 528);
      return (1);
    } else {

    }
    tmp = get_current();
    tmp->task_state_change = 0UL;
    __ret = 1L;
    switch (8UL) {
    case 1UL: 
    tmp___0 = get_current();
    __asm__  volatile   ("xchgb %b0, %1\n": "+q" (__ret), "+m" (tmp___0->state): : "memory",
                         "cc");
    goto ldv_38480;
    case 2UL: 
    tmp___1 = get_current();
    __asm__  volatile   ("xchgw %w0, %1\n": "+r" (__ret), "+m" (tmp___1->state): : "memory",
                         "cc");
    goto ldv_38480;
    case 4UL: 
    tmp___2 = get_current();
    __asm__  volatile   ("xchgl %0, %1\n": "+r" (__ret), "+m" (tmp___2->state): : "memory",
                         "cc");
    goto ldv_38480;
    case 8UL: 
    tmp___3 = get_current();
    __asm__  volatile   ("xchgq %q0, %1\n": "+r" (__ret), "+m" (tmp___3->state): : "memory",
                         "cc");
    goto ldv_38480;
    default: 
    __xchg_wrong_size();
    }
    ldv_38480: 
    schedule_timeout(62L);
    chip->ci = 0;
    if (chip->asic_code != 0) {
      xd_fill_pull_ctl_enable(chip);
    } else {
      rtsx_add_cmd(chip, 1, 64541, 255, 252);
    }
    retval = rtsx_send_cmd(chip, 16, 100);
    if (retval < 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/xd.c",
                  "reset_xd", 546);
      return (1);
    } else {

    }
    retval = card_power_on(chip, 16);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/xd.c",
                  "reset_xd", 552);
      return (1);
    } else {

    }
    tmp___4 = get_current();
    tmp___4->task_state_change = 0UL;
    __ret___0 = 1L;
    switch (8UL) {
    case 1UL: 
    tmp___5 = get_current();
    __asm__  volatile   ("xchgb %b0, %1\n": "+q" (__ret___0), "+m" (tmp___5->state): : "memory",
                         "cc");
    goto ldv_38488;
    case 2UL: 
    tmp___6 = get_current();
    __asm__  volatile   ("xchgw %w0, %1\n": "+r" (__ret___0), "+m" (tmp___6->state): : "memory",
                         "cc");
    goto ldv_38488;
    case 4UL: 
    tmp___7 = get_current();
    __asm__  volatile   ("xchgl %0, %1\n": "+r" (__ret___0), "+m" (tmp___7->state): : "memory",
                         "cc");
    goto ldv_38488;
    case 8UL: 
    tmp___8 = get_current();
    __asm__  volatile   ("xchgq %q0, %1\n": "+r" (__ret___0), "+m" (tmp___8->state): : "memory",
                         "cc");
    goto ldv_38488;
    default: 
    __xchg_wrong_size();
    }
    ldv_38488: 
    schedule_timeout(12L);
    if (((int )chip->ocp_stat & 6) != 0) {
      descriptor.modname = "rts5208";
      descriptor.function = "reset_xd";
      descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/xd.c";
      descriptor.format = "Over current, OCPSTAT is 0x%x\n";
      descriptor.lineno = 560U;
      descriptor.flags = 0U;
      tmp___10 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
      if (tmp___10 != 0L) {
        tmp___9 = rtsx_dev((struct rtsx_chip  const  *)chip);
        __dynamic_dev_dbg(& descriptor, (struct device  const  *)tmp___9, "Over current, OCPSTAT is 0x%x\n",
                          (int )chip->ocp_stat);
      } else {

      }
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/xd.c",
                  "reset_xd", 561);
      return (1);
    } else {

    }
  } else {

  }
  chip->ci = 0;
  if (chip->ft2_fast_mode != 0) {
    if (chip->asic_code != 0) {
      xd_fill_pull_ctl_enable(chip);
    } else {
      rtsx_add_cmd(chip, 1, 64541, 255, 252);
    }
  } else {

  }
  rtsx_add_cmd(chip, 1, 64853, 2, 2);
  rtsx_add_cmd(chip, 1, 64786, 2, 2);
  retval = rtsx_send_cmd(chip, 16, 100);
  if (retval < 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/xd.c",
                "reset_xd", 584);
    return (1);
  } else {

  }
  if (chip->ft2_fast_mode == 0) {
    tmp___11 = get_current();
    tmp___11->task_state_change = 0UL;
    __ret___1 = 1L;
    switch (8UL) {
    case 1UL: 
    tmp___12 = get_current();
    __asm__  volatile   ("xchgb %b0, %1\n": "+q" (__ret___1), "+m" (tmp___12->state): : "memory",
                         "cc");
    goto ldv_38497;
    case 2UL: 
    tmp___13 = get_current();
    __asm__  volatile   ("xchgw %w0, %1\n": "+r" (__ret___1), "+m" (tmp___13->state): : "memory",
                         "cc");
    goto ldv_38497;
    case 4UL: 
    tmp___14 = get_current();
    __asm__  volatile   ("xchgl %0, %1\n": "+r" (__ret___1), "+m" (tmp___14->state): : "memory",
                         "cc");
    goto ldv_38497;
    case 8UL: 
    tmp___15 = get_current();
    __asm__  volatile   ("xchgq %q0, %1\n": "+r" (__ret___1), "+m" (tmp___15->state): : "memory",
                         "cc");
    goto ldv_38497;
    default: 
    __xchg_wrong_size();
    }
    ldv_38497: 
    schedule_timeout(50L);
  } else {

  }
  retval = xd_set_init_para(chip);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/xd.c",
                "reset_xd", 593);
    return (1);
  } else {

  }
  i = 0;
  goto ldv_38524;
  ldv_38523: 
  chip->ci = 0;
  rtsx_add_cmd(chip, 1, 64785, 255, (int )((unsigned int )((u8 )((i + 2) + i * 8)) * 4U + 3U));
  rtsx_add_cmd(chip, 1, 64814, 255, (int )((unsigned int )((u8 )((i + 4) + (i + 3) * 8)) * 4U + 3U));
  rtsx_add_cmd(chip, 1, 64787, 255, 128);
  rtsx_add_cmd(chip, 2, 64787, 64, 64);
  rtsx_add_cmd(chip, 0, 64794, 0, 0);
  rtsx_add_cmd(chip, 0, 64786, 0, 0);
  retval = rtsx_send_cmd(chip, 16, 100);
  if (retval < 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/xd.c",
                "reset_xd", 618);
    return (1);
  } else {

  }
  tmp___16 = rtsx_get_cmd_data(chip);
  ptr = tmp___16 + 1UL;
  descriptor___0.modname = "rts5208";
  descriptor___0.function = "reset_xd";
  descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/xd.c";
  descriptor___0.format = "XD_DAT: 0x%x, XD_CTL: 0x%x\n";
  descriptor___0.lineno = 625U;
  descriptor___0.flags = 0U;
  tmp___18 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
  if (tmp___18 != 0L) {
    tmp___17 = rtsx_dev((struct rtsx_chip  const  *)chip);
    __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)tmp___17, "XD_DAT: 0x%x, XD_CTL: 0x%x\n",
                      (int )*ptr, (int )*(ptr + 1UL));
  } else {

  }
  if (((int )*ptr & 95) != 64 || ((int )*(ptr + 1UL) & 4) == 0) {
    goto ldv_38504;
  } else {

  }
  retval = xd_read_id(chip, 144, (u8 *)(& id_buf), 4);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/xd.c",
                "reset_xd", 633);
    return (1);
  } else {

  }
  descriptor___1.modname = "rts5208";
  descriptor___1.function = "reset_xd";
  descriptor___1.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/xd.c";
  descriptor___1.format = "READ_ID: 0x%x 0x%x 0x%x 0x%x\n";
  descriptor___1.lineno = 638U;
  descriptor___1.flags = 0U;
  tmp___20 = ldv__builtin_expect((long )descriptor___1.flags & 1L, 0L);
  if (tmp___20 != 0L) {
    tmp___19 = rtsx_dev((struct rtsx_chip  const  *)chip);
    __dynamic_dev_dbg(& descriptor___1, (struct device  const  *)tmp___19, "READ_ID: 0x%x 0x%x 0x%x 0x%x\n",
                      (int )id_buf[0], (int )id_buf[1], (int )id_buf[2], (int )id_buf[3]);
  } else {

  }
  xd_card->device_code = id_buf[1];
  switch ((int )xd_card->device_code) {
  case 227: ;
  case 229: 
  xd_card->block_shift = 4U;
  xd_card->page_off = 15U;
  xd_card->addr_cycle = 3U;
  xd_card->zone_cnt = 1;
  xd_card->capacity = 8000U;
  xd_card->multi_flag = (u8 )((unsigned int )xd_card->multi_flag | 16U);
  goto ldv_38508;
  case 230: 
  xd_card->block_shift = 4U;
  xd_card->page_off = 15U;
  xd_card->addr_cycle = 3U;
  xd_card->zone_cnt = 1;
  xd_card->capacity = 16000U;
  goto ldv_38508;
  case 115: 
  xd_card->block_shift = 5U;
  xd_card->page_off = 31U;
  xd_card->addr_cycle = 3U;
  xd_card->zone_cnt = 1;
  xd_card->capacity = 32000U;
  goto ldv_38508;
  case 117: 
  xd_card->block_shift = 5U;
  xd_card->page_off = 31U;
  xd_card->addr_cycle = 3U;
  xd_card->zone_cnt = 2;
  xd_card->capacity = 64000U;
  goto ldv_38508;
  case 118: 
  xd_card->block_shift = 5U;
  xd_card->page_off = 31U;
  xd_card->addr_cycle = 4U;
  xd_card->zone_cnt = 4;
  xd_card->capacity = 128000U;
  goto ldv_38508;
  case 121: 
  xd_card->block_shift = 5U;
  xd_card->page_off = 31U;
  xd_card->addr_cycle = 4U;
  xd_card->zone_cnt = 8;
  xd_card->capacity = 256000U;
  goto ldv_38508;
  case 113: 
  xd_card->block_shift = 5U;
  xd_card->page_off = 31U;
  xd_card->addr_cycle = 4U;
  xd_card->zone_cnt = 16;
  xd_card->capacity = 512000U;
  goto ldv_38508;
  case 220: 
  xd_card->block_shift = 5U;
  xd_card->page_off = 31U;
  xd_card->addr_cycle = 4U;
  xd_card->zone_cnt = 32;
  xd_card->capacity = 1024000U;
  goto ldv_38508;
  case 211: 
  xd_card->block_shift = 5U;
  xd_card->page_off = 31U;
  xd_card->addr_cycle = 4U;
  xd_card->zone_cnt = 64;
  xd_card->capacity = 2048000U;
  goto ldv_38508;
  case 213: 
  xd_card->block_shift = 5U;
  xd_card->page_off = 31U;
  xd_card->addr_cycle = 4U;
  xd_card->zone_cnt = 128;
  xd_card->capacity = 4096000U;
  goto ldv_38508;
  default: ;
  goto ldv_38504;
  }
  ldv_38508: 
  j = 0;
  goto ldv_38521;
  ldv_38520: 
  retval = xd_read_id(chip, 144, (u8 *)(& id_buf), 4);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/xd.c",
                "reset_xd", 716);
    return (1);
  } else {

  }
  if ((int )id_buf[1] != (int )xd_card->device_code) {
    goto ldv_38519;
  } else {

  }
  j = j + 1;
  ldv_38521: ;
  if (j <= 9) {
    goto ldv_38520;
  } else {

  }
  ldv_38519: ;
  if (j == 10) {
    goto ldv_38522;
  } else {

  }
  ldv_38504: 
  i = i + 1;
  ldv_38524: ;
  if (i <= 3) {
    goto ldv_38523;
  } else {

  }
  ldv_38522: ;
  if (i == 4) {
    xd_card->block_shift = 0U;
    xd_card->page_off = 0U;
    xd_card->addr_cycle = 0U;
    xd_card->capacity = 0U;
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/xd.c",
                "reset_xd", 734);
    return (1);
  } else {

  }
  retval = xd_read_id(chip, 154, (u8 *)(& id_buf), 4);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/xd.c",
                "reset_xd", 740);
    return (1);
  } else {

  }
  descriptor___2.modname = "rts5208";
  descriptor___2.function = "reset_xd";
  descriptor___2.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/xd.c";
  descriptor___2.format = "READ_xD_ID: 0x%x 0x%x 0x%x 0x%x\n";
  descriptor___2.lineno = 744U;
  descriptor___2.flags = 0U;
  tmp___22 = ldv__builtin_expect((long )descriptor___2.flags & 1L, 0L);
  if (tmp___22 != 0L) {
    tmp___21 = rtsx_dev((struct rtsx_chip  const  *)chip);
    __dynamic_dev_dbg(& descriptor___2, (struct device  const  *)tmp___21, "READ_xD_ID: 0x%x 0x%x 0x%x 0x%x\n",
                      (int )id_buf[0], (int )id_buf[1], (int )id_buf[2], (int )id_buf[3]);
  } else {

  }
  if ((unsigned int )id_buf[2] != 181U) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/xd.c",
                "reset_xd", 746);
    return (1);
  } else {

  }
  i = 0;
  goto ldv_38537;
  ldv_38536: 
  tmp___23 = detect_card_cd(chip, 16);
  if (tmp___23 != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/xd.c",
                "reset_xd", 755);
    return (1);
  } else {

  }
  page_addr = (unsigned int )i << (int )xd_card->block_shift;
  j = 0;
  goto ldv_38529;
  ldv_38528: 
  retval = xd_read_redundant(chip, page_addr, (u8 *)(& redunt), 11);
  if (retval == 0) {
    goto ldv_38527;
  } else {

  }
  j = j + 1;
  ldv_38529: ;
  if (j <= 2) {
    goto ldv_38528;
  } else {

  }
  ldv_38527: ;
  if (j == 3) {
    goto ldv_38530;
  } else {

  }
  if ((unsigned int )redunt[1] != 255U) {
    goto ldv_38530;
  } else {

  }
  j = 0;
  if ((unsigned int )redunt[0] != 255U) {
    j = 1;
    goto ldv_38533;
    ldv_38532: 
    retval = xd_read_redundant(chip, page_addr + (u32 )j, (u8 *)(& redunt), 11);
    if (retval == 0) {
      if ((unsigned int )redunt[0] == 255U) {
        goto ldv_38531;
      } else {

      }
    } else {

    }
    j = j + 1;
    ldv_38533: ;
    if (j <= 8) {
      goto ldv_38532;
    } else {

    }
    ldv_38531: ;
    if (j == 9) {
      goto ldv_38534;
    } else {

    }
  } else {

  }
  if ((unsigned int )redunt[1] == 255U && ((int )redunt[10] & 16) != 0) {
    page_addr = page_addr + (u32 )j;
    retval = xd_read_cis(chip, page_addr, (u8 *)(& buf), 10);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/xd.c",
                  "reset_xd", 796);
      return (1);
    } else {

    }
    if ((((((((((unsigned int )buf[0] == 1U && (unsigned int )buf[1] == 3U) && (unsigned int )buf[2] == 217U) && (unsigned int )buf[3] == 1U) && (unsigned int )buf[4] == 255U) && (unsigned int )buf[5] == 24U) && (unsigned int )buf[6] == 2U) && (unsigned int )buf[7] == 223U) && (unsigned int )buf[8] == 1U) && (unsigned int )buf[9] == 32U) {
      xd_card->cis_block = (unsigned short )i;
    } else {

    }
  } else {

  }
  goto ldv_38534;
  ldv_38530: 
  i = i + 1;
  ldv_38537: ;
  if (i <= 23) {
    goto ldv_38536;
  } else {

  }
  ldv_38534: 
  descriptor___3.modname = "rts5208";
  descriptor___3.function = "reset_xd";
  descriptor___3.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/xd.c";
  descriptor___3.format = "CIS block: 0x%x\n";
  descriptor___3.lineno = 813U;
  descriptor___3.flags = 0U;
  tmp___25 = ldv__builtin_expect((long )descriptor___3.flags & 1L, 0L);
  if (tmp___25 != 0L) {
    tmp___24 = rtsx_dev((struct rtsx_chip  const  *)chip);
    __dynamic_dev_dbg(& descriptor___3, (struct device  const  *)tmp___24, "CIS block: 0x%x\n",
                      (int )xd_card->cis_block);
  } else {

  }
  if ((unsigned int )xd_card->cis_block == 65535U) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/xd.c",
                "reset_xd", 815);
    return (1);
  } else {

  }
  chip->capacity[(int )chip->card2lun[16]] = xd_card->capacity;
  return (0);
}
}
static int xd_check_data_blank(u8 *redunt ) 
{ 
  int i ;

  {
  i = 0;
  goto ldv_38544;
  ldv_38543: ;
  if ((unsigned int )*(redunt + (unsigned long )i) != 255U) {
    return (0);
  } else {

  }
  i = i + 1;
  ldv_38544: ;
  if (i <= 5) {
    goto ldv_38543;
  } else {

  }

  if (((int )*(redunt + 10UL) & 192) != 192) {
    return (0);
  } else {

  }
  i = 0;
  goto ldv_38547;
  ldv_38546: ;
  if ((unsigned int )*(redunt + (unsigned long )(i + 6)) != 255U) {
    return (0);
  } else {

  }
  i = i + 1;
  ldv_38547: ;
  if (i <= 3) {
    goto ldv_38546;
  } else {

  }

  return (1);
}
}
static u16 xd_load_log_block_addr(u8 *redunt ) 
{ 
  u16 addr ;

  {
  addr = 65535U;
  if (((int )*(redunt + 10UL) & 4) != 0) {
    addr = (u16 )((int )((short )((int )*(redunt + 3UL) << 8)) | (int )((short )*(redunt + 2UL)));
  } else
  if ((int )*(redunt + 10UL) & 1) {
    addr = (u16 )((int )((short )((int )*(redunt + 3UL) << 8)) | (int )((short )*(redunt + 2UL)));
  } else
  if (((int )*(redunt + 10UL) & 2) != 0) {
    addr = (u16 )((int )((short )((int )*(redunt + 5UL) << 8)) | (int )((short )*(redunt + 4UL)));
  } else {

  }
  return (addr);
}
}
static int xd_init_l2p_tbl(struct rtsx_chip *chip ) 
{ 
  struct xd_info *xd_card ;
  int size ;
  int i ;
  struct _ddebug descriptor ;
  struct device *tmp ;
  long tmp___0 ;
  struct _ddebug descriptor___0 ;
  struct device *tmp___1 ;
  long tmp___2 ;
  void *tmp___3 ;

  {
  xd_card = & chip->xd_card;
  descriptor.modname = "rts5208";
  descriptor.function = "xd_init_l2p_tbl";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/xd.c";
  descriptor.format = "xd_init_l2p_tbl: zone_cnt = %d\n";
  descriptor.lineno = 869U;
  descriptor.flags = 0U;
  tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp___0 != 0L) {
    tmp = rtsx_dev((struct rtsx_chip  const  *)chip);
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)tmp, "xd_init_l2p_tbl: zone_cnt = %d\n",
                      xd_card->zone_cnt);
  } else {

  }
  if (xd_card->zone_cnt <= 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/xd.c",
                "xd_init_l2p_tbl", 872);
    return (1);
  } else {

  }
  size = (int )((unsigned int )xd_card->zone_cnt * 56U);
  descriptor___0.modname = "rts5208";
  descriptor___0.function = "xd_init_l2p_tbl";
  descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/xd.c";
  descriptor___0.format = "Buffer size for l2p table is %d\n";
  descriptor___0.lineno = 877U;
  descriptor___0.flags = 0U;
  tmp___2 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
  if (tmp___2 != 0L) {
    tmp___1 = rtsx_dev((struct rtsx_chip  const  *)chip);
    __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)tmp___1, "Buffer size for l2p table is %d\n",
                      size);
  } else {

  }
  tmp___3 = vmalloc((unsigned long )size);
  xd_card->zone = (struct zone_entry *)tmp___3;
  if ((unsigned long )xd_card->zone == (unsigned long )((struct zone_entry *)0)) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/xd.c",
                "xd_init_l2p_tbl", 881);
    return (10);
  } else {

  }
  i = 0;
  goto ldv_38563;
  ldv_38562: 
  (xd_card->zone + (unsigned long )i)->build_flag = 0;
  (xd_card->zone + (unsigned long )i)->l2p_table = (u16 *)0U;
  (xd_card->zone + (unsigned long )i)->free_table = (u16 *)0U;
  (xd_card->zone + (unsigned long )i)->get_index = 0;
  (xd_card->zone + (unsigned long )i)->set_index = 0;
  (xd_card->zone + (unsigned long )i)->unused_blk_cnt = 0;
  i = i + 1;
  ldv_38563: ;
  if (xd_card->zone_cnt > i) {
    goto ldv_38562;
  } else {

  }

  return (0);
}
}
__inline static void free_zone(struct zone_entry *zone ) 
{ 


  {
  if ((unsigned long )zone == (unsigned long )((struct zone_entry *)0)) {
    return;
  } else {

  }
  zone->build_flag = 0;
  zone->set_index = 0;
  zone->get_index = 0;
  zone->unused_blk_cnt = 0;
  if ((unsigned long )zone->l2p_table != (unsigned long )((u16 *)0U)) {
    vfree((void const   *)zone->l2p_table);
    zone->l2p_table = (u16 *)0U;
  } else {

  }
  if ((unsigned long )zone->free_table != (unsigned long )((u16 *)0U)) {
    vfree((void const   *)zone->free_table);
    zone->free_table = (u16 *)0U;
  } else {

  }
  return;
}
}
static void xd_set_unused_block(struct rtsx_chip *chip , u32 phy_blk ) 
{ 
  struct xd_info *xd_card ;
  struct zone_entry *zone ;
  int zone_no ;
    klee_make_symbolic(&zone_no, sizeof(int), "zone_no");
  struct _ddebug descriptor ;
  struct device *tmp ;
  long tmp___0 ;
  int tmp___1 ;
  struct _ddebug descriptor___0 ;
  struct device *tmp___2 ;
  long tmp___3 ;
  struct _ddebug descriptor___1 ;
  struct device *tmp___4 ;
  long tmp___5 ;
  int tmp___6 ;

  {
  xd_card = & chip->xd_card;
  zone_no = (int )phy_blk >> 10;
  if (xd_card->zone_cnt <= zone_no) {
    descriptor.modname = "rts5208";
    descriptor.function = "xd_set_unused_block";
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/xd.c";
    descriptor.format = "Set unused block to invalid zone (zone_no = %d, zone_cnt = %d)\n";
    descriptor.lineno = 925U;
    descriptor.flags = 0U;
    tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
    if (tmp___0 != 0L) {
      tmp = rtsx_dev((struct rtsx_chip  const  *)chip);
      __dynamic_dev_dbg(& descriptor, (struct device  const  *)tmp, "Set unused block to invalid zone (zone_no = %d, zone_cnt = %d)\n",
                        zone_no, xd_card->zone_cnt);
    } else {

    }
    return;
  } else {

  }
  zone = xd_card->zone + (unsigned long )zone_no;
  if ((unsigned long )zone->free_table == (unsigned long )((u16 *)0U)) {
    tmp___1 = xd_build_l2p_tbl(chip, zone_no);
    if (tmp___1 != 0) {
      return;
    } else {

    }
  } else {

  }
  if (zone->set_index > 1199 || zone->set_index < 0) {
    free_zone(zone);
    descriptor___0.modname = "rts5208";
    descriptor___0.function = "xd_set_unused_block";
    descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/xd.c";
    descriptor___0.format = "Set unused block fail, invalid set_index\n";
    descriptor___0.lineno = 938U;
    descriptor___0.flags = 0U;
    tmp___3 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
    if (tmp___3 != 0L) {
      tmp___2 = rtsx_dev((struct rtsx_chip  const  *)chip);
      __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)tmp___2, "Set unused block fail, invalid set_index\n");
    } else {

    }
    return;
  } else {

  }
  descriptor___1.modname = "rts5208";
  descriptor___1.function = "xd_set_unused_block";
  descriptor___1.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/xd.c";
  descriptor___1.format = "Set unused block to index %d\n";
  descriptor___1.lineno = 943U;
  descriptor___1.flags = 0U;
  tmp___5 = ldv__builtin_expect((long )descriptor___1.flags & 1L, 0L);
  if (tmp___5 != 0L) {
    tmp___4 = rtsx_dev((struct rtsx_chip  const  *)chip);
    __dynamic_dev_dbg(& descriptor___1, (struct device  const  *)tmp___4, "Set unused block to index %d\n",
                      zone->set_index);
  } else {

  }
  tmp___6 = zone->set_index;
  zone->set_index = zone->set_index + 1;
  *(zone->free_table + (unsigned long )tmp___6) = (unsigned int )((unsigned short )phy_blk) & 1023U;
  if (zone->set_index > 1199) {
    zone->set_index = 0;
  } else {

  }
  zone->unused_blk_cnt = zone->unused_blk_cnt + 1;
  return;
}
}
static u32 xd_get_unused_block(struct rtsx_chip *chip , int zone_no ) 
{ 
  struct xd_info *xd_card ;
  struct zone_entry *zone ;
  u32 phy_blk ;
  struct _ddebug descriptor ;
  struct device *tmp ;
  long tmp___0 ;
  struct _ddebug descriptor___0 ;
  struct device *tmp___1 ;
  long tmp___2 ;
  struct _ddebug descriptor___1 ;
  struct device *tmp___3 ;
  long tmp___4 ;
  struct _ddebug descriptor___2 ;
  struct device *tmp___5 ;
  long tmp___6 ;
  int tmp___7 ;

  {
  xd_card = & chip->xd_card;
  if (xd_card->zone_cnt <= zone_no) {
    descriptor.modname = "rts5208";
    descriptor.function = "xd_get_unused_block";
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/xd.c";
    descriptor.format = "Get unused block from invalid zone (zone_no = %d, zone_cnt = %d)\n";
    descriptor.lineno = 959U;
    descriptor.flags = 0U;
    tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
    if (tmp___0 != 0L) {
      tmp = rtsx_dev((struct rtsx_chip  const  *)chip);
      __dynamic_dev_dbg(& descriptor, (struct device  const  *)tmp, "Get unused block from invalid zone (zone_no = %d, zone_cnt = %d)\n",
                        zone_no, xd_card->zone_cnt);
    } else {

    }
    return (4294967295U);
  } else {

  }
  zone = xd_card->zone + (unsigned long )zone_no;
  if (zone->unused_blk_cnt == 0 || zone->set_index == zone->get_index) {
    free_zone(zone);
    descriptor___0.modname = "rts5208";
    descriptor___0.function = "xd_get_unused_block";
    descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/xd.c";
    descriptor___0.format = "Get unused block fail, no unused block available\n";
    descriptor___0.lineno = 967U;
    descriptor___0.flags = 0U;
    tmp___2 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
    if (tmp___2 != 0L) {
      tmp___1 = rtsx_dev((struct rtsx_chip  const  *)chip);
      __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)tmp___1, "Get unused block fail, no unused block available\n");
    } else {

    }
    return (4294967295U);
  } else {

  }
  if (zone->get_index > 1199 || zone->get_index < 0) {
    free_zone(zone);
    descriptor___1.modname = "rts5208";
    descriptor___1.function = "xd_get_unused_block";
    descriptor___1.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/xd.c";
    descriptor___1.format = "Get unused block fail, invalid get_index\n";
    descriptor___1.lineno = 972U;
    descriptor___1.flags = 0U;
    tmp___4 = ldv__builtin_expect((long )descriptor___1.flags & 1L, 0L);
    if (tmp___4 != 0L) {
      tmp___3 = rtsx_dev((struct rtsx_chip  const  *)chip);
      __dynamic_dev_dbg(& descriptor___1, (struct device  const  *)tmp___3, "Get unused block fail, invalid get_index\n");
    } else {

    }
    return (4294967295U);
  } else {

  }
  descriptor___2.modname = "rts5208";
  descriptor___2.function = "xd_get_unused_block";
  descriptor___2.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/xd.c";
  descriptor___2.format = "Get unused block from index %d\n";
  descriptor___2.lineno = 977U;
  descriptor___2.flags = 0U;
  tmp___6 = ldv__builtin_expect((long )descriptor___2.flags & 1L, 0L);
  if (tmp___6 != 0L) {
    tmp___5 = rtsx_dev((struct rtsx_chip  const  *)chip);
    __dynamic_dev_dbg(& descriptor___2, (struct device  const  *)tmp___5, "Get unused block from index %d\n",
                      zone->get_index);
  } else {

  }
  phy_blk = (u32 )*(zone->free_table + (unsigned long )zone->get_index);
  tmp___7 = zone->get_index;
  zone->get_index = zone->get_index + 1;
  *(zone->free_table + (unsigned long )tmp___7) = 65535U;
  if (zone->get_index > 1199) {
    zone->get_index = 0;
  } else {

  }
  zone->unused_blk_cnt = zone->unused_blk_cnt - 1;
  phy_blk = ((unsigned int )zone_no << 10) + phy_blk;
  return (phy_blk);
}
}
static void xd_set_l2p_tbl(struct rtsx_chip *chip , int zone_no , u16 log_off , u16 phy_off ) 
{ 
  struct xd_info *xd_card ;
  struct zone_entry *zone ;

  {
  xd_card = & chip->xd_card;
  zone = xd_card->zone + (unsigned long )zone_no;
  *(zone->l2p_table + (unsigned long )log_off) = phy_off;
  return;
}
}
static u32 xd_get_l2p_tbl(struct rtsx_chip *chip , int zone_no , u16 log_off ) 
{ 
  struct xd_info *xd_card ;
  struct zone_entry *zone ;
  int retval ;
  u32 phy_blk ;
  int i ;
  struct _ddebug descriptor ;
  struct device *tmp ;
  long tmp___0 ;
  struct _ddebug descriptor___0 ;
  struct device *tmp___1 ;
  long tmp___2 ;
  struct _ddebug descriptor___1 ;
  struct device *tmp___3 ;
  long tmp___4 ;
  struct _ddebug descriptor___2 ;
  struct device *tmp___5 ;
  long tmp___6 ;

  {
  xd_card = & chip->xd_card;
  zone = xd_card->zone + (unsigned long )zone_no;
  if ((unsigned int )*(zone->l2p_table + (unsigned long )log_off) == 65535U) {
    phy_blk = 0U;
    retval = xd_delay_write(chip);
    if (retval != 0) {
      descriptor.modname = "rts5208";
      descriptor.function = "xd_get_l2p_tbl";
      descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/xd.c";
      descriptor.format = "In xd_get_l2p_tbl, delay write fail!\n";
      descriptor.lineno = 1013U;
      descriptor.flags = 0U;
      tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
      if (tmp___0 != 0L) {
        tmp = rtsx_dev((struct rtsx_chip  const  *)chip);
        __dynamic_dev_dbg(& descriptor, (struct device  const  *)tmp, "In xd_get_l2p_tbl, delay write fail!\n");
      } else {

      }
      return (4294967295U);
    } else {

    }
    if (zone->unused_blk_cnt <= 0) {
      descriptor___0.modname = "rts5208";
      descriptor___0.function = "xd_get_l2p_tbl";
      descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/xd.c";
      descriptor___0.format = "No unused block!\n";
      descriptor___0.lineno = 1019U;
      descriptor___0.flags = 0U;
      tmp___2 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
      if (tmp___2 != 0L) {
        tmp___1 = rtsx_dev((struct rtsx_chip  const  *)chip);
        __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)tmp___1, "No unused block!\n");
      } else {

      }
      return (4294967295U);
    } else {

    }
    i = 0;
    goto ldv_38615;
    ldv_38614: 
    phy_blk = xd_get_unused_block(chip, zone_no);
    if (phy_blk == 4294967295U) {
      descriptor___1.modname = "rts5208";
      descriptor___1.function = "xd_get_l2p_tbl";
      descriptor___1.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/xd.c";
      descriptor___1.format = "No unused block available!\n";
      descriptor___1.lineno = 1026U;
      descriptor___1.flags = 0U;
      tmp___4 = ldv__builtin_expect((long )descriptor___1.flags & 1L, 0L);
      if (tmp___4 != 0L) {
        tmp___3 = rtsx_dev((struct rtsx_chip  const  *)chip);
        __dynamic_dev_dbg(& descriptor___1, (struct device  const  *)tmp___3, "No unused block available!\n");
      } else {

      }
      return (4294967295U);
    } else {

    }
    retval = xd_init_page(chip, phy_blk, (int )log_off, 0, (int )((unsigned int )xd_card->page_off + 1U));
    if (retval == 0) {
      goto ldv_38613;
    } else {

    }
    i = i + 1;
    ldv_38615: ;
    if (zone->unused_blk_cnt > i) {
      goto ldv_38614;
    } else {

    }
    ldv_38613: ;
    if (zone->unused_blk_cnt <= i) {
      descriptor___2.modname = "rts5208";
      descriptor___2.function = "xd_get_l2p_tbl";
      descriptor___2.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/xd.c";
      descriptor___2.format = "No good unused block available!\n";
      descriptor___2.lineno = 1036U;
      descriptor___2.flags = 0U;
      tmp___6 = ldv__builtin_expect((long )descriptor___2.flags & 1L, 0L);
      if (tmp___6 != 0L) {
        tmp___5 = rtsx_dev((struct rtsx_chip  const  *)chip);
        __dynamic_dev_dbg(& descriptor___2, (struct device  const  *)tmp___5, "No good unused block available!\n");
      } else {

      }
      return (4294967295U);
    } else {

    }
    xd_set_l2p_tbl(chip, zone_no, (int )log_off, (int )((unsigned short )phy_blk) & 1023);
    return (phy_blk);
  } else {

  }
  return ((unsigned int )*(zone->l2p_table + (unsigned long )log_off) + ((unsigned int )zone_no << 10));
}
}
int reset_xd_card(struct rtsx_chip *chip ) 
{ 
  struct xd_info *xd_card ;
  int retval ;

  {
  xd_card = & chip->xd_card;
  memset((void *)xd_card, 0, 56UL);
  xd_card->block_shift = 0U;
  xd_card->page_off = 0U;
  xd_card->addr_cycle = 0U;
  xd_card->capacity = 0U;
  xd_card->zone_cnt = 0;
  xd_card->cis_block = 65535U;
  xd_card->delay_write.delay_write_flag = 0U;
  retval = enable_card_clock(chip, 16);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/xd.c",
                "reset_xd_card", 1064);
    return (1);
  } else {

  }
  retval = reset_xd(chip);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/xd.c",
                "reset_xd_card", 1070);
    return (1);
  } else {

  }
  retval = xd_init_l2p_tbl(chip);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/xd.c",
                "reset_xd_card", 1076);
    return (1);
  } else {

  }
  return (0);
}
}
static int xd_mark_bad_block(struct rtsx_chip *chip , u32 phy_blk ) 
{ 
  struct xd_info *xd_card ;
  int retval ;
  u32 page_addr ;
  u8 reg ;
  struct _ddebug descriptor ;
  struct device *tmp ;
  long tmp___0 ;

  {
  xd_card = & chip->xd_card;
  reg = 0U;
  descriptor.modname = "rts5208";
  descriptor.function = "xd_mark_bad_block";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/xd.c";
  descriptor.format = "mark block 0x%x as bad block\n";
  descriptor.lineno = 1090U;
  descriptor.flags = 0U;
  tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp___0 != 0L) {
    tmp = rtsx_dev((struct rtsx_chip  const  *)chip);
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)tmp, "mark block 0x%x as bad block\n",
                      phy_blk);
  } else {

  }
  if (phy_blk == 4294967295U) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/xd.c",
                "xd_mark_bad_block", 1093);
    return (1);
  } else {

  }
  chip->ci = 0;
  rtsx_add_cmd(chip, 1, 64796, 255, 255);
  rtsx_add_cmd(chip, 1, 64797, 255, 240);
  rtsx_add_cmd(chip, 1, 64799, 255, 255);
  rtsx_add_cmd(chip, 1, 64798, 255, 255);
  rtsx_add_cmd(chip, 1, 64801, 255, 255);
  rtsx_add_cmd(chip, 1, 64800, 255, 255);
  rtsx_add_cmd(chip, 1, 64809, 255, 255);
  rtsx_add_cmd(chip, 1, 64810, 255, 255);
  rtsx_add_cmd(chip, 1, 64811, 255, 255);
  rtsx_add_cmd(chip, 1, 64812, 255, 255);
  page_addr = phy_blk << (int )xd_card->block_shift;
  xd_assign_phy_addr(chip, page_addr, 1);
  rtsx_add_cmd(chip, 1, 64795, 255, (int )((unsigned int )xd_card->page_off + 1U));
  rtsx_add_cmd(chip, 1, 64787, 255, 138);
  rtsx_add_cmd(chip, 2, 64787, 64, 64);
  retval = rtsx_send_cmd(chip, 16, 500);
  if (retval < 0) {
    rtsx_clear_xd_error(chip);
    rtsx_read_register(chip, 64794, & reg);
    if ((int )reg & 1) {
      xd_set_err_code(chip, 64);
    } else {
      xd_set_err_code(chip, 1);
    }
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/xd.c",
                "xd_mark_bad_block", 1130);
    return (1);
  } else {

  }
  return (0);
}
}
static int xd_init_page(struct rtsx_chip *chip , u32 phy_blk , u16 logoff , u8 start_page ,
                        u8 end_page ) 
{ 
  struct xd_info *xd_card ;
  int retval ;
  u32 page_addr ;
  u8 reg ;
  struct _ddebug descriptor ;
  struct device *tmp ;
  long tmp___0 ;

  {
  xd_card = & chip->xd_card;
  reg = 0U;
  descriptor.modname = "rts5208";
  descriptor.function = "xd_init_page";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/xd.c";
  descriptor.format = "Init block 0x%x\n";
  descriptor.lineno = 1145U;
  descriptor.flags = 0U;
  tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp___0 != 0L) {
    tmp = rtsx_dev((struct rtsx_chip  const  *)chip);
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)tmp, "Init block 0x%x\n",
                      phy_blk);
  } else {

  }
  if ((int )start_page > (int )end_page) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/xd.c",
                "xd_init_page", 1148);
    return (1);
  } else {

  }
  if (phy_blk == 4294967295U) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/xd.c",
                "xd_init_page", 1152);
    return (1);
  } else {

  }
  chip->ci = 0;
  rtsx_add_cmd(chip, 1, 64796, 255, 255);
  rtsx_add_cmd(chip, 1, 64797, 255, 255);
  rtsx_add_cmd(chip, 1, 64799, 255, (int )((unsigned char )((int )logoff >> 8)));
  rtsx_add_cmd(chip, 1, 64798, 255, (int )((unsigned char )logoff));
  page_addr = (phy_blk << (int )xd_card->block_shift) + (u32 )start_page;
  xd_assign_phy_addr(chip, page_addr, 1);
  rtsx_add_cmd(chip, 1, 64788, 64, 64);
  rtsx_add_cmd(chip, 1, 64795, 255, (int )end_page - (int )start_page);
  rtsx_add_cmd(chip, 1, 64787, 255, 138);
  rtsx_add_cmd(chip, 2, 64787, 64, 64);
  retval = rtsx_send_cmd(chip, 16, 500);
  if (retval < 0) {
    rtsx_clear_xd_error(chip);
    rtsx_read_register(chip, 64794, & reg);
    if ((int )reg & 1) {
      xd_mark_bad_block(chip, phy_blk);
      xd_set_err_code(chip, 64);
    } else {
      xd_set_err_code(chip, 1);
    }
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/xd.c",
                "xd_init_page", 1189);
    return (1);
  } else {

  }
  return (0);
}
}
static int xd_copy_page(struct rtsx_chip *chip , u32 old_blk , u32 new_blk , u8 start_page ,
                        u8 end_page ) 
{ 
  struct xd_info *xd_card ;
  u32 old_page ;
  u32 new_page ;
  u8 i ;
  u8 reg ;
  int retval ;
  struct _ddebug descriptor ;
  struct device *tmp ;
  long tmp___0 ;
  int tmp___1 ;
  struct task_struct *tmp___2 ;
  long volatile   __ret ;
  struct task_struct *tmp___3 ;
  struct task_struct *tmp___4 ;
  struct task_struct *tmp___5 ;
  struct task_struct *tmp___6 ;
  int tmp___7 ;
  struct _ddebug descriptor___0 ;
  struct device *tmp___8 ;
  long tmp___9 ;

  {
  xd_card = & chip->xd_card;
  reg = 0U;
  descriptor.modname = "rts5208";
  descriptor.function = "xd_copy_page";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/xd.c";
  descriptor.format = "Copy page from block 0x%x to block 0x%x\n";
  descriptor.lineno = 1205U;
  descriptor.flags = 0U;
  tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp___0 != 0L) {
    tmp = rtsx_dev((struct rtsx_chip  const  *)chip);
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)tmp, "Copy page from block 0x%x to block 0x%x\n",
                      old_blk, new_blk);
  } else {

  }
  if ((int )start_page > (int )end_page) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/xd.c",
                "xd_copy_page", 1208);
    return (1);
  } else {

  }
  if (old_blk == 4294967295U || new_blk == 4294967295U) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/xd.c",
                "xd_copy_page", 1213);
    return (1);
  } else {

  }
  old_page = (old_blk << (int )xd_card->block_shift) + (u32 )start_page;
  new_page = (new_blk << (int )xd_card->block_shift) + (u32 )start_page;
  xd_card->multi_flag = (unsigned int )xd_card->multi_flag & 254U;
  retval = rtsx_write_register(chip, 64859, 1, 1);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/xd.c",
                "xd_copy_page", 1225);
    return (retval);
  } else {

  }
  i = start_page;
  goto ldv_38671;
  ldv_38670: 
  tmp___1 = detect_card_cd(chip, 16);
  if (tmp___1 != 0) {
    rtsx_clear_xd_error(chip);
    xd_set_err_code(chip, 32);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/xd.c",
                "xd_copy_page", 1233);
    return (1);
  } else {

  }
  chip->ci = 0;
  xd_assign_phy_addr(chip, old_page, 1);
  rtsx_add_cmd(chip, 1, 64795, 255, 1);
  rtsx_add_cmd(chip, 1, 64813, 1, 0);
  rtsx_add_cmd(chip, 1, 64787, 255, 133);
  rtsx_add_cmd(chip, 2, 64787, 64, 64);
  retval = rtsx_send_cmd(chip, 16, 500);
  if (retval < 0) {
    rtsx_clear_xd_error(chip);
    reg = 0U;
    rtsx_read_register(chip, 64786, & reg);
    if (((int )reg & 80) != 0) {
      tmp___2 = get_current();
      tmp___2->task_state_change = 0UL;
      __ret = 1L;
      switch (8UL) {
      case 1UL: 
      tmp___3 = get_current();
      __asm__  volatile   ("xchgb %b0, %1\n": "+q" (__ret), "+m" (tmp___3->state): : "memory",
                           "cc");
      goto ldv_38663;
      case 2UL: 
      tmp___4 = get_current();
      __asm__  volatile   ("xchgw %w0, %1\n": "+r" (__ret), "+m" (tmp___4->state): : "memory",
                           "cc");
      goto ldv_38663;
      case 4UL: 
      tmp___5 = get_current();
      __asm__  volatile   ("xchgl %0, %1\n": "+r" (__ret), "+m" (tmp___5->state): : "memory",
                           "cc");
      goto ldv_38663;
      case 8UL: 
      tmp___6 = get_current();
      __asm__  volatile   ("xchgq %q0, %1\n": "+r" (__ret), "+m" (tmp___6->state): : "memory",
                           "cc");
      goto ldv_38663;
      default: 
      __xchg_wrong_size();
      }
      ldv_38663: 
      schedule_timeout(25L);
      tmp___7 = detect_card_cd(chip, 16);
      if (tmp___7 != 0) {
        xd_set_err_code(chip, 32);
        _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/xd.c",
                    "xd_copy_page", 1260);
        return (1);
      } else {

      }
      if (((int )reg & 48) == 48 || ((int )reg & 192) == 192) {
        rtsx_write_register(chip, 64796, 255, 0);
        rtsx_write_register(chip, 64797, 255, 255);
        xd_card->multi_flag = (u8 )((unsigned int )xd_card->multi_flag | 2U);
        descriptor___0.modname = "rts5208";
        descriptor___0.function = "xd_copy_page";
        descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/xd.c";
        descriptor___0.format = "old block 0x%x ecc error\n";
        descriptor___0.lineno = 1276U;
        descriptor___0.flags = 0U;
        tmp___9 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
        if (tmp___9 != 0L) {
          tmp___8 = rtsx_dev((struct rtsx_chip  const  *)chip);
          __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)tmp___8, "old block 0x%x ecc error\n",
                            old_blk);
        } else {

        }
      } else {

      }
    } else {
      xd_set_err_code(chip, 1);
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/xd.c",
                  "xd_copy_page", 1280);
      return (1);
    }
  } else {

  }
  if (((int )xd_card->multi_flag & 2) != 0) {
    rtsx_clear_xd_error(chip);
  } else {

  }
  chip->ci = 0;
  xd_assign_phy_addr(chip, new_page, 1);
  rtsx_add_cmd(chip, 1, 64795, 255, 1);
  rtsx_add_cmd(chip, 1, 64787, 255, 136);
  rtsx_add_cmd(chip, 2, 64787, 64, 64);
  retval = rtsx_send_cmd(chip, 16, 300);
  if (retval < 0) {
    rtsx_clear_xd_error(chip);
    reg = 0U;
    rtsx_read_register(chip, 64794, & reg);
    if ((int )reg & 1) {
      xd_mark_bad_block(chip, new_blk);
      xd_set_err_code(chip, 64);
      xd_card->multi_flag = (u8 )((unsigned int )xd_card->multi_flag | 1U);
    } else {
      xd_set_err_code(chip, 1);
    }
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/xd.c",
                "xd_copy_page", 1309);
    return (1);
  } else {

  }
  old_page = old_page + 1U;
  new_page = new_page + 1U;
  i = (u8 )((int )i + 1);
  ldv_38671: ;
  if ((int )i < (int )end_page) {
    goto ldv_38670;
  } else {

  }

  return (0);
}
}
static int xd_reset_cmd(struct rtsx_chip *chip ) 
{ 
  int retval ;
  u8 *ptr ;
  u8 *tmp ;

  {
  chip->ci = 0;
  rtsx_add_cmd(chip, 1, 64787, 255, 128);
  rtsx_add_cmd(chip, 2, 64787, 64, 64);
  rtsx_add_cmd(chip, 0, 64794, 0, 0);
  rtsx_add_cmd(chip, 0, 64786, 0, 0);
  retval = rtsx_send_cmd(chip, 16, 100);
  if (retval < 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/xd.c",
                "xd_reset_cmd", 1336);
    return (1);
  } else {

  }
  tmp = rtsx_get_cmd_data(chip);
  ptr = tmp + 1UL;
  if (((int )*ptr & 95) == 64 && ((int )*(ptr + 1UL) & 4) != 0) {
    return (0);
  } else {

  }
  _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/xd.c",
              "xd_reset_cmd", 1344);
  return (1);
}
}
static int xd_erase_block(struct rtsx_chip *chip , u32 phy_blk ) 
{ 
  struct xd_info *xd_card ;
  u32 page_addr ;
  u8 reg ;
  u8 *ptr ;
  int i ;
  int retval ;
  u8 *tmp ;

  {
  xd_card = & chip->xd_card;
  reg = 0U;
  if (phy_blk == 4294967295U) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/xd.c",
                "xd_erase_block", 1356);
    return (1);
  } else {

  }
  page_addr = phy_blk << (int )xd_card->block_shift;
  i = 0;
  goto ldv_38692;
  ldv_38691: 
  chip->ci = 0;
  xd_assign_phy_addr(chip, page_addr, 2);
  rtsx_add_cmd(chip, 1, 64787, 255, 129);
  rtsx_add_cmd(chip, 2, 64787, 64, 64);
  rtsx_add_cmd(chip, 0, 64794, 0, 0);
  retval = rtsx_send_cmd(chip, 16, 250);
  if (retval < 0) {
    rtsx_clear_xd_error(chip);
    rtsx_read_register(chip, 64794, & reg);
    if ((int )reg & 1) {
      xd_mark_bad_block(chip, phy_blk);
      xd_set_err_code(chip, 64);
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/xd.c",
                  "xd_erase_block", 1380);
      return (1);
    } else {

    }
    xd_set_err_code(chip, 8);
    retval = xd_reset_cmd(chip);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/xd.c",
                  "xd_erase_block", 1386);
      return (1);
    } else {

    }
    goto ldv_38690;
  } else {

  }
  tmp = rtsx_get_cmd_data(chip);
  ptr = tmp + 1UL;
  if ((int )*ptr & 1) {
    xd_mark_bad_block(chip, phy_blk);
    xd_set_err_code(chip, 64);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/xd.c",
                "xd_erase_block", 1396);
    return (1);
  } else {

  }
  return (0);
  ldv_38690: 
  i = i + 1;
  ldv_38692: ;
  if (i <= 2) {
    goto ldv_38691;
  } else {

  }
  xd_mark_bad_block(chip, phy_blk);
  xd_set_err_code(chip, 8);
  _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/xd.c",
              "xd_erase_block", 1405);
  return (1);
}
}
static int xd_build_l2p_tbl(struct rtsx_chip *chip , int zone_no ) 
{ 
  struct xd_info *xd_card ;
  struct zone_entry *zone ;
  int retval ;
  u32 start ;
  u32 end ;
  u32 i ;
  u16 max_logoff ;
  u16 cur_fst_page_logoff ;
  u16 cur_lst_page_logoff ;
  u16 ent_lst_page_logoff ;
  u8 redunt[11U] ;
  struct _ddebug descriptor ;
  struct device *tmp ;
  long tmp___0 ;
  struct _ddebug descriptor___0 ;
  struct device *tmp___1 ;
  long tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  struct _ddebug descriptor___1 ;
  struct device *tmp___5 ;
  long tmp___6 ;
  int tmp___7 ;
  u32 page_addr ;
  u32 phy_block ;
  struct _ddebug descriptor___2 ;
  struct device *tmp___8 ;
  long tmp___9 ;
  struct _ddebug descriptor___3 ;
  struct device *tmp___10 ;
  long tmp___11 ;
  int tmp___12 ;
  int m ;
    klee_make_symbolic(&m, sizeof(int), "m");
  struct _ddebug descriptor___4 ;
  struct device *tmp___13 ;
  long tmp___14 ;
  struct _ddebug descriptor___5 ;
  struct device *tmp___15 ;
  long tmp___16 ;

  {
  xd_card = & chip->xd_card;
  descriptor.modname = "rts5208";
  descriptor.function = "xd_build_l2p_tbl";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/xd.c";
  descriptor.format = "xd_build_l2p_tbl: %d\n";
  descriptor.lineno = 1420U;
  descriptor.flags = 0U;
  tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp___0 != 0L) {
    tmp = rtsx_dev((struct rtsx_chip  const  *)chip);
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)tmp, "xd_build_l2p_tbl: %d\n",
                      zone_no);
  } else {

  }
  if ((unsigned long )xd_card->zone == (unsigned long )((struct zone_entry *)0)) {
    retval = xd_init_l2p_tbl(chip);
    if (retval != 0) {
      return (retval);
    } else {

    }
  } else {

  }
  if ((xd_card->zone + (unsigned long )zone_no)->build_flag != 0) {
    descriptor___0.modname = "rts5208";
    descriptor___0.function = "xd_build_l2p_tbl";
    descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/xd.c";
    descriptor___0.format = "l2p table of zone %d has been built\n";
    descriptor___0.lineno = 1430U;
    descriptor___0.flags = 0U;
    tmp___2 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
    if (tmp___2 != 0L) {
      tmp___1 = rtsx_dev((struct rtsx_chip  const  *)chip);
      __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)tmp___1, "l2p table of zone %d has been built\n",
                        zone_no);
    } else {

    }
    return (0);
  } else {

  }
  zone = xd_card->zone + (unsigned long )zone_no;
  if ((unsigned long )zone->l2p_table == (unsigned long )((u16 *)0U)) {
    tmp___3 = vmalloc(2000UL);
    zone->l2p_table = (u16 *)tmp___3;
    if ((unsigned long )zone->l2p_table == (unsigned long )((u16 *)0U)) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/xd.c",
                  "xd_build_l2p_tbl", 1439);
      goto Build_Fail;
    } else {

    }
  } else {

  }
  memset((void *)zone->l2p_table, 255, 2000UL);
  if ((unsigned long )zone->free_table == (unsigned long )((u16 *)0U)) {
    tmp___4 = vmalloc(2400UL);
    zone->free_table = (u16 *)tmp___4;
    if ((unsigned long )zone->free_table == (unsigned long )((u16 *)0U)) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/xd.c",
                  "xd_build_l2p_tbl", 1448);
      goto Build_Fail;
    } else {

    }
  } else {

  }
  memset((void *)zone->free_table, 255, 2400UL);
  if (zone_no == 0) {
    if ((unsigned int )xd_card->cis_block == 65535U) {
      start = 0U;
    } else {
      start = (u32 )((int )xd_card->cis_block + 1);
    }
    if (((int )xd_card->multi_flag & 16) != 0) {
      end = 512U;
      max_logoff = 499U;
    } else {
      end = 1024U;
      max_logoff = 999U;
    }
  } else {
    start = (unsigned int )zone_no << 10;
    end = (unsigned int )(zone_no + 1) << 10;
    max_logoff = 999U;
  }
  descriptor___1.modname = "rts5208";
  descriptor___1.function = "xd_build_l2p_tbl";
  descriptor___1.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/xd.c";
  descriptor___1.format = "start block 0x%x, end block 0x%x\n";
  descriptor___1.lineno = 1473U;
  descriptor___1.flags = 0U;
  tmp___6 = ldv__builtin_expect((long )descriptor___1.flags & 1L, 0L);
  if (tmp___6 != 0L) {
    tmp___5 = rtsx_dev((struct rtsx_chip  const  *)chip);
    __dynamic_dev_dbg(& descriptor___1, (struct device  const  *)tmp___5, "start block 0x%x, end block 0x%x\n",
                      start, end);
  } else {

  }
  tmp___7 = 0;
  zone->get_index = tmp___7;
  zone->set_index = tmp___7;
  zone->unused_blk_cnt = 0;
  i = start;
  goto ldv_38724;
  ldv_38723: 
  page_addr = i << (int )xd_card->block_shift;
  retval = xd_read_redundant(chip, page_addr, (u8 *)(& redunt), 11);
  if (retval != 0) {
    goto ldv_38716;
  } else {

  }
  if ((unsigned int )redunt[1] != 255U) {
    descriptor___2.modname = "rts5208";
    descriptor___2.function = "xd_build_l2p_tbl";
    descriptor___2.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/xd.c";
    descriptor___2.format = "bad block\n";
    descriptor___2.lineno = 1487U;
    descriptor___2.flags = 0U;
    tmp___9 = ldv__builtin_expect((long )descriptor___2.flags & 1L, 0L);
    if (tmp___9 != 0L) {
      tmp___8 = rtsx_dev((struct rtsx_chip  const  *)chip);
      __dynamic_dev_dbg(& descriptor___2, (struct device  const  *)tmp___8, "bad block\n");
    } else {

    }
    goto ldv_38716;
  } else {

  }
  tmp___12 = xd_check_data_blank((u8 *)(& redunt));
  if (tmp___12 != 0) {
    descriptor___3.modname = "rts5208";
    descriptor___3.function = "xd_build_l2p_tbl";
    descriptor___3.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/xd.c";
    descriptor___3.format = "blank block\n";
    descriptor___3.lineno = 1492U;
    descriptor___3.flags = 0U;
    tmp___11 = ldv__builtin_expect((long )descriptor___3.flags & 1L, 0L);
    if (tmp___11 != 0L) {
      tmp___10 = rtsx_dev((struct rtsx_chip  const  *)chip);
      __dynamic_dev_dbg(& descriptor___3, (struct device  const  *)tmp___10, "blank block\n");
    } else {

    }
    xd_set_unused_block(chip, i);
    goto ldv_38716;
  } else {

  }
  cur_fst_page_logoff = xd_load_log_block_addr((u8 *)(& redunt));
  if ((unsigned int )cur_fst_page_logoff == 65535U || (int )cur_fst_page_logoff > (int )max_logoff) {
    retval = xd_erase_block(chip, i);
    if (retval == 0) {
      xd_set_unused_block(chip, i);
    } else {

    }
    goto ldv_38716;
  } else {

  }
  if ((zone_no == 0 && (unsigned int )cur_fst_page_logoff == 0U) && (unsigned int )redunt[0] != 255U) {
    xd_card->multi_flag = (u8 )((unsigned int )xd_card->multi_flag | 4U);
  } else {

  }
  if ((unsigned int )*(zone->l2p_table + (unsigned long )cur_fst_page_logoff) == 65535U) {
    *(zone->l2p_table + (unsigned long )cur_fst_page_logoff) = (unsigned int )((unsigned short )i) & 1023U;
    goto ldv_38716;
  } else {

  }
  phy_block = (unsigned int )*(zone->l2p_table + (unsigned long )cur_fst_page_logoff) + (unsigned int )(zone_no << 10);
  page_addr = ((i + 1U) << (int )xd_card->block_shift) - 1U;
  retval = xd_read_redundant(chip, page_addr, (u8 *)(& redunt), 11);
  if (retval != 0) {
    goto ldv_38716;
  } else {

  }
  cur_lst_page_logoff = xd_load_log_block_addr((u8 *)(& redunt));
  if ((int )cur_lst_page_logoff == (int )cur_fst_page_logoff) {
    page_addr = ((phy_block + 1U) << (int )xd_card->block_shift) - 1U;
    m = 0;
    goto ldv_38722;
    ldv_38721: 
    retval = xd_read_redundant(chip, page_addr, (u8 *)(& redunt), 11);
    if (retval == 0) {
      goto ldv_38720;
    } else {

    }
    m = m + 1;
    ldv_38722: ;
    if (m <= 2) {
      goto ldv_38721;
    } else {

    }
    ldv_38720: ;
    if (m == 3) {
      *(zone->l2p_table + (unsigned long )cur_fst_page_logoff) = (unsigned int )((unsigned short )i) & 1023U;
      retval = xd_erase_block(chip, phy_block);
      if (retval == 0) {
        xd_set_unused_block(chip, phy_block);
      } else {

      }
      goto ldv_38716;
    } else {

    }
    ent_lst_page_logoff = xd_load_log_block_addr((u8 *)(& redunt));
    if ((int )ent_lst_page_logoff != (int )cur_fst_page_logoff) {
      *(zone->l2p_table + (unsigned long )cur_fst_page_logoff) = (unsigned int )((unsigned short )i) & 1023U;
      retval = xd_erase_block(chip, phy_block);
      if (retval == 0) {
        xd_set_unused_block(chip, phy_block);
      } else {

      }
      goto ldv_38716;
    } else {
      retval = xd_erase_block(chip, i);
      if (retval == 0) {
        xd_set_unused_block(chip, i);
      } else {

      }
    }
  } else {
    retval = xd_erase_block(chip, i);
    if (retval == 0) {
      xd_set_unused_block(chip, i);
    } else {

    }
  }
  ldv_38716: 
  i = i + 1U;
  ldv_38724: ;
  if (i < end) {
    goto ldv_38723;
  } else {

  }

  if (((int )xd_card->multi_flag & 16) != 0) {
    end = 500U;
  } else {
    end = 1000U;
  }
  i = 0U;
  start = 0U;
  goto ldv_38727;
  ldv_38726: ;
  if ((unsigned int )*(zone->l2p_table + (unsigned long )start) == 65535U) {
    i = i + 1U;
  } else {

  }
  start = start + 1U;
  ldv_38727: ;
  if (start < end) {
    goto ldv_38726;
  } else {

  }
  descriptor___4.modname = "rts5208";
  descriptor___4.function = "xd_build_l2p_tbl";
  descriptor___4.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/xd.c";
  descriptor___4.format = "Block count %d, invalid L2P entry %d\n";
  descriptor___4.lineno = 1579U;
  descriptor___4.flags = 0U;
  tmp___14 = ldv__builtin_expect((long )descriptor___4.flags & 1L, 0L);
  if (tmp___14 != 0L) {
    tmp___13 = rtsx_dev((struct rtsx_chip  const  *)chip);
    __dynamic_dev_dbg(& descriptor___4, (struct device  const  *)tmp___13, "Block count %d, invalid L2P entry %d\n",
                      end, i);
  } else {

  }
  descriptor___5.modname = "rts5208";
  descriptor___5.function = "xd_build_l2p_tbl";
  descriptor___5.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/xd.c";
  descriptor___5.format = "Total unused block: %d\n";
  descriptor___5.lineno = 1581U;
  descriptor___5.flags = 0U;
  tmp___16 = ldv__builtin_expect((long )descriptor___5.flags & 1L, 0L);
  if (tmp___16 != 0L) {
    tmp___15 = rtsx_dev((struct rtsx_chip  const  *)chip);
    __dynamic_dev_dbg(& descriptor___5, (struct device  const  *)tmp___15, "Total unused block: %d\n",
                      zone->unused_blk_cnt);
  } else {

  }
  if ((u32 )zone->unused_blk_cnt == i) {
    chip->card_wp = (u8 )((unsigned int )chip->card_wp | 16U);
  } else {

  }
  zone->build_flag = 1;
  return (0);
  Build_Fail: ;
  if ((unsigned long )zone->l2p_table != (unsigned long )((u16 *)0U)) {
    vfree((void const   *)zone->l2p_table);
    zone->l2p_table = (u16 *)0U;
  } else {

  }
  if ((unsigned long )zone->free_table != (unsigned long )((u16 *)0U)) {
    vfree((void const   *)zone->free_table);
    zone->free_table = (u16 *)0U;
  } else {

  }
  return (1);
}
}
static int xd_send_cmd(struct rtsx_chip *chip , u8 cmd ) 
{ 
  int retval ;

  {
  chip->ci = 0;
  rtsx_add_cmd(chip, 1, 64794, 255, (int )cmd);
  rtsx_add_cmd(chip, 1, 64787, 255, 134);
  rtsx_add_cmd(chip, 2, 64787, 64, 64);
  retval = rtsx_send_cmd(chip, 16, 200);
  if (retval < 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/xd.c",
                "xd_send_cmd", 1617);
    return (1);
  } else {

  }
  return (0);
}
}
static int xd_read_multiple_pages(struct rtsx_chip *chip , u32 phy_blk , u32 log_blk ,
                                  u8 start_page , u8 end_page , u8 *buf , unsigned int *index ,
                                  unsigned int *offset ) 
{ 
  struct xd_info *xd_card ;
  u32 page_addr ;
  u32 new_blk ;
  u16 log_off ;
  u8 reg_val ;
  u8 page_cnt ;
  int zone_no ;
  int retval ;
  int i ;
  int tmp ;
  unsigned int tmp___0 ;
  struct task_struct *tmp___1 ;
  long volatile   __ret ;
  struct task_struct *tmp___2 ;
  struct task_struct *tmp___3 ;
  struct task_struct *tmp___4 ;
  struct task_struct *tmp___5 ;
  int tmp___6 ;

  {
  xd_card = & chip->xd_card;
  if ((int )start_page > (int )end_page) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/xd.c",
                "xd_read_multiple_pages", 1636);
    return (1);
  } else {

  }
  page_cnt = (int )end_page - (int )start_page;
  zone_no = (int )(log_blk / 1000U);
  log_off = (unsigned short )(log_blk % 1000U);
  if ((phy_blk & 1023U) == 1023U) {
    i = 0;
    goto ldv_38759;
    ldv_38758: 
    page_addr = (unsigned int )i << (int )xd_card->block_shift;
    retval = xd_read_redundant(chip, page_addr, (u8 *)0U, 0);
    if (retval == 0) {
      goto ldv_38757;
    } else {

    }
    tmp = detect_card_cd(chip, 16);
    if (tmp != 0) {
      xd_set_err_code(chip, 32);
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/xd.c",
                  "xd_read_multiple_pages", 1654);
      return (1);
    } else {

    }
    i = i + 1;
    ldv_38759: ;
    if (i <= 255) {
      goto ldv_38758;
    } else {

    }
    ldv_38757: ;
  } else {

  }
  page_addr = (phy_blk << (int )xd_card->block_shift) + (u32 )start_page;
  chip->ci = 0;
  xd_assign_phy_addr(chip, page_addr, 1);
  rtsx_add_cmd(chip, 1, 64788, 128, 128);
  rtsx_add_cmd(chip, 1, 64859, 1, 0);
  rtsx_add_cmd(chip, 1, 64795, 255, (int )page_cnt);
  rtsx_add_cmd(chip, 1, 64813, 1, 1);
  trans_dma_enable((chip->srb)->sc_data_direction, chip, (u32 )((int )page_cnt * 512),
                   32);
  rtsx_add_cmd(chip, 1, 64787, 255, 133);
  rtsx_add_cmd(chip, 2, 64787, 96, 96);
  rtsx_send_cmd_no_wait(chip);
  tmp___0 = scsi_sg_count(chip->srb);
  retval = rtsx_transfer_data_partial(chip, 16, (void *)buf, (size_t )((int )page_cnt * 512),
                                      (int )tmp___0, index, offset, 2, chip->xd_timeout);
  if (retval < 0) {
    rtsx_clear_xd_error(chip);
    if (retval == -110) {
      xd_set_err_code(chip, 1);
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/xd.c",
                  "xd_read_multiple_pages", 1690);
      return (1);
    } else {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/xd.c",
                  "xd_read_multiple_pages", 1693);
      goto Fail;
    }
  } else {

  }
  return (0);
  Fail: 
  retval = rtsx_read_register(chip, 64796, & reg_val);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/xd.c",
                "xd_read_multiple_pages", 1703);
    return (retval);
  } else {

  }
  if ((unsigned int )reg_val != 255U) {
    xd_set_err_code(chip, 64);
  } else {

  }
  retval = rtsx_read_register(chip, 64786, & reg_val);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/xd.c",
                "xd_read_multiple_pages", 1712);
    return (retval);
  } else {

  }
  if (((int )reg_val & 48) == 48 || ((int )reg_val & 192) == 192) {
    tmp___1 = get_current();
    tmp___1->task_state_change = 0UL;
    __ret = 1L;
    switch (8UL) {
    case 1UL: 
    tmp___2 = get_current();
    __asm__  volatile   ("xchgb %b0, %1\n": "+q" (__ret), "+m" (tmp___2->state): : "memory",
                         "cc");
    goto ldv_38763;
    case 2UL: 
    tmp___3 = get_current();
    __asm__  volatile   ("xchgw %w0, %1\n": "+r" (__ret), "+m" (tmp___3->state): : "memory",
                         "cc");
    goto ldv_38763;
    case 4UL: 
    tmp___4 = get_current();
    __asm__  volatile   ("xchgl %0, %1\n": "+r" (__ret), "+m" (tmp___4->state): : "memory",
                         "cc");
    goto ldv_38763;
    case 8UL: 
    tmp___5 = get_current();
    __asm__  volatile   ("xchgq %q0, %1\n": "+r" (__ret), "+m" (tmp___5->state): : "memory",
                         "cc");
    goto ldv_38763;
    default: 
    __xchg_wrong_size();
    }
    ldv_38763: 
    schedule_timeout(25L);
    tmp___6 = detect_card_cd(chip, 16);
    if (tmp___6 != 0) {
      xd_set_err_code(chip, 32);
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/xd.c",
                  "xd_read_multiple_pages", 1724);
      return (1);
    } else {

    }
    xd_set_err_code(chip, 2);
    new_blk = xd_get_unused_block(chip, zone_no);
    if (new_blk == 4294967295U) {
      xd_card->multi_flag = (unsigned int )xd_card->multi_flag & 253U;
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/xd.c",
                  "xd_read_multiple_pages", 1733);
      return (1);
    } else {

    }
    retval = xd_copy_page(chip, phy_blk, new_blk, 0, (int )((unsigned int )xd_card->page_off + 1U));
    if (retval != 0) {
      if (((int )xd_card->multi_flag & 1) == 0) {
        retval = xd_erase_block(chip, new_blk);
        if (retval == 0) {
          xd_set_unused_block(chip, new_blk);
        } else {

        }
      } else {
        xd_card->multi_flag = (unsigned int )xd_card->multi_flag & 254U;
      }
      xd_card->multi_flag = (unsigned int )xd_card->multi_flag & 253U;
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/xd.c",
                  "xd_read_multiple_pages", 1748);
      return (1);
    } else {

    }
    xd_set_l2p_tbl(chip, zone_no, (int )log_off, (int )((unsigned short )new_blk) & 1023);
    xd_erase_block(chip, phy_blk);
    xd_mark_bad_block(chip, phy_blk);
    xd_card->multi_flag = (unsigned int )xd_card->multi_flag & 253U;
  } else {

  }
  _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/xd.c",
              "xd_read_multiple_pages", 1757);
  return (1);
}
}
static int xd_finish_write(struct rtsx_chip *chip , u32 old_blk , u32 new_blk , u32 log_blk ,
                           u8 page_off ) 
{ 
  struct xd_info *xd_card ;
  int retval ;
  int zone_no ;
  u16 log_off ;
  struct _ddebug descriptor ;
  struct device *tmp ;
  long tmp___0 ;

  {
  xd_card = & chip->xd_card;
  descriptor.modname = "rts5208";
  descriptor.function = "xd_finish_write";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/xd.c";
  descriptor.format = "xd_finish_write, old_blk = 0x%x, new_blk = 0x%x, log_blk = 0x%x\n";
  descriptor.lineno = 1769U;
  descriptor.flags = 0U;
  tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp___0 != 0L) {
    tmp = rtsx_dev((struct rtsx_chip  const  *)chip);
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)tmp, "xd_finish_write, old_blk = 0x%x, new_blk = 0x%x, log_blk = 0x%x\n",
                      old_blk, new_blk, log_blk);
  } else {

  }
  if ((int )xd_card->page_off < (int )page_off) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/xd.c",
                "xd_finish_write", 1772);
    return (1);
  } else {

  }
  zone_no = (int )(log_blk / 1000U);
  log_off = (unsigned short )(log_blk % 1000U);
  if (old_blk == 4294967295U) {
    retval = xd_init_page(chip, new_blk, (int )log_off, (int )page_off, (int )((unsigned int )xd_card->page_off + 1U));
    if (retval != 0) {
      retval = xd_erase_block(chip, new_blk);
      if (retval == 0) {
        xd_set_unused_block(chip, new_blk);
      } else {

      }
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/xd.c",
                  "xd_finish_write", 1786);
      return (1);
    } else {

    }
  } else {
    retval = xd_copy_page(chip, old_blk, new_blk, (int )page_off, (int )((unsigned int )xd_card->page_off + 1U));
    if (retval != 0) {
      if (((int )xd_card->multi_flag & 1) == 0) {
        retval = xd_erase_block(chip, new_blk);
        if (retval == 0) {
          xd_set_unused_block(chip, new_blk);
        } else {

        }
      } else {

      }
      xd_card->multi_flag = (unsigned int )xd_card->multi_flag & 254U;
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/xd.c",
                  "xd_finish_write", 1799);
      return (1);
    } else {

    }
    retval = xd_erase_block(chip, old_blk);
    if (retval == 0) {
      if (((int )xd_card->multi_flag & 2) != 0) {
        xd_mark_bad_block(chip, old_blk);
        xd_card->multi_flag = (unsigned int )xd_card->multi_flag & 253U;
      } else {
        xd_set_unused_block(chip, old_blk);
      }
    } else {
      xd_set_err_code(chip, 0);
      xd_card->multi_flag = (unsigned int )xd_card->multi_flag & 253U;
    }
  }
  xd_set_l2p_tbl(chip, zone_no, (int )log_off, (int )((unsigned short )new_blk) & 1023);
  return (0);
}
}
static int xd_prepare_write(struct rtsx_chip *chip , u32 old_blk , u32 new_blk , u32 log_blk ,
                            u8 page_off ) 
{ 
  int retval ;
  struct _ddebug descriptor ;
  struct device *tmp ;
  long tmp___0 ;

  {
  descriptor.modname = "rts5208";
  descriptor.function = "xd_prepare_write";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/xd.c";
  descriptor.format = "%s, old_blk = 0x%x, new_blk = 0x%x, log_blk = 0x%x, page_off = %d\n";
  descriptor.lineno = 1828U;
  descriptor.flags = 0U;
  tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp___0 != 0L) {
    tmp = rtsx_dev((struct rtsx_chip  const  *)chip);
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)tmp, "%s, old_blk = 0x%x, new_blk = 0x%x, log_blk = 0x%x, page_off = %d\n",
                      "xd_prepare_write", old_blk, new_blk, log_blk, (int )page_off);
  } else {

  }
  if ((unsigned int )page_off != 0U) {
    retval = xd_copy_page(chip, old_blk, new_blk, 0, (int )page_off);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/xd.c",
                  "xd_prepare_write", 1833);
      return (1);
    } else {

    }
  } else {

  }
  return (0);
}
}
static int xd_write_multiple_pages(struct rtsx_chip *chip , u32 old_blk , u32 new_blk ,
                                   u32 log_blk , u8 start_page , u8 end_page , u8 *buf ,
                                   unsigned int *index , unsigned int *offset ) 
{ 
  struct xd_info *xd_card ;
  u32 page_addr ;
  int zone_no ;
  int retval ;
  u16 log_off ;
  u8 page_cnt ;
  u8 reg_val ;
  struct _ddebug descriptor ;
  struct device *tmp ;
  long tmp___0 ;
  unsigned int tmp___1 ;

  {
  xd_card = & chip->xd_card;
  descriptor.modname = "rts5208";
  descriptor.function = "xd_write_multiple_pages";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/xd.c";
  descriptor.format = "%s, old_blk = 0x%x, new_blk = 0x%x, log_blk = 0x%x\n";
  descriptor.lineno = 1854U;
  descriptor.flags = 0U;
  tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp___0 != 0L) {
    tmp = rtsx_dev((struct rtsx_chip  const  *)chip);
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)tmp, "%s, old_blk = 0x%x, new_blk = 0x%x, log_blk = 0x%x\n",
                      "xd_write_multiple_pages", old_blk, new_blk, log_blk);
  } else {

  }
  if ((int )start_page > (int )end_page) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/xd.c",
                "xd_write_multiple_pages", 1857);
    return (1);
  } else {

  }
  page_cnt = (int )end_page - (int )start_page;
  zone_no = (int )(log_blk / 1000U);
  log_off = (unsigned short )(log_blk % 1000U);
  page_addr = (new_blk << (int )xd_card->block_shift) + (u32 )start_page;
  retval = xd_send_cmd(chip, 0);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/xd.c",
                "xd_write_multiple_pages", 1869);
    return (1);
  } else {

  }
  chip->ci = 0;
  rtsx_add_cmd(chip, 1, 64799, 255, (int )((unsigned char )((int )log_off >> 8)));
  rtsx_add_cmd(chip, 1, 64798, 255, (int )((unsigned char )log_off));
  rtsx_add_cmd(chip, 1, 64797, 255, 255);
  rtsx_add_cmd(chip, 1, 64796, 255, 255);
  xd_assign_phy_addr(chip, page_addr, 1);
  rtsx_add_cmd(chip, 1, 64788, 64, 64);
  rtsx_add_cmd(chip, 1, 64795, 255, (int )page_cnt);
  rtsx_add_cmd(chip, 1, 64859, 1, 0);
  trans_dma_enable((chip->srb)->sc_data_direction, chip, (u32 )((int )page_cnt * 512),
                   32);
  rtsx_add_cmd(chip, 1, 64787, 255, 136);
  rtsx_add_cmd(chip, 2, 64787, 64, 64);
  rtsx_send_cmd_no_wait(chip);
  tmp___1 = scsi_sg_count(chip->srb);
  retval = rtsx_transfer_data_partial(chip, 16, (void *)buf, (size_t )((int )page_cnt * 512),
                                      (int )tmp___1, index, offset, 1, chip->xd_timeout);
  if (retval < 0) {
    rtsx_clear_xd_error(chip);
    if (retval == -110) {
      xd_set_err_code(chip, 1);
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/xd.c",
                  "xd_write_multiple_pages", 1906);
      return (1);
    } else {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/xd.c",
                  "xd_write_multiple_pages", 1909);
      goto Fail;
    }
  } else {

  }
  if ((int )end_page == (int )xd_card->page_off + 1) {
    xd_card->delay_write.delay_write_flag = 0U;
    if (old_blk != 4294967295U) {
      retval = xd_erase_block(chip, old_blk);
      if (retval == 0) {
        if (((int )xd_card->multi_flag & 2) != 0) {
          xd_mark_bad_block(chip, old_blk);
          xd_card->multi_flag = (unsigned int )xd_card->multi_flag & 253U;
        } else {
          xd_set_unused_block(chip, old_blk);
        }
      } else {
        xd_set_err_code(chip, 0);
        xd_card->multi_flag = (unsigned int )xd_card->multi_flag & 253U;
      }
    } else {

    }
    xd_set_l2p_tbl(chip, zone_no, (int )log_off, (int )((unsigned short )new_blk) & 1023);
  } else {

  }
  return (0);
  Fail: 
  retval = rtsx_read_register(chip, 64794, & reg_val);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/xd.c",
                "xd_write_multiple_pages", 1939);
    return (retval);
  } else {

  }
  if ((int )reg_val & 1) {
    xd_set_err_code(chip, 64);
    xd_mark_bad_block(chip, new_blk);
  } else {

  }
  _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/xd.c",
              "xd_write_multiple_pages", 1947);
  return (1);
}
}
int xd_delay_write(struct rtsx_chip *chip ) 
{ 
  struct xd_info *xd_card ;
  struct xd_delay_write_tag *delay_write ;
  int retval ;
  struct _ddebug descriptor ;
  struct device *tmp ;
  long tmp___0 ;

  {
  xd_card = & chip->xd_card;
  delay_write = & xd_card->delay_write;
  if ((unsigned int )delay_write->delay_write_flag != 0U) {
    descriptor.modname = "rts5208";
    descriptor.function = "xd_delay_write";
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/xd.c";
    descriptor.format = "xd_delay_write\n";
    descriptor.lineno = 1959U;
    descriptor.flags = 0U;
    tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
    if (tmp___0 != 0L) {
      tmp = rtsx_dev((struct rtsx_chip  const  *)chip);
      __dynamic_dev_dbg(& descriptor, (struct device  const  *)tmp, "xd_delay_write\n");
    } else {

    }
    retval = xd_switch_clock(chip);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/xd.c",
                  "xd_delay_write", 1962);
      return (1);
    } else {

    }
    delay_write->delay_write_flag = 0U;
    retval = xd_finish_write(chip, delay_write->old_phyblock, delay_write->new_phyblock,
                             delay_write->logblock, (int )delay_write->pageoff);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/xd.c",
                  "xd_delay_write", 1972);
      return (1);
    } else {

    }
  } else {

  }
  return (0);
}
}
int xd_rw(struct scsi_cmnd *srb , struct rtsx_chip *chip , u32 start_sector , u16 sector_cnt ) 
{ 
  struct xd_info *xd_card ;
  unsigned int lun ;
  struct xd_delay_write_tag *delay_write ;
  int retval ;
  int zone_no ;
  unsigned int index ;
  unsigned int offset ;
  u32 log_blk ;
  u32 old_blk ;
  u32 new_blk ;
  u16 log_off ;
  u16 total_sec_cnt ;
  u8 start_page ;
  u8 end_page ;
  u8 page_cnt ;
  u8 *ptr ;
  struct _ddebug descriptor ;
  unsigned int tmp ;
  struct device *tmp___0 ;
  long tmp___1 ;
  struct scatterlist *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  struct _ddebug descriptor___0 ;
  struct device *tmp___6 ;
  long tmp___7 ;
  int tmp___8 ;
  unsigned int tmp___9 ;

  {
  xd_card = & chip->xd_card;
  lun = (unsigned int )(srb->device)->lun;
  delay_write = & xd_card->delay_write;
  index = 0U;
  offset = 0U;
  old_blk = 0U;
  new_blk = 0U;
  total_sec_cnt = sector_cnt;
  end_page = 0U;
  xd_set_err_code(chip, 0);
  xd_card->cleanup_counter = 0;
  descriptor.modname = "rts5208";
  descriptor.function = "xd_rw";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/xd.c";
  descriptor.format = "xd_rw: scsi_sg_count = %d\n";
  descriptor.lineno = 2001U;
  descriptor.flags = 0U;
  tmp___1 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp___1 != 0L) {
    tmp = scsi_sg_count(srb);
    tmp___0 = rtsx_dev((struct rtsx_chip  const  *)chip);
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)tmp___0, "xd_rw: scsi_sg_count = %d\n",
                      tmp);
  } else {

  }
  tmp___2 = scsi_sglist(srb);
  ptr = (u8 *)tmp___2;
  retval = xd_switch_clock(chip);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/xd.c",
                "xd_rw", 2007);
    return (1);
  } else {

  }
  tmp___3 = detect_card_cd(chip, 16);
  if (tmp___3 != 0) {
    chip->card_fail = (u8 )((unsigned int )chip->card_fail | 16U);
    set_sense_type(chip, lun, 2);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/xd.c",
                "xd_rw", 2015);
    return (1);
  } else {

  }
  log_blk = start_sector >> (int )xd_card->block_shift;
  start_page = (u8 )((int )((unsigned char )start_sector) & (int )xd_card->page_off);
  zone_no = (int )(log_blk / 1000U);
  log_off = (unsigned short )(log_blk % 1000U);
  if ((xd_card->zone + (unsigned long )zone_no)->build_flag == 0) {
    retval = xd_build_l2p_tbl(chip, zone_no);
    if (retval != 0) {
      chip->card_fail = (u8 )((unsigned int )chip->card_fail | 16U);
      set_sense_type(chip, lun, 2);
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/xd.c",
                  "xd_rw", 2029);
      return (1);
    } else {

    }
  } else {

  }
  if ((unsigned int )srb->sc_data_direction == 1U) {
    if (((unsigned int )delay_write->delay_write_flag != 0U && delay_write->logblock == log_blk) && (int )delay_write->pageoff < (int )start_page) {
      delay_write->delay_write_flag = 0U;
      if (delay_write->old_phyblock != 4294967295U) {
        retval = xd_copy_page(chip, delay_write->old_phyblock, delay_write->new_phyblock,
                              (int )delay_write->pageoff, (int )start_page);
        if (retval != 0) {
          set_sense_type(chip, lun, 8);
          _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/xd.c",
                      "xd_rw", 2048);
          return (1);
        } else {

        }
      } else {

      }
      old_blk = delay_write->old_phyblock;
      new_blk = delay_write->new_phyblock;
    } else
    if (((unsigned int )delay_write->delay_write_flag != 0U && delay_write->logblock == log_blk) && (int )delay_write->pageoff == (int )start_page) {
      delay_write->delay_write_flag = 0U;
      old_blk = delay_write->old_phyblock;
      new_blk = delay_write->new_phyblock;
    } else {
      retval = xd_delay_write(chip);
      if (retval != 0) {
        set_sense_type(chip, lun, 8);
        _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/xd.c",
                    "xd_rw", 2065);
        return (1);
      } else {

      }
      old_blk = xd_get_l2p_tbl(chip, zone_no, (int )log_off);
      new_blk = xd_get_unused_block(chip, zone_no);
      if (old_blk == 4294967295U || new_blk == 4294967295U) {
        set_sense_type(chip, lun, 8);
        _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/xd.c",
                    "xd_rw", 2075);
        return (1);
      } else {

      }
      retval = xd_prepare_write(chip, old_blk, new_blk, log_blk, (int )start_page);
      if (retval != 0) {
        tmp___4 = detect_card_cd(chip, 16);
        if (tmp___4 != 0) {
          set_sense_type(chip, lun, 2);
          _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/xd.c",
                      "xd_rw", 2086);
          return (1);
        } else {

        }
        set_sense_type(chip, lun, 8);
        _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/xd.c",
                    "xd_rw", 2091);
        return (1);
      } else {

      }
    }
  } else {
    retval = xd_delay_write(chip);
    if (retval != 0) {
      tmp___5 = detect_card_cd(chip, 16);
      if (tmp___5 != 0) {
        set_sense_type(chip, lun, 2);
        _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/xd.c",
                    "xd_rw", 2104);
        return (1);
      } else {

      }
      set_sense_type(chip, lun, 7);
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/xd.c",
                  "xd_rw", 2109);
      return (1);
    } else {

    }
    old_blk = xd_get_l2p_tbl(chip, zone_no, (int )log_off);
    if (old_blk == 4294967295U) {
      set_sense_type(chip, lun, 7);
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/xd.c",
                  "xd_rw", 2118);
      return (1);
    } else {

    }
  }
  descriptor___0.modname = "rts5208";
  descriptor___0.function = "xd_rw";
  descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/xd.c";
  descriptor___0.format = "old_blk = 0x%x\n";
  descriptor___0.lineno = 2123U;
  descriptor___0.flags = 0U;
  tmp___7 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
  if (tmp___7 != 0L) {
    tmp___6 = rtsx_dev((struct rtsx_chip  const  *)chip);
    __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)tmp___6, "old_blk = 0x%x\n",
                      old_blk);
  } else {

  }
  goto ldv_38848;
  ldv_38847: 
  tmp___8 = detect_card_cd(chip, 16);
  if (tmp___8 != 0) {
    chip->card_fail = (u8 )((unsigned int )chip->card_fail | 16U);
    set_sense_type(chip, lun, 2);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/xd.c",
                "xd_rw", 2129);
    return (1);
  } else {

  }
  if ((int )start_page + (int )total_sec_cnt > (int )xd_card->page_off + 1) {
    end_page = (unsigned int )xd_card->page_off + 1U;
  } else {
    end_page = (int )((u8 )total_sec_cnt) + (int )start_page;
  }
  page_cnt = (int )end_page - (int )start_page;
  if ((unsigned int )srb->sc_data_direction == 2U) {
    retval = xd_read_multiple_pages(chip, old_blk, log_blk, (int )start_page, (int )end_page,
                                    ptr, & index, & offset);
    if (retval != 0) {
      set_sense_type(chip, lun, 7);
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/xd.c",
                  "xd_rw", 2146);
      return (1);
    } else {

    }
  } else {
    retval = xd_write_multiple_pages(chip, old_blk, new_blk, log_blk, (int )start_page,
                                     (int )end_page, ptr, & index, & offset);
    if (retval != 0) {
      set_sense_type(chip, lun, 8);
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/xd.c",
                  "xd_rw", 2157);
      return (1);
    } else {

    }
  }
  total_sec_cnt = (int )total_sec_cnt - (int )((u16 )page_cnt);
  tmp___9 = scsi_sg_count(srb);
  if (tmp___9 == 0U) {
    ptr = ptr + (unsigned long )((int )page_cnt * 512);
  } else {

  }
  if ((unsigned int )total_sec_cnt == 0U) {
    goto ldv_38846;
  } else {

  }
  log_blk = log_blk + 1U;
  zone_no = (int )(log_blk / 1000U);
  log_off = (unsigned short )(log_blk % 1000U);
  if ((xd_card->zone + (unsigned long )zone_no)->build_flag == 0) {
    retval = xd_build_l2p_tbl(chip, zone_no);
    if (retval != 0) {
      chip->card_fail = (u8 )((unsigned int )chip->card_fail | 16U);
      set_sense_type(chip, lun, 2);
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/xd.c",
                  "xd_rw", 2179);
      return (1);
    } else {

    }
  } else {

  }
  old_blk = xd_get_l2p_tbl(chip, zone_no, (int )log_off);
  if (old_blk == 4294967295U) {
    if ((unsigned int )srb->sc_data_direction == 2U) {
      set_sense_type(chip, lun, 7);
    } else {
      set_sense_type(chip, lun, 8);
    }
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/xd.c",
                "xd_rw", 2193);
    return (1);
  } else {

  }
  if ((unsigned int )srb->sc_data_direction == 1U) {
    new_blk = xd_get_unused_block(chip, zone_no);
    if (new_blk == 4294967295U) {
      set_sense_type(chip, lun, 8);
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/xd.c",
                  "xd_rw", 2202);
      return (1);
    } else {

    }
  } else {

  }
  start_page = 0U;
  ldv_38848: ;
  if ((unsigned int )total_sec_cnt != 0U) {
    goto ldv_38847;
  } else {

  }
  ldv_38846: ;
  if ((unsigned int )srb->sc_data_direction == 1U && (int )end_page != (int )xd_card->page_off + 1) {
    delay_write->delay_write_flag = 1U;
    delay_write->old_phyblock = old_blk;
    delay_write->new_phyblock = new_blk;
    delay_write->logblock = log_blk;
    delay_write->pageoff = end_page;
  } else {

  }
  scsi_set_resid(srb, 0);
  return (0);
}
}
void xd_free_l2p_tbl(struct rtsx_chip *chip ) 
{ 
  struct xd_info *xd_card ;
  int i ;

  {
  xd_card = & chip->xd_card;
  i = 0;
  if ((unsigned long )xd_card->zone != (unsigned long )((struct zone_entry *)0)) {
    i = 0;
    goto ldv_38855;
    ldv_38854: ;
    if ((unsigned long )(xd_card->zone + (unsigned long )i)->l2p_table != (unsigned long )((u16 *)0U)) {
      vfree((void const   *)(xd_card->zone + (unsigned long )i)->l2p_table);
      (xd_card->zone + (unsigned long )i)->l2p_table = (u16 *)0U;
    } else {

    }
    if ((unsigned long )(xd_card->zone + (unsigned long )i)->free_table != (unsigned long )((u16 *)0U)) {
      vfree((void const   *)(xd_card->zone + (unsigned long )i)->free_table);
      (xd_card->zone + (unsigned long )i)->free_table = (u16 *)0U;
    } else {

    }
    i = i + 1;
    ldv_38855: ;
    if (xd_card->zone_cnt > i) {
      goto ldv_38854;
    } else {

    }
    vfree((void const   *)xd_card->zone);
    xd_card->zone = (struct zone_entry *)0;
  } else {

  }
  return;
}
}
void xd_cleanup_work(struct rtsx_chip *chip ) 
{ 
  struct xd_info *xd_card ;
  struct _ddebug descriptor ;
  struct device *tmp ;
  long tmp___0 ;

  {
  xd_card = & chip->xd_card;
  if ((unsigned int )xd_card->delay_write.delay_write_flag != 0U) {
    descriptor.modname = "rts5208";
    descriptor.function = "xd_cleanup_work";
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/xd.c";
    descriptor.format = "xD: delay write\n";
    descriptor.lineno = 2274U;
    descriptor.flags = 0U;
    tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
    if (tmp___0 != 0L) {
      tmp = rtsx_dev((struct rtsx_chip  const  *)chip);
      __dynamic_dev_dbg(& descriptor, (struct device  const  *)tmp, "xD: delay write\n");
    } else {

    }
    xd_delay_write(chip);
    xd_card->cleanup_counter = 0;
  } else {

  }
  return;
}
}
int xd_power_off_card3v3(struct rtsx_chip *chip ) 
{ 
  int retval ;
  struct task_struct *tmp ;
  long volatile   __ret ;
  struct task_struct *tmp___0 ;
  struct task_struct *tmp___1 ;
  struct task_struct *tmp___2 ;
  struct task_struct *tmp___3 ;

  {
  retval = disable_card_clock(chip, 16);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/xd.c",
                "xd_power_off_card3v3", 2287);
    return (1);
  } else {

  }
  retval = rtsx_write_register(chip, 64853, 2, 0);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/xd.c",
                "xd_power_off_card3v3", 2293);
    return (retval);
  } else {

  }
  if (chip->ft2_fast_mode == 0) {
    retval = card_power_off(chip, 16);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/xd.c",
                  "xd_power_off_card3v3", 2300);
      return (1);
    } else {

    }
    tmp = get_current();
    tmp->task_state_change = 0UL;
    __ret = 1L;
    switch (8UL) {
    case 1UL: 
    tmp___0 = get_current();
    __asm__  volatile   ("xchgb %b0, %1\n": "+q" (__ret), "+m" (tmp___0->state): : "memory",
                         "cc");
    goto ldv_38870;
    case 2UL: 
    tmp___1 = get_current();
    __asm__  volatile   ("xchgw %w0, %1\n": "+r" (__ret), "+m" (tmp___1->state): : "memory",
                         "cc");
    goto ldv_38870;
    case 4UL: 
    tmp___2 = get_current();
    __asm__  volatile   ("xchgl %0, %1\n": "+r" (__ret), "+m" (tmp___2->state): : "memory",
                         "cc");
    goto ldv_38870;
    case 8UL: 
    tmp___3 = get_current();
    __asm__  volatile   ("xchgq %q0, %1\n": "+r" (__ret), "+m" (tmp___3->state): : "memory",
                         "cc");
    goto ldv_38870;
    default: 
    __xchg_wrong_size();
    }
    ldv_38870: 
    schedule_timeout(12L);
  } else {

  }
  if (chip->asic_code != 0) {
    retval = xd_pull_ctl_disable(chip);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/xd.c",
                  "xd_power_off_card3v3", 2310);
      return (1);
    } else {

    }
  } else {
    retval = rtsx_write_register(chip, 64541, 255, 223);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/xd.c",
                  "xd_power_off_card3v3", 2316);
      return (retval);
    } else {

    }
  }
  return (0);
}
}
int release_xd_card(struct rtsx_chip *chip ) 
{ 
  struct xd_info *xd_card ;
  int retval ;

  {
  xd_card = & chip->xd_card;
  chip->card_ready = (unsigned int )chip->card_ready & 239U;
  chip->card_fail = (unsigned int )chip->card_fail & 239U;
  chip->card_wp = (unsigned int )chip->card_wp & 239U;
  xd_card->delay_write.delay_write_flag = 0U;
  xd_free_l2p_tbl(chip);
  retval = xd_power_off_card3v3(chip);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/xd.c",
                "release_xd_card", 2339);
    return (1);
  } else {

  }
  return (0);
}
}
void ldv_mutex_lock_197(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_lock_lock(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_198(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_unlock_lock(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_199(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
int ldv_mutex_trylock_200(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
  tmp = mutex_trylock(ldv_func_arg1);
  ldv_func_res = tmp;
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
  return (tmp___0);
  return (ldv_func_res);
}
}
void ldv_mutex_unlock_201(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_202(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_unlock_i_mutex_of_inode(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_203(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_lock_i_mutex_of_inode(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
int ldv_scsi_add_host_with_dma_204(struct Scsi_Host *shost , struct device *dev ,
                                   struct device *dma_dev ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  int tmp ;

  {
  tmp = scsi_add_host_with_dma(shost, dev, dma_dev);
  ldv_func_res = tmp;
  if (ldv_func_res == 0) {
    ldv_state_variable_3 = 1;
    ldv_initialize_scsi_host_template_3();
  } else {

  }
  return (ldv_func_res);
}
}
__inline static long ldv__builtin_expect(long exp , long c ) ;
int ldv_mutex_trylock_220(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_218(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_221(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_222(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_217(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_219(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_223(struct mutex *ldv_func_arg1 ) ;
int ldv_scsi_add_host_with_dma_224(struct Scsi_Host *shost , struct device *dev ,
                                   struct device *dma_dev ) ;
__inline static void rtsx_clear_ms_error(struct rtsx_chip *chip ) 
{ 


  {
  rtsx_write_register(chip, 64852, 136, 136);
  return;
}
}
void mspro_stop_seq_mode(struct rtsx_chip *chip ) ;
int ms_delay_write(struct rtsx_chip *chip ) ;
__inline static void ms_set_err_code(struct rtsx_chip *chip , u8 err_code ) 
{ 
  struct ms_info *ms_card ;

  {
  ms_card = & chip->ms_card;
  ms_card->err_code = err_code;
  return;
}
}
__inline static int ms_check_err_code(struct rtsx_chip *chip , u8 err_code ) 
{ 
  struct ms_info *ms_card ;

  {
  ms_card = & chip->ms_card;
  return ((int )ms_card->err_code == (int )err_code);
}
}
static int ms_parse_err_code(struct rtsx_chip *chip ) 
{ 


  {
  _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
              "ms_parse_err_code", 47);
  return (1);
}
}
static int ms_transfer_tpc(struct rtsx_chip *chip , u8 trans_mode , u8 tpc , u8 cnt ,
                           u8 cfg ) 
{ 
  struct ms_info *ms_card ;
  int retval ;
  u8 *ptr ;
  struct _ddebug descriptor ;
  struct device *tmp ;
  long tmp___0 ;
  int tmp___1 ;
  u8 *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  ms_card = & chip->ms_card;
  descriptor.modname = "rts5208";
  descriptor.function = "ms_transfer_tpc";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c";
  descriptor.format = "%s: tpc = 0x%x\n";
  descriptor.lineno = 58U;
  descriptor.flags = 0U;
  tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp___0 != 0L) {
    tmp = rtsx_dev((struct rtsx_chip  const  *)chip);
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)tmp, "%s: tpc = 0x%x\n",
                      "ms_transfer_tpc", (int )tpc);
  } else {

  }
  chip->ci = 0;
  rtsx_add_cmd(chip, 1, 64833, 255, (int )tpc);
  rtsx_add_cmd(chip, 1, 64837, 255, (int )cnt);
  rtsx_add_cmd(chip, 1, 64834, 255, (int )cfg);
  rtsx_add_cmd(chip, 1, 64859, 1, 1);
  rtsx_add_cmd(chip, 1, 64835, 255, (int )((unsigned int )trans_mode | 128U));
  rtsx_add_cmd(chip, 2, 64835, 64, 64);
  rtsx_add_cmd(chip, 0, 64834, 0, 0);
  retval = rtsx_send_cmd(chip, 8, 5000);
  if (retval < 0) {
    rtsx_clear_ms_error(chip);
    ms_set_err_code(chip, 64);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "ms_transfer_tpc", 79);
    tmp___1 = ms_parse_err_code(chip);
    return (tmp___1);
  } else {

  }
  tmp___2 = rtsx_get_cmd_data(chip);
  ptr = tmp___2 + 1UL;
  if (((int )tpc & 8) == 0) {
    if (((int )*ptr & 32) != 0) {
      ms_set_err_code(chip, 128);
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                  "ms_transfer_tpc", 88);
      tmp___3 = ms_parse_err_code(chip);
      return (tmp___3);
    } else {

    }
  } else
  if (((int )ms_card->ms_type & 255) == 1 && (int )((signed char )*ptr) >= 0) {
    if (((int )*ptr & 10) != 0) {
      ms_set_err_code(chip, 8);
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                  "ms_transfer_tpc", 95);
      tmp___4 = ms_parse_err_code(chip);
      return (tmp___4);
    } else {

    }
  } else {

  }
  if (((int )*ptr & 16) != 0) {
    rtsx_clear_ms_error(chip);
    ms_set_err_code(chip, 64);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "ms_transfer_tpc", 104);
    tmp___5 = ms_parse_err_code(chip);
    return (tmp___5);
  } else {

  }
  return (0);
}
}
static int ms_transfer_data(struct rtsx_chip *chip , u8 trans_mode , u8 tpc , u16 sec_cnt ,
                            u8 cfg , bool mode_2k , int use_sg , void *buf , int buf_len ) 
{ 
  int retval ;
  u8 val ;
  u8 err_code ;
  enum dma_data_direction dir ;

  {
  err_code = 0U;
  if ((unsigned long )buf == (unsigned long )((void *)0) || buf_len == 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "ms_transfer_data", 120);
    return (1);
  } else {

  }
  if ((unsigned int )trans_mode == 8U) {
    dir = 2;
    err_code = 4U;
  } else
  if ((unsigned int )trans_mode == 12U) {
    dir = 1;
    err_code = 2U;
  } else {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "ms_transfer_data", 131);
    return (1);
  }
  chip->ci = 0;
  rtsx_add_cmd(chip, 1, 64833, 255, (int )tpc);
  rtsx_add_cmd(chip, 1, 64839, 255, (int )((unsigned char )((int )sec_cnt >> 8)));
  rtsx_add_cmd(chip, 1, 64838, 255, (int )((unsigned char )sec_cnt));
  rtsx_add_cmd(chip, 1, 64834, 255, (int )cfg);
  if ((int )mode_2k) {
    rtsx_add_cmd(chip, 1, 64832, 4, 4);
  } else {
    rtsx_add_cmd(chip, 1, 64832, 4, 0);
  }
  trans_dma_enable(dir, chip, (u32 )((int )sec_cnt * 512), 32);
  rtsx_add_cmd(chip, 1, 64835, 255, (int )((unsigned int )trans_mode | 128U));
  rtsx_add_cmd(chip, 2, 64835, 64, 64);
  rtsx_send_cmd_no_wait(chip);
  retval = rtsx_transfer_data(chip, 8, buf, (size_t )buf_len, use_sg, dir, chip->mspro_timeout);
  if (retval < 0) {
    ms_set_err_code(chip, (int )err_code);
    if (retval == -110) {
      retval = 2;
    } else {
      retval = 1;
    }
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "ms_transfer_data", 168);
    return (retval);
  } else {

  }
  retval = rtsx_read_register(chip, 64834, & val);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "ms_transfer_data", 174);
    return (retval);
  } else {

  }
  if (((int )val & 58) != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "ms_transfer_data", 178);
    return (1);
  } else {

  }
  return (0);
}
}
static int ms_write_bytes(struct rtsx_chip *chip , u8 tpc , u8 cnt , u8 cfg , u8 *data ,
                          int data_len ) 
{ 
  struct ms_info *ms_card ;
  int retval ;
  int i ;
  u8 val ;
  struct _ddebug descriptor ;
  struct device *tmp ;
  long tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  ms_card = & chip->ms_card;
  if ((unsigned long )data == (unsigned long )((u8 *)0U) || (int )cnt > data_len) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "ms_write_bytes", 192);
    return (10);
  } else {

  }
  chip->ci = 0;
  i = 0;
  goto ldv_38437;
  ldv_38436: 
  rtsx_add_cmd(chip, 1, (int )((unsigned int )((u16 )i) + 64000U), 255, (int )*(data + (unsigned long )i));
  i = i + 1;
  ldv_38437: ;
  if ((int )cnt > i) {
    goto ldv_38436;
  } else {

  }

  if ((int )cnt & 1) {
    rtsx_add_cmd(chip, 1, (int )((unsigned int )((u16 )i) + 64000U), 255, 255);
  } else {

  }
  rtsx_add_cmd(chip, 1, 64833, 255, (int )tpc);
  rtsx_add_cmd(chip, 1, 64837, 255, (int )cnt);
  rtsx_add_cmd(chip, 1, 64834, 255, (int )cfg);
  rtsx_add_cmd(chip, 1, 64859, 1, 1);
  rtsx_add_cmd(chip, 1, 64835, 255, 132);
  rtsx_add_cmd(chip, 2, 64835, 64, 64);
  retval = rtsx_send_cmd(chip, 8, 5000);
  if (retval < 0) {
    val = 0U;
    rtsx_read_register(chip, 64834, & val);
    descriptor.modname = "rts5208";
    descriptor.function = "ms_write_bytes";
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c";
    descriptor.format = "MS_TRANS_CFG: 0x%02x\n";
    descriptor.lineno = 221U;
    descriptor.flags = 0U;
    tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
    if (tmp___0 != 0L) {
      tmp = rtsx_dev((struct rtsx_chip  const  *)chip);
      __dynamic_dev_dbg(& descriptor, (struct device  const  *)tmp, "MS_TRANS_CFG: 0x%02x\n",
                        (int )val);
    } else {

    }
    rtsx_clear_ms_error(chip);
    if (((int )tpc & 8) == 0) {
      if (((int )val & 32) != 0) {
        ms_set_err_code(chip, 128);
        _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                    "ms_write_bytes", 228);
        tmp___1 = ms_parse_err_code(chip);
        return (tmp___1);
      } else {

      }
    } else
    if (((int )ms_card->ms_type & 255) == 1 && (int )((signed char )val) >= 0) {
      if (((int )val & 10) != 0) {
        ms_set_err_code(chip, 8);
        _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                    "ms_write_bytes", 235);
        tmp___2 = ms_parse_err_code(chip);
        return (tmp___2);
      } else {

      }
    } else {

    }
    if (((int )val & 16) != 0) {
      ms_set_err_code(chip, 64);
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                  "ms_write_bytes", 243);
      tmp___3 = ms_parse_err_code(chip);
      return (tmp___3);
    } else {

    }
    ms_set_err_code(chip, 64);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "ms_write_bytes", 248);
    tmp___4 = ms_parse_err_code(chip);
    return (tmp___4);
  } else {

  }
  return (0);
}
}
static int ms_read_bytes(struct rtsx_chip *chip , u8 tpc , u8 cnt , u8 cfg , u8 *data ,
                         int data_len ) 
{ 
  struct ms_info *ms_card ;
  int retval ;
  int i ;
  u8 *ptr ;
  u8 val ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  u8 *tmp___3 ;
  struct _ddebug descriptor ;
  struct device *tmp___4 ;
  long tmp___5 ;
  struct _ddebug descriptor___0 ;
  long tmp___6 ;

  {
  ms_card = & chip->ms_card;
  if ((unsigned long )data == (unsigned long )((u8 *)0U)) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "ms_read_bytes", 263);
    return (10);
  } else {

  }
  chip->ci = 0;
  rtsx_add_cmd(chip, 1, 64833, 255, (int )tpc);
  rtsx_add_cmd(chip, 1, 64837, 255, (int )cnt);
  rtsx_add_cmd(chip, 1, 64834, 255, (int )cfg);
  rtsx_add_cmd(chip, 1, 64859, 1, 1);
  rtsx_add_cmd(chip, 1, 64835, 255, 128);
  rtsx_add_cmd(chip, 2, 64835, 64, 64);
  i = 0;
  goto ldv_38455;
  ldv_38454: 
  rtsx_add_cmd(chip, 0, (int )((unsigned int )((u16 )i) + 64000U), 0, 0);
  i = i + 1;
  ldv_38455: ;
  if (data_len + -1 > i) {
    goto ldv_38454;
  } else {

  }

  if (data_len & 1) {
    rtsx_add_cmd(chip, 0, (int )((unsigned int )((u16 )data_len) + 64000U), 0, 0);
  } else {
    rtsx_add_cmd(chip, 0, (int )((unsigned int )((u16 )data_len) + 63999U), 0, 0);
  }
  retval = rtsx_send_cmd(chip, 8, 5000);
  if (retval < 0) {
    val = 0U;
    rtsx_read_register(chip, 64834, & val);
    rtsx_clear_ms_error(chip);
    if (((int )tpc & 8) == 0) {
      if (((int )val & 32) != 0) {
        ms_set_err_code(chip, 128);
        _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                    "ms_read_bytes", 299);
        tmp = ms_parse_err_code(chip);
        return (tmp);
      } else {

      }
    } else
    if (((int )ms_card->ms_type & 255) == 1 && (int )((signed char )val) >= 0) {
      if (((int )val & 10) != 0) {
        ms_set_err_code(chip, 8);
        _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                    "ms_read_bytes", 306);
        tmp___0 = ms_parse_err_code(chip);
        return (tmp___0);
      } else {

      }
    } else {

    }
    if (((int )val & 16) != 0) {
      ms_set_err_code(chip, 64);
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                  "ms_read_bytes", 314);
      tmp___1 = ms_parse_err_code(chip);
      return (tmp___1);
    } else {

    }
    ms_set_err_code(chip, 64);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "ms_read_bytes", 319);
    tmp___2 = ms_parse_err_code(chip);
    return (tmp___2);
  } else {

  }
  tmp___3 = rtsx_get_cmd_data(chip);
  ptr = tmp___3 + 1UL;
  i = 0;
  goto ldv_38459;
  ldv_38458: 
  *(data + (unsigned long )i) = *(ptr + (unsigned long )i);
  i = i + 1;
  ldv_38459: ;
  if (i < data_len) {
    goto ldv_38458;
  } else {

  }

  if ((unsigned int )tpc == 3U && data_len == 8) {
    descriptor.modname = "rts5208";
    descriptor.function = "ms_read_bytes";
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c";
    descriptor.format = "Read format progress:\n";
    descriptor.lineno = 329U;
    descriptor.flags = 0U;
    tmp___5 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
    if (tmp___5 != 0L) {
      tmp___4 = rtsx_dev((struct rtsx_chip  const  *)chip);
      __dynamic_dev_dbg(& descriptor, (struct device  const  *)tmp___4, "Read format progress:\n");
    } else {

    }
    descriptor___0.modname = "rts5208";
    descriptor___0.function = "ms_read_bytes";
    descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c";
    descriptor___0.format = "rts5208: ";
    descriptor___0.lineno = 331U;
    descriptor___0.flags = 0U;
    tmp___6 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
    if (tmp___6 != 0L) {
      print_hex_dump("\017", "rts5208: ", 0, 16, 1, (void const   *)ptr, (size_t )cnt,
                     1);
    } else {

    }
  } else {

  }
  return (0);
}
}
static int ms_set_rw_reg_addr(struct rtsx_chip *chip , u8 read_start , u8 read_cnt ,
                              u8 write_start , u8 write_cnt ) 
{ 
  int retval ;
  int i ;
  u8 data[4U] ;

  {
  data[0] = read_start;
  data[1] = read_cnt;
  data[2] = write_start;
  data[3] = write_cnt;
  i = 0;
  goto ldv_38474;
  ldv_38473: 
  retval = ms_write_bytes(chip, 8, 4, 0, (u8 *)(& data), 4);
  if (retval == 0) {
    return (0);
  } else {

  }
  rtsx_clear_ms_error(chip);
  i = i + 1;
  ldv_38474: ;
  if (i <= 2) {
    goto ldv_38473;
  } else {

  }
  _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
              "ms_set_rw_reg_addr", 356);
  return (1);
}
}
static int ms_send_cmd(struct rtsx_chip *chip , u8 cmd , u8 cfg ) 
{ 
  u8 data[2U] ;
  int tmp ;

  {
  data[0] = cmd;
  data[1] = 0U;
  tmp = ms_write_bytes(chip, 14, 1, (int )cfg, (u8 *)(& data), 1);
  return (tmp);
}
}
static int ms_set_init_para(struct rtsx_chip *chip ) 
{ 
  struct ms_info *ms_card ;
  int retval ;

  {
  ms_card = & chip->ms_card;
  if (((int )ms_card->ms_type & 255) == 1 && ((int )ms_card->ms_type & 1536) == 1536) {
    if (chip->asic_code != 0) {
      ms_card->ms_clock = chip->asic_ms_hg_clk;
    } else {
      ms_card->ms_clock = chip->fpga_ms_hg_clk;
    }
  } else
  if (((int )ms_card->ms_type & 255) == 1 || ((int )ms_card->ms_type & 256) != 0) {
    if (chip->asic_code != 0) {
      ms_card->ms_clock = chip->asic_ms_4bit_clk;
    } else {
      ms_card->ms_clock = chip->fpga_ms_4bit_clk;
    }
  } else
  if (chip->asic_code != 0) {
    ms_card->ms_clock = chip->asic_ms_1bit_clk;
  } else {
    ms_card->ms_clock = chip->fpga_ms_1bit_clk;
  }
  retval = switch_clock(chip, ms_card->ms_clock);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "ms_set_init_para", 396);
    return (1);
  } else {

  }
  retval = select_card(chip, 8);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "ms_set_init_para", 402);
    return (1);
  } else {

  }
  return (0);
}
}
static int ms_switch_clock(struct rtsx_chip *chip ) 
{ 
  struct ms_info *ms_card ;
  int retval ;

  {
  ms_card = & chip->ms_card;
  retval = select_card(chip, 8);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "ms_switch_clock", 416);
    return (1);
  } else {

  }
  retval = switch_clock(chip, ms_card->ms_clock);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "ms_switch_clock", 422);
    return (1);
  } else {

  }
  return (0);
}
}
static int ms_pull_ctl_disable(struct rtsx_chip *chip ) 
{ 
  int retval ;

  {
  if ((unsigned int )chip->product_id == 21000U) {
    retval = rtsx_write_register(chip, 64864, 255, 85);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                  "ms_pull_ctl_disable", 437);
      return (retval);
    } else {

    }
    retval = rtsx_write_register(chip, 64865, 255, 85);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                  "ms_pull_ctl_disable", 443);
      return (retval);
    } else {

    }
    retval = rtsx_write_register(chip, 64866, 255, 75);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                  "ms_pull_ctl_disable", 449);
      return (retval);
    } else {

    }
    retval = rtsx_write_register(chip, 64867, 255, 85);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                  "ms_pull_ctl_disable", 455);
      return (retval);
    } else {

    }
    retval = rtsx_write_register(chip, 64868, 255, 180);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                  "ms_pull_ctl_disable", 461);
      return (retval);
    } else {

    }
    retval = rtsx_write_register(chip, 64869, 255, 5);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                  "ms_pull_ctl_disable", 467);
      return (retval);
    } else {

    }
  } else
  if ((unsigned int )chip->product_id == 21128U) {
    if (chip->baro_pkg == 0) {
      retval = rtsx_write_register(chip, 64864, 255, 85);
      if (retval != 0) {
        _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                    "ms_pull_ctl_disable", 475);
        return (retval);
      } else {

      }
      retval = rtsx_write_register(chip, 64865, 255, 85);
      if (retval != 0) {
        _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                    "ms_pull_ctl_disable", 481);
        return (retval);
      } else {

      }
      retval = rtsx_write_register(chip, 64866, 255, 75);
      if (retval != 0) {
        _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                    "ms_pull_ctl_disable", 487);
        return (retval);
      } else {

      }
      retval = rtsx_write_register(chip, 64867, 255, 105);
      if (retval != 0) {
        _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                    "ms_pull_ctl_disable", 493);
        return (retval);
      } else {

      }
    } else {

    }
  } else {

  }
  return (0);
}
}
static int ms_pull_ctl_enable(struct rtsx_chip *chip ) 
{ 
  int retval ;

  {
  chip->ci = 0;
  if ((unsigned int )chip->product_id == 21000U) {
    rtsx_add_cmd(chip, 1, 64864, 255, 81);
    rtsx_add_cmd(chip, 1, 64865, 255, 81);
    rtsx_add_cmd(chip, 1, 64866, 255, 75);
    rtsx_add_cmd(chip, 1, 64867, 255, 85);
    rtsx_add_cmd(chip, 1, 64868, 255, 180);
    rtsx_add_cmd(chip, 1, 64869, 255, 5);
  } else
  if ((unsigned int )chip->product_id == 21128U) {
    if (chip->baro_pkg == 0) {
      rtsx_add_cmd(chip, 1, 64864, 255, 85);
      rtsx_add_cmd(chip, 1, 64865, 255, 69);
      rtsx_add_cmd(chip, 1, 64866, 255, 75);
      rtsx_add_cmd(chip, 1, 64867, 255, 41);
    } else {

    }
  } else {

  }
  retval = rtsx_send_cmd(chip, 8, 100);
  if (retval < 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "ms_pull_ctl_enable", 536);
    return (1);
  } else {

  }
  return (0);
}
}
static int ms_prepare_reset(struct rtsx_chip *chip ) 
{ 
  struct ms_info *ms_card ;
  int retval ;
  u8 oc_mask ;
  struct task_struct *tmp ;
  long volatile   __ret ;
  struct task_struct *tmp___0 ;
  struct task_struct *tmp___1 ;
  struct task_struct *tmp___2 ;
  struct task_struct *tmp___3 ;
  struct task_struct *tmp___4 ;
  long volatile   __ret___0 ;
  struct task_struct *tmp___5 ;
  struct task_struct *tmp___6 ;
  struct task_struct *tmp___7 ;
  struct task_struct *tmp___8 ;
  struct _ddebug descriptor ;
  struct device *tmp___9 ;
  long tmp___10 ;

  {
  ms_card = & chip->ms_card;
  oc_mask = 0U;
  ms_card->ms_type = 0U;
  ms_card->check_ms_flow = 0U;
  ms_card->switch_8bit_fail = 0U;
  ms_card->delay_write.delay_write_flag = 0U;
  ms_card->pro_under_formatting = 0;
  retval = ms_power_off_card3v3(chip);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "ms_prepare_reset", 558);
    return (1);
  } else {

  }
  if (chip->ft2_fast_mode == 0) {
    tmp = get_current();
    tmp->task_state_change = 0UL;
    __ret = 1L;
    switch (8UL) {
    case 1UL: 
    tmp___0 = get_current();
    __asm__  volatile   ("xchgb %b0, %1\n": "+q" (__ret), "+m" (tmp___0->state): : "memory",
                         "cc");
    goto ldv_38514;
    case 2UL: 
    tmp___1 = get_current();
    __asm__  volatile   ("xchgw %w0, %1\n": "+r" (__ret), "+m" (tmp___1->state): : "memory",
                         "cc");
    goto ldv_38514;
    case 4UL: 
    tmp___2 = get_current();
    __asm__  volatile   ("xchgl %0, %1\n": "+r" (__ret), "+m" (tmp___2->state): : "memory",
                         "cc");
    goto ldv_38514;
    case 8UL: 
    tmp___3 = get_current();
    __asm__  volatile   ("xchgq %q0, %1\n": "+r" (__ret), "+m" (tmp___3->state): : "memory",
                         "cc");
    goto ldv_38514;
    default: 
    __xchg_wrong_size();
    }
    ldv_38514: 
    schedule_timeout(62L);
  } else {

  }
  retval = enable_card_clock(chip, 8);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "ms_prepare_reset", 567);
    return (1);
  } else {

  }
  if (chip->asic_code != 0) {
    retval = ms_pull_ctl_enable(chip);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                  "ms_prepare_reset", 574);
      return (1);
    } else {

    }
  } else {
    retval = rtsx_write_register(chip, 64541, 48, 0);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                  "ms_prepare_reset", 581);
      return (retval);
    } else {

    }
  }
  if (chip->ft2_fast_mode == 0) {
    retval = card_power_on(chip, 8);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                  "ms_prepare_reset", 589);
      return (1);
    } else {

    }
    tmp___4 = get_current();
    tmp___4->task_state_change = 0UL;
    __ret___0 = 1L;
    switch (8UL) {
    case 1UL: 
    tmp___5 = get_current();
    __asm__  volatile   ("xchgb %b0, %1\n": "+q" (__ret___0), "+m" (tmp___5->state): : "memory",
                         "cc");
    goto ldv_38522;
    case 2UL: 
    tmp___6 = get_current();
    __asm__  volatile   ("xchgw %w0, %1\n": "+r" (__ret___0), "+m" (tmp___6->state): : "memory",
                         "cc");
    goto ldv_38522;
    case 4UL: 
    tmp___7 = get_current();
    __asm__  volatile   ("xchgl %0, %1\n": "+r" (__ret___0), "+m" (tmp___7->state): : "memory",
                         "cc");
    goto ldv_38522;
    case 8UL: 
    tmp___8 = get_current();
    __asm__  volatile   ("xchgq %q0, %1\n": "+r" (__ret___0), "+m" (tmp___8->state): : "memory",
                         "cc");
    goto ldv_38522;
    default: 
    __xchg_wrong_size();
    }
    ldv_38522: 
    schedule_timeout(37L);
    if ((unsigned int )chip->lun_mode == 1U) {
      oc_mask = 96U;
    } else {
      oc_mask = 6U;
    }
    if ((unsigned int )((int )chip->ocp_stat & (int )oc_mask) != 0U) {
      descriptor.modname = "rts5208";
      descriptor.function = "ms_prepare_reset";
      descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c";
      descriptor.format = "Over current, OCPSTAT is 0x%x\n";
      descriptor.lineno = 603U;
      descriptor.flags = 0U;
      tmp___10 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
      if (tmp___10 != 0L) {
        tmp___9 = rtsx_dev((struct rtsx_chip  const  *)chip);
        __dynamic_dev_dbg(& descriptor, (struct device  const  *)tmp___9, "Over current, OCPSTAT is 0x%x\n",
                          (int )chip->ocp_stat);
      } else {

      }
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                  "ms_prepare_reset", 604);
      return (1);
    } else {

    }
  } else {

  }
  retval = rtsx_write_register(chip, 64853, 8, 8);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "ms_prepare_reset", 613);
    return (retval);
  } else {

  }
  if (chip->asic_code != 0) {
    retval = rtsx_write_register(chip, 64832, 255, 0);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                  "ms_prepare_reset", 621);
      return (retval);
    } else {

    }
  } else {
    retval = rtsx_write_register(chip, 64832, 255, 128);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                  "ms_prepare_reset", 628);
      return (retval);
    } else {

    }
  }
  retval = rtsx_write_register(chip, 64834, 255, 0);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "ms_prepare_reset", 635);
    return (retval);
  } else {

  }
  retval = rtsx_write_register(chip, 64852, 136, 136);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "ms_prepare_reset", 641);
    return (retval);
  } else {

  }
  retval = ms_set_init_para(chip);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "ms_prepare_reset", 647);
    return (1);
  } else {

  }
  return (0);
}
}
static int ms_identify_media_type(struct rtsx_chip *chip , int switch_8bit_bus ) 
{ 
  struct ms_info *ms_card ;
  int retval ;
  int i ;
  u8 val ;
  struct _ddebug descriptor ;
  struct device *tmp ;
  long tmp___0 ;
  struct _ddebug descriptor___0 ;
  struct device *tmp___1 ;
  long tmp___2 ;
  struct _ddebug descriptor___1 ;
  struct device *tmp___3 ;
  long tmp___4 ;
  struct _ddebug descriptor___2 ;
  struct device *tmp___5 ;
  long tmp___6 ;

  {
  ms_card = & chip->ms_card;
  retval = ms_set_rw_reg_addr(chip, 2, 6, 16, 1);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "ms_identify_media_type", 662);
    return (1);
  } else {

  }
  i = 0;
  goto ldv_38540;
  ldv_38539: 
  retval = ms_transfer_tpc(chip, 0, 4, 6, 0);
  if (retval == 0) {
    goto ldv_38538;
  } else {

  }
  i = i + 1;
  ldv_38540: ;
  if (i <= 2) {
    goto ldv_38539;
  } else {

  }
  ldv_38538: ;
  if (i == 3) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "ms_identify_media_type", 673);
    return (1);
  } else {

  }
  retval = rtsx_read_register(chip, 64002, & val);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "ms_identify_media_type", 679);
    return (retval);
  } else {

  }
  descriptor.modname = "rts5208";
  descriptor.function = "ms_identify_media_type";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c";
  descriptor.format = "Type register: 0x%x\n";
  descriptor.lineno = 682U;
  descriptor.flags = 0U;
  tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp___0 != 0L) {
    tmp = rtsx_dev((struct rtsx_chip  const  *)chip);
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)tmp, "Type register: 0x%x\n",
                      (int )val);
  } else {

  }
  if ((unsigned int )val != 1U) {
    if ((unsigned int )val != 2U) {
      ms_card->check_ms_flow = 1U;
    } else {

    }
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "ms_identify_media_type", 687);
    return (1);
  } else {

  }
  retval = rtsx_read_register(chip, 64004, & val);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "ms_identify_media_type", 693);
    return (retval);
  } else {

  }
  descriptor___0.modname = "rts5208";
  descriptor___0.function = "ms_identify_media_type";
  descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c";
  descriptor___0.format = "Category register: 0x%x\n";
  descriptor___0.lineno = 696U;
  descriptor___0.flags = 0U;
  tmp___2 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
  if (tmp___2 != 0L) {
    tmp___1 = rtsx_dev((struct rtsx_chip  const  *)chip);
    __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)tmp___1, "Category register: 0x%x\n",
                      (int )val);
  } else {

  }
  if ((unsigned int )val != 0U) {
    ms_card->check_ms_flow = 1U;
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "ms_identify_media_type", 699);
    return (1);
  } else {

  }
  retval = rtsx_read_register(chip, 64005, & val);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "ms_identify_media_type", 705);
    return (retval);
  } else {

  }
  descriptor___1.modname = "rts5208";
  descriptor___1.function = "ms_identify_media_type";
  descriptor___1.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c";
  descriptor___1.format = "Class register: 0x%x\n";
  descriptor___1.lineno = 708U;
  descriptor___1.flags = 0U;
  tmp___4 = ldv__builtin_expect((long )descriptor___1.flags & 1L, 0L);
  if (tmp___4 != 0L) {
    tmp___3 = rtsx_dev((struct rtsx_chip  const  *)chip);
    __dynamic_dev_dbg(& descriptor___1, (struct device  const  *)tmp___3, "Class register: 0x%x\n",
                      (int )val);
  } else {

  }
  if ((unsigned int )val == 0U) {
    retval = rtsx_read_register(chip, 64000, & val);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                  "ms_identify_media_type", 712);
      return (retval);
    } else {

    }
    if ((int )val & 1) {
      chip->card_wp = (u8 )((unsigned int )chip->card_wp | 8U);
    } else {
      chip->card_wp = (unsigned int )chip->card_wp & 247U;
    }
  } else
  if (((unsigned int )val == 1U || (unsigned int )val == 2U) || (unsigned int )val == 3U) {
    chip->card_wp = (u8 )((unsigned int )chip->card_wp | 8U);
  } else {
    ms_card->check_ms_flow = 1U;
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "ms_identify_media_type", 724);
    return (1);
  }
  ms_card->ms_type = (u16 )((unsigned int )ms_card->ms_type | 1U);
  retval = rtsx_read_register(chip, 64003, & val);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "ms_identify_media_type", 732);
    return (retval);
  } else {

  }
  descriptor___2.modname = "rts5208";
  descriptor___2.function = "ms_identify_media_type";
  descriptor___2.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c";
  descriptor___2.format = "IF Mode register: 0x%x\n";
  descriptor___2.lineno = 735U;
  descriptor___2.flags = 0U;
  tmp___6 = ldv__builtin_expect((long )descriptor___2.flags & 1L, 0L);
  if (tmp___6 != 0L) {
    tmp___5 = rtsx_dev((struct rtsx_chip  const  *)chip);
    __dynamic_dev_dbg(& descriptor___2, (struct device  const  *)tmp___5, "IF Mode register: 0x%x\n",
                      (int )val);
  } else {

  }
  if ((unsigned int )val == 0U) {
    ms_card->ms_type = (unsigned int )ms_card->ms_type & 15U;
  } else
  if ((unsigned int )val == 7U) {
    if (switch_8bit_bus != 0) {
      ms_card->ms_type = (u16 )((unsigned int )ms_card->ms_type | 1024U);
    } else {
      ms_card->ms_type = (unsigned int )ms_card->ms_type & 15U;
    }
  } else {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "ms_identify_media_type", 745);
    return (1);
  }
  return (0);
}
}
static int ms_confirm_cpu_startup(struct rtsx_chip *chip ) 
{ 
  int retval ;
  int i ;
  int k ;
  u8 val ;
  int tmp ;
  struct task_struct *tmp___0 ;
  long volatile   __ret ;
  struct task_struct *tmp___1 ;
  struct task_struct *tmp___2 ;
  struct task_struct *tmp___3 ;
  struct task_struct *tmp___4 ;

  {
  k = 0;
  ldv_38564: 
  tmp = detect_card_cd(chip, 8);
  if (tmp != 0) {
    ms_set_err_code(chip, 32);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "ms_confirm_cpu_startup", 762);
    return (1);
  } else {

  }
  i = 0;
  goto ldv_38555;
  ldv_38554: 
  retval = ms_read_bytes(chip, 7, 1, 0, & val, 1);
  if (retval == 0) {
    goto ldv_38553;
  } else {

  }
  i = i + 1;
  ldv_38555: ;
  if (i <= 2) {
    goto ldv_38554;
  } else {

  }
  ldv_38553: ;
  if (i == 3) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "ms_confirm_cpu_startup", 773);
    return (1);
  } else {

  }
  if (k > 100) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "ms_confirm_cpu_startup", 778);
    return (1);
  } else {

  }
  k = k + 1;
  tmp___0 = get_current();
  tmp___0->task_state_change = 0UL;
  __ret = 1L;
  switch (8UL) {
  case 1UL: 
  tmp___1 = get_current();
  __asm__  volatile   ("xchgb %b0, %1\n": "+q" (__ret), "+m" (tmp___1->state): : "memory",
                       "cc");
  goto ldv_38558;
  case 2UL: 
  tmp___2 = get_current();
  __asm__  volatile   ("xchgw %w0, %1\n": "+r" (__ret), "+m" (tmp___2->state): : "memory",
                       "cc");
  goto ldv_38558;
  case 4UL: 
  tmp___3 = get_current();
  __asm__  volatile   ("xchgl %0, %1\n": "+r" (__ret), "+m" (tmp___3->state): : "memory",
                       "cc");
  goto ldv_38558;
  case 8UL: 
  tmp___4 = get_current();
  __asm__  volatile   ("xchgq %q0, %1\n": "+r" (__ret), "+m" (tmp___4->state): : "memory",
                       "cc");
  goto ldv_38558;
  default: 
  __xchg_wrong_size();
  }
  ldv_38558: 
  schedule_timeout(25L);
  if ((int )((signed char )val) >= 0) {
    goto ldv_38564;
  } else {

  }
  i = 0;
  goto ldv_38568;
  ldv_38567: 
  retval = ms_read_bytes(chip, 7, 1, 0, & val, 1);
  if (retval == 0) {
    goto ldv_38566;
  } else {

  }
  i = i + 1;
  ldv_38568: ;
  if (i <= 2) {
    goto ldv_38567;
  } else {

  }
  ldv_38566: ;
  if (i == 3) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "ms_confirm_cpu_startup", 792);
    return (1);
  } else {

  }
  if (((int )val & 64) != 0) {
    if ((int )val & 1) {
      chip->card_wp = (u8 )((unsigned int )chip->card_wp | 8U);
    } else {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                  "ms_confirm_cpu_startup", 800);
      return (1);
    }
  } else {

  }
  return (0);
}
}
static int ms_switch_parallel_bus(struct rtsx_chip *chip ) 
{ 
  int retval ;
  int i ;
  u8 data[2U] ;

  {
  data[0] = 0U;
  data[1] = 0U;
  i = 0;
  goto ldv_38577;
  ldv_38576: 
  retval = ms_write_bytes(chip, 11, 1, 0, (u8 *)(& data), 2);
  if (retval == 0) {
    goto ldv_38575;
  } else {

  }
  i = i + 1;
  ldv_38577: ;
  if (i <= 2) {
    goto ldv_38576;
  } else {

  }
  ldv_38575: ;
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "ms_switch_parallel_bus", 823);
    return (1);
  } else {

  }
  return (0);
}
}
static int ms_switch_8bit_bus(struct rtsx_chip *chip ) 
{ 
  struct ms_info *ms_card ;
  int retval ;
  int i ;
  u8 data[2U] ;

  {
  ms_card = & chip->ms_card;
  data[0] = 64U;
  data[1] = 0U;
  i = 0;
  goto ldv_38588;
  ldv_38587: 
  retval = ms_write_bytes(chip, 11, 1, 0, (u8 *)(& data), 2);
  if (retval == 0) {
    goto ldv_38586;
  } else {

  }
  i = i + 1;
  ldv_38588: ;
  if (i <= 2) {
    goto ldv_38587;
  } else {

  }
  ldv_38586: ;
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "ms_switch_8bit_bus", 845);
    return (1);
  } else {

  }
  retval = rtsx_write_register(chip, 64832, 152, 152);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "ms_switch_8bit_bus", 852);
    return (retval);
  } else {

  }
  ms_card->ms_type = (u16 )((unsigned int )ms_card->ms_type | 512U);
  retval = ms_set_init_para(chip);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "ms_switch_8bit_bus", 858);
    return (1);
  } else {

  }
  i = 0;
  goto ldv_38591;
  ldv_38590: 
  retval = ms_transfer_tpc(chip, 0, 7, 1, 0);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "ms_switch_8bit_bus", 866);
    return (1);
  } else {

  }
  i = i + 1;
  ldv_38591: ;
  if (i <= 2) {
    goto ldv_38590;
  } else {

  }

  return (0);
}
}
static int ms_pro_reset_flow(struct rtsx_chip *chip , int switch_8bit_bus ) 
{ 
  struct ms_info *ms_card ;
  int retval ;
  int i ;
  int tmp ;

  {
  ms_card = & chip->ms_card;
  i = 0;
  goto ldv_38604;
  ldv_38603: 
  retval = ms_prepare_reset(chip);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "ms_pro_reset_flow", 882);
    return (1);
  } else {

  }
  retval = ms_identify_media_type(chip, switch_8bit_bus);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "ms_pro_reset_flow", 888);
    return (1);
  } else {

  }
  retval = ms_confirm_cpu_startup(chip);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "ms_pro_reset_flow", 894);
    return (1);
  } else {

  }
  retval = ms_switch_parallel_bus(chip);
  if (retval != 0) {
    tmp = detect_card_cd(chip, 8);
    if (tmp != 0) {
      ms_set_err_code(chip, 32);
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                  "ms_pro_reset_flow", 902);
      return (1);
    } else {

    }
    goto ldv_38601;
  } else {
    goto ldv_38602;
  }
  ldv_38601: 
  i = i + 1;
  ldv_38604: ;
  if (i <= 2) {
    goto ldv_38603;
  } else {

  }
  ldv_38602: ;
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "ms_pro_reset_flow", 912);
    return (1);
  } else {

  }
  retval = rtsx_write_register(chip, 64832, 24, 16);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "ms_pro_reset_flow", 919);
    return (retval);
  } else {

  }
  retval = rtsx_write_register(chip, 64832, 64, 64);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "ms_pro_reset_flow", 925);
    return (retval);
  } else {

  }
  retval = ms_set_init_para(chip);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "ms_pro_reset_flow", 931);
    return (1);
  } else {

  }
  if (((((int )ms_card->ms_type & 255) == 1 && ((int )ms_card->ms_type & 1024) != 0) && chip->support_ms_8bit != 0) && switch_8bit_bus != 0) {
    retval = ms_switch_8bit_bus(chip);
    if (retval != 0) {
      ms_card->switch_8bit_fail = 1U;
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                  "ms_pro_reset_flow", 940);
      return (1);
    } else {

    }
  } else {

  }
  return (0);
}
}
static int msxc_change_power(struct rtsx_chip *chip , u8 mode ) 
{ 
  int retval ;
  u8 buf[6U] ;

  {
  ms_cleanup_work(chip);
  retval = ms_set_rw_reg_addr(chip, 0, 0, 17, 6);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "msxc_change_power", 958);
    return (1);
  } else {

  }
  buf[0] = 0U;
  buf[1] = mode;
  buf[2] = 0U;
  buf[3] = 0U;
  buf[4] = 0U;
  buf[5] = 0U;
  retval = ms_write_bytes(chip, 11, 6, 0, (u8 *)(& buf), 6);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "msxc_change_power", 971);
    return (1);
  } else {

  }
  retval = ms_send_cmd(chip, 22, 128);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "msxc_change_power", 977);
    return (1);
  } else {

  }
  retval = rtsx_read_register(chip, 64834, (u8 *)(& buf));
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "msxc_change_power", 983);
    return (retval);
  } else {

  }
  if (((int )buf[0] & 10) != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "msxc_change_power", 987);
    return (1);
  } else {

  }
  return (0);
}
}
static int ms_read_attribute_info(struct rtsx_chip *chip ) 
{ 
  struct ms_info *ms_card ;
  int retval ;
  int i ;
  u8 val ;
  u8 *buf ;
  u8 class_code ;
  u8 device_type ;
  u8 sub_class ;
  u8 data[16U] ;
  u16 total_blk ;
  u16 blk_size ;
  u32 xc_total_blk ;
  u32 xc_blk_size ;
  u32 sys_info_addr ;
  u32 sys_info_size ;
  u32 model_name_addr ;
  u32 model_name_size ;
  int found_sys_info ;
    klee_make_symbolic(&found_sys_info, sizeof(int), "found_sys_info");
  int found_model_name ;
    klee_make_symbolic(&found_model_name, sizeof(int), "found_model_name");
  void *tmp ;
  int cur_addr_off ;
    klee_make_symbolic(&cur_addr_off, sizeof(int), "cur_addr_off");
  struct _ddebug descriptor ;
  struct device *tmp___0 ;
  long tmp___1 ;
  struct _ddebug descriptor___0 ;
  struct device *tmp___2 ;
  long tmp___3 ;
  struct _ddebug descriptor___1 ;
  struct device *tmp___4 ;
  long tmp___5 ;
  struct _ddebug descriptor___2 ;
  struct device *tmp___6 ;
  long tmp___7 ;
  struct _ddebug descriptor___3 ;
  struct device *tmp___8 ;
  long tmp___9 ;
  struct _ddebug descriptor___4 ;
  struct device *tmp___10 ;
  long tmp___11 ;
  u32 tmp___12 ;
  u32 tmp___13 ;

  {
  ms_card = & chip->ms_card;
  total_blk = 0U;
  blk_size = 0U;
  xc_total_blk = 0U;
  xc_blk_size = 0U;
  sys_info_addr = 0U;
  model_name_addr = 0U;
  found_sys_info = 0;
  found_model_name = 0;
  retval = ms_set_rw_reg_addr(chip, 1, 2, 16, 7);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "ms_read_attribute_info", 1012);
    return (1);
  } else {

  }
  if (((int )ms_card->ms_type & 512) != 0) {
    data[0] = 64U;
  } else {
    data[0] = 0U;
  }
  data[1] = 0U;
  data[2] = 64U;
  data[3] = 0U;
  data[4] = 0U;
  data[5] = 0U;
  data[6] = 0U;
  data[7] = 0U;
  i = 0;
  goto ldv_38637;
  ldv_38636: 
  retval = ms_write_bytes(chip, 11, 7, 0, (u8 *)(& data), 8);
  if (retval == 0) {
    goto ldv_38635;
  } else {

  }
  i = i + 1;
  ldv_38637: ;
  if (i <= 2) {
    goto ldv_38636;
  } else {

  }
  ldv_38635: ;
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "ms_read_attribute_info", 1037);
    return (1);
  } else {

  }
  tmp = kmalloc(32768UL, 208U);
  buf = (u8 *)tmp;
  if ((unsigned long )buf == (unsigned long )((u8 *)0U)) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "ms_read_attribute_info", 1043);
    return (10);
  } else {

  }
  i = 0;
  goto ldv_38641;
  ldv_38640: 
  retval = ms_send_cmd(chip, 36, 128);
  if (retval != 0) {
    goto ldv_38638;
  } else {

  }
  retval = rtsx_read_register(chip, 64834, & val);
  if (retval != 0) {
    kfree((void const   *)buf);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "ms_read_attribute_info", 1055);
    return (1);
  } else {

  }
  if (((int )val & 4) == 0) {
    kfree((void const   *)buf);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "ms_read_attribute_info", 1060);
    return (1);
  } else {

  }
  retval = ms_transfer_data(chip, 8, 2, 64, 128, 0, 0, (void *)buf, 32768);
  if (retval == 0) {
    goto ldv_38639;
  } else {

  }
  rtsx_clear_ms_error(chip);
  ldv_38638: 
  i = i + 1;
  ldv_38641: ;
  if (i <= 2) {
    goto ldv_38640;
  } else {

  }
  ldv_38639: ;
  if (retval != 0) {
    kfree((void const   *)buf);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "ms_read_attribute_info", 1073);
    return (1);
  } else {

  }
  i = 0;
  ldv_38643: 
  retval = rtsx_read_register(chip, 64834, & val);
  if (retval != 0) {
    kfree((void const   *)buf);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "ms_read_attribute_info", 1082);
    return (1);
  } else {

  }
  if ((int )val & 1 || ((int )val & 4) == 0) {
    goto ldv_38642;
  } else {

  }
  retval = ms_transfer_tpc(chip, 1, 2, 0, 128);
  if (retval != 0) {
    kfree((void const   *)buf);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "ms_read_attribute_info", 1093);
    return (1);
  } else {

  }
  i = i + 1;
  if (i <= 1023) {
    goto ldv_38643;
  } else {

  }
  ldv_38642: ;
  if (retval != 0) {
    kfree((void const   *)buf);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "ms_read_attribute_info", 1102);
    return (1);
  } else {

  }
  if ((unsigned int )*buf != 165U && (unsigned int )*(buf + 1UL) != 195U) {
    kfree((void const   *)buf);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "ms_read_attribute_info", 1109);
    return (1);
  } else {

  }
  if ((unsigned int )*(buf + 4UL) == 0U || (unsigned int )*(buf + 4UL) > 12U) {
    kfree((void const   *)buf);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "ms_read_attribute_info", 1115);
    return (1);
  } else {

  }
  i = 0;
  goto ldv_38649;
  ldv_38648: 
  cur_addr_off = i * 12 + 16;
  if ((unsigned int )*(buf + ((unsigned long )cur_addr_off + 8UL)) == 16U || (unsigned int )*(buf + ((unsigned long )cur_addr_off + 8UL)) == 19U) {
    sys_info_addr = ((((unsigned int )*(buf + (unsigned long )cur_addr_off) << 24) | ((unsigned int )*(buf + ((unsigned long )cur_addr_off + 1UL)) << 16)) | ((unsigned int )*(buf + ((unsigned long )cur_addr_off + 2UL)) << 8)) | (unsigned int )*(buf + ((unsigned long )cur_addr_off + 3UL));
    sys_info_size = ((((unsigned int )*(buf + ((unsigned long )cur_addr_off + 4UL)) << 24) | ((unsigned int )*(buf + ((unsigned long )cur_addr_off + 5UL)) << 16)) | ((unsigned int )*(buf + ((unsigned long )cur_addr_off + 6UL)) << 8)) | (unsigned int )*(buf + ((unsigned long )cur_addr_off + 7UL));
    descriptor.modname = "rts5208";
    descriptor.function = "ms_read_attribute_info";
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c";
    descriptor.format = "sys_info_addr = 0x%x, sys_info_size = 0x%x\n";
    descriptor.lineno = 1138U;
    descriptor.flags = 0U;
    tmp___1 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
    if (tmp___1 != 0L) {
      tmp___0 = rtsx_dev((struct rtsx_chip  const  *)chip);
      __dynamic_dev_dbg(& descriptor, (struct device  const  *)tmp___0, "sys_info_addr = 0x%x, sys_info_size = 0x%x\n",
                        sys_info_addr, sys_info_size);
    } else {

    }
    if (sys_info_size != 96U) {
      kfree((void const   *)buf);
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                  "ms_read_attribute_info", 1141);
      return (1);
    } else {

    }
    if (sys_info_addr <= 415U) {
      kfree((void const   *)buf);
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                  "ms_read_attribute_info", 1146);
      return (1);
    } else {

    }
    if (sys_info_size + sys_info_addr > 32768U) {
      kfree((void const   *)buf);
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                  "ms_read_attribute_info", 1151);
      return (1);
    } else {

    }
    if ((unsigned int )*(buf + ((unsigned long )cur_addr_off + 8UL)) == 19U) {
      ms_card->ms_type = (u16 )((unsigned int )ms_card->ms_type | 2048U);
    } else {

    }
    found_sys_info = 1;
  } else {

  }
  if ((unsigned int )*(buf + ((unsigned long )cur_addr_off + 8UL)) == 21U) {
    model_name_addr = ((((unsigned int )*(buf + (unsigned long )cur_addr_off) << 24) | ((unsigned int )*(buf + ((unsigned long )cur_addr_off + 1UL)) << 16)) | ((unsigned int )*(buf + ((unsigned long )cur_addr_off + 2UL)) << 8)) | (unsigned int )*(buf + ((unsigned long )cur_addr_off + 3UL));
    model_name_size = ((((unsigned int )*(buf + ((unsigned long )cur_addr_off + 4UL)) << 24) | ((unsigned int )*(buf + ((unsigned long )cur_addr_off + 5UL)) << 16)) | ((unsigned int )*(buf + ((unsigned long )cur_addr_off + 6UL)) << 8)) | (unsigned int )*(buf + ((unsigned long )cur_addr_off + 7UL));
    descriptor___0.modname = "rts5208";
    descriptor___0.function = "ms_read_attribute_info";
    descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c";
    descriptor___0.format = "model_name_addr = 0x%x, model_name_size = 0x%x\n";
    descriptor___0.lineno = 1176U;
    descriptor___0.flags = 0U;
    tmp___3 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
    if (tmp___3 != 0L) {
      tmp___2 = rtsx_dev((struct rtsx_chip  const  *)chip);
      __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)tmp___2, "model_name_addr = 0x%x, model_name_size = 0x%x\n",
                        model_name_addr, model_name_size);
    } else {

    }
    if (model_name_size != 48U) {
      kfree((void const   *)buf);
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                  "ms_read_attribute_info", 1179);
      return (1);
    } else {

    }
    if (model_name_addr <= 415U) {
      kfree((void const   *)buf);
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                  "ms_read_attribute_info", 1184);
      return (1);
    } else {

    }
    if (model_name_size + model_name_addr > 32768U) {
      kfree((void const   *)buf);
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                  "ms_read_attribute_info", 1189);
      return (1);
    } else {

    }
    found_model_name = 1;
  } else {

  }
  if (found_sys_info != 0 && found_model_name != 0) {
    goto ldv_38647;
  } else {

  }
  i = i + 1;
  ldv_38649: ;
  if ((int )*(buf + 4UL) > i) {
    goto ldv_38648;
  } else {

  }
  ldv_38647: ;
  if ((int )*(buf + 4UL) == i) {
    kfree((void const   *)buf);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "ms_read_attribute_info", 1203);
    return (1);
  } else {

  }
  class_code = *(buf + (unsigned long )sys_info_addr);
  device_type = *(buf + (unsigned long )(sys_info_addr + 56U));
  sub_class = *(buf + (unsigned long )(sys_info_addr + 46U));
  if (((int )ms_card->ms_type & 255) == 1 && ((int )ms_card->ms_type & 2048) != 0) {
    xc_total_blk = ((((unsigned int )*(buf + (unsigned long )(sys_info_addr + 6U)) << 24) | ((unsigned int )*(buf + (unsigned long )(sys_info_addr + 7U)) << 16)) | ((unsigned int )*(buf + (unsigned long )(sys_info_addr + 8U)) << 8)) | (unsigned int )*(buf + (unsigned long )(sys_info_addr + 9U));
    xc_blk_size = ((((unsigned int )*(buf + (unsigned long )(sys_info_addr + 32U)) << 24) | ((unsigned int )*(buf + (unsigned long )(sys_info_addr + 33U)) << 16)) | ((unsigned int )*(buf + (unsigned long )(sys_info_addr + 34U)) << 8)) | (unsigned int )*(buf + (unsigned long )(sys_info_addr + 35U));
    descriptor___1.modname = "rts5208";
    descriptor___1.function = "ms_read_attribute_info";
    descriptor___1.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c";
    descriptor___1.format = "xc_total_blk = 0x%x, xc_blk_size = 0x%x\n";
    descriptor___1.lineno = 1221U;
    descriptor___1.flags = 0U;
    tmp___5 = ldv__builtin_expect((long )descriptor___1.flags & 1L, 0L);
    if (tmp___5 != 0L) {
      tmp___4 = rtsx_dev((struct rtsx_chip  const  *)chip);
      __dynamic_dev_dbg(& descriptor___1, (struct device  const  *)tmp___4, "xc_total_blk = 0x%x, xc_blk_size = 0x%x\n",
                        xc_total_blk, xc_blk_size);
    } else {

    }
  } else {
    total_blk = (u16 )((int )((short )((int )*(buf + (unsigned long )(sys_info_addr + 6U)) << 8)) | (int )((short )*(buf + (unsigned long )(sys_info_addr + 7U))));
    blk_size = (u16 )((int )((short )((int )*(buf + (unsigned long )(sys_info_addr + 2U)) << 8)) | (int )((short )*(buf + (unsigned long )(sys_info_addr + 3U))));
    descriptor___2.modname = "rts5208";
    descriptor___2.function = "ms_read_attribute_info";
    descriptor___2.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c";
    descriptor___2.format = "total_blk = 0x%x, blk_size = 0x%x\n";
    descriptor___2.lineno = 1228U;
    descriptor___2.flags = 0U;
    tmp___7 = ldv__builtin_expect((long )descriptor___2.flags & 1L, 0L);
    if (tmp___7 != 0L) {
      tmp___6 = rtsx_dev((struct rtsx_chip  const  *)chip);
      __dynamic_dev_dbg(& descriptor___2, (struct device  const  *)tmp___6, "total_blk = 0x%x, blk_size = 0x%x\n",
                        (int )total_blk, (int )blk_size);
    } else {

    }
  }
  descriptor___3.modname = "rts5208";
  descriptor___3.function = "ms_read_attribute_info";
  descriptor___3.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c";
  descriptor___3.format = "class_code = 0x%x, device_type = 0x%x, sub_class = 0x%x\n";
  descriptor___3.lineno = 1238U;
  descriptor___3.flags = 0U;
  tmp___9 = ldv__builtin_expect((long )descriptor___3.flags & 1L, 0L);
  if (tmp___9 != 0L) {
    tmp___8 = rtsx_dev((struct rtsx_chip  const  *)chip);
    __dynamic_dev_dbg(& descriptor___3, (struct device  const  *)tmp___8, "class_code = 0x%x, device_type = 0x%x, sub_class = 0x%x\n",
                      (int )class_code, (int )device_type, (int )sub_class);
  } else {

  }
  memcpy((void *)(& ms_card->raw_sys_info), (void const   *)buf + (unsigned long )sys_info_addr,
           96UL);
  memcpy((void *)(& ms_card->raw_model_name), (void const   *)buf + (unsigned long )model_name_addr,
           48UL);
  kfree((void const   *)buf);
  if (((int )ms_card->ms_type & 255) == 1 && ((int )ms_card->ms_type & 2048) != 0) {
    if ((unsigned int )class_code != 3U) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                  "ms_read_attribute_info", 1250);
      return (1);
    } else {

    }
  } else
  if ((unsigned int )class_code != 2U) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "ms_read_attribute_info", 1255);
    return (1);
  } else {

  }
  if ((unsigned int )device_type != 0U) {
    if (((unsigned int )device_type == 1U || (unsigned int )device_type == 2U) || (unsigned int )device_type == 3U) {
      chip->card_wp = (u8 )((unsigned int )chip->card_wp | 8U);
    } else {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                  "ms_read_attribute_info", 1271);
      return (1);
    }
  } else {

  }
  if (((int )sub_class & 192) != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "ms_read_attribute_info", 1277);
    return (1);
  } else {

  }
  descriptor___4.modname = "rts5208";
  descriptor___4.function = "ms_read_attribute_info";
  descriptor___4.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c";
  descriptor___4.format = "class_code: 0x%x, device_type: 0x%x, sub_class: 0x%x\n";
  descriptor___4.lineno = 1282U;
  descriptor___4.flags = 0U;
  tmp___11 = ldv__builtin_expect((long )descriptor___4.flags & 1L, 0L);
  if (tmp___11 != 0L) {
    tmp___10 = rtsx_dev((struct rtsx_chip  const  *)chip);
    __dynamic_dev_dbg(& descriptor___4, (struct device  const  *)tmp___10, "class_code: 0x%x, device_type: 0x%x, sub_class: 0x%x\n",
                      (int )class_code, (int )device_type, (int )sub_class);
  } else {

  }
  if (((int )ms_card->ms_type & 255) == 1 && ((int )ms_card->ms_type & 2048) != 0) {
    tmp___12 = xc_total_blk * xc_blk_size;
    ms_card->capacity = tmp___12;
    chip->capacity[(int )chip->card2lun[8]] = tmp___12;
  } else {
    tmp___13 = (u32 )((int )total_blk * (int )blk_size);
    ms_card->capacity = tmp___13;
    chip->capacity[(int )chip->card2lun[8]] = tmp___13;
  }
  return (0);
}
}
static int mg_set_tpc_para_sub(struct rtsx_chip *chip , int type , u8 mg_entry_num ) ;
static int reset_ms_pro(struct rtsx_chip *chip ) 
{ 
  struct ms_info *ms_card ;
  int retval ;
  u8 change_power_class ;
  u8 power_class_en ;
  struct _ddebug descriptor ;
  struct device *tmp ;
  long tmp___0 ;
  struct _ddebug descriptor___0 ;
  struct device *tmp___1 ;
  long tmp___2 ;
  u8 power_class_mode ;
  struct _ddebug descriptor___1 ;
  struct device *tmp___3 ;
  long tmp___4 ;

  {
  ms_card = & chip->ms_card;
  if (((int )chip->ms_power_class_en & 2) != 0) {
    change_power_class = 2U;
  } else
  if ((int )chip->ms_power_class_en & 1) {
    change_power_class = 1U;
  } else {
    change_power_class = 0U;
  }
  Retry: 
  retval = ms_pro_reset_flow(chip, 1);
  if (retval != 0) {
    if ((unsigned int )ms_card->switch_8bit_fail != 0U) {
      retval = ms_pro_reset_flow(chip, 0);
      if (retval != 0) {
        _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                    "reset_ms_pro", 1328);
        return (1);
      } else {

      }
    } else {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                  "reset_ms_pro", 1332);
      return (1);
    }
  } else {

  }
  retval = ms_read_attribute_info(chip);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "reset_ms_pro", 1339);
    return (1);
  } else {

  }
  if (((int )ms_card->ms_type & 255) == 1 && ((int )ms_card->ms_type & 1536) == 1536) {
    change_power_class = 0U;
  } else {

  }
  if ((unsigned int )change_power_class != 0U && (((int )ms_card->ms_type & 255) == 1 && ((int )ms_card->ms_type & 2048) != 0)) {
    power_class_en = chip->ms_power_class_en;
    descriptor.modname = "rts5208";
    descriptor.function = "reset_ms_pro";
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c";
    descriptor.format = "power_class_en = 0x%x\n";
    descriptor.lineno = 1351U;
    descriptor.flags = 0U;
    tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
    if (tmp___0 != 0L) {
      tmp = rtsx_dev((struct rtsx_chip  const  *)chip);
      __dynamic_dev_dbg(& descriptor, (struct device  const  *)tmp, "power_class_en = 0x%x\n",
                        (int )power_class_en);
    } else {

    }
    descriptor___0.modname = "rts5208";
    descriptor___0.function = "reset_ms_pro";
    descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c";
    descriptor___0.format = "change_power_class = %d\n";
    descriptor___0.lineno = 1353U;
    descriptor___0.flags = 0U;
    tmp___2 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
    if (tmp___2 != 0L) {
      tmp___1 = rtsx_dev((struct rtsx_chip  const  *)chip);
      __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)tmp___1, "change_power_class = %d\n",
                        (int )change_power_class);
    } else {

    }
    if ((unsigned int )change_power_class != 0U) {
      power_class_en = (u8 )((int )((signed char )(1 << ((int )change_power_class + -1))) & (int )((signed char )power_class_en));
    } else {
      power_class_en = 0U;
    }
    if ((unsigned int )power_class_en != 0U) {
      power_class_mode = (u8 )(((int )ms_card->raw_sys_info[46] & 24) >> 3);
      descriptor___1.modname = "rts5208";
      descriptor___1.function = "reset_ms_pro";
      descriptor___1.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c";
      descriptor___1.format = "power_class_mode = 0x%x";
      descriptor___1.lineno = 1364U;
      descriptor___1.flags = 0U;
      tmp___4 = ldv__builtin_expect((long )descriptor___1.flags & 1L, 0L);
      if (tmp___4 != 0L) {
        tmp___3 = rtsx_dev((struct rtsx_chip  const  *)chip);
        __dynamic_dev_dbg(& descriptor___1, (struct device  const  *)tmp___3, "power_class_mode = 0x%x",
                          (int )power_class_mode);
      } else {

      }
      if ((int )change_power_class > (int )power_class_mode) {
        change_power_class = power_class_mode;
      } else {

      }
      if ((unsigned int )change_power_class != 0U) {
        retval = msxc_change_power(chip, (int )change_power_class);
        if (retval != 0) {
          change_power_class = (u8 )((int )change_power_class - 1);
          goto Retry;
        } else {

        }
      } else {

      }
    } else {

    }
  } else {

  }
  retval = mg_set_tpc_para_sub(chip, 0, 0);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "reset_ms_pro", 1382);
    return (1);
  } else {

  }
  if (((int )ms_card->ms_type & 255) == 1 && ((int )ms_card->ms_type & 1536) == 1536) {
    chip->card_bus_width[(int )chip->card2lun[8]] = 8U;
  } else {
    chip->card_bus_width[(int )chip->card2lun[8]] = 4U;
  }
  return (0);
}
}
static int ms_read_status_reg(struct rtsx_chip *chip ) 
{ 
  int retval ;
  u8 val[2U] ;

  {
  retval = ms_set_rw_reg_addr(chip, 2, 2, 0, 0);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "ms_read_status_reg", 1402);
    return (1);
  } else {

  }
  retval = ms_read_bytes(chip, 4, 2, 0, (u8 *)(& val), 2);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "ms_read_status_reg", 1408);
    return (1);
  } else {

  }
  if (((int )val[1] & 21) != 0) {
    ms_set_err_code(chip, 4);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "ms_read_status_reg", 1414);
    return (1);
  } else {

  }
  return (0);
}
}
static int ms_read_extra_data(struct rtsx_chip *chip , u16 block_addr , u8 page_num ,
                              u8 *buf , int buf_len ) 
{ 
  struct ms_info *ms_card ;
  int retval ;
  int i ;
  u8 val ;
  u8 data[10U] ;

  {
  ms_card = & chip->ms_card;
  retval = ms_set_rw_reg_addr(chip, 22, 9, 16, 6);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "ms_read_extra_data", 1432);
    return (1);
  } else {

  }
  if (((int )ms_card->ms_type & 256) != 0) {
    data[0] = 136U;
  } else {
    data[0] = 128U;
  }
  data[1] = 0U;
  data[2] = (unsigned char )((int )block_addr >> 8);
  data[3] = (unsigned char )block_addr;
  data[4] = 64U;
  data[5] = page_num;
  i = 0;
  goto ldv_38692;
  ldv_38691: 
  retval = ms_write_bytes(chip, 11, 6, 0, (u8 *)(& data), 6);
  if (retval == 0) {
    goto ldv_38690;
  } else {

  }
  i = i + 1;
  ldv_38692: ;
  if (i <= 2) {
    goto ldv_38691;
  } else {

  }
  ldv_38690: ;
  if (i == 3) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "ms_read_extra_data", 1456);
    return (1);
  } else {

  }
  ms_set_err_code(chip, 0);
  i = 0;
  goto ldv_38695;
  ldv_38694: 
  retval = ms_send_cmd(chip, 170, 128);
  if (retval == 0) {
    goto ldv_38693;
  } else {

  }
  i = i + 1;
  ldv_38695: ;
  if (i <= 2) {
    goto ldv_38694;
  } else {

  }
  ldv_38693: ;
  if (i == 3) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "ms_read_extra_data", 1468);
    return (1);
  } else {

  }
  ms_set_err_code(chip, 0);
  retval = ms_read_bytes(chip, 7, 1, 0, & val, 1);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "ms_read_extra_data", 1475);
    return (1);
  } else {

  }
  if ((int )val & 1) {
    ms_set_err_code(chip, 8);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "ms_read_extra_data", 1481);
    return (1);
  } else {

  }
  if ((int )((signed char )val) < 0) {
    if (((int )val & 64) != 0) {
      retval = ms_read_status_reg(chip);
      if (retval != 0) {
        _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                    "ms_read_extra_data", 1488);
        return (1);
      } else {

      }
      retval = ms_set_rw_reg_addr(chip, 22, 9, 16, 6);
      if (retval != 0) {
        _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                    "ms_read_extra_data", 1495);
        return (1);
      } else {

      }
    } else {

    }
  } else {

  }
  retval = ms_read_bytes(chip, 4, 9, 0, (u8 *)(& data), 9);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "ms_read_extra_data", 1504);
    return (1);
  } else {

  }
  if ((unsigned long )buf != (unsigned long )((u8 *)0U) && buf_len != 0) {
    if (buf_len > 9) {
      buf_len = 9;
    } else {

    }
    memcpy((void *)buf, (void const   *)(& data), (size_t )buf_len);
  } else {

  }
  return (0);
}
}
static int ms_write_extra_data(struct rtsx_chip *chip , u16 block_addr , u8 page_num ,
                               u8 *buf , int buf_len ) 
{ 
  struct ms_info *ms_card ;
  int retval ;
  int i ;
  u8 val ;
  u8 data[16U] ;

  {
  ms_card = & chip->ms_card;
  if ((unsigned long )buf == (unsigned long )((u8 *)0U) || buf_len <= 8) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "ms_write_extra_data", 1525);
    return (1);
  } else {

  }
  retval = ms_set_rw_reg_addr(chip, 22, 9, 16, 15);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "ms_write_extra_data", 1532);
    return (1);
  } else {

  }
  if (((int )ms_card->ms_type & 256) != 0) {
    data[0] = 136U;
  } else {
    data[0] = 128U;
  }
  data[1] = 0U;
  data[2] = (unsigned char )((int )block_addr >> 8);
  data[3] = (unsigned char )block_addr;
  data[4] = 64U;
  data[5] = page_num;
  i = 6;
  goto ldv_38710;
  ldv_38709: 
  data[i] = *(buf + ((unsigned long )i + 0xfffffffffffffffaUL));
  i = i + 1;
  ldv_38710: ;
  if (i <= 14) {
    goto ldv_38709;
  } else {

  }
  retval = ms_write_bytes(chip, 11, 15, 0, (u8 *)(& data), 16);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "ms_write_extra_data", 1553);
    return (1);
  } else {

  }
  retval = ms_send_cmd(chip, 85, 128);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "ms_write_extra_data", 1559);
    return (1);
  } else {

  }
  ms_set_err_code(chip, 0);
  retval = ms_read_bytes(chip, 7, 1, 0, & val, 1);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "ms_write_extra_data", 1566);
    return (1);
  } else {

  }
  if ((int )val & 1) {
    ms_set_err_code(chip, 8);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "ms_write_extra_data", 1572);
    return (1);
  } else {

  }
  if ((int )((signed char )val) < 0) {
    if (((int )val & 64) != 0) {
      ms_set_err_code(chip, 2);
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                  "ms_write_extra_data", 1578);
      return (1);
    } else {

    }
  } else {

  }
  return (0);
}
}
static int ms_read_page(struct rtsx_chip *chip , u16 block_addr , u8 page_num ) 
{ 
  struct ms_info *ms_card ;
  int retval ;
  u8 val ;
  u8 data[6U] ;
  int tmp ;

  {
  ms_card = & chip->ms_card;
  retval = ms_set_rw_reg_addr(chip, 22, 9, 16, 6);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "ms_read_page", 1596);
    return (1);
  } else {

  }
  if (((int )ms_card->ms_type & 256) != 0) {
    data[0] = 136U;
  } else {
    data[0] = 128U;
  }
  data[1] = 0U;
  data[2] = (unsigned char )((int )block_addr >> 8);
  data[3] = (unsigned char )block_addr;
  data[4] = 32U;
  data[5] = page_num;
  retval = ms_write_bytes(chip, 11, 6, 0, (u8 *)(& data), 6);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "ms_read_page", 1613);
    return (1);
  } else {

  }
  retval = ms_send_cmd(chip, 170, 128);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "ms_read_page", 1619);
    return (1);
  } else {

  }
  ms_set_err_code(chip, 0);
  retval = ms_read_bytes(chip, 7, 1, 0, & val, 1);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "ms_read_page", 1626);
    return (1);
  } else {

  }
  if ((int )val & 1) {
    ms_set_err_code(chip, 8);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "ms_read_page", 1632);
    return (1);
  } else {

  }
  if ((int )((signed char )val) < 0) {
    if (((int )val & 64) != 0) {
      if (((int )val & 32) == 0) {
        ms_set_err_code(chip, 4);
        _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                    "ms_read_page", 1640);
        return (1);
      } else {

      }
      retval = ms_read_status_reg(chip);
      if (retval != 0) {
        ms_set_err_code(chip, 2);
      } else {

      }
    } else
    if (((int )val & 32) == 0) {
      ms_set_err_code(chip, 1);
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                  "ms_read_page", 1650);
      return (1);
    } else {

    }
  } else {

  }
  retval = ms_transfer_tpc(chip, 1, 2, 0, 0);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "ms_read_page", 1659);
    return (1);
  } else {

  }
  tmp = ms_check_err_code(chip, 2);
  if (tmp != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "ms_read_page", 1664);
    return (1);
  } else {

  }
  return (0);
}
}
static int ms_set_bad_block(struct rtsx_chip *chip , u16 phy_blk ) 
{ 
  struct ms_info *ms_card ;
  int retval ;
  u8 val ;
  u8 data[8U] ;
  u8 extra[9U] ;

  {
  ms_card = & chip->ms_card;
  retval = ms_read_extra_data(chip, (int )phy_blk, 0, (u8 *)(& extra), 9);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "ms_set_bad_block", 1680);
    return (1);
  } else {

  }
  retval = ms_set_rw_reg_addr(chip, 22, 9, 16, 7);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "ms_set_bad_block", 1687);
    return (1);
  } else {

  }
  ms_set_err_code(chip, 0);
  if (((int )ms_card->ms_type & 256) != 0) {
    data[0] = 136U;
  } else {
    data[0] = 128U;
  }
  data[1] = 0U;
  data[2] = (unsigned char )((int )phy_blk >> 8);
  data[3] = (unsigned char )phy_blk;
  data[4] = 128U;
  data[5] = 0U;
  data[6] = (unsigned int )extra[0] & 127U;
  data[7] = 255U;
  retval = ms_write_bytes(chip, 11, 7, 0, (u8 *)(& data), 7);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "ms_set_bad_block", 1708);
    return (1);
  } else {

  }
  retval = ms_send_cmd(chip, 85, 128);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "ms_set_bad_block", 1714);
    return (1);
  } else {

  }
  ms_set_err_code(chip, 0);
  retval = ms_read_bytes(chip, 7, 1, 0, & val, 1);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "ms_set_bad_block", 1721);
    return (1);
  } else {

  }
  if ((int )val & 1) {
    ms_set_err_code(chip, 8);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "ms_set_bad_block", 1727);
    return (1);
  } else {

  }
  if ((int )((signed char )val) < 0) {
    if (((int )val & 64) != 0) {
      ms_set_err_code(chip, 2);
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                  "ms_set_bad_block", 1734);
      return (1);
    } else {

    }
  } else {

  }
  return (0);
}
}
static int ms_erase_block(struct rtsx_chip *chip , u16 phy_blk ) 
{ 
  struct ms_info *ms_card ;
  int retval ;
  int i ;
  u8 val ;
  u8 data[6U] ;

  {
  ms_card = & chip->ms_card;
  i = 0;
  retval = ms_set_rw_reg_addr(chip, 22, 9, 16, 6);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "ms_erase_block", 1752);
    return (1);
  } else {

  }
  ms_set_err_code(chip, 0);
  if (((int )ms_card->ms_type & 256) != 0) {
    data[0] = 136U;
  } else {
    data[0] = 128U;
  }
  data[1] = 0U;
  data[2] = (unsigned char )((int )phy_blk >> 8);
  data[3] = (unsigned char )phy_blk;
  data[4] = 0U;
  data[5] = 0U;
  retval = ms_write_bytes(chip, 11, 6, 0, (u8 *)(& data), 6);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "ms_erase_block", 1771);
    return (1);
  } else {

  }
  ERASE_RTY: 
  retval = ms_send_cmd(chip, 153, 128);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "ms_erase_block", 1778);
    return (1);
  } else {

  }
  ms_set_err_code(chip, 0);
  retval = ms_read_bytes(chip, 7, 1, 0, & val, 1);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "ms_erase_block", 1785);
    return (1);
  } else {

  }
  if ((int )val & 1) {
    if (i <= 2) {
      i = i + 1;
      goto ERASE_RTY;
    } else {

    }
    ms_set_err_code(chip, 8);
    ms_set_bad_block(chip, (int )phy_blk);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "ms_erase_block", 1797);
    return (1);
  } else {

  }
  if ((int )((signed char )val) < 0) {
    if (((int )val & 64) != 0) {
      ms_set_err_code(chip, 2);
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                  "ms_erase_block", 1804);
      return (1);
    } else {

    }
  } else {

  }
  return (0);
}
}
static void ms_set_page_status(u16 log_blk , u8 type , u8 *extra , int extra_len ) 
{ 


  {
  if ((unsigned long )extra == (unsigned long )((u8 *)0U) || extra_len <= 8) {
    return;
  } else {

  }
  memset((void *)extra, 255, 9UL);
  if ((unsigned int )type == 1U) {
    *extra = 184U;
  } else {
    *extra = 152U;
  }
  *(extra + 2UL) = (unsigned char )((int )log_blk >> 8);
  *(extra + 3UL) = (unsigned char )log_blk;
  return;
}
}
static int ms_init_page(struct rtsx_chip *chip , u16 phy_blk , u16 log_blk , u8 start_page ,
                        u8 end_page ) 
{ 
  int retval ;
  u8 extra[9U] ;
  u8 i ;
  int tmp ;

  {
  memset((void *)(& extra), 255, 9UL);
  extra[0] = 248U;
  extra[1] = 255U;
  extra[2] = (unsigned char )((int )log_blk >> 8);
  extra[3] = (unsigned char )log_blk;
  i = start_page;
  goto ldv_38761;
  ldv_38760: 
  tmp = detect_card_cd(chip, 8);
  if (tmp != 0) {
    ms_set_err_code(chip, 32);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "ms_init_page", 1848);
    return (1);
  } else {

  }
  retval = ms_write_extra_data(chip, (int )phy_blk, (int )i, (u8 *)(& extra), 9);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "ms_init_page", 1855);
    return (1);
  } else {

  }
  i = (u8 )((int )i + 1);
  ldv_38761: ;
  if ((int )i < (int )end_page) {
    goto ldv_38760;
  } else {

  }

  return (0);
}
}
static int ms_copy_page(struct rtsx_chip *chip , u16 old_blk , u16 new_blk , u16 log_blk ,
                        u8 start_page , u8 end_page ) 
{ 
  struct ms_info *ms_card ;
  bool uncorrect_flag ;
  int retval ;
  int rty_cnt ;
  u8 extra[9U] ;
  u8 val ;
  u8 i ;
  u8 j ;
  u8 data[16U] ;
  struct _ddebug descriptor ;
  struct device *tmp ;
  long tmp___0 ;
  struct _ddebug descriptor___0 ;
  struct device *tmp___1 ;
  long tmp___2 ;
  int tmp___3 ;
  struct _ddebug descriptor___1 ;
  struct device *tmp___4 ;
  long tmp___5 ;
  struct _ddebug descriptor___2 ;
  struct device *tmp___6 ;
  long tmp___7 ;

  {
  ms_card = & chip->ms_card;
  uncorrect_flag = 0;
  descriptor.modname = "rts5208";
  descriptor.function = "ms_copy_page";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c";
  descriptor.format = "Copy page from 0x%x to 0x%x, logical block is 0x%x\n";
  descriptor.lineno = 1872U;
  descriptor.flags = 0U;
  tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp___0 != 0L) {
    tmp = rtsx_dev((struct rtsx_chip  const  *)chip);
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)tmp, "Copy page from 0x%x to 0x%x, logical block is 0x%x\n",
                      (int )old_blk, (int )new_blk, (int )log_blk);
  } else {

  }
  descriptor___0.modname = "rts5208";
  descriptor___0.function = "ms_copy_page";
  descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c";
  descriptor___0.format = "start_page = %d, end_page = %d\n";
  descriptor___0.lineno = 1874U;
  descriptor___0.flags = 0U;
  tmp___2 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
  if (tmp___2 != 0L) {
    tmp___1 = rtsx_dev((struct rtsx_chip  const  *)chip);
    __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)tmp___1, "start_page = %d, end_page = %d\n",
                      (int )start_page, (int )end_page);
  } else {

  }
  retval = ms_read_extra_data(chip, (int )new_blk, 0, (u8 *)(& extra), 9);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "ms_copy_page", 1878);
    return (1);
  } else {

  }
  retval = ms_read_status_reg(chip);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "ms_copy_page", 1884);
    return (1);
  } else {

  }
  retval = rtsx_read_register(chip, 64000, & val);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "ms_copy_page", 1890);
    return (retval);
  } else {

  }
  if (((int )val & 16) != 0) {
    retval = ms_send_cmd(chip, 195, 128);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                  "ms_copy_page", 1897);
      return (1);
    } else {

    }
    retval = ms_read_bytes(chip, 7, 1, 0, & val, 1);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                  "ms_copy_page", 1903);
      return (1);
    } else {

    }
    if ((int )((signed char )val) >= 0) {
      ms_set_err_code(chip, 2);
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                  "ms_copy_page", 1909);
      return (1);
    } else {

    }
  } else {

  }
  i = start_page;
  goto ldv_38793;
  ldv_38792: 
  tmp___3 = detect_card_cd(chip, 8);
  if (tmp___3 != 0) {
    ms_set_err_code(chip, 32);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "ms_copy_page", 1917);
    return (1);
  } else {

  }
  ms_read_extra_data(chip, (int )old_blk, (int )i, (u8 *)(& extra), 9);
  retval = ms_set_rw_reg_addr(chip, 22, 9, 16, 6);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "ms_copy_page", 1926);
    return (1);
  } else {

  }
  ms_set_err_code(chip, 0);
  if (((int )ms_card->ms_type & 256) != 0) {
    data[0] = 136U;
  } else {
    data[0] = 128U;
  }
  data[1] = 0U;
  data[2] = (unsigned char )((int )old_blk >> 8);
  data[3] = (unsigned char )old_blk;
  data[4] = 32U;
  data[5] = i;
  retval = ms_write_bytes(chip, 11, 6, 0, (u8 *)(& data), 6);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "ms_copy_page", 1946);
    return (1);
  } else {

  }
  retval = ms_send_cmd(chip, 170, 128);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "ms_copy_page", 1952);
    return (1);
  } else {

  }
  ms_set_err_code(chip, 0);
  retval = ms_read_bytes(chip, 7, 1, 0, & val, 1);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "ms_copy_page", 1959);
    return (1);
  } else {

  }
  if ((int )val & 1) {
    ms_set_err_code(chip, 8);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "ms_copy_page", 1965);
    return (1);
  } else {

  }
  if ((int )((signed char )val) < 0) {
    if (((int )val & 64) != 0) {
      retval = ms_read_status_reg(chip);
      if (retval != 0) {
        uncorrect_flag = 1;
        descriptor___1.modname = "rts5208";
        descriptor___1.function = "ms_copy_page";
        descriptor___1.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c";
        descriptor___1.format = "Uncorrectable error\n";
        descriptor___1.lineno = 1974U;
        descriptor___1.flags = 0U;
        tmp___5 = ldv__builtin_expect((long )descriptor___1.flags & 1L, 0L);
        if (tmp___5 != 0L) {
          tmp___4 = rtsx_dev((struct rtsx_chip  const  *)chip);
          __dynamic_dev_dbg(& descriptor___1, (struct device  const  *)tmp___4, "Uncorrectable error\n");
        } else {

        }
      } else {
        uncorrect_flag = 0;
      }
      retval = ms_transfer_tpc(chip, 1, 2, 0, 0);
      if (retval != 0) {
        _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                    "ms_copy_page", 1984);
        return (1);
      } else {

      }
      if ((int )uncorrect_flag) {
        ms_set_page_status((int )log_blk, 1, (u8 *)(& extra), 9);
        if ((unsigned int )i == 0U) {
          extra[0] = (unsigned int )extra[0] & 239U;
        } else {

        }
        ms_write_extra_data(chip, (int )old_blk, (int )i, (u8 *)(& extra), 9);
        descriptor___2.modname = "rts5208";
        descriptor___2.function = "ms_copy_page";
        descriptor___2.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c";
        descriptor___2.format = "page %d : extra[0] = 0x%x\n";
        descriptor___2.lineno = 1997U;
        descriptor___2.flags = 0U;
        tmp___7 = ldv__builtin_expect((long )descriptor___2.flags & 1L, 0L);
        if (tmp___7 != 0L) {
          tmp___6 = rtsx_dev((struct rtsx_chip  const  *)chip);
          __dynamic_dev_dbg(& descriptor___2, (struct device  const  *)tmp___6, "page %d : extra[0] = 0x%x\n",
                            (int )i, (int )extra[0]);
        } else {

        }
        ms_card->multi_flag = (u8 )((unsigned int )ms_card->multi_flag | 128U);
        ms_set_page_status((int )log_blk, 0, (u8 *)(& extra), 9);
        ms_write_extra_data(chip, (int )new_blk, (int )i, (u8 *)(& extra), 9);
        goto ldv_38785;
      } else {

      }
      rty_cnt = 0;
      goto ldv_38788;
      ldv_38787: 
      retval = ms_transfer_tpc(chip, 5, 13, 0, 0);
      if (retval == 0) {
        goto ldv_38786;
      } else {

      }
      rty_cnt = rty_cnt + 1;
      ldv_38788: ;
      if (rty_cnt <= 2) {
        goto ldv_38787;
      } else {

      }
      ldv_38786: ;
      if (rty_cnt == 3) {
        _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                    "ms_copy_page", 2018);
        return (1);
      } else {

      }
    } else {

    }
    if (((int )val & 32) == 0) {
      ms_set_err_code(chip, 1);
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                  "ms_copy_page", 2025);
      return (1);
    } else {

    }
  } else {

  }
  retval = ms_set_rw_reg_addr(chip, 22, 9, 16, 15);
  ms_set_err_code(chip, 0);
  if (((int )ms_card->ms_type & 256) != 0) {
    data[0] = 136U;
  } else {
    data[0] = 128U;
  }
  data[1] = 0U;
  data[2] = (unsigned char )((int )new_blk >> 8);
  data[3] = (unsigned char )new_blk;
  data[4] = 32U;
  data[5] = i;
  if (((int )extra[0] & 96) != 96) {
    data[6] = extra[0];
  } else {
    data[6] = 248U;
  }
  data[7] = 255U;
  data[8] = (unsigned char )((int )log_blk >> 8);
  data[9] = (unsigned char )log_blk;
  j = 4U;
  goto ldv_38790;
  ldv_38789: 
  data[(int )j + 6] = 255U;
  j = (u8 )((int )j + 1);
  ldv_38790: ;
  if ((unsigned int )j <= 9U) {
    goto ldv_38789;
  } else {

  }
  retval = ms_write_bytes(chip, 11, 15, 0, (u8 *)(& data), 16);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "ms_copy_page", 2061);
    return (1);
  } else {

  }
  retval = ms_send_cmd(chip, 85, 128);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "ms_copy_page", 2067);
    return (1);
  } else {

  }
  ms_set_err_code(chip, 0);
  retval = ms_read_bytes(chip, 7, 1, 0, & val, 1);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "ms_copy_page", 2074);
    return (1);
  } else {

  }
  if ((int )val & 1) {
    ms_set_err_code(chip, 8);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "ms_copy_page", 2080);
    return (1);
  } else {

  }
  if ((int )((signed char )val) < 0) {
    if (((int )val & 64) != 0) {
      ms_set_err_code(chip, 2);
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                  "ms_copy_page", 2087);
      return (1);
    } else {

    }
  } else {

  }
  if ((unsigned int )i == 0U) {
    retval = ms_set_rw_reg_addr(chip, 22, 9, 16, 7);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                  "ms_copy_page", 2096);
      return (1);
    } else {

    }
    ms_set_err_code(chip, 0);
    if (((int )ms_card->ms_type & 256) != 0) {
      data[0] = 136U;
    } else {
      data[0] = 128U;
    }
    data[1] = 0U;
    data[2] = (unsigned char )((int )old_blk >> 8);
    data[3] = (unsigned char )old_blk;
    data[4] = 128U;
    data[5] = 0U;
    data[6] = 239U;
    data[7] = 255U;
    retval = ms_write_bytes(chip, 11, 7, 0, (u8 *)(& data), 8);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                  "ms_copy_page", 2118);
      return (1);
    } else {

    }
    retval = ms_send_cmd(chip, 85, 128);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                  "ms_copy_page", 2124);
      return (1);
    } else {

    }
    ms_set_err_code(chip, 0);
    retval = ms_read_bytes(chip, 7, 1, 0, & val, 1);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                  "ms_copy_page", 2132);
      return (1);
    } else {

    }
    if ((int )val & 1) {
      ms_set_err_code(chip, 8);
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                  "ms_copy_page", 2138);
      return (1);
    } else {

    }
    if ((int )((signed char )val) < 0) {
      if (((int )val & 64) != 0) {
        ms_set_err_code(chip, 2);
        _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                    "ms_copy_page", 2146);
        return (1);
      } else {

      }
    } else {

    }
  } else {

  }
  ldv_38785: 
  i = (u8 )((int )i + 1);
  ldv_38793: ;
  if ((int )i < (int )end_page) {
    goto ldv_38792;
  } else {

  }

  return (0);
}
}
static int reset_ms(struct rtsx_chip *chip ) 
{ 
  struct ms_info *ms_card ;
  int retval ;
  u16 i ;
  u16 reg_addr ;
  u16 block_size___0 ;
  u8 val ;
  u8 extra[9U] ;
  u8 j ;
  u8 *ptr ;
  int tmp ;
  struct _ddebug descriptor ;
  struct device *tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;
  struct _ddebug descriptor___0 ;
  struct device *tmp___3 ;
  long tmp___4 ;
  struct _ddebug descriptor___1 ;
  struct device *tmp___5 ;
  long tmp___6 ;

  {
  ms_card = & chip->ms_card;
  retval = ms_prepare_reset(chip);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "reset_ms", 2169);
    return (1);
  } else {

  }
  ms_card->ms_type = ms_card->ms_type;
  retval = ms_send_cmd(chip, 60, 0);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "reset_ms", 2177);
    return (1);
  } else {

  }
  retval = ms_read_status_reg(chip);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "reset_ms", 2183);
    return (1);
  } else {

  }
  retval = rtsx_read_register(chip, 64000, & val);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "reset_ms", 2189);
    return (retval);
  } else {

  }
  if ((int )val & 1) {
    chip->card_wp = (u8 )((unsigned int )chip->card_wp | 8U);
  } else {
    chip->card_wp = (unsigned int )chip->card_wp & 247U;
  }
  i = 0U;
  RE_SEARCH: ;
  goto ldv_38809;
  ldv_38811: 
  tmp = detect_card_cd(chip, 8);
  if (tmp != 0) {
    ms_set_err_code(chip, 32);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "reset_ms", 2204);
    return (1);
  } else {

  }
  retval = ms_read_extra_data(chip, (int )i, 0, (u8 *)(& extra), 9);
  if (retval != 0) {
    i = (u16 )((int )i + 1);
    goto ldv_38809;
  } else {

  }
  if ((int )((signed char )extra[0]) < 0) {
    if (((int )extra[1] & 4) == 0) {
      ms_card->boot_block = i;
      goto ldv_38810;
    } else {

    }
  } else {

  }
  i = (u16 )((int )i + 1);
  ldv_38809: ;
  if ((unsigned int )i <= 11U) {
    goto ldv_38811;
  } else {

  }
  ldv_38810: ;
  if ((unsigned int )i == 12U) {
    descriptor.modname = "rts5208";
    descriptor.function = "reset_ms";
    descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c";
    descriptor.format = "No boot block found!";
    descriptor.lineno = 2224U;
    descriptor.flags = 0U;
    tmp___1 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
    if (tmp___1 != 0L) {
      tmp___0 = rtsx_dev((struct rtsx_chip  const  *)chip);
      __dynamic_dev_dbg(& descriptor, (struct device  const  *)tmp___0, "No boot block found!");
    } else {

    }
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "reset_ms", 2225);
    return (1);
  } else {

  }
  j = 0U;
  goto ldv_38814;
  ldv_38813: 
  retval = ms_read_page(chip, (int )ms_card->boot_block, (int )j);
  if (retval != 0) {
    tmp___2 = ms_check_err_code(chip, 2);
    if (tmp___2 != 0) {
      i = (unsigned int )ms_card->boot_block + 1U;
      ms_set_err_code(chip, 0);
      goto RE_SEARCH;
    } else {

    }
  } else {

  }
  j = (u8 )((int )j + 1);
  ldv_38814: ;
  if ((unsigned int )j <= 2U) {
    goto ldv_38813;
  } else {

  }
  retval = ms_read_page(chip, (int )ms_card->boot_block, 0);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "reset_ms", 2242);
    return (1);
  } else {

  }
  chip->ci = 0;
  i = 0U;
  goto ldv_38817;
  ldv_38816: 
  rtsx_add_cmd(chip, 0, (int )((unsigned int )i + 64416U), 0, 0);
  i = (u16 )((int )i + 1);
  ldv_38817: ;
  if ((unsigned int )i <= 95U) {
    goto ldv_38816;
  } else {

  }
  retval = rtsx_send_cmd(chip, 8, 100);
  if (retval < 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "reset_ms", 2254);
    return (1);
  } else {

  }
  ptr = rtsx_get_cmd_data(chip);
  memcpy((void *)(& ms_card->raw_sys_info), (void const   *)ptr, 96UL);
  chip->ci = 0;
  rtsx_add_cmd(chip, 0, 64000, 0, 0);
  rtsx_add_cmd(chip, 0, 64001, 0, 0);
  reg_addr = 64372U;
  goto ldv_38820;
  ldv_38819: 
  rtsx_add_cmd(chip, 0, (int )reg_addr, 0, 0);
  reg_addr = (u16 )((int )reg_addr + 1);
  ldv_38820: ;
  if ((unsigned int )reg_addr <= 64375U) {
    goto ldv_38819;
  } else {

  }
  reg_addr = 64418U;
  goto ldv_38823;
  ldv_38822: 
  rtsx_add_cmd(chip, 0, (int )reg_addr, 0, 0);
  reg_addr = (u16 )((int )reg_addr + 1);
  ldv_38823: ;
  if ((unsigned int )reg_addr <= 64425U) {
    goto ldv_38822;
  } else {

  }
  rtsx_add_cmd(chip, 0, 64472, 0, 0);
  rtsx_add_cmd(chip, 0, 64467, 0, 0);
  retval = rtsx_send_cmd(chip, 8, 100);
  if (retval < 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "reset_ms", 2279);
    return (1);
  } else {

  }
  ptr = rtsx_get_cmd_data(chip);
  descriptor___0.modname = "rts5208";
  descriptor___0.function = "reset_ms";
  descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c";
  descriptor___0.format = "Boot block data:\n";
  descriptor___0.lineno = 2285U;
  descriptor___0.flags = 0U;
  tmp___4 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
  if (tmp___4 != 0L) {
    tmp___3 = rtsx_dev((struct rtsx_chip  const  *)chip);
    __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)tmp___3, "Boot block data:\n");
  } else {

  }
  descriptor___1.modname = "rts5208";
  descriptor___1.function = "reset_ms";
  descriptor___1.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c";
  descriptor___1.format = "%*ph\n";
  descriptor___1.lineno = 2286U;
  descriptor___1.flags = 0U;
  tmp___6 = ldv__builtin_expect((long )descriptor___1.flags & 1L, 0L);
  if (tmp___6 != 0L) {
    tmp___5 = rtsx_dev((struct rtsx_chip  const  *)chip);
    __dynamic_dev_dbg(& descriptor___1, (struct device  const  *)tmp___5, "%*ph\n",
                      16, ptr);
  } else {

  }
  if ((unsigned int )*ptr != 0U || (unsigned int )*(ptr + 1UL) != 1U) {
    i = (unsigned int )ms_card->boot_block + 1U;
    goto RE_SEARCH;
  } else {

  }
  if ((unsigned int )*(ptr + 12UL) != 2U || (unsigned int )*(ptr + 13UL) != 0U) {
    i = (unsigned int )ms_card->boot_block + 1U;
    goto RE_SEARCH;
  } else {

  }
  if ((unsigned int )*(ptr + 14UL) == 1U || (unsigned int )*(ptr + 14UL) == 3U) {
    chip->card_wp = (u8 )((unsigned int )chip->card_wp | 8U);
  } else {

  }
  block_size___0 = (u16 )((int )((short )((int )*(ptr + 6UL) << 8)) | (int )((short )*(ptr + 7UL)));
  if ((unsigned int )block_size___0 == 16U) {
    ms_card->block_shift = 5U;
    ms_card->page_off = 31U;
  } else
  if ((unsigned int )block_size___0 == 8U) {
    ms_card->block_shift = 4U;
    ms_card->page_off = 15U;
  } else {

  }
  ms_card->total_block = (u16 )((int )((short )((int )*(ptr + 8UL) << 8)) | (int )((short )*(ptr + 9UL)));
  j = *(ptr + 10UL);
  if ((unsigned int )ms_card->block_shift == 4U) {
    if ((unsigned int )j <= 1U) {
      ms_card->capacity = 7904U;
    } else {
      ms_card->capacity = 15840U;
    }
  } else
  if ((unsigned int )j <= 4U) {
    ms_card->capacity = 31680U;
  } else
  if ((unsigned int )j <= 9U) {
    ms_card->capacity = 63424U;
  } else
  if ((unsigned int )j <= 16U) {
    ms_card->capacity = 126848U;
  } else {
    ms_card->capacity = 253696U;
  }
  chip->capacity[(int )chip->card2lun[8]] = ms_card->capacity;
  if ((unsigned int )*(ptr + 15UL) != 0U) {
    retval = ms_set_rw_reg_addr(chip, 0, 0, 16, 1);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                  "reset_ms", 2355);
      return (1);
    } else {

    }
    retval = rtsx_write_register(chip, 64000, 255, 136);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                  "reset_ms", 2361);
      return (retval);
    } else {

    }
    retval = rtsx_write_register(chip, 64001, 255, 0);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                  "reset_ms", 2366);
      return (retval);
    } else {

    }
    retval = ms_transfer_tpc(chip, 4, 11, 1, 0);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                  "reset_ms", 2373);
      return (1);
    } else {

    }
    retval = rtsx_write_register(chip, 64832, 90, 82);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                  "reset_ms", 2381);
      return (retval);
    } else {

    }
    ms_card->ms_type = (u16 )((unsigned int )ms_card->ms_type | 256U);
  } else {

  }
  if (((int )ms_card->ms_type & 256) != 0) {
    chip->card_bus_width[(int )chip->card2lun[8]] = 4U;
  } else {
    chip->card_bus_width[(int )chip->card2lun[8]] = 1U;
  }
  return (0);
}
}
static int ms_init_l2p_tbl(struct rtsx_chip *chip ) 
{ 
  struct ms_info *ms_card ;
  int size ;
  int i ;
  int seg_no ;
  int retval ;
  u16 defect_block ;
  u16 reg_addr ;
  u8 val1 ;
  u8 val2 ;
  struct _ddebug descriptor ;
  struct device *tmp ;
  long tmp___0 ;
  void *tmp___1 ;
  int block_no ;
    klee_make_symbolic(&block_no, sizeof(int), "block_no");
  u16 tmp___2 ;
  u16 tmp___3 ;
  int tmp___4 ;
  struct _ddebug descriptor___0 ;
  struct device *tmp___5 ;
  long tmp___6 ;

  {
  ms_card = & chip->ms_card;
  ms_card->segment_cnt = (int )ms_card->total_block >> 9;
  descriptor.modname = "rts5208";
  descriptor.function = "ms_init_l2p_tbl";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c";
  descriptor.format = "ms_card->segment_cnt = %d\n";
  descriptor.lineno = 2405U;
  descriptor.flags = 0U;
  tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp___0 != 0L) {
    tmp = rtsx_dev((struct rtsx_chip  const  *)chip);
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)tmp, "ms_card->segment_cnt = %d\n",
                      ms_card->segment_cnt);
  } else {

  }
  size = (int )((unsigned int )ms_card->segment_cnt * 56U);
  tmp___1 = vzalloc((unsigned long )size);
  ms_card->segment = (struct zone_entry *)tmp___1;
  if ((unsigned long )ms_card->segment == (unsigned long )((struct zone_entry *)0)) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "ms_init_l2p_tbl", 2410);
    return (1);
  } else {

  }
  retval = ms_read_page(chip, (int )ms_card->boot_block, 1);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "ms_init_l2p_tbl", 2416);
    goto INIT_FAIL;
  } else {

  }
  reg_addr = 64000U;
  i = 0;
  goto ldv_38845;
  ldv_38844: 
  tmp___2 = reg_addr;
  reg_addr = (u16 )((int )reg_addr + 1);
  retval = rtsx_read_register(chip, (int )tmp___2, & val1);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "ms_init_l2p_tbl", 2426);
    goto INIT_FAIL;
  } else {

  }
  tmp___3 = reg_addr;
  reg_addr = (u16 )((int )reg_addr + 1);
  retval = rtsx_read_register(chip, (int )tmp___3, & val2);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "ms_init_l2p_tbl", 2432);
    goto INIT_FAIL;
  } else {

  }
  defect_block = (u16 )((int )((short )((int )val1 << 8)) | (int )((short )val2));
  if ((unsigned int )defect_block == 65535U) {
    goto ldv_38843;
  } else {

  }
  seg_no = (int )((unsigned int )defect_block / 512U);
  tmp___4 = (ms_card->segment + (unsigned long )seg_no)->disable_count;
  (ms_card->segment + (unsigned long )seg_no)->disable_count = (ms_card->segment + (unsigned long )seg_no)->disable_count + 1;
  block_no = tmp___4;
  (ms_card->segment + (unsigned long )seg_no)->defect_list[block_no] = defect_block;
  i = i + 1;
  ldv_38845: ;
  if (((int )ms_card->total_block >> 9) * 10 + 1 > i) {
    goto ldv_38844;
  } else {

  }
  ldv_38843: 
  i = 0;
  goto ldv_38848;
  ldv_38847: 
  (ms_card->segment + (unsigned long )i)->build_flag = 0;
  (ms_card->segment + (unsigned long )i)->l2p_table = (u16 *)0U;
  (ms_card->segment + (unsigned long )i)->free_table = (u16 *)0U;
  (ms_card->segment + (unsigned long )i)->get_index = 0;
  (ms_card->segment + (unsigned long )i)->set_index = 0;
  (ms_card->segment + (unsigned long )i)->unused_blk_cnt = 0;
  descriptor___0.modname = "rts5208";
  descriptor___0.function = "ms_init_l2p_tbl";
  descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c";
  descriptor___0.format = "defective block count of segment %d is %d\n";
  descriptor___0.lineno = 2455U;
  descriptor___0.flags = 0U;
  tmp___6 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
  if (tmp___6 != 0L) {
    tmp___5 = rtsx_dev((struct rtsx_chip  const  *)chip);
    __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)tmp___5, "defective block count of segment %d is %d\n",
                      i, (ms_card->segment + (unsigned long )i)->disable_count);
  } else {

  }
  i = i + 1;
  ldv_38848: ;
  if (ms_card->segment_cnt > i) {
    goto ldv_38847;
  } else {

  }

  return (0);
  INIT_FAIL: ;
  if ((unsigned long )ms_card->segment != (unsigned long )((struct zone_entry *)0)) {
    vfree((void const   *)ms_card->segment);
    ms_card->segment = (struct zone_entry *)0;
  } else {

  }
  return (1);
}
}
static u16 ms_get_l2p_tbl(struct rtsx_chip *chip , int seg_no , u16 log_off ) 
{ 
  struct ms_info *ms_card ;
  struct zone_entry *segment ;

  {
  ms_card = & chip->ms_card;
  if ((unsigned long )ms_card->segment == (unsigned long )((struct zone_entry *)0)) {
    return (65535U);
  } else {

  }
  segment = ms_card->segment + (unsigned long )seg_no;
  if ((unsigned long )segment->l2p_table != (unsigned long )((u16 *)0U)) {
    return (*(segment->l2p_table + (unsigned long )log_off));
  } else {

  }
  return (65535U);
}
}
static void ms_set_l2p_tbl(struct rtsx_chip *chip , int seg_no , u16 log_off , u16 phy_blk ) 
{ 
  struct ms_info *ms_card ;
  struct zone_entry *segment ;

  {
  ms_card = & chip->ms_card;
  if ((unsigned long )ms_card->segment == (unsigned long )((struct zone_entry *)0)) {
    return;
  } else {

  }
  segment = ms_card->segment + (unsigned long )seg_no;
  if ((unsigned long )segment->l2p_table != (unsigned long )((u16 *)0U)) {
    *(segment->l2p_table + (unsigned long )log_off) = phy_blk;
  } else {

  }
  return;
}
}
static void ms_set_unused_block(struct rtsx_chip *chip , u16 phy_blk ) 
{ 
  struct ms_info *ms_card ;
  struct zone_entry *segment ;
  int seg_no ;
  int tmp ;

  {
  ms_card = & chip->ms_card;
  seg_no = (int )phy_blk >> 9;
  segment = ms_card->segment + (unsigned long )seg_no;
  tmp = segment->set_index;
  segment->set_index = segment->set_index + 1;
  *(segment->free_table + (unsigned long )tmp) = phy_blk;
  if (segment->set_index > 511) {
    segment->set_index = 0;
  } else {

  }
  segment->unused_blk_cnt = segment->unused_blk_cnt + 1;
  return;
}
}
static u16 ms_get_unused_block(struct rtsx_chip *chip , int seg_no ) 
{ 
  struct ms_info *ms_card ;
  struct zone_entry *segment ;
  u16 phy_blk ;
  int tmp ;

  {
  ms_card = & chip->ms_card;
  segment = ms_card->segment + (unsigned long )seg_no;
  if (segment->unused_blk_cnt <= 0) {
    return (65535U);
  } else {

  }
  phy_blk = *(segment->free_table + (unsigned long )segment->get_index);
  tmp = segment->get_index;
  segment->get_index = segment->get_index + 1;
  *(segment->free_table + (unsigned long )tmp) = 65535U;
  if (segment->get_index > 511) {
    segment->get_index = 0;
  } else {

  }
  segment->unused_blk_cnt = segment->unused_blk_cnt - 1;
  return (phy_blk);
}
}
static unsigned short const   ms_start_idx[17U]  = 
  {      0U,      494U,      990U,      1486U, 
        1982U,      2478U,      2974U,      3470U, 
        3966U,      4462U,      4958U,      5454U, 
        5950U,      6446U,      6942U,      7438U, 
        7934U};
static int ms_arbitrate_l2p(struct rtsx_chip *chip , u16 phy_blk , u16 log_off , u8 us1 ,
                            u8 us2 ) 
{ 
  struct ms_info *ms_card ;
  struct zone_entry *segment ;
  int seg_no ;
  u16 tmp_blk ;

  {
  ms_card = & chip->ms_card;
  seg_no = (int )phy_blk >> 9;
  segment = ms_card->segment + (unsigned long )seg_no;
  tmp_blk = *(segment->l2p_table + (unsigned long )log_off);
  if ((int )us1 != (int )us2) {
    if ((unsigned int )us1 == 0U) {
      if (((int )chip->card_wp & 8) == 0) {
        ms_erase_block(chip, (int )tmp_blk);
      } else {

      }
      ms_set_unused_block(chip, (int )tmp_blk);
      *(segment->l2p_table + (unsigned long )log_off) = phy_blk;
    } else {
      if (((int )chip->card_wp & 8) == 0) {
        ms_erase_block(chip, (int )phy_blk);
      } else {

      }
      ms_set_unused_block(chip, (int )phy_blk);
    }
  } else
  if ((int )phy_blk < (int )tmp_blk) {
    if (((int )chip->card_wp & 8) == 0) {
      ms_erase_block(chip, (int )phy_blk);
    } else {

    }
    ms_set_unused_block(chip, (int )phy_blk);
  } else {
    if (((int )chip->card_wp & 8) == 0) {
      ms_erase_block(chip, (int )tmp_blk);
    } else {

    }
    ms_set_unused_block(chip, (int )tmp_blk);
    *(segment->l2p_table + (unsigned long )log_off) = phy_blk;
  }
  return (0);
}
}
static int ms_build_l2p_tbl(struct rtsx_chip *chip , int seg_no ) 
{ 
  struct ms_info *ms_card ;
  struct zone_entry *segment ;
  bool defect_flag ;
  int retval ;
  int table_size ;
    klee_make_symbolic(&table_size, sizeof(int), "table_size");
  int disable_cnt ;
    klee_make_symbolic(&disable_cnt, sizeof(int), "disable_cnt");
  int i ;
  u16 start ;
  u16 end ;
  u16 phy_blk ;
  u16 log_blk ;
  u16 tmp_blk ;
  u16 idx ;
  u8 extra[9U] ;
  u8 us1 ;
  u8 us2 ;
  struct _ddebug descriptor ;
  struct device *tmp ;
  long tmp___0 ;
  struct _ddebug descriptor___0 ;
  struct device *tmp___1 ;
  long tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  int tmp___5 ;
  struct _ddebug descriptor___1 ;
  struct device *tmp___6 ;
  long tmp___7 ;
  struct _ddebug descriptor___2 ;
  struct device *tmp___8 ;
  long tmp___9 ;
  struct _ddebug descriptor___3 ;
  struct device *tmp___10 ;
  long tmp___11 ;

  {
  ms_card = & chip->ms_card;
  descriptor.modname = "rts5208";
  descriptor.function = "ms_build_l2p_tbl";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c";
  descriptor.format = "ms_build_l2p_tbl: %d\n";
  descriptor.lineno = 2593U;
  descriptor.flags = 0U;
  tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp___0 != 0L) {
    tmp = rtsx_dev((struct rtsx_chip  const  *)chip);
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)tmp, "ms_build_l2p_tbl: %d\n",
                      seg_no);
  } else {

  }
  if ((unsigned long )ms_card->segment == (unsigned long )((struct zone_entry *)0)) {
    retval = ms_init_l2p_tbl(chip);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                  "ms_build_l2p_tbl", 2598);
      return (retval);
    } else {

    }
  } else {

  }
  if ((ms_card->segment + (unsigned long )seg_no)->build_flag != 0) {
    descriptor___0.modname = "rts5208";
    descriptor___0.function = "ms_build_l2p_tbl";
    descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c";
    descriptor___0.format = "l2p table of segment %d has been built\n";
    descriptor___0.lineno = 2605U;
    descriptor___0.flags = 0U;
    tmp___2 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
    if (tmp___2 != 0L) {
      tmp___1 = rtsx_dev((struct rtsx_chip  const  *)chip);
      __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)tmp___1, "l2p table of segment %d has been built\n",
                        seg_no);
    } else {

    }
    return (0);
  } else {

  }
  if (seg_no == 0) {
    table_size = 494;
  } else {
    table_size = 496;
  }
  segment = ms_card->segment + (unsigned long )seg_no;
  if ((unsigned long )segment->l2p_table == (unsigned long )((u16 *)0U)) {
    tmp___3 = vmalloc((unsigned long )(table_size * 2));
    segment->l2p_table = (u16 *)tmp___3;
    if ((unsigned long )segment->l2p_table == (unsigned long )((u16 *)0U)) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                  "ms_build_l2p_tbl", 2619);
      goto BUILD_FAIL;
    } else {

    }
  } else {

  }
  memset((void *)segment->l2p_table, 255, (size_t )(table_size * 2));
  if ((unsigned long )segment->free_table == (unsigned long )((u16 *)0U)) {
    tmp___4 = vmalloc(1024UL);
    segment->free_table = (u16 *)tmp___4;
    if ((unsigned long )segment->free_table == (unsigned long )((u16 *)0U)) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                  "ms_build_l2p_tbl", 2628);
      goto BUILD_FAIL;
    } else {

    }
  } else {

  }
  memset((void *)segment->free_table, 255, 1024UL);
  start = (int )((u16 )seg_no) << 9U;
  end = (int )((u16 )((unsigned int )((unsigned short )seg_no) + 1U)) << 9U;
  disable_cnt = segment->disable_count;
  tmp___5 = 0;
  segment->set_index = tmp___5;
  segment->get_index = tmp___5;
  segment->unused_blk_cnt = 0;
  phy_blk = start;
  goto ldv_38921;
  ldv_38920: ;
  if (disable_cnt != 0) {
    defect_flag = 0;
    i = 0;
    goto ldv_38917;
    ldv_38916: ;
    if ((int )segment->defect_list[i] == (int )phy_blk) {
      defect_flag = 1;
      goto ldv_38915;
    } else {

    }
    i = i + 1;
    ldv_38917: ;
    if (segment->disable_count > i) {
      goto ldv_38916;
    } else {

    }
    ldv_38915: ;
    if ((int )defect_flag) {
      disable_cnt = disable_cnt - 1;
      goto ldv_38918;
    } else {

    }
  } else {

  }
  retval = ms_read_extra_data(chip, (int )phy_blk, 0, (u8 *)(& extra), 9);
  if (retval != 0) {
    descriptor___1.modname = "rts5208";
    descriptor___1.function = "ms_build_l2p_tbl";
    descriptor___1.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c";
    descriptor___1.format = "read extra data fail\n";
    descriptor___1.lineno = 2660U;
    descriptor___1.flags = 0U;
    tmp___7 = ldv__builtin_expect((long )descriptor___1.flags & 1L, 0L);
    if (tmp___7 != 0L) {
      tmp___6 = rtsx_dev((struct rtsx_chip  const  *)chip);
      __dynamic_dev_dbg(& descriptor___1, (struct device  const  *)tmp___6, "read extra data fail\n");
    } else {

    }
    ms_set_bad_block(chip, (int )phy_blk);
    goto ldv_38918;
  } else {

  }
  if (ms_card->segment_cnt + -1 == seg_no) {
    if (((int )extra[1] & 8) == 0) {
      if (((int )chip->card_wp & 8) == 0) {
        retval = ms_erase_block(chip, (int )phy_blk);
        if (retval != 0) {
          goto ldv_38918;
        } else {

        }
        extra[2] = 255U;
        extra[3] = 255U;
      } else {

      }
    } else {

    }
  } else {

  }
  if ((int )((signed char )extra[0]) >= 0) {
    goto ldv_38918;
  } else {

  }
  if (((int )extra[1] & 4) == 0) {
    goto ldv_38918;
  } else {

  }
  if (((int )extra[0] & 96) != 96) {
    goto ldv_38918;
  } else {

  }
  log_blk = (u16 )((int )((short )((int )extra[2] << 8)) | (int )((short )extra[3]));
  if ((unsigned int )log_blk == 65535U) {
    if (((int )chip->card_wp & 8) == 0) {
      retval = ms_erase_block(chip, (int )phy_blk);
      if (retval != 0) {
        goto ldv_38918;
      } else {

      }
    } else {

    }
    ms_set_unused_block(chip, (int )phy_blk);
    goto ldv_38918;
  } else {

  }
  if ((int )((unsigned short )ms_start_idx[seg_no]) > (int )log_blk || (int )((unsigned short )ms_start_idx[seg_no + 1]) <= (int )log_blk) {
    if (((int )chip->card_wp & 8) == 0) {
      retval = ms_erase_block(chip, (int )phy_blk);
      if (retval != 0) {
        goto ldv_38918;
      } else {

      }
    } else {

    }
    ms_set_unused_block(chip, (int )phy_blk);
    goto ldv_38918;
  } else {

  }
  idx = (int )log_blk - (int )((u16 )ms_start_idx[seg_no]);
  if ((unsigned int )*(segment->l2p_table + (unsigned long )idx) == 65535U) {
    *(segment->l2p_table + (unsigned long )idx) = phy_blk;
    goto ldv_38918;
  } else {

  }
  us1 = (unsigned int )extra[0] & 16U;
  tmp_blk = *(segment->l2p_table + (unsigned long )idx);
  retval = ms_read_extra_data(chip, (int )tmp_blk, 0, (u8 *)(& extra), 9);
  if (retval != 0) {
    goto ldv_38918;
  } else {

  }
  us2 = (unsigned int )extra[0] & 16U;
  ms_arbitrate_l2p(chip, (int )phy_blk, (int )log_blk - (int )((u16 )ms_start_idx[seg_no]),
                   (int )us1, (int )us2);
  goto ldv_38918;
  ldv_38918: 
  phy_blk = (u16 )((int )phy_blk + 1);
  ldv_38921: ;
  if ((int )phy_blk < (int )end) {
    goto ldv_38920;
  } else {

  }
  segment->build_flag = 1;
  descriptor___2.modname = "rts5208";
  descriptor___2.function = "ms_build_l2p_tbl";
  descriptor___2.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c";
  descriptor___2.format = "unused block count: %d\n";
  descriptor___2.lineno = 2730U;
  descriptor___2.flags = 0U;
  tmp___9 = ldv__builtin_expect((long )descriptor___2.flags & 1L, 0L);
  if (tmp___9 != 0L) {
    tmp___8 = rtsx_dev((struct rtsx_chip  const  *)chip);
    __dynamic_dev_dbg(& descriptor___2, (struct device  const  *)tmp___8, "unused block count: %d\n",
                      segment->unused_blk_cnt);
  } else {

  }
  if (ms_card->segment_cnt + -1 == seg_no) {
    if (segment->unused_blk_cnt <= 1) {
      chip->card_wp = (u8 )((unsigned int )chip->card_wp | 8U);
    } else {

    }
  } else
  if (segment->unused_blk_cnt <= 0) {
    chip->card_wp = (u8 )((unsigned int )chip->card_wp | 8U);
  } else {

  }
  if (((int )chip->card_wp & 8) != 0) {
    return (0);
  } else {

  }
  log_blk = ms_start_idx[seg_no];
  goto ldv_38925;
  ldv_38924: 
  idx = (int )log_blk - (int )((u16 )ms_start_idx[seg_no]);
  if ((unsigned int )*(segment->l2p_table + (unsigned long )idx) == 65535U) {
    phy_blk = ms_get_unused_block(chip, seg_no);
    if ((unsigned int )phy_blk == 65535U) {
      chip->card_wp = (u8 )((unsigned int )chip->card_wp | 8U);
      return (0);
    } else {

    }
    retval = ms_init_page(chip, (int )phy_blk, (int )log_blk, 0, 1);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                  "ms_build_l2p_tbl", 2755);
      goto BUILD_FAIL;
    } else {

    }
    *(segment->l2p_table + (unsigned long )idx) = phy_blk;
    if (ms_card->segment_cnt + -1 == seg_no) {
      if (segment->unused_blk_cnt <= 1) {
        chip->card_wp = (u8 )((unsigned int )chip->card_wp | 8U);
        return (0);
      } else {

      }
    } else
    if (segment->unused_blk_cnt <= 0) {
      chip->card_wp = (u8 )((unsigned int )chip->card_wp | 8U);
      return (0);
    } else {

    }
  } else {

  }
  log_blk = (u16 )((int )log_blk + 1);
  ldv_38925: ;
  if ((int )((unsigned short )ms_start_idx[seg_no + 1]) > (int )log_blk) {
    goto ldv_38924;
  } else {

  }

  if (seg_no == 0) {
    log_blk = 0U;
    goto ldv_38930;
    ldv_38929: 
    tmp_blk = *(segment->l2p_table + (unsigned long )log_blk);
    if ((int )ms_card->boot_block > (int )tmp_blk) {
      descriptor___3.modname = "rts5208";
      descriptor___3.function = "ms_build_l2p_tbl";
      descriptor___3.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c";
      descriptor___3.format = "Boot block is not the first normal block.\n";
      descriptor___3.lineno = 2779U;
      descriptor___3.flags = 0U;
      tmp___11 = ldv__builtin_expect((long )descriptor___3.flags & 1L, 0L);
      if (tmp___11 != 0L) {
        tmp___10 = rtsx_dev((struct rtsx_chip  const  *)chip);
        __dynamic_dev_dbg(& descriptor___3, (struct device  const  *)tmp___10, "Boot block is not the first normal block.\n");
      } else {

      }
      if (((int )chip->card_wp & 8) != 0) {
        goto ldv_38928;
      } else {

      }
      phy_blk = ms_get_unused_block(chip, 0);
      retval = ms_copy_page(chip, (int )tmp_blk, (int )phy_blk, (int )log_blk, 0,
                            (int )((unsigned int )ms_card->page_off + 1U));
      if (retval != 0) {
        _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                    "ms_build_l2p_tbl", 2788);
        return (1);
      } else {

      }
      *(segment->l2p_table + (unsigned long )log_blk) = phy_blk;
      retval = ms_set_bad_block(chip, (int )tmp_blk);
      if (retval != 0) {
        _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                    "ms_build_l2p_tbl", 2796);
        return (1);
      } else {

      }
    } else {

    }
    log_blk = (u16 )((int )log_blk + 1);
    ldv_38930: ;
    if ((unsigned int )log_blk <= 493U) {
      goto ldv_38929;
    } else {

    }
    ldv_38928: ;
  } else {

  }
  return (0);
  BUILD_FAIL: 
  segment->build_flag = 0;
  if ((unsigned long )segment->l2p_table != (unsigned long )((u16 *)0U)) {
    vfree((void const   *)segment->l2p_table);
    segment->l2p_table = (u16 *)0U;
  } else {

  }
  if ((unsigned long )segment->free_table != (unsigned long )((u16 *)0U)) {
    vfree((void const   *)segment->free_table);
    segment->free_table = (u16 *)0U;
  } else {

  }
  return (1);
}
}
int reset_ms_card(struct rtsx_chip *chip ) 
{ 
  struct ms_info *ms_card ;
  int retval ;
  struct _ddebug descriptor ;
  struct device *tmp ;
  long tmp___0 ;

  {
  ms_card = & chip->ms_card;
  memset((void *)ms_card, 0, 240UL);
  retval = enable_card_clock(chip, 8);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "reset_ms_card", 2829);
    return (1);
  } else {

  }
  retval = select_card(chip, 8);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "reset_ms_card", 2835);
    return (1);
  } else {

  }
  ms_card->ms_type = 0U;
  retval = reset_ms_pro(chip);
  if (retval != 0) {
    if ((unsigned int )ms_card->check_ms_flow != 0U) {
      retval = reset_ms(chip);
      if (retval != 0) {
        _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                    "reset_ms_card", 2846);
        return (1);
      } else {

      }
    } else {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                  "reset_ms_card", 2850);
      return (1);
    }
  } else {

  }
  retval = ms_set_init_para(chip);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "reset_ms_card", 2857);
    return (1);
  } else {

  }
  if (((int )ms_card->ms_type & 255) != 1) {
    retval = ms_build_l2p_tbl(chip, (int )((unsigned int )ms_card->total_block / 512U) + -1);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                  "reset_ms_card", 2867);
      return (1);
    } else {

    }
  } else {

  }
  descriptor.modname = "rts5208";
  descriptor.function = "reset_ms_card";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c";
  descriptor.format = "ms_card->ms_type = 0x%x\n";
  descriptor.lineno = 2872U;
  descriptor.flags = 0U;
  tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp___0 != 0L) {
    tmp = rtsx_dev((struct rtsx_chip  const  *)chip);
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)tmp, "ms_card->ms_type = 0x%x\n",
                      (int )ms_card->ms_type);
  } else {

  }
  return (0);
}
}
static int mspro_set_rw_cmd(struct rtsx_chip *chip , u32 start_sec , u16 sec_cnt ,
                            u8 cmd ) 
{ 
  int retval ;
  int i ;
  u8 data[8U] ;

  {
  data[0] = cmd;
  data[1] = (unsigned char )((int )sec_cnt >> 8);
  data[2] = (unsigned char )sec_cnt;
  data[3] = (unsigned char )(start_sec >> 24);
  data[4] = (unsigned char )(start_sec >> 16);
  data[5] = (unsigned char )(start_sec >> 8);
  data[6] = (unsigned char )start_sec;
  data[7] = 0U;
  i = 0;
  goto ldv_38949;
  ldv_38948: 
  retval = ms_write_bytes(chip, 9, 7, 128, (u8 *)(& data), 8);
  if (retval == 0) {
    goto ldv_38947;
  } else {

  }
  i = i + 1;
  ldv_38949: ;
  if (i <= 2) {
    goto ldv_38948;
  } else {

  }
  ldv_38947: ;
  if (i == 3) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "mspro_set_rw_cmd", 2899);
    return (1);
  } else {

  }
  return (0);
}
}
void mspro_stop_seq_mode(struct rtsx_chip *chip ) 
{ 
  struct ms_info *ms_card ;
  int retval ;

  {
  ms_card = & chip->ms_card;
  if ((unsigned int )ms_card->seq_mode != 0U) {
    retval = ms_switch_clock(chip);
    if (retval != 0) {
      return;
    } else {

    }
    ms_card->seq_mode = 0U;
    ms_card->total_sec_cnt = 0U;
    ms_send_cmd(chip, 37, 128);
    rtsx_write_register(chip, 65076, 128, 128);
  } else {

  }
  return;
}
}
__inline static int ms_auto_tune_clock(struct rtsx_chip *chip ) 
{ 
  struct ms_info *ms_card ;
  int retval ;

  {
  ms_card = & chip->ms_card;
  if (chip->asic_code != 0) {
    if (ms_card->ms_clock > 30) {
      ms_card->ms_clock = ms_card->ms_clock + -20;
    } else {

    }
  } else
  if (ms_card->ms_clock == 6) {
    ms_card->ms_clock = 5;
  } else
  if (ms_card->ms_clock == 5) {
    ms_card->ms_clock = 3;
  } else {

  }
  retval = ms_switch_clock(chip);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "ms_auto_tune_clock", 2942);
    return (1);
  } else {

  }
  return (0);
}
}
static int mspro_rw_multi_sector(struct scsi_cmnd *srb , struct rtsx_chip *chip ,
                                 u32 start_sector , u16 sector_cnt ) 
{ 
  struct ms_info *ms_card ;
  bool mode_2k ;
  int retval ;
  u16 count ;
  u8 val ;
  u8 trans_mode ;
  u8 rw_tpc ;
  u8 rw_cmd ;
  unsigned int tmp ;
  struct scatterlist *tmp___0 ;
  unsigned int tmp___1 ;
  struct _ddebug descriptor ;
  struct device *tmp___2 ;
  long tmp___3 ;
  int tmp___4 ;
  struct _ddebug descriptor___0 ;
  struct device *tmp___5 ;
  long tmp___6 ;

  {
  ms_card = & chip->ms_card;
  mode_2k = 0;
  ms_set_err_code(chip, 0);
  ms_card->cleanup_counter = 0;
  if (((int )ms_card->ms_type & 255) == 1 && ((int )ms_card->ms_type & 1024) != 0) {
    if ((start_sector & 3U) != 0U || ((unsigned int )sector_cnt & 3U) != 0U) {
      if ((unsigned int )srb->sc_data_direction == 2U) {
        rw_tpc = 2U;
        rw_cmd = 32U;
      } else {
        rw_tpc = 13U;
        rw_cmd = 33U;
      }
    } else {
      if ((unsigned int )srb->sc_data_direction == 2U) {
        rw_tpc = 5U;
        rw_cmd = 39U;
      } else {
        rw_tpc = 10U;
        rw_cmd = 40U;
      }
      mode_2k = 1;
    }
  } else
  if ((unsigned int )srb->sc_data_direction == 2U) {
    rw_tpc = 2U;
    rw_cmd = 32U;
  } else {
    rw_tpc = 13U;
    rw_cmd = 33U;
  }
  retval = ms_switch_clock(chip);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "mspro_rw_multi_sector", 2994);
    return (1);
  } else {

  }
  if ((unsigned int )srb->sc_data_direction == 2U) {
    trans_mode = 8U;
  } else {
    trans_mode = 12U;
  }
  retval = rtsx_read_register(chip, 64834, & val);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "mspro_rw_multi_sector", 3005);
    return (retval);
  } else {

  }
  if ((unsigned int )ms_card->seq_mode != 0U) {
    if ((((((unsigned int )ms_card->pre_dir != (unsigned int )srb->sc_data_direction || ms_card->pre_sec_addr + (u32 )ms_card->pre_sec_cnt != start_sector) || ((int )mode_2k && (int )ms_card->seq_mode & 1)) || (! mode_2k && ((int )ms_card->seq_mode & 2) != 0)) || ((int )val & 4) == 0) || ms_card->total_sec_cnt + (u32 )sector_cnt > 65024U) {
      ms_card->seq_mode = 0U;
      ms_card->total_sec_cnt = 0U;
      if (((int )val & 4) != 0) {
        retval = ms_send_cmd(chip, 37, 128);
        if (retval != 0) {
          _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                      "mspro_rw_multi_sector", 3021);
          return (1);
        } else {

        }
        rtsx_write_register(chip, 65076, 128, 128);
      } else {

      }
    } else {

    }
  } else {

  }
  if ((unsigned int )ms_card->seq_mode == 0U) {
    ms_card->total_sec_cnt = 0U;
    if ((unsigned int )sector_cnt > 31U) {
      if (ms_card->capacity - start_sector > 65024U) {
        count = 65024U;
      } else {
        count = (int )((unsigned short )ms_card->capacity) - (int )((unsigned short )start_sector);
      }
      if ((int )count > (int )sector_cnt) {
        if ((int )mode_2k) {
          ms_card->seq_mode = 2U;
        } else {
          ms_card->seq_mode = 1U;
        }
      } else {

      }
    } else {
      count = sector_cnt;
    }
    retval = mspro_set_rw_cmd(chip, start_sector, (int )count, (int )rw_cmd);
    if (retval != 0) {
      ms_card->seq_mode = 0U;
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                  "mspro_rw_multi_sector", 3050);
      return (1);
    } else {

    }
  } else {

  }
  tmp = scsi_bufflen(srb);
  tmp___0 = scsi_sglist(srb);
  tmp___1 = scsi_sg_count(srb);
  retval = ms_transfer_data(chip, (int )trans_mode, (int )rw_tpc, (int )sector_cnt,
                            128, (int )mode_2k, (int )tmp___1, (void *)tmp___0, (int )tmp);
  if (retval != 0) {
    ms_card->seq_mode = 0U;
    rtsx_read_register(chip, 64834, & val);
    rtsx_clear_ms_error(chip);
    tmp___4 = detect_card_cd(chip, 8);
    if (tmp___4 != 0) {
      chip->rw_need_retry = 0;
      descriptor.modname = "rts5208";
      descriptor.function = "mspro_rw_multi_sector";
      descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c";
      descriptor.format = "No card exist, exit mspro_rw_multi_sector\n";
      descriptor.lineno = 3065U;
      descriptor.flags = 0U;
      tmp___3 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
      if (tmp___3 != 0L) {
        tmp___2 = rtsx_dev((struct rtsx_chip  const  *)chip);
        __dynamic_dev_dbg(& descriptor, (struct device  const  *)tmp___2, "No card exist, exit mspro_rw_multi_sector\n");
      } else {

      }
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                  "mspro_rw_multi_sector", 3066);
      return (1);
    } else {

    }
    if (((int )val & 4) != 0) {
      ms_send_cmd(chip, 37, 128);
    } else {

    }
    if (((int )val & 48) != 0) {
      descriptor___0.modname = "rts5208";
      descriptor___0.function = "mspro_rw_multi_sector";
      descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c";
      descriptor___0.format = "MSPro CRC error, tune clock!\n";
      descriptor___0.lineno = 3074U;
      descriptor___0.flags = 0U;
      tmp___6 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
      if (tmp___6 != 0L) {
        tmp___5 = rtsx_dev((struct rtsx_chip  const  *)chip);
        __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)tmp___5, "MSPro CRC error, tune clock!\n");
      } else {

      }
      chip->rw_need_retry = 1;
      ms_auto_tune_clock(chip);
    } else {

    }
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "mspro_rw_multi_sector", 3079);
    return (retval);
  } else {

  }
  if ((unsigned int )ms_card->seq_mode != 0U) {
    ms_card->pre_sec_addr = start_sector;
    ms_card->pre_sec_cnt = sector_cnt;
    ms_card->pre_dir = srb->sc_data_direction;
    ms_card->total_sec_cnt = ms_card->total_sec_cnt + (u32 )sector_cnt;
  } else {

  }
  return (0);
}
}
static int mspro_read_format_progress(struct rtsx_chip *chip , int const   short_data_len ) 
{ 
  struct ms_info *ms_card ;
  int retval ;
  int i ;
  u32 total_progress ;
  u32 cur_progress ;
  u8 cnt ;
  u8 tmp ;
  u8 data[8U] ;
  struct _ddebug descriptor ;
  struct device *tmp___0 ;
  long tmp___1 ;
  struct _ddebug descriptor___0 ;
  struct device *tmp___2 ;
  long tmp___3 ;
  u64 ulltmp ;
  uint32_t __base ;
  uint32_t __rem ;
  struct _ddebug descriptor___1 ;
  struct device *tmp___4 ;
  long tmp___5 ;
  struct task_struct *tmp___6 ;
  long volatile   __ret ;
  struct task_struct *tmp___7 ;
  struct task_struct *tmp___8 ;
  struct task_struct *tmp___9 ;
  struct task_struct *tmp___10 ;

  {
  ms_card = & chip->ms_card;
  descriptor.modname = "rts5208";
  descriptor.function = "mspro_read_format_progress";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c";
  descriptor.format = "mspro_read_format_progress, short_data_len = %d\n";
  descriptor.lineno = 3103U;
  descriptor.flags = 0U;
  tmp___1 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp___1 != 0L) {
    tmp___0 = rtsx_dev((struct rtsx_chip  const  *)chip);
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)tmp___0, "mspro_read_format_progress, short_data_len = %d\n",
                      short_data_len);
  } else {

  }
  retval = ms_switch_clock(chip);
  if (retval != 0) {
    ms_card->format_status = 1;
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "mspro_read_format_progress", 3108);
    return (1);
  } else {

  }
  retval = rtsx_read_register(chip, 64834, & tmp);
  if (retval != 0) {
    ms_card->format_status = 1;
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "mspro_read_format_progress", 3115);
    return (1);
  } else {

  }
  if (((int )tmp & 4) == 0) {
    if (((int )tmp & 15) == 1) {
      ms_card->format_status = 0;
      return (0);
    } else {

    }
    ms_card->format_status = 1;
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "mspro_read_format_progress", 3125);
    return (1);
  } else {

  }
  if ((int )short_data_len > 255) {
    cnt = 0U;
  } else {
    cnt = (unsigned char )short_data_len;
  }
  retval = rtsx_write_register(chip, 64832, 2, 2);
  if (retval != 0) {
    ms_card->format_status = 1;
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "mspro_read_format_progress", 3138);
    return (1);
  } else {

  }
  retval = ms_read_bytes(chip, 3, (int )cnt, 128, (u8 *)(& data), 8);
  if (retval != 0) {
    ms_card->format_status = 1;
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "mspro_read_format_progress", 3146);
    return (1);
  } else {

  }
  total_progress = (u32 )(((((int )data[0] << 24) | ((int )data[1] << 16)) | ((int )data[2] << 8)) | (int )data[3]);
  cur_progress = (u32 )(((((int )data[4] << 24) | ((int )data[5] << 16)) | ((int )data[6] << 8)) | (int )data[7]);
  descriptor___0.modname = "rts5208";
  descriptor___0.function = "mspro_read_format_progress";
  descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c";
  descriptor___0.format = "total_progress = %d, cur_progress = %d\n";
  descriptor___0.lineno = 3156U;
  descriptor___0.flags = 0U;
  tmp___3 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
  if (tmp___3 != 0L) {
    tmp___2 = rtsx_dev((struct rtsx_chip  const  *)chip);
    __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)tmp___2, "total_progress = %d, cur_progress = %d\n",
                      total_progress, cur_progress);
  } else {

  }
  if (total_progress == 0U) {
    ms_card->progress = 0U;
  } else {
    ulltmp = (unsigned long long )cur_progress * 65535ULL;
    __base = total_progress;
    __rem = (uint32_t )(ulltmp % (u64 )__base);
    ulltmp = ulltmp / (u64 )__base;
    ms_card->progress = (unsigned short )ulltmp;
  }
  descriptor___1.modname = "rts5208";
  descriptor___1.function = "mspro_read_format_progress";
  descriptor___1.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c";
  descriptor___1.format = "progress = %d\n";
  descriptor___1.lineno = 3166U;
  descriptor___1.flags = 0U;
  tmp___5 = ldv__builtin_expect((long )descriptor___1.flags & 1L, 0L);
  if (tmp___5 != 0L) {
    tmp___4 = rtsx_dev((struct rtsx_chip  const  *)chip);
    __dynamic_dev_dbg(& descriptor___1, (struct device  const  *)tmp___4, "progress = %d\n",
                      (int )ms_card->progress);
  } else {

  }
  i = 0;
  goto ldv_39009;
  ldv_39008: 
  retval = rtsx_read_register(chip, 64834, & tmp);
  if (retval != 0) {
    ms_card->format_status = 1;
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "mspro_read_format_progress", 3172);
    return (1);
  } else {

  }
  if (((int )tmp & 15) != 0) {
    goto ldv_38999;
  } else {

  }
  tmp___6 = get_current();
  tmp___6->task_state_change = 0UL;
  __ret = 1L;
  switch (8UL) {
  case 1UL: 
  tmp___7 = get_current();
  __asm__  volatile   ("xchgb %b0, %1\n": "+q" (__ret), "+m" (tmp___7->state): : "memory",
                       "cc");
  goto ldv_39002;
  case 2UL: 
  tmp___8 = get_current();
  __asm__  volatile   ("xchgw %w0, %1\n": "+r" (__ret), "+m" (tmp___8->state): : "memory",
                       "cc");
  goto ldv_39002;
  case 4UL: 
  tmp___9 = get_current();
  __asm__  volatile   ("xchgl %0, %1\n": "+r" (__ret), "+m" (tmp___9->state): : "memory",
                       "cc");
  goto ldv_39002;
  case 8UL: 
  tmp___10 = get_current();
  __asm__  volatile   ("xchgq %q0, %1\n": "+r" (__ret), "+m" (tmp___10->state): : "memory",
                       "cc");
  goto ldv_39002;
  default: 
  __xchg_wrong_size();
  }
  ldv_39002: 
  schedule_timeout(0L);
  i = i + 1;
  ldv_39009: ;
  if (i <= 4999) {
    goto ldv_39008;
  } else {

  }
  ldv_38999: 
  retval = rtsx_write_register(chip, 64832, 2, 0);
  if (retval != 0) {
    ms_card->format_status = 1;
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "mspro_read_format_progress", 3185);
    return (1);
  } else {

  }
  if (i == 5000) {
    ms_card->format_status = 1;
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "mspro_read_format_progress", 3191);
    return (1);
  } else {

  }
  if (((int )tmp & 10) != 0) {
    ms_card->format_status = 1;
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "mspro_read_format_progress", 3197);
    return (1);
  } else {

  }
  if ((int )tmp & 1) {
    ms_card->format_status = 0;
    ms_card->pro_under_formatting = 0;
  } else
  if (((int )tmp & 4) != 0) {
    ms_card->format_status = 2;
  } else {
    ms_card->format_status = 1;
    ms_card->pro_under_formatting = 0;
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "mspro_read_format_progress", 3209);
    return (1);
  }
  return (0);
}
}
void mspro_polling_format_status(struct rtsx_chip *chip ) 
{ 
  struct ms_info *ms_card ;
  int i ;

  {
  ms_card = & chip->ms_card;
  if (ms_card->pro_under_formatting != 0 && (unsigned int )chip->rtsx_stat != 3U) {
    chip->idle_counter = 0;
    chip->rtsx_stat = 2;
    i = 0;
    goto ldv_39017;
    ldv_39016: 
    mspro_read_format_progress(chip, 32);
    if (ms_card->format_status != 2) {
      goto ldv_39015;
    } else {

    }
    i = i + 1;
    ldv_39017: ;
    if (i <= 65534) {
      goto ldv_39016;
    } else {

    }
    ldv_39015: ;
  } else {

  }
  return;
}
}
int mspro_format(struct scsi_cmnd *srb , struct rtsx_chip *chip , int short_data_len ,
                 bool quick_format ) 
{ 
  struct ms_info *ms_card ;
  int retval ;
  int i ;
  u8 buf[8U] ;
  u8 tmp ;
  u16 para ;

  {
  ms_card = & chip->ms_card;
  retval = ms_switch_clock(chip);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "mspro_format", 3243);
    return (1);
  } else {

  }
  retval = ms_set_rw_reg_addr(chip, 0, 0, 23, 1);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "mspro_format", 3249);
    return (1);
  } else {

  }
  memset((void *)(& buf), 0, 2UL);
  switch (short_data_len) {
  case 32: 
  buf[0] = 0U;
  goto ldv_39032;
  case 64: 
  buf[0] = 1U;
  goto ldv_39032;
  case 128: 
  buf[0] = 2U;
  goto ldv_39032;
  case 256: ;
  default: 
  buf[0] = 3U;
  goto ldv_39032;
  }
  ldv_39032: 
  i = 0;
  goto ldv_39039;
  ldv_39038: 
  retval = ms_write_bytes(chip, 11, 1, 0, (u8 *)(& buf), 2);
  if (retval == 0) {
    goto ldv_39037;
  } else {

  }
  i = i + 1;
  ldv_39039: ;
  if (i <= 2) {
    goto ldv_39038;
  } else {

  }
  ldv_39037: ;
  if (i == 3) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "mspro_format", 3277);
    return (1);
  } else {

  }
  if ((int )quick_format) {
    para = 0U;
  } else {
    para = 1U;
  }
  retval = mspro_set_rw_cmd(chip, 0U, (int )para, 16);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "mspro_format", 3288);
    return (1);
  } else {

  }
  retval = rtsx_read_register(chip, 64834, & tmp);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "mspro_format", 3294);
    return (retval);
  } else {

  }
  if (((int )tmp & 10) != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "mspro_format", 3299);
    return (1);
  } else {

  }
  if (((int )tmp & 5) == 4) {
    ms_card->pro_under_formatting = 1;
    ms_card->progress = 0U;
    ms_card->format_status = 2;
    return (0);
  } else {

  }
  if ((int )tmp & 1) {
    ms_card->pro_under_formatting = 0;
    ms_card->progress = 0U;
    ms_card->format_status = 0;
    set_sense_type(chip, (unsigned int )(srb->device)->lun, 0);
    return (0);
  } else {

  }
  _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
              "mspro_format", 3318);
  return (1);
}
}
static int ms_read_multiple_pages(struct rtsx_chip *chip , u16 phy_blk , u16 log_blk ,
                                  u8 start_page , u8 end_page , u8 *buf , unsigned int *index ,
                                  unsigned int *offset ) 
{ 
  struct ms_info *ms_card ;
  int retval ;
  int i ;
  u8 extra[9U] ;
  u8 page_addr ;
  u8 val ;
  u8 trans_cfg ;
  u8 data[6U] ;
  u8 *ptr ;
  int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;

  {
  ms_card = & chip->ms_card;
  retval = ms_read_extra_data(chip, (int )phy_blk, (int )start_page, (u8 *)(& extra),
                              9);
  if (retval == 0) {
    if (((int )extra[1] & 48) != 48) {
      ms_set_err_code(chip, 4);
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                  "ms_read_multiple_pages", 3338);
      return (1);
    } else {

    }
  } else {

  }
  retval = ms_set_rw_reg_addr(chip, 22, 9, 16, 6);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "ms_read_multiple_pages", 3346);
    return (1);
  } else {

  }
  if (((int )ms_card->ms_type & 256) != 0) {
    data[0] = 136U;
  } else {
    data[0] = 128U;
  }
  data[1] = 0U;
  data[2] = (unsigned char )((int )phy_blk >> 8);
  data[3] = (unsigned char )phy_blk;
  data[4] = 0U;
  data[5] = start_page;
  i = 0;
  goto ldv_39062;
  ldv_39061: 
  retval = ms_write_bytes(chip, 11, 6, 0, (u8 *)(& data), 6);
  if (retval == 0) {
    goto ldv_39060;
  } else {

  }
  i = i + 1;
  ldv_39062: ;
  if (i <= 2) {
    goto ldv_39061;
  } else {

  }
  ldv_39060: ;
  if (i == 3) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "ms_read_multiple_pages", 3368);
    return (1);
  } else {

  }
  ms_set_err_code(chip, 0);
  retval = ms_send_cmd(chip, 170, 128);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "ms_read_multiple_pages", 3376);
    return (1);
  } else {

  }
  ptr = buf;
  page_addr = start_page;
  goto ldv_39064;
  ldv_39063: 
  ms_set_err_code(chip, 0);
  tmp = detect_card_cd(chip, 8);
  if (tmp != 0) {
    ms_set_err_code(chip, 32);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "ms_read_multiple_pages", 3387);
    return (1);
  } else {

  }
  retval = ms_read_bytes(chip, 7, 1, 0, & val, 1);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "ms_read_multiple_pages", 3393);
    return (1);
  } else {

  }
  if ((int )val & 1) {
    ms_set_err_code(chip, 8);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "ms_read_multiple_pages", 3399);
    return (1);
  } else {

  }
  if (((int )val & 64) != 0) {
    if (((int )val & 32) != 0) {
      retval = ms_read_status_reg(chip);
      if (retval != 0) {
        if (((int )chip->card_wp & 8) == 0) {
          reset_ms(chip);
          ms_set_page_status((int )log_blk, 1, (u8 *)(& extra), 9);
          ms_write_extra_data(chip, (int )phy_blk, (int )page_addr, (u8 *)(& extra),
                              9);
        } else {

        }
        ms_set_err_code(chip, 4);
        _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                    "ms_read_multiple_pages", 3413);
        return (1);
      } else {

      }
    } else {
      ms_set_err_code(chip, 4);
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                  "ms_read_multiple_pages", 3418);
      return (1);
    }
  } else
  if (((int )val & 32) == 0) {
    ms_set_err_code(chip, 1);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "ms_read_multiple_pages", 3424);
    return (1);
  } else {

  }
  if ((int )page_addr == (int )end_page + -1) {
    if ((int )((signed char )val) >= 0) {
      retval = ms_send_cmd(chip, 51, 128);
      if (retval != 0) {
        _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                    "ms_read_multiple_pages", 3433);
        return (1);
      } else {

      }
    } else {

    }
    retval = ms_read_bytes(chip, 7, 1, 0, & val, 1);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                  "ms_read_multiple_pages", 3441);
      return (1);
    } else {

    }
    if ((int )((signed char )val) >= 0) {
      ms_set_err_code(chip, 4);
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                  "ms_read_multiple_pages", 3447);
      return (1);
    } else {

    }
    trans_cfg = 0U;
  } else {
    trans_cfg = 128U;
  }
  chip->ci = 0;
  rtsx_add_cmd(chip, 1, 64833, 255, 2);
  rtsx_add_cmd(chip, 1, 64834, 255, (int )trans_cfg);
  rtsx_add_cmd(chip, 1, 64859, 1, 0);
  trans_dma_enable(2, chip, 512U, 32);
  rtsx_add_cmd(chip, 1, 64835, 255, 129);
  rtsx_add_cmd(chip, 2, 64835, 64, 64);
  rtsx_send_cmd_no_wait(chip);
  tmp___0 = scsi_sg_count(chip->srb);
  retval = rtsx_transfer_data_partial(chip, 8, (void *)ptr, 512UL, (int )tmp___0,
                                      index, offset, 2, chip->ms_timeout);
  if (retval < 0) {
    if (retval == -110) {
      ms_set_err_code(chip, 64);
      rtsx_clear_ms_error(chip);
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                  "ms_read_multiple_pages", 3481);
      return (2);
    } else {

    }
    retval = rtsx_read_register(chip, 64834, & val);
    if (retval != 0) {
      ms_set_err_code(chip, 64);
      rtsx_clear_ms_error(chip);
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                  "ms_read_multiple_pages", 3489);
      return (2);
    } else {

    }
    if (((int )val & 48) != 0) {
      ms_set_err_code(chip, 128);
      rtsx_clear_ms_error(chip);
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                  "ms_read_multiple_pages", 3495);
      return (1);
    } else {

    }
  } else {

  }
  tmp___1 = scsi_sg_count(chip->srb);
  if (tmp___1 == 0U) {
    ptr = ptr + 512UL;
  } else {

  }
  page_addr = (u8 )((int )page_addr + 1);
  ldv_39064: ;
  if ((int )page_addr < (int )end_page) {
    goto ldv_39063;
  } else {

  }

  return (0);
}
}
static int ms_write_multiple_pages(struct rtsx_chip *chip , u16 old_blk , u16 new_blk ,
                                   u16 log_blk , u8 start_page , u8 end_page , u8 *buf ,
                                   unsigned int *index , unsigned int *offset ) 
{ 
  struct ms_info *ms_card ;
  int retval ;
  int i ;
  u8 page_addr ;
  u8 val ;
  u8 data[16U] ;
  u8 *ptr ;
  int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;

  {
  ms_card = & chip->ms_card;
  if ((unsigned int )start_page == 0U) {
    retval = ms_set_rw_reg_addr(chip, 22, 9, 16, 7);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                  "ms_write_multiple_pages", 3521);
      return (1);
    } else {

    }
    if (((int )ms_card->ms_type & 256) != 0) {
      data[0] = 136U;
    } else {
      data[0] = 128U;
    }
    data[1] = 0U;
    data[2] = (unsigned char )((int )old_blk >> 8);
    data[3] = (unsigned char )old_blk;
    data[4] = 128U;
    data[5] = 0U;
    data[6] = 239U;
    data[7] = 255U;
    retval = ms_write_bytes(chip, 11, 7, 0, (u8 *)(& data), 8);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                  "ms_write_multiple_pages", 3541);
      return (1);
    } else {

    }
    retval = ms_send_cmd(chip, 85, 128);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                  "ms_write_multiple_pages", 3547);
      return (1);
    } else {

    }
    ms_set_err_code(chip, 0);
    retval = ms_transfer_tpc(chip, 0, 7, 1, 0);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                  "ms_write_multiple_pages", 3555);
      return (1);
    } else {

    }
  } else {

  }
  retval = ms_set_rw_reg_addr(chip, 22, 9, 16, 15);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "ms_write_multiple_pages", 3563);
    return (1);
  } else {

  }
  ms_set_err_code(chip, 0);
  if (((int )ms_card->ms_type & 256) != 0) {
    data[0] = 136U;
  } else {
    data[0] = 128U;
  }
  data[1] = 0U;
  data[2] = (unsigned char )((int )new_blk >> 8);
  data[3] = (unsigned char )new_blk;
  if ((int )end_page - (int )start_page == 1) {
    data[4] = 32U;
  } else {
    data[4] = 0U;
  }
  data[5] = start_page;
  data[6] = 248U;
  data[7] = 255U;
  data[8] = (unsigned char )((int )log_blk >> 8);
  data[9] = (unsigned char )log_blk;
  i = 10;
  goto ldv_39086;
  ldv_39085: 
  data[i] = 255U;
  i = i + 1;
  ldv_39086: ;
  if (i <= 15) {
    goto ldv_39085;
  } else {

  }
  i = 0;
  goto ldv_39090;
  ldv_39089: 
  retval = ms_write_bytes(chip, 11, 15, 0, (u8 *)(& data), 16);
  if (retval == 0) {
    goto ldv_39088;
  } else {

  }
  i = i + 1;
  ldv_39090: ;
  if (i <= 2) {
    goto ldv_39089;
  } else {

  }
  ldv_39088: ;
  if (i == 3) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "ms_write_multiple_pages", 3598);
    return (1);
  } else {

  }
  i = 0;
  goto ldv_39093;
  ldv_39092: 
  retval = ms_send_cmd(chip, 85, 128);
  if (retval == 0) {
    goto ldv_39091;
  } else {

  }
  i = i + 1;
  ldv_39093: ;
  if (i <= 2) {
    goto ldv_39092;
  } else {

  }
  ldv_39091: ;
  if (i == 3) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "ms_write_multiple_pages", 3608);
    return (1);
  } else {

  }
  retval = ms_read_bytes(chip, 7, 1, 0, & val, 1);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "ms_write_multiple_pages", 3614);
    return (1);
  } else {

  }
  ptr = buf;
  page_addr = start_page;
  goto ldv_39095;
  ldv_39094: 
  ms_set_err_code(chip, 0);
  tmp = detect_card_cd(chip, 8);
  if (tmp != 0) {
    ms_set_err_code(chip, 32);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "ms_write_multiple_pages", 3624);
    return (1);
  } else {

  }
  if ((int )val & 1) {
    ms_set_err_code(chip, 8);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "ms_write_multiple_pages", 3630);
    return (1);
  } else {

  }
  if (((int )val & 64) != 0) {
    ms_set_err_code(chip, 2);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "ms_write_multiple_pages", 3635);
    return (1);
  } else {

  }
  if (((int )val & 32) == 0) {
    ms_set_err_code(chip, 1);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "ms_write_multiple_pages", 3640);
    return (1);
  } else {

  }
  __const_udelay(128850UL);
  chip->ci = 0;
  rtsx_add_cmd(chip, 1, 64833, 255, 13);
  rtsx_add_cmd(chip, 1, 64834, 255, 128);
  rtsx_add_cmd(chip, 1, 64859, 1, 0);
  trans_dma_enable(1, chip, 512U, 32);
  rtsx_add_cmd(chip, 1, 64835, 255, 133);
  rtsx_add_cmd(chip, 2, 64835, 64, 64);
  rtsx_send_cmd_no_wait(chip);
  tmp___0 = scsi_sg_count(chip->srb);
  retval = rtsx_transfer_data_partial(chip, 8, (void *)ptr, 512UL, (int )tmp___0,
                                      index, offset, 1, chip->ms_timeout);
  if (retval < 0) {
    ms_set_err_code(chip, 64);
    rtsx_clear_ms_error(chip);
    if (retval == -110) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                  "ms_write_multiple_pages", 3673);
      return (2);
    } else {

    }
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "ms_write_multiple_pages", 3676);
    return (1);
  } else {

  }
  retval = ms_read_bytes(chip, 7, 1, 0, & val, 1);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "ms_write_multiple_pages", 3682);
    return (1);
  } else {

  }
  if ((int )end_page - (int )start_page == 1) {
    if ((int )((signed char )val) >= 0) {
      ms_set_err_code(chip, 2);
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                  "ms_write_multiple_pages", 3689);
      return (1);
    } else {

    }
  } else {
    if ((int )page_addr == (int )end_page + -1) {
      if ((int )((signed char )val) >= 0) {
        retval = ms_send_cmd(chip, 51, 128);
        if (retval != 0) {
          _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                      "ms_write_multiple_pages", 3698);
          return (1);
        } else {

        }
      } else {

      }
      retval = ms_read_bytes(chip, 7, 1, 0, & val, 1);
      if (retval != 0) {
        _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                    "ms_write_multiple_pages", 3706);
        return (1);
      } else {

      }
    } else {

    }
    if ((int )page_addr == (int )end_page + -1 || (int )ms_card->page_off == (int )page_addr) {
      if ((int )((signed char )val) >= 0) {
        ms_set_err_code(chip, 2);
        _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                    "ms_write_multiple_pages", 3716);
        return (1);
      } else {

      }
    } else {

    }
  }
  tmp___1 = scsi_sg_count(chip->srb);
  if (tmp___1 == 0U) {
    ptr = ptr + 512UL;
  } else {

  }
  page_addr = (u8 )((int )page_addr + 1);
  ldv_39095: ;
  if ((int )page_addr < (int )end_page) {
    goto ldv_39094;
  } else {

  }

  return (0);
}
}
static int ms_finish_write(struct rtsx_chip *chip , u16 old_blk , u16 new_blk , u16 log_blk ,
                           u8 page_off ) 
{ 
  struct ms_info *ms_card ;
  int retval ;
  int seg_no ;

  {
  ms_card = & chip->ms_card;
  retval = ms_copy_page(chip, (int )old_blk, (int )new_blk, (int )log_blk, (int )page_off,
                        (int )((unsigned int )ms_card->page_off + 1U));
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "ms_finish_write", 3739);
    return (1);
  } else {

  }
  seg_no = (int )old_blk >> 9;
  if ((int )((signed char )ms_card->multi_flag) < 0) {
    ms_card->multi_flag = (unsigned int )ms_card->multi_flag & 127U;
    ms_set_bad_block(chip, (int )old_blk);
  } else {
    retval = ms_erase_block(chip, (int )old_blk);
    if (retval == 0) {
      ms_set_unused_block(chip, (int )old_blk);
    } else {

    }
  }
  ms_set_l2p_tbl(chip, seg_no, (int )log_blk - (int )((u16 )ms_start_idx[seg_no]),
                 (int )new_blk);
  return (0);
}
}
static int ms_prepare_write(struct rtsx_chip *chip , u16 old_blk , u16 new_blk , u16 log_blk ,
                            u8 start_page ) 
{ 
  int retval ;

  {
  if ((unsigned int )start_page != 0U) {
    retval = ms_copy_page(chip, (int )old_blk, (int )new_blk, (int )log_blk, 0, (int )start_page);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                  "ms_prepare_write", 3768);
      return (1);
    } else {

    }
  } else {

  }
  return (0);
}
}
int ms_delay_write(struct rtsx_chip *chip ) 
{ 
  struct ms_info *ms_card ;
  struct ms_delay_write_tag *delay_write ;
  int retval ;

  {
  ms_card = & chip->ms_card;
  delay_write = & ms_card->delay_write;
  if ((unsigned int )delay_write->delay_write_flag != 0U) {
    retval = ms_set_init_para(chip);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                  "ms_delay_write", 3786);
      return (1);
    } else {

    }
    delay_write->delay_write_flag = 0U;
    retval = ms_finish_write(chip, (int )delay_write->old_phyblock, (int )delay_write->new_phyblock,
                             (int )delay_write->logblock, (int )delay_write->pageoff);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                  "ms_delay_write", 3797);
      return (1);
    } else {

    }
  } else {

  }
  return (0);
}
}
__inline static void ms_rw_fail(struct scsi_cmnd *srb , struct rtsx_chip *chip ) 
{ 


  {
  if ((unsigned int )srb->sc_data_direction == 2U) {
    set_sense_type(chip, (unsigned int )(srb->device)->lun, 7);
  } else {
    set_sense_type(chip, (unsigned int )(srb->device)->lun, 8);
  }
  return;
}
}
static int ms_rw_multi_sector(struct scsi_cmnd *srb , struct rtsx_chip *chip , u32 start_sector ,
                              u16 sector_cnt ) 
{ 
  struct ms_info *ms_card ;
  unsigned int lun ;
  int retval ;
  int seg_no ;
  unsigned int index ;
  unsigned int offset ;
  u16 old_blk ;
  u16 new_blk ;
  u16 log_blk ;
  u16 total_sec_cnt ;
  u8 start_page ;
  u8 end_page ;
  u8 page_cnt ;
  u8 *ptr ;
  struct ms_delay_write_tag *delay_write ;
  struct scatterlist *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  struct _ddebug descriptor ;
  struct device *tmp___2 ;
  long tmp___3 ;
  struct _ddebug descriptor___0 ;
  struct device *tmp___4 ;
  long tmp___5 ;
  int tmp___6 ;
  unsigned int tmp___7 ;
  struct _ddebug descriptor___1 ;
  struct device *tmp___8 ;
  long tmp___9 ;

  {
  ms_card = & chip->ms_card;
  lun = (unsigned int )(srb->device)->lun;
  index = 0U;
  offset = 0U;
  old_blk = 0U;
  new_blk = 0U;
  total_sec_cnt = sector_cnt;
  end_page = 0U;
  delay_write = & ms_card->delay_write;
  ms_set_err_code(chip, 0);
  ms_card->cleanup_counter = 0;
  tmp = scsi_sglist(srb);
  ptr = (u8 *)tmp;
  retval = ms_switch_clock(chip);
  if (retval != 0) {
    ms_rw_fail(srb, chip);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "ms_rw_multi_sector", 3838);
    return (1);
  } else {

  }
  log_blk = (unsigned short )(start_sector >> (int )ms_card->block_shift);
  start_page = (int )((unsigned char )start_sector) & (int )ms_card->page_off;
  seg_no = 0;
  goto ldv_39154;
  ldv_39153: ;
  if ((int )((unsigned short )ms_start_idx[seg_no + 1]) > (int )log_blk) {
    goto ldv_39152;
  } else {

  }
  seg_no = seg_no + 1;
  ldv_39154: ;
  if ((unsigned int )seg_no <= 15U) {
    goto ldv_39153;
  } else {

  }
  ldv_39152: ;
  if ((ms_card->segment + (unsigned long )seg_no)->build_flag == 0) {
    retval = ms_build_l2p_tbl(chip, seg_no);
    if (retval != 0) {
      chip->card_fail = (u8 )((unsigned int )chip->card_fail | 8U);
      set_sense_type(chip, lun, 2);
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                  "ms_rw_multi_sector", 3855);
      return (1);
    } else {

    }
  } else {

  }
  if ((unsigned int )srb->sc_data_direction == 1U) {
    if (((unsigned int )delay_write->delay_write_flag != 0U && (int )delay_write->logblock == (int )log_blk) && (int )delay_write->pageoff < (int )start_page) {
      delay_write->delay_write_flag = 0U;
      retval = ms_copy_page(chip, (int )delay_write->old_phyblock, (int )delay_write->new_phyblock,
                            (int )log_blk, (int )delay_write->pageoff, (int )start_page);
      if (retval != 0) {
        set_sense_type(chip, lun, 8);
        _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                    "ms_rw_multi_sector", 3873);
        return (1);
      } else {

      }
      old_blk = delay_write->old_phyblock;
      new_blk = delay_write->new_phyblock;
    } else
    if (((unsigned int )delay_write->delay_write_flag != 0U && (int )delay_write->logblock == (int )log_blk) && (int )delay_write->pageoff == (int )start_page) {
      delay_write->delay_write_flag = 0U;
      old_blk = delay_write->old_phyblock;
      new_blk = delay_write->new_phyblock;
    } else {
      retval = ms_delay_write(chip);
      if (retval != 0) {
        set_sense_type(chip, lun, 8);
        _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                    "ms_rw_multi_sector", 3889);
        return (1);
      } else {

      }
      old_blk = ms_get_l2p_tbl(chip, seg_no, (int )log_blk - (int )((u16 )ms_start_idx[seg_no]));
      new_blk = ms_get_unused_block(chip, seg_no);
      if ((unsigned int )old_blk == 65535U || (unsigned int )new_blk == 65535U) {
        set_sense_type(chip, lun, 8);
        _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                    "ms_rw_multi_sector", 3899);
        return (1);
      } else {

      }
      retval = ms_prepare_write(chip, (int )old_blk, (int )new_blk, (int )log_blk,
                                (int )start_page);
      if (retval != 0) {
        tmp___0 = detect_card_cd(chip, 8);
        if (tmp___0 != 0) {
          set_sense_type(chip, lun, 2);
          _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                      "ms_rw_multi_sector", 3909);
          return (1);
        } else {

        }
        set_sense_type(chip, lun, 8);
        _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                    "ms_rw_multi_sector", 3914);
        return (1);
      } else {

      }
    }
  } else {
    retval = ms_delay_write(chip);
    if (retval != 0) {
      tmp___1 = detect_card_cd(chip, 8);
      if (tmp___1 != 0) {
        set_sense_type(chip, lun, 2);
        _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                    "ms_rw_multi_sector", 3927);
        return (1);
      } else {

      }
      set_sense_type(chip, lun, 7);
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                  "ms_rw_multi_sector", 3932);
      return (1);
    } else {

    }
    old_blk = ms_get_l2p_tbl(chip, seg_no, (int )log_blk - (int )((u16 )ms_start_idx[seg_no]));
    if ((unsigned int )old_blk == 65535U) {
      set_sense_type(chip, lun, 7);
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                  "ms_rw_multi_sector", 3941);
      return (1);
    } else {

    }
  }
  descriptor.modname = "rts5208";
  descriptor.function = "ms_rw_multi_sector";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c";
  descriptor.format = "seg_no = %d, old_blk = 0x%x, new_blk = 0x%x\n";
  descriptor.lineno = 3947U;
  descriptor.flags = 0U;
  tmp___3 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp___3 != 0L) {
    tmp___2 = rtsx_dev((struct rtsx_chip  const  *)chip);
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)tmp___2, "seg_no = %d, old_blk = 0x%x, new_blk = 0x%x\n",
                      seg_no, (int )old_blk, (int )new_blk);
  } else {

  }
  goto ldv_39165;
  ldv_39164: ;
  if ((int )start_page + (int )total_sec_cnt > (int )ms_card->page_off + 1) {
    end_page = (unsigned int )ms_card->page_off + 1U;
  } else {
    end_page = (int )((u8 )total_sec_cnt) + (int )start_page;
  }
  page_cnt = (int )end_page - (int )start_page;
  descriptor___0.modname = "rts5208";
  descriptor___0.function = "ms_rw_multi_sector";
  descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c";
  descriptor___0.format = "start_page = %d, end_page = %d, page_cnt = %d\n";
  descriptor___0.lineno = 3958U;
  descriptor___0.flags = 0U;
  tmp___5 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
  if (tmp___5 != 0L) {
    tmp___4 = rtsx_dev((struct rtsx_chip  const  *)chip);
    __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)tmp___4, "start_page = %d, end_page = %d, page_cnt = %d\n",
                      (int )start_page, (int )end_page, (int )page_cnt);
  } else {

  }
  if ((unsigned int )srb->sc_data_direction == 2U) {
    retval = ms_read_multiple_pages(chip, (int )old_blk, (int )log_blk, (int )start_page,
                                    (int )end_page, ptr, & index, & offset);
  } else {
    retval = ms_write_multiple_pages(chip, (int )old_blk, (int )new_blk, (int )log_blk,
                                     (int )start_page, (int )end_page, ptr, & index,
                                     & offset);
  }
  if (retval != 0) {
    toggle_gpio(chip, 1);
    tmp___6 = detect_card_cd(chip, 8);
    if (tmp___6 != 0) {
      set_sense_type(chip, lun, 2);
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                  "ms_rw_multi_sector", 3975);
      return (1);
    } else {

    }
    ms_rw_fail(srb, chip);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "ms_rw_multi_sector", 3979);
    return (1);
  } else {

  }
  if ((unsigned int )srb->sc_data_direction == 1U) {
    if ((int )end_page == (int )ms_card->page_off + 1) {
      retval = ms_erase_block(chip, (int )old_blk);
      if (retval == 0) {
        ms_set_unused_block(chip, (int )old_blk);
      } else {

      }
      ms_set_l2p_tbl(chip, seg_no, (int )log_blk - (int )((u16 )ms_start_idx[seg_no]),
                     (int )new_blk);
    } else {

    }
  } else {

  }
  total_sec_cnt = (int )total_sec_cnt - (int )((u16 )page_cnt);
  tmp___7 = scsi_sg_count(srb);
  if (tmp___7 == 0U) {
    ptr = ptr + (unsigned long )((int )page_cnt * 512);
  } else {

  }
  if ((unsigned int )total_sec_cnt == 0U) {
    goto ldv_39157;
  } else {

  }
  log_blk = (u16 )((int )log_blk + 1);
  seg_no = 0;
  goto ldv_39162;
  ldv_39161: ;
  if ((int )((unsigned short )ms_start_idx[seg_no + 1]) > (int )log_blk) {
    goto ldv_39160;
  } else {

  }
  seg_no = seg_no + 1;
  ldv_39162: ;
  if ((unsigned int )seg_no <= 15U) {
    goto ldv_39161;
  } else {

  }
  ldv_39160: ;
  if ((ms_card->segment + (unsigned long )seg_no)->build_flag == 0) {
    retval = ms_build_l2p_tbl(chip, seg_no);
    if (retval != 0) {
      chip->card_fail = (u8 )((unsigned int )chip->card_fail | 8U);
      set_sense_type(chip, lun, 2);
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                  "ms_rw_multi_sector", 4016);
      return (1);
    } else {

    }
  } else {

  }
  old_blk = ms_get_l2p_tbl(chip, seg_no, (int )log_blk - (int )((u16 )ms_start_idx[seg_no]));
  if ((unsigned int )old_blk == 65535U) {
    ms_rw_fail(srb, chip);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "ms_rw_multi_sector", 4025);
    return (1);
  } else {

  }
  if ((unsigned int )srb->sc_data_direction == 1U) {
    new_blk = ms_get_unused_block(chip, seg_no);
    if ((unsigned int )new_blk == 65535U) {
      ms_rw_fail(srb, chip);
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                  "ms_rw_multi_sector", 4033);
      return (1);
    } else {

    }
  } else {

  }
  descriptor___1.modname = "rts5208";
  descriptor___1.function = "ms_rw_multi_sector";
  descriptor___1.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c";
  descriptor___1.format = "seg_no = %d, old_blk = 0x%x, new_blk = 0x%x\n";
  descriptor___1.lineno = 4039U;
  descriptor___1.flags = 0U;
  tmp___9 = ldv__builtin_expect((long )descriptor___1.flags & 1L, 0L);
  if (tmp___9 != 0L) {
    tmp___8 = rtsx_dev((struct rtsx_chip  const  *)chip);
    __dynamic_dev_dbg(& descriptor___1, (struct device  const  *)tmp___8, "seg_no = %d, old_blk = 0x%x, new_blk = 0x%x\n",
                      seg_no, (int )old_blk, (int )new_blk);
  } else {

  }
  start_page = 0U;
  ldv_39165: ;
  if ((unsigned int )total_sec_cnt != 0U) {
    goto ldv_39164;
  } else {

  }
  ldv_39157: ;
  if ((unsigned int )srb->sc_data_direction == 1U) {
    if ((int )end_page < (int )ms_card->page_off + 1) {
      delay_write->delay_write_flag = 1U;
      delay_write->old_phyblock = old_blk;
      delay_write->new_phyblock = new_blk;
      delay_write->logblock = log_blk;
      delay_write->pageoff = end_page;
    } else {

    }
  } else {

  }
  scsi_set_resid(srb, 0);
  return (0);
}
}
int ms_rw(struct scsi_cmnd *srb , struct rtsx_chip *chip , u32 start_sector , u16 sector_cnt ) 
{ 
  struct ms_info *ms_card ;
  int retval ;

  {
  ms_card = & chip->ms_card;
  if (((int )ms_card->ms_type & 255) == 1) {
    retval = mspro_rw_multi_sector(srb, chip, start_sector, (int )sector_cnt);
  } else {
    retval = ms_rw_multi_sector(srb, chip, start_sector, (int )sector_cnt);
  }
  return (retval);
}
}
void ms_free_l2p_tbl(struct rtsx_chip *chip ) 
{ 
  struct ms_info *ms_card ;
  int i ;

  {
  ms_card = & chip->ms_card;
  i = 0;
  if ((unsigned long )ms_card->segment != (unsigned long )((struct zone_entry *)0)) {
    i = 0;
    goto ldv_39180;
    ldv_39179: ;
    if ((unsigned long )(ms_card->segment + (unsigned long )i)->l2p_table != (unsigned long )((u16 *)0U)) {
      vfree((void const   *)(ms_card->segment + (unsigned long )i)->l2p_table);
      (ms_card->segment + (unsigned long )i)->l2p_table = (u16 *)0U;
    } else {

    }
    if ((unsigned long )(ms_card->segment + (unsigned long )i)->free_table != (unsigned long )((u16 *)0U)) {
      vfree((void const   *)(ms_card->segment + (unsigned long )i)->free_table);
      (ms_card->segment + (unsigned long )i)->free_table = (u16 *)0U;
    } else {

    }
    i = i + 1;
    ldv_39180: ;
    if (ms_card->segment_cnt > i) {
      goto ldv_39179;
    } else {

    }
    vfree((void const   *)ms_card->segment);
    ms_card->segment = (struct zone_entry *)0;
  } else {

  }
  return;
}
}
static int ms_poll_int(struct rtsx_chip *chip ) 
{ 
  int retval ;
  u8 val ;
  u8 *tmp ;

  {
  chip->ci = 0;
  rtsx_add_cmd(chip, 2, 64834, 1, 1);
  retval = rtsx_send_cmd(chip, 8, 5000);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "ms_poll_int", 4128);
    return (1);
  } else {

  }
  tmp = rtsx_get_cmd_data(chip);
  val = *tmp;
  if (((int )val & 2) != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "ms_poll_int", 4134);
    return (1);
  } else {

  }
  return (0);
}
}
static int check_ms_err(struct rtsx_chip *chip ) 
{ 
  int retval ;
  u8 val ;

  {
  retval = rtsx_read_register(chip, 64835, & val);
  if (retval != 0) {
    return (1);
  } else {

  }
  if (((int )val & 32) != 0) {
    return (1);
  } else {

  }
  retval = rtsx_read_register(chip, 64834, & val);
  if (retval != 0) {
    return (1);
  } else {

  }
  if (((int )val & 10) != 0) {
    return (1);
  } else {

  }
  return (0);
}
}
static int mg_send_ex_cmd(struct rtsx_chip *chip , u8 cmd , u8 entry_num ) 
{ 
  int retval ;
  int i ;
  u8 data[8U] ;
  int tmp ;

  {
  data[0] = cmd;
  data[1] = 0U;
  data[2] = 0U;
  data[3] = 0U;
  data[4] = 0U;
  data[5] = 0U;
  data[6] = entry_num;
  data[7] = 0U;
  i = 0;
  goto ldv_39203;
  ldv_39202: 
  retval = ms_write_bytes(chip, 9, 7, 128, (u8 *)(& data), 8);
  if (retval == 0) {
    goto ldv_39201;
  } else {

  }
  i = i + 1;
  ldv_39203: ;
  if (i <= 2) {
    goto ldv_39202;
  } else {

  }
  ldv_39201: ;
  if (i == 3) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "mg_send_ex_cmd", 4200);
    return (1);
  } else {

  }
  tmp = check_ms_err(chip);
  if (tmp != 0) {
    rtsx_clear_ms_error(chip);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "mg_send_ex_cmd", 4206);
    return (1);
  } else {

  }
  return (0);
}
}
static int mg_set_tpc_para_sub(struct rtsx_chip *chip , int type , u8 mg_entry_num ) 
{ 
  int retval ;
  u8 buf[6U] ;

  {
  if (type == 0) {
    retval = ms_set_rw_reg_addr(chip, 0, 0, 23, 1);
  } else {
    retval = ms_set_rw_reg_addr(chip, 0, 0, 17, 6);
  }
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "mg_set_tpc_para_sub", 4225);
    return (1);
  } else {

  }
  buf[0] = 0U;
  buf[1] = 0U;
  if (type == 1) {
    buf[2] = 0U;
    buf[3] = 0U;
    buf[4] = 0U;
    buf[5] = mg_entry_num;
  } else {

  }
  retval = ms_write_bytes(chip, 11, type == 0 ? 1 : 6, 0, (u8 *)(& buf), 6);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "mg_set_tpc_para_sub", 4240);
    return (1);
  } else {

  }
  return (0);
}
}
int mg_set_leaf_id(struct scsi_cmnd *srb , struct rtsx_chip *chip ) 
{ 
  int retval ;
  int i ;
  unsigned int lun ;
  u8 buf1[32U] ;
  u8 buf2[12U] ;
  unsigned int tmp ;
  int __min1 ;
  int __min2 ;
  unsigned int tmp___0 ;
  int tmp___1 ;

  {
  lun = (unsigned int )(srb->device)->lun;
  tmp = scsi_bufflen(srb);
  if (tmp <= 11U) {
    set_sense_type(chip, lun, 6);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "mg_set_leaf_id", 4256);
    return (1);
  } else {

  }
  ms_cleanup_work(chip);
  retval = ms_switch_clock(chip);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "mg_set_leaf_id", 4264);
    return (1);
  } else {

  }
  retval = mg_send_ex_cmd(chip, 65, 0);
  if (retval != 0) {
    set_sense_type(chip, lun, 11);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "mg_set_leaf_id", 4271);
    return (1);
  } else {

  }
  memset((void *)(& buf1), 0, 32UL);
  __min1 = 12;
  tmp___0 = scsi_bufflen(srb);
  __min2 = (int )tmp___0;
  rtsx_stor_get_xfer_buf((unsigned char *)(& buf2), (unsigned int )(__min1 < __min2 ? __min1 : __min2),
                         srb);
  i = 0;
  goto ldv_39227;
  ldv_39226: 
  buf1[i + 8] = buf2[i + 4];
  i = i + 1;
  ldv_39227: ;
  if (i <= 7) {
    goto ldv_39226;
  } else {

  }
  retval = ms_write_bytes(chip, 12, 32, 128, (u8 *)(& buf1), 32);
  if (retval != 0) {
    set_sense_type(chip, lun, 11);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "mg_set_leaf_id", 4284);
    return (1);
  } else {

  }
  tmp___1 = check_ms_err(chip);
  if (tmp___1 != 0) {
    set_sense_type(chip, lun, 11);
    rtsx_clear_ms_error(chip);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "mg_set_leaf_id", 4290);
    return (1);
  } else {

  }
  return (0);
}
}
int mg_get_local_EKB(struct scsi_cmnd *srb , struct rtsx_chip *chip ) 
{ 
  int retval ;
  int bufflen ;
    klee_make_symbolic(&bufflen, sizeof(int), "bufflen");
  unsigned int lun ;
  u8 *buf ;
  void *tmp ;
  int tmp___0 ;
  int __min1 ;
  int __min2 ;
  unsigned int tmp___1 ;

  {
  retval = 1;
  lun = (unsigned int )(srb->device)->lun;
  buf = (u8 *)0U;
  ms_cleanup_work(chip);
  retval = ms_switch_clock(chip);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "mg_get_local_EKB", 4308);
    return (1);
  } else {

  }
  tmp = kmalloc(1540UL, 208U);
  buf = (u8 *)tmp;
  if ((unsigned long )buf == (unsigned long )((u8 *)0U)) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "mg_get_local_EKB", 4314);
    return (10);
  } else {

  }
  *buf = 4U;
  *(buf + 1UL) = 26U;
  *(buf + 2UL) = 0U;
  *(buf + 3UL) = 0U;
  retval = mg_send_ex_cmd(chip, 66, 0);
  if (retval != 0) {
    set_sense_type(chip, lun, 12);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "mg_get_local_EKB", 4326);
    goto GetEKBFinish;
  } else {

  }
  retval = ms_transfer_data(chip, 8, 2, 3, 128, 0, 0, (void *)buf + 4U, 1536);
  if (retval != 0) {
    set_sense_type(chip, lun, 12);
    rtsx_clear_ms_error(chip);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "mg_get_local_EKB", 4335);
    goto GetEKBFinish;
  } else {

  }
  tmp___0 = check_ms_err(chip);
  if (tmp___0 != 0) {
    set_sense_type(chip, lun, 12);
    rtsx_clear_ms_error(chip);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "mg_get_local_EKB", 4341);
    return (1);
  } else {

  }
  __min1 = 1052;
  tmp___1 = scsi_bufflen(srb);
  __min2 = (int )tmp___1;
  bufflen = __min1 < __min2 ? __min1 : __min2;
  rtsx_stor_set_xfer_buf(buf, (unsigned int )bufflen, srb);
  GetEKBFinish: 
  kfree((void const   *)buf);
  return (retval);
}
}
int mg_chg(struct scsi_cmnd *srb , struct rtsx_chip *chip ) 
{ 
  struct ms_info *ms_card ;
  int retval ;
  int bufflen ;
  int i ;
  unsigned int lun ;
  u8 buf[32U] ;
  int tmp ;
  int __min1 ;
  int __min2 ;
  unsigned int tmp___0 ;
  int tmp___1 ;

  {
  ms_card = & chip->ms_card;
  lun = (unsigned int )(srb->device)->lun;
  ms_cleanup_work(chip);
  retval = ms_switch_clock(chip);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "mg_chg", 4366);
    return (1);
  } else {

  }
  retval = mg_send_ex_cmd(chip, 64, 0);
  if (retval != 0) {
    set_sense_type(chip, lun, 13);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "mg_chg", 4373);
    return (1);
  } else {

  }
  retval = ms_read_bytes(chip, 3, 32, 128, (u8 *)(& buf), 32);
  if (retval != 0) {
    set_sense_type(chip, lun, 13);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "mg_chg", 4381);
    return (1);
  } else {

  }
  tmp = check_ms_err(chip);
  if (tmp != 0) {
    set_sense_type(chip, lun, 13);
    rtsx_clear_ms_error(chip);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "mg_chg", 4387);
    return (1);
  } else {

  }
  memcpy((void *)(& ms_card->magic_gate_id), (void const   *)(& buf), 16UL);
  retval = ms_poll_int(chip);
  if (retval != 0) {
    set_sense_type(chip, lun, 13);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "mg_chg", 4397);
    return (1);
  } else {

  }
  retval = mg_send_ex_cmd(chip, 67, 0);
  if (retval != 0) {
    set_sense_type(chip, lun, 13);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "mg_chg", 4405);
    return (1);
  } else {

  }
  __min1 = 12;
  tmp___0 = scsi_bufflen(srb);
  __min2 = (int )tmp___0;
  bufflen = __min1 < __min2 ? __min1 : __min2;
  rtsx_stor_get_xfer_buf((unsigned char *)(& buf), (unsigned int )bufflen, srb);
  i = 0;
  goto ldv_39257;
  ldv_39256: 
  buf[i] = buf[i + 4];
  i = i + 1;
  ldv_39257: ;
  if (i <= 7) {
    goto ldv_39256;
  } else {

  }
  i = 0;
  goto ldv_39260;
  ldv_39259: 
  buf[i + 8] = 0U;
  i = i + 1;
  ldv_39260: ;
  if (i <= 23) {
    goto ldv_39259;
  } else {

  }
  retval = ms_write_bytes(chip, 12, 32, 128, (u8 *)(& buf), 32);
  if (retval != 0) {
    set_sense_type(chip, lun, 13);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "mg_chg", 4422);
    return (1);
  } else {

  }
  tmp___1 = check_ms_err(chip);
  if (tmp___1 != 0) {
    set_sense_type(chip, lun, 13);
    rtsx_clear_ms_error(chip);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "mg_chg", 4428);
    return (1);
  } else {

  }
  ms_card->mg_auth = 0;
  return (0);
}
}
int mg_get_rsp_chg(struct scsi_cmnd *srb , struct rtsx_chip *chip ) 
{ 
  struct ms_info *ms_card ;
  int retval ;
  int bufflen ;
  unsigned int lun ;
  u8 buf1[32U] ;
  u8 buf2[36U] ;
  int tmp ;
  int __min1 ;
  int __min2 ;
  unsigned int tmp___0 ;

  {
  ms_card = & chip->ms_card;
  lun = (unsigned int )(srb->device)->lun;
  ms_cleanup_work(chip);
  retval = ms_switch_clock(chip);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "mg_get_rsp_chg", 4449);
    return (1);
  } else {

  }
  retval = mg_send_ex_cmd(chip, 68, 0);
  if (retval != 0) {
    set_sense_type(chip, lun, 12);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "mg_get_rsp_chg", 4456);
    return (1);
  } else {

  }
  retval = ms_read_bytes(chip, 3, 32, 128, (u8 *)(& buf1), 32);
  if (retval != 0) {
    set_sense_type(chip, lun, 12);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "mg_get_rsp_chg", 4464);
    return (1);
  } else {

  }
  tmp = check_ms_err(chip);
  if (tmp != 0) {
    set_sense_type(chip, lun, 12);
    rtsx_clear_ms_error(chip);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "mg_get_rsp_chg", 4470);
    return (1);
  } else {

  }
  buf2[0] = 0U;
  buf2[1] = 34U;
  buf2[2] = 0U;
  buf2[3] = 0U;
  memcpy((void *)(& buf2) + 4U, (void const   *)(& ms_card->magic_gate_id), 16UL);
  memcpy((void *)(& buf2) + 20U, (void const   *)(& buf1), 16UL);
  __min1 = 36;
  tmp___0 = scsi_bufflen(srb);
  __min2 = (int )tmp___0;
  bufflen = __min1 < __min2 ? __min1 : __min2;
  rtsx_stor_set_xfer_buf((unsigned char *)(& buf2), (unsigned int )bufflen, srb);
  retval = ms_poll_int(chip);
  if (retval != 0) {
    set_sense_type(chip, lun, 12);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "mg_get_rsp_chg", 4489);
    return (1);
  } else {

  }
  return (0);
}
}
int mg_rsp(struct scsi_cmnd *srb , struct rtsx_chip *chip ) 
{ 
  struct ms_info *ms_card ;
  int retval ;
  int i ;
  int bufflen ;
  unsigned int lun ;
  u8 buf[32U] ;
  int __min1 ;
  int __min2 ;
  unsigned int tmp ;
  int tmp___0 ;

  {
  ms_card = & chip->ms_card;
  lun = (unsigned int )(srb->device)->lun;
  ms_cleanup_work(chip);
  retval = ms_switch_clock(chip);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "mg_rsp", 4510);
    return (1);
  } else {

  }
  retval = mg_send_ex_cmd(chip, 69, 0);
  if (retval != 0) {
    set_sense_type(chip, lun, 12);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "mg_rsp", 4517);
    return (1);
  } else {

  }
  __min1 = 12;
  tmp = scsi_bufflen(srb);
  __min2 = (int )tmp;
  bufflen = __min1 < __min2 ? __min1 : __min2;
  rtsx_stor_get_xfer_buf((unsigned char *)(& buf), (unsigned int )bufflen, srb);
  i = 0;
  goto ldv_39291;
  ldv_39290: 
  buf[i] = buf[i + 4];
  i = i + 1;
  ldv_39291: ;
  if (i <= 7) {
    goto ldv_39290;
  } else {

  }
  i = 0;
  goto ldv_39294;
  ldv_39293: 
  buf[i + 8] = 0U;
  i = i + 1;
  ldv_39294: ;
  if (i <= 23) {
    goto ldv_39293;
  } else {

  }
  retval = ms_write_bytes(chip, 12, 32, 128, (u8 *)(& buf), 32);
  if (retval != 0) {
    set_sense_type(chip, lun, 12);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "mg_rsp", 4534);
    return (1);
  } else {

  }
  tmp___0 = check_ms_err(chip);
  if (tmp___0 != 0) {
    set_sense_type(chip, lun, 12);
    rtsx_clear_ms_error(chip);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "mg_rsp", 4540);
    return (1);
  } else {

  }
  ms_card->mg_auth = 1;
  return (0);
}
}
int mg_get_ICV(struct scsi_cmnd *srb , struct rtsx_chip *chip ) 
{ 
  struct ms_info *ms_card ;
  int retval ;
  int bufflen ;
  unsigned int lun ;
  u8 *buf ;
  void *tmp ;
  int tmp___0 ;
  int __min1 ;
  int __min2 ;
  unsigned int tmp___1 ;

  {
  ms_card = & chip->ms_card;
  lun = (unsigned int )(srb->device)->lun;
  buf = (u8 *)0U;
  ms_cleanup_work(chip);
  retval = ms_switch_clock(chip);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "mg_get_ICV", 4561);
    return (1);
  } else {

  }
  tmp = kmalloc(1028UL, 208U);
  buf = (u8 *)tmp;
  if ((unsigned long )buf == (unsigned long )((u8 *)0U)) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "mg_get_ICV", 4567);
    return (10);
  } else {

  }
  *buf = 4U;
  *(buf + 1UL) = 2U;
  *(buf + 2UL) = 0U;
  *(buf + 3UL) = 0U;
  retval = mg_send_ex_cmd(chip, 71, (int )ms_card->mg_entry_num);
  if (retval != 0) {
    set_sense_type(chip, lun, 7);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "mg_get_ICV", 4579);
    goto GetICVFinish;
  } else {

  }
  retval = ms_transfer_data(chip, 8, 2, 2, 128, 0, 0, (void *)buf + 4U, 1024);
  if (retval != 0) {
    set_sense_type(chip, lun, 7);
    rtsx_clear_ms_error(chip);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "mg_get_ICV", 4588);
    goto GetICVFinish;
  } else {

  }
  tmp___0 = check_ms_err(chip);
  if (tmp___0 != 0) {
    set_sense_type(chip, lun, 7);
    rtsx_clear_ms_error(chip);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "mg_get_ICV", 4594);
    return (1);
  } else {

  }
  __min1 = 1028;
  tmp___1 = scsi_bufflen(srb);
  __min2 = (int )tmp___1;
  bufflen = __min1 < __min2 ? __min1 : __min2;
  rtsx_stor_set_xfer_buf(buf, (unsigned int )bufflen, srb);
  GetICVFinish: 
  kfree((void const   *)buf);
  return (retval);
}
}
int mg_set_ICV(struct scsi_cmnd *srb , struct rtsx_chip *chip ) 
{ 
  struct ms_info *ms_card ;
  int retval ;
  int bufflen ;
  int i ;
  unsigned int lun ;
  u8 *buf ;
  void *tmp ;
  int __min1 ;
  int __min2 ;
  unsigned int tmp___0 ;
  int tmp___1 ;

  {
  ms_card = & chip->ms_card;
  lun = (unsigned int )(srb->device)->lun;
  buf = (u8 *)0U;
  ms_cleanup_work(chip);
  retval = ms_switch_clock(chip);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "mg_set_ICV", 4621);
    return (1);
  } else {

  }
  tmp = kmalloc(1028UL, 208U);
  buf = (u8 *)tmp;
  if ((unsigned long )buf == (unsigned long )((u8 *)0U)) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "mg_set_ICV", 4627);
    return (10);
  } else {

  }
  __min1 = 1028;
  tmp___0 = scsi_bufflen(srb);
  __min2 = (int )tmp___0;
  bufflen = __min1 < __min2 ? __min1 : __min2;
  rtsx_stor_get_xfer_buf(buf, (unsigned int )bufflen, srb);
  retval = mg_send_ex_cmd(chip, 70, (int )ms_card->mg_entry_num);
  if (retval != 0) {
    if (ms_card->mg_auth == 0) {
      if (((int )*(buf + 5UL) & 192) != 0) {
        set_sense_type(chip, lun, 11);
      } else {
        set_sense_type(chip, lun, 14);
      }
    } else {
      set_sense_type(chip, lun, 14);
    }
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "mg_set_ICV", 4646);
    goto SetICVFinish;
  } else {

  }
  i = 0;
  goto ldv_39326;
  ldv_39325: 
  __const_udelay(214750UL);
  chip->ci = 0;
  rtsx_add_cmd(chip, 1, 64833, 255, 13);
  rtsx_add_cmd(chip, 1, 64834, 255, 128);
  rtsx_add_cmd(chip, 1, 64859, 1, 0);
  trans_dma_enable(1, chip, 512U, 32);
  rtsx_add_cmd(chip, 1, 64835, 255, 133);
  rtsx_add_cmd(chip, 2, 64835, 64, 64);
  rtsx_send_cmd_no_wait(chip);
  retval = rtsx_transfer_data(chip, 8, (void *)(buf + ((unsigned long )(i * 512) + 4UL)),
                              512UL, 0, 1, 3000);
  if (retval < 0) {
    goto _L;
  } else {
    tmp___1 = check_ms_err(chip);
    if (tmp___1 != 0) {
      _L: /* CIL Label */ 
      rtsx_clear_ms_error(chip);
      if (ms_card->mg_auth == 0) {
        if (((int )*(buf + 5UL) & 192) != 0) {
          set_sense_type(chip, lun, 11);
        } else {
          set_sense_type(chip, lun, 14);
        }
      } else {
        set_sense_type(chip, lun, 14);
      }
      retval = 1;
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                  "mg_set_ICV", 4686);
      goto SetICVFinish;
    } else {

    }
  }
  i = i + 1;
  ldv_39326: ;
  if (i <= 1) {
    goto ldv_39325;
  } else {

  }

  SetICVFinish: 
  kfree((void const   *)buf);
  return (retval);
}
}
void ms_cleanup_work(struct rtsx_chip *chip ) 
{ 
  struct ms_info *ms_card ;
  struct _ddebug descriptor ;
  struct device *tmp ;
  long tmp___0 ;
  struct _ddebug descriptor___0 ;
  struct device *tmp___1 ;
  long tmp___2 ;

  {
  ms_card = & chip->ms_card;
  if (((int )ms_card->ms_type & 255) == 1) {
    if ((unsigned int )ms_card->seq_mode != 0U) {
      descriptor.modname = "rts5208";
      descriptor.function = "ms_cleanup_work";
      descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c";
      descriptor.format = "MS Pro: stop transmission\n";
      descriptor.lineno = 4723U;
      descriptor.flags = 0U;
      tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
      if (tmp___0 != 0L) {
        tmp = rtsx_dev((struct rtsx_chip  const  *)chip);
        __dynamic_dev_dbg(& descriptor, (struct device  const  *)tmp, "MS Pro: stop transmission\n");
      } else {

      }
      mspro_stop_seq_mode(chip);
      ms_card->cleanup_counter = 0;
    } else {

    }
    if (((int )ms_card->ms_type & 255) == 1 && ((int )ms_card->ms_type & 1024) != 0) {
      rtsx_write_register(chip, 64832, 4, 0);
    } else {

    }
  } else
  if (((int )ms_card->ms_type & 255) != 1 && (unsigned int )ms_card->delay_write.delay_write_flag != 0U) {
    descriptor___0.modname = "rts5208";
    descriptor___0.function = "ms_cleanup_work";
    descriptor___0.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c";
    descriptor___0.format = "MS: delay write\n";
    descriptor___0.lineno = 4734U;
    descriptor___0.flags = 0U;
    tmp___2 = ldv__builtin_expect((long )descriptor___0.flags & 1L, 0L);
    if (tmp___2 != 0L) {
      tmp___1 = rtsx_dev((struct rtsx_chip  const  *)chip);
      __dynamic_dev_dbg(& descriptor___0, (struct device  const  *)tmp___1, "MS: delay write\n");
    } else {

    }
    ms_delay_write(chip);
    ms_card->cleanup_counter = 0;
  } else {

  }
  return;
}
}
int ms_power_off_card3v3(struct rtsx_chip *chip ) 
{ 
  int retval ;

  {
  retval = disable_card_clock(chip, 8);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "ms_power_off_card3v3", 4747);
    return (1);
  } else {

  }
  if (chip->asic_code != 0) {
    retval = ms_pull_ctl_disable(chip);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                  "ms_power_off_card3v3", 4754);
      return (1);
    } else {

    }
  } else {
    retval = rtsx_write_register(chip, 64541, 48, 16);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                  "ms_power_off_card3v3", 4762);
      return (retval);
    } else {

    }
  }
  retval = rtsx_write_register(chip, 64853, 8, 0);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "ms_power_off_card3v3", 4768);
    return (retval);
  } else {

  }
  if (chip->ft2_fast_mode == 0) {
    retval = card_power_off(chip, 8);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                  "ms_power_off_card3v3", 4774);
      return (1);
    } else {

    }
  } else {

  }
  return (0);
}
}
int release_ms_card(struct rtsx_chip *chip ) 
{ 
  struct ms_info *ms_card ;
  int retval ;

  {
  ms_card = & chip->ms_card;
  ms_card->delay_write.delay_write_flag = 0U;
  ms_card->pro_under_formatting = 0;
  chip->card_ready = (unsigned int )chip->card_ready & 247U;
  chip->card_fail = (unsigned int )chip->card_fail & 247U;
  chip->card_wp = (unsigned int )chip->card_wp & 247U;
  ms_free_l2p_tbl(chip);
  memset((void *)(& ms_card->raw_sys_info), 0, 96UL);
  memset((void *)(& ms_card->raw_model_name), 0, 48UL);
  retval = ms_power_off_card3v3(chip);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/ms.c",
                "release_ms_card", 4805);
    return (1);
  } else {

  }
  return (0);
}
}
void ldv_mutex_lock_217(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_lock_lock(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_218(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_unlock_lock(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_219(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
int ldv_mutex_trylock_220(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
  tmp = mutex_trylock(ldv_func_arg1);
  ldv_func_res = tmp;
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
  return (tmp___0);
  return (ldv_func_res);
}
}
void ldv_mutex_unlock_221(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_222(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_unlock_i_mutex_of_inode(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_223(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_lock_i_mutex_of_inode(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
int ldv_scsi_add_host_with_dma_224(struct Scsi_Host *shost , struct device *dev ,
                                   struct device *dma_dev ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  int tmp ;

  {
  tmp = scsi_add_host_with_dma(shost, dev, dma_dev);
  ldv_func_res = tmp;
  if (ldv_func_res == 0) {
    ldv_state_variable_3 = 1;
    ldv_initialize_scsi_host_template_3();
  } else {

  }
  return (ldv_func_res);
}
}
__inline static long ldv__builtin_expect(long exp , long c ) ;
int ldv_mutex_trylock_240(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_238(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_241(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_242(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_237(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_239(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_243(struct mutex *ldv_func_arg1 ) ;
int ldv_scsi_add_host_with_dma_244(struct Scsi_Host *shost , struct device *dev ,
                                   struct device *dma_dev ) ;
__inline static void rtsx_clear_spi_error(struct rtsx_chip *chip ) 
{ 


  {
  rtsx_write_register(chip, 64852, 17, 17);
  return;
}
}
__inline static void spi_set_err_code(struct rtsx_chip *chip , u8 err_code ) 
{ 
  struct spi_info *spi ;

  {
  spi = & chip->spi;
  spi->err_code = err_code;
  return;
}
}
static int spi_init(struct rtsx_chip *chip ) 
{ 
  int retval ;

  {
  retval = rtsx_write_register(chip, 64914, 255, 2);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/spi.c",
                "spi_init", 44);
    return (retval);
  } else {

  }
  retval = rtsx_write_register(chip, 64916, 3, 1);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/spi.c",
                "spi_init", 50);
    return (retval);
  } else {

  }
  return (0);
}
}
static int spi_set_init_para(struct rtsx_chip *chip ) 
{ 
  struct spi_info *spi ;
  int retval ;
  struct task_struct *tmp ;
  long volatile   __ret ;
  struct task_struct *tmp___0 ;
  struct task_struct *tmp___1 ;
  struct task_struct *tmp___2 ;
  struct task_struct *tmp___3 ;

  {
  spi = & chip->spi;
  retval = rtsx_write_register(chip, 64919, 255, (int )((unsigned char )((int )spi->clk_div >> 8)));
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/spi.c",
                "spi_set_init_para", 65);
    return (retval);
  } else {

  }
  retval = rtsx_write_register(chip, 64918, 255, (int )((unsigned char )spi->clk_div));
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/spi.c",
                "spi_set_init_para", 71);
    return (retval);
  } else {

  }
  retval = switch_clock(chip, spi->spi_clock);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/spi.c",
                "spi_set_init_para", 77);
    return (1);
  } else {

  }
  retval = select_card(chip, 128);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/spi.c",
                "spi_set_init_para", 83);
    return (1);
  } else {

  }
  retval = rtsx_write_register(chip, 64873, 16, 16);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/spi.c",
                "spi_set_init_para", 90);
    return (retval);
  } else {

  }
  retval = rtsx_write_register(chip, 64853, 16, 16);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/spi.c",
                "spi_set_init_para", 96);
    return (retval);
  } else {

  }
  tmp = get_current();
  tmp->task_state_change = 0UL;
  __ret = 1L;
  switch (8UL) {
  case 1UL: 
  tmp___0 = get_current();
  __asm__  volatile   ("xchgb %b0, %1\n": "+q" (__ret), "+m" (tmp___0->state): : "memory",
                       "cc");
  goto ldv_38234;
  case 2UL: 
  tmp___1 = get_current();
  __asm__  volatile   ("xchgw %w0, %1\n": "+r" (__ret), "+m" (tmp___1->state): : "memory",
                       "cc");
  goto ldv_38234;
  case 4UL: 
  tmp___2 = get_current();
  __asm__  volatile   ("xchgl %0, %1\n": "+r" (__ret), "+m" (tmp___2->state): : "memory",
                       "cc");
  goto ldv_38234;
  case 8UL: 
  tmp___3 = get_current();
  __asm__  volatile   ("xchgq %q0, %1\n": "+r" (__ret), "+m" (tmp___3->state): : "memory",
                       "cc");
  goto ldv_38234;
  default: 
  __xchg_wrong_size();
  }
  ldv_38234: 
  schedule_timeout(2L);
  retval = spi_init(chip);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/spi.c",
                "spi_set_init_para", 104);
    return (1);
  } else {

  }
  return (0);
}
}
static int sf_polling_status(struct rtsx_chip *chip , int msec ) 
{ 
  int retval ;

  {
  chip->ci = 0;
  rtsx_add_cmd(chip, 1, 64896, 255, 5);
  rtsx_add_cmd(chip, 1, 64912, 255, 134);
  rtsx_add_cmd(chip, 2, 64912, 64, 64);
  retval = rtsx_send_cmd(chip, 0, msec);
  if (retval < 0) {
    rtsx_clear_spi_error(chip);
    spi_set_err_code(chip, 6);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/spi.c",
                "sf_polling_status", 127);
    return (1);
  } else {

  }
  return (0);
}
}
static int sf_enable_write(struct rtsx_chip *chip , u8 ins ) 
{ 
  struct spi_info *spi ;
  int retval ;

  {
  spi = & chip->spi;
  if ((unsigned int )spi->write_en == 0U) {
    return (0);
  } else {

  }
  chip->ci = 0;
  rtsx_add_cmd(chip, 1, 64896, 255, (int )ins);
  rtsx_add_cmd(chip, 1, 64901, 255, 247);
  rtsx_add_cmd(chip, 1, 64912, 255, 128);
  rtsx_add_cmd(chip, 2, 64912, 64, 64);
  retval = rtsx_send_cmd(chip, 0, 100);
  if (retval < 0) {
    rtsx_clear_spi_error(chip);
    spi_set_err_code(chip, 1);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/spi.c",
                "sf_enable_write", 156);
    return (1);
  } else {

  }
  return (0);
}
}
static int sf_disable_write(struct rtsx_chip *chip , u8 ins ) 
{ 
  struct spi_info *spi ;
  int retval ;

  {
  spi = & chip->spi;
  if ((unsigned int )spi->write_en == 0U) {
    return (0);
  } else {

  }
  chip->ci = 0;
  rtsx_add_cmd(chip, 1, 64896, 255, (int )ins);
  rtsx_add_cmd(chip, 1, 64901, 255, 247);
  rtsx_add_cmd(chip, 1, 64912, 255, 128);
  rtsx_add_cmd(chip, 2, 64912, 64, 64);
  retval = rtsx_send_cmd(chip, 0, 100);
  if (retval < 0) {
    rtsx_clear_spi_error(chip);
    spi_set_err_code(chip, 1);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/spi.c",
                "sf_disable_write", 185);
    return (1);
  } else {

  }
  return (0);
}
}
static void sf_program(struct rtsx_chip *chip , u8 ins , u8 addr_mode , u32 addr ,
                       u16 len ) 
{ 


  {
  rtsx_add_cmd(chip, 1, 64896, 255, (int )ins);
  rtsx_add_cmd(chip, 1, 64901, 255, 247);
  rtsx_add_cmd(chip, 1, 64902, 255, (int )((unsigned char )len));
  rtsx_add_cmd(chip, 1, 64903, 255, (int )((unsigned char )((int )len >> 8)));
  if ((unsigned int )addr_mode != 0U) {
    rtsx_add_cmd(chip, 1, 64897, 255, (int )((unsigned char )addr));
    rtsx_add_cmd(chip, 1, 64898, 255, (int )((unsigned char )(addr >> 8)));
    rtsx_add_cmd(chip, 1, 64899, 255, (int )((unsigned char )(addr >> 16)));
    rtsx_add_cmd(chip, 1, 64912, 255, 132);
  } else {
    rtsx_add_cmd(chip, 1, 64912, 255, 130);
  }
  rtsx_add_cmd(chip, 2, 64912, 64, 64);
  return;
}
}
static int sf_erase(struct rtsx_chip *chip , u8 ins , u8 addr_mode , u32 addr ) 
{ 
  int retval ;

  {
  chip->ci = 0;
  rtsx_add_cmd(chip, 1, 64896, 255, (int )ins);
  rtsx_add_cmd(chip, 1, 64901, 255, 247);
  if ((unsigned int )addr_mode != 0U) {
    rtsx_add_cmd(chip, 1, 64897, 255, (int )((unsigned char )addr));
    rtsx_add_cmd(chip, 1, 64898, 255, (int )((unsigned char )(addr >> 8)));
    rtsx_add_cmd(chip, 1, 64899, 255, (int )((unsigned char )(addr >> 16)));
    rtsx_add_cmd(chip, 1, 64912, 255, 129);
  } else {
    rtsx_add_cmd(chip, 1, 64912, 255, 128);
  }
  rtsx_add_cmd(chip, 2, 64912, 64, 64);
  retval = rtsx_send_cmd(chip, 0, 100);
  if (retval < 0) {
    rtsx_clear_spi_error(chip);
    spi_set_err_code(chip, 1);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/spi.c",
                "sf_erase", 244);
    return (1);
  } else {

  }
  return (0);
}
}
static int spi_init_eeprom(struct rtsx_chip *chip ) 
{ 
  int retval ;
  int clk ;
    klee_make_symbolic(&clk, sizeof(int), "clk");
  struct task_struct *tmp ;
  long volatile   __ret ;
  struct task_struct *tmp___0 ;
  struct task_struct *tmp___1 ;
  struct task_struct *tmp___2 ;
  struct task_struct *tmp___3 ;

  {
  if (chip->asic_code != 0) {
    clk = 30;
  } else {
    clk = 2;
  }
  retval = rtsx_write_register(chip, 64919, 255, 0);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/spi.c",
                "spi_init_eeprom", 263);
    return (retval);
  } else {

  }
  retval = rtsx_write_register(chip, 64918, 255, 39);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/spi.c",
                "spi_init_eeprom", 268);
    return (retval);
  } else {

  }
  retval = switch_clock(chip, clk);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/spi.c",
                "spi_init_eeprom", 274);
    return (1);
  } else {

  }
  retval = select_card(chip, 128);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/spi.c",
                "spi_init_eeprom", 280);
    return (1);
  } else {

  }
  retval = rtsx_write_register(chip, 64873, 16, 16);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/spi.c",
                "spi_init_eeprom", 287);
    return (retval);
  } else {

  }
  retval = rtsx_write_register(chip, 64853, 16, 16);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/spi.c",
                "spi_init_eeprom", 293);
    return (retval);
  } else {

  }
  tmp = get_current();
  tmp->task_state_change = 0UL;
  __ret = 1L;
  switch (8UL) {
  case 1UL: 
  tmp___0 = get_current();
  __asm__  volatile   ("xchgb %b0, %1\n": "+q" (__ret), "+m" (tmp___0->state): : "memory",
                       "cc");
  goto ldv_38283;
  case 2UL: 
  tmp___1 = get_current();
  __asm__  volatile   ("xchgw %w0, %1\n": "+r" (__ret), "+m" (tmp___1->state): : "memory",
                       "cc");
  goto ldv_38283;
  case 4UL: 
  tmp___2 = get_current();
  __asm__  volatile   ("xchgl %0, %1\n": "+r" (__ret), "+m" (tmp___2->state): : "memory",
                       "cc");
  goto ldv_38283;
  case 8UL: 
  tmp___3 = get_current();
  __asm__  volatile   ("xchgq %q0, %1\n": "+r" (__ret), "+m" (tmp___3->state): : "memory",
                       "cc");
  goto ldv_38283;
  default: 
  __xchg_wrong_size();
  }
  ldv_38283: 
  schedule_timeout(2L);
  retval = rtsx_write_register(chip, 64914, 255, 67);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/spi.c",
                "spi_init_eeprom", 302);
    return (retval);
  } else {

  }
  retval = rtsx_write_register(chip, 64916, 3, 1);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/spi.c",
                "spi_init_eeprom", 308);
    return (retval);
  } else {

  }
  return (0);
}
}
static int spi_eeprom_program_enable(struct rtsx_chip *chip ) 
{ 
  int retval ;

  {
  chip->ci = 0;
  rtsx_add_cmd(chip, 1, 64901, 255, 134);
  rtsx_add_cmd(chip, 1, 64896, 255, 19);
  rtsx_add_cmd(chip, 1, 64912, 255, 129);
  rtsx_add_cmd(chip, 2, 64912, 64, 64);
  retval = rtsx_send_cmd(chip, 0, 100);
  if (retval < 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/spi.c",
                "spi_eeprom_program_enable", 330);
    return (1);
  } else {

  }
  return (0);
}
}
int spi_erase_eeprom_chip(struct rtsx_chip *chip ) 
{ 
  int retval ;

  {
  retval = spi_init_eeprom(chip);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/spi.c",
                "spi_erase_eeprom_chip", 343);
    return (1);
  } else {

  }
  retval = spi_eeprom_program_enable(chip);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/spi.c",
                "spi_erase_eeprom_chip", 349);
    return (1);
  } else {

  }
  chip->ci = 0;
  rtsx_add_cmd(chip, 1, 64855, 1, 0);
  rtsx_add_cmd(chip, 1, 64859, 1, 0);
  rtsx_add_cmd(chip, 1, 64896, 255, 18);
  rtsx_add_cmd(chip, 1, 64901, 255, 132);
  rtsx_add_cmd(chip, 1, 64912, 255, 129);
  rtsx_add_cmd(chip, 2, 64912, 64, 64);
  retval = rtsx_send_cmd(chip, 0, 100);
  if (retval < 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/spi.c",
                "spi_erase_eeprom_chip", 366);
    return (1);
  } else {

  }
  retval = rtsx_write_register(chip, 64855, 1, 1);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/spi.c",
                "spi_erase_eeprom_chip", 372);
    return (retval);
  } else {

  }
  return (0);
}
}
int spi_erase_eeprom_byte(struct rtsx_chip *chip , u16 addr ) 
{ 
  int retval ;

  {
  retval = spi_init_eeprom(chip);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/spi.c",
                "spi_erase_eeprom_byte", 385);
    return (1);
  } else {

  }
  retval = spi_eeprom_program_enable(chip);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/spi.c",
                "spi_erase_eeprom_byte", 391);
    return (1);
  } else {

  }
  chip->ci = 0;
  rtsx_add_cmd(chip, 1, 64855, 1, 0);
  rtsx_add_cmd(chip, 1, 64859, 1, 0);
  rtsx_add_cmd(chip, 1, 64896, 255, 7);
  rtsx_add_cmd(chip, 1, 64897, 255, (int )((unsigned char )addr));
  rtsx_add_cmd(chip, 1, 64898, 255, (int )((unsigned char )((int )addr >> 8)));
  rtsx_add_cmd(chip, 1, 64901, 255, 70);
  rtsx_add_cmd(chip, 1, 64912, 255, 129);
  rtsx_add_cmd(chip, 2, 64912, 64, 64);
  retval = rtsx_send_cmd(chip, 0, 100);
  if (retval < 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/spi.c",
                "spi_erase_eeprom_byte", 410);
    return (1);
  } else {

  }
  retval = rtsx_write_register(chip, 64855, 1, 1);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/spi.c",
                "spi_erase_eeprom_byte", 416);
    return (retval);
  } else {

  }
  return (0);
}
}
int spi_read_eeprom(struct rtsx_chip *chip , u16 addr , u8 *val ) 
{ 
  int retval ;
  u8 data ;
  struct task_struct *tmp ;
  long volatile   __ret ;
  struct task_struct *tmp___0 ;
  struct task_struct *tmp___1 ;
  struct task_struct *tmp___2 ;
  struct task_struct *tmp___3 ;

  {
  retval = spi_init_eeprom(chip);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/spi.c",
                "spi_read_eeprom", 431);
    return (1);
  } else {

  }
  chip->ci = 0;
  rtsx_add_cmd(chip, 1, 64855, 1, 0);
  rtsx_add_cmd(chip, 1, 64859, 1, 0);
  rtsx_add_cmd(chip, 1, 64896, 255, 6);
  rtsx_add_cmd(chip, 1, 64897, 255, (int )((unsigned char )addr));
  rtsx_add_cmd(chip, 1, 64898, 255, (int )((unsigned char )((int )addr >> 8)));
  rtsx_add_cmd(chip, 1, 64901, 255, 70);
  rtsx_add_cmd(chip, 1, 64902, 255, 1);
  rtsx_add_cmd(chip, 1, 64912, 255, 133);
  rtsx_add_cmd(chip, 2, 64912, 64, 64);
  retval = rtsx_send_cmd(chip, 0, 100);
  if (retval < 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/spi.c",
                "spi_read_eeprom", 451);
    return (1);
  } else {

  }
  tmp = get_current();
  tmp->task_state_change = 0UL;
  __ret = 1L;
  switch (8UL) {
  case 1UL: 
  tmp___0 = get_current();
  __asm__  volatile   ("xchgb %b0, %1\n": "+q" (__ret), "+m" (tmp___0->state): : "memory",
                       "cc");
  goto ldv_38315;
  case 2UL: 
  tmp___1 = get_current();
  __asm__  volatile   ("xchgw %w0, %1\n": "+r" (__ret), "+m" (tmp___1->state): : "memory",
                       "cc");
  goto ldv_38315;
  case 4UL: 
  tmp___2 = get_current();
  __asm__  volatile   ("xchgl %0, %1\n": "+r" (__ret), "+m" (tmp___2->state): : "memory",
                       "cc");
  goto ldv_38315;
  case 8UL: 
  tmp___3 = get_current();
  __asm__  volatile   ("xchgq %q0, %1\n": "+r" (__ret), "+m" (tmp___3->state): : "memory",
                       "cc");
  goto ldv_38315;
  default: 
  __xchg_wrong_size();
  }
  ldv_38315: 
  schedule_timeout(1L);
  retval = rtsx_read_register(chip, 64904, & data);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/spi.c",
                "spi_read_eeprom", 458);
    return (retval);
  } else {

  }
  if ((unsigned long )val != (unsigned long )((u8 *)0U)) {
    *val = data;
  } else {

  }
  retval = rtsx_write_register(chip, 64855, 1, 1);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/spi.c",
                "spi_read_eeprom", 467);
    return (retval);
  } else {

  }
  return (0);
}
}
int spi_write_eeprom(struct rtsx_chip *chip , u16 addr , u8 val ) 
{ 
  int retval ;

  {
  retval = spi_init_eeprom(chip);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/spi.c",
                "spi_write_eeprom", 480);
    return (1);
  } else {

  }
  retval = spi_eeprom_program_enable(chip);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/spi.c",
                "spi_write_eeprom", 486);
    return (1);
  } else {

  }
  chip->ci = 0;
  rtsx_add_cmd(chip, 1, 64855, 1, 0);
  rtsx_add_cmd(chip, 1, 64859, 1, 0);
  rtsx_add_cmd(chip, 1, 64896, 255, 5);
  rtsx_add_cmd(chip, 1, 64897, 255, (int )val);
  rtsx_add_cmd(chip, 1, 64898, 255, (int )((unsigned char )addr));
  rtsx_add_cmd(chip, 1, 64899, 255, (int )((unsigned char )((int )addr >> 8)));
  rtsx_add_cmd(chip, 1, 64901, 255, 78);
  rtsx_add_cmd(chip, 1, 64912, 255, 129);
  rtsx_add_cmd(chip, 2, 64912, 64, 64);
  retval = rtsx_send_cmd(chip, 0, 100);
  if (retval < 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/spi.c",
                "spi_write_eeprom", 506);
    return (1);
  } else {

  }
  retval = rtsx_write_register(chip, 64855, 1, 1);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/spi.c",
                "spi_write_eeprom", 512);
    return (retval);
  } else {

  }
  return (0);
}
}
int spi_get_status(struct scsi_cmnd *srb , struct rtsx_chip *chip ) 
{ 
  struct spi_info *spi ;
  struct _ddebug descriptor ;
  struct device *tmp ;
  long tmp___0 ;
  int __min1 ;
  unsigned int tmp___1 ;
  int __min2 ;
  unsigned int tmp___2 ;

  {
  spi = & chip->spi;
  descriptor.modname = "rts5208";
  descriptor.function = "spi_get_status";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/spi.c";
  descriptor.format = "spi_get_status: err_code = 0x%x\n";
  descriptor.lineno = 525U;
  descriptor.flags = 0U;
  tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp___0 != 0L) {
    tmp = rtsx_dev((struct rtsx_chip  const  *)chip);
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)tmp, "spi_get_status: err_code = 0x%x\n",
                      (int )spi->err_code);
  } else {

  }
  tmp___1 = scsi_bufflen(srb);
  __min1 = (int )tmp___1;
  __min2 = 1;
  rtsx_stor_set_xfer_buf(& spi->err_code, (unsigned int )(__min1 < __min2 ? __min1 : __min2),
                         srb);
  tmp___2 = scsi_bufflen(srb);
  scsi_set_resid(srb, (int )(tmp___2 - 1U));
  return (0);
}
}
int spi_set_parameter(struct scsi_cmnd *srb , struct rtsx_chip *chip ) 
{ 
  struct spi_info *spi ;
  struct _ddebug descriptor ;
  struct device *tmp ;
  long tmp___0 ;

  {
  spi = & chip->spi;
  spi_set_err_code(chip, 0);
  if (chip->asic_code != 0) {
    spi->spi_clock = ((int )*(srb->cmnd + 8UL) << 8) | (int )*(srb->cmnd + 9UL);
  } else {
    spi->spi_clock = (int )*(srb->cmnd + 3UL);
  }
  spi->clk_div = (u16 )((int )((short )((int )*(srb->cmnd + 4UL) << 8)) | (int )((short )*(srb->cmnd + 5UL)));
  spi->write_en = *(srb->cmnd + 6UL);
  descriptor.modname = "rts5208";
  descriptor.function = "spi_set_parameter";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/spi.c";
  descriptor.format = "spi_set_parameter: spi_clock = %d, clk_div = %d, write_en = %d\n";
  descriptor.lineno = 548U;
  descriptor.flags = 0U;
  tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp___0 != 0L) {
    tmp = rtsx_dev((struct rtsx_chip  const  *)chip);
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)tmp, "spi_set_parameter: spi_clock = %d, clk_div = %d, write_en = %d\n",
                      spi->spi_clock, (int )spi->clk_div, (int )spi->write_en);
  } else {

  }
  return (0);
}
}
int spi_read_flash_id(struct scsi_cmnd *srb , struct rtsx_chip *chip ) 
{ 
  int retval ;
  u16 len ;
  u8 *buf ;
  void *tmp ;
  unsigned int tmp___0 ;

  {
  spi_set_err_code(chip, 0);
  len = (u16 )((int )((short )((int )*(srb->cmnd + 7UL) << 8)) | (int )((short )*(srb->cmnd + 8UL)));
  if ((unsigned int )len > 512U) {
    spi_set_err_code(chip, 2);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/spi.c",
                "spi_read_flash_id", 564);
    return (1);
  } else {

  }
  retval = spi_set_init_para(chip);
  if (retval != 0) {
    spi_set_err_code(chip, 1);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/spi.c",
                "spi_read_flash_id", 571);
    return (1);
  } else {

  }
  chip->ci = 0;
  rtsx_add_cmd(chip, 1, 64859, 1, 1);
  rtsx_add_cmd(chip, 1, 64896, 255, (int )*(srb->cmnd + 3UL));
  rtsx_add_cmd(chip, 1, 64899, 255, (int )*(srb->cmnd + 4UL));
  rtsx_add_cmd(chip, 1, 64898, 255, (int )*(srb->cmnd + 5UL));
  rtsx_add_cmd(chip, 1, 64897, 255, (int )*(srb->cmnd + 6UL));
  rtsx_add_cmd(chip, 1, 64901, 255, 247);
  rtsx_add_cmd(chip, 1, 64903, 255, (int )*(srb->cmnd + 7UL));
  rtsx_add_cmd(chip, 1, 64902, 255, (int )*(srb->cmnd + 8UL));
  if ((unsigned int )len == 0U) {
    if ((unsigned int )*(srb->cmnd + 9UL) != 0U) {
      rtsx_add_cmd(chip, 1, 64912, 255, 129);
    } else {
      rtsx_add_cmd(chip, 1, 64912, 255, 128);
    }
  } else
  if ((unsigned int )*(srb->cmnd + 9UL) != 0U) {
    rtsx_add_cmd(chip, 1, 64912, 255, 133);
  } else {
    rtsx_add_cmd(chip, 1, 64912, 255, 131);
  }
  rtsx_add_cmd(chip, 2, 64912, 64, 64);
  retval = rtsx_send_cmd(chip, 0, 100);
  if (retval < 0) {
    rtsx_clear_spi_error(chip);
    spi_set_err_code(chip, 1);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/spi.c",
                "spi_read_flash_id", 614);
    return (1);
  } else {

  }
  if ((unsigned int )len != 0U) {
    tmp = kmalloc((size_t )len, 208U);
    buf = (u8 *)tmp;
    if ((unsigned long )buf == (unsigned long )((u8 *)0U)) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/spi.c",
                  "spi_read_flash_id", 621);
      return (10);
    } else {

    }
    retval = rtsx_read_ppbuf(chip, buf, (int )len);
    if (retval != 0) {
      spi_set_err_code(chip, 3);
      kfree((void const   *)buf);
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/spi.c",
                  "spi_read_flash_id", 629);
      return (1);
    } else {

    }
    tmp___0 = scsi_bufflen(srb);
    rtsx_stor_set_xfer_buf(buf, tmp___0, srb);
    scsi_set_resid(srb, 0);
    kfree((void const   *)buf);
  } else {

  }
  return (0);
}
}
int spi_read_flash(struct scsi_cmnd *srb , struct rtsx_chip *chip ) 
{ 
  int retval ;
  unsigned int index ;
  unsigned int offset ;
  u8 ins ;
  u8 slow_read ;
  u32 addr ;
  u16 len ;
  u8 *buf ;
  void *tmp ;
  u16 pagelen ;

  {
  index = 0U;
  offset = 0U;
  spi_set_err_code(chip, 0);
  ins = *(srb->cmnd + 3UL);
  addr = (((unsigned int )*(srb->cmnd + 4UL) << 16) | ((unsigned int )*(srb->cmnd + 5UL) << 8)) | (unsigned int )*(srb->cmnd + 6UL);
  len = (u16 )((int )((short )((int )*(srb->cmnd + 7UL) << 8)) | (int )((short )*(srb->cmnd + 8UL)));
  slow_read = *(srb->cmnd + 9UL);
  retval = spi_set_init_para(chip);
  if (retval != 0) {
    spi_set_err_code(chip, 1);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/spi.c",
                "spi_read_flash", 662);
    return (1);
  } else {

  }
  tmp = kmalloc(256UL, 208U);
  buf = (u8 *)tmp;
  if ((unsigned long )buf == (unsigned long )((u8 *)0U)) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/spi.c",
                "spi_read_flash", 668);
    return (10);
  } else {

  }
  goto ldv_38368;
  ldv_38367: 
  pagelen = 256U - (unsigned int )((u16 )((unsigned char )addr));
  if ((int )pagelen > (int )len) {
    pagelen = len;
  } else {

  }
  chip->ci = 0;
  trans_dma_enable(2, chip, 256U, 16);
  rtsx_add_cmd(chip, 1, 64896, 255, (int )ins);
  if ((unsigned int )slow_read != 0U) {
    rtsx_add_cmd(chip, 1, 64897, 255, (int )((unsigned char )addr));
    rtsx_add_cmd(chip, 1, 64898, 255, (int )((unsigned char )(addr >> 8)));
    rtsx_add_cmd(chip, 1, 64899, 255, (int )((unsigned char )(addr >> 16)));
    rtsx_add_cmd(chip, 1, 64901, 255, 247);
  } else {
    rtsx_add_cmd(chip, 1, 64898, 255, (int )((unsigned char )addr));
    rtsx_add_cmd(chip, 1, 64899, 255, (int )((unsigned char )(addr >> 8)));
    rtsx_add_cmd(chip, 1, 64900, 255, (int )((unsigned char )(addr >> 16)));
    rtsx_add_cmd(chip, 1, 64901, 255, 255);
  }
  rtsx_add_cmd(chip, 1, 64903, 255, (int )((unsigned char )((int )pagelen >> 8)));
  rtsx_add_cmd(chip, 1, 64902, 255, (int )((unsigned char )pagelen));
  rtsx_add_cmd(chip, 1, 64912, 255, 133);
  rtsx_add_cmd(chip, 2, 64912, 64, 64);
  rtsx_send_cmd_no_wait(chip);
  retval = rtsx_transfer_data(chip, 0, (void *)buf, (size_t )pagelen, 0, 2, 10000);
  if (retval < 0) {
    kfree((void const   *)buf);
    rtsx_clear_spi_error(chip);
    spi_set_err_code(chip, 1);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/spi.c",
                "spi_read_flash", 722);
    return (1);
  } else {

  }
  rtsx_stor_access_xfer_buf(buf, (unsigned int )pagelen, srb, & index, & offset, 0);
  addr = (u32 )pagelen + addr;
  len = (int )len - (int )pagelen;
  ldv_38368: ;
  if ((unsigned int )len != 0U) {
    goto ldv_38367;
  } else {

  }
  scsi_set_resid(srb, 0);
  kfree((void const   *)buf);
  return (0);
}
}
int spi_write_flash(struct scsi_cmnd *srb , struct rtsx_chip *chip ) 
{ 
  int retval ;
  u8 ins ;
  u8 program_mode ;
  u32 addr ;
  u16 len ;
  u8 *buf ;
  unsigned int index ;
  unsigned int offset ;
  void *tmp ;
  int first_byte ;
    klee_make_symbolic(&first_byte, sizeof(int), "first_byte");
  void *tmp___0 ;
  void *tmp___1 ;
  u16 pagelen ;

  {
  index = 0U;
  offset = 0U;
  spi_set_err_code(chip, 0);
  ins = *(srb->cmnd + 3UL);
  addr = (((unsigned int )*(srb->cmnd + 4UL) << 16) | ((unsigned int )*(srb->cmnd + 5UL) << 8)) | (unsigned int )*(srb->cmnd + 6UL);
  len = (u16 )((int )((short )((int )*(srb->cmnd + 7UL) << 8)) | (int )((short )*(srb->cmnd + 8UL)));
  program_mode = *(srb->cmnd + 9UL);
  retval = spi_set_init_para(chip);
  if (retval != 0) {
    spi_set_err_code(chip, 1);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/spi.c",
                "spi_write_flash", 759);
    return (1);
  } else {

  }
  if ((unsigned int )program_mode == 0U) {
    tmp = kmalloc(4UL, 208U);
    buf = (u8 *)tmp;
    if ((unsigned long )buf == (unsigned long )((u8 *)0U)) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/spi.c",
                  "spi_write_flash", 766);
      return (10);
    } else {

    }
    goto ldv_38384;
    ldv_38383: 
    retval = sf_enable_write(chip, 6);
    if (retval != 0) {
      kfree((void const   *)buf);
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/spi.c",
                  "spi_write_flash", 774);
      return (1);
    } else {

    }
    rtsx_stor_access_xfer_buf(buf, 1U, srb, & index, & offset, 1);
    chip->ci = 0;
    rtsx_add_cmd(chip, 1, 64859, 1, 1);
    rtsx_add_cmd(chip, 1, 64000, 255, (int )*buf);
    sf_program(chip, (int )ins, 1, addr, 1);
    retval = rtsx_send_cmd(chip, 0, 100);
    if (retval < 0) {
      kfree((void const   *)buf);
      rtsx_clear_spi_error(chip);
      spi_set_err_code(chip, 1);
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/spi.c",
                  "spi_write_flash", 794);
      return (1);
    } else {

    }
    retval = sf_polling_status(chip, 100);
    if (retval != 0) {
      kfree((void const   *)buf);
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/spi.c",
                  "spi_write_flash", 801);
      return (1);
    } else {

    }
    addr = addr + 1U;
    len = (u16 )((int )len - 1);
    ldv_38384: ;
    if ((unsigned int )len != 0U) {
      goto ldv_38383;
    } else {

    }
    kfree((void const   *)buf);
  } else
  if ((unsigned int )program_mode == 1U) {
    first_byte = 1;
    retval = sf_enable_write(chip, 6);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/spi.c",
                  "spi_write_flash", 816);
      return (1);
    } else {

    }
    tmp___0 = kmalloc(4UL, 208U);
    buf = (u8 *)tmp___0;
    if ((unsigned long )buf == (unsigned long )((u8 *)0U)) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/spi.c",
                  "spi_write_flash", 822);
      return (10);
    } else {

    }
    goto ldv_38388;
    ldv_38387: 
    rtsx_stor_access_xfer_buf(buf, 1U, srb, & index, & offset, 1);
    chip->ci = 0;
    rtsx_add_cmd(chip, 1, 64859, 1, 1);
    rtsx_add_cmd(chip, 1, 64000, 255, (int )*buf);
    if (first_byte != 0) {
      sf_program(chip, (int )ins, 1, addr, 1);
      first_byte = 0;
    } else {
      sf_program(chip, (int )ins, 0, 0U, 1);
    }
    retval = rtsx_send_cmd(chip, 0, 100);
    if (retval < 0) {
      kfree((void const   *)buf);
      rtsx_clear_spi_error(chip);
      spi_set_err_code(chip, 1);
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/spi.c",
                  "spi_write_flash", 848);
      return (1);
    } else {

    }
    retval = sf_polling_status(chip, 100);
    if (retval != 0) {
      kfree((void const   *)buf);
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/spi.c",
                  "spi_write_flash", 855);
      return (1);
    } else {

    }
    len = (u16 )((int )len - 1);
    ldv_38388: ;
    if ((unsigned int )len != 0U) {
      goto ldv_38387;
    } else {

    }
    kfree((void const   *)buf);
    retval = sf_disable_write(chip, 4);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/spi.c",
                  "spi_write_flash", 866);
      return (1);
    } else {

    }
    retval = sf_polling_status(chip, 100);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/spi.c",
                  "spi_write_flash", 872);
      return (1);
    } else {

    }
  } else
  if ((unsigned int )program_mode == 2U) {
    tmp___1 = kmalloc(256UL, 208U);
    buf = (u8 *)tmp___1;
    if ((unsigned long )buf == (unsigned long )((u8 *)0U)) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/spi.c",
                  "spi_write_flash", 878);
      return (3);
    } else {

    }
    goto ldv_38392;
    ldv_38391: 
    pagelen = 256U - (unsigned int )((u16 )((unsigned char )addr));
    if ((int )pagelen > (int )len) {
      pagelen = len;
    } else {

    }
    retval = sf_enable_write(chip, 6);
    if (retval != 0) {
      kfree((void const   *)buf);
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/spi.c",
                  "spi_write_flash", 891);
      return (1);
    } else {

    }
    chip->ci = 0;
    trans_dma_enable(1, chip, 256U, 16);
    sf_program(chip, (int )ins, 1, addr, (int )pagelen);
    rtsx_send_cmd_no_wait(chip);
    rtsx_stor_access_xfer_buf(buf, (unsigned int )pagelen, srb, & index, & offset,
                              1);
    retval = rtsx_transfer_data(chip, 0, (void *)buf, (size_t )pagelen, 0, 1, 100);
    if (retval < 0) {
      kfree((void const   *)buf);
      rtsx_clear_spi_error(chip);
      spi_set_err_code(chip, 1);
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/spi.c",
                  "spi_write_flash", 911);
      return (1);
    } else {

    }
    retval = sf_polling_status(chip, 100);
    if (retval != 0) {
      kfree((void const   *)buf);
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/spi.c",
                  "spi_write_flash", 918);
      return (1);
    } else {

    }
    addr = (u32 )pagelen + addr;
    len = (int )len - (int )pagelen;
    ldv_38392: ;
    if ((unsigned int )len != 0U) {
      goto ldv_38391;
    } else {

    }
    kfree((void const   *)buf);
  } else {
    spi_set_err_code(chip, 2);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/spi.c",
                "spi_write_flash", 929);
    return (1);
  }
  return (0);
}
}
int spi_erase_flash(struct scsi_cmnd *srb , struct rtsx_chip *chip ) 
{ 
  int retval ;
  u8 ins ;
  u8 erase_mode ;
  u32 addr ;

  {
  spi_set_err_code(chip, 0);
  ins = *(srb->cmnd + 3UL);
  addr = (((unsigned int )*(srb->cmnd + 4UL) << 16) | ((unsigned int )*(srb->cmnd + 5UL) << 8)) | (unsigned int )*(srb->cmnd + 6UL);
  erase_mode = *(srb->cmnd + 9UL);
  retval = spi_set_init_para(chip);
  if (retval != 0) {
    spi_set_err_code(chip, 1);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/spi.c",
                "spi_erase_flash", 952);
    return (1);
  } else {

  }
  if ((unsigned int )erase_mode == 0U) {
    retval = sf_enable_write(chip, 6);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/spi.c",
                  "spi_erase_flash", 959);
      return (1);
    } else {

    }
    retval = sf_erase(chip, (int )ins, 1, addr);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/spi.c",
                  "spi_erase_flash", 965);
      return (1);
    } else {

    }
  } else
  if ((unsigned int )erase_mode == 1U) {
    retval = sf_enable_write(chip, 6);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/spi.c",
                  "spi_erase_flash", 971);
      return (1);
    } else {

    }
    retval = sf_erase(chip, (int )ins, 0, 0U);
    if (retval != 0) {
      _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/spi.c",
                  "spi_erase_flash", 977);
      return (1);
    } else {

    }
  } else {
    spi_set_err_code(chip, 2);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/spi.c",
                "spi_erase_flash", 982);
    return (1);
  }
  return (0);
}
}
int spi_write_flash_status(struct scsi_cmnd *srb , struct rtsx_chip *chip ) 
{ 
  int retval ;
  u8 ins ;
  u8 status ;
  u8 ewsr ;

  {
  ins = *(srb->cmnd + 3UL);
  status = *(srb->cmnd + 4UL);
  ewsr = *(srb->cmnd + 5UL);
  retval = spi_set_init_para(chip);
  if (retval != 0) {
    spi_set_err_code(chip, 1);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/spi.c",
                "spi_write_flash_status", 1001);
    return (1);
  } else {

  }
  retval = sf_enable_write(chip, (int )ewsr);
  if (retval != 0) {
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/spi.c",
                "spi_write_flash_status", 1007);
    return (1);
  } else {

  }
  chip->ci = 0;
  rtsx_add_cmd(chip, 1, 64859, 1, 1);
  rtsx_add_cmd(chip, 1, 64896, 255, (int )ins);
  rtsx_add_cmd(chip, 1, 64901, 255, 247);
  rtsx_add_cmd(chip, 1, 64903, 255, 0);
  rtsx_add_cmd(chip, 1, 64902, 255, 1);
  rtsx_add_cmd(chip, 1, 64000, 255, (int )status);
  rtsx_add_cmd(chip, 1, 64912, 255, 130);
  rtsx_add_cmd(chip, 2, 64912, 64, 64);
  retval = rtsx_send_cmd(chip, 0, 100);
  if (retval != 0) {
    rtsx_clear_spi_error(chip);
    spi_set_err_code(chip, 1);
    _rtsx_trace(chip, "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/spi.c",
                "spi_write_flash_status", 1031);
    return (1);
  } else {

  }
  return (0);
}
}
void ldv_mutex_lock_237(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_lock_lock(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_238(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_unlock_lock(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_239(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
int ldv_mutex_trylock_240(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
  tmp = mutex_trylock(ldv_func_arg1);
  ldv_func_res = tmp;
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
  return (tmp___0);
  return (ldv_func_res);
}
}
void ldv_mutex_unlock_241(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_242(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_unlock_i_mutex_of_inode(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_243(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_lock_i_mutex_of_inode(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
int ldv_scsi_add_host_with_dma_244(struct Scsi_Host *shost , struct device *dev ,
                                   struct device *dma_dev ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  int tmp ;

  {
  tmp = scsi_add_host_with_dma(shost, dev, dma_dev);
  ldv_func_res = tmp;
  if (ldv_func_res == 0) {
    ldv_state_variable_3 = 1;
    ldv_initialize_scsi_host_template_3();
  } else {

  }
  return (ldv_func_res);
}
}
__inline static long ldv__builtin_expect(long exp , long c ) ;
extern char *strncpy(char * , char const   * , __kernel_size_t  ) ;
extern char *strrchr(char const   * , int  ) ;
__inline static char const   *kbasename(char const   *path ) 
{ 
  char const   *tail ;
  char *tmp ;

  {
  tmp = strrchr(path, 47);
  tail = (char const   *)tmp;
  return ((unsigned long )tail != (unsigned long )((char const   *)0) ? tail + 1UL : path);
}
}
int ldv_mutex_trylock_260(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_258(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_261(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_262(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_257(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_259(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_263(struct mutex *ldv_func_arg1 ) ;
extern void getnstimeofday64(struct timespec * ) ;
int ldv_scsi_add_host_with_dma_264(struct Scsi_Host *shost , struct device *dev ,
                                   struct device *dma_dev ) ;
__inline static void get_current_time(u8 *timeval_buf , int buf_len ) 
{ 
  struct timespec ts64 ;
  u32 tv_usec ;

  {
  if ((unsigned long )timeval_buf == (unsigned long )((u8 *)0U) || buf_len <= 7) {
    return;
  } else {

  }
  getnstimeofday64(& ts64);
  tv_usec = (u32 )(ts64.tv_nsec / 1000L);
  *timeval_buf = (unsigned char )(ts64.tv_sec >> 24);
  *(timeval_buf + 1UL) = (unsigned char )(ts64.tv_sec >> 16);
  *(timeval_buf + 2UL) = (unsigned char )(ts64.tv_sec >> 8);
  *(timeval_buf + 3UL) = (unsigned char )ts64.tv_sec;
  *(timeval_buf + 4UL) = (unsigned char )(tv_usec >> 24);
  *(timeval_buf + 5UL) = (unsigned char )(tv_usec >> 16);
  *(timeval_buf + 6UL) = (unsigned char )(tv_usec >> 8);
  *(timeval_buf + 7UL) = (unsigned char )tv_usec;
  return;
}
}
void _rtsx_trace(struct rtsx_chip *chip , char const   *file , char const   *func ,
                 int line ) 
{ 
  struct trace_msg_t *msg ;
  struct _ddebug descriptor ;
  struct device *tmp ;
  long tmp___0 ;

  {
  msg = (struct trace_msg_t *)(& chip->trace_msg) + (unsigned long )chip->msg_idx;
  file = kbasename(file);
  descriptor.modname = "rts5208";
  descriptor.function = "_rtsx_trace";
  descriptor.filename = "/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/7085/dscv_tempdir/dscv/ri/32_7a/drivers/staging/rts5208/trace.c";
  descriptor.format = "[%s][%s]:[%d]\n";
  descriptor.lineno = 14U;
  descriptor.flags = 0U;
  tmp___0 = ldv__builtin_expect((long )descriptor.flags & 1L, 0L);
  if (tmp___0 != 0L) {
    tmp = rtsx_dev((struct rtsx_chip  const  *)chip);
    __dynamic_dev_dbg(& descriptor, (struct device  const  *)tmp, "[%s][%s]:[%d]\n",
                      file, func, line);
  } else {

  }
  strncpy((char *)(& msg->file), file, 31UL);
  strncpy((char *)(& msg->func), func, 63UL);
  msg->line = (unsigned short )line;
  get_current_time((u8 *)(& msg->timeval_buf), 16);
  msg->valid = 1U;
  chip->msg_idx = chip->msg_idx + 1;
  if (chip->msg_idx > 63) {
    chip->msg_idx = 0;
  } else {

  }
  return;
}
}
void ldv_mutex_lock_257(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_lock_lock(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_258(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_unlock_lock(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_259(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
int ldv_mutex_trylock_260(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
  tmp = mutex_trylock(ldv_func_arg1);
  ldv_func_res = tmp;
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
  return (tmp___0);
  return (ldv_func_res);
}
}
void ldv_mutex_unlock_261(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_262(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_unlock_i_mutex_of_inode(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_263(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_lock_i_mutex_of_inode(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
int ldv_scsi_add_host_with_dma_264(struct Scsi_Host *shost , struct device *dev ,
                                   struct device *dma_dev ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  int tmp ;

  {
  tmp = scsi_add_host_with_dma(shost, dev, dma_dev);
  ldv_func_res = tmp;
  if (ldv_func_res == 0) {
    ldv_state_variable_3 = 1;
    ldv_initialize_scsi_host_template_3();
  } else {

  }
  return (ldv_func_res);
}
}
__inline static void ldv_error(void) 
{ 


  {
  ERROR: ;
  {reach_error();}
}
}
__inline static int ldv_undef_int_negative(void) 
{ 
  int ret ;
  int tmp ;

  {
  tmp = ldv_undef_int();
  ret = tmp;
  if (ret >= 0) {
    ldv_stop();
  } else {

  }
  return (ret);
}
}
bool ldv_is_err(void const   *ptr ) 
{ 


  {
  return ((unsigned long )ptr > 2012UL);
}
}
void *ldv_err_ptr(long error ) 
{ 


  {
  return ((void *)(2012L - error));
}
}
long ldv_ptr_err(void const   *ptr ) 
{ 


  {
  return ((long )(2012UL - (unsigned long )ptr));
}
}
bool ldv_is_err_or_null(void const   *ptr ) 
{ 
  bool tmp ;
  int tmp___0 ;

  {
  if ((unsigned long )ptr == (unsigned long )((void const   *)0)) {
    tmp___0 = 1;
  } else {
    tmp = ldv_is_err(ptr);
    if ((int )tmp) {
      tmp___0 = 1;
    } else {
      tmp___0 = 0;
    }
  }
  return ((bool )tmp___0);
}
}
static int ldv_mutex_dev_mutex_of_rtsx_dev  =    1;
int ldv_mutex_lock_interruptible_dev_mutex_of_rtsx_dev(struct mutex *lock ) 
{ 
  int nondetermined ;
    klee_make_symbolic(&nondetermined, sizeof(int), "nondetermined");

  {
  if (ldv_mutex_dev_mutex_of_rtsx_dev != 1) {
    ldv_error();
  } else {

  }
  nondetermined = ldv_undef_int();
  if (nondetermined != 0) {
    ldv_mutex_dev_mutex_of_rtsx_dev = 2;
    return (0);
  } else {
    return (-4);
  }
}
}
int ldv_mutex_lock_killable_dev_mutex_of_rtsx_dev(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
  if (ldv_mutex_dev_mutex_of_rtsx_dev != 1) {
    ldv_error();
  } else {

  }
  nondetermined = ldv_undef_int();
  if (nondetermined != 0) {
    ldv_mutex_dev_mutex_of_rtsx_dev = 2;
    return (0);
  } else {
    return (-4);
  }
}
}
void ldv_mutex_lock_dev_mutex_of_rtsx_dev(struct mutex *lock ) 
{ 


  {
  if (ldv_mutex_dev_mutex_of_rtsx_dev != 1) {
    ldv_error();
  } else {

  }
  ldv_mutex_dev_mutex_of_rtsx_dev = 2;
  return;
}
}
int ldv_mutex_trylock_dev_mutex_of_rtsx_dev(struct mutex *lock ) 
{ 
  int is_mutex_held_by_another_thread ;
    klee_make_symbolic(&is_mutex_held_by_another_thread, sizeof(int), "is_mutex_held_by_another_thread");

  {
  if (ldv_mutex_dev_mutex_of_rtsx_dev != 1) {
    ldv_error();
  } else {

  }
  is_mutex_held_by_another_thread = ldv_undef_int();
  if (is_mutex_held_by_another_thread != 0) {
    return (0);
  } else {
    ldv_mutex_dev_mutex_of_rtsx_dev = 2;
    return (1);
  }
}
}
int ldv_atomic_dec_and_mutex_lock_dev_mutex_of_rtsx_dev(atomic_t *cnt , struct mutex *lock ) 
{ 
  int atomic_value_after_dec ;
    klee_make_symbolic(&atomic_value_after_dec, sizeof(int), "atomic_value_after_dec");

  {
  if (ldv_mutex_dev_mutex_of_rtsx_dev != 1) {
    ldv_error();
  } else {

  }
  atomic_value_after_dec = ldv_undef_int();
  if (atomic_value_after_dec == 0) {
    ldv_mutex_dev_mutex_of_rtsx_dev = 2;
    return (1);
  } else {

  }
  return (0);
}
}
int ldv_mutex_is_locked_dev_mutex_of_rtsx_dev(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
  if (ldv_mutex_dev_mutex_of_rtsx_dev == 1) {
    nondetermined = ldv_undef_int();
    if (nondetermined != 0) {
      return (0);
    } else {
      return (1);
    }
  } else {
    return (1);
  }
}
}
void ldv_mutex_unlock_dev_mutex_of_rtsx_dev(struct mutex *lock ) 
{ 


  {
  if (ldv_mutex_dev_mutex_of_rtsx_dev != 2) {
    ldv_error();
  } else {

  }
  ldv_mutex_dev_mutex_of_rtsx_dev = 1;
  return;
}
}
void ldv_usb_lock_device_dev_mutex_of_rtsx_dev(void) 
{ 


  {
  ldv_mutex_lock_dev_mutex_of_rtsx_dev((struct mutex *)0);
  return;
}
}
int ldv_usb_trylock_device_dev_mutex_of_rtsx_dev(void) 
{ 
  int tmp ;

  {
  tmp = ldv_mutex_trylock_dev_mutex_of_rtsx_dev((struct mutex *)0);
  return (tmp);
}
}
int ldv_usb_lock_device_for_reset_dev_mutex_of_rtsx_dev(void) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  tmp___0 = ldv_undef_int();
  if (tmp___0 != 0) {
    ldv_mutex_lock_dev_mutex_of_rtsx_dev((struct mutex *)0);
    return (0);
  } else {
    tmp = ldv_undef_int_negative();
    return (tmp);
  }
}
}
void ldv_usb_unlock_device_dev_mutex_of_rtsx_dev(void) 
{ 


  {
  ldv_mutex_unlock_dev_mutex_of_rtsx_dev((struct mutex *)0);
  return;
}
}
static int ldv_mutex_i_mutex_of_inode  =    1;
int ldv_mutex_lock_interruptible_i_mutex_of_inode(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
  if (ldv_mutex_i_mutex_of_inode != 1) {
    ldv_error();
  } else {

  }
  nondetermined = ldv_undef_int();
  if (nondetermined != 0) {
    ldv_mutex_i_mutex_of_inode = 2;
    return (0);
  } else {
    return (-4);
  }
}
}
int ldv_mutex_lock_killable_i_mutex_of_inode(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
  if (ldv_mutex_i_mutex_of_inode != 1) {
    ldv_error();
  } else {

  }
  nondetermined = ldv_undef_int();
  if (nondetermined != 0) {
    ldv_mutex_i_mutex_of_inode = 2;
    return (0);
  } else {
    return (-4);
  }
}
}
void ldv_mutex_lock_i_mutex_of_inode(struct mutex *lock ) 
{ 


  {
  if (ldv_mutex_i_mutex_of_inode != 1) {
    ldv_error();
  } else {

  }
  ldv_mutex_i_mutex_of_inode = 2;
  return;
}
}
int ldv_mutex_trylock_i_mutex_of_inode(struct mutex *lock ) 
{ 
  int is_mutex_held_by_another_thread ;

  {
  if (ldv_mutex_i_mutex_of_inode != 1) {
    ldv_error();
  } else {

  }
  is_mutex_held_by_another_thread = ldv_undef_int();
  if (is_mutex_held_by_another_thread != 0) {
    return (0);
  } else {
    ldv_mutex_i_mutex_of_inode = 2;
    return (1);
  }
}
}
int ldv_atomic_dec_and_mutex_lock_i_mutex_of_inode(atomic_t *cnt , struct mutex *lock ) 
{ 
  int atomic_value_after_dec ;

  {
  if (ldv_mutex_i_mutex_of_inode != 1) {
    ldv_error();
  } else {

  }
  atomic_value_after_dec = ldv_undef_int();
  if (atomic_value_after_dec == 0) {
    ldv_mutex_i_mutex_of_inode = 2;
    return (1);
  } else {

  }
  return (0);
}
}
int ldv_mutex_is_locked_i_mutex_of_inode(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
  if (ldv_mutex_i_mutex_of_inode == 1) {
    nondetermined = ldv_undef_int();
    if (nondetermined != 0) {
      return (0);
    } else {
      return (1);
    }
  } else {
    return (1);
  }
}
}
void ldv_mutex_unlock_i_mutex_of_inode(struct mutex *lock ) 
{ 


  {
  if (ldv_mutex_i_mutex_of_inode != 2) {
    ldv_error();
  } else {

  }
  ldv_mutex_i_mutex_of_inode = 1;
  return;
}
}
void ldv_usb_lock_device_i_mutex_of_inode(void) 
{ 


  {
  ldv_mutex_lock_i_mutex_of_inode((struct mutex *)0);
  return;
}
}
int ldv_usb_trylock_device_i_mutex_of_inode(void) 
{ 
  int tmp ;

  {
  tmp = ldv_mutex_trylock_i_mutex_of_inode((struct mutex *)0);
  return (tmp);
}
}
int ldv_usb_lock_device_for_reset_i_mutex_of_inode(void) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  tmp___0 = ldv_undef_int();
  if (tmp___0 != 0) {
    ldv_mutex_lock_i_mutex_of_inode((struct mutex *)0);
    return (0);
  } else {
    tmp = ldv_undef_int_negative();
    return (tmp);
  }
}
}
void ldv_usb_unlock_device_i_mutex_of_inode(void) 
{ 


  {
  ldv_mutex_unlock_i_mutex_of_inode((struct mutex *)0);
  return;
}
}
static int ldv_mutex_lock  =    1;
int ldv_mutex_lock_interruptible_lock(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
  if (ldv_mutex_lock != 1) {
    ldv_error();
  } else {

  }
  nondetermined = ldv_undef_int();
  if (nondetermined != 0) {
    ldv_mutex_lock = 2;
    return (0);
  } else {
    return (-4);
  }
}
}
int ldv_mutex_lock_killable_lock(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
  if (ldv_mutex_lock != 1) {
    ldv_error();
  } else {

  }
  nondetermined = ldv_undef_int();
  if (nondetermined != 0) {
    ldv_mutex_lock = 2;
    return (0);
  } else {
    return (-4);
  }
}
}
void ldv_mutex_lock_lock(struct mutex *lock ) 
{ 


  {
  if (ldv_mutex_lock != 1) {
    ldv_error();
  } else {

  }
  ldv_mutex_lock = 2;
  return;
}
}
int ldv_mutex_trylock_lock(struct mutex *lock ) 
{ 
  int is_mutex_held_by_another_thread ;

  {
  if (ldv_mutex_lock != 1) {
    ldv_error();
  } else {

  }
  is_mutex_held_by_another_thread = ldv_undef_int();
  if (is_mutex_held_by_another_thread != 0) {
    return (0);
  } else {
    ldv_mutex_lock = 2;
    return (1);
  }
}
}
int ldv_atomic_dec_and_mutex_lock_lock(atomic_t *cnt , struct mutex *lock ) 
{ 
  int atomic_value_after_dec ;

  {
  if (ldv_mutex_lock != 1) {
    ldv_error();
  } else {

  }
  atomic_value_after_dec = ldv_undef_int();
  if (atomic_value_after_dec == 0) {
    ldv_mutex_lock = 2;
    return (1);
  } else {

  }
  return (0);
}
}
int ldv_mutex_is_locked_lock(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
  if (ldv_mutex_lock == 1) {
    nondetermined = ldv_undef_int();
    if (nondetermined != 0) {
      return (0);
    } else {
      return (1);
    }
  } else {
    return (1);
  }
}
}
void ldv_mutex_unlock_lock(struct mutex *lock ) 
{ 


  {
  if (ldv_mutex_lock != 2) {
    ldv_error();
  } else {

  }
  ldv_mutex_lock = 1;
  return;
}
}
void ldv_usb_lock_device_lock(void) 
{ 


  {
  ldv_mutex_lock_lock((struct mutex *)0);
  return;
}
}
int ldv_usb_trylock_device_lock(void) 
{ 
  int tmp ;

  {
  tmp = ldv_mutex_trylock_lock((struct mutex *)0);
  return (tmp);
}
}
int ldv_usb_lock_device_for_reset_lock(void) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  tmp___0 = ldv_undef_int();
  if (tmp___0 != 0) {
    ldv_mutex_lock_lock((struct mutex *)0);
    return (0);
  } else {
    tmp = ldv_undef_int_negative();
    return (tmp);
  }
}
}
void ldv_usb_unlock_device_lock(void) 
{ 


  {
  ldv_mutex_unlock_lock((struct mutex *)0);
  return;
}
}
static int ldv_mutex_mutex_of_device  =    1;
int ldv_mutex_lock_interruptible_mutex_of_device(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
  if (ldv_mutex_mutex_of_device != 1) {
    ldv_error();
  } else {

  }
  nondetermined = ldv_undef_int();
  if (nondetermined != 0) {
    ldv_mutex_mutex_of_device = 2;
    return (0);
  } else {
    return (-4);
  }
}
}
int ldv_mutex_lock_killable_mutex_of_device(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
  if (ldv_mutex_mutex_of_device != 1) {
    ldv_error();
  } else {

  }
  nondetermined = ldv_undef_int();
  if (nondetermined != 0) {
    ldv_mutex_mutex_of_device = 2;
    return (0);
  } else {
    return (-4);
  }
}
}
void ldv_mutex_lock_mutex_of_device(struct mutex *lock ) 
{ 


  {
  if (ldv_mutex_mutex_of_device != 1) {
    ldv_error();
  } else {

  }
  ldv_mutex_mutex_of_device = 2;
  return;
}
}
int ldv_mutex_trylock_mutex_of_device(struct mutex *lock ) 
{ 
  int is_mutex_held_by_another_thread ;

  {
  if (ldv_mutex_mutex_of_device != 1) {
    ldv_error();
  } else {

  }
  is_mutex_held_by_another_thread = ldv_undef_int();
  if (is_mutex_held_by_another_thread != 0) {
    return (0);
  } else {
    ldv_mutex_mutex_of_device = 2;
    return (1);
  }
}
}
int ldv_atomic_dec_and_mutex_lock_mutex_of_device(atomic_t *cnt , struct mutex *lock ) 
{ 
  int atomic_value_after_dec ;

  {
  if (ldv_mutex_mutex_of_device != 1) {
    ldv_error();
  } else {

  }
  atomic_value_after_dec = ldv_undef_int();
  if (atomic_value_after_dec == 0) {
    ldv_mutex_mutex_of_device = 2;
    return (1);
  } else {

  }
  return (0);
}
}
int ldv_mutex_is_locked_mutex_of_device(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
  if (ldv_mutex_mutex_of_device == 1) {
    nondetermined = ldv_undef_int();
    if (nondetermined != 0) {
      return (0);
    } else {
      return (1);
    }
  } else {
    return (1);
  }
}
}
void ldv_mutex_unlock_mutex_of_device(struct mutex *lock ) 
{ 


  {
  if (ldv_mutex_mutex_of_device != 2) {
    ldv_error();
  } else {

  }
  ldv_mutex_mutex_of_device = 1;
  return;
}
}
void ldv_usb_lock_device_mutex_of_device(void) 
{ 


  {
  ldv_mutex_lock_mutex_of_device((struct mutex *)0);
  return;
}
}
int ldv_usb_trylock_device_mutex_of_device(void) 
{ 
  int tmp ;

  {
  tmp = ldv_mutex_trylock_mutex_of_device((struct mutex *)0);
  return (tmp);
}
}
int ldv_usb_lock_device_for_reset_mutex_of_device(void) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  tmp___0 = ldv_undef_int();
  if (tmp___0 != 0) {
    ldv_mutex_lock_mutex_of_device((struct mutex *)0);
    return (0);
  } else {
    tmp = ldv_undef_int_negative();
    return (tmp);
  }
}
}
void ldv_usb_unlock_device_mutex_of_device(void) 
{ 


  {
  ldv_mutex_unlock_mutex_of_device((struct mutex *)0);
  return;
}
}
void ldv_check_final_state(void) 
{ 


  {
  if (ldv_mutex_dev_mutex_of_rtsx_dev != 1) {
    ldv_error();
  } else {

  }
  if (ldv_mutex_i_mutex_of_inode != 1) {
    ldv_error();
  } else {

  }
  if (ldv_mutex_lock != 1) {
    ldv_error();
  } else {

  }
  if (ldv_mutex_mutex_of_device != 1) {
    ldv_error();
  } else {

  }
  return;
}
}
#include "model/linux-4.2-rc1.tar.xz-32_7a-drivers--staging--rts5208--rts5208.ko-entry_point_true-unreach-call.cil.out.env.c"
#include <klee/klee.h>
#include "model/common.env.c"
