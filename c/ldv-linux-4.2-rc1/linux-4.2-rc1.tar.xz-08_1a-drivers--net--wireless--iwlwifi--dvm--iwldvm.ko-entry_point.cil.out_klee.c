extern void abort(void);
#include <assert.h>
void reach_error() { assert(0); }
/* Generated by CIL v. 1.5.1 */
/* print_CIL_Input is false */

typedef unsigned char __u8;
    klee_make_symbolic(&__u8, sizeof(char), "__u8");
typedef unsigned short __u16;
    klee_make_symbolic(&__u16, sizeof(short), "__u16");
typedef int __s32;
    klee_make_symbolic(&__s32, sizeof(int), "__s32");
typedef unsigned int __u32;
    klee_make_symbolic(&__u32, sizeof(int), "__u32");
typedef unsigned long long __u64;
    klee_make_symbolic(&__u64, sizeof(long), "__u64");
typedef signed char s8;
    klee_make_symbolic(&s8, sizeof(char), "s8");
typedef unsigned char u8;
    klee_make_symbolic(&u8, sizeof(char), "u8");
typedef unsigned short u16;
    klee_make_symbolic(&u16, sizeof(short), "u16");
typedef int s32;
    klee_make_symbolic(&s32, sizeof(int), "s32");
typedef unsigned int u32;
    klee_make_symbolic(&u32, sizeof(int), "u32");
typedef long long s64;
    klee_make_symbolic(&s64, sizeof(long), "s64");
typedef unsigned long long u64;
    klee_make_symbolic(&u64, sizeof(long), "u64");
typedef long __kernel_long_t;
    klee_make_symbolic(&__kernel_long_t, sizeof(long), "__kernel_long_t");
typedef unsigned long __kernel_ulong_t;
    klee_make_symbolic(&__kernel_ulong_t, sizeof(long), "__kernel_ulong_t");
typedef int __kernel_pid_t;
    klee_make_symbolic(&__kernel_pid_t, sizeof(int), "__kernel_pid_t");
typedef unsigned int __kernel_uid32_t;
    klee_make_symbolic(&__kernel_uid32_t, sizeof(int), "__kernel_uid32_t");
typedef unsigned int __kernel_gid32_t;
    klee_make_symbolic(&__kernel_gid32_t, sizeof(int), "__kernel_gid32_t");
typedef __kernel_ulong_t __kernel_size_t;
typedef __kernel_long_t __kernel_ssize_t;
typedef long long __kernel_loff_t;
    klee_make_symbolic(&__kernel_loff_t, sizeof(long), "__kernel_loff_t");
typedef __kernel_long_t __kernel_time_t;
typedef __kernel_long_t __kernel_clock_t;
typedef int __kernel_timer_t;
    klee_make_symbolic(&__kernel_timer_t, sizeof(int), "__kernel_timer_t");
typedef int __kernel_clockid_t;
    klee_make_symbolic(&__kernel_clockid_t, sizeof(int), "__kernel_clockid_t");
typedef __u16 __le16;
typedef __u16 __be16;
typedef __u32 __le32;
typedef __u32 __be32;
typedef __u64 __le64;
typedef __u32 __wsum;
struct kernel_symbol {
   unsigned long value ;
    klee_make_symbolic(&value, sizeof(long), "value");
   char const   *name ;
};
struct module;
typedef __u32 __kernel_dev_t;
typedef __kernel_dev_t dev_t;
typedef unsigned short umode_t;
    klee_make_symbolic(&umode_t, sizeof(short), "umode_t");
typedef __kernel_pid_t pid_t;
typedef __kernel_clockid_t clockid_t;
typedef _Bool bool;
typedef __kernel_uid32_t uid_t;
typedef __kernel_gid32_t gid_t;
typedef __kernel_loff_t loff_t;
typedef __kernel_size_t size_t;
typedef __kernel_ssize_t ssize_t;
typedef __kernel_time_t time_t;
typedef __s32 int32_t;
typedef __u8 uint8_t;
typedef __u32 uint32_t;
typedef __u64 uint64_t;
typedef unsigned long sector_t;
    klee_make_symbolic(&sector_t, sizeof(long), "sector_t");
typedef unsigned long blkcnt_t;
    klee_make_symbolic(&blkcnt_t, sizeof(long), "blkcnt_t");
typedef u64 dma_addr_t;
typedef unsigned int gfp_t;
    klee_make_symbolic(&gfp_t, sizeof(int), "gfp_t");
typedef unsigned int fmode_t;
    klee_make_symbolic(&fmode_t, sizeof(int), "fmode_t");
typedef unsigned int oom_flags_t;
    klee_make_symbolic(&oom_flags_t, sizeof(int), "oom_flags_t");
struct __anonstruct_atomic_t_6 {
   int counter ;
    klee_make_symbolic(&counter, sizeof(int), "counter");
};
typedef struct __anonstruct_atomic_t_6 atomic_t;
struct __anonstruct_atomic64_t_7 {
   long counter ;
};
typedef struct __anonstruct_atomic64_t_7 atomic64_t;
struct list_head {
   struct list_head *next ;
   struct list_head *prev ;
};
struct hlist_node;
struct hlist_head {
   struct hlist_node *first ;
};
struct hlist_node {
   struct hlist_node *next ;
   struct hlist_node **pprev ;
};
struct callback_head {
   struct callback_head *next ;
   void (*func)(struct callback_head * ) ;
};
struct pt_regs {
   unsigned long r15 ;
    klee_make_symbolic(&r15, sizeof(long), "r15");
   unsigned long r14 ;
    klee_make_symbolic(&r14, sizeof(long), "r14");
   unsigned long r13 ;
    klee_make_symbolic(&r13, sizeof(long), "r13");
   unsigned long r12 ;
    klee_make_symbolic(&r12, sizeof(long), "r12");
   unsigned long bp ;
    klee_make_symbolic(&bp, sizeof(long), "bp");
   unsigned long bx ;
    klee_make_symbolic(&bx, sizeof(long), "bx");
   unsigned long r11 ;
    klee_make_symbolic(&r11, sizeof(long), "r11");
   unsigned long r10 ;
    klee_make_symbolic(&r10, sizeof(long), "r10");
   unsigned long r9 ;
    klee_make_symbolic(&r9, sizeof(long), "r9");
   unsigned long r8 ;
    klee_make_symbolic(&r8, sizeof(long), "r8");
   unsigned long ax ;
    klee_make_symbolic(&ax, sizeof(long), "ax");
   unsigned long cx ;
    klee_make_symbolic(&cx, sizeof(long), "cx");
   unsigned long dx ;
    klee_make_symbolic(&dx, sizeof(long), "dx");
   unsigned long si ;
    klee_make_symbolic(&si, sizeof(long), "si");
   unsigned long di ;
    klee_make_symbolic(&di, sizeof(long), "di");
   unsigned long orig_ax ;
    klee_make_symbolic(&orig_ax, sizeof(long), "orig_ax");
   unsigned long ip ;
    klee_make_symbolic(&ip, sizeof(long), "ip");
   unsigned long cs ;
    klee_make_symbolic(&cs, sizeof(long), "cs");
   unsigned long flags ;
    klee_make_symbolic(&flags, sizeof(long), "flags");
   unsigned long sp ;
    klee_make_symbolic(&sp, sizeof(long), "sp");
   unsigned long ss ;
    klee_make_symbolic(&ss, sizeof(long), "ss");
};
struct __anonstruct____missing_field_name_9 {
   unsigned int a ;
    klee_make_symbolic(&a, sizeof(int), "a");
   unsigned int b ;
    klee_make_symbolic(&b, sizeof(int), "b");
};
struct __anonstruct____missing_field_name_10 {
   u16 limit0 ;
   u16 base0 ;
   unsigned char base1 ;
    klee_make_symbolic(&base1, sizeof(char), "base1");
   unsigned char type : 4 ;
   unsigned char s : 1 ;
   unsigned char dpl : 2 ;
   unsigned char p : 1 ;
   unsigned char limit : 4 ;
   unsigned char avl : 1 ;
   unsigned char l : 1 ;
   unsigned char d : 1 ;
   unsigned char g : 1 ;
   unsigned char base2 ;
    klee_make_symbolic(&base2, sizeof(char), "base2");
};
union __anonunion____missing_field_name_8 {
   struct __anonstruct____missing_field_name_9 __annonCompField4 ;
   struct __anonstruct____missing_field_name_10 __annonCompField5 ;
};
struct desc_struct {
   union __anonunion____missing_field_name_8 __annonCompField6 ;
};
typedef unsigned long pteval_t;
    klee_make_symbolic(&pteval_t, sizeof(long), "pteval_t");
typedef unsigned long pgdval_t;
    klee_make_symbolic(&pgdval_t, sizeof(long), "pgdval_t");
typedef unsigned long pgprotval_t;
    klee_make_symbolic(&pgprotval_t, sizeof(long), "pgprotval_t");
struct __anonstruct_pte_t_11 {
   pteval_t pte ;
};
typedef struct __anonstruct_pte_t_11 pte_t;
struct pgprot {
   pgprotval_t pgprot ;
};
typedef struct pgprot pgprot_t;
struct __anonstruct_pgd_t_12 {
   pgdval_t pgd ;
};
typedef struct __anonstruct_pgd_t_12 pgd_t;
struct page;
typedef struct page *pgtable_t;
struct file;
struct seq_file;
struct thread_struct;
struct mm_struct;
struct task_struct;
struct cpumask;
struct paravirt_callee_save {
   void *func ;
};
struct pv_irq_ops {
   struct paravirt_callee_save save_fl ;
   struct paravirt_callee_save restore_fl ;
   struct paravirt_callee_save irq_disable ;
   struct paravirt_callee_save irq_enable ;
   void (*safe_halt)(void) ;
   void (*halt)(void) ;
   void (*adjust_exception_frame)(void) ;
};
struct qspinlock {
   atomic_t val ;
};
typedef struct qspinlock arch_spinlock_t;
struct qrwlock {
   atomic_t cnts ;
   arch_spinlock_t lock ;
};
typedef struct qrwlock arch_rwlock_t;
typedef void (*ctor_fn_t)(void);
struct device;
struct net_device;
struct file_operations;
struct completion;
struct bug_entry {
   int bug_addr_disp ;
    klee_make_symbolic(&bug_addr_disp, sizeof(int), "bug_addr_disp");
   int file_disp ;
    klee_make_symbolic(&file_disp, sizeof(int), "file_disp");
   unsigned short line ;
    klee_make_symbolic(&line, sizeof(short), "line");
   unsigned short flags ;
};
struct timespec;
struct compat_timespec;
struct __anonstruct_futex_16 {
   u32 *uaddr ;
   u32 val ;
   u32 flags ;
   u32 bitset ;
   u64 time ;
   u32 *uaddr2 ;
};
struct __anonstruct_nanosleep_17 {
   clockid_t clockid ;
   struct timespec *rmtp ;
   struct compat_timespec *compat_rmtp ;
   u64 expires ;
};
struct pollfd;
struct __anonstruct_poll_18 {
   struct pollfd *ufds ;
   int nfds ;
    klee_make_symbolic(&nfds, sizeof(int), "nfds");
   int has_timeout ;
    klee_make_symbolic(&has_timeout, sizeof(int), "has_timeout");
   unsigned long tv_sec ;
    klee_make_symbolic(&tv_sec, sizeof(long), "tv_sec");
   unsigned long tv_nsec ;
    klee_make_symbolic(&tv_nsec, sizeof(long), "tv_nsec");
};
union __anonunion____missing_field_name_15 {
   struct __anonstruct_futex_16 futex ;
   struct __anonstruct_nanosleep_17 nanosleep ;
   struct __anonstruct_poll_18 poll ;
};
struct restart_block {
   long (*fn)(struct restart_block * ) ;
   union __anonunion____missing_field_name_15 __annonCompField7 ;
};
struct kernel_vm86_regs {
   struct pt_regs pt ;
   unsigned short es ;
    klee_make_symbolic(&es, sizeof(short), "es");
   unsigned short __esh ;
    klee_make_symbolic(&__esh, sizeof(short), "__esh");
   unsigned short ds ;
    klee_make_symbolic(&ds, sizeof(short), "ds");
   unsigned short __dsh ;
    klee_make_symbolic(&__dsh, sizeof(short), "__dsh");
   unsigned short fs ;
    klee_make_symbolic(&fs, sizeof(short), "fs");
   unsigned short __fsh ;
    klee_make_symbolic(&__fsh, sizeof(short), "__fsh");
   unsigned short gs ;
    klee_make_symbolic(&gs, sizeof(short), "gs");
   unsigned short __gsh ;
    klee_make_symbolic(&__gsh, sizeof(short), "__gsh");
};
union __anonunion____missing_field_name_19 {
   struct pt_regs *regs ;
   struct kernel_vm86_regs *vm86 ;
};
struct math_emu_info {
   long ___orig_eip ;
    klee_make_symbolic(&___orig_eip, sizeof(long), "___orig_eip");
   union __anonunion____missing_field_name_19 __annonCompField8 ;
};
struct cpumask {
   unsigned long bits[128U] ;
};
typedef struct cpumask cpumask_t;
typedef struct cpumask *cpumask_var_t;
struct static_key;
struct fregs_state {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20U] ;
   u32 status ;
};
struct __anonstruct____missing_field_name_29 {
   u64 rip ;
   u64 rdp ;
};
struct __anonstruct____missing_field_name_30 {
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
};
union __anonunion____missing_field_name_28 {
   struct __anonstruct____missing_field_name_29 __annonCompField12 ;
   struct __anonstruct____missing_field_name_30 __annonCompField13 ;
};
union __anonunion____missing_field_name_31 {
   u32 padding1[12U] ;
   u32 sw_reserved[12U] ;
};
struct fxregs_state {
   u16 cwd ;
   u16 swd ;
   u16 twd ;
   u16 fop ;
   union __anonunion____missing_field_name_28 __annonCompField14 ;
   u32 mxcsr ;
   u32 mxcsr_mask ;
   u32 st_space[32U] ;
   u32 xmm_space[64U] ;
   u32 padding[12U] ;
   union __anonunion____missing_field_name_31 __annonCompField15 ;
};
struct swregs_state {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20U] ;
   u8 ftop ;
   u8 changed ;
   u8 lookahead ;
   u8 no_update ;
   u8 rm ;
   u8 alimit ;
   struct math_emu_info *info ;
   u32 entry_eip ;
};
struct xstate_header {
   u64 xfeatures ;
   u64 xcomp_bv ;
   u64 reserved[6U] ;
};
struct xregs_state {
   struct fxregs_state i387 ;
   struct xstate_header header ;
   u8 __reserved[464U] ;
};
union fpregs_state {
   struct fregs_state fsave ;
   struct fxregs_state fxsave ;
   struct swregs_state soft ;
   struct xregs_state xsave ;
};
struct fpu {
   union fpregs_state state ;
   unsigned int last_cpu ;
    klee_make_symbolic(&last_cpu, sizeof(int), "last_cpu");
   unsigned char fpstate_active ;
    klee_make_symbolic(&fpstate_active, sizeof(char), "fpstate_active");
   unsigned char fpregs_active ;
    klee_make_symbolic(&fpregs_active, sizeof(char), "fpregs_active");
   unsigned char counter ;
};
struct seq_operations;
struct perf_event;
struct thread_struct {
   struct desc_struct tls_array[3U] ;
   unsigned long sp0 ;
    klee_make_symbolic(&sp0, sizeof(long), "sp0");
   unsigned long sp ;
   unsigned short es ;
   unsigned short ds ;
   unsigned short fsindex ;
    klee_make_symbolic(&fsindex, sizeof(short), "fsindex");
   unsigned short gsindex ;
    klee_make_symbolic(&gsindex, sizeof(short), "gsindex");
   unsigned long fs ;
   unsigned long gs ;
   struct fpu fpu ;
   struct perf_event *ptrace_bps[4U] ;
   unsigned long debugreg6 ;
    klee_make_symbolic(&debugreg6, sizeof(long), "debugreg6");
   unsigned long ptrace_dr7 ;
    klee_make_symbolic(&ptrace_dr7, sizeof(long), "ptrace_dr7");
   unsigned long cr2 ;
    klee_make_symbolic(&cr2, sizeof(long), "cr2");
   unsigned long trap_nr ;
    klee_make_symbolic(&trap_nr, sizeof(long), "trap_nr");
   unsigned long error_code ;
    klee_make_symbolic(&error_code, sizeof(long), "error_code");
   unsigned long *io_bitmap_ptr ;
   unsigned long iopl ;
    klee_make_symbolic(&iopl, sizeof(long), "iopl");
   unsigned int io_bitmap_max ;
    klee_make_symbolic(&io_bitmap_max, sizeof(int), "io_bitmap_max");
};
typedef atomic64_t atomic_long_t;
typedef int pao_T__;
    klee_make_symbolic(&pao_T__, sizeof(int), "pao_T__");
typedef int pao_T_____0;
    klee_make_symbolic(&pao_T_____0, sizeof(int), "pao_T_____0");
struct lockdep_map;
struct stack_trace {
   unsigned int nr_entries ;
    klee_make_symbolic(&nr_entries, sizeof(int), "nr_entries");
   unsigned int max_entries ;
    klee_make_symbolic(&max_entries, sizeof(int), "max_entries");
   unsigned long *entries ;
   int skip ;
    klee_make_symbolic(&skip, sizeof(int), "skip");
};
struct lockdep_subclass_key {
   char __one_byte ;
    klee_make_symbolic(&__one_byte, sizeof(char), "__one_byte");
};
struct lock_class_key {
   struct lockdep_subclass_key subkeys[8U] ;
};
struct lock_class {
   struct list_head hash_entry ;
   struct list_head lock_entry ;
   struct lockdep_subclass_key *key ;
   unsigned int subclass ;
    klee_make_symbolic(&subclass, sizeof(int), "subclass");
   unsigned int dep_gen_id ;
    klee_make_symbolic(&dep_gen_id, sizeof(int), "dep_gen_id");
   unsigned long usage_mask ;
    klee_make_symbolic(&usage_mask, sizeof(long), "usage_mask");
   struct stack_trace usage_traces[13U] ;
   struct list_head locks_after ;
   struct list_head locks_before ;
   unsigned int version ;
    klee_make_symbolic(&version, sizeof(int), "version");
   unsigned long ops ;
    klee_make_symbolic(&ops, sizeof(long), "ops");
   char const   *name ;
   int name_version ;
    klee_make_symbolic(&name_version, sizeof(int), "name_version");
   unsigned long contention_point[4U] ;
   unsigned long contending_point[4U] ;
};
struct lockdep_map {
   struct lock_class_key *key ;
   struct lock_class *class_cache[2U] ;
   char const   *name ;
   int cpu ;
    klee_make_symbolic(&cpu, sizeof(int), "cpu");
   unsigned long ip ;
};
struct held_lock {
   u64 prev_chain_key ;
   unsigned long acquire_ip ;
    klee_make_symbolic(&acquire_ip, sizeof(long), "acquire_ip");
   struct lockdep_map *instance ;
   struct lockdep_map *nest_lock ;
   u64 waittime_stamp ;
   u64 holdtime_stamp ;
   unsigned short class_idx : 13 ;
   unsigned char irq_context : 2 ;
   unsigned char trylock : 1 ;
   unsigned char read : 2 ;
   unsigned char check : 1 ;
   unsigned char hardirqs_off : 1 ;
   unsigned short references : 12 ;
   unsigned int pin_count ;
    klee_make_symbolic(&pin_count, sizeof(int), "pin_count");
};
struct raw_spinlock {
   arch_spinlock_t raw_lock ;
   unsigned int magic ;
    klee_make_symbolic(&magic, sizeof(int), "magic");
   unsigned int owner_cpu ;
    klee_make_symbolic(&owner_cpu, sizeof(int), "owner_cpu");
   void *owner ;
   struct lockdep_map dep_map ;
};
typedef struct raw_spinlock raw_spinlock_t;
struct __anonstruct____missing_field_name_35 {
   u8 __padding[24U] ;
   struct lockdep_map dep_map ;
};
union __anonunion____missing_field_name_34 {
   struct raw_spinlock rlock ;
   struct __anonstruct____missing_field_name_35 __annonCompField17 ;
};
struct spinlock {
   union __anonunion____missing_field_name_34 __annonCompField18 ;
};
typedef struct spinlock spinlock_t;
struct __anonstruct_rwlock_t_36 {
   arch_rwlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
   struct lockdep_map dep_map ;
};
typedef struct __anonstruct_rwlock_t_36 rwlock_t;
struct static_key {
   atomic_t enabled ;
};
struct seqcount {
   unsigned int sequence ;
    klee_make_symbolic(&sequence, sizeof(int), "sequence");
   struct lockdep_map dep_map ;
};
typedef struct seqcount seqcount_t;
struct __anonstruct_seqlock_t_45 {
   struct seqcount seqcount ;
   spinlock_t lock ;
};
typedef struct __anonstruct_seqlock_t_45 seqlock_t;
struct timespec {
   __kernel_time_t tv_sec ;
   long tv_nsec ;
};
struct user_namespace;
struct __anonstruct_kuid_t_46 {
   uid_t val ;
};
typedef struct __anonstruct_kuid_t_46 kuid_t;
struct __anonstruct_kgid_t_47 {
   gid_t val ;
};
typedef struct __anonstruct_kgid_t_47 kgid_t;
struct kstat {
   u64 ino ;
   dev_t dev ;
   umode_t mode ;
   unsigned int nlink ;
    klee_make_symbolic(&nlink, sizeof(int), "nlink");
   kuid_t uid ;
   kgid_t gid ;
   dev_t rdev ;
   loff_t size ;
   struct timespec atime ;
   struct timespec mtime ;
   struct timespec ctime ;
   unsigned long blksize ;
    klee_make_symbolic(&blksize, sizeof(long), "blksize");
   unsigned long long blocks ;
    klee_make_symbolic(&blocks, sizeof(long), "blocks");
};
struct vm_area_struct;
struct __wait_queue_head {
   spinlock_t lock ;
   struct list_head task_list ;
};
typedef struct __wait_queue_head wait_queue_head_t;
struct __anonstruct_nodemask_t_48 {
   unsigned long bits[16U] ;
};
typedef struct __anonstruct_nodemask_t_48 nodemask_t;
struct optimistic_spin_queue {
   atomic_t tail ;
};
struct mutex {
   atomic_t count ;
   spinlock_t wait_lock ;
   struct list_head wait_list ;
   struct task_struct *owner ;
   void *magic ;
   struct lockdep_map dep_map ;
};
struct mutex_waiter {
   struct list_head list ;
   struct task_struct *task ;
   void *magic ;
};
struct rw_semaphore;
struct rw_semaphore {
   long count ;
    klee_make_symbolic(&count, sizeof(long), "count");
   struct list_head wait_list ;
   raw_spinlock_t wait_lock ;
   struct optimistic_spin_queue osq ;
   struct task_struct *owner ;
   struct lockdep_map dep_map ;
};
struct completion {
   unsigned int done ;
    klee_make_symbolic(&done, sizeof(int), "done");
   wait_queue_head_t wait ;
};
union ktime {
   s64 tv64 ;
};
typedef union ktime ktime_t;
struct notifier_block;
struct timer_list {
   struct hlist_node entry ;
   unsigned long expires ;
    klee_make_symbolic(&expires, sizeof(long), "expires");
   void (*function)(unsigned long  ) ;
   unsigned long data ;
    klee_make_symbolic(&data, sizeof(long), "data");
   u32 flags ;
   int slack ;
    klee_make_symbolic(&slack, sizeof(int), "slack");
   int start_pid ;
    klee_make_symbolic(&start_pid, sizeof(int), "start_pid");
   void *start_site ;
   char start_comm[16U] ;
   struct lockdep_map lockdep_map ;
};
struct hrtimer;
enum hrtimer_restart;
struct rb_node {
   unsigned long __rb_parent_color ;
    klee_make_symbolic(&__rb_parent_color, sizeof(long), "__rb_parent_color");
   struct rb_node *rb_right ;
   struct rb_node *rb_left ;
};
struct rb_root {
   struct rb_node *rb_node ;
};
struct ctl_table;
struct nsproxy;
struct ctl_table_root;
struct ctl_table_header;
struct ctl_dir;
typedef int proc_handler(struct ctl_table * , int  , void * , size_t * , loff_t * );
struct ctl_table_poll {
   atomic_t event ;
   wait_queue_head_t wait ;
};
struct ctl_table {
   char const   *procname ;
   void *data ;
   int maxlen ;
    klee_make_symbolic(&maxlen, sizeof(int), "maxlen");
   umode_t mode ;
   struct ctl_table *child ;
   proc_handler *proc_handler ;
   struct ctl_table_poll *poll ;
   void *extra1 ;
   void *extra2 ;
};
struct ctl_node {
   struct rb_node node ;
   struct ctl_table_header *header ;
};
struct __anonstruct____missing_field_name_50 {
   struct ctl_table *ctl_table ;
   int used ;
    klee_make_symbolic(&used, sizeof(int), "used");
   int count ;
   int nreg ;
    klee_make_symbolic(&nreg, sizeof(int), "nreg");
};
union __anonunion____missing_field_name_49 {
   struct __anonstruct____missing_field_name_50 __annonCompField19 ;
   struct callback_head rcu ;
};
struct ctl_table_set;
struct ctl_table_header {
   union __anonunion____missing_field_name_49 __annonCompField20 ;
   struct completion *unregistering ;
   struct ctl_table *ctl_table_arg ;
   struct ctl_table_root *root ;
   struct ctl_table_set *set ;
   struct ctl_dir *parent ;
   struct ctl_node *node ;
};
struct ctl_dir {
   struct ctl_table_header header ;
   struct rb_root root ;
};
struct ctl_table_set {
   int (*is_seen)(struct ctl_table_set * ) ;
   struct ctl_dir dir ;
};
struct ctl_table_root {
   struct ctl_table_set default_set ;
   struct ctl_table_set *(*lookup)(struct ctl_table_root * , struct nsproxy * ) ;
   int (*permissions)(struct ctl_table_header * , struct ctl_table * ) ;
};
struct workqueue_struct;
struct work_struct;
struct work_struct {
   atomic_long_t data ;
   struct list_head entry ;
   void (*func)(struct work_struct * ) ;
   struct lockdep_map lockdep_map ;
};
struct delayed_work {
   struct work_struct work ;
   struct timer_list timer ;
   struct workqueue_struct *wq ;
   int cpu ;
};
struct notifier_block {
   int (*notifier_call)(struct notifier_block * , unsigned long  , void * ) ;
   struct notifier_block *next ;
   int priority ;
    klee_make_symbolic(&priority, sizeof(int), "priority");
};
struct pm_message {
   int event ;
    klee_make_symbolic(&event, sizeof(int), "event");
};
typedef struct pm_message pm_message_t;
struct dev_pm_ops {
   int (*prepare)(struct device * ) ;
   void (*complete)(struct device * ) ;
   int (*suspend)(struct device * ) ;
   int (*resume)(struct device * ) ;
   int (*freeze)(struct device * ) ;
   int (*thaw)(struct device * ) ;
   int (*poweroff)(struct device * ) ;
   int (*restore)(struct device * ) ;
   int (*suspend_late)(struct device * ) ;
   int (*resume_early)(struct device * ) ;
   int (*freeze_late)(struct device * ) ;
   int (*thaw_early)(struct device * ) ;
   int (*poweroff_late)(struct device * ) ;
   int (*restore_early)(struct device * ) ;
   int (*suspend_noirq)(struct device * ) ;
   int (*resume_noirq)(struct device * ) ;
   int (*freeze_noirq)(struct device * ) ;
   int (*thaw_noirq)(struct device * ) ;
   int (*poweroff_noirq)(struct device * ) ;
   int (*restore_noirq)(struct device * ) ;
   int (*runtime_suspend)(struct device * ) ;
   int (*runtime_resume)(struct device * ) ;
   int (*runtime_idle)(struct device * ) ;
};
enum rpm_status {
    RPM_ACTIVE = 0,
    RPM_RESUMING = 1,
    RPM_SUSPENDED = 2,
    RPM_SUSPENDING = 3
} ;
enum rpm_request {
    RPM_REQ_NONE = 0,
    RPM_REQ_IDLE = 1,
    RPM_REQ_SUSPEND = 2,
    RPM_REQ_AUTOSUSPEND = 3,
    RPM_REQ_RESUME = 4
} ;
struct wakeup_source;
struct wake_irq;
struct pm_subsys_data {
   spinlock_t lock ;
   unsigned int refcount ;
    klee_make_symbolic(&refcount, sizeof(int), "refcount");
   struct list_head clock_list ;
};
struct dev_pm_qos;
struct dev_pm_info {
   pm_message_t power_state ;
   unsigned char can_wakeup : 1 ;
   unsigned char async_suspend : 1 ;
   bool is_prepared ;
   bool is_suspended ;
   bool is_noirq_suspended ;
   bool is_late_suspended ;
   bool ignore_children ;
   bool early_init ;
   bool direct_complete ;
   spinlock_t lock ;
   struct list_head entry ;
   struct completion completion ;
   struct wakeup_source *wakeup ;
   bool wakeup_path ;
   bool syscore ;
   struct timer_list suspend_timer ;
   unsigned long timer_expires ;
    klee_make_symbolic(&timer_expires, sizeof(long), "timer_expires");
   struct work_struct work ;
   wait_queue_head_t wait_queue ;
   struct wake_irq *wakeirq ;
   atomic_t usage_count ;
   atomic_t child_count ;
   unsigned char disable_depth : 3 ;
   unsigned char idle_notification : 1 ;
   unsigned char request_pending : 1 ;
   unsigned char deferred_resume : 1 ;
   unsigned char run_wake : 1 ;
   unsigned char runtime_auto : 1 ;
   unsigned char no_callbacks : 1 ;
   unsigned char irq_safe : 1 ;
   unsigned char use_autosuspend : 1 ;
   unsigned char timer_autosuspends : 1 ;
   unsigned char memalloc_noio : 1 ;
   enum rpm_request request ;
   enum rpm_status runtime_status ;
   int runtime_error ;
    klee_make_symbolic(&runtime_error, sizeof(int), "runtime_error");
   int autosuspend_delay ;
    klee_make_symbolic(&autosuspend_delay, sizeof(int), "autosuspend_delay");
   unsigned long last_busy ;
    klee_make_symbolic(&last_busy, sizeof(long), "last_busy");
   unsigned long active_jiffies ;
    klee_make_symbolic(&active_jiffies, sizeof(long), "active_jiffies");
   unsigned long suspended_jiffies ;
    klee_make_symbolic(&suspended_jiffies, sizeof(long), "suspended_jiffies");
   unsigned long accounting_timestamp ;
    klee_make_symbolic(&accounting_timestamp, sizeof(long), "accounting_timestamp");
   struct pm_subsys_data *subsys_data ;
   void (*set_latency_tolerance)(struct device * , s32  ) ;
   struct dev_pm_qos *qos ;
};
struct dev_pm_domain {
   struct dev_pm_ops ops ;
   void (*detach)(struct device * , bool  ) ;
   int (*activate)(struct device * ) ;
   void (*sync)(struct device * ) ;
   void (*dismiss)(struct device * ) ;
};
struct __anonstruct_mm_context_t_115 {
   void *ldt ;
   int size ;
    klee_make_symbolic(&size, sizeof(int), "size");
   unsigned short ia32_compat ;
    klee_make_symbolic(&ia32_compat, sizeof(short), "ia32_compat");
   struct mutex lock ;
   void *vdso ;
   atomic_t perf_rdpmc_allowed ;
};
typedef struct __anonstruct_mm_context_t_115 mm_context_t;
struct bio_vec;
struct llist_node;
struct llist_node {
   struct llist_node *next ;
};
struct cred;
struct inode;
struct arch_uprobe_task {
   unsigned long saved_scratch_register ;
    klee_make_symbolic(&saved_scratch_register, sizeof(long), "saved_scratch_register");
   unsigned int saved_trap_nr ;
    klee_make_symbolic(&saved_trap_nr, sizeof(int), "saved_trap_nr");
   unsigned int saved_tf ;
    klee_make_symbolic(&saved_tf, sizeof(int), "saved_tf");
};
enum uprobe_task_state {
    UTASK_RUNNING = 0,
    UTASK_SSTEP = 1,
    UTASK_SSTEP_ACK = 2,
    UTASK_SSTEP_TRAPPED = 3
} ;
struct __anonstruct____missing_field_name_148 {
   struct arch_uprobe_task autask ;
   unsigned long vaddr ;
    klee_make_symbolic(&vaddr, sizeof(long), "vaddr");
};
struct __anonstruct____missing_field_name_149 {
   struct callback_head dup_xol_work ;
   unsigned long dup_xol_addr ;
    klee_make_symbolic(&dup_xol_addr, sizeof(long), "dup_xol_addr");
};
union __anonunion____missing_field_name_147 {
   struct __anonstruct____missing_field_name_148 __annonCompField33 ;
   struct __anonstruct____missing_field_name_149 __annonCompField34 ;
};
struct uprobe;
struct return_instance;
struct uprobe_task {
   enum uprobe_task_state state ;
   union __anonunion____missing_field_name_147 __annonCompField35 ;
   struct uprobe *active_uprobe ;
   unsigned long xol_vaddr ;
    klee_make_symbolic(&xol_vaddr, sizeof(long), "xol_vaddr");
   struct return_instance *return_instances ;
   unsigned int depth ;
    klee_make_symbolic(&depth, sizeof(int), "depth");
};
struct xol_area;
struct uprobes_state {
   struct xol_area *xol_area ;
};
struct address_space;
struct mem_cgroup;
typedef void compound_page_dtor(struct page * );
union __anonunion____missing_field_name_150 {
   struct address_space *mapping ;
   void *s_mem ;
};
union __anonunion____missing_field_name_152 {
   unsigned long index ;
    klee_make_symbolic(&index, sizeof(long), "index");
   void *freelist ;
   bool pfmemalloc ;
};
struct __anonstruct____missing_field_name_156 {
   unsigned short inuse ;
    klee_make_symbolic(&inuse, sizeof(short), "inuse");
   unsigned short objects : 15 ;
   unsigned char frozen : 1 ;
};
union __anonunion____missing_field_name_155 {
   atomic_t _mapcount ;
   struct __anonstruct____missing_field_name_156 __annonCompField38 ;
   int units ;
    klee_make_symbolic(&units, sizeof(int), "units");
};
struct __anonstruct____missing_field_name_154 {
   union __anonunion____missing_field_name_155 __annonCompField39 ;
   atomic_t _count ;
};
union __anonunion____missing_field_name_153 {
   unsigned long counters ;
    klee_make_symbolic(&counters, sizeof(long), "counters");
   struct __anonstruct____missing_field_name_154 __annonCompField40 ;
   unsigned int active ;
    klee_make_symbolic(&active, sizeof(int), "active");
};
struct __anonstruct____missing_field_name_151 {
   union __anonunion____missing_field_name_152 __annonCompField37 ;
   union __anonunion____missing_field_name_153 __annonCompField41 ;
};
struct __anonstruct____missing_field_name_158 {
   struct page *next ;
   int pages ;
    klee_make_symbolic(&pages, sizeof(int), "pages");
   int pobjects ;
    klee_make_symbolic(&pobjects, sizeof(int), "pobjects");
};
struct slab;
struct __anonstruct____missing_field_name_159 {
   compound_page_dtor *compound_dtor ;
   unsigned long compound_order ;
    klee_make_symbolic(&compound_order, sizeof(long), "compound_order");
};
union __anonunion____missing_field_name_157 {
   struct list_head lru ;
   struct __anonstruct____missing_field_name_158 __annonCompField43 ;
   struct slab *slab_page ;
   struct callback_head callback_head ;
   struct __anonstruct____missing_field_name_159 __annonCompField44 ;
   pgtable_t pmd_huge_pte ;
};
struct kmem_cache;
union __anonunion____missing_field_name_160 {
   unsigned long private ;
    klee_make_symbolic(&private, sizeof(long), "private");
   spinlock_t *ptl ;
   struct kmem_cache *slab_cache ;
   struct page *first_page ;
};
struct page {
   unsigned long flags ;
   union __anonunion____missing_field_name_150 __annonCompField36 ;
   struct __anonstruct____missing_field_name_151 __annonCompField42 ;
   union __anonunion____missing_field_name_157 __annonCompField45 ;
   union __anonunion____missing_field_name_160 __annonCompField46 ;
   struct mem_cgroup *mem_cgroup ;
};
struct page_frag {
   struct page *page ;
   __u32 offset ;
   __u32 size ;
};
struct __anonstruct_shared_161 {
   struct rb_node rb ;
   unsigned long rb_subtree_last ;
    klee_make_symbolic(&rb_subtree_last, sizeof(long), "rb_subtree_last");
};
struct anon_vma;
struct vm_operations_struct;
struct mempolicy;
struct vm_area_struct {
   unsigned long vm_start ;
    klee_make_symbolic(&vm_start, sizeof(long), "vm_start");
   unsigned long vm_end ;
    klee_make_symbolic(&vm_end, sizeof(long), "vm_end");
   struct vm_area_struct *vm_next ;
   struct vm_area_struct *vm_prev ;
   struct rb_node vm_rb ;
   unsigned long rb_subtree_gap ;
    klee_make_symbolic(&rb_subtree_gap, sizeof(long), "rb_subtree_gap");
   struct mm_struct *vm_mm ;
   pgprot_t vm_page_prot ;
   unsigned long vm_flags ;
    klee_make_symbolic(&vm_flags, sizeof(long), "vm_flags");
   struct __anonstruct_shared_161 shared ;
   struct list_head anon_vma_chain ;
   struct anon_vma *anon_vma ;
   struct vm_operations_struct  const  *vm_ops ;
   unsigned long vm_pgoff ;
    klee_make_symbolic(&vm_pgoff, sizeof(long), "vm_pgoff");
   struct file *vm_file ;
   void *vm_private_data ;
   struct mempolicy *vm_policy ;
};
struct core_thread {
   struct task_struct *task ;
   struct core_thread *next ;
};
struct core_state {
   atomic_t nr_threads ;
   struct core_thread dumper ;
   struct completion startup ;
};
struct task_rss_stat {
   int events ;
    klee_make_symbolic(&events, sizeof(int), "events");
   int count[3U] ;
};
struct mm_rss_stat {
   atomic_long_t count[3U] ;
};
struct kioctx_table;
struct linux_binfmt;
struct mmu_notifier_mm;
struct mm_struct {
   struct vm_area_struct *mmap ;
   struct rb_root mm_rb ;
   u32 vmacache_seqnum ;
   unsigned long (*get_unmapped_area)(struct file * , unsigned long  , unsigned long  ,
                                      unsigned long  , unsigned long  ) ;
   unsigned long mmap_base ;
    klee_make_symbolic(&mmap_base, sizeof(long), "mmap_base");
   unsigned long mmap_legacy_base ;
    klee_make_symbolic(&mmap_legacy_base, sizeof(long), "mmap_legacy_base");
   unsigned long task_size ;
    klee_make_symbolic(&task_size, sizeof(long), "task_size");
   unsigned long highest_vm_end ;
    klee_make_symbolic(&highest_vm_end, sizeof(long), "highest_vm_end");
   pgd_t *pgd ;
   atomic_t mm_users ;
   atomic_t mm_count ;
   atomic_long_t nr_ptes ;
   atomic_long_t nr_pmds ;
   int map_count ;
    klee_make_symbolic(&map_count, sizeof(int), "map_count");
   spinlock_t page_table_lock ;
   struct rw_semaphore mmap_sem ;
   struct list_head mmlist ;
   unsigned long hiwater_rss ;
    klee_make_symbolic(&hiwater_rss, sizeof(long), "hiwater_rss");
   unsigned long hiwater_vm ;
    klee_make_symbolic(&hiwater_vm, sizeof(long), "hiwater_vm");
   unsigned long total_vm ;
    klee_make_symbolic(&total_vm, sizeof(long), "total_vm");
   unsigned long locked_vm ;
    klee_make_symbolic(&locked_vm, sizeof(long), "locked_vm");
   unsigned long pinned_vm ;
    klee_make_symbolic(&pinned_vm, sizeof(long), "pinned_vm");
   unsigned long shared_vm ;
    klee_make_symbolic(&shared_vm, sizeof(long), "shared_vm");
   unsigned long exec_vm ;
    klee_make_symbolic(&exec_vm, sizeof(long), "exec_vm");
   unsigned long stack_vm ;
    klee_make_symbolic(&stack_vm, sizeof(long), "stack_vm");
   unsigned long def_flags ;
    klee_make_symbolic(&def_flags, sizeof(long), "def_flags");
   unsigned long start_code ;
    klee_make_symbolic(&start_code, sizeof(long), "start_code");
   unsigned long end_code ;
    klee_make_symbolic(&end_code, sizeof(long), "end_code");
   unsigned long start_data ;
    klee_make_symbolic(&start_data, sizeof(long), "start_data");
   unsigned long end_data ;
    klee_make_symbolic(&end_data, sizeof(long), "end_data");
   unsigned long start_brk ;
    klee_make_symbolic(&start_brk, sizeof(long), "start_brk");
   unsigned long brk ;
    klee_make_symbolic(&brk, sizeof(long), "brk");
   unsigned long start_stack ;
    klee_make_symbolic(&start_stack, sizeof(long), "start_stack");
   unsigned long arg_start ;
    klee_make_symbolic(&arg_start, sizeof(long), "arg_start");
   unsigned long arg_end ;
    klee_make_symbolic(&arg_end, sizeof(long), "arg_end");
   unsigned long env_start ;
    klee_make_symbolic(&env_start, sizeof(long), "env_start");
   unsigned long env_end ;
    klee_make_symbolic(&env_end, sizeof(long), "env_end");
   unsigned long saved_auxv[46U] ;
   struct mm_rss_stat rss_stat ;
   struct linux_binfmt *binfmt ;
   cpumask_var_t cpu_vm_mask_var ;
   mm_context_t context ;
   unsigned long flags ;
   struct core_state *core_state ;
   spinlock_t ioctx_lock ;
   struct kioctx_table *ioctx_table ;
   struct task_struct *owner ;
   struct file *exe_file ;
   struct mmu_notifier_mm *mmu_notifier_mm ;
   struct cpumask cpumask_allocation ;
   unsigned long numa_next_scan ;
    klee_make_symbolic(&numa_next_scan, sizeof(long), "numa_next_scan");
   unsigned long numa_scan_offset ;
    klee_make_symbolic(&numa_scan_offset, sizeof(long), "numa_scan_offset");
   int numa_scan_seq ;
    klee_make_symbolic(&numa_scan_seq, sizeof(int), "numa_scan_seq");
   bool tlb_flush_pending ;
   struct uprobes_state uprobes_state ;
   void *bd_addr ;
};
typedef __u64 Elf64_Addr;
typedef __u16 Elf64_Half;
typedef __u32 Elf64_Word;
typedef __u64 Elf64_Xword;
struct elf64_sym {
   Elf64_Word st_name ;
   unsigned char st_info ;
    klee_make_symbolic(&st_info, sizeof(char), "st_info");
   unsigned char st_other ;
    klee_make_symbolic(&st_other, sizeof(char), "st_other");
   Elf64_Half st_shndx ;
   Elf64_Addr st_value ;
   Elf64_Xword st_size ;
};
typedef struct elf64_sym Elf64_Sym;
union __anonunion____missing_field_name_166 {
   unsigned long bitmap[4U] ;
   struct callback_head callback_head ;
};
struct idr_layer {
   int prefix ;
    klee_make_symbolic(&prefix, sizeof(int), "prefix");
   int layer ;
    klee_make_symbolic(&layer, sizeof(int), "layer");
   struct idr_layer *ary[256U] ;
   int count ;
   union __anonunion____missing_field_name_166 __annonCompField47 ;
};
struct idr {
   struct idr_layer *hint ;
   struct idr_layer *top ;
   int layers ;
    klee_make_symbolic(&layers, sizeof(int), "layers");
   int cur ;
    klee_make_symbolic(&cur, sizeof(int), "cur");
   spinlock_t lock ;
   int id_free_cnt ;
    klee_make_symbolic(&id_free_cnt, sizeof(int), "id_free_cnt");
   struct idr_layer *id_free ;
};
struct ida_bitmap {
   long nr_busy ;
    klee_make_symbolic(&nr_busy, sizeof(long), "nr_busy");
   unsigned long bitmap[15U] ;
};
struct ida {
   struct idr idr ;
   struct ida_bitmap *free_bitmap ;
};
struct dentry;
struct iattr;
struct super_block;
struct file_system_type;
struct kernfs_open_node;
struct kernfs_iattrs;
struct kernfs_root;
struct kernfs_elem_dir {
   unsigned long subdirs ;
    klee_make_symbolic(&subdirs, sizeof(long), "subdirs");
   struct rb_root children ;
   struct kernfs_root *root ;
};
struct kernfs_node;
struct kernfs_elem_symlink {
   struct kernfs_node *target_kn ;
};
struct kernfs_ops;
struct kernfs_elem_attr {
   struct kernfs_ops  const  *ops ;
   struct kernfs_open_node *open ;
   loff_t size ;
   struct kernfs_node *notify_next ;
};
union __anonunion____missing_field_name_171 {
   struct kernfs_elem_dir dir ;
   struct kernfs_elem_symlink symlink ;
   struct kernfs_elem_attr attr ;
};
struct kernfs_node {
   atomic_t count ;
   atomic_t active ;
   struct lockdep_map dep_map ;
   struct kernfs_node *parent ;
   char const   *name ;
   struct rb_node rb ;
   void const   *ns ;
   unsigned int hash ;
    klee_make_symbolic(&hash, sizeof(int), "hash");
   union __anonunion____missing_field_name_171 __annonCompField48 ;
   void *priv ;
   unsigned short flags ;
   umode_t mode ;
   unsigned int ino ;
    klee_make_symbolic(&ino, sizeof(int), "ino");
   struct kernfs_iattrs *iattr ;
};
struct kernfs_syscall_ops {
   int (*remount_fs)(struct kernfs_root * , int * , char * ) ;
   int (*show_options)(struct seq_file * , struct kernfs_root * ) ;
   int (*mkdir)(struct kernfs_node * , char const   * , umode_t  ) ;
   int (*rmdir)(struct kernfs_node * ) ;
   int (*rename)(struct kernfs_node * , struct kernfs_node * , char const   * ) ;
};
struct kernfs_root {
   struct kernfs_node *kn ;
   unsigned int flags ;
   struct ida ino_ida ;
   struct kernfs_syscall_ops *syscall_ops ;
   struct list_head supers ;
   wait_queue_head_t deactivate_waitq ;
};
struct kernfs_open_file {
   struct kernfs_node *kn ;
   struct file *file ;
   void *priv ;
   struct mutex mutex ;
   int event ;
   struct list_head list ;
   char *prealloc_buf ;
   size_t atomic_write_len ;
   bool mmapped ;
   struct vm_operations_struct  const  *vm_ops ;
};
struct kernfs_ops {
   int (*seq_show)(struct seq_file * , void * ) ;
   void *(*seq_start)(struct seq_file * , loff_t * ) ;
   void *(*seq_next)(struct seq_file * , void * , loff_t * ) ;
   void (*seq_stop)(struct seq_file * , void * ) ;
   ssize_t (*read)(struct kernfs_open_file * , char * , size_t  , loff_t  ) ;
   size_t atomic_write_len ;
   bool prealloc ;
   ssize_t (*write)(struct kernfs_open_file * , char * , size_t  , loff_t  ) ;
   int (*mmap)(struct kernfs_open_file * , struct vm_area_struct * ) ;
   struct lock_class_key lockdep_key ;
};
struct sock;
struct kobject;
enum kobj_ns_type {
    KOBJ_NS_TYPE_NONE = 0,
    KOBJ_NS_TYPE_NET = 1,
    KOBJ_NS_TYPES = 2
} ;
struct kobj_ns_type_operations {
   enum kobj_ns_type type ;
   bool (*current_may_mount)(void) ;
   void *(*grab_current_ns)(void) ;
   void const   *(*netlink_ns)(struct sock * ) ;
   void const   *(*initial_ns)(void) ;
   void (*drop_ns)(void * ) ;
};
struct bin_attribute;
struct attribute {
   char const   *name ;
   umode_t mode ;
   bool ignore_lockdep ;
   struct lock_class_key *key ;
   struct lock_class_key skey ;
};
struct attribute_group {
   char const   *name ;
   umode_t (*is_visible)(struct kobject * , struct attribute * , int  ) ;
   struct attribute **attrs ;
   struct bin_attribute **bin_attrs ;
};
struct bin_attribute {
   struct attribute attr ;
   size_t size ;
   void *private ;
   ssize_t (*read)(struct file * , struct kobject * , struct bin_attribute * , char * ,
                   loff_t  , size_t  ) ;
   ssize_t (*write)(struct file * , struct kobject * , struct bin_attribute * , char * ,
                    loff_t  , size_t  ) ;
   int (*mmap)(struct file * , struct kobject * , struct bin_attribute * , struct vm_area_struct * ) ;
};
struct sysfs_ops {
   ssize_t (*show)(struct kobject * , struct attribute * , char * ) ;
   ssize_t (*store)(struct kobject * , struct attribute * , char const   * , size_t  ) ;
};
struct kref {
   atomic_t refcount ;
};
struct kset;
struct kobj_type;
struct kobject {
   char const   *name ;
   struct list_head entry ;
   struct kobject *parent ;
   struct kset *kset ;
   struct kobj_type *ktype ;
   struct kernfs_node *sd ;
   struct kref kref ;
   struct delayed_work release ;
   unsigned char state_initialized : 1 ;
   unsigned char state_in_sysfs : 1 ;
   unsigned char state_add_uevent_sent : 1 ;
   unsigned char state_remove_uevent_sent : 1 ;
   unsigned char uevent_suppress : 1 ;
};
struct kobj_type {
   void (*release)(struct kobject * ) ;
   struct sysfs_ops  const  *sysfs_ops ;
   struct attribute **default_attrs ;
   struct kobj_ns_type_operations  const  *(*child_ns_type)(struct kobject * ) ;
   void const   *(*namespace)(struct kobject * ) ;
};
struct kobj_uevent_env {
   char *argv[3U] ;
   char *envp[32U] ;
   int envp_idx ;
    klee_make_symbolic(&envp_idx, sizeof(int), "envp_idx");
   char buf[2048U] ;
   int buflen ;
    klee_make_symbolic(&buflen, sizeof(int), "buflen");
};
struct kset_uevent_ops {
   int (* const  filter)(struct kset * , struct kobject * ) ;
   char const   *(* const  name)(struct kset * , struct kobject * ) ;
   int (* const  uevent)(struct kset * , struct kobject * , struct kobj_uevent_env * ) ;
};
struct kset {
   struct list_head list ;
   spinlock_t list_lock ;
   struct kobject kobj ;
   struct kset_uevent_ops  const  *uevent_ops ;
};
struct kernel_param;
struct kernel_param_ops {
   unsigned int flags ;
   int (*set)(char const   * , struct kernel_param  const  * ) ;
   int (*get)(char * , struct kernel_param  const  * ) ;
   void (*free)(void * ) ;
};
struct kparam_string;
struct kparam_array;
union __anonunion____missing_field_name_172 {
   void *arg ;
   struct kparam_string  const  *str ;
   struct kparam_array  const  *arr ;
};
struct kernel_param {
   char const   *name ;
   struct module *mod ;
   struct kernel_param_ops  const  *ops ;
   u16 const   perm ;
   s8 level ;
   u8 flags ;
   union __anonunion____missing_field_name_172 __annonCompField49 ;
};
struct kparam_string {
   unsigned int maxlen ;
   char *string ;
};
struct kparam_array {
   unsigned int max ;
    klee_make_symbolic(&max, sizeof(int), "max");
   unsigned int elemsize ;
    klee_make_symbolic(&elemsize, sizeof(int), "elemsize");
   unsigned int *num ;
   struct kernel_param_ops  const  *ops ;
   void *elem ;
};
struct latch_tree_node {
   struct rb_node node[2U] ;
};
struct mod_arch_specific {

};
struct module_param_attrs;
struct module_kobject {
   struct kobject kobj ;
   struct module *mod ;
   struct kobject *drivers_dir ;
   struct module_param_attrs *mp ;
   struct completion *kobj_completion ;
};
struct module_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct module_attribute * , struct module_kobject * , char * ) ;
   ssize_t (*store)(struct module_attribute * , struct module_kobject * , char const   * ,
                    size_t  ) ;
   void (*setup)(struct module * , char const   * ) ;
   int (*test)(struct module * ) ;
   void (*free)(struct module * ) ;
};
struct exception_table_entry;
enum module_state {
    MODULE_STATE_LIVE = 0,
    MODULE_STATE_COMING = 1,
    MODULE_STATE_GOING = 2,
    MODULE_STATE_UNFORMED = 3
} ;
struct mod_tree_node {
   struct module *mod ;
   struct latch_tree_node node ;
};
struct module_sect_attrs;
struct module_notes_attrs;
struct tracepoint;
struct trace_event_call;
struct trace_enum_map;
struct module {
   enum module_state state ;
   struct list_head list ;
   char name[56U] ;
   struct module_kobject mkobj ;
   struct module_attribute *modinfo_attrs ;
   char const   *version ;
   char const   *srcversion ;
   struct kobject *holders_dir ;
   struct kernel_symbol  const  *syms ;
   unsigned long const   *crcs ;
   unsigned int num_syms ;
    klee_make_symbolic(&num_syms, sizeof(int), "num_syms");
   struct mutex param_lock ;
   struct kernel_param *kp ;
   unsigned int num_kp ;
    klee_make_symbolic(&num_kp, sizeof(int), "num_kp");
   unsigned int num_gpl_syms ;
    klee_make_symbolic(&num_gpl_syms, sizeof(int), "num_gpl_syms");
   struct kernel_symbol  const  *gpl_syms ;
   unsigned long const   *gpl_crcs ;
   struct kernel_symbol  const  *unused_syms ;
   unsigned long const   *unused_crcs ;
   unsigned int num_unused_syms ;
    klee_make_symbolic(&num_unused_syms, sizeof(int), "num_unused_syms");
   unsigned int num_unused_gpl_syms ;
    klee_make_symbolic(&num_unused_gpl_syms, sizeof(int), "num_unused_gpl_syms");
   struct kernel_symbol  const  *unused_gpl_syms ;
   unsigned long const   *unused_gpl_crcs ;
   bool sig_ok ;
   bool async_probe_requested ;
   struct kernel_symbol  const  *gpl_future_syms ;
   unsigned long const   *gpl_future_crcs ;
   unsigned int num_gpl_future_syms ;
    klee_make_symbolic(&num_gpl_future_syms, sizeof(int), "num_gpl_future_syms");
   unsigned int num_exentries ;
    klee_make_symbolic(&num_exentries, sizeof(int), "num_exentries");
   struct exception_table_entry *extable ;
   int (*init)(void) ;
   void *module_init ;
   void *module_core ;
   unsigned int init_size ;
    klee_make_symbolic(&init_size, sizeof(int), "init_size");
   unsigned int core_size ;
    klee_make_symbolic(&core_size, sizeof(int), "core_size");
   unsigned int init_text_size ;
    klee_make_symbolic(&init_text_size, sizeof(int), "init_text_size");
   unsigned int core_text_size ;
    klee_make_symbolic(&core_text_size, sizeof(int), "core_text_size");
   struct mod_tree_node mtn_core ;
   struct mod_tree_node mtn_init ;
   unsigned int init_ro_size ;
    klee_make_symbolic(&init_ro_size, sizeof(int), "init_ro_size");
   unsigned int core_ro_size ;
    klee_make_symbolic(&core_ro_size, sizeof(int), "core_ro_size");
   struct mod_arch_specific arch ;
   unsigned int taints ;
    klee_make_symbolic(&taints, sizeof(int), "taints");
   unsigned int num_bugs ;
    klee_make_symbolic(&num_bugs, sizeof(int), "num_bugs");
   struct list_head bug_list ;
   struct bug_entry *bug_table ;
   Elf64_Sym *symtab ;
   Elf64_Sym *core_symtab ;
   unsigned int num_symtab ;
    klee_make_symbolic(&num_symtab, sizeof(int), "num_symtab");
   unsigned int core_num_syms ;
    klee_make_symbolic(&core_num_syms, sizeof(int), "core_num_syms");
   char *strtab ;
   char *core_strtab ;
   struct module_sect_attrs *sect_attrs ;
   struct module_notes_attrs *notes_attrs ;
   char *args ;
   void *percpu ;
   unsigned int percpu_size ;
    klee_make_symbolic(&percpu_size, sizeof(int), "percpu_size");
   unsigned int num_tracepoints ;
    klee_make_symbolic(&num_tracepoints, sizeof(int), "num_tracepoints");
   struct tracepoint * const  *tracepoints_ptrs ;
   unsigned int num_trace_bprintk_fmt ;
    klee_make_symbolic(&num_trace_bprintk_fmt, sizeof(int), "num_trace_bprintk_fmt");
   char const   **trace_bprintk_fmt_start ;
   struct trace_event_call **trace_events ;
   unsigned int num_trace_events ;
    klee_make_symbolic(&num_trace_events, sizeof(int), "num_trace_events");
   struct trace_enum_map **trace_enums ;
   unsigned int num_trace_enums ;
    klee_make_symbolic(&num_trace_enums, sizeof(int), "num_trace_enums");
   unsigned int num_ftrace_callsites ;
    klee_make_symbolic(&num_ftrace_callsites, sizeof(int), "num_ftrace_callsites");
   unsigned long *ftrace_callsites ;
   bool klp_alive ;
   struct list_head source_list ;
   struct list_head target_list ;
   void (*exit)(void) ;
   atomic_t refcnt ;
   ctor_fn_t (**ctors)(void) ;
   unsigned int num_ctors ;
    klee_make_symbolic(&num_ctors, sizeof(int), "num_ctors");
};
struct kernel_cap_struct {
   __u32 cap[2U] ;
};
typedef struct kernel_cap_struct kernel_cap_t;
struct plist_node {
   int prio ;
    klee_make_symbolic(&prio, sizeof(int), "prio");
   struct list_head prio_list ;
   struct list_head node_list ;
};
typedef unsigned long cputime_t;
    klee_make_symbolic(&cputime_t, sizeof(long), "cputime_t");
struct sem_undo_list;
struct sysv_sem {
   struct sem_undo_list *undo_list ;
};
struct user_struct;
struct sysv_shm {
   struct list_head shm_clist ;
};
struct __anonstruct_sigset_t_180 {
   unsigned long sig[1U] ;
};
typedef struct __anonstruct_sigset_t_180 sigset_t;
struct siginfo;
typedef void __signalfn_t(int  );
typedef __signalfn_t *__sighandler_t;
typedef void __restorefn_t(void);
typedef __restorefn_t *__sigrestore_t;
union sigval {
   int sival_int ;
    klee_make_symbolic(&sival_int, sizeof(int), "sival_int");
   void *sival_ptr ;
};
typedef union sigval sigval_t;
struct __anonstruct__kill_182 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
};
struct __anonstruct__timer_183 {
   __kernel_timer_t _tid ;
   int _overrun ;
    klee_make_symbolic(&_overrun, sizeof(int), "_overrun");
   char _pad[0U] ;
   sigval_t _sigval ;
   int _sys_private ;
    klee_make_symbolic(&_sys_private, sizeof(int), "_sys_private");
};
struct __anonstruct__rt_184 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
   sigval_t _sigval ;
};
struct __anonstruct__sigchld_185 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
   int _status ;
    klee_make_symbolic(&_status, sizeof(int), "_status");
   __kernel_clock_t _utime ;
   __kernel_clock_t _stime ;
};
struct __anonstruct__addr_bnd_187 {
   void *_lower ;
   void *_upper ;
};
struct __anonstruct__sigfault_186 {
   void *_addr ;
   short _addr_lsb ;
    klee_make_symbolic(&_addr_lsb, sizeof(short), "_addr_lsb");
   struct __anonstruct__addr_bnd_187 _addr_bnd ;
};
struct __anonstruct__sigpoll_188 {
   long _band ;
    klee_make_symbolic(&_band, sizeof(long), "_band");
   int _fd ;
    klee_make_symbolic(&_fd, sizeof(int), "_fd");
};
struct __anonstruct__sigsys_189 {
   void *_call_addr ;
   int _syscall ;
    klee_make_symbolic(&_syscall, sizeof(int), "_syscall");
   unsigned int _arch ;
    klee_make_symbolic(&_arch, sizeof(int), "_arch");
};
union __anonunion__sifields_181 {
   int _pad[28U] ;
   struct __anonstruct__kill_182 _kill ;
   struct __anonstruct__timer_183 _timer ;
   struct __anonstruct__rt_184 _rt ;
   struct __anonstruct__sigchld_185 _sigchld ;
   struct __anonstruct__sigfault_186 _sigfault ;
   struct __anonstruct__sigpoll_188 _sigpoll ;
   struct __anonstruct__sigsys_189 _sigsys ;
};
struct siginfo {
   int si_signo ;
    klee_make_symbolic(&si_signo, sizeof(int), "si_signo");
   int si_errno ;
    klee_make_symbolic(&si_errno, sizeof(int), "si_errno");
   int si_code ;
    klee_make_symbolic(&si_code, sizeof(int), "si_code");
   union __anonunion__sifields_181 _sifields ;
};
typedef struct siginfo siginfo_t;
struct sigpending {
   struct list_head list ;
   sigset_t signal ;
};
struct sigaction {
   __sighandler_t sa_handler ;
   unsigned long sa_flags ;
    klee_make_symbolic(&sa_flags, sizeof(long), "sa_flags");
   __sigrestore_t sa_restorer ;
   sigset_t sa_mask ;
};
struct k_sigaction {
   struct sigaction sa ;
};
enum pid_type {
    PIDTYPE_PID = 0,
    PIDTYPE_PGID = 1,
    PIDTYPE_SID = 2,
    PIDTYPE_MAX = 3
} ;
struct pid_namespace;
struct upid {
   int nr ;
    klee_make_symbolic(&nr, sizeof(int), "nr");
   struct pid_namespace *ns ;
   struct hlist_node pid_chain ;
};
struct pid {
   atomic_t count ;
   unsigned int level ;
    klee_make_symbolic(&level, sizeof(int), "level");
   struct hlist_head tasks[3U] ;
   struct callback_head rcu ;
   struct upid numbers[1U] ;
};
struct pid_link {
   struct hlist_node node ;
   struct pid *pid ;
};
struct percpu_counter {
   raw_spinlock_t lock ;
   s64 count ;
   struct list_head list ;
   s32 *counters ;
};
struct seccomp_filter;
struct seccomp {
   int mode ;
    klee_make_symbolic(&mode, sizeof(int), "mode");
   struct seccomp_filter *filter ;
};
struct rt_mutex_waiter;
struct rlimit {
   __kernel_ulong_t rlim_cur ;
   __kernel_ulong_t rlim_max ;
};
struct timerqueue_node {
   struct rb_node node ;
   ktime_t expires ;
};
struct timerqueue_head {
   struct rb_root head ;
   struct timerqueue_node *next ;
};
struct hrtimer_clock_base;
struct hrtimer_cpu_base;
enum hrtimer_restart {
    HRTIMER_NORESTART = 0,
    HRTIMER_RESTART = 1
} ;
struct hrtimer {
   struct timerqueue_node node ;
   ktime_t _softexpires ;
   enum hrtimer_restart (*function)(struct hrtimer * ) ;
   struct hrtimer_clock_base *base ;
   unsigned long state ;
    klee_make_symbolic(&state, sizeof(long), "state");
   int start_pid ;
   void *start_site ;
   char start_comm[16U] ;
};
struct hrtimer_clock_base {
   struct hrtimer_cpu_base *cpu_base ;
   int index ;
   clockid_t clockid ;
   struct timerqueue_head active ;
   ktime_t (*get_time)(void) ;
   ktime_t offset ;
};
struct hrtimer_cpu_base {
   raw_spinlock_t lock ;
   seqcount_t seq ;
   struct hrtimer *running ;
   unsigned int cpu ;
   unsigned int active_bases ;
    klee_make_symbolic(&active_bases, sizeof(int), "active_bases");
   unsigned int clock_was_set_seq ;
    klee_make_symbolic(&clock_was_set_seq, sizeof(int), "clock_was_set_seq");
   bool migration_enabled ;
   bool nohz_active ;
   unsigned char in_hrtirq : 1 ;
   unsigned char hres_active : 1 ;
   unsigned char hang_detected : 1 ;
   ktime_t expires_next ;
   struct hrtimer *next_timer ;
   unsigned int nr_events ;
    klee_make_symbolic(&nr_events, sizeof(int), "nr_events");
   unsigned int nr_retries ;
    klee_make_symbolic(&nr_retries, sizeof(int), "nr_retries");
   unsigned int nr_hangs ;
    klee_make_symbolic(&nr_hangs, sizeof(int), "nr_hangs");
   unsigned int max_hang_time ;
    klee_make_symbolic(&max_hang_time, sizeof(int), "max_hang_time");
   struct hrtimer_clock_base clock_base[4U] ;
};
struct task_io_accounting {
   u64 rchar ;
   u64 wchar ;
   u64 syscr ;
   u64 syscw ;
   u64 read_bytes ;
   u64 write_bytes ;
   u64 cancelled_write_bytes ;
};
struct latency_record {
   unsigned long backtrace[12U] ;
   unsigned int count ;
   unsigned long time ;
    klee_make_symbolic(&time, sizeof(long), "time");
   unsigned long max ;
};
struct assoc_array_ptr;
struct assoc_array {
   struct assoc_array_ptr *root ;
   unsigned long nr_leaves_on_tree ;
    klee_make_symbolic(&nr_leaves_on_tree, sizeof(long), "nr_leaves_on_tree");
};
typedef int32_t key_serial_t;
typedef uint32_t key_perm_t;
struct key;
struct signal_struct;
struct key_type;
struct keyring_index_key {
   struct key_type *type ;
   char const   *description ;
   size_t desc_len ;
};
union __anonunion____missing_field_name_196 {
   struct list_head graveyard_link ;
   struct rb_node serial_node ;
};
struct key_user;
union __anonunion____missing_field_name_197 {
   time_t expiry ;
   time_t revoked_at ;
};
struct __anonstruct____missing_field_name_199 {
   struct key_type *type ;
   char *description ;
};
union __anonunion____missing_field_name_198 {
   struct keyring_index_key index_key ;
   struct __anonstruct____missing_field_name_199 __annonCompField52 ;
};
union __anonunion_type_data_200 {
   struct list_head link ;
   unsigned long x[2U] ;
   void *p[2U] ;
   int reject_error ;
    klee_make_symbolic(&reject_error, sizeof(int), "reject_error");
};
union __anonunion_payload_202 {
   unsigned long value ;
   void *rcudata ;
   void *data ;
   void *data2[2U] ;
};
union __anonunion____missing_field_name_201 {
   union __anonunion_payload_202 payload ;
   struct assoc_array keys ;
};
struct key {
   atomic_t usage ;
   key_serial_t serial ;
   union __anonunion____missing_field_name_196 __annonCompField50 ;
   struct rw_semaphore sem ;
   struct key_user *user ;
   void *security ;
   union __anonunion____missing_field_name_197 __annonCompField51 ;
   time_t last_used_at ;
   kuid_t uid ;
   kgid_t gid ;
   key_perm_t perm ;
   unsigned short quotalen ;
    klee_make_symbolic(&quotalen, sizeof(short), "quotalen");
   unsigned short datalen ;
    klee_make_symbolic(&datalen, sizeof(short), "datalen");
   unsigned long flags ;
   union __anonunion____missing_field_name_198 __annonCompField53 ;
   union __anonunion_type_data_200 type_data ;
   union __anonunion____missing_field_name_201 __annonCompField54 ;
};
struct audit_context;
struct group_info {
   atomic_t usage ;
   int ngroups ;
    klee_make_symbolic(&ngroups, sizeof(int), "ngroups");
   int nblocks ;
    klee_make_symbolic(&nblocks, sizeof(int), "nblocks");
   kgid_t small_block[32U] ;
   kgid_t *blocks[0U] ;
};
struct cred {
   atomic_t usage ;
   atomic_t subscribers ;
   void *put_addr ;
   unsigned int magic ;
   kuid_t uid ;
   kgid_t gid ;
   kuid_t suid ;
   kgid_t sgid ;
   kuid_t euid ;
   kgid_t egid ;
   kuid_t fsuid ;
   kgid_t fsgid ;
   unsigned int securebits ;
    klee_make_symbolic(&securebits, sizeof(int), "securebits");
   kernel_cap_t cap_inheritable ;
   kernel_cap_t cap_permitted ;
   kernel_cap_t cap_effective ;
   kernel_cap_t cap_bset ;
   unsigned char jit_keyring ;
    klee_make_symbolic(&jit_keyring, sizeof(char), "jit_keyring");
   struct key *session_keyring ;
   struct key *process_keyring ;
   struct key *thread_keyring ;
   struct key *request_key_auth ;
   void *security ;
   struct user_struct *user ;
   struct user_namespace *user_ns ;
   struct group_info *group_info ;
   struct callback_head rcu ;
};
struct percpu_ref;
typedef void percpu_ref_func_t(struct percpu_ref * );
struct percpu_ref {
   atomic_long_t count ;
   unsigned long percpu_count_ptr ;
    klee_make_symbolic(&percpu_count_ptr, sizeof(long), "percpu_count_ptr");
   percpu_ref_func_t *release ;
   percpu_ref_func_t *confirm_switch ;
   bool force_atomic ;
   struct callback_head rcu ;
};
struct cgroup;
struct cgroup_root;
struct cgroup_subsys;
struct cgroup_taskset;
struct cgroup_subsys_state {
   struct cgroup *cgroup ;
   struct cgroup_subsys *ss ;
   struct percpu_ref refcnt ;
   struct cgroup_subsys_state *parent ;
   struct list_head sibling ;
   struct list_head children ;
   int id ;
    klee_make_symbolic(&id, sizeof(int), "id");
   unsigned int flags ;
   u64 serial_nr ;
   struct callback_head callback_head ;
   struct work_struct destroy_work ;
};
struct css_set {
   atomic_t refcount ;
   struct hlist_node hlist ;
   struct list_head tasks ;
   struct list_head mg_tasks ;
   struct list_head cgrp_links ;
   struct cgroup *dfl_cgrp ;
   struct cgroup_subsys_state *subsys[12U] ;
   struct list_head mg_preload_node ;
   struct list_head mg_node ;
   struct cgroup *mg_src_cgrp ;
   struct css_set *mg_dst_cset ;
   struct list_head e_cset_node[12U] ;
   struct callback_head callback_head ;
};
struct cgroup {
   struct cgroup_subsys_state self ;
   unsigned long flags ;
   int id ;
   int populated_cnt ;
    klee_make_symbolic(&populated_cnt, sizeof(int), "populated_cnt");
   struct kernfs_node *kn ;
   struct kernfs_node *procs_kn ;
   struct kernfs_node *populated_kn ;
   unsigned int subtree_control ;
    klee_make_symbolic(&subtree_control, sizeof(int), "subtree_control");
   unsigned int child_subsys_mask ;
    klee_make_symbolic(&child_subsys_mask, sizeof(int), "child_subsys_mask");
   struct cgroup_subsys_state *subsys[12U] ;
   struct cgroup_root *root ;
   struct list_head cset_links ;
   struct list_head e_csets[12U] ;
   struct list_head pidlists ;
   struct mutex pidlist_mutex ;
   wait_queue_head_t offline_waitq ;
   struct work_struct release_agent_work ;
};
struct cgroup_root {
   struct kernfs_root *kf_root ;
   unsigned int subsys_mask ;
    klee_make_symbolic(&subsys_mask, sizeof(int), "subsys_mask");
   int hierarchy_id ;
    klee_make_symbolic(&hierarchy_id, sizeof(int), "hierarchy_id");
   struct cgroup cgrp ;
   atomic_t nr_cgrps ;
   struct list_head root_list ;
   unsigned int flags ;
   struct idr cgroup_idr ;
   char release_agent_path[4096U] ;
   char name[64U] ;
};
struct cftype {
   char name[64U] ;
   int private ;
   umode_t mode ;
   size_t max_write_len ;
   unsigned int flags ;
   struct cgroup_subsys *ss ;
   struct list_head node ;
   struct kernfs_ops *kf_ops ;
   u64 (*read_u64)(struct cgroup_subsys_state * , struct cftype * ) ;
   s64 (*read_s64)(struct cgroup_subsys_state * , struct cftype * ) ;
   int (*seq_show)(struct seq_file * , void * ) ;
   void *(*seq_start)(struct seq_file * , loff_t * ) ;
   void *(*seq_next)(struct seq_file * , void * , loff_t * ) ;
   void (*seq_stop)(struct seq_file * , void * ) ;
   int (*write_u64)(struct cgroup_subsys_state * , struct cftype * , u64  ) ;
   int (*write_s64)(struct cgroup_subsys_state * , struct cftype * , s64  ) ;
   ssize_t (*write)(struct kernfs_open_file * , char * , size_t  , loff_t  ) ;
   struct lock_class_key lockdep_key ;
};
struct cgroup_subsys {
   struct cgroup_subsys_state *(*css_alloc)(struct cgroup_subsys_state * ) ;
   int (*css_online)(struct cgroup_subsys_state * ) ;
   void (*css_offline)(struct cgroup_subsys_state * ) ;
   void (*css_released)(struct cgroup_subsys_state * ) ;
   void (*css_free)(struct cgroup_subsys_state * ) ;
   void (*css_reset)(struct cgroup_subsys_state * ) ;
   void (*css_e_css_changed)(struct cgroup_subsys_state * ) ;
   int (*can_attach)(struct cgroup_subsys_state * , struct cgroup_taskset * ) ;
   void (*cancel_attach)(struct cgroup_subsys_state * , struct cgroup_taskset * ) ;
   void (*attach)(struct cgroup_subsys_state * , struct cgroup_taskset * ) ;
   void (*fork)(struct task_struct * ) ;
   void (*exit)(struct cgroup_subsys_state * , struct cgroup_subsys_state * , struct task_struct * ) ;
   void (*bind)(struct cgroup_subsys_state * ) ;
   int disabled ;
    klee_make_symbolic(&disabled, sizeof(int), "disabled");
   int early_init ;
    klee_make_symbolic(&early_init, sizeof(int), "early_init");
   bool broken_hierarchy ;
   bool warned_broken_hierarchy ;
   int id ;
   char const   *name ;
   struct cgroup_root *root ;
   struct idr css_idr ;
   struct list_head cfts ;
   struct cftype *dfl_cftypes ;
   struct cftype *legacy_cftypes ;
   unsigned int depends_on ;
    klee_make_symbolic(&depends_on, sizeof(int), "depends_on");
};
struct futex_pi_state;
struct robust_list_head;
struct bio_list;
struct fs_struct;
struct perf_event_context;
struct blk_plug;
struct nameidata;
struct cfs_rq;
struct task_group;
struct sighand_struct {
   atomic_t count ;
   struct k_sigaction action[64U] ;
   spinlock_t siglock ;
   wait_queue_head_t signalfd_wqh ;
};
struct pacct_struct {
   int ac_flag ;
    klee_make_symbolic(&ac_flag, sizeof(int), "ac_flag");
   long ac_exitcode ;
    klee_make_symbolic(&ac_exitcode, sizeof(long), "ac_exitcode");
   unsigned long ac_mem ;
    klee_make_symbolic(&ac_mem, sizeof(long), "ac_mem");
   cputime_t ac_utime ;
   cputime_t ac_stime ;
   unsigned long ac_minflt ;
    klee_make_symbolic(&ac_minflt, sizeof(long), "ac_minflt");
   unsigned long ac_majflt ;
    klee_make_symbolic(&ac_majflt, sizeof(long), "ac_majflt");
};
struct cpu_itimer {
   cputime_t expires ;
   cputime_t incr ;
   u32 error ;
   u32 incr_error ;
};
struct cputime {
   cputime_t utime ;
   cputime_t stime ;
};
struct task_cputime {
   cputime_t utime ;
   cputime_t stime ;
   unsigned long long sum_exec_runtime ;
    klee_make_symbolic(&sum_exec_runtime, sizeof(long), "sum_exec_runtime");
};
struct task_cputime_atomic {
   atomic64_t utime ;
   atomic64_t stime ;
   atomic64_t sum_exec_runtime ;
};
struct thread_group_cputimer {
   struct task_cputime_atomic cputime_atomic ;
   int running ;
    klee_make_symbolic(&running, sizeof(int), "running");
};
struct autogroup;
struct tty_struct;
struct taskstats;
struct tty_audit_buf;
struct signal_struct {
   atomic_t sigcnt ;
   atomic_t live ;
   int nr_threads ;
    klee_make_symbolic(&nr_threads, sizeof(int), "nr_threads");
   struct list_head thread_head ;
   wait_queue_head_t wait_chldexit ;
   struct task_struct *curr_target ;
   struct sigpending shared_pending ;
   int group_exit_code ;
    klee_make_symbolic(&group_exit_code, sizeof(int), "group_exit_code");
   int notify_count ;
    klee_make_symbolic(&notify_count, sizeof(int), "notify_count");
   struct task_struct *group_exit_task ;
   int group_stop_count ;
    klee_make_symbolic(&group_stop_count, sizeof(int), "group_stop_count");
   unsigned int flags ;
   unsigned char is_child_subreaper : 1 ;
   unsigned char has_child_subreaper : 1 ;
   int posix_timer_id ;
    klee_make_symbolic(&posix_timer_id, sizeof(int), "posix_timer_id");
   struct list_head posix_timers ;
   struct hrtimer real_timer ;
   struct pid *leader_pid ;
   ktime_t it_real_incr ;
   struct cpu_itimer it[2U] ;
   struct thread_group_cputimer cputimer ;
   struct task_cputime cputime_expires ;
   struct list_head cpu_timers[3U] ;
   struct pid *tty_old_pgrp ;
   int leader ;
    klee_make_symbolic(&leader, sizeof(int), "leader");
   struct tty_struct *tty ;
   struct autogroup *autogroup ;
   seqlock_t stats_lock ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t cutime ;
   cputime_t cstime ;
   cputime_t gtime ;
   cputime_t cgtime ;
   struct cputime prev_cputime ;
   unsigned long nvcsw ;
    klee_make_symbolic(&nvcsw, sizeof(long), "nvcsw");
   unsigned long nivcsw ;
    klee_make_symbolic(&nivcsw, sizeof(long), "nivcsw");
   unsigned long cnvcsw ;
    klee_make_symbolic(&cnvcsw, sizeof(long), "cnvcsw");
   unsigned long cnivcsw ;
    klee_make_symbolic(&cnivcsw, sizeof(long), "cnivcsw");
   unsigned long min_flt ;
    klee_make_symbolic(&min_flt, sizeof(long), "min_flt");
   unsigned long maj_flt ;
    klee_make_symbolic(&maj_flt, sizeof(long), "maj_flt");
   unsigned long cmin_flt ;
    klee_make_symbolic(&cmin_flt, sizeof(long), "cmin_flt");
   unsigned long cmaj_flt ;
    klee_make_symbolic(&cmaj_flt, sizeof(long), "cmaj_flt");
   unsigned long inblock ;
    klee_make_symbolic(&inblock, sizeof(long), "inblock");
   unsigned long oublock ;
    klee_make_symbolic(&oublock, sizeof(long), "oublock");
   unsigned long cinblock ;
    klee_make_symbolic(&cinblock, sizeof(long), "cinblock");
   unsigned long coublock ;
    klee_make_symbolic(&coublock, sizeof(long), "coublock");
   unsigned long maxrss ;
    klee_make_symbolic(&maxrss, sizeof(long), "maxrss");
   unsigned long cmaxrss ;
    klee_make_symbolic(&cmaxrss, sizeof(long), "cmaxrss");
   struct task_io_accounting ioac ;
   unsigned long long sum_sched_runtime ;
    klee_make_symbolic(&sum_sched_runtime, sizeof(long), "sum_sched_runtime");
   struct rlimit rlim[16U] ;
   struct pacct_struct pacct ;
   struct taskstats *stats ;
   unsigned int audit_tty ;
    klee_make_symbolic(&audit_tty, sizeof(int), "audit_tty");
   unsigned int audit_tty_log_passwd ;
    klee_make_symbolic(&audit_tty_log_passwd, sizeof(int), "audit_tty_log_passwd");
   struct tty_audit_buf *tty_audit_buf ;
   oom_flags_t oom_flags ;
   short oom_score_adj ;
    klee_make_symbolic(&oom_score_adj, sizeof(short), "oom_score_adj");
   short oom_score_adj_min ;
    klee_make_symbolic(&oom_score_adj_min, sizeof(short), "oom_score_adj_min");
   struct mutex cred_guard_mutex ;
};
struct user_struct {
   atomic_t __count ;
   atomic_t processes ;
   atomic_t sigpending ;
   atomic_t inotify_watches ;
   atomic_t inotify_devs ;
   atomic_t fanotify_listeners ;
   atomic_long_t epoll_watches ;
   unsigned long mq_bytes ;
    klee_make_symbolic(&mq_bytes, sizeof(long), "mq_bytes");
   unsigned long locked_shm ;
    klee_make_symbolic(&locked_shm, sizeof(long), "locked_shm");
   struct key *uid_keyring ;
   struct key *session_keyring ;
   struct hlist_node uidhash_node ;
   kuid_t uid ;
   atomic_long_t locked_vm ;
};
struct backing_dev_info;
struct reclaim_state;
struct sched_info {
   unsigned long pcount ;
    klee_make_symbolic(&pcount, sizeof(long), "pcount");
   unsigned long long run_delay ;
    klee_make_symbolic(&run_delay, sizeof(long), "run_delay");
   unsigned long long last_arrival ;
    klee_make_symbolic(&last_arrival, sizeof(long), "last_arrival");
   unsigned long long last_queued ;
    klee_make_symbolic(&last_queued, sizeof(long), "last_queued");
};
struct task_delay_info {
   spinlock_t lock ;
   unsigned int flags ;
   u64 blkio_start ;
   u64 blkio_delay ;
   u64 swapin_delay ;
   u32 blkio_count ;
   u32 swapin_count ;
   u64 freepages_start ;
   u64 freepages_delay ;
   u32 freepages_count ;
};
struct wake_q_node {
   struct wake_q_node *next ;
};
struct io_context;
struct pipe_inode_info;
struct uts_namespace;
struct load_weight {
   unsigned long weight ;
    klee_make_symbolic(&weight, sizeof(long), "weight");
   u32 inv_weight ;
};
struct sched_avg {
   u64 last_runnable_update ;
   s64 decay_count ;
   unsigned long load_avg_contrib ;
    klee_make_symbolic(&load_avg_contrib, sizeof(long), "load_avg_contrib");
   unsigned long utilization_avg_contrib ;
    klee_make_symbolic(&utilization_avg_contrib, sizeof(long), "utilization_avg_contrib");
   u32 runnable_avg_sum ;
   u32 avg_period ;
   u32 running_avg_sum ;
};
struct sched_statistics {
   u64 wait_start ;
   u64 wait_max ;
   u64 wait_count ;
   u64 wait_sum ;
   u64 iowait_count ;
   u64 iowait_sum ;
   u64 sleep_start ;
   u64 sleep_max ;
   s64 sum_sleep_runtime ;
   u64 block_start ;
   u64 block_max ;
   u64 exec_max ;
   u64 slice_max ;
   u64 nr_migrations_cold ;
   u64 nr_failed_migrations_affine ;
   u64 nr_failed_migrations_running ;
   u64 nr_failed_migrations_hot ;
   u64 nr_forced_migrations ;
   u64 nr_wakeups ;
   u64 nr_wakeups_sync ;
   u64 nr_wakeups_migrate ;
   u64 nr_wakeups_local ;
   u64 nr_wakeups_remote ;
   u64 nr_wakeups_affine ;
   u64 nr_wakeups_affine_attempts ;
   u64 nr_wakeups_passive ;
   u64 nr_wakeups_idle ;
};
struct sched_entity {
   struct load_weight load ;
   struct rb_node run_node ;
   struct list_head group_node ;
   unsigned int on_rq ;
    klee_make_symbolic(&on_rq, sizeof(int), "on_rq");
   u64 exec_start ;
   u64 sum_exec_runtime ;
   u64 vruntime ;
   u64 prev_sum_exec_runtime ;
   u64 nr_migrations ;
   struct sched_statistics statistics ;
   int depth ;
   struct sched_entity *parent ;
   struct cfs_rq *cfs_rq ;
   struct cfs_rq *my_q ;
   struct sched_avg avg ;
};
struct rt_rq;
struct sched_rt_entity {
   struct list_head run_list ;
   unsigned long timeout ;
    klee_make_symbolic(&timeout, sizeof(long), "timeout");
   unsigned long watchdog_stamp ;
    klee_make_symbolic(&watchdog_stamp, sizeof(long), "watchdog_stamp");
   unsigned int time_slice ;
    klee_make_symbolic(&time_slice, sizeof(int), "time_slice");
   struct sched_rt_entity *back ;
   struct sched_rt_entity *parent ;
   struct rt_rq *rt_rq ;
   struct rt_rq *my_q ;
};
struct sched_dl_entity {
   struct rb_node rb_node ;
   u64 dl_runtime ;
   u64 dl_deadline ;
   u64 dl_period ;
   u64 dl_bw ;
   s64 runtime ;
   u64 deadline ;
   unsigned int flags ;
   int dl_throttled ;
    klee_make_symbolic(&dl_throttled, sizeof(int), "dl_throttled");
   int dl_new ;
    klee_make_symbolic(&dl_new, sizeof(int), "dl_new");
   int dl_boosted ;
    klee_make_symbolic(&dl_boosted, sizeof(int), "dl_boosted");
   int dl_yielded ;
    klee_make_symbolic(&dl_yielded, sizeof(int), "dl_yielded");
   struct hrtimer dl_timer ;
};
struct memcg_oom_info {
   struct mem_cgroup *memcg ;
   gfp_t gfp_mask ;
   int order ;
    klee_make_symbolic(&order, sizeof(int), "order");
   unsigned char may_oom : 1 ;
};
struct sched_class;
struct files_struct;
struct compat_robust_list_head;
struct numa_group;
struct ftrace_ret_stack;
struct task_struct {
   long volatile   state ;
   void *stack ;
   atomic_t usage ;
   unsigned int flags ;
   unsigned int ptrace ;
    klee_make_symbolic(&ptrace, sizeof(int), "ptrace");
   struct llist_node wake_entry ;
   int on_cpu ;
    klee_make_symbolic(&on_cpu, sizeof(int), "on_cpu");
   struct task_struct *last_wakee ;
   unsigned long wakee_flips ;
    klee_make_symbolic(&wakee_flips, sizeof(long), "wakee_flips");
   unsigned long wakee_flip_decay_ts ;
    klee_make_symbolic(&wakee_flip_decay_ts, sizeof(long), "wakee_flip_decay_ts");
   int wake_cpu ;
    klee_make_symbolic(&wake_cpu, sizeof(int), "wake_cpu");
   int on_rq ;
   int prio ;
   int static_prio ;
    klee_make_symbolic(&static_prio, sizeof(int), "static_prio");
   int normal_prio ;
    klee_make_symbolic(&normal_prio, sizeof(int), "normal_prio");
   unsigned int rt_priority ;
    klee_make_symbolic(&rt_priority, sizeof(int), "rt_priority");
   struct sched_class  const  *sched_class ;
   struct sched_entity se ;
   struct sched_rt_entity rt ;
   struct task_group *sched_task_group ;
   struct sched_dl_entity dl ;
   struct hlist_head preempt_notifiers ;
   unsigned int btrace_seq ;
    klee_make_symbolic(&btrace_seq, sizeof(int), "btrace_seq");
   unsigned int policy ;
    klee_make_symbolic(&policy, sizeof(int), "policy");
   int nr_cpus_allowed ;
    klee_make_symbolic(&nr_cpus_allowed, sizeof(int), "nr_cpus_allowed");
   cpumask_t cpus_allowed ;
   unsigned long rcu_tasks_nvcsw ;
    klee_make_symbolic(&rcu_tasks_nvcsw, sizeof(long), "rcu_tasks_nvcsw");
   bool rcu_tasks_holdout ;
   struct list_head rcu_tasks_holdout_list ;
   int rcu_tasks_idle_cpu ;
    klee_make_symbolic(&rcu_tasks_idle_cpu, sizeof(int), "rcu_tasks_idle_cpu");
   struct sched_info sched_info ;
   struct list_head tasks ;
   struct plist_node pushable_tasks ;
   struct rb_node pushable_dl_tasks ;
   struct mm_struct *mm ;
   struct mm_struct *active_mm ;
   u32 vmacache_seqnum ;
   struct vm_area_struct *vmacache[4U] ;
   struct task_rss_stat rss_stat ;
   int exit_state ;
    klee_make_symbolic(&exit_state, sizeof(int), "exit_state");
   int exit_code ;
    klee_make_symbolic(&exit_code, sizeof(int), "exit_code");
   int exit_signal ;
    klee_make_symbolic(&exit_signal, sizeof(int), "exit_signal");
   int pdeath_signal ;
    klee_make_symbolic(&pdeath_signal, sizeof(int), "pdeath_signal");
   unsigned long jobctl ;
    klee_make_symbolic(&jobctl, sizeof(long), "jobctl");
   unsigned int personality ;
    klee_make_symbolic(&personality, sizeof(int), "personality");
   unsigned char in_execve : 1 ;
   unsigned char in_iowait : 1 ;
   unsigned char sched_reset_on_fork : 1 ;
   unsigned char sched_contributes_to_load : 1 ;
   unsigned char sched_migrated : 1 ;
   unsigned char memcg_kmem_skip_account : 1 ;
   unsigned char brk_randomized : 1 ;
   unsigned long atomic_flags ;
    klee_make_symbolic(&atomic_flags, sizeof(long), "atomic_flags");
   struct restart_block restart_block ;
   pid_t pid ;
   pid_t tgid ;
   struct task_struct *real_parent ;
   struct task_struct *parent ;
   struct list_head children ;
   struct list_head sibling ;
   struct task_struct *group_leader ;
   struct list_head ptraced ;
   struct list_head ptrace_entry ;
   struct pid_link pids[3U] ;
   struct list_head thread_group ;
   struct list_head thread_node ;
   struct completion *vfork_done ;
   int *set_child_tid ;
   int *clear_child_tid ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t utimescaled ;
   cputime_t stimescaled ;
   cputime_t gtime ;
   struct cputime prev_cputime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   u64 start_time ;
   u64 real_start_time ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   struct task_cputime cputime_expires ;
   struct list_head cpu_timers[3U] ;
   struct cred  const  *real_cred ;
   struct cred  const  *cred ;
   char comm[16U] ;
   struct nameidata *nameidata ;
   struct sysv_sem sysvsem ;
   struct sysv_shm sysvshm ;
   unsigned long last_switch_count ;
    klee_make_symbolic(&last_switch_count, sizeof(long), "last_switch_count");
   struct thread_struct thread ;
   struct fs_struct *fs ;
   struct files_struct *files ;
   struct nsproxy *nsproxy ;
   struct signal_struct *signal ;
   struct sighand_struct *sighand ;
   sigset_t blocked ;
   sigset_t real_blocked ;
   sigset_t saved_sigmask ;
   struct sigpending pending ;
   unsigned long sas_ss_sp ;
    klee_make_symbolic(&sas_ss_sp, sizeof(long), "sas_ss_sp");
   size_t sas_ss_size ;
   int (*notifier)(void * ) ;
   void *notifier_data ;
   sigset_t *notifier_mask ;
   struct callback_head *task_works ;
   struct audit_context *audit_context ;
   kuid_t loginuid ;
   unsigned int sessionid ;
    klee_make_symbolic(&sessionid, sizeof(int), "sessionid");
   struct seccomp seccomp ;
   u32 parent_exec_id ;
   u32 self_exec_id ;
   spinlock_t alloc_lock ;
   raw_spinlock_t pi_lock ;
   struct wake_q_node wake_q ;
   struct rb_root pi_waiters ;
   struct rb_node *pi_waiters_leftmost ;
   struct rt_mutex_waiter *pi_blocked_on ;
   struct mutex_waiter *blocked_on ;
   unsigned int irq_events ;
    klee_make_symbolic(&irq_events, sizeof(int), "irq_events");
   unsigned long hardirq_enable_ip ;
    klee_make_symbolic(&hardirq_enable_ip, sizeof(long), "hardirq_enable_ip");
   unsigned long hardirq_disable_ip ;
    klee_make_symbolic(&hardirq_disable_ip, sizeof(long), "hardirq_disable_ip");
   unsigned int hardirq_enable_event ;
    klee_make_symbolic(&hardirq_enable_event, sizeof(int), "hardirq_enable_event");
   unsigned int hardirq_disable_event ;
    klee_make_symbolic(&hardirq_disable_event, sizeof(int), "hardirq_disable_event");
   int hardirqs_enabled ;
    klee_make_symbolic(&hardirqs_enabled, sizeof(int), "hardirqs_enabled");
   int hardirq_context ;
    klee_make_symbolic(&hardirq_context, sizeof(int), "hardirq_context");
   unsigned long softirq_disable_ip ;
    klee_make_symbolic(&softirq_disable_ip, sizeof(long), "softirq_disable_ip");
   unsigned long softirq_enable_ip ;
    klee_make_symbolic(&softirq_enable_ip, sizeof(long), "softirq_enable_ip");
   unsigned int softirq_disable_event ;
    klee_make_symbolic(&softirq_disable_event, sizeof(int), "softirq_disable_event");
   unsigned int softirq_enable_event ;
    klee_make_symbolic(&softirq_enable_event, sizeof(int), "softirq_enable_event");
   int softirqs_enabled ;
    klee_make_symbolic(&softirqs_enabled, sizeof(int), "softirqs_enabled");
   int softirq_context ;
    klee_make_symbolic(&softirq_context, sizeof(int), "softirq_context");
   u64 curr_chain_key ;
   int lockdep_depth ;
    klee_make_symbolic(&lockdep_depth, sizeof(int), "lockdep_depth");
   unsigned int lockdep_recursion ;
    klee_make_symbolic(&lockdep_recursion, sizeof(int), "lockdep_recursion");
   struct held_lock held_locks[48U] ;
   gfp_t lockdep_reclaim_gfp ;
   void *journal_info ;
   struct bio_list *bio_list ;
   struct blk_plug *plug ;
   struct reclaim_state *reclaim_state ;
   struct backing_dev_info *backing_dev_info ;
   struct io_context *io_context ;
   unsigned long ptrace_message ;
    klee_make_symbolic(&ptrace_message, sizeof(long), "ptrace_message");
   siginfo_t *last_siginfo ;
   struct task_io_accounting ioac ;
   u64 acct_rss_mem1 ;
   u64 acct_vm_mem1 ;
   cputime_t acct_timexpd ;
   nodemask_t mems_allowed ;
   seqcount_t mems_allowed_seq ;
   int cpuset_mem_spread_rotor ;
    klee_make_symbolic(&cpuset_mem_spread_rotor, sizeof(int), "cpuset_mem_spread_rotor");
   int cpuset_slab_spread_rotor ;
    klee_make_symbolic(&cpuset_slab_spread_rotor, sizeof(int), "cpuset_slab_spread_rotor");
   struct css_set *cgroups ;
   struct list_head cg_list ;
   struct robust_list_head *robust_list ;
   struct compat_robust_list_head *compat_robust_list ;
   struct list_head pi_state_list ;
   struct futex_pi_state *pi_state_cache ;
   struct perf_event_context *perf_event_ctxp[2U] ;
   struct mutex perf_event_mutex ;
   struct list_head perf_event_list ;
   struct mempolicy *mempolicy ;
   short il_next ;
    klee_make_symbolic(&il_next, sizeof(short), "il_next");
   short pref_node_fork ;
    klee_make_symbolic(&pref_node_fork, sizeof(short), "pref_node_fork");
   int numa_scan_seq ;
   unsigned int numa_scan_period ;
    klee_make_symbolic(&numa_scan_period, sizeof(int), "numa_scan_period");
   unsigned int numa_scan_period_max ;
    klee_make_symbolic(&numa_scan_period_max, sizeof(int), "numa_scan_period_max");
   int numa_preferred_nid ;
    klee_make_symbolic(&numa_preferred_nid, sizeof(int), "numa_preferred_nid");
   unsigned long numa_migrate_retry ;
    klee_make_symbolic(&numa_migrate_retry, sizeof(long), "numa_migrate_retry");
   u64 node_stamp ;
   u64 last_task_numa_placement ;
   u64 last_sum_exec_runtime ;
   struct callback_head numa_work ;
   struct list_head numa_entry ;
   struct numa_group *numa_group ;
   unsigned long *numa_faults ;
   unsigned long total_numa_faults ;
    klee_make_symbolic(&total_numa_faults, sizeof(long), "total_numa_faults");
   unsigned long numa_faults_locality[3U] ;
   unsigned long numa_pages_migrated ;
    klee_make_symbolic(&numa_pages_migrated, sizeof(long), "numa_pages_migrated");
   struct callback_head rcu ;
   struct pipe_inode_info *splice_pipe ;
   struct page_frag task_frag ;
   struct task_delay_info *delays ;
   int make_it_fail ;
    klee_make_symbolic(&make_it_fail, sizeof(int), "make_it_fail");
   int nr_dirtied ;
    klee_make_symbolic(&nr_dirtied, sizeof(int), "nr_dirtied");
   int nr_dirtied_pause ;
    klee_make_symbolic(&nr_dirtied_pause, sizeof(int), "nr_dirtied_pause");
   unsigned long dirty_paused_when ;
    klee_make_symbolic(&dirty_paused_when, sizeof(long), "dirty_paused_when");
   int latency_record_count ;
    klee_make_symbolic(&latency_record_count, sizeof(int), "latency_record_count");
   struct latency_record latency_record[32U] ;
   unsigned long timer_slack_ns ;
    klee_make_symbolic(&timer_slack_ns, sizeof(long), "timer_slack_ns");
   unsigned long default_timer_slack_ns ;
    klee_make_symbolic(&default_timer_slack_ns, sizeof(long), "default_timer_slack_ns");
   unsigned int kasan_depth ;
    klee_make_symbolic(&kasan_depth, sizeof(int), "kasan_depth");
   int curr_ret_stack ;
    klee_make_symbolic(&curr_ret_stack, sizeof(int), "curr_ret_stack");
   struct ftrace_ret_stack *ret_stack ;
   unsigned long long ftrace_timestamp ;
    klee_make_symbolic(&ftrace_timestamp, sizeof(long), "ftrace_timestamp");
   atomic_t trace_overrun ;
   atomic_t tracing_graph_pause ;
   unsigned long trace ;
    klee_make_symbolic(&trace, sizeof(long), "trace");
   unsigned long trace_recursion ;
    klee_make_symbolic(&trace_recursion, sizeof(long), "trace_recursion");
   struct memcg_oom_info memcg_oom ;
   struct uprobe_task *utask ;
   unsigned int sequential_io ;
    klee_make_symbolic(&sequential_io, sizeof(int), "sequential_io");
   unsigned int sequential_io_avg ;
    klee_make_symbolic(&sequential_io_avg, sizeof(int), "sequential_io_avg");
   unsigned long task_state_change ;
    klee_make_symbolic(&task_state_change, sizeof(long), "task_state_change");
   int pagefault_disabled ;
    klee_make_symbolic(&pagefault_disabled, sizeof(int), "pagefault_disabled");
};
struct ieee80211_sta;
struct iwl_priv;
struct iwl_op_mode;
struct ieee80211_hw;
struct ieee80211_supported_band;
struct iovec {
   void *iov_base ;
   __kernel_size_t iov_len ;
};
struct kvec {
   void *iov_base ;
   size_t iov_len ;
};
union __anonunion____missing_field_name_217 {
   struct iovec  const  *iov ;
   struct kvec  const  *kvec ;
   struct bio_vec  const  *bvec ;
};
struct iov_iter {
   int type ;
    klee_make_symbolic(&type, sizeof(int), "type");
   size_t iov_offset ;
   size_t count ;
   union __anonunion____missing_field_name_217 __annonCompField58 ;
   unsigned long nr_segs ;
    klee_make_symbolic(&nr_segs, sizeof(long), "nr_segs");
};
typedef unsigned short __kernel_sa_family_t;
    klee_make_symbolic(&__kernel_sa_family_t, sizeof(short), "__kernel_sa_family_t");
typedef __kernel_sa_family_t sa_family_t;
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14U] ;
};
struct kiocb;
struct msghdr {
   void *msg_name ;
   int msg_namelen ;
    klee_make_symbolic(&msg_namelen, sizeof(int), "msg_namelen");
   struct iov_iter msg_iter ;
   void *msg_control ;
   __kernel_size_t msg_controllen ;
   unsigned int msg_flags ;
    klee_make_symbolic(&msg_flags, sizeof(int), "msg_flags");
   struct kiocb *msg_iocb ;
};
enum ldv_17802 {
    SS_FREE = 0,
    SS_UNCONNECTED = 1,
    SS_CONNECTING = 2,
    SS_CONNECTED = 3,
    SS_DISCONNECTING = 4
} ;
typedef enum ldv_17802 socket_state;
struct poll_table_struct;
struct net;
struct fasync_struct;
struct socket_wq {
   wait_queue_head_t wait ;
   struct fasync_struct *fasync_list ;
   struct callback_head rcu ;
};
struct proto_ops;
struct socket {
   socket_state state ;
   short type ;
   unsigned long flags ;
   struct socket_wq *wq ;
   struct file *file ;
   struct sock *sk ;
   struct proto_ops  const  *ops ;
};
struct proto_ops {
   int family ;
    klee_make_symbolic(&family, sizeof(int), "family");
   struct module *owner ;
   int (*release)(struct socket * ) ;
   int (*bind)(struct socket * , struct sockaddr * , int  ) ;
   int (*connect)(struct socket * , struct sockaddr * , int  , int  ) ;
   int (*socketpair)(struct socket * , struct socket * ) ;
   int (*accept)(struct socket * , struct socket * , int  ) ;
   int (*getname)(struct socket * , struct sockaddr * , int * , int  ) ;
   unsigned int (*poll)(struct file * , struct socket * , struct poll_table_struct * ) ;
   int (*ioctl)(struct socket * , unsigned int  , unsigned long  ) ;
   int (*compat_ioctl)(struct socket * , unsigned int  , unsigned long  ) ;
   int (*listen)(struct socket * , int  ) ;
   int (*shutdown)(struct socket * , int  ) ;
   int (*setsockopt)(struct socket * , int  , int  , char * , unsigned int  ) ;
   int (*getsockopt)(struct socket * , int  , int  , char * , int * ) ;
   int (*compat_setsockopt)(struct socket * , int  , int  , char * , unsigned int  ) ;
   int (*compat_getsockopt)(struct socket * , int  , int  , char * , int * ) ;
   int (*sendmsg)(struct socket * , struct msghdr * , size_t  ) ;
   int (*recvmsg)(struct socket * , struct msghdr * , size_t  , int  ) ;
   int (*mmap)(struct file * , struct socket * , struct vm_area_struct * ) ;
   ssize_t (*sendpage)(struct socket * , struct page * , int  , size_t  , int  ) ;
   ssize_t (*splice_read)(struct socket * , loff_t * , struct pipe_inode_info * ,
                          size_t  , unsigned int  ) ;
   int (*set_peek_off)(struct sock * , int  ) ;
};
struct exception_table_entry {
   int insn ;
    klee_make_symbolic(&insn, sizeof(int), "insn");
   int fixup ;
    klee_make_symbolic(&fixup, sizeof(int), "fixup");
};
struct in6_addr;
struct sk_buff;
struct klist_node;
struct klist_node {
   void *n_klist ;
   struct list_head n_node ;
   struct kref n_ref ;
};
struct path;
struct seq_file {
   char *buf ;
   size_t size ;
   size_t from ;
   size_t count ;
   size_t pad_until ;
   loff_t index ;
   loff_t read_pos ;
   u64 version ;
   struct mutex lock ;
   struct seq_operations  const  *op ;
   int poll_event ;
    klee_make_symbolic(&poll_event, sizeof(int), "poll_event");
   struct user_namespace *user_ns ;
   void *private ;
};
struct seq_operations {
   void *(*start)(struct seq_file * , loff_t * ) ;
   void (*stop)(struct seq_file * , void * ) ;
   void *(*next)(struct seq_file * , void * , loff_t * ) ;
   int (*show)(struct seq_file * , void * ) ;
};
struct pinctrl;
struct pinctrl_state;
struct dev_pin_info {
   struct pinctrl *p ;
   struct pinctrl_state *default_state ;
   struct pinctrl_state *sleep_state ;
   struct pinctrl_state *idle_state ;
};
struct dma_map_ops;
struct dev_archdata {
   struct dma_map_ops *dma_ops ;
   void *iommu ;
};
struct device_private;
struct device_driver;
struct driver_private;
struct class;
struct subsys_private;
struct bus_type;
struct device_node;
struct fwnode_handle;
struct iommu_ops;
struct iommu_group;
struct device_attribute;
struct bus_type {
   char const   *name ;
   char const   *dev_name ;
   struct device *dev_root ;
   struct device_attribute *dev_attrs ;
   struct attribute_group  const  **bus_groups ;
   struct attribute_group  const  **dev_groups ;
   struct attribute_group  const  **drv_groups ;
   int (*match)(struct device * , struct device_driver * ) ;
   int (*uevent)(struct device * , struct kobj_uevent_env * ) ;
   int (*probe)(struct device * ) ;
   int (*remove)(struct device * ) ;
   void (*shutdown)(struct device * ) ;
   int (*online)(struct device * ) ;
   int (*offline)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
   struct iommu_ops  const  *iommu_ops ;
   struct subsys_private *p ;
   struct lock_class_key lock_key ;
};
struct device_type;
enum probe_type {
    PROBE_DEFAULT_STRATEGY = 0,
    PROBE_PREFER_ASYNCHRONOUS = 1,
    PROBE_FORCE_SYNCHRONOUS = 2
} ;
struct of_device_id;
struct acpi_device_id;
struct device_driver {
   char const   *name ;
   struct bus_type *bus ;
   struct module *owner ;
   char const   *mod_name ;
   bool suppress_bind_attrs ;
   enum probe_type probe_type ;
   struct of_device_id  const  *of_match_table ;
   struct acpi_device_id  const  *acpi_match_table ;
   int (*probe)(struct device * ) ;
   int (*remove)(struct device * ) ;
   void (*shutdown)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct attribute_group  const  **groups ;
   struct dev_pm_ops  const  *pm ;
   struct driver_private *p ;
};
struct class_attribute;
struct class {
   char const   *name ;
   struct module *owner ;
   struct class_attribute *class_attrs ;
   struct attribute_group  const  **dev_groups ;
   struct kobject *dev_kobj ;
   int (*dev_uevent)(struct device * , struct kobj_uevent_env * ) ;
   char *(*devnode)(struct device * , umode_t * ) ;
   void (*class_release)(struct class * ) ;
   void (*dev_release)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct kobj_ns_type_operations  const  *ns_type ;
   void const   *(*namespace)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
   struct subsys_private *p ;
};
struct class_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct class * , struct class_attribute * , char * ) ;
   ssize_t (*store)(struct class * , struct class_attribute * , char const   * , size_t  ) ;
};
struct device_type {
   char const   *name ;
   struct attribute_group  const  **groups ;
   int (*uevent)(struct device * , struct kobj_uevent_env * ) ;
   char *(*devnode)(struct device * , umode_t * , kuid_t * , kgid_t * ) ;
   void (*release)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
};
struct device_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct device * , struct device_attribute * , char * ) ;
   ssize_t (*store)(struct device * , struct device_attribute * , char const   * ,
                    size_t  ) ;
};
struct device_dma_parameters {
   unsigned int max_segment_size ;
    klee_make_symbolic(&max_segment_size, sizeof(int), "max_segment_size");
   unsigned long segment_boundary_mask ;
    klee_make_symbolic(&segment_boundary_mask, sizeof(long), "segment_boundary_mask");
};
struct dma_coherent_mem;
struct cma;
struct device {
   struct device *parent ;
   struct device_private *p ;
   struct kobject kobj ;
   char const   *init_name ;
   struct device_type  const  *type ;
   struct mutex mutex ;
   struct bus_type *bus ;
   struct device_driver *driver ;
   void *platform_data ;
   void *driver_data ;
   struct dev_pm_info power ;
   struct dev_pm_domain *pm_domain ;
   struct dev_pin_info *pins ;
   int numa_node ;
    klee_make_symbolic(&numa_node, sizeof(int), "numa_node");
   u64 *dma_mask ;
   u64 coherent_dma_mask ;
   unsigned long dma_pfn_offset ;
    klee_make_symbolic(&dma_pfn_offset, sizeof(long), "dma_pfn_offset");
   struct device_dma_parameters *dma_parms ;
   struct list_head dma_pools ;
   struct dma_coherent_mem *dma_mem ;
   struct cma *cma_area ;
   struct dev_archdata archdata ;
   struct device_node *of_node ;
   struct fwnode_handle *fwnode ;
   dev_t devt ;
   u32 id ;
   spinlock_t devres_lock ;
   struct list_head devres_head ;
   struct klist_node knode_class ;
   struct class *class ;
   struct attribute_group  const  **groups ;
   void (*release)(struct device * ) ;
   struct iommu_group *iommu_group ;
   bool offline_disabled ;
   bool offline ;
};
struct wakeup_source {
   char const   *name ;
   struct list_head entry ;
   spinlock_t lock ;
   struct wake_irq *wakeirq ;
   struct timer_list timer ;
   unsigned long timer_expires ;
   ktime_t total_time ;
   ktime_t max_time ;
   ktime_t last_time ;
   ktime_t start_prevent_time ;
   ktime_t prevent_sleep_time ;
   unsigned long event_count ;
    klee_make_symbolic(&event_count, sizeof(long), "event_count");
   unsigned long active_count ;
    klee_make_symbolic(&active_count, sizeof(long), "active_count");
   unsigned long relax_count ;
    klee_make_symbolic(&relax_count, sizeof(long), "relax_count");
   unsigned long expire_count ;
    klee_make_symbolic(&expire_count, sizeof(long), "expire_count");
   unsigned long wakeup_count ;
    klee_make_symbolic(&wakeup_count, sizeof(long), "wakeup_count");
   bool active ;
   bool autosleep_enabled ;
};
struct dma_attrs {
   unsigned long flags[1U] ;
};
enum dma_data_direction {
    DMA_BIDIRECTIONAL = 0,
    DMA_TO_DEVICE = 1,
    DMA_FROM_DEVICE = 2,
    DMA_NONE = 3
} ;
struct shrink_control {
   gfp_t gfp_mask ;
   unsigned long nr_to_scan ;
    klee_make_symbolic(&nr_to_scan, sizeof(long), "nr_to_scan");
   int nid ;
    klee_make_symbolic(&nid, sizeof(int), "nid");
   struct mem_cgroup *memcg ;
};
struct shrinker {
   unsigned long (*count_objects)(struct shrinker * , struct shrink_control * ) ;
   unsigned long (*scan_objects)(struct shrinker * , struct shrink_control * ) ;
   int seeks ;
    klee_make_symbolic(&seeks, sizeof(int), "seeks");
   long batch ;
    klee_make_symbolic(&batch, sizeof(long), "batch");
   unsigned long flags ;
   struct list_head list ;
   atomic_long_t *nr_deferred ;
};
struct file_ra_state;
struct writeback_control;
struct bdi_writeback;
struct vm_fault {
   unsigned int flags ;
   unsigned long pgoff ;
    klee_make_symbolic(&pgoff, sizeof(long), "pgoff");
   void *virtual_address ;
   struct page *cow_page ;
   struct page *page ;
   unsigned long max_pgoff ;
    klee_make_symbolic(&max_pgoff, sizeof(long), "max_pgoff");
   pte_t *pte ;
};
struct vm_operations_struct {
   void (*open)(struct vm_area_struct * ) ;
   void (*close)(struct vm_area_struct * ) ;
   int (*fault)(struct vm_area_struct * , struct vm_fault * ) ;
   void (*map_pages)(struct vm_area_struct * , struct vm_fault * ) ;
   int (*page_mkwrite)(struct vm_area_struct * , struct vm_fault * ) ;
   int (*pfn_mkwrite)(struct vm_area_struct * , struct vm_fault * ) ;
   int (*access)(struct vm_area_struct * , unsigned long  , void * , int  , int  ) ;
   char const   *(*name)(struct vm_area_struct * ) ;
   int (*set_policy)(struct vm_area_struct * , struct mempolicy * ) ;
   struct mempolicy *(*get_policy)(struct vm_area_struct * , unsigned long  ) ;
   struct page *(*find_special_page)(struct vm_area_struct * , unsigned long  ) ;
};
struct scatterlist {
   unsigned long sg_magic ;
    klee_make_symbolic(&sg_magic, sizeof(long), "sg_magic");
   unsigned long page_link ;
    klee_make_symbolic(&page_link, sizeof(long), "page_link");
   unsigned int offset ;
    klee_make_symbolic(&offset, sizeof(int), "offset");
   unsigned int length ;
    klee_make_symbolic(&length, sizeof(int), "length");
   dma_addr_t dma_address ;
   unsigned int dma_length ;
    klee_make_symbolic(&dma_length, sizeof(int), "dma_length");
};
struct sg_table {
   struct scatterlist *sgl ;
   unsigned int nents ;
    klee_make_symbolic(&nents, sizeof(int), "nents");
   unsigned int orig_nents ;
    klee_make_symbolic(&orig_nents, sizeof(int), "orig_nents");
};
struct dma_map_ops {
   void *(*alloc)(struct device * , size_t  , dma_addr_t * , gfp_t  , struct dma_attrs * ) ;
   void (*free)(struct device * , size_t  , void * , dma_addr_t  , struct dma_attrs * ) ;
   int (*mmap)(struct device * , struct vm_area_struct * , void * , dma_addr_t  ,
               size_t  , struct dma_attrs * ) ;
   int (*get_sgtable)(struct device * , struct sg_table * , void * , dma_addr_t  ,
                      size_t  , struct dma_attrs * ) ;
   dma_addr_t (*map_page)(struct device * , struct page * , unsigned long  , size_t  ,
                          enum dma_data_direction  , struct dma_attrs * ) ;
   void (*unmap_page)(struct device * , dma_addr_t  , size_t  , enum dma_data_direction  ,
                      struct dma_attrs * ) ;
   int (*map_sg)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ,
                 struct dma_attrs * ) ;
   void (*unmap_sg)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ,
                    struct dma_attrs * ) ;
   void (*sync_single_for_cpu)(struct device * , dma_addr_t  , size_t  , enum dma_data_direction  ) ;
   void (*sync_single_for_device)(struct device * , dma_addr_t  , size_t  , enum dma_data_direction  ) ;
   void (*sync_sg_for_cpu)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ) ;
   void (*sync_sg_for_device)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ) ;
   int (*mapping_error)(struct device * , dma_addr_t  ) ;
   int (*dma_supported)(struct device * , u64  ) ;
   int (*set_dma_mask)(struct device * , u64  ) ;
   int is_phys ;
    klee_make_symbolic(&is_phys, sizeof(int), "is_phys");
};
typedef u64 netdev_features_t;
union __anonunion_in6_u_218 {
   __u8 u6_addr8[16U] ;
   __be16 u6_addr16[8U] ;
   __be32 u6_addr32[4U] ;
};
struct in6_addr {
   union __anonunion_in6_u_218 in6_u ;
};
struct ethhdr {
   unsigned char h_dest[6U] ;
   unsigned char h_source[6U] ;
   __be16 h_proto ;
};
struct pipe_buf_operations;
struct pipe_buffer {
   struct page *page ;
   unsigned int offset ;
   unsigned int len ;
    klee_make_symbolic(&len, sizeof(int), "len");
   struct pipe_buf_operations  const  *ops ;
   unsigned int flags ;
   unsigned long private ;
};
struct pipe_inode_info {
   struct mutex mutex ;
   wait_queue_head_t wait ;
   unsigned int nrbufs ;
    klee_make_symbolic(&nrbufs, sizeof(int), "nrbufs");
   unsigned int curbuf ;
    klee_make_symbolic(&curbuf, sizeof(int), "curbuf");
   unsigned int buffers ;
    klee_make_symbolic(&buffers, sizeof(int), "buffers");
   unsigned int readers ;
    klee_make_symbolic(&readers, sizeof(int), "readers");
   unsigned int writers ;
    klee_make_symbolic(&writers, sizeof(int), "writers");
   unsigned int files ;
    klee_make_symbolic(&files, sizeof(int), "files");
   unsigned int waiting_writers ;
    klee_make_symbolic(&waiting_writers, sizeof(int), "waiting_writers");
   unsigned int r_counter ;
    klee_make_symbolic(&r_counter, sizeof(int), "r_counter");
   unsigned int w_counter ;
    klee_make_symbolic(&w_counter, sizeof(int), "w_counter");
   struct page *tmp_page ;
   struct fasync_struct *fasync_readers ;
   struct fasync_struct *fasync_writers ;
   struct pipe_buffer *bufs ;
};
struct pipe_buf_operations {
   int can_merge ;
    klee_make_symbolic(&can_merge, sizeof(int), "can_merge");
   int (*confirm)(struct pipe_inode_info * , struct pipe_buffer * ) ;
   void (*release)(struct pipe_inode_info * , struct pipe_buffer * ) ;
   int (*steal)(struct pipe_inode_info * , struct pipe_buffer * ) ;
   void (*get)(struct pipe_inode_info * , struct pipe_buffer * ) ;
};
struct napi_struct;
struct nf_conntrack {
   atomic_t use ;
};
union __anonunion____missing_field_name_223 {
   struct net_device *physoutdev ;
   char neigh_header[8U] ;
};
union __anonunion____missing_field_name_224 {
   __be32 ipv4_daddr ;
   struct in6_addr ipv6_daddr ;
};
struct nf_bridge_info {
   atomic_t use ;
   unsigned char orig_proto ;
    klee_make_symbolic(&orig_proto, sizeof(char), "orig_proto");
   bool pkt_otherhost ;
   __u16 frag_max_size ;
   unsigned int mask ;
    klee_make_symbolic(&mask, sizeof(int), "mask");
   struct net_device *physindev ;
   union __anonunion____missing_field_name_223 __annonCompField62 ;
   union __anonunion____missing_field_name_224 __annonCompField63 ;
};
struct sk_buff_head {
   struct sk_buff *next ;
   struct sk_buff *prev ;
   __u32 qlen ;
   spinlock_t lock ;
};
typedef unsigned int sk_buff_data_t;
    klee_make_symbolic(&sk_buff_data_t, sizeof(int), "sk_buff_data_t");
struct __anonstruct____missing_field_name_227 {
   u32 stamp_us ;
   u32 stamp_jiffies ;
};
union __anonunion____missing_field_name_226 {
   u64 v64 ;
   struct __anonstruct____missing_field_name_227 __annonCompField64 ;
};
struct skb_mstamp {
   union __anonunion____missing_field_name_226 __annonCompField65 ;
};
union __anonunion____missing_field_name_230 {
   ktime_t tstamp ;
   struct skb_mstamp skb_mstamp ;
};
struct __anonstruct____missing_field_name_229 {
   struct sk_buff *next ;
   struct sk_buff *prev ;
   union __anonunion____missing_field_name_230 __annonCompField66 ;
};
union __anonunion____missing_field_name_228 {
   struct __anonstruct____missing_field_name_229 __annonCompField67 ;
   struct rb_node rbnode ;
};
struct sec_path;
struct __anonstruct____missing_field_name_232 {
   __u16 csum_start ;
   __u16 csum_offset ;
};
union __anonunion____missing_field_name_231 {
   __wsum csum ;
   struct __anonstruct____missing_field_name_232 __annonCompField69 ;
};
union __anonunion____missing_field_name_233 {
   unsigned int napi_id ;
    klee_make_symbolic(&napi_id, sizeof(int), "napi_id");
   unsigned int sender_cpu ;
    klee_make_symbolic(&sender_cpu, sizeof(int), "sender_cpu");
};
union __anonunion____missing_field_name_234 {
   __u32 mark ;
   __u32 reserved_tailroom ;
};
union __anonunion____missing_field_name_235 {
   __be16 inner_protocol ;
   __u8 inner_ipproto ;
};
struct sk_buff {
   union __anonunion____missing_field_name_228 __annonCompField68 ;
   struct sock *sk ;
   struct net_device *dev ;
   char cb[48U] ;
   unsigned long _skb_refdst ;
    klee_make_symbolic(&_skb_refdst, sizeof(long), "_skb_refdst");
   void (*destructor)(struct sk_buff * ) ;
   struct sec_path *sp ;
   struct nf_conntrack *nfct ;
   struct nf_bridge_info *nf_bridge ;
   unsigned int len ;
   unsigned int data_len ;
    klee_make_symbolic(&data_len, sizeof(int), "data_len");
   __u16 mac_len ;
   __u16 hdr_len ;
   __u16 queue_mapping ;
   unsigned char cloned : 1 ;
   unsigned char nohdr : 1 ;
   unsigned char fclone : 2 ;
   unsigned char peeked : 1 ;
   unsigned char head_frag : 1 ;
   unsigned char xmit_more : 1 ;
   __u32 headers_start[0U] ;
   __u8 __pkt_type_offset[0U] ;
   unsigned char pkt_type : 3 ;
   unsigned char pfmemalloc : 1 ;
   unsigned char ignore_df : 1 ;
   unsigned char nfctinfo : 3 ;
   unsigned char nf_trace : 1 ;
   unsigned char ip_summed : 2 ;
   unsigned char ooo_okay : 1 ;
   unsigned char l4_hash : 1 ;
   unsigned char sw_hash : 1 ;
   unsigned char wifi_acked_valid : 1 ;
   unsigned char wifi_acked : 1 ;
   unsigned char no_fcs : 1 ;
   unsigned char encapsulation : 1 ;
   unsigned char encap_hdr_csum : 1 ;
   unsigned char csum_valid : 1 ;
   unsigned char csum_complete_sw : 1 ;
   unsigned char csum_level : 2 ;
   unsigned char csum_bad : 1 ;
   unsigned char ndisc_nodetype : 2 ;
   unsigned char ipvs_property : 1 ;
   unsigned char inner_protocol_type : 1 ;
   unsigned char remcsum_offload : 1 ;
   __u16 tc_index ;
   __u16 tc_verd ;
   union __anonunion____missing_field_name_231 __annonCompField70 ;
   __u32 priority ;
   int skb_iif ;
    klee_make_symbolic(&skb_iif, sizeof(int), "skb_iif");
   __u32 hash ;
   __be16 vlan_proto ;
   __u16 vlan_tci ;
   union __anonunion____missing_field_name_233 __annonCompField71 ;
   __u32 secmark ;
   union __anonunion____missing_field_name_234 __annonCompField72 ;
   union __anonunion____missing_field_name_235 __annonCompField73 ;
   __u16 inner_transport_header ;
   __u16 inner_network_header ;
   __u16 inner_mac_header ;
   __be16 protocol ;
   __u16 transport_header ;
   __u16 network_header ;
   __u16 mac_header ;
   __u32 headers_end[0U] ;
   sk_buff_data_t tail ;
   sk_buff_data_t end ;
   unsigned char *head ;
   unsigned char *data ;
   unsigned int truesize ;
    klee_make_symbolic(&truesize, sizeof(int), "truesize");
   atomic_t users ;
};
struct dst_entry;
struct dql {
   unsigned int num_queued ;
    klee_make_symbolic(&num_queued, sizeof(int), "num_queued");
   unsigned int adj_limit ;
    klee_make_symbolic(&adj_limit, sizeof(int), "adj_limit");
   unsigned int last_obj_cnt ;
    klee_make_symbolic(&last_obj_cnt, sizeof(int), "last_obj_cnt");
   unsigned int limit ;
    klee_make_symbolic(&limit, sizeof(int), "limit");
   unsigned int num_completed ;
    klee_make_symbolic(&num_completed, sizeof(int), "num_completed");
   unsigned int prev_ovlimit ;
    klee_make_symbolic(&prev_ovlimit, sizeof(int), "prev_ovlimit");
   unsigned int prev_num_queued ;
    klee_make_symbolic(&prev_num_queued, sizeof(int), "prev_num_queued");
   unsigned int prev_last_obj_cnt ;
    klee_make_symbolic(&prev_last_obj_cnt, sizeof(int), "prev_last_obj_cnt");
   unsigned int lowest_slack ;
    klee_make_symbolic(&lowest_slack, sizeof(int), "lowest_slack");
   unsigned long slack_start_time ;
    klee_make_symbolic(&slack_start_time, sizeof(long), "slack_start_time");
   unsigned int max_limit ;
    klee_make_symbolic(&max_limit, sizeof(int), "max_limit");
   unsigned int min_limit ;
    klee_make_symbolic(&min_limit, sizeof(int), "min_limit");
   unsigned int slack_hold_time ;
    klee_make_symbolic(&slack_hold_time, sizeof(int), "slack_hold_time");
};
struct __anonstruct_sync_serial_settings_237 {
   unsigned int clock_rate ;
    klee_make_symbolic(&clock_rate, sizeof(int), "clock_rate");
   unsigned int clock_type ;
    klee_make_symbolic(&clock_type, sizeof(int), "clock_type");
   unsigned short loopback ;
    klee_make_symbolic(&loopback, sizeof(short), "loopback");
};
typedef struct __anonstruct_sync_serial_settings_237 sync_serial_settings;
struct __anonstruct_te1_settings_238 {
   unsigned int clock_rate ;
   unsigned int clock_type ;
   unsigned short loopback ;
   unsigned int slot_map ;
    klee_make_symbolic(&slot_map, sizeof(int), "slot_map");
};
typedef struct __anonstruct_te1_settings_238 te1_settings;
struct __anonstruct_raw_hdlc_proto_239 {
   unsigned short encoding ;
    klee_make_symbolic(&encoding, sizeof(short), "encoding");
   unsigned short parity ;
    klee_make_symbolic(&parity, sizeof(short), "parity");
};
typedef struct __anonstruct_raw_hdlc_proto_239 raw_hdlc_proto;
struct __anonstruct_fr_proto_240 {
   unsigned int t391 ;
    klee_make_symbolic(&t391, sizeof(int), "t391");
   unsigned int t392 ;
    klee_make_symbolic(&t392, sizeof(int), "t392");
   unsigned int n391 ;
    klee_make_symbolic(&n391, sizeof(int), "n391");
   unsigned int n392 ;
    klee_make_symbolic(&n392, sizeof(int), "n392");
   unsigned int n393 ;
    klee_make_symbolic(&n393, sizeof(int), "n393");
   unsigned short lmi ;
    klee_make_symbolic(&lmi, sizeof(short), "lmi");
   unsigned short dce ;
    klee_make_symbolic(&dce, sizeof(short), "dce");
};
typedef struct __anonstruct_fr_proto_240 fr_proto;
struct __anonstruct_fr_proto_pvc_241 {
   unsigned int dlci ;
    klee_make_symbolic(&dlci, sizeof(int), "dlci");
};
typedef struct __anonstruct_fr_proto_pvc_241 fr_proto_pvc;
struct __anonstruct_fr_proto_pvc_info_242 {
   unsigned int dlci ;
   char master[16U] ;
};
typedef struct __anonstruct_fr_proto_pvc_info_242 fr_proto_pvc_info;
struct __anonstruct_cisco_proto_243 {
   unsigned int interval ;
    klee_make_symbolic(&interval, sizeof(int), "interval");
   unsigned int timeout ;
};
typedef struct __anonstruct_cisco_proto_243 cisco_proto;
struct ifmap {
   unsigned long mem_start ;
    klee_make_symbolic(&mem_start, sizeof(long), "mem_start");
   unsigned long mem_end ;
    klee_make_symbolic(&mem_end, sizeof(long), "mem_end");
   unsigned short base_addr ;
    klee_make_symbolic(&base_addr, sizeof(short), "base_addr");
   unsigned char irq ;
    klee_make_symbolic(&irq, sizeof(char), "irq");
   unsigned char dma ;
    klee_make_symbolic(&dma, sizeof(char), "dma");
   unsigned char port ;
    klee_make_symbolic(&port, sizeof(char), "port");
};
union __anonunion_ifs_ifsu_244 {
   raw_hdlc_proto *raw_hdlc ;
   cisco_proto *cisco ;
   fr_proto *fr ;
   fr_proto_pvc *fr_pvc ;
   fr_proto_pvc_info *fr_pvc_info ;
   sync_serial_settings *sync ;
   te1_settings *te1 ;
};
struct if_settings {
   unsigned int type ;
   unsigned int size ;
   union __anonunion_ifs_ifsu_244 ifs_ifsu ;
};
union __anonunion_ifr_ifrn_245 {
   char ifrn_name[16U] ;
};
union __anonunion_ifr_ifru_246 {
   struct sockaddr ifru_addr ;
   struct sockaddr ifru_dstaddr ;
   struct sockaddr ifru_broadaddr ;
   struct sockaddr ifru_netmask ;
   struct sockaddr ifru_hwaddr ;
   short ifru_flags ;
    klee_make_symbolic(&ifru_flags, sizeof(short), "ifru_flags");
   int ifru_ivalue ;
    klee_make_symbolic(&ifru_ivalue, sizeof(int), "ifru_ivalue");
   int ifru_mtu ;
    klee_make_symbolic(&ifru_mtu, sizeof(int), "ifru_mtu");
   struct ifmap ifru_map ;
   char ifru_slave[16U] ;
   char ifru_newname[16U] ;
   void *ifru_data ;
   struct if_settings ifru_settings ;
};
struct ifreq {
   union __anonunion_ifr_ifrn_245 ifr_ifrn ;
   union __anonunion_ifr_ifru_246 ifr_ifru ;
};
struct hlist_bl_node;
struct hlist_bl_head {
   struct hlist_bl_node *first ;
};
struct hlist_bl_node {
   struct hlist_bl_node *next ;
   struct hlist_bl_node **pprev ;
};
struct __anonstruct____missing_field_name_251 {
   spinlock_t lock ;
   int count ;
};
union __anonunion____missing_field_name_250 {
   struct __anonstruct____missing_field_name_251 __annonCompField74 ;
};
struct lockref {
   union __anonunion____missing_field_name_250 __annonCompField75 ;
};
struct vfsmount;
struct __anonstruct____missing_field_name_253 {
   u32 hash ;
   u32 len ;
};
union __anonunion____missing_field_name_252 {
   struct __anonstruct____missing_field_name_253 __annonCompField76 ;
   u64 hash_len ;
};
struct qstr {
   union __anonunion____missing_field_name_252 __annonCompField77 ;
   unsigned char const   *name ;
};
struct dentry_operations;
union __anonunion_d_u_254 {
   struct hlist_node d_alias ;
   struct callback_head d_rcu ;
};
struct dentry {
   unsigned int d_flags ;
    klee_make_symbolic(&d_flags, sizeof(int), "d_flags");
   seqcount_t d_seq ;
   struct hlist_bl_node d_hash ;
   struct dentry *d_parent ;
   struct qstr d_name ;
   struct inode *d_inode ;
   unsigned char d_iname[32U] ;
   struct lockref d_lockref ;
   struct dentry_operations  const  *d_op ;
   struct super_block *d_sb ;
   unsigned long d_time ;
    klee_make_symbolic(&d_time, sizeof(long), "d_time");
   void *d_fsdata ;
   struct list_head d_lru ;
   struct list_head d_child ;
   struct list_head d_subdirs ;
   union __anonunion_d_u_254 d_u ;
};
struct dentry_operations {
   int (*d_revalidate)(struct dentry * , unsigned int  ) ;
   int (*d_weak_revalidate)(struct dentry * , unsigned int  ) ;
   int (*d_hash)(struct dentry  const  * , struct qstr * ) ;
   int (*d_compare)(struct dentry  const  * , struct dentry  const  * , unsigned int  ,
                    char const   * , struct qstr  const  * ) ;
   int (*d_delete)(struct dentry  const  * ) ;
   void (*d_release)(struct dentry * ) ;
   void (*d_prune)(struct dentry * ) ;
   void (*d_iput)(struct dentry * , struct inode * ) ;
   char *(*d_dname)(struct dentry * , char * , int  ) ;
   struct vfsmount *(*d_automount)(struct path * ) ;
   int (*d_manage)(struct dentry * , bool  ) ;
   struct inode *(*d_select_inode)(struct dentry * , unsigned int  ) ;
};
struct path {
   struct vfsmount *mnt ;
   struct dentry *dentry ;
};
struct list_lru_one {
   struct list_head list ;
   long nr_items ;
    klee_make_symbolic(&nr_items, sizeof(long), "nr_items");
};
struct list_lru_memcg {
   struct list_lru_one *lru[0U] ;
};
struct list_lru_node {
   spinlock_t lock ;
   struct list_lru_one lru ;
   struct list_lru_memcg *memcg_lrus ;
};
struct list_lru {
   struct list_lru_node *node ;
   struct list_head list ;
};
struct __anonstruct____missing_field_name_258 {
   struct radix_tree_node *parent ;
   void *private_data ;
};
union __anonunion____missing_field_name_257 {
   struct __anonstruct____missing_field_name_258 __annonCompField78 ;
   struct callback_head callback_head ;
};
struct radix_tree_node {
   unsigned int path ;
    klee_make_symbolic(&path, sizeof(int), "path");
   unsigned int count ;
   union __anonunion____missing_field_name_257 __annonCompField79 ;
   struct list_head private_list ;
   void *slots[64U] ;
   unsigned long tags[3U][1U] ;
};
struct radix_tree_root {
   unsigned int height ;
    klee_make_symbolic(&height, sizeof(int), "height");
   gfp_t gfp_mask ;
   struct radix_tree_node *rnode ;
};
struct fiemap_extent {
   __u64 fe_logical ;
   __u64 fe_physical ;
   __u64 fe_length ;
   __u64 fe_reserved64[2U] ;
   __u32 fe_flags ;
   __u32 fe_reserved[3U] ;
};
enum migrate_mode {
    MIGRATE_ASYNC = 0,
    MIGRATE_SYNC_LIGHT = 1,
    MIGRATE_SYNC = 2
} ;
struct block_device;
struct bio_vec {
   struct page *bv_page ;
   unsigned int bv_len ;
    klee_make_symbolic(&bv_len, sizeof(int), "bv_len");
   unsigned int bv_offset ;
    klee_make_symbolic(&bv_offset, sizeof(int), "bv_offset");
};
struct export_operations;
struct kstatfs;
struct swap_info_struct;
struct iattr {
   unsigned int ia_valid ;
    klee_make_symbolic(&ia_valid, sizeof(int), "ia_valid");
   umode_t ia_mode ;
   kuid_t ia_uid ;
   kgid_t ia_gid ;
   loff_t ia_size ;
   struct timespec ia_atime ;
   struct timespec ia_mtime ;
   struct timespec ia_ctime ;
   struct file *ia_file ;
};
struct dquot;
typedef __kernel_uid32_t projid_t;
struct __anonstruct_kprojid_t_262 {
   projid_t val ;
};
typedef struct __anonstruct_kprojid_t_262 kprojid_t;
enum quota_type {
    USRQUOTA = 0,
    GRPQUOTA = 1,
    PRJQUOTA = 2
} ;
typedef long long qsize_t;
    klee_make_symbolic(&qsize_t, sizeof(long), "qsize_t");
union __anonunion____missing_field_name_263 {
   kuid_t uid ;
   kgid_t gid ;
   kprojid_t projid ;
};
struct kqid {
   union __anonunion____missing_field_name_263 __annonCompField81 ;
   enum quota_type type ;
};
struct mem_dqblk {
   qsize_t dqb_bhardlimit ;
   qsize_t dqb_bsoftlimit ;
   qsize_t dqb_curspace ;
   qsize_t dqb_rsvspace ;
   qsize_t dqb_ihardlimit ;
   qsize_t dqb_isoftlimit ;
   qsize_t dqb_curinodes ;
   time_t dqb_btime ;
   time_t dqb_itime ;
};
struct quota_format_type;
struct mem_dqinfo {
   struct quota_format_type *dqi_format ;
   int dqi_fmt_id ;
    klee_make_symbolic(&dqi_fmt_id, sizeof(int), "dqi_fmt_id");
   struct list_head dqi_dirty_list ;
   unsigned long dqi_flags ;
    klee_make_symbolic(&dqi_flags, sizeof(long), "dqi_flags");
   unsigned int dqi_bgrace ;
    klee_make_symbolic(&dqi_bgrace, sizeof(int), "dqi_bgrace");
   unsigned int dqi_igrace ;
    klee_make_symbolic(&dqi_igrace, sizeof(int), "dqi_igrace");
   qsize_t dqi_max_spc_limit ;
   qsize_t dqi_max_ino_limit ;
   void *dqi_priv ;
};
struct dquot {
   struct hlist_node dq_hash ;
   struct list_head dq_inuse ;
   struct list_head dq_free ;
   struct list_head dq_dirty ;
   struct mutex dq_lock ;
   atomic_t dq_count ;
   wait_queue_head_t dq_wait_unused ;
   struct super_block *dq_sb ;
   struct kqid dq_id ;
   loff_t dq_off ;
   unsigned long dq_flags ;
    klee_make_symbolic(&dq_flags, sizeof(long), "dq_flags");
   struct mem_dqblk dq_dqb ;
};
struct quota_format_ops {
   int (*check_quota_file)(struct super_block * , int  ) ;
   int (*read_file_info)(struct super_block * , int  ) ;
   int (*write_file_info)(struct super_block * , int  ) ;
   int (*free_file_info)(struct super_block * , int  ) ;
   int (*read_dqblk)(struct dquot * ) ;
   int (*commit_dqblk)(struct dquot * ) ;
   int (*release_dqblk)(struct dquot * ) ;
};
struct dquot_operations {
   int (*write_dquot)(struct dquot * ) ;
   struct dquot *(*alloc_dquot)(struct super_block * , int  ) ;
   void (*destroy_dquot)(struct dquot * ) ;
   int (*acquire_dquot)(struct dquot * ) ;
   int (*release_dquot)(struct dquot * ) ;
   int (*mark_dirty)(struct dquot * ) ;
   int (*write_info)(struct super_block * , int  ) ;
   qsize_t *(*get_reserved_space)(struct inode * ) ;
   int (*get_projid)(struct inode * , kprojid_t * ) ;
};
struct qc_dqblk {
   int d_fieldmask ;
    klee_make_symbolic(&d_fieldmask, sizeof(int), "d_fieldmask");
   u64 d_spc_hardlimit ;
   u64 d_spc_softlimit ;
   u64 d_ino_hardlimit ;
   u64 d_ino_softlimit ;
   u64 d_space ;
   u64 d_ino_count ;
   s64 d_ino_timer ;
   s64 d_spc_timer ;
   int d_ino_warns ;
    klee_make_symbolic(&d_ino_warns, sizeof(int), "d_ino_warns");
   int d_spc_warns ;
    klee_make_symbolic(&d_spc_warns, sizeof(int), "d_spc_warns");
   u64 d_rt_spc_hardlimit ;
   u64 d_rt_spc_softlimit ;
   u64 d_rt_space ;
   s64 d_rt_spc_timer ;
   int d_rt_spc_warns ;
    klee_make_symbolic(&d_rt_spc_warns, sizeof(int), "d_rt_spc_warns");
};
struct qc_type_state {
   unsigned int flags ;
   unsigned int spc_timelimit ;
    klee_make_symbolic(&spc_timelimit, sizeof(int), "spc_timelimit");
   unsigned int ino_timelimit ;
    klee_make_symbolic(&ino_timelimit, sizeof(int), "ino_timelimit");
   unsigned int rt_spc_timelimit ;
    klee_make_symbolic(&rt_spc_timelimit, sizeof(int), "rt_spc_timelimit");
   unsigned int spc_warnlimit ;
    klee_make_symbolic(&spc_warnlimit, sizeof(int), "spc_warnlimit");
   unsigned int ino_warnlimit ;
    klee_make_symbolic(&ino_warnlimit, sizeof(int), "ino_warnlimit");
   unsigned int rt_spc_warnlimit ;
    klee_make_symbolic(&rt_spc_warnlimit, sizeof(int), "rt_spc_warnlimit");
   unsigned long long ino ;
   blkcnt_t blocks ;
   blkcnt_t nextents ;
};
struct qc_state {
   unsigned int s_incoredqs ;
    klee_make_symbolic(&s_incoredqs, sizeof(int), "s_incoredqs");
   struct qc_type_state s_state[3U] ;
};
struct qc_info {
   int i_fieldmask ;
    klee_make_symbolic(&i_fieldmask, sizeof(int), "i_fieldmask");
   unsigned int i_flags ;
    klee_make_symbolic(&i_flags, sizeof(int), "i_flags");
   unsigned int i_spc_timelimit ;
    klee_make_symbolic(&i_spc_timelimit, sizeof(int), "i_spc_timelimit");
   unsigned int i_ino_timelimit ;
    klee_make_symbolic(&i_ino_timelimit, sizeof(int), "i_ino_timelimit");
   unsigned int i_rt_spc_timelimit ;
    klee_make_symbolic(&i_rt_spc_timelimit, sizeof(int), "i_rt_spc_timelimit");
   unsigned int i_spc_warnlimit ;
    klee_make_symbolic(&i_spc_warnlimit, sizeof(int), "i_spc_warnlimit");
   unsigned int i_ino_warnlimit ;
    klee_make_symbolic(&i_ino_warnlimit, sizeof(int), "i_ino_warnlimit");
   unsigned int i_rt_spc_warnlimit ;
    klee_make_symbolic(&i_rt_spc_warnlimit, sizeof(int), "i_rt_spc_warnlimit");
};
struct quotactl_ops {
   int (*quota_on)(struct super_block * , int  , int  , struct path * ) ;
   int (*quota_off)(struct super_block * , int  ) ;
   int (*quota_enable)(struct super_block * , unsigned int  ) ;
   int (*quota_disable)(struct super_block * , unsigned int  ) ;
   int (*quota_sync)(struct super_block * , int  ) ;
   int (*set_info)(struct super_block * , int  , struct qc_info * ) ;
   int (*get_dqblk)(struct super_block * , struct kqid  , struct qc_dqblk * ) ;
   int (*set_dqblk)(struct super_block * , struct kqid  , struct qc_dqblk * ) ;
   int (*get_state)(struct super_block * , struct qc_state * ) ;
   int (*rm_xquota)(struct super_block * , unsigned int  ) ;
};
struct quota_format_type {
   int qf_fmt_id ;
    klee_make_symbolic(&qf_fmt_id, sizeof(int), "qf_fmt_id");
   struct quota_format_ops  const  *qf_ops ;
   struct module *qf_owner ;
   struct quota_format_type *qf_next ;
};
struct quota_info {
   unsigned int flags ;
   struct mutex dqio_mutex ;
   struct mutex dqonoff_mutex ;
   struct inode *files[3U] ;
   struct mem_dqinfo info[3U] ;
   struct quota_format_ops  const  *ops[3U] ;
};
struct kiocb {
   struct file *ki_filp ;
   loff_t ki_pos ;
   void (*ki_complete)(struct kiocb * , long  , long  ) ;
   void *private ;
   int ki_flags ;
    klee_make_symbolic(&ki_flags, sizeof(int), "ki_flags");
};
struct address_space_operations {
   int (*writepage)(struct page * , struct writeback_control * ) ;
   int (*readpage)(struct file * , struct page * ) ;
   int (*writepages)(struct address_space * , struct writeback_control * ) ;
   int (*set_page_dirty)(struct page * ) ;
   int (*readpages)(struct file * , struct address_space * , struct list_head * ,
                    unsigned int  ) ;
   int (*write_begin)(struct file * , struct address_space * , loff_t  , unsigned int  ,
                      unsigned int  , struct page ** , void ** ) ;
   int (*write_end)(struct file * , struct address_space * , loff_t  , unsigned int  ,
                    unsigned int  , struct page * , void * ) ;
   sector_t (*bmap)(struct address_space * , sector_t  ) ;
   void (*invalidatepage)(struct page * , unsigned int  , unsigned int  ) ;
   int (*releasepage)(struct page * , gfp_t  ) ;
   void (*freepage)(struct page * ) ;
   ssize_t (*direct_IO)(struct kiocb * , struct iov_iter * , loff_t  ) ;
   int (*migratepage)(struct address_space * , struct page * , struct page * , enum migrate_mode  ) ;
   int (*launder_page)(struct page * ) ;
   int (*is_partially_uptodate)(struct page * , unsigned long  , unsigned long  ) ;
   void (*is_dirty_writeback)(struct page * , bool * , bool * ) ;
   int (*error_remove_page)(struct address_space * , struct page * ) ;
   int (*swap_activate)(struct swap_info_struct * , struct file * , sector_t * ) ;
   void (*swap_deactivate)(struct file * ) ;
};
struct address_space {
   struct inode *host ;
   struct radix_tree_root page_tree ;
   spinlock_t tree_lock ;
   atomic_t i_mmap_writable ;
   struct rb_root i_mmap ;
   struct rw_semaphore i_mmap_rwsem ;
   unsigned long nrpages ;
    klee_make_symbolic(&nrpages, sizeof(long), "nrpages");
   unsigned long nrshadows ;
    klee_make_symbolic(&nrshadows, sizeof(long), "nrshadows");
   unsigned long writeback_index ;
    klee_make_symbolic(&writeback_index, sizeof(long), "writeback_index");
   struct address_space_operations  const  *a_ops ;
   unsigned long flags ;
   spinlock_t private_lock ;
   struct list_head private_list ;
   void *private_data ;
};
struct request_queue;
struct hd_struct;
struct gendisk;
struct block_device {
   dev_t bd_dev ;
   int bd_openers ;
    klee_make_symbolic(&bd_openers, sizeof(int), "bd_openers");
   struct inode *bd_inode ;
   struct super_block *bd_super ;
   struct mutex bd_mutex ;
   struct list_head bd_inodes ;
   void *bd_claiming ;
   void *bd_holder ;
   int bd_holders ;
    klee_make_symbolic(&bd_holders, sizeof(int), "bd_holders");
   bool bd_write_holder ;
   struct list_head bd_holder_disks ;
   struct block_device *bd_contains ;
   unsigned int bd_block_size ;
    klee_make_symbolic(&bd_block_size, sizeof(int), "bd_block_size");
   struct hd_struct *bd_part ;
   unsigned int bd_part_count ;
    klee_make_symbolic(&bd_part_count, sizeof(int), "bd_part_count");
   int bd_invalidated ;
    klee_make_symbolic(&bd_invalidated, sizeof(int), "bd_invalidated");
   struct gendisk *bd_disk ;
   struct request_queue *bd_queue ;
   struct list_head bd_list ;
   unsigned long bd_private ;
    klee_make_symbolic(&bd_private, sizeof(long), "bd_private");
   int bd_fsfreeze_count ;
    klee_make_symbolic(&bd_fsfreeze_count, sizeof(int), "bd_fsfreeze_count");
   struct mutex bd_fsfreeze_mutex ;
};
struct posix_acl;
struct inode_operations;
union __anonunion____missing_field_name_266 {
   unsigned int const   i_nlink ;
   unsigned int __i_nlink ;
    klee_make_symbolic(&__i_nlink, sizeof(int), "__i_nlink");
};
union __anonunion____missing_field_name_267 {
   struct hlist_head i_dentry ;
   struct callback_head i_rcu ;
};
struct file_lock_context;
struct cdev;
union __anonunion____missing_field_name_268 {
   struct pipe_inode_info *i_pipe ;
   struct block_device *i_bdev ;
   struct cdev *i_cdev ;
   char *i_link ;
};
struct inode {
   umode_t i_mode ;
   unsigned short i_opflags ;
    klee_make_symbolic(&i_opflags, sizeof(short), "i_opflags");
   kuid_t i_uid ;
   kgid_t i_gid ;
   unsigned int i_flags ;
   struct posix_acl *i_acl ;
   struct posix_acl *i_default_acl ;
   struct inode_operations  const  *i_op ;
   struct super_block *i_sb ;
   struct address_space *i_mapping ;
   void *i_security ;
   unsigned long i_ino ;
    klee_make_symbolic(&i_ino, sizeof(long), "i_ino");
   union __anonunion____missing_field_name_266 __annonCompField82 ;
   dev_t i_rdev ;
   loff_t i_size ;
   struct timespec i_atime ;
   struct timespec i_mtime ;
   struct timespec i_ctime ;
   spinlock_t i_lock ;
   unsigned short i_bytes ;
    klee_make_symbolic(&i_bytes, sizeof(short), "i_bytes");
   unsigned int i_blkbits ;
    klee_make_symbolic(&i_blkbits, sizeof(int), "i_blkbits");
   blkcnt_t i_blocks ;
   unsigned long i_state ;
    klee_make_symbolic(&i_state, sizeof(long), "i_state");
   struct mutex i_mutex ;
   unsigned long dirtied_when ;
    klee_make_symbolic(&dirtied_when, sizeof(long), "dirtied_when");
   unsigned long dirtied_time_when ;
    klee_make_symbolic(&dirtied_time_when, sizeof(long), "dirtied_time_when");
   struct hlist_node i_hash ;
   struct list_head i_wb_list ;
   struct bdi_writeback *i_wb ;
   int i_wb_frn_winner ;
    klee_make_symbolic(&i_wb_frn_winner, sizeof(int), "i_wb_frn_winner");
   u16 i_wb_frn_avg_time ;
   u16 i_wb_frn_history ;
   struct list_head i_lru ;
   struct list_head i_sb_list ;
   union __anonunion____missing_field_name_267 __annonCompField83 ;
   u64 i_version ;
   atomic_t i_count ;
   atomic_t i_dio_count ;
   atomic_t i_writecount ;
   atomic_t i_readcount ;
   struct file_operations  const  *i_fop ;
   struct file_lock_context *i_flctx ;
   struct address_space i_data ;
   struct list_head i_devices ;
   union __anonunion____missing_field_name_268 __annonCompField84 ;
   __u32 i_generation ;
   __u32 i_fsnotify_mask ;
   struct hlist_head i_fsnotify_marks ;
   void *i_private ;
};
struct fown_struct {
   rwlock_t lock ;
   struct pid *pid ;
   enum pid_type pid_type ;
   kuid_t uid ;
   kuid_t euid ;
   int signum ;
    klee_make_symbolic(&signum, sizeof(int), "signum");
};
struct file_ra_state {
   unsigned long start ;
    klee_make_symbolic(&start, sizeof(long), "start");
   unsigned int size ;
   unsigned int async_size ;
    klee_make_symbolic(&async_size, sizeof(int), "async_size");
   unsigned int ra_pages ;
    klee_make_symbolic(&ra_pages, sizeof(int), "ra_pages");
   unsigned int mmap_miss ;
    klee_make_symbolic(&mmap_miss, sizeof(int), "mmap_miss");
   loff_t prev_pos ;
};
union __anonunion_f_u_269 {
   struct llist_node fu_llist ;
   struct callback_head fu_rcuhead ;
};
struct file {
   union __anonunion_f_u_269 f_u ;
   struct path f_path ;
   struct inode *f_inode ;
   struct file_operations  const  *f_op ;
   spinlock_t f_lock ;
   atomic_long_t f_count ;
   unsigned int f_flags ;
    klee_make_symbolic(&f_flags, sizeof(int), "f_flags");
   fmode_t f_mode ;
   struct mutex f_pos_lock ;
   loff_t f_pos ;
   struct fown_struct f_owner ;
   struct cred  const  *f_cred ;
   struct file_ra_state f_ra ;
   u64 f_version ;
   void *f_security ;
   void *private_data ;
   struct list_head f_ep_links ;
   struct list_head f_tfile_llink ;
   struct address_space *f_mapping ;
};
typedef void *fl_owner_t;
struct file_lock;
struct file_lock_operations {
   void (*fl_copy_lock)(struct file_lock * , struct file_lock * ) ;
   void (*fl_release_private)(struct file_lock * ) ;
};
struct lock_manager_operations {
   int (*lm_compare_owner)(struct file_lock * , struct file_lock * ) ;
   unsigned long (*lm_owner_key)(struct file_lock * ) ;
   fl_owner_t (*lm_get_owner)(fl_owner_t  ) ;
   void (*lm_put_owner)(fl_owner_t  ) ;
   void (*lm_notify)(struct file_lock * ) ;
   int (*lm_grant)(struct file_lock * , int  ) ;
   bool (*lm_break)(struct file_lock * ) ;
   int (*lm_change)(struct file_lock * , int  , struct list_head * ) ;
   void (*lm_setup)(struct file_lock * , void ** ) ;
};
struct nlm_lockowner;
struct nfs_lock_info {
   u32 state ;
   struct nlm_lockowner *owner ;
   struct list_head list ;
};
struct nfs4_lock_state;
struct nfs4_lock_info {
   struct nfs4_lock_state *owner ;
};
struct __anonstruct_afs_271 {
   struct list_head link ;
   int state ;
};
union __anonunion_fl_u_270 {
   struct nfs_lock_info nfs_fl ;
   struct nfs4_lock_info nfs4_fl ;
   struct __anonstruct_afs_271 afs ;
};
struct file_lock {
   struct file_lock *fl_next ;
   struct list_head fl_list ;
   struct hlist_node fl_link ;
   struct list_head fl_block ;
   fl_owner_t fl_owner ;
   unsigned int fl_flags ;
    klee_make_symbolic(&fl_flags, sizeof(int), "fl_flags");
   unsigned char fl_type ;
    klee_make_symbolic(&fl_type, sizeof(char), "fl_type");
   unsigned int fl_pid ;
    klee_make_symbolic(&fl_pid, sizeof(int), "fl_pid");
   int fl_link_cpu ;
    klee_make_symbolic(&fl_link_cpu, sizeof(int), "fl_link_cpu");
   struct pid *fl_nspid ;
   wait_queue_head_t fl_wait ;
   struct file *fl_file ;
   loff_t fl_start ;
   loff_t fl_end ;
   struct fasync_struct *fl_fasync ;
   unsigned long fl_break_time ;
    klee_make_symbolic(&fl_break_time, sizeof(long), "fl_break_time");
   unsigned long fl_downgrade_time ;
    klee_make_symbolic(&fl_downgrade_time, sizeof(long), "fl_downgrade_time");
   struct file_lock_operations  const  *fl_ops ;
   struct lock_manager_operations  const  *fl_lmops ;
   union __anonunion_fl_u_270 fl_u ;
};
struct file_lock_context {
   spinlock_t flc_lock ;
   struct list_head flc_flock ;
   struct list_head flc_posix ;
   struct list_head flc_lease ;
};
struct fasync_struct {
   spinlock_t fa_lock ;
   int magic ;
   int fa_fd ;
    klee_make_symbolic(&fa_fd, sizeof(int), "fa_fd");
   struct fasync_struct *fa_next ;
   struct file *fa_file ;
   struct callback_head fa_rcu ;
};
struct sb_writers {
   struct percpu_counter counter[3U] ;
   wait_queue_head_t wait ;
   int frozen ;
    klee_make_symbolic(&frozen, sizeof(int), "frozen");
   wait_queue_head_t wait_unfrozen ;
   struct lockdep_map lock_map[3U] ;
};
struct super_operations;
struct xattr_handler;
struct mtd_info;
struct super_block {
   struct list_head s_list ;
   dev_t s_dev ;
   unsigned char s_blocksize_bits ;
    klee_make_symbolic(&s_blocksize_bits, sizeof(char), "s_blocksize_bits");
   unsigned long s_blocksize ;
    klee_make_symbolic(&s_blocksize, sizeof(long), "s_blocksize");
   loff_t s_maxbytes ;
   struct file_system_type *s_type ;
   struct super_operations  const  *s_op ;
   struct dquot_operations  const  *dq_op ;
   struct quotactl_ops  const  *s_qcop ;
   struct export_operations  const  *s_export_op ;
   unsigned long s_flags ;
    klee_make_symbolic(&s_flags, sizeof(long), "s_flags");
   unsigned long s_iflags ;
    klee_make_symbolic(&s_iflags, sizeof(long), "s_iflags");
   unsigned long s_magic ;
    klee_make_symbolic(&s_magic, sizeof(long), "s_magic");
   struct dentry *s_root ;
   struct rw_semaphore s_umount ;
   int s_count ;
    klee_make_symbolic(&s_count, sizeof(int), "s_count");
   atomic_t s_active ;
   void *s_security ;
   struct xattr_handler  const  **s_xattr ;
   struct list_head s_inodes ;
   struct hlist_bl_head s_anon ;
   struct list_head s_mounts ;
   struct block_device *s_bdev ;
   struct backing_dev_info *s_bdi ;
   struct mtd_info *s_mtd ;
   struct hlist_node s_instances ;
   unsigned int s_quota_types ;
    klee_make_symbolic(&s_quota_types, sizeof(int), "s_quota_types");
   struct quota_info s_dquot ;
   struct sb_writers s_writers ;
   char s_id[32U] ;
   u8 s_uuid[16U] ;
   void *s_fs_info ;
   unsigned int s_max_links ;
    klee_make_symbolic(&s_max_links, sizeof(int), "s_max_links");
   fmode_t s_mode ;
   u32 s_time_gran ;
   struct mutex s_vfs_rename_mutex ;
   char *s_subtype ;
   char *s_options ;
   struct dentry_operations  const  *s_d_op ;
   int cleancache_poolid ;
    klee_make_symbolic(&cleancache_poolid, sizeof(int), "cleancache_poolid");
   struct shrinker s_shrink ;
   atomic_long_t s_remove_count ;
   int s_readonly_remount ;
    klee_make_symbolic(&s_readonly_remount, sizeof(int), "s_readonly_remount");
   struct workqueue_struct *s_dio_done_wq ;
   struct hlist_head s_pins ;
   struct list_lru s_dentry_lru ;
   struct list_lru s_inode_lru ;
   struct callback_head rcu ;
   int s_stack_depth ;
    klee_make_symbolic(&s_stack_depth, sizeof(int), "s_stack_depth");
};
struct fiemap_extent_info {
   unsigned int fi_flags ;
    klee_make_symbolic(&fi_flags, sizeof(int), "fi_flags");
   unsigned int fi_extents_mapped ;
    klee_make_symbolic(&fi_extents_mapped, sizeof(int), "fi_extents_mapped");
   unsigned int fi_extents_max ;
    klee_make_symbolic(&fi_extents_max, sizeof(int), "fi_extents_max");
   struct fiemap_extent *fi_extents_start ;
};
struct dir_context;
struct dir_context {
   int (*actor)(struct dir_context * , char const   * , int  , loff_t  , u64  , unsigned int  ) ;
   loff_t pos ;
};
struct file_operations {
   struct module *owner ;
   loff_t (*llseek)(struct file * , loff_t  , int  ) ;
   ssize_t (*read)(struct file * , char * , size_t  , loff_t * ) ;
   ssize_t (*write)(struct file * , char const   * , size_t  , loff_t * ) ;
   ssize_t (*read_iter)(struct kiocb * , struct iov_iter * ) ;
   ssize_t (*write_iter)(struct kiocb * , struct iov_iter * ) ;
   int (*iterate)(struct file * , struct dir_context * ) ;
   unsigned int (*poll)(struct file * , struct poll_table_struct * ) ;
   long (*unlocked_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   long (*compat_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   int (*mmap)(struct file * , struct vm_area_struct * ) ;
   int (*mremap)(struct file * , struct vm_area_struct * ) ;
   int (*open)(struct inode * , struct file * ) ;
   int (*flush)(struct file * , fl_owner_t  ) ;
   int (*release)(struct inode * , struct file * ) ;
   int (*fsync)(struct file * , loff_t  , loff_t  , int  ) ;
   int (*aio_fsync)(struct kiocb * , int  ) ;
   int (*fasync)(int  , struct file * , int  ) ;
   int (*lock)(struct file * , int  , struct file_lock * ) ;
   ssize_t (*sendpage)(struct file * , struct page * , int  , size_t  , loff_t * ,
                       int  ) ;
   unsigned long (*get_unmapped_area)(struct file * , unsigned long  , unsigned long  ,
                                      unsigned long  , unsigned long  ) ;
   int (*check_flags)(int  ) ;
   int (*flock)(struct file * , int  , struct file_lock * ) ;
   ssize_t (*splice_write)(struct pipe_inode_info * , struct file * , loff_t * , size_t  ,
                           unsigned int  ) ;
   ssize_t (*splice_read)(struct file * , loff_t * , struct pipe_inode_info * , size_t  ,
                          unsigned int  ) ;
   int (*setlease)(struct file * , long  , struct file_lock ** , void ** ) ;
   long (*fallocate)(struct file * , int  , loff_t  , loff_t  ) ;
   void (*show_fdinfo)(struct seq_file * , struct file * ) ;
};
struct inode_operations {
   struct dentry *(*lookup)(struct inode * , struct dentry * , unsigned int  ) ;
   char const   *(*follow_link)(struct dentry * , void ** ) ;
   int (*permission)(struct inode * , int  ) ;
   struct posix_acl *(*get_acl)(struct inode * , int  ) ;
   int (*readlink)(struct dentry * , char * , int  ) ;
   void (*put_link)(struct inode * , void * ) ;
   int (*create)(struct inode * , struct dentry * , umode_t  , bool  ) ;
   int (*link)(struct dentry * , struct inode * , struct dentry * ) ;
   int (*unlink)(struct inode * , struct dentry * ) ;
   int (*symlink)(struct inode * , struct dentry * , char const   * ) ;
   int (*mkdir)(struct inode * , struct dentry * , umode_t  ) ;
   int (*rmdir)(struct inode * , struct dentry * ) ;
   int (*mknod)(struct inode * , struct dentry * , umode_t  , dev_t  ) ;
   int (*rename)(struct inode * , struct dentry * , struct inode * , struct dentry * ) ;
   int (*rename2)(struct inode * , struct dentry * , struct inode * , struct dentry * ,
                  unsigned int  ) ;
   int (*setattr)(struct dentry * , struct iattr * ) ;
   int (*getattr)(struct vfsmount * , struct dentry * , struct kstat * ) ;
   int (*setxattr)(struct dentry * , char const   * , void const   * , size_t  , int  ) ;
   ssize_t (*getxattr)(struct dentry * , char const   * , void * , size_t  ) ;
   ssize_t (*listxattr)(struct dentry * , char * , size_t  ) ;
   int (*removexattr)(struct dentry * , char const   * ) ;
   int (*fiemap)(struct inode * , struct fiemap_extent_info * , u64  , u64  ) ;
   int (*update_time)(struct inode * , struct timespec * , int  ) ;
   int (*atomic_open)(struct inode * , struct dentry * , struct file * , unsigned int  ,
                      umode_t  , int * ) ;
   int (*tmpfile)(struct inode * , struct dentry * , umode_t  ) ;
   int (*set_acl)(struct inode * , struct posix_acl * , int  ) ;
};
struct super_operations {
   struct inode *(*alloc_inode)(struct super_block * ) ;
   void (*destroy_inode)(struct inode * ) ;
   void (*dirty_inode)(struct inode * , int  ) ;
   int (*write_inode)(struct inode * , struct writeback_control * ) ;
   int (*drop_inode)(struct inode * ) ;
   void (*evict_inode)(struct inode * ) ;
   void (*put_super)(struct super_block * ) ;
   int (*sync_fs)(struct super_block * , int  ) ;
   int (*freeze_super)(struct super_block * ) ;
   int (*freeze_fs)(struct super_block * ) ;
   int (*thaw_super)(struct super_block * ) ;
   int (*unfreeze_fs)(struct super_block * ) ;
   int (*statfs)(struct dentry * , struct kstatfs * ) ;
   int (*remount_fs)(struct super_block * , int * , char * ) ;
   void (*umount_begin)(struct super_block * ) ;
   int (*show_options)(struct seq_file * , struct dentry * ) ;
   int (*show_devname)(struct seq_file * , struct dentry * ) ;
   int (*show_path)(struct seq_file * , struct dentry * ) ;
   int (*show_stats)(struct seq_file * , struct dentry * ) ;
   ssize_t (*quota_read)(struct super_block * , int  , char * , size_t  , loff_t  ) ;
   ssize_t (*quota_write)(struct super_block * , int  , char const   * , size_t  ,
                          loff_t  ) ;
   struct dquot **(*get_dquots)(struct inode * ) ;
   int (*bdev_try_to_free_page)(struct super_block * , struct page * , gfp_t  ) ;
   long (*nr_cached_objects)(struct super_block * , struct shrink_control * ) ;
   long (*free_cached_objects)(struct super_block * , struct shrink_control * ) ;
};
struct file_system_type {
   char const   *name ;
   int fs_flags ;
    klee_make_symbolic(&fs_flags, sizeof(int), "fs_flags");
   struct dentry *(*mount)(struct file_system_type * , int  , char const   * , void * ) ;
   void (*kill_sb)(struct super_block * ) ;
   struct module *owner ;
   struct file_system_type *next ;
   struct hlist_head fs_supers ;
   struct lock_class_key s_lock_key ;
   struct lock_class_key s_umount_key ;
   struct lock_class_key s_vfs_rename_key ;
   struct lock_class_key s_writers_key[3U] ;
   struct lock_class_key i_lock_key ;
   struct lock_class_key i_mutex_key ;
   struct lock_class_key i_mutex_dir_key ;
};
typedef s32 compat_time_t;
typedef s32 compat_long_t;
typedef u32 compat_uptr_t;
struct compat_timespec {
   compat_time_t tv_sec ;
   s32 tv_nsec ;
};
struct compat_robust_list {
   compat_uptr_t next ;
};
struct compat_robust_list_head {
   struct compat_robust_list list ;
   compat_long_t futex_offset ;
   compat_uptr_t list_op_pending ;
};
struct ethtool_cmd {
   __u32 cmd ;
   __u32 supported ;
   __u32 advertising ;
   __u16 speed ;
   __u8 duplex ;
   __u8 port ;
   __u8 phy_address ;
   __u8 transceiver ;
   __u8 autoneg ;
   __u8 mdio_support ;
   __u32 maxtxpkt ;
   __u32 maxrxpkt ;
   __u16 speed_hi ;
   __u8 eth_tp_mdix ;
   __u8 eth_tp_mdix_ctrl ;
   __u32 lp_advertising ;
   __u32 reserved[2U] ;
};
struct ethtool_drvinfo {
   __u32 cmd ;
   char driver[32U] ;
   char version[32U] ;
   char fw_version[32U] ;
   char bus_info[32U] ;
   char erom_version[32U] ;
   char reserved2[12U] ;
   __u32 n_priv_flags ;
   __u32 n_stats ;
   __u32 testinfo_len ;
   __u32 eedump_len ;
   __u32 regdump_len ;
};
struct ethtool_wolinfo {
   __u32 cmd ;
   __u32 supported ;
   __u32 wolopts ;
   __u8 sopass[6U] ;
};
struct ethtool_tunable {
   __u32 cmd ;
   __u32 id ;
   __u32 type_id ;
   __u32 len ;
   void *data[0U] ;
};
struct ethtool_regs {
   __u32 cmd ;
   __u32 version ;
   __u32 len ;
   __u8 data[0U] ;
};
struct ethtool_eeprom {
   __u32 cmd ;
   __u32 magic ;
   __u32 offset ;
   __u32 len ;
   __u8 data[0U] ;
};
struct ethtool_eee {
   __u32 cmd ;
   __u32 supported ;
   __u32 advertised ;
   __u32 lp_advertised ;
   __u32 eee_active ;
   __u32 eee_enabled ;
   __u32 tx_lpi_enabled ;
   __u32 tx_lpi_timer ;
   __u32 reserved[2U] ;
};
struct ethtool_modinfo {
   __u32 cmd ;
   __u32 type ;
   __u32 eeprom_len ;
   __u32 reserved[8U] ;
};
struct ethtool_coalesce {
   __u32 cmd ;
   __u32 rx_coalesce_usecs ;
   __u32 rx_max_coalesced_frames ;
   __u32 rx_coalesce_usecs_irq ;
   __u32 rx_max_coalesced_frames_irq ;
   __u32 tx_coalesce_usecs ;
   __u32 tx_max_coalesced_frames ;
   __u32 tx_coalesce_usecs_irq ;
   __u32 tx_max_coalesced_frames_irq ;
   __u32 stats_block_coalesce_usecs ;
   __u32 use_adaptive_rx_coalesce ;
   __u32 use_adaptive_tx_coalesce ;
   __u32 pkt_rate_low ;
   __u32 rx_coalesce_usecs_low ;
   __u32 rx_max_coalesced_frames_low ;
   __u32 tx_coalesce_usecs_low ;
   __u32 tx_max_coalesced_frames_low ;
   __u32 pkt_rate_high ;
   __u32 rx_coalesce_usecs_high ;
   __u32 rx_max_coalesced_frames_high ;
   __u32 tx_coalesce_usecs_high ;
   __u32 tx_max_coalesced_frames_high ;
   __u32 rate_sample_interval ;
};
struct ethtool_ringparam {
   __u32 cmd ;
   __u32 rx_max_pending ;
   __u32 rx_mini_max_pending ;
   __u32 rx_jumbo_max_pending ;
   __u32 tx_max_pending ;
   __u32 rx_pending ;
   __u32 rx_mini_pending ;
   __u32 rx_jumbo_pending ;
   __u32 tx_pending ;
};
struct ethtool_channels {
   __u32 cmd ;
   __u32 max_rx ;
   __u32 max_tx ;
   __u32 max_other ;
   __u32 max_combined ;
   __u32 rx_count ;
   __u32 tx_count ;
   __u32 other_count ;
   __u32 combined_count ;
};
struct ethtool_pauseparam {
   __u32 cmd ;
   __u32 autoneg ;
   __u32 rx_pause ;
   __u32 tx_pause ;
};
struct ethtool_test {
   __u32 cmd ;
   __u32 flags ;
   __u32 reserved ;
   __u32 len ;
   __u64 data[0U] ;
};
struct ethtool_stats {
   __u32 cmd ;
   __u32 n_stats ;
   __u64 data[0U] ;
};
struct ethtool_tcpip4_spec {
   __be32 ip4src ;
   __be32 ip4dst ;
   __be16 psrc ;
   __be16 pdst ;
   __u8 tos ;
};
struct ethtool_ah_espip4_spec {
   __be32 ip4src ;
   __be32 ip4dst ;
   __be32 spi ;
   __u8 tos ;
};
struct ethtool_usrip4_spec {
   __be32 ip4src ;
   __be32 ip4dst ;
   __be32 l4_4_bytes ;
   __u8 tos ;
   __u8 ip_ver ;
   __u8 proto ;
};
union ethtool_flow_union {
   struct ethtool_tcpip4_spec tcp_ip4_spec ;
   struct ethtool_tcpip4_spec udp_ip4_spec ;
   struct ethtool_tcpip4_spec sctp_ip4_spec ;
   struct ethtool_ah_espip4_spec ah_ip4_spec ;
   struct ethtool_ah_espip4_spec esp_ip4_spec ;
   struct ethtool_usrip4_spec usr_ip4_spec ;
   struct ethhdr ether_spec ;
   __u8 hdata[52U] ;
};
struct ethtool_flow_ext {
   __u8 padding[2U] ;
   unsigned char h_dest[6U] ;
   __be16 vlan_etype ;
   __be16 vlan_tci ;
   __be32 data[2U] ;
};
struct ethtool_rx_flow_spec {
   __u32 flow_type ;
   union ethtool_flow_union h_u ;
   struct ethtool_flow_ext h_ext ;
   union ethtool_flow_union m_u ;
   struct ethtool_flow_ext m_ext ;
   __u64 ring_cookie ;
   __u32 location ;
};
struct ethtool_rxnfc {
   __u32 cmd ;
   __u32 flow_type ;
   __u64 data ;
   struct ethtool_rx_flow_spec fs ;
   __u32 rule_cnt ;
   __u32 rule_locs[0U] ;
};
struct ethtool_flash {
   __u32 cmd ;
   __u32 region ;
   char data[128U] ;
};
struct ethtool_dump {
   __u32 cmd ;
   __u32 version ;
   __u32 flag ;
   __u32 len ;
   __u8 data[0U] ;
};
struct ethtool_ts_info {
   __u32 cmd ;
   __u32 so_timestamping ;
   __s32 phc_index ;
   __u32 tx_types ;
   __u32 tx_reserved[3U] ;
   __u32 rx_filters ;
   __u32 rx_reserved[3U] ;
};
enum ethtool_phys_id_state {
    ETHTOOL_ID_INACTIVE = 0,
    ETHTOOL_ID_ACTIVE = 1,
    ETHTOOL_ID_ON = 2,
    ETHTOOL_ID_OFF = 3
} ;
struct ethtool_ops {
   int (*get_settings)(struct net_device * , struct ethtool_cmd * ) ;
   int (*set_settings)(struct net_device * , struct ethtool_cmd * ) ;
   void (*get_drvinfo)(struct net_device * , struct ethtool_drvinfo * ) ;
   int (*get_regs_len)(struct net_device * ) ;
   void (*get_regs)(struct net_device * , struct ethtool_regs * , void * ) ;
   void (*get_wol)(struct net_device * , struct ethtool_wolinfo * ) ;
   int (*set_wol)(struct net_device * , struct ethtool_wolinfo * ) ;
   u32 (*get_msglevel)(struct net_device * ) ;
   void (*set_msglevel)(struct net_device * , u32  ) ;
   int (*nway_reset)(struct net_device * ) ;
   u32 (*get_link)(struct net_device * ) ;
   int (*get_eeprom_len)(struct net_device * ) ;
   int (*get_eeprom)(struct net_device * , struct ethtool_eeprom * , u8 * ) ;
   int (*set_eeprom)(struct net_device * , struct ethtool_eeprom * , u8 * ) ;
   int (*get_coalesce)(struct net_device * , struct ethtool_coalesce * ) ;
   int (*set_coalesce)(struct net_device * , struct ethtool_coalesce * ) ;
   void (*get_ringparam)(struct net_device * , struct ethtool_ringparam * ) ;
   int (*set_ringparam)(struct net_device * , struct ethtool_ringparam * ) ;
   void (*get_pauseparam)(struct net_device * , struct ethtool_pauseparam * ) ;
   int (*set_pauseparam)(struct net_device * , struct ethtool_pauseparam * ) ;
   void (*self_test)(struct net_device * , struct ethtool_test * , u64 * ) ;
   void (*get_strings)(struct net_device * , u32  , u8 * ) ;
   int (*set_phys_id)(struct net_device * , enum ethtool_phys_id_state  ) ;
   void (*get_ethtool_stats)(struct net_device * , struct ethtool_stats * , u64 * ) ;
   int (*begin)(struct net_device * ) ;
   void (*complete)(struct net_device * ) ;
   u32 (*get_priv_flags)(struct net_device * ) ;
   int (*set_priv_flags)(struct net_device * , u32  ) ;
   int (*get_sset_count)(struct net_device * , int  ) ;
   int (*get_rxnfc)(struct net_device * , struct ethtool_rxnfc * , u32 * ) ;
   int (*set_rxnfc)(struct net_device * , struct ethtool_rxnfc * ) ;
   int (*flash_device)(struct net_device * , struct ethtool_flash * ) ;
   int (*reset)(struct net_device * , u32 * ) ;
   u32 (*get_rxfh_key_size)(struct net_device * ) ;
   u32 (*get_rxfh_indir_size)(struct net_device * ) ;
   int (*get_rxfh)(struct net_device * , u32 * , u8 * , u8 * ) ;
   int (*set_rxfh)(struct net_device * , u32 const   * , u8 const   * , u8 const    ) ;
   void (*get_channels)(struct net_device * , struct ethtool_channels * ) ;
   int (*set_channels)(struct net_device * , struct ethtool_channels * ) ;
   int (*get_dump_flag)(struct net_device * , struct ethtool_dump * ) ;
   int (*get_dump_data)(struct net_device * , struct ethtool_dump * , void * ) ;
   int (*set_dump)(struct net_device * , struct ethtool_dump * ) ;
   int (*get_ts_info)(struct net_device * , struct ethtool_ts_info * ) ;
   int (*get_module_info)(struct net_device * , struct ethtool_modinfo * ) ;
   int (*get_module_eeprom)(struct net_device * , struct ethtool_eeprom * , u8 * ) ;
   int (*get_eee)(struct net_device * , struct ethtool_eee * ) ;
   int (*set_eee)(struct net_device * , struct ethtool_eee * ) ;
   int (*get_tunable)(struct net_device * , struct ethtool_tunable  const  * , void * ) ;
   int (*set_tunable)(struct net_device * , struct ethtool_tunable  const  * , void const   * ) ;
};
struct prot_inuse;
struct netns_core {
   struct ctl_table_header *sysctl_hdr ;
   int sysctl_somaxconn ;
    klee_make_symbolic(&sysctl_somaxconn, sizeof(int), "sysctl_somaxconn");
   struct prot_inuse *inuse ;
};
struct u64_stats_sync {

};
struct ipstats_mib {
   u64 mibs[36U] ;
   struct u64_stats_sync syncp ;
};
struct icmp_mib {
   unsigned long mibs[28U] ;
};
struct icmpmsg_mib {
   atomic_long_t mibs[512U] ;
};
struct icmpv6_mib {
   unsigned long mibs[6U] ;
};
struct icmpv6msg_mib {
   atomic_long_t mibs[512U] ;
};
struct tcp_mib {
   unsigned long mibs[16U] ;
};
struct udp_mib {
   unsigned long mibs[9U] ;
};
struct linux_mib {
   unsigned long mibs[115U] ;
};
struct linux_xfrm_mib {
   unsigned long mibs[29U] ;
};
struct proc_dir_entry;
struct netns_mib {
   struct tcp_mib *tcp_statistics ;
   struct ipstats_mib *ip_statistics ;
   struct linux_mib *net_statistics ;
   struct udp_mib *udp_statistics ;
   struct udp_mib *udplite_statistics ;
   struct icmp_mib *icmp_statistics ;
   struct icmpmsg_mib *icmpmsg_statistics ;
   struct proc_dir_entry *proc_net_devsnmp6 ;
   struct udp_mib *udp_stats_in6 ;
   struct udp_mib *udplite_stats_in6 ;
   struct ipstats_mib *ipv6_statistics ;
   struct icmpv6_mib *icmpv6_statistics ;
   struct icmpv6msg_mib *icmpv6msg_statistics ;
   struct linux_xfrm_mib *xfrm_statistics ;
};
struct netns_unix {
   int sysctl_max_dgram_qlen ;
    klee_make_symbolic(&sysctl_max_dgram_qlen, sizeof(int), "sysctl_max_dgram_qlen");
   struct ctl_table_header *ctl ;
};
struct netns_packet {
   struct mutex sklist_lock ;
   struct hlist_head sklist ;
};
struct netns_frags {
   struct percpu_counter mem ;
   int timeout ;
   int high_thresh ;
    klee_make_symbolic(&high_thresh, sizeof(int), "high_thresh");
   int low_thresh ;
    klee_make_symbolic(&low_thresh, sizeof(int), "low_thresh");
};
struct ipv4_devconf;
struct fib_rules_ops;
struct fib_table;
struct local_ports {
   seqlock_t lock ;
   int range[2U] ;
   bool warned ;
};
struct ping_group_range {
   seqlock_t lock ;
   kgid_t range[2U] ;
};
struct inet_peer_base;
struct xt_table;
struct netns_ipv4 {
   struct ctl_table_header *forw_hdr ;
   struct ctl_table_header *frags_hdr ;
   struct ctl_table_header *ipv4_hdr ;
   struct ctl_table_header *route_hdr ;
   struct ctl_table_header *xfrm4_hdr ;
   struct ipv4_devconf *devconf_all ;
   struct ipv4_devconf *devconf_dflt ;
   struct fib_rules_ops *rules_ops ;
   bool fib_has_custom_rules ;
   struct fib_table *fib_local ;
   struct fib_table *fib_main ;
   struct fib_table *fib_default ;
   int fib_num_tclassid_users ;
    klee_make_symbolic(&fib_num_tclassid_users, sizeof(int), "fib_num_tclassid_users");
   struct hlist_head *fib_table_hash ;
   bool fib_offload_disabled ;
   struct sock *fibnl ;
   struct sock **icmp_sk ;
   struct sock *mc_autojoin_sk ;
   struct inet_peer_base *peers ;
   struct sock **tcp_sk ;
   struct netns_frags frags ;
   struct xt_table *iptable_filter ;
   struct xt_table *iptable_mangle ;
   struct xt_table *iptable_raw ;
   struct xt_table *arptable_filter ;
   struct xt_table *iptable_security ;
   struct xt_table *nat_table ;
   int sysctl_icmp_echo_ignore_all ;
    klee_make_symbolic(&sysctl_icmp_echo_ignore_all, sizeof(int), "sysctl_icmp_echo_ignore_all");
   int sysctl_icmp_echo_ignore_broadcasts ;
    klee_make_symbolic(&sysctl_icmp_echo_ignore_broadcasts, sizeof(int), "sysctl_icmp_echo_ignore_broadcasts");
   int sysctl_icmp_ignore_bogus_error_responses ;
    klee_make_symbolic(&sysctl_icmp_ignore_bogus_error_responses, sizeof(int), "sysctl_icmp_ignore_bogus_error_responses");
   int sysctl_icmp_ratelimit ;
    klee_make_symbolic(&sysctl_icmp_ratelimit, sizeof(int), "sysctl_icmp_ratelimit");
   int sysctl_icmp_ratemask ;
    klee_make_symbolic(&sysctl_icmp_ratemask, sizeof(int), "sysctl_icmp_ratemask");
   int sysctl_icmp_errors_use_inbound_ifaddr ;
    klee_make_symbolic(&sysctl_icmp_errors_use_inbound_ifaddr, sizeof(int), "sysctl_icmp_errors_use_inbound_ifaddr");
   struct local_ports ip_local_ports ;
   int sysctl_tcp_ecn ;
    klee_make_symbolic(&sysctl_tcp_ecn, sizeof(int), "sysctl_tcp_ecn");
   int sysctl_tcp_ecn_fallback ;
    klee_make_symbolic(&sysctl_tcp_ecn_fallback, sizeof(int), "sysctl_tcp_ecn_fallback");
   int sysctl_ip_no_pmtu_disc ;
    klee_make_symbolic(&sysctl_ip_no_pmtu_disc, sizeof(int), "sysctl_ip_no_pmtu_disc");
   int sysctl_ip_fwd_use_pmtu ;
    klee_make_symbolic(&sysctl_ip_fwd_use_pmtu, sizeof(int), "sysctl_ip_fwd_use_pmtu");
   int sysctl_ip_nonlocal_bind ;
    klee_make_symbolic(&sysctl_ip_nonlocal_bind, sizeof(int), "sysctl_ip_nonlocal_bind");
   int sysctl_fwmark_reflect ;
    klee_make_symbolic(&sysctl_fwmark_reflect, sizeof(int), "sysctl_fwmark_reflect");
   int sysctl_tcp_fwmark_accept ;
    klee_make_symbolic(&sysctl_tcp_fwmark_accept, sizeof(int), "sysctl_tcp_fwmark_accept");
   int sysctl_tcp_mtu_probing ;
    klee_make_symbolic(&sysctl_tcp_mtu_probing, sizeof(int), "sysctl_tcp_mtu_probing");
   int sysctl_tcp_base_mss ;
    klee_make_symbolic(&sysctl_tcp_base_mss, sizeof(int), "sysctl_tcp_base_mss");
   int sysctl_tcp_probe_threshold ;
    klee_make_symbolic(&sysctl_tcp_probe_threshold, sizeof(int), "sysctl_tcp_probe_threshold");
   u32 sysctl_tcp_probe_interval ;
   struct ping_group_range ping_group_range ;
   atomic_t dev_addr_genid ;
   unsigned long *sysctl_local_reserved_ports ;
   struct list_head mr_tables ;
   struct fib_rules_ops *mr_rules_ops ;
   atomic_t rt_genid ;
};
struct neighbour;
struct dst_ops {
   unsigned short family ;
   unsigned int gc_thresh ;
    klee_make_symbolic(&gc_thresh, sizeof(int), "gc_thresh");
   int (*gc)(struct dst_ops * ) ;
   struct dst_entry *(*check)(struct dst_entry * , __u32  ) ;
   unsigned int (*default_advmss)(struct dst_entry  const  * ) ;
   unsigned int (*mtu)(struct dst_entry  const  * ) ;
   u32 *(*cow_metrics)(struct dst_entry * , unsigned long  ) ;
   void (*destroy)(struct dst_entry * ) ;
   void (*ifdown)(struct dst_entry * , struct net_device * , int  ) ;
   struct dst_entry *(*negative_advice)(struct dst_entry * ) ;
   void (*link_failure)(struct sk_buff * ) ;
   void (*update_pmtu)(struct dst_entry * , struct sock * , struct sk_buff * , u32  ) ;
   void (*redirect)(struct dst_entry * , struct sock * , struct sk_buff * ) ;
   int (*local_out)(struct sk_buff * ) ;
   struct neighbour *(*neigh_lookup)(struct dst_entry  const  * , struct sk_buff * ,
                                     void const   * ) ;
   struct kmem_cache *kmem_cachep ;
   struct percpu_counter pcpuc_entries ;
};
struct netns_sysctl_ipv6 {
   struct ctl_table_header *hdr ;
   struct ctl_table_header *route_hdr ;
   struct ctl_table_header *icmp_hdr ;
   struct ctl_table_header *frags_hdr ;
   struct ctl_table_header *xfrm6_hdr ;
   int bindv6only ;
    klee_make_symbolic(&bindv6only, sizeof(int), "bindv6only");
   int flush_delay ;
    klee_make_symbolic(&flush_delay, sizeof(int), "flush_delay");
   int ip6_rt_max_size ;
    klee_make_symbolic(&ip6_rt_max_size, sizeof(int), "ip6_rt_max_size");
   int ip6_rt_gc_min_interval ;
    klee_make_symbolic(&ip6_rt_gc_min_interval, sizeof(int), "ip6_rt_gc_min_interval");
   int ip6_rt_gc_timeout ;
    klee_make_symbolic(&ip6_rt_gc_timeout, sizeof(int), "ip6_rt_gc_timeout");
   int ip6_rt_gc_interval ;
    klee_make_symbolic(&ip6_rt_gc_interval, sizeof(int), "ip6_rt_gc_interval");
   int ip6_rt_gc_elasticity ;
    klee_make_symbolic(&ip6_rt_gc_elasticity, sizeof(int), "ip6_rt_gc_elasticity");
   int ip6_rt_mtu_expires ;
    klee_make_symbolic(&ip6_rt_mtu_expires, sizeof(int), "ip6_rt_mtu_expires");
   int ip6_rt_min_advmss ;
    klee_make_symbolic(&ip6_rt_min_advmss, sizeof(int), "ip6_rt_min_advmss");
   int flowlabel_consistency ;
    klee_make_symbolic(&flowlabel_consistency, sizeof(int), "flowlabel_consistency");
   int auto_flowlabels ;
    klee_make_symbolic(&auto_flowlabels, sizeof(int), "auto_flowlabels");
   int icmpv6_time ;
    klee_make_symbolic(&icmpv6_time, sizeof(int), "icmpv6_time");
   int anycast_src_echo_reply ;
    klee_make_symbolic(&anycast_src_echo_reply, sizeof(int), "anycast_src_echo_reply");
   int fwmark_reflect ;
    klee_make_symbolic(&fwmark_reflect, sizeof(int), "fwmark_reflect");
   int idgen_retries ;
    klee_make_symbolic(&idgen_retries, sizeof(int), "idgen_retries");
   int idgen_delay ;
    klee_make_symbolic(&idgen_delay, sizeof(int), "idgen_delay");
   int flowlabel_state_ranges ;
    klee_make_symbolic(&flowlabel_state_ranges, sizeof(int), "flowlabel_state_ranges");
};
struct ipv6_devconf;
struct rt6_info;
struct rt6_statistics;
struct fib6_table;
struct netns_ipv6 {
   struct netns_sysctl_ipv6 sysctl ;
   struct ipv6_devconf *devconf_all ;
   struct ipv6_devconf *devconf_dflt ;
   struct inet_peer_base *peers ;
   struct netns_frags frags ;
   struct xt_table *ip6table_filter ;
   struct xt_table *ip6table_mangle ;
   struct xt_table *ip6table_raw ;
   struct xt_table *ip6table_security ;
   struct xt_table *ip6table_nat ;
   struct rt6_info *ip6_null_entry ;
   struct rt6_statistics *rt6_stats ;
   struct timer_list ip6_fib_timer ;
   struct hlist_head *fib_table_hash ;
   struct fib6_table *fib6_main_tbl ;
   struct dst_ops ip6_dst_ops ;
   unsigned int ip6_rt_gc_expire ;
    klee_make_symbolic(&ip6_rt_gc_expire, sizeof(int), "ip6_rt_gc_expire");
   unsigned long ip6_rt_last_gc ;
    klee_make_symbolic(&ip6_rt_last_gc, sizeof(long), "ip6_rt_last_gc");
   struct rt6_info *ip6_prohibit_entry ;
   struct rt6_info *ip6_blk_hole_entry ;
   struct fib6_table *fib6_local_tbl ;
   struct fib_rules_ops *fib6_rules_ops ;
   struct sock **icmp_sk ;
   struct sock *ndisc_sk ;
   struct sock *tcp_sk ;
   struct sock *igmp_sk ;
   struct sock *mc_autojoin_sk ;
   struct list_head mr6_tables ;
   struct fib_rules_ops *mr6_rules_ops ;
   atomic_t dev_addr_genid ;
   atomic_t fib6_sernum ;
};
struct netns_nf_frag {
   struct netns_sysctl_ipv6 sysctl ;
   struct netns_frags frags ;
};
struct netns_sysctl_lowpan {
   struct ctl_table_header *frags_hdr ;
};
struct netns_ieee802154_lowpan {
   struct netns_sysctl_lowpan sysctl ;
   struct netns_frags frags ;
};
struct sctp_mib;
struct netns_sctp {
   struct sctp_mib *sctp_statistics ;
   struct proc_dir_entry *proc_net_sctp ;
   struct ctl_table_header *sysctl_header ;
   struct sock *ctl_sock ;
   struct list_head local_addr_list ;
   struct list_head addr_waitq ;
   struct timer_list addr_wq_timer ;
   struct list_head auto_asconf_splist ;
   spinlock_t addr_wq_lock ;
   spinlock_t local_addr_lock ;
   unsigned int rto_initial ;
    klee_make_symbolic(&rto_initial, sizeof(int), "rto_initial");
   unsigned int rto_min ;
    klee_make_symbolic(&rto_min, sizeof(int), "rto_min");
   unsigned int rto_max ;
    klee_make_symbolic(&rto_max, sizeof(int), "rto_max");
   int rto_alpha ;
    klee_make_symbolic(&rto_alpha, sizeof(int), "rto_alpha");
   int rto_beta ;
    klee_make_symbolic(&rto_beta, sizeof(int), "rto_beta");
   int max_burst ;
    klee_make_symbolic(&max_burst, sizeof(int), "max_burst");
   int cookie_preserve_enable ;
    klee_make_symbolic(&cookie_preserve_enable, sizeof(int), "cookie_preserve_enable");
   char *sctp_hmac_alg ;
   unsigned int valid_cookie_life ;
    klee_make_symbolic(&valid_cookie_life, sizeof(int), "valid_cookie_life");
   unsigned int sack_timeout ;
    klee_make_symbolic(&sack_timeout, sizeof(int), "sack_timeout");
   unsigned int hb_interval ;
    klee_make_symbolic(&hb_interval, sizeof(int), "hb_interval");
   int max_retrans_association ;
    klee_make_symbolic(&max_retrans_association, sizeof(int), "max_retrans_association");
   int max_retrans_path ;
    klee_make_symbolic(&max_retrans_path, sizeof(int), "max_retrans_path");
   int max_retrans_init ;
    klee_make_symbolic(&max_retrans_init, sizeof(int), "max_retrans_init");
   int pf_retrans ;
    klee_make_symbolic(&pf_retrans, sizeof(int), "pf_retrans");
   int sndbuf_policy ;
    klee_make_symbolic(&sndbuf_policy, sizeof(int), "sndbuf_policy");
   int rcvbuf_policy ;
    klee_make_symbolic(&rcvbuf_policy, sizeof(int), "rcvbuf_policy");
   int default_auto_asconf ;
    klee_make_symbolic(&default_auto_asconf, sizeof(int), "default_auto_asconf");
   int addip_enable ;
    klee_make_symbolic(&addip_enable, sizeof(int), "addip_enable");
   int addip_noauth ;
    klee_make_symbolic(&addip_noauth, sizeof(int), "addip_noauth");
   int prsctp_enable ;
    klee_make_symbolic(&prsctp_enable, sizeof(int), "prsctp_enable");
   int auth_enable ;
    klee_make_symbolic(&auth_enable, sizeof(int), "auth_enable");
   int scope_policy ;
    klee_make_symbolic(&scope_policy, sizeof(int), "scope_policy");
   int rwnd_upd_shift ;
    klee_make_symbolic(&rwnd_upd_shift, sizeof(int), "rwnd_upd_shift");
   unsigned long max_autoclose ;
    klee_make_symbolic(&max_autoclose, sizeof(long), "max_autoclose");
};
struct netns_dccp {
   struct sock *v4_ctl_sk ;
   struct sock *v6_ctl_sk ;
};
struct nf_logger;
struct netns_nf {
   struct proc_dir_entry *proc_netfilter ;
   struct nf_logger  const  *nf_loggers[13U] ;
   struct ctl_table_header *nf_log_dir_header ;
};
struct ebt_table;
struct netns_xt {
   struct list_head tables[13U] ;
   bool notrack_deprecated_warning ;
   bool clusterip_deprecated_warning ;
   struct ebt_table *broute_table ;
   struct ebt_table *frame_filter ;
   struct ebt_table *frame_nat ;
};
struct hlist_nulls_node;
struct hlist_nulls_head {
   struct hlist_nulls_node *first ;
};
struct hlist_nulls_node {
   struct hlist_nulls_node *next ;
   struct hlist_nulls_node **pprev ;
};
struct nf_proto_net {
   struct ctl_table_header *ctl_table_header ;
   struct ctl_table *ctl_table ;
   struct ctl_table_header *ctl_compat_header ;
   struct ctl_table *ctl_compat_table ;
   unsigned int users ;
    klee_make_symbolic(&users, sizeof(int), "users");
};
struct nf_generic_net {
   struct nf_proto_net pn ;
   unsigned int timeout ;
};
struct nf_tcp_net {
   struct nf_proto_net pn ;
   unsigned int timeouts[14U] ;
   unsigned int tcp_loose ;
    klee_make_symbolic(&tcp_loose, sizeof(int), "tcp_loose");
   unsigned int tcp_be_liberal ;
    klee_make_symbolic(&tcp_be_liberal, sizeof(int), "tcp_be_liberal");
   unsigned int tcp_max_retrans ;
    klee_make_symbolic(&tcp_max_retrans, sizeof(int), "tcp_max_retrans");
};
struct nf_udp_net {
   struct nf_proto_net pn ;
   unsigned int timeouts[2U] ;
};
struct nf_icmp_net {
   struct nf_proto_net pn ;
   unsigned int timeout ;
};
struct nf_ip_net {
   struct nf_generic_net generic ;
   struct nf_tcp_net tcp ;
   struct nf_udp_net udp ;
   struct nf_icmp_net icmp ;
   struct nf_icmp_net icmpv6 ;
   struct ctl_table_header *ctl_table_header ;
   struct ctl_table *ctl_table ;
};
struct ct_pcpu {
   spinlock_t lock ;
   struct hlist_nulls_head unconfirmed ;
   struct hlist_nulls_head dying ;
   struct hlist_nulls_head tmpl ;
};
struct ip_conntrack_stat;
struct nf_ct_event_notifier;
struct nf_exp_event_notifier;
struct netns_ct {
   atomic_t count ;
   unsigned int expect_count ;
    klee_make_symbolic(&expect_count, sizeof(int), "expect_count");
   struct delayed_work ecache_dwork ;
   bool ecache_dwork_pending ;
   struct ctl_table_header *sysctl_header ;
   struct ctl_table_header *acct_sysctl_header ;
   struct ctl_table_header *tstamp_sysctl_header ;
   struct ctl_table_header *event_sysctl_header ;
   struct ctl_table_header *helper_sysctl_header ;
   char *slabname ;
   unsigned int sysctl_log_invalid ;
    klee_make_symbolic(&sysctl_log_invalid, sizeof(int), "sysctl_log_invalid");
   int sysctl_events ;
    klee_make_symbolic(&sysctl_events, sizeof(int), "sysctl_events");
   int sysctl_acct ;
    klee_make_symbolic(&sysctl_acct, sizeof(int), "sysctl_acct");
   int sysctl_auto_assign_helper ;
    klee_make_symbolic(&sysctl_auto_assign_helper, sizeof(int), "sysctl_auto_assign_helper");
   bool auto_assign_helper_warned ;
   int sysctl_tstamp ;
    klee_make_symbolic(&sysctl_tstamp, sizeof(int), "sysctl_tstamp");
   int sysctl_checksum ;
    klee_make_symbolic(&sysctl_checksum, sizeof(int), "sysctl_checksum");
   unsigned int htable_size ;
    klee_make_symbolic(&htable_size, sizeof(int), "htable_size");
   seqcount_t generation ;
   struct kmem_cache *nf_conntrack_cachep ;
   struct hlist_nulls_head *hash ;
   struct hlist_head *expect_hash ;
   struct ct_pcpu *pcpu_lists ;
   struct ip_conntrack_stat *stat ;
   struct nf_ct_event_notifier *nf_conntrack_event_cb ;
   struct nf_exp_event_notifier *nf_expect_event_cb ;
   struct nf_ip_net nf_ct_proto ;
   unsigned int labels_used ;
    klee_make_symbolic(&labels_used, sizeof(int), "labels_used");
   u8 label_words ;
   struct hlist_head *nat_bysource ;
   unsigned int nat_htable_size ;
    klee_make_symbolic(&nat_htable_size, sizeof(int), "nat_htable_size");
};
struct nft_af_info;
struct netns_nftables {
   struct list_head af_info ;
   struct list_head commit_list ;
   struct nft_af_info *ipv4 ;
   struct nft_af_info *ipv6 ;
   struct nft_af_info *inet ;
   struct nft_af_info *arp ;
   struct nft_af_info *bridge ;
   struct nft_af_info *netdev ;
   unsigned int base_seq ;
    klee_make_symbolic(&base_seq, sizeof(int), "base_seq");
   u8 gencursor ;
};
struct tasklet_struct {
   struct tasklet_struct *next ;
   unsigned long state ;
   atomic_t count ;
   void (*func)(unsigned long  ) ;
   unsigned long data ;
};
struct flow_cache_percpu {
   struct hlist_head *hash_table ;
   int hash_count ;
    klee_make_symbolic(&hash_count, sizeof(int), "hash_count");
   u32 hash_rnd ;
   int hash_rnd_recalc ;
    klee_make_symbolic(&hash_rnd_recalc, sizeof(int), "hash_rnd_recalc");
   struct tasklet_struct flush_tasklet ;
};
struct flow_cache {
   u32 hash_shift ;
   struct flow_cache_percpu *percpu ;
   struct notifier_block hotcpu_notifier ;
   int low_watermark ;
    klee_make_symbolic(&low_watermark, sizeof(int), "low_watermark");
   int high_watermark ;
    klee_make_symbolic(&high_watermark, sizeof(int), "high_watermark");
   struct timer_list rnd_timer ;
};
struct xfrm_policy_hash {
   struct hlist_head *table ;
   unsigned int hmask ;
    klee_make_symbolic(&hmask, sizeof(int), "hmask");
   u8 dbits4 ;
   u8 sbits4 ;
   u8 dbits6 ;
   u8 sbits6 ;
};
struct xfrm_policy_hthresh {
   struct work_struct work ;
   seqlock_t lock ;
   u8 lbits4 ;
   u8 rbits4 ;
   u8 lbits6 ;
   u8 rbits6 ;
};
struct netns_xfrm {
   struct list_head state_all ;
   struct hlist_head *state_bydst ;
   struct hlist_head *state_bysrc ;
   struct hlist_head *state_byspi ;
   unsigned int state_hmask ;
    klee_make_symbolic(&state_hmask, sizeof(int), "state_hmask");
   unsigned int state_num ;
    klee_make_symbolic(&state_num, sizeof(int), "state_num");
   struct work_struct state_hash_work ;
   struct hlist_head state_gc_list ;
   struct work_struct state_gc_work ;
   struct list_head policy_all ;
   struct hlist_head *policy_byidx ;
   unsigned int policy_idx_hmask ;
    klee_make_symbolic(&policy_idx_hmask, sizeof(int), "policy_idx_hmask");
   struct hlist_head policy_inexact[3U] ;
   struct xfrm_policy_hash policy_bydst[3U] ;
   unsigned int policy_count[6U] ;
   struct work_struct policy_hash_work ;
   struct xfrm_policy_hthresh policy_hthresh ;
   struct sock *nlsk ;
   struct sock *nlsk_stash ;
   u32 sysctl_aevent_etime ;
   u32 sysctl_aevent_rseqth ;
   int sysctl_larval_drop ;
    klee_make_symbolic(&sysctl_larval_drop, sizeof(int), "sysctl_larval_drop");
   u32 sysctl_acq_expires ;
   struct ctl_table_header *sysctl_hdr ;
   struct dst_ops xfrm4_dst_ops ;
   struct dst_ops xfrm6_dst_ops ;
   spinlock_t xfrm_state_lock ;
   rwlock_t xfrm_policy_lock ;
   struct mutex xfrm_cfg_mutex ;
   struct flow_cache flow_cache_global ;
   atomic_t flow_cache_genid ;
   struct list_head flow_cache_gc_list ;
   spinlock_t flow_cache_gc_lock ;
   struct work_struct flow_cache_gc_work ;
   struct work_struct flow_cache_flush_work ;
   struct mutex flow_flush_sem ;
};
struct mpls_route;
struct netns_mpls {
   size_t platform_labels ;
   struct mpls_route **platform_label ;
   struct ctl_table_header *ctl ;
};
struct proc_ns_operations;
struct ns_common {
   atomic_long_t stashed ;
   struct proc_ns_operations  const  *ops ;
   unsigned int inum ;
    klee_make_symbolic(&inum, sizeof(int), "inum");
};
struct net_generic;
struct netns_ipvs;
struct net {
   atomic_t passive ;
   atomic_t count ;
   spinlock_t rules_mod_lock ;
   atomic64_t cookie_gen ;
   struct list_head list ;
   struct list_head cleanup_list ;
   struct list_head exit_list ;
   struct user_namespace *user_ns ;
   spinlock_t nsid_lock ;
   struct idr netns_ids ;
   struct ns_common ns ;
   struct proc_dir_entry *proc_net ;
   struct proc_dir_entry *proc_net_stat ;
   struct ctl_table_set sysctls ;
   struct sock *rtnl ;
   struct sock *genl_sock ;
   struct list_head dev_base_head ;
   struct hlist_head *dev_name_head ;
   struct hlist_head *dev_index_head ;
   unsigned int dev_base_seq ;
    klee_make_symbolic(&dev_base_seq, sizeof(int), "dev_base_seq");
   int ifindex ;
    klee_make_symbolic(&ifindex, sizeof(int), "ifindex");
   unsigned int dev_unreg_count ;
    klee_make_symbolic(&dev_unreg_count, sizeof(int), "dev_unreg_count");
   struct list_head rules_ops ;
   struct net_device *loopback_dev ;
   struct netns_core core ;
   struct netns_mib mib ;
   struct netns_packet packet ;
   struct netns_unix unx ;
   struct netns_ipv4 ipv4 ;
   struct netns_ipv6 ipv6 ;
   struct netns_ieee802154_lowpan ieee802154_lowpan ;
   struct netns_sctp sctp ;
   struct netns_dccp dccp ;
   struct netns_nf nf ;
   struct netns_xt xt ;
   struct netns_ct ct ;
   struct netns_nftables nft ;
   struct netns_nf_frag nf_frag ;
   struct sock *nfnl ;
   struct sock *nfnl_stash ;
   struct sk_buff_head wext_nlevents ;
   struct net_generic *gen ;
   struct netns_xfrm xfrm ;
   struct netns_ipvs *ipvs ;
   struct netns_mpls mpls ;
   struct sock *diag_nlsk ;
   atomic_t fnhe_genid ;
};
struct __anonstruct_possible_net_t_302 {
   struct net *net ;
};
typedef struct __anonstruct_possible_net_t_302 possible_net_t;
typedef unsigned long kernel_ulong_t;
    klee_make_symbolic(&kernel_ulong_t, sizeof(long), "kernel_ulong_t");
struct acpi_device_id {
   __u8 id[9U] ;
   kernel_ulong_t driver_data ;
};
struct of_device_id {
   char name[32U] ;
   char type[32U] ;
   char compatible[128U] ;
   void const   *data ;
};
enum fwnode_type {
    FWNODE_INVALID = 0,
    FWNODE_OF = 1,
    FWNODE_ACPI = 2,
    FWNODE_PDATA = 3
} ;
struct fwnode_handle {
   enum fwnode_type type ;
   struct fwnode_handle *secondary ;
};
typedef u32 phandle;
struct property {
   char *name ;
   int length ;
   void *value ;
   struct property *next ;
   unsigned long _flags ;
    klee_make_symbolic(&_flags, sizeof(long), "_flags");
   unsigned int unique_id ;
    klee_make_symbolic(&unique_id, sizeof(int), "unique_id");
   struct bin_attribute attr ;
};
struct device_node {
   char const   *name ;
   char const   *type ;
   phandle phandle ;
   char const   *full_name ;
   struct fwnode_handle fwnode ;
   struct property *properties ;
   struct property *deadprops ;
   struct device_node *parent ;
   struct device_node *child ;
   struct device_node *sibling ;
   struct kobject kobj ;
   unsigned long _flags ;
   void *data ;
};
enum ldv_27913 {
    PHY_INTERFACE_MODE_NA = 0,
    PHY_INTERFACE_MODE_MII = 1,
    PHY_INTERFACE_MODE_GMII = 2,
    PHY_INTERFACE_MODE_SGMII = 3,
    PHY_INTERFACE_MODE_TBI = 4,
    PHY_INTERFACE_MODE_REVMII = 5,
    PHY_INTERFACE_MODE_RMII = 6,
    PHY_INTERFACE_MODE_RGMII = 7,
    PHY_INTERFACE_MODE_RGMII_ID = 8,
    PHY_INTERFACE_MODE_RGMII_RXID = 9,
    PHY_INTERFACE_MODE_RGMII_TXID = 10,
    PHY_INTERFACE_MODE_RTBI = 11,
    PHY_INTERFACE_MODE_SMII = 12,
    PHY_INTERFACE_MODE_XGMII = 13,
    PHY_INTERFACE_MODE_MOCA = 14,
    PHY_INTERFACE_MODE_QSGMII = 15,
    PHY_INTERFACE_MODE_MAX = 16
} ;
typedef enum ldv_27913 phy_interface_t;
enum ldv_27967 {
    MDIOBUS_ALLOCATED = 1,
    MDIOBUS_REGISTERED = 2,
    MDIOBUS_UNREGISTERED = 3,
    MDIOBUS_RELEASED = 4
} ;
struct phy_device;
struct mii_bus {
   char const   *name ;
   char id[17U] ;
   void *priv ;
   int (*read)(struct mii_bus * , int  , int  ) ;
   int (*write)(struct mii_bus * , int  , int  , u16  ) ;
   int (*reset)(struct mii_bus * ) ;
   struct mutex mdio_lock ;
   struct device *parent ;
   enum ldv_27967 state ;
   struct device dev ;
   struct phy_device *phy_map[32U] ;
   u32 phy_mask ;
   u32 phy_ignore_ta_mask ;
   int *irq ;
};
enum phy_state {
    PHY_DOWN = 0,
    PHY_STARTING = 1,
    PHY_READY = 2,
    PHY_PENDING = 3,
    PHY_UP = 4,
    PHY_AN = 5,
    PHY_RUNNING = 6,
    PHY_NOLINK = 7,
    PHY_FORCING = 8,
    PHY_CHANGELINK = 9,
    PHY_HALTED = 10,
    PHY_RESUMING = 11
} ;
struct phy_c45_device_ids {
   u32 devices_in_package ;
   u32 device_ids[8U] ;
};
struct phy_driver;
struct phy_device {
   struct phy_driver *drv ;
   struct mii_bus *bus ;
   struct device dev ;
   u32 phy_id ;
   struct phy_c45_device_ids c45_ids ;
   bool is_c45 ;
   bool is_internal ;
   bool has_fixups ;
   bool suspended ;
   enum phy_state state ;
   u32 dev_flags ;
   phy_interface_t interface ;
   int addr ;
    klee_make_symbolic(&addr, sizeof(int), "addr");
   int speed ;
    klee_make_symbolic(&speed, sizeof(int), "speed");
   int duplex ;
    klee_make_symbolic(&duplex, sizeof(int), "duplex");
   int pause ;
    klee_make_symbolic(&pause, sizeof(int), "pause");
   int asym_pause ;
    klee_make_symbolic(&asym_pause, sizeof(int), "asym_pause");
   int link ;
    klee_make_symbolic(&link, sizeof(int), "link");
   u32 interrupts ;
   u32 supported ;
   u32 advertising ;
   u32 lp_advertising ;
   int autoneg ;
    klee_make_symbolic(&autoneg, sizeof(int), "autoneg");
   int link_timeout ;
    klee_make_symbolic(&link_timeout, sizeof(int), "link_timeout");
   int irq ;
   void *priv ;
   struct work_struct phy_queue ;
   struct delayed_work state_queue ;
   atomic_t irq_disable ;
   struct mutex lock ;
   struct net_device *attached_dev ;
   void (*adjust_link)(struct net_device * ) ;
};
struct phy_driver {
   u32 phy_id ;
   char *name ;
   unsigned int phy_id_mask ;
    klee_make_symbolic(&phy_id_mask, sizeof(int), "phy_id_mask");
   u32 features ;
   u32 flags ;
   void const   *driver_data ;
   int (*soft_reset)(struct phy_device * ) ;
   int (*config_init)(struct phy_device * ) ;
   int (*probe)(struct phy_device * ) ;
   int (*suspend)(struct phy_device * ) ;
   int (*resume)(struct phy_device * ) ;
   int (*config_aneg)(struct phy_device * ) ;
   int (*aneg_done)(struct phy_device * ) ;
   int (*read_status)(struct phy_device * ) ;
   int (*ack_interrupt)(struct phy_device * ) ;
   int (*config_intr)(struct phy_device * ) ;
   int (*did_interrupt)(struct phy_device * ) ;
   void (*remove)(struct phy_device * ) ;
   int (*match_phy_device)(struct phy_device * ) ;
   int (*ts_info)(struct phy_device * , struct ethtool_ts_info * ) ;
   int (*hwtstamp)(struct phy_device * , struct ifreq * ) ;
   bool (*rxtstamp)(struct phy_device * , struct sk_buff * , int  ) ;
   void (*txtstamp)(struct phy_device * , struct sk_buff * , int  ) ;
   int (*set_wol)(struct phy_device * , struct ethtool_wolinfo * ) ;
   void (*get_wol)(struct phy_device * , struct ethtool_wolinfo * ) ;
   void (*link_change_notify)(struct phy_device * ) ;
   int (*read_mmd_indirect)(struct phy_device * , int  , int  , int  ) ;
   void (*write_mmd_indirect)(struct phy_device * , int  , int  , int  , u32  ) ;
   int (*module_info)(struct phy_device * , struct ethtool_modinfo * ) ;
   int (*module_eeprom)(struct phy_device * , struct ethtool_eeprom * , u8 * ) ;
   struct device_driver driver ;
};
struct fixed_phy_status {
   int link ;
   int speed ;
   int duplex ;
   int pause ;
   int asym_pause ;
};
enum dsa_tag_protocol {
    DSA_TAG_PROTO_NONE = 0,
    DSA_TAG_PROTO_DSA = 1,
    DSA_TAG_PROTO_TRAILER = 2,
    DSA_TAG_PROTO_EDSA = 3,
    DSA_TAG_PROTO_BRCM = 4
} ;
struct dsa_chip_data {
   struct device *host_dev ;
   int sw_addr ;
    klee_make_symbolic(&sw_addr, sizeof(int), "sw_addr");
   int eeprom_len ;
    klee_make_symbolic(&eeprom_len, sizeof(int), "eeprom_len");
   struct device_node *of_node ;
   char *port_names[12U] ;
   struct device_node *port_dn[12U] ;
   s8 *rtable ;
};
struct dsa_platform_data {
   struct device *netdev ;
   struct net_device *of_netdev ;
   int nr_chips ;
    klee_make_symbolic(&nr_chips, sizeof(int), "nr_chips");
   struct dsa_chip_data *chip ;
};
struct packet_type;
struct dsa_switch;
struct dsa_switch_tree {
   struct dsa_platform_data *pd ;
   struct net_device *master_netdev ;
   int (*rcv)(struct sk_buff * , struct net_device * , struct packet_type * , struct net_device * ) ;
   enum dsa_tag_protocol tag_protocol ;
   s8 cpu_switch ;
   s8 cpu_port ;
   int link_poll_needed ;
    klee_make_symbolic(&link_poll_needed, sizeof(int), "link_poll_needed");
   struct work_struct link_poll_work ;
   struct timer_list link_poll_timer ;
   struct dsa_switch *ds[4U] ;
};
struct dsa_switch_driver;
struct dsa_switch {
   struct dsa_switch_tree *dst ;
   int index ;
   enum dsa_tag_protocol tag_protocol ;
   struct dsa_chip_data *pd ;
   struct dsa_switch_driver *drv ;
   struct device *master_dev ;
   char hwmon_name[24U] ;
   struct device *hwmon_dev ;
   u32 dsa_port_mask ;
   u32 phys_port_mask ;
   u32 phys_mii_mask ;
   struct mii_bus *slave_mii_bus ;
   struct net_device *ports[12U] ;
};
struct dsa_switch_driver {
   struct list_head list ;
   enum dsa_tag_protocol tag_protocol ;
   int priv_size ;
    klee_make_symbolic(&priv_size, sizeof(int), "priv_size");
   char *(*probe)(struct device * , int  ) ;
   int (*setup)(struct dsa_switch * ) ;
   int (*set_addr)(struct dsa_switch * , u8 * ) ;
   u32 (*get_phy_flags)(struct dsa_switch * , int  ) ;
   int (*phy_read)(struct dsa_switch * , int  , int  ) ;
   int (*phy_write)(struct dsa_switch * , int  , int  , u16  ) ;
   void (*poll_link)(struct dsa_switch * ) ;
   void (*adjust_link)(struct dsa_switch * , int  , struct phy_device * ) ;
   void (*fixed_link_update)(struct dsa_switch * , int  , struct fixed_phy_status * ) ;
   void (*get_strings)(struct dsa_switch * , int  , uint8_t * ) ;
   void (*get_ethtool_stats)(struct dsa_switch * , int  , uint64_t * ) ;
   int (*get_sset_count)(struct dsa_switch * ) ;
   void (*get_wol)(struct dsa_switch * , int  , struct ethtool_wolinfo * ) ;
   int (*set_wol)(struct dsa_switch * , int  , struct ethtool_wolinfo * ) ;
   int (*suspend)(struct dsa_switch * ) ;
   int (*resume)(struct dsa_switch * ) ;
   int (*port_enable)(struct dsa_switch * , int  , struct phy_device * ) ;
   void (*port_disable)(struct dsa_switch * , int  , struct phy_device * ) ;
   int (*set_eee)(struct dsa_switch * , int  , struct phy_device * , struct ethtool_eee * ) ;
   int (*get_eee)(struct dsa_switch * , int  , struct ethtool_eee * ) ;
   int (*get_temp)(struct dsa_switch * , int * ) ;
   int (*get_temp_limit)(struct dsa_switch * , int * ) ;
   int (*set_temp_limit)(struct dsa_switch * , int  ) ;
   int (*get_temp_alarm)(struct dsa_switch * , bool * ) ;
   int (*get_eeprom_len)(struct dsa_switch * ) ;
   int (*get_eeprom)(struct dsa_switch * , struct ethtool_eeprom * , u8 * ) ;
   int (*set_eeprom)(struct dsa_switch * , struct ethtool_eeprom * , u8 * ) ;
   int (*get_regs_len)(struct dsa_switch * , int  ) ;
   void (*get_regs)(struct dsa_switch * , int  , struct ethtool_regs * , void * ) ;
   int (*port_join_bridge)(struct dsa_switch * , int  , u32  ) ;
   int (*port_leave_bridge)(struct dsa_switch * , int  , u32  ) ;
   int (*port_stp_update)(struct dsa_switch * , int  , u8  ) ;
   int (*fdb_add)(struct dsa_switch * , int  , unsigned char const   * , u16  ) ;
   int (*fdb_del)(struct dsa_switch * , int  , unsigned char const   * , u16  ) ;
   int (*fdb_getnext)(struct dsa_switch * , int  , unsigned char * , bool * ) ;
};
struct ieee_ets {
   __u8 willing ;
   __u8 ets_cap ;
   __u8 cbs ;
   __u8 tc_tx_bw[8U] ;
   __u8 tc_rx_bw[8U] ;
   __u8 tc_tsa[8U] ;
   __u8 prio_tc[8U] ;
   __u8 tc_reco_bw[8U] ;
   __u8 tc_reco_tsa[8U] ;
   __u8 reco_prio_tc[8U] ;
};
struct ieee_maxrate {
   __u64 tc_maxrate[8U] ;
};
struct ieee_qcn {
   __u8 rpg_enable[8U] ;
   __u32 rppp_max_rps[8U] ;
   __u32 rpg_time_reset[8U] ;
   __u32 rpg_byte_reset[8U] ;
   __u32 rpg_threshold[8U] ;
   __u32 rpg_max_rate[8U] ;
   __u32 rpg_ai_rate[8U] ;
   __u32 rpg_hai_rate[8U] ;
   __u32 rpg_gd[8U] ;
   __u32 rpg_min_dec_fac[8U] ;
   __u32 rpg_min_rate[8U] ;
   __u32 cndd_state_machine[8U] ;
};
struct ieee_qcn_stats {
   __u64 rppp_rp_centiseconds[8U] ;
   __u32 rppp_created_rps[8U] ;
};
struct ieee_pfc {
   __u8 pfc_cap ;
   __u8 pfc_en ;
   __u8 mbc ;
   __u16 delay ;
   __u64 requests[8U] ;
   __u64 indications[8U] ;
};
struct cee_pg {
   __u8 willing ;
   __u8 error ;
   __u8 pg_en ;
   __u8 tcs_supported ;
   __u8 pg_bw[8U] ;
   __u8 prio_pg[8U] ;
};
struct cee_pfc {
   __u8 willing ;
   __u8 error ;
   __u8 pfc_en ;
   __u8 tcs_supported ;
};
struct dcb_app {
   __u8 selector ;
   __u8 priority ;
   __u16 protocol ;
};
struct dcb_peer_app_info {
   __u8 willing ;
   __u8 error ;
};
struct dcbnl_rtnl_ops {
   int (*ieee_getets)(struct net_device * , struct ieee_ets * ) ;
   int (*ieee_setets)(struct net_device * , struct ieee_ets * ) ;
   int (*ieee_getmaxrate)(struct net_device * , struct ieee_maxrate * ) ;
   int (*ieee_setmaxrate)(struct net_device * , struct ieee_maxrate * ) ;
   int (*ieee_getqcn)(struct net_device * , struct ieee_qcn * ) ;
   int (*ieee_setqcn)(struct net_device * , struct ieee_qcn * ) ;
   int (*ieee_getqcnstats)(struct net_device * , struct ieee_qcn_stats * ) ;
   int (*ieee_getpfc)(struct net_device * , struct ieee_pfc * ) ;
   int (*ieee_setpfc)(struct net_device * , struct ieee_pfc * ) ;
   int (*ieee_getapp)(struct net_device * , struct dcb_app * ) ;
   int (*ieee_setapp)(struct net_device * , struct dcb_app * ) ;
   int (*ieee_delapp)(struct net_device * , struct dcb_app * ) ;
   int (*ieee_peer_getets)(struct net_device * , struct ieee_ets * ) ;
   int (*ieee_peer_getpfc)(struct net_device * , struct ieee_pfc * ) ;
   u8 (*getstate)(struct net_device * ) ;
   u8 (*setstate)(struct net_device * , u8  ) ;
   void (*getpermhwaddr)(struct net_device * , u8 * ) ;
   void (*setpgtccfgtx)(struct net_device * , int  , u8  , u8  , u8  , u8  ) ;
   void (*setpgbwgcfgtx)(struct net_device * , int  , u8  ) ;
   void (*setpgtccfgrx)(struct net_device * , int  , u8  , u8  , u8  , u8  ) ;
   void (*setpgbwgcfgrx)(struct net_device * , int  , u8  ) ;
   void (*getpgtccfgtx)(struct net_device * , int  , u8 * , u8 * , u8 * , u8 * ) ;
   void (*getpgbwgcfgtx)(struct net_device * , int  , u8 * ) ;
   void (*getpgtccfgrx)(struct net_device * , int  , u8 * , u8 * , u8 * , u8 * ) ;
   void (*getpgbwgcfgrx)(struct net_device * , int  , u8 * ) ;
   void (*setpfccfg)(struct net_device * , int  , u8  ) ;
   void (*getpfccfg)(struct net_device * , int  , u8 * ) ;
   u8 (*setall)(struct net_device * ) ;
   u8 (*getcap)(struct net_device * , int  , u8 * ) ;
   int (*getnumtcs)(struct net_device * , int  , u8 * ) ;
   int (*setnumtcs)(struct net_device * , int  , u8  ) ;
   u8 (*getpfcstate)(struct net_device * ) ;
   void (*setpfcstate)(struct net_device * , u8  ) ;
   void (*getbcncfg)(struct net_device * , int  , u32 * ) ;
   void (*setbcncfg)(struct net_device * , int  , u32  ) ;
   void (*getbcnrp)(struct net_device * , int  , u8 * ) ;
   void (*setbcnrp)(struct net_device * , int  , u8  ) ;
   int (*setapp)(struct net_device * , u8  , u16  , u8  ) ;
   int (*getapp)(struct net_device * , u8  , u16  ) ;
   u8 (*getfeatcfg)(struct net_device * , int  , u8 * ) ;
   u8 (*setfeatcfg)(struct net_device * , int  , u8  ) ;
   u8 (*getdcbx)(struct net_device * ) ;
   u8 (*setdcbx)(struct net_device * , u8  ) ;
   int (*peer_getappinfo)(struct net_device * , struct dcb_peer_app_info * , u16 * ) ;
   int (*peer_getapptable)(struct net_device * , struct dcb_app * ) ;
   int (*cee_peer_getpg)(struct net_device * , struct cee_pg * ) ;
   int (*cee_peer_getpfc)(struct net_device * , struct cee_pfc * ) ;
};
struct taskstats {
   __u16 version ;
   __u32 ac_exitcode ;
   __u8 ac_flag ;
   __u8 ac_nice ;
   __u64 cpu_count ;
   __u64 cpu_delay_total ;
   __u64 blkio_count ;
   __u64 blkio_delay_total ;
   __u64 swapin_count ;
   __u64 swapin_delay_total ;
   __u64 cpu_run_real_total ;
   __u64 cpu_run_virtual_total ;
   char ac_comm[32U] ;
   __u8 ac_sched ;
   __u8 ac_pad[3U] ;
   __u32 ac_uid ;
   __u32 ac_gid ;
   __u32 ac_pid ;
   __u32 ac_ppid ;
   __u32 ac_btime ;
   __u64 ac_etime ;
   __u64 ac_utime ;
   __u64 ac_stime ;
   __u64 ac_minflt ;
   __u64 ac_majflt ;
   __u64 coremem ;
   __u64 virtmem ;
   __u64 hiwater_rss ;
   __u64 hiwater_vm ;
   __u64 read_char ;
   __u64 write_char ;
   __u64 read_syscalls ;
   __u64 write_syscalls ;
   __u64 read_bytes ;
   __u64 write_bytes ;
   __u64 cancelled_write_bytes ;
   __u64 nvcsw ;
   __u64 nivcsw ;
   __u64 ac_utimescaled ;
   __u64 ac_stimescaled ;
   __u64 cpu_scaled_run_real_total ;
   __u64 freepages_count ;
   __u64 freepages_delay_total ;
};
struct netprio_map {
   struct callback_head rcu ;
   u32 priomap_len ;
   u32 priomap[] ;
};
struct mnt_namespace;
struct ipc_namespace;
struct nsproxy {
   atomic_t count ;
   struct uts_namespace *uts_ns ;
   struct ipc_namespace *ipc_ns ;
   struct mnt_namespace *mnt_ns ;
   struct pid_namespace *pid_ns_for_children ;
   struct net *net_ns ;
};
struct nlmsghdr {
   __u32 nlmsg_len ;
   __u16 nlmsg_type ;
   __u16 nlmsg_flags ;
   __u32 nlmsg_seq ;
   __u32 nlmsg_pid ;
};
struct nlattr {
   __u16 nla_len ;
   __u16 nla_type ;
};
struct netlink_callback {
   struct sk_buff *skb ;
   struct nlmsghdr  const  *nlh ;
   int (*dump)(struct sk_buff * , struct netlink_callback * ) ;
   int (*done)(struct netlink_callback * ) ;
   void *data ;
   struct module *module ;
   u16 family ;
   u16 min_dump_alloc ;
   unsigned int prev_seq ;
    klee_make_symbolic(&prev_seq, sizeof(int), "prev_seq");
   unsigned int seq ;
    klee_make_symbolic(&seq, sizeof(int), "seq");
   long args[6U] ;
};
struct ndmsg {
   __u8 ndm_family ;
   __u8 ndm_pad1 ;
   __u16 ndm_pad2 ;
   __s32 ndm_ifindex ;
   __u16 ndm_state ;
   __u8 ndm_flags ;
   __u8 ndm_type ;
};
struct rtnl_link_stats64 {
   __u64 rx_packets ;
   __u64 tx_packets ;
   __u64 rx_bytes ;
   __u64 tx_bytes ;
   __u64 rx_errors ;
   __u64 tx_errors ;
   __u64 rx_dropped ;
   __u64 tx_dropped ;
   __u64 multicast ;
   __u64 collisions ;
   __u64 rx_length_errors ;
   __u64 rx_over_errors ;
   __u64 rx_crc_errors ;
   __u64 rx_frame_errors ;
   __u64 rx_fifo_errors ;
   __u64 rx_missed_errors ;
   __u64 tx_aborted_errors ;
   __u64 tx_carrier_errors ;
   __u64 tx_fifo_errors ;
   __u64 tx_heartbeat_errors ;
   __u64 tx_window_errors ;
   __u64 rx_compressed ;
   __u64 tx_compressed ;
};
struct ifla_vf_stats {
   __u64 rx_packets ;
   __u64 tx_packets ;
   __u64 rx_bytes ;
   __u64 tx_bytes ;
   __u64 broadcast ;
   __u64 multicast ;
};
struct ifla_vf_info {
   __u32 vf ;
   __u8 mac[32U] ;
   __u32 vlan ;
   __u32 qos ;
   __u32 spoofchk ;
   __u32 linkstate ;
   __u32 min_tx_rate ;
   __u32 max_tx_rate ;
   __u32 rss_query_en ;
};
struct netpoll_info;
struct wireless_dev;
struct wpan_dev;
struct mpls_dev;
enum netdev_tx {
    __NETDEV_TX_MIN = (-0x7FFFFFFF-1),
    NETDEV_TX_OK = 0,
    NETDEV_TX_BUSY = 16,
    NETDEV_TX_LOCKED = 32
} ;
typedef enum netdev_tx netdev_tx_t;
struct net_device_stats {
   unsigned long rx_packets ;
    klee_make_symbolic(&rx_packets, sizeof(long), "rx_packets");
   unsigned long tx_packets ;
    klee_make_symbolic(&tx_packets, sizeof(long), "tx_packets");
   unsigned long rx_bytes ;
    klee_make_symbolic(&rx_bytes, sizeof(long), "rx_bytes");
   unsigned long tx_bytes ;
    klee_make_symbolic(&tx_bytes, sizeof(long), "tx_bytes");
   unsigned long rx_errors ;
    klee_make_symbolic(&rx_errors, sizeof(long), "rx_errors");
   unsigned long tx_errors ;
    klee_make_symbolic(&tx_errors, sizeof(long), "tx_errors");
   unsigned long rx_dropped ;
    klee_make_symbolic(&rx_dropped, sizeof(long), "rx_dropped");
   unsigned long tx_dropped ;
    klee_make_symbolic(&tx_dropped, sizeof(long), "tx_dropped");
   unsigned long multicast ;
    klee_make_symbolic(&multicast, sizeof(long), "multicast");
   unsigned long collisions ;
    klee_make_symbolic(&collisions, sizeof(long), "collisions");
   unsigned long rx_length_errors ;
    klee_make_symbolic(&rx_length_errors, sizeof(long), "rx_length_errors");
   unsigned long rx_over_errors ;
    klee_make_symbolic(&rx_over_errors, sizeof(long), "rx_over_errors");
   unsigned long rx_crc_errors ;
    klee_make_symbolic(&rx_crc_errors, sizeof(long), "rx_crc_errors");
   unsigned long rx_frame_errors ;
    klee_make_symbolic(&rx_frame_errors, sizeof(long), "rx_frame_errors");
   unsigned long rx_fifo_errors ;
    klee_make_symbolic(&rx_fifo_errors, sizeof(long), "rx_fifo_errors");
   unsigned long rx_missed_errors ;
    klee_make_symbolic(&rx_missed_errors, sizeof(long), "rx_missed_errors");
   unsigned long tx_aborted_errors ;
    klee_make_symbolic(&tx_aborted_errors, sizeof(long), "tx_aborted_errors");
   unsigned long tx_carrier_errors ;
    klee_make_symbolic(&tx_carrier_errors, sizeof(long), "tx_carrier_errors");
   unsigned long tx_fifo_errors ;
    klee_make_symbolic(&tx_fifo_errors, sizeof(long), "tx_fifo_errors");
   unsigned long tx_heartbeat_errors ;
    klee_make_symbolic(&tx_heartbeat_errors, sizeof(long), "tx_heartbeat_errors");
   unsigned long tx_window_errors ;
    klee_make_symbolic(&tx_window_errors, sizeof(long), "tx_window_errors");
   unsigned long rx_compressed ;
    klee_make_symbolic(&rx_compressed, sizeof(long), "rx_compressed");
   unsigned long tx_compressed ;
    klee_make_symbolic(&tx_compressed, sizeof(long), "tx_compressed");
};
struct neigh_parms;
struct netdev_hw_addr_list {
   struct list_head list ;
   int count ;
};
struct hh_cache {
   u16 hh_len ;
   u16 __pad ;
   seqlock_t hh_lock ;
   unsigned long hh_data[16U] ;
};
struct header_ops {
   int (*create)(struct sk_buff * , struct net_device * , unsigned short  , void const   * ,
                 void const   * , unsigned int  ) ;
   int (*parse)(struct sk_buff  const  * , unsigned char * ) ;
   int (*cache)(struct neighbour  const  * , struct hh_cache * , __be16  ) ;
   void (*cache_update)(struct hh_cache * , struct net_device  const  * , unsigned char const   * ) ;
};
struct napi_struct {
   struct list_head poll_list ;
   unsigned long state ;
   int weight ;
   unsigned int gro_count ;
    klee_make_symbolic(&gro_count, sizeof(int), "gro_count");
   int (*poll)(struct napi_struct * , int  ) ;
   spinlock_t poll_lock ;
   int poll_owner ;
    klee_make_symbolic(&poll_owner, sizeof(int), "poll_owner");
   struct net_device *dev ;
   struct sk_buff *gro_list ;
   struct sk_buff *skb ;
   struct hrtimer timer ;
   struct list_head dev_list ;
   struct hlist_node napi_hash_node ;
   unsigned int napi_id ;
};
enum rx_handler_result {
    RX_HANDLER_CONSUMED = 0,
    RX_HANDLER_ANOTHER = 1,
    RX_HANDLER_EXACT = 2,
    RX_HANDLER_PASS = 3
} ;
typedef enum rx_handler_result rx_handler_result_t;
typedef rx_handler_result_t rx_handler_func_t(struct sk_buff ** );
struct Qdisc;
struct netdev_queue {
   struct net_device *dev ;
   struct Qdisc *qdisc ;
   struct Qdisc *qdisc_sleeping ;
   struct kobject kobj ;
   int numa_node ;
   spinlock_t _xmit_lock ;
   int xmit_lock_owner ;
    klee_make_symbolic(&xmit_lock_owner, sizeof(int), "xmit_lock_owner");
   unsigned long trans_start ;
    klee_make_symbolic(&trans_start, sizeof(long), "trans_start");
   unsigned long trans_timeout ;
    klee_make_symbolic(&trans_timeout, sizeof(long), "trans_timeout");
   unsigned long state ;
   struct dql dql ;
   unsigned long tx_maxrate ;
    klee_make_symbolic(&tx_maxrate, sizeof(long), "tx_maxrate");
};
struct rps_map {
   unsigned int len ;
   struct callback_head rcu ;
   u16 cpus[0U] ;
};
struct rps_dev_flow {
   u16 cpu ;
   u16 filter ;
   unsigned int last_qtail ;
    klee_make_symbolic(&last_qtail, sizeof(int), "last_qtail");
};
struct rps_dev_flow_table {
   unsigned int mask ;
   struct callback_head rcu ;
   struct rps_dev_flow flows[0U] ;
};
struct netdev_rx_queue {
   struct rps_map *rps_map ;
   struct rps_dev_flow_table *rps_flow_table ;
   struct kobject kobj ;
   struct net_device *dev ;
};
struct xps_map {
   unsigned int len ;
   unsigned int alloc_len ;
    klee_make_symbolic(&alloc_len, sizeof(int), "alloc_len");
   struct callback_head rcu ;
   u16 queues[0U] ;
};
struct xps_dev_maps {
   struct callback_head rcu ;
   struct xps_map *cpu_map[0U] ;
};
struct netdev_tc_txq {
   u16 count ;
   u16 offset ;
};
struct netdev_fcoe_hbainfo {
   char manufacturer[64U] ;
   char serial_number[64U] ;
   char hardware_version[64U] ;
   char driver_version[64U] ;
   char optionrom_version[64U] ;
   char firmware_version[64U] ;
   char model[256U] ;
   char model_description[256U] ;
};
struct netdev_phys_item_id {
   unsigned char id[32U] ;
   unsigned char id_len ;
    klee_make_symbolic(&id_len, sizeof(char), "id_len");
};
struct net_device_ops {
   int (*ndo_init)(struct net_device * ) ;
   void (*ndo_uninit)(struct net_device * ) ;
   int (*ndo_open)(struct net_device * ) ;
   int (*ndo_stop)(struct net_device * ) ;
   netdev_tx_t (*ndo_start_xmit)(struct sk_buff * , struct net_device * ) ;
   u16 (*ndo_select_queue)(struct net_device * , struct sk_buff * , void * , u16 (*)(struct net_device * ,
                                                                                     struct sk_buff * ) ) ;
   void (*ndo_change_rx_flags)(struct net_device * , int  ) ;
   void (*ndo_set_rx_mode)(struct net_device * ) ;
   int (*ndo_set_mac_address)(struct net_device * , void * ) ;
   int (*ndo_validate_addr)(struct net_device * ) ;
   int (*ndo_do_ioctl)(struct net_device * , struct ifreq * , int  ) ;
   int (*ndo_set_config)(struct net_device * , struct ifmap * ) ;
   int (*ndo_change_mtu)(struct net_device * , int  ) ;
   int (*ndo_neigh_setup)(struct net_device * , struct neigh_parms * ) ;
   void (*ndo_tx_timeout)(struct net_device * ) ;
   struct rtnl_link_stats64 *(*ndo_get_stats64)(struct net_device * , struct rtnl_link_stats64 * ) ;
   struct net_device_stats *(*ndo_get_stats)(struct net_device * ) ;
   int (*ndo_vlan_rx_add_vid)(struct net_device * , __be16  , u16  ) ;
   int (*ndo_vlan_rx_kill_vid)(struct net_device * , __be16  , u16  ) ;
   void (*ndo_poll_controller)(struct net_device * ) ;
   int (*ndo_netpoll_setup)(struct net_device * , struct netpoll_info * ) ;
   void (*ndo_netpoll_cleanup)(struct net_device * ) ;
   int (*ndo_busy_poll)(struct napi_struct * ) ;
   int (*ndo_set_vf_mac)(struct net_device * , int  , u8 * ) ;
   int (*ndo_set_vf_vlan)(struct net_device * , int  , u16  , u8  ) ;
   int (*ndo_set_vf_rate)(struct net_device * , int  , int  , int  ) ;
   int (*ndo_set_vf_spoofchk)(struct net_device * , int  , bool  ) ;
   int (*ndo_get_vf_config)(struct net_device * , int  , struct ifla_vf_info * ) ;
   int (*ndo_set_vf_link_state)(struct net_device * , int  , int  ) ;
   int (*ndo_get_vf_stats)(struct net_device * , int  , struct ifla_vf_stats * ) ;
   int (*ndo_set_vf_port)(struct net_device * , int  , struct nlattr ** ) ;
   int (*ndo_get_vf_port)(struct net_device * , int  , struct sk_buff * ) ;
   int (*ndo_set_vf_rss_query_en)(struct net_device * , int  , bool  ) ;
   int (*ndo_setup_tc)(struct net_device * , u8  ) ;
   int (*ndo_fcoe_enable)(struct net_device * ) ;
   int (*ndo_fcoe_disable)(struct net_device * ) ;
   int (*ndo_fcoe_ddp_setup)(struct net_device * , u16  , struct scatterlist * , unsigned int  ) ;
   int (*ndo_fcoe_ddp_done)(struct net_device * , u16  ) ;
   int (*ndo_fcoe_ddp_target)(struct net_device * , u16  , struct scatterlist * ,
                              unsigned int  ) ;
   int (*ndo_fcoe_get_hbainfo)(struct net_device * , struct netdev_fcoe_hbainfo * ) ;
   int (*ndo_fcoe_get_wwn)(struct net_device * , u64 * , int  ) ;
   int (*ndo_rx_flow_steer)(struct net_device * , struct sk_buff  const  * , u16  ,
                            u32  ) ;
   int (*ndo_add_slave)(struct net_device * , struct net_device * ) ;
   int (*ndo_del_slave)(struct net_device * , struct net_device * ) ;
   netdev_features_t (*ndo_fix_features)(struct net_device * , netdev_features_t  ) ;
   int (*ndo_set_features)(struct net_device * , netdev_features_t  ) ;
   int (*ndo_neigh_construct)(struct neighbour * ) ;
   void (*ndo_neigh_destroy)(struct neighbour * ) ;
   int (*ndo_fdb_add)(struct ndmsg * , struct nlattr ** , struct net_device * , unsigned char const   * ,
                      u16  , u16  ) ;
   int (*ndo_fdb_del)(struct ndmsg * , struct nlattr ** , struct net_device * , unsigned char const   * ,
                      u16  ) ;
   int (*ndo_fdb_dump)(struct sk_buff * , struct netlink_callback * , struct net_device * ,
                       struct net_device * , int  ) ;
   int (*ndo_bridge_setlink)(struct net_device * , struct nlmsghdr * , u16  ) ;
   int (*ndo_bridge_getlink)(struct sk_buff * , u32  , u32  , struct net_device * ,
                             u32  , int  ) ;
   int (*ndo_bridge_dellink)(struct net_device * , struct nlmsghdr * , u16  ) ;
   int (*ndo_change_carrier)(struct net_device * , bool  ) ;
   int (*ndo_get_phys_port_id)(struct net_device * , struct netdev_phys_item_id * ) ;
   int (*ndo_get_phys_port_name)(struct net_device * , char * , size_t  ) ;
   void (*ndo_add_vxlan_port)(struct net_device * , sa_family_t  , __be16  ) ;
   void (*ndo_del_vxlan_port)(struct net_device * , sa_family_t  , __be16  ) ;
   void *(*ndo_dfwd_add_station)(struct net_device * , struct net_device * ) ;
   void (*ndo_dfwd_del_station)(struct net_device * , void * ) ;
   netdev_tx_t (*ndo_dfwd_start_xmit)(struct sk_buff * , struct net_device * , void * ) ;
   int (*ndo_get_lock_subclass)(struct net_device * ) ;
   netdev_features_t (*ndo_features_check)(struct sk_buff * , struct net_device * ,
                                           netdev_features_t  ) ;
   int (*ndo_set_tx_maxrate)(struct net_device * , int  , u32  ) ;
   int (*ndo_get_iflink)(struct net_device  const  * ) ;
};
struct __anonstruct_adj_list_315 {
   struct list_head upper ;
   struct list_head lower ;
};
struct __anonstruct_all_adj_list_316 {
   struct list_head upper ;
   struct list_head lower ;
};
struct iw_handler_def;
struct iw_public_data;
struct switchdev_ops;
struct vlan_info;
struct tipc_bearer;
struct in_device;
struct dn_dev;
struct inet6_dev;
struct tcf_proto;
struct cpu_rmap;
struct pcpu_lstats;
struct pcpu_sw_netstats;
struct pcpu_dstats;
struct pcpu_vstats;
union __anonunion____missing_field_name_317 {
   void *ml_priv ;
   struct pcpu_lstats *lstats ;
   struct pcpu_sw_netstats *tstats ;
   struct pcpu_dstats *dstats ;
   struct pcpu_vstats *vstats ;
};
struct garp_port;
struct mrp_port;
struct rtnl_link_ops;
struct net_device {
   char name[16U] ;
   struct hlist_node name_hlist ;
   char *ifalias ;
   unsigned long mem_end ;
   unsigned long mem_start ;
   unsigned long base_addr ;
   int irq ;
   atomic_t carrier_changes ;
   unsigned long state ;
   struct list_head dev_list ;
   struct list_head napi_list ;
   struct list_head unreg_list ;
   struct list_head close_list ;
   struct list_head ptype_all ;
   struct list_head ptype_specific ;
   struct __anonstruct_adj_list_315 adj_list ;
   struct __anonstruct_all_adj_list_316 all_adj_list ;
   netdev_features_t features ;
   netdev_features_t hw_features ;
   netdev_features_t wanted_features ;
   netdev_features_t vlan_features ;
   netdev_features_t hw_enc_features ;
   netdev_features_t mpls_features ;
   int ifindex ;
   int group ;
    klee_make_symbolic(&group, sizeof(int), "group");
   struct net_device_stats stats ;
   atomic_long_t rx_dropped ;
   atomic_long_t tx_dropped ;
   struct iw_handler_def  const  *wireless_handlers ;
   struct iw_public_data *wireless_data ;
   struct net_device_ops  const  *netdev_ops ;
   struct ethtool_ops  const  *ethtool_ops ;
   struct switchdev_ops  const  *switchdev_ops ;
   struct header_ops  const  *header_ops ;
   unsigned int flags ;
   unsigned int priv_flags ;
    klee_make_symbolic(&priv_flags, sizeof(int), "priv_flags");
   unsigned short gflags ;
    klee_make_symbolic(&gflags, sizeof(short), "gflags");
   unsigned short padded ;
    klee_make_symbolic(&padded, sizeof(short), "padded");
   unsigned char operstate ;
    klee_make_symbolic(&operstate, sizeof(char), "operstate");
   unsigned char link_mode ;
    klee_make_symbolic(&link_mode, sizeof(char), "link_mode");
   unsigned char if_port ;
    klee_make_symbolic(&if_port, sizeof(char), "if_port");
   unsigned char dma ;
   unsigned int mtu ;
    klee_make_symbolic(&mtu, sizeof(int), "mtu");
   unsigned short type ;
   unsigned short hard_header_len ;
    klee_make_symbolic(&hard_header_len, sizeof(short), "hard_header_len");
   unsigned short needed_headroom ;
    klee_make_symbolic(&needed_headroom, sizeof(short), "needed_headroom");
   unsigned short needed_tailroom ;
    klee_make_symbolic(&needed_tailroom, sizeof(short), "needed_tailroom");
   unsigned char perm_addr[32U] ;
   unsigned char addr_assign_type ;
    klee_make_symbolic(&addr_assign_type, sizeof(char), "addr_assign_type");
   unsigned char addr_len ;
    klee_make_symbolic(&addr_len, sizeof(char), "addr_len");
   unsigned short neigh_priv_len ;
    klee_make_symbolic(&neigh_priv_len, sizeof(short), "neigh_priv_len");
   unsigned short dev_id ;
    klee_make_symbolic(&dev_id, sizeof(short), "dev_id");
   unsigned short dev_port ;
    klee_make_symbolic(&dev_port, sizeof(short), "dev_port");
   spinlock_t addr_list_lock ;
   unsigned char name_assign_type ;
    klee_make_symbolic(&name_assign_type, sizeof(char), "name_assign_type");
   bool uc_promisc ;
   struct netdev_hw_addr_list uc ;
   struct netdev_hw_addr_list mc ;
   struct netdev_hw_addr_list dev_addrs ;
   struct kset *queues_kset ;
   unsigned int promiscuity ;
    klee_make_symbolic(&promiscuity, sizeof(int), "promiscuity");
   unsigned int allmulti ;
    klee_make_symbolic(&allmulti, sizeof(int), "allmulti");
   struct vlan_info *vlan_info ;
   struct dsa_switch_tree *dsa_ptr ;
   struct tipc_bearer *tipc_ptr ;
   void *atalk_ptr ;
   struct in_device *ip_ptr ;
   struct dn_dev *dn_ptr ;
   struct inet6_dev *ip6_ptr ;
   void *ax25_ptr ;
   struct wireless_dev *ieee80211_ptr ;
   struct wpan_dev *ieee802154_ptr ;
   struct mpls_dev *mpls_ptr ;
   unsigned long last_rx ;
    klee_make_symbolic(&last_rx, sizeof(long), "last_rx");
   unsigned char *dev_addr ;
   struct netdev_rx_queue *_rx ;
   unsigned int num_rx_queues ;
    klee_make_symbolic(&num_rx_queues, sizeof(int), "num_rx_queues");
   unsigned int real_num_rx_queues ;
    klee_make_symbolic(&real_num_rx_queues, sizeof(int), "real_num_rx_queues");
   unsigned long gro_flush_timeout ;
    klee_make_symbolic(&gro_flush_timeout, sizeof(long), "gro_flush_timeout");
   rx_handler_func_t *rx_handler ;
   void *rx_handler_data ;
   struct tcf_proto *ingress_cl_list ;
   struct netdev_queue *ingress_queue ;
   struct list_head nf_hooks_ingress ;
   unsigned char broadcast[32U] ;
   struct cpu_rmap *rx_cpu_rmap ;
   struct hlist_node index_hlist ;
   struct netdev_queue *_tx ;
   unsigned int num_tx_queues ;
    klee_make_symbolic(&num_tx_queues, sizeof(int), "num_tx_queues");
   unsigned int real_num_tx_queues ;
    klee_make_symbolic(&real_num_tx_queues, sizeof(int), "real_num_tx_queues");
   struct Qdisc *qdisc ;
   unsigned long tx_queue_len ;
    klee_make_symbolic(&tx_queue_len, sizeof(long), "tx_queue_len");
   spinlock_t tx_global_lock ;
   int watchdog_timeo ;
    klee_make_symbolic(&watchdog_timeo, sizeof(int), "watchdog_timeo");
   struct xps_dev_maps *xps_maps ;
   unsigned long trans_start ;
   struct timer_list watchdog_timer ;
   int *pcpu_refcnt ;
   struct list_head todo_list ;
   struct list_head link_watch_list ;
   unsigned char reg_state ;
    klee_make_symbolic(&reg_state, sizeof(char), "reg_state");
   bool dismantle ;
   unsigned short rtnl_link_state ;
    klee_make_symbolic(&rtnl_link_state, sizeof(short), "rtnl_link_state");
   void (*destructor)(struct net_device * ) ;
   struct netpoll_info *npinfo ;
   possible_net_t nd_net ;
   union __anonunion____missing_field_name_317 __annonCompField94 ;
   struct garp_port *garp_port ;
   struct mrp_port *mrp_port ;
   struct device dev ;
   struct attribute_group  const  *sysfs_groups[4U] ;
   struct attribute_group  const  *sysfs_rx_queue_group ;
   struct rtnl_link_ops  const  *rtnl_link_ops ;
   unsigned int gso_max_size ;
    klee_make_symbolic(&gso_max_size, sizeof(int), "gso_max_size");
   u16 gso_max_segs ;
   u16 gso_min_segs ;
   struct dcbnl_rtnl_ops  const  *dcbnl_ops ;
   u8 num_tc ;
   struct netdev_tc_txq tc_to_txq[16U] ;
   u8 prio_tc_map[16U] ;
   unsigned int fcoe_ddp_xid ;
    klee_make_symbolic(&fcoe_ddp_xid, sizeof(int), "fcoe_ddp_xid");
   struct netprio_map *priomap ;
   struct phy_device *phydev ;
   struct lock_class_key *qdisc_tx_busylock ;
};
struct packet_type {
   __be16 type ;
   struct net_device *dev ;
   int (*func)(struct sk_buff * , struct net_device * , struct packet_type * , struct net_device * ) ;
   bool (*id_match)(struct packet_type * , struct sock * ) ;
   void *af_packet_priv ;
   struct list_head list ;
};
struct pcpu_sw_netstats {
   u64 rx_packets ;
   u64 rx_bytes ;
   u64 tx_packets ;
   u64 tx_bytes ;
   struct u64_stats_sync syncp ;
};
struct ieee80211_hdr {
   __le16 frame_control ;
   __le16 duration_id ;
   u8 addr1[6U] ;
   u8 addr2[6U] ;
   u8 addr3[6U] ;
   __le16 seq_ctrl ;
   u8 addr4[6U] ;
};
struct ieee80211_msrment_ie {
   u8 token ;
   u8 mode ;
   u8 type ;
   u8 request[0U] ;
};
struct ieee80211_ext_chansw_ie {
   u8 mode ;
   u8 new_operating_class ;
   u8 new_ch_num ;
   u8 count ;
};
struct ieee80211_tpc_report_ie {
   u8 tx_power ;
   u8 link_margin ;
};
struct __anonstruct_auth_327 {
   __le16 auth_alg ;
   __le16 auth_transaction ;
   __le16 status_code ;
   u8 variable[0U] ;
};
struct __anonstruct_deauth_328 {
   __le16 reason_code ;
};
struct __anonstruct_assoc_req_329 {
   __le16 capab_info ;
   __le16 listen_interval ;
   u8 variable[0U] ;
};
struct __anonstruct_assoc_resp_330 {
   __le16 capab_info ;
   __le16 status_code ;
   __le16 aid ;
   u8 variable[0U] ;
};
struct __anonstruct_reassoc_resp_331 {
   __le16 capab_info ;
   __le16 status_code ;
   __le16 aid ;
   u8 variable[0U] ;
};
struct __anonstruct_reassoc_req_332 {
   __le16 capab_info ;
   __le16 listen_interval ;
   u8 current_ap[6U] ;
   u8 variable[0U] ;
};
struct __anonstruct_disassoc_333 {
   __le16 reason_code ;
};
struct __anonstruct_beacon_334 {
   __le64 timestamp ;
   __le16 beacon_int ;
   __le16 capab_info ;
   u8 variable[0U] ;
};
struct __anonstruct_probe_req_335 {
   u8 variable[0U] ;
};
struct __anonstruct_probe_resp_336 {
   __le64 timestamp ;
   __le16 beacon_int ;
   __le16 capab_info ;
   u8 variable[0U] ;
};
struct __anonstruct_wme_action_339 {
   u8 action_code ;
   u8 dialog_token ;
   u8 status_code ;
   u8 variable[0U] ;
};
struct __anonstruct_chan_switch_340 {
   u8 action_code ;
   u8 variable[0U] ;
};
struct __anonstruct_ext_chan_switch_341 {
   u8 action_code ;
   struct ieee80211_ext_chansw_ie data ;
   u8 variable[0U] ;
};
struct __anonstruct_measurement_342 {
   u8 action_code ;
   u8 dialog_token ;
   u8 element_id ;
   u8 length ;
   struct ieee80211_msrment_ie msr_elem ;
};
struct __anonstruct_addba_req_343 {
   u8 action_code ;
   u8 dialog_token ;
   __le16 capab ;
   __le16 timeout ;
   __le16 start_seq_num ;
};
struct __anonstruct_addba_resp_344 {
   u8 action_code ;
   u8 dialog_token ;
   __le16 status ;
   __le16 capab ;
   __le16 timeout ;
};
struct __anonstruct_delba_345 {
   u8 action_code ;
   __le16 params ;
   __le16 reason_code ;
};
struct __anonstruct_self_prot_346 {
   u8 action_code ;
   u8 variable[0U] ;
};
struct __anonstruct_mesh_action_347 {
   u8 action_code ;
   u8 variable[0U] ;
};
struct __anonstruct_sa_query_348 {
   u8 action ;
   u8 trans_id[2U] ;
};
struct __anonstruct_ht_smps_349 {
   u8 action ;
   u8 smps_control ;
};
struct __anonstruct_ht_notify_cw_350 {
   u8 action_code ;
   u8 chanwidth ;
};
struct __anonstruct_tdls_discover_resp_351 {
   u8 action_code ;
   u8 dialog_token ;
   __le16 capability ;
   u8 variable[0U] ;
};
struct __anonstruct_vht_opmode_notif_352 {
   u8 action_code ;
   u8 operating_mode ;
};
struct __anonstruct_tpc_report_353 {
   u8 action_code ;
   u8 dialog_token ;
   u8 tpc_elem_id ;
   u8 tpc_elem_length ;
   struct ieee80211_tpc_report_ie tpc ;
};
union __anonunion_u_338 {
   struct __anonstruct_wme_action_339 wme_action ;
   struct __anonstruct_chan_switch_340 chan_switch ;
   struct __anonstruct_ext_chan_switch_341 ext_chan_switch ;
   struct __anonstruct_measurement_342 measurement ;
   struct __anonstruct_addba_req_343 addba_req ;
   struct __anonstruct_addba_resp_344 addba_resp ;
   struct __anonstruct_delba_345 delba ;
   struct __anonstruct_self_prot_346 self_prot ;
   struct __anonstruct_mesh_action_347 mesh_action ;
   struct __anonstruct_sa_query_348 sa_query ;
   struct __anonstruct_ht_smps_349 ht_smps ;
   struct __anonstruct_ht_notify_cw_350 ht_notify_cw ;
   struct __anonstruct_tdls_discover_resp_351 tdls_discover_resp ;
   struct __anonstruct_vht_opmode_notif_352 vht_opmode_notif ;
   struct __anonstruct_tpc_report_353 tpc_report ;
};
struct __anonstruct_action_337 {
   u8 category ;
   union __anonunion_u_338 u ;
};
union __anonunion_u_326 {
   struct __anonstruct_auth_327 auth ;
   struct __anonstruct_deauth_328 deauth ;
   struct __anonstruct_assoc_req_329 assoc_req ;
   struct __anonstruct_assoc_resp_330 assoc_resp ;
   struct __anonstruct_reassoc_resp_331 reassoc_resp ;
   struct __anonstruct_reassoc_req_332 reassoc_req ;
   struct __anonstruct_disassoc_333 disassoc ;
   struct __anonstruct_beacon_334 beacon ;
   struct __anonstruct_probe_req_335 probe_req ;
   struct __anonstruct_probe_resp_336 probe_resp ;
   struct __anonstruct_action_337 action ;
};
struct ieee80211_mgmt {
   __le16 frame_control ;
   __le16 duration ;
   u8 da[6U] ;
   u8 sa[6U] ;
   u8 bssid[6U] ;
   __le16 seq_ctrl ;
   union __anonunion_u_326 u ;
};
struct ieee80211_p2p_noa_desc {
   u8 count ;
   __le32 duration ;
   __le32 interval ;
   __le32 start_time ;
};
struct ieee80211_p2p_noa_attr {
   u8 index ;
   u8 oppps_ctwindow ;
   struct ieee80211_p2p_noa_desc desc[4U] ;
};
struct ieee80211_mcs_info {
   u8 rx_mask[10U] ;
   __le16 rx_highest ;
   u8 tx_params ;
   u8 reserved[3U] ;
};
struct ieee80211_ht_cap {
   __le16 cap_info ;
   u8 ampdu_params_info ;
   struct ieee80211_mcs_info mcs ;
   __le16 extended_ht_cap_info ;
   __le32 tx_BF_cap_info ;
   u8 antenna_selection_info ;
};
struct ieee80211_vht_mcs_info {
   __le16 rx_mcs_map ;
   __le16 rx_highest ;
   __le16 tx_mcs_map ;
   __le16 tx_highest ;
};
struct ieee80211_vht_cap {
   __le32 vht_cap_info ;
   struct ieee80211_vht_mcs_info supp_mcs ;
};
enum nl80211_iftype {
    NL80211_IFTYPE_UNSPECIFIED = 0,
    NL80211_IFTYPE_ADHOC = 1,
    NL80211_IFTYPE_STATION = 2,
    NL80211_IFTYPE_AP = 3,
    NL80211_IFTYPE_AP_VLAN = 4,
    NL80211_IFTYPE_WDS = 5,
    NL80211_IFTYPE_MONITOR = 6,
    NL80211_IFTYPE_MESH_POINT = 7,
    NL80211_IFTYPE_P2P_CLIENT = 8,
    NL80211_IFTYPE_P2P_GO = 9,
    NL80211_IFTYPE_P2P_DEVICE = 10,
    NL80211_IFTYPE_OCB = 11,
    NUM_NL80211_IFTYPES = 12,
    NL80211_IFTYPE_MAX = 11
} ;
enum nl80211_reg_initiator {
    NL80211_REGDOM_SET_BY_CORE = 0,
    NL80211_REGDOM_SET_BY_USER = 1,
    NL80211_REGDOM_SET_BY_DRIVER = 2,
    NL80211_REGDOM_SET_BY_COUNTRY_IE = 3
} ;
enum nl80211_dfs_regions {
    NL80211_DFS_UNSET = 0,
    NL80211_DFS_FCC = 1,
    NL80211_DFS_ETSI = 2,
    NL80211_DFS_JP = 3
} ;
enum nl80211_user_reg_hint_type {
    NL80211_USER_REG_HINT_USER = 0,
    NL80211_USER_REG_HINT_CELL_BASE = 1,
    NL80211_USER_REG_HINT_INDOOR = 2
} ;
enum nl80211_chan_width {
    NL80211_CHAN_WIDTH_20_NOHT = 0,
    NL80211_CHAN_WIDTH_20 = 1,
    NL80211_CHAN_WIDTH_40 = 2,
    NL80211_CHAN_WIDTH_80 = 3,
    NL80211_CHAN_WIDTH_80P80 = 4,
    NL80211_CHAN_WIDTH_160 = 5,
    NL80211_CHAN_WIDTH_5 = 6,
    NL80211_CHAN_WIDTH_10 = 7
} ;
enum nl80211_bss_scan_width {
    NL80211_BSS_CHAN_WIDTH_20 = 0,
    NL80211_BSS_CHAN_WIDTH_10 = 1,
    NL80211_BSS_CHAN_WIDTH_5 = 2
} ;
enum nl80211_auth_type {
    NL80211_AUTHTYPE_OPEN_SYSTEM = 0,
    NL80211_AUTHTYPE_SHARED_KEY = 1,
    NL80211_AUTHTYPE_FT = 2,
    NL80211_AUTHTYPE_NETWORK_EAP = 3,
    NL80211_AUTHTYPE_SAE = 4,
    __NL80211_AUTHTYPE_NUM = 5,
    NL80211_AUTHTYPE_MAX = 4,
    NL80211_AUTHTYPE_AUTOMATIC = 5
} ;
enum nl80211_mfp {
    NL80211_MFP_NO = 0,
    NL80211_MFP_REQUIRED = 1
} ;
enum nl80211_tx_power_setting {
    NL80211_TX_POWER_AUTOMATIC = 0,
    NL80211_TX_POWER_LIMITED = 1,
    NL80211_TX_POWER_FIXED = 2
} ;
struct nl80211_wowlan_tcp_data_seq {
   __u32 start ;
   __u32 offset ;
   __u32 len ;
};
struct nl80211_wowlan_tcp_data_token {
   __u32 offset ;
   __u32 len ;
   __u8 token_stream[] ;
};
struct nl80211_wowlan_tcp_data_token_feature {
   __u32 min_len ;
   __u32 max_len ;
   __u32 bufsize ;
};
enum nl80211_dfs_state {
    NL80211_DFS_USABLE = 0,
    NL80211_DFS_UNAVAILABLE = 1,
    NL80211_DFS_AVAILABLE = 2
} ;
struct nl80211_vendor_cmd_info {
   __u32 vendor_id ;
   __u32 subcmd ;
};
enum environment_cap {
    ENVIRON_ANY = 0,
    ENVIRON_INDOOR = 1,
    ENVIRON_OUTDOOR = 2
} ;
struct regulatory_request {
   struct callback_head callback_head ;
   int wiphy_idx ;
    klee_make_symbolic(&wiphy_idx, sizeof(int), "wiphy_idx");
   enum nl80211_reg_initiator initiator ;
   enum nl80211_user_reg_hint_type user_reg_hint_type ;
   char alpha2[2U] ;
   enum nl80211_dfs_regions dfs_region ;
   bool intersect ;
   bool processed ;
   enum environment_cap country_ie_env ;
   struct list_head list ;
};
struct ieee80211_freq_range {
   u32 start_freq_khz ;
   u32 end_freq_khz ;
   u32 max_bandwidth_khz ;
};
struct ieee80211_power_rule {
   u32 max_antenna_gain ;
   u32 max_eirp ;
};
struct ieee80211_reg_rule {
   struct ieee80211_freq_range freq_range ;
   struct ieee80211_power_rule power_rule ;
   u32 flags ;
   u32 dfs_cac_ms ;
};
struct ieee80211_regdomain {
   struct callback_head callback_head ;
   u32 n_reg_rules ;
   char alpha2[3U] ;
   enum nl80211_dfs_regions dfs_region ;
   struct ieee80211_reg_rule reg_rules[] ;
};
struct wiphy;
enum ieee80211_band {
    IEEE80211_BAND_2GHZ = 0,
    IEEE80211_BAND_5GHZ = 1,
    IEEE80211_BAND_60GHZ = 2,
    IEEE80211_NUM_BANDS = 3
} ;
struct ieee80211_channel {
   enum ieee80211_band band ;
   u16 center_freq ;
   u16 hw_value ;
   u32 flags ;
   int max_antenna_gain ;
    klee_make_symbolic(&max_antenna_gain, sizeof(int), "max_antenna_gain");
   int max_power ;
    klee_make_symbolic(&max_power, sizeof(int), "max_power");
   int max_reg_power ;
    klee_make_symbolic(&max_reg_power, sizeof(int), "max_reg_power");
   bool beacon_found ;
   u32 orig_flags ;
   int orig_mag ;
    klee_make_symbolic(&orig_mag, sizeof(int), "orig_mag");
   int orig_mpwr ;
    klee_make_symbolic(&orig_mpwr, sizeof(int), "orig_mpwr");
   enum nl80211_dfs_state dfs_state ;
   unsigned long dfs_state_entered ;
    klee_make_symbolic(&dfs_state_entered, sizeof(long), "dfs_state_entered");
   unsigned int dfs_cac_ms ;
    klee_make_symbolic(&dfs_cac_ms, sizeof(int), "dfs_cac_ms");
};
struct ieee80211_rate {
   u32 flags ;
   u16 bitrate ;
   u16 hw_value ;
   u16 hw_value_short ;
};
struct ieee80211_sta_ht_cap {
   u16 cap ;
   bool ht_supported ;
   u8 ampdu_factor ;
   u8 ampdu_density ;
   struct ieee80211_mcs_info mcs ;
};
struct ieee80211_sta_vht_cap {
   bool vht_supported ;
   u32 cap ;
   struct ieee80211_vht_mcs_info vht_mcs ;
};
struct ieee80211_supported_band {
   struct ieee80211_channel *channels ;
   struct ieee80211_rate *bitrates ;
   enum ieee80211_band band ;
   int n_channels ;
    klee_make_symbolic(&n_channels, sizeof(int), "n_channels");
   int n_bitrates ;
    klee_make_symbolic(&n_bitrates, sizeof(int), "n_bitrates");
   struct ieee80211_sta_ht_cap ht_cap ;
   struct ieee80211_sta_vht_cap vht_cap ;
};
struct cfg80211_chan_def {
   struct ieee80211_channel *chan ;
   enum nl80211_chan_width width ;
   u32 center_freq1 ;
   u32 center_freq2 ;
};
struct cfg80211_crypto_settings {
   u32 wpa_versions ;
   u32 cipher_group ;
   int n_ciphers_pairwise ;
    klee_make_symbolic(&n_ciphers_pairwise, sizeof(int), "n_ciphers_pairwise");
   u32 ciphers_pairwise[5U] ;
   int n_akm_suites ;
    klee_make_symbolic(&n_akm_suites, sizeof(int), "n_akm_suites");
   u32 akm_suites[2U] ;
   bool control_port ;
   __be16 control_port_ethertype ;
   bool control_port_no_encrypt ;
};
struct mac_address {
   u8 addr[6U] ;
};
struct cfg80211_ssid {
   u8 ssid[32U] ;
   u8 ssid_len ;
};
struct cfg80211_scan_request {
   struct cfg80211_ssid *ssids ;
   int n_ssids ;
    klee_make_symbolic(&n_ssids, sizeof(int), "n_ssids");
   u32 n_channels ;
   enum nl80211_bss_scan_width scan_width ;
   u8 const   *ie ;
   size_t ie_len ;
   u32 flags ;
   u32 rates[3U] ;
   struct wireless_dev *wdev ;
   u8 mac_addr[6U] ;
   u8 mac_addr_mask[6U] ;
   struct wiphy *wiphy ;
   unsigned long scan_start ;
    klee_make_symbolic(&scan_start, sizeof(long), "scan_start");
   bool aborted ;
   bool notified ;
   bool no_cck ;
   struct ieee80211_channel *channels[0U] ;
};
struct cfg80211_match_set {
   struct cfg80211_ssid ssid ;
   s32 rssi_thold ;
};
struct cfg80211_sched_scan_request {
   struct cfg80211_ssid *ssids ;
   int n_ssids ;
   u32 n_channels ;
   enum nl80211_bss_scan_width scan_width ;
   u32 interval ;
   u8 const   *ie ;
   size_t ie_len ;
   u32 flags ;
   struct cfg80211_match_set *match_sets ;
   int n_match_sets ;
    klee_make_symbolic(&n_match_sets, sizeof(int), "n_match_sets");
   s32 min_rssi_thold ;
   u32 delay ;
   u8 mac_addr[6U] ;
   u8 mac_addr_mask[6U] ;
   struct wiphy *wiphy ;
   struct net_device *dev ;
   unsigned long scan_start ;
   struct callback_head callback_head ;
   u32 owner_nlportid ;
   struct ieee80211_channel *channels[0U] ;
};
enum cfg80211_signal_type {
    CFG80211_SIGNAL_TYPE_NONE = 0,
    CFG80211_SIGNAL_TYPE_MBM = 1,
    CFG80211_SIGNAL_TYPE_UNSPEC = 2
} ;
struct cfg80211_ibss_params {
   u8 const   *ssid ;
   u8 const   *bssid ;
   struct cfg80211_chan_def chandef ;
   u8 const   *ie ;
   u8 ssid_len ;
   u8 ie_len ;
   u16 beacon_interval ;
   u32 basic_rates ;
   bool channel_fixed ;
   bool privacy ;
   bool control_port ;
   bool userspace_handles_dfs ;
   int mcast_rate[3U] ;
   struct ieee80211_ht_cap ht_capa ;
   struct ieee80211_ht_cap ht_capa_mask ;
};
struct cfg80211_connect_params {
   struct ieee80211_channel *channel ;
   struct ieee80211_channel *channel_hint ;
   u8 const   *bssid ;
   u8 const   *bssid_hint ;
   u8 const   *ssid ;
   size_t ssid_len ;
   enum nl80211_auth_type auth_type ;
   u8 const   *ie ;
   size_t ie_len ;
   bool privacy ;
   enum nl80211_mfp mfp ;
   struct cfg80211_crypto_settings crypto ;
   u8 const   *key ;
   u8 key_len ;
   u8 key_idx ;
   u32 flags ;
   int bg_scan_period ;
    klee_make_symbolic(&bg_scan_period, sizeof(int), "bg_scan_period");
   struct ieee80211_ht_cap ht_capa ;
   struct ieee80211_ht_cap ht_capa_mask ;
   struct ieee80211_vht_cap vht_capa ;
   struct ieee80211_vht_cap vht_capa_mask ;
};
struct cfg80211_pkt_pattern {
   u8 const   *mask ;
   u8 const   *pattern ;
   int pattern_len ;
    klee_make_symbolic(&pattern_len, sizeof(int), "pattern_len");
   int pkt_offset ;
    klee_make_symbolic(&pkt_offset, sizeof(int), "pkt_offset");
};
struct cfg80211_wowlan_tcp {
   struct socket *sock ;
   __be32 src ;
   __be32 dst ;
   u16 src_port ;
   u16 dst_port ;
   u8 dst_mac[6U] ;
   int payload_len ;
    klee_make_symbolic(&payload_len, sizeof(int), "payload_len");
   u8 const   *payload ;
   struct nl80211_wowlan_tcp_data_seq payload_seq ;
   u32 data_interval ;
   u32 wake_len ;
   u8 const   *wake_data ;
   u8 const   *wake_mask ;
   u32 tokens_size ;
   struct nl80211_wowlan_tcp_data_token payload_tok ;
};
struct cfg80211_wowlan {
   bool any ;
   bool disconnect ;
   bool magic_pkt ;
   bool gtk_rekey_failure ;
   bool eap_identity_req ;
   bool four_way_handshake ;
   bool rfkill_release ;
   struct cfg80211_pkt_pattern *patterns ;
   struct cfg80211_wowlan_tcp *tcp ;
   int n_patterns ;
    klee_make_symbolic(&n_patterns, sizeof(int), "n_patterns");
   struct cfg80211_sched_scan_request *nd_config ;
};
struct ieee80211_iface_limit {
   u16 max ;
   u16 types ;
};
struct ieee80211_iface_combination {
   struct ieee80211_iface_limit  const  *limits ;
   u32 num_different_channels ;
   u16 max_interfaces ;
   u8 n_limits ;
   bool beacon_int_infra_match ;
   u8 radar_detect_widths ;
   u8 radar_detect_regions ;
};
struct ieee80211_txrx_stypes {
   u16 tx ;
   u16 rx ;
};
struct wiphy_wowlan_tcp_support {
   struct nl80211_wowlan_tcp_data_token_feature  const  *tok ;
   u32 data_payload_max ;
   u32 data_interval_max ;
   u32 wake_payload_max ;
   bool seq ;
};
struct wiphy_wowlan_support {
   u32 flags ;
   int n_patterns ;
   int pattern_max_len ;
    klee_make_symbolic(&pattern_max_len, sizeof(int), "pattern_max_len");
   int pattern_min_len ;
    klee_make_symbolic(&pattern_min_len, sizeof(int), "pattern_min_len");
   int max_pkt_offset ;
    klee_make_symbolic(&max_pkt_offset, sizeof(int), "max_pkt_offset");
   int max_nd_match_sets ;
    klee_make_symbolic(&max_nd_match_sets, sizeof(int), "max_nd_match_sets");
   struct wiphy_wowlan_tcp_support  const  *tcp ;
};
struct wiphy_coalesce_support {
   int n_rules ;
    klee_make_symbolic(&n_rules, sizeof(int), "n_rules");
   int max_delay ;
    klee_make_symbolic(&max_delay, sizeof(int), "max_delay");
   int n_patterns ;
   int pattern_max_len ;
   int pattern_min_len ;
   int max_pkt_offset ;
};
struct wiphy_vendor_command {
   struct nl80211_vendor_cmd_info info ;
   u32 flags ;
   int (*doit)(struct wiphy * , struct wireless_dev * , void const   * , int  ) ;
};
struct wiphy {
   u8 perm_addr[6U] ;
   u8 addr_mask[6U] ;
   struct mac_address *addresses ;
   struct ieee80211_txrx_stypes  const  *mgmt_stypes ;
   struct ieee80211_iface_combination  const  *iface_combinations ;
   int n_iface_combinations ;
    klee_make_symbolic(&n_iface_combinations, sizeof(int), "n_iface_combinations");
   u16 software_iftypes ;
   u16 n_addresses ;
   u16 interface_modes ;
   u16 max_acl_mac_addrs ;
   u32 flags ;
   u32 regulatory_flags ;
   u32 features ;
   u8 ext_features[1U] ;
   u32 ap_sme_capa ;
   enum cfg80211_signal_type signal_type ;
   int bss_priv_size ;
    klee_make_symbolic(&bss_priv_size, sizeof(int), "bss_priv_size");
   u8 max_scan_ssids ;
   u8 max_sched_scan_ssids ;
   u8 max_match_sets ;
   u16 max_scan_ie_len ;
   u16 max_sched_scan_ie_len ;
   int n_cipher_suites ;
    klee_make_symbolic(&n_cipher_suites, sizeof(int), "n_cipher_suites");
   u32 const   *cipher_suites ;
   u8 retry_short ;
   u8 retry_long ;
   u32 frag_threshold ;
   u32 rts_threshold ;
   u8 coverage_class ;
   char fw_version[32U] ;
   u32 hw_version ;
   struct wiphy_wowlan_support  const  *wowlan ;
   struct cfg80211_wowlan *wowlan_config ;
   u16 max_remain_on_channel_duration ;
   u8 max_num_pmkids ;
   u32 available_antennas_tx ;
   u32 available_antennas_rx ;
   u32 probe_resp_offload ;
   u8 const   *extended_capabilities ;
   u8 const   *extended_capabilities_mask ;
   u8 extended_capabilities_len ;
   void const   *privid ;
   struct ieee80211_supported_band *bands[3U] ;
   void (*reg_notifier)(struct wiphy * , struct regulatory_request * ) ;
   struct ieee80211_regdomain  const  *regd ;
   struct device dev ;
   bool registered ;
   struct dentry *debugfsdir ;
   struct ieee80211_ht_cap  const  *ht_capa_mod_mask ;
   struct ieee80211_vht_cap  const  *vht_capa_mod_mask ;
   possible_net_t _net ;
   struct iw_handler_def  const  *wext ;
   struct wiphy_coalesce_support  const  *coalesce ;
   struct wiphy_vendor_command  const  *vendor_commands ;
   struct nl80211_vendor_cmd_info  const  *vendor_events ;
   int n_vendor_commands ;
    klee_make_symbolic(&n_vendor_commands, sizeof(int), "n_vendor_commands");
   int n_vendor_events ;
    klee_make_symbolic(&n_vendor_events, sizeof(int), "n_vendor_events");
   u16 max_ap_assoc_sta ;
   u8 max_num_csa_counters ;
   u8 max_adj_channel_rssi_comp ;
   char priv[0U] ;
};
struct cfg80211_conn;
struct cfg80211_internal_bss;
struct cfg80211_cached_keys;
struct __anonstruct_wext_366 {
   struct cfg80211_ibss_params ibss ;
   struct cfg80211_connect_params connect ;
   struct cfg80211_cached_keys *keys ;
   u8 const   *ie ;
   size_t ie_len ;
   u8 bssid[6U] ;
   u8 prev_bssid[6U] ;
   u8 ssid[32U] ;
   s8 default_key ;
   s8 default_mgmt_key ;
   bool prev_bssid_valid ;
};
struct wireless_dev {
   struct wiphy *wiphy ;
   enum nl80211_iftype iftype ;
   struct list_head list ;
   struct net_device *netdev ;
   u32 identifier ;
   struct list_head mgmt_registrations ;
   spinlock_t mgmt_registrations_lock ;
   struct mutex mtx ;
   bool use_4addr ;
   bool p2p_started ;
   u8 address[6U] ;
   u8 ssid[32U] ;
   u8 ssid_len ;
   u8 mesh_id_len ;
   u8 mesh_id_up_len ;
   struct cfg80211_conn *conn ;
   struct cfg80211_cached_keys *connect_keys ;
   struct list_head event_list ;
   spinlock_t event_lock ;
   struct cfg80211_internal_bss *current_bss ;
   struct cfg80211_chan_def preset_chandef ;
   struct cfg80211_chan_def chandef ;
   bool ibss_fixed ;
   bool ibss_dfs_possible ;
   bool ps ;
   int ps_timeout ;
    klee_make_symbolic(&ps_timeout, sizeof(int), "ps_timeout");
   int beacon_interval ;
    klee_make_symbolic(&beacon_interval, sizeof(int), "beacon_interval");
   u32 ap_unexpected_nlportid ;
   bool cac_started ;
   unsigned long cac_start_time ;
    klee_make_symbolic(&cac_start_time, sizeof(long), "cac_start_time");
   unsigned int cac_time_ms ;
    klee_make_symbolic(&cac_time_ms, sizeof(int), "cac_time_ms");
   u32 owner_nlportid ;
   struct __anonstruct_wext_366 wext ;
};
struct ieee80211_chanctx_conf {
   struct cfg80211_chan_def def ;
   struct cfg80211_chan_def min_def ;
   u8 rx_chains_static ;
   u8 rx_chains_dynamic ;
   bool radar_enabled ;
   u8 drv_priv[0U] ;
};
struct ieee80211_vif;
struct ieee80211_bss_conf {
   u8 const   *bssid ;
   bool assoc ;
   bool ibss_joined ;
   bool ibss_creator ;
   u16 aid ;
   bool use_cts_prot ;
   bool use_short_preamble ;
   bool use_short_slot ;
   bool enable_beacon ;
   u8 dtim_period ;
   u16 beacon_int ;
   u16 assoc_capability ;
   u64 sync_tsf ;
   u32 sync_device_ts ;
   u8 sync_dtim_count ;
   u32 basic_rates ;
   struct ieee80211_rate *beacon_rate ;
   int mcast_rate[3U] ;
   u16 ht_operation_mode ;
   s32 cqm_rssi_thold ;
   u32 cqm_rssi_hyst ;
   struct cfg80211_chan_def chandef ;
   __be32 arp_addr_list[4U] ;
   int arp_addr_cnt ;
    klee_make_symbolic(&arp_addr_cnt, sizeof(int), "arp_addr_cnt");
   bool qos ;
   bool idle ;
   bool ps ;
   u8 ssid[32U] ;
   size_t ssid_len ;
   bool hidden_ssid ;
   int txpower ;
    klee_make_symbolic(&txpower, sizeof(int), "txpower");
   enum nl80211_tx_power_setting txpower_type ;
   struct ieee80211_p2p_noa_attr p2p_noa_attr ;
};
struct ieee80211_tx_rate {
   s8 idx ;
   unsigned char count : 5 ;
   unsigned short flags : 11 ;
};
struct __anonstruct____missing_field_name_371 {
   struct ieee80211_tx_rate rates[4U] ;
   s8 rts_cts_rate_idx ;
   unsigned char use_rts : 1 ;
   unsigned char use_cts_prot : 1 ;
   unsigned char short_preamble : 1 ;
   unsigned char skip_table : 1 ;
};
union __anonunion____missing_field_name_370 {
   struct __anonstruct____missing_field_name_371 __annonCompField96 ;
   unsigned long jiffies ;
    klee_make_symbolic(&jiffies, sizeof(long), "jiffies");
};
struct ieee80211_key_conf;
struct __anonstruct_control_369 {
   union __anonunion____missing_field_name_370 __annonCompField97 ;
   struct ieee80211_vif *vif ;
   struct ieee80211_key_conf *hw_key ;
   u32 flags ;
};
struct __anonstruct_ack_372 {
   u64 cookie ;
};
struct __anonstruct_status_373 {
   struct ieee80211_tx_rate rates[4U] ;
   s32 ack_signal ;
   u8 ampdu_ack_len ;
   u8 ampdu_len ;
   u8 antenna ;
   u16 tx_time ;
   void *status_driver_data[2U] ;
};
struct __anonstruct____missing_field_name_374 {
   struct ieee80211_tx_rate driver_rates[4U] ;
   u8 pad[4U] ;
   void *rate_driver_data[3U] ;
};
union __anonunion____missing_field_name_368 {
   struct __anonstruct_control_369 control ;
   struct __anonstruct_ack_372 ack ;
   struct __anonstruct_status_373 status ;
   struct __anonstruct____missing_field_name_374 __annonCompField98 ;
   void *driver_data[5U] ;
};
struct ieee80211_tx_info {
   u32 flags ;
   u8 band ;
   u8 hw_queue ;
   u16 ack_frame_id ;
   union __anonunion____missing_field_name_368 __annonCompField99 ;
};
enum ieee80211_smps_mode {
    IEEE80211_SMPS_AUTOMATIC = 0,
    IEEE80211_SMPS_OFF = 1,
    IEEE80211_SMPS_STATIC = 2,
    IEEE80211_SMPS_DYNAMIC = 3,
    IEEE80211_SMPS_NUM_MODES = 4
} ;
struct ieee80211_conf {
   u32 flags ;
   int power_level ;
    klee_make_symbolic(&power_level, sizeof(int), "power_level");
   int dynamic_ps_timeout ;
    klee_make_symbolic(&dynamic_ps_timeout, sizeof(int), "dynamic_ps_timeout");
   int max_sleep_period ;
    klee_make_symbolic(&max_sleep_period, sizeof(int), "max_sleep_period");
   u16 listen_interval ;
   u8 ps_dtim_period ;
   u8 long_frame_max_tx_count ;
   u8 short_frame_max_tx_count ;
   struct cfg80211_chan_def chandef ;
   bool radar_enabled ;
   enum ieee80211_smps_mode smps_mode ;
};
struct ieee80211_channel_switch {
   u64 timestamp ;
   u32 device_timestamp ;
   bool block_tx ;
   struct cfg80211_chan_def chandef ;
   u8 count ;
};
struct ieee80211_txq;
struct ieee80211_vif {
   enum nl80211_iftype type ;
   struct ieee80211_bss_conf bss_conf ;
   u8 addr[6U] ;
   bool p2p ;
   bool csa_active ;
   u8 cab_queue ;
   u8 hw_queue[4U] ;
   struct ieee80211_txq *txq ;
   struct ieee80211_chanctx_conf *chanctx_conf ;
   u32 driver_flags ;
   struct dentry *debugfs_dir ;
   u8 drv_priv[0U] ;
};
struct ieee80211_key_conf {
   atomic64_t tx_pn ;
   u32 cipher ;
   u8 icv_len ;
   u8 iv_len ;
   u8 hw_key_idx ;
   u8 flags ;
   s8 keyidx ;
   u8 keylen ;
   u8 key[0U] ;
};
struct ieee80211_cipher_scheme {
   u32 cipher ;
   u16 iftype ;
   u8 hdr_len ;
   u8 pn_len ;
   u8 pn_off ;
   u8 key_idx_off ;
   u8 key_idx_mask ;
   u8 key_idx_shift ;
   u8 mic_len ;
};
enum ieee80211_sta_rx_bandwidth {
    IEEE80211_STA_RX_BW_20 = 0,
    IEEE80211_STA_RX_BW_40 = 1,
    IEEE80211_STA_RX_BW_80 = 2,
    IEEE80211_STA_RX_BW_160 = 3
} ;
struct __anonstruct_rate_382 {
   s8 idx ;
   u8 count ;
   u8 count_cts ;
   u8 count_rts ;
   u16 flags ;
};
struct ieee80211_sta_rates {
   struct callback_head callback_head ;
   struct __anonstruct_rate_382 rate[4U] ;
};
struct ieee80211_sta {
   u32 supp_rates[3U] ;
   u8 addr[6U] ;
   u16 aid ;
   struct ieee80211_sta_ht_cap ht_cap ;
   struct ieee80211_sta_vht_cap vht_cap ;
   bool wme ;
   u8 uapsd_queues ;
   u8 max_sp ;
   u8 rx_nss ;
   enum ieee80211_sta_rx_bandwidth bandwidth ;
   enum ieee80211_smps_mode smps_mode ;
   struct ieee80211_sta_rates *rates ;
   bool tdls ;
   bool tdls_initiator ;
   bool mfp ;
   struct ieee80211_txq *txq[16U] ;
   u8 drv_priv[0U] ;
};
struct ieee80211_txq {
   struct ieee80211_vif *vif ;
   struct ieee80211_sta *sta ;
   u8 tid ;
   u8 ac ;
   u8 drv_priv[0U] ;
};
struct ieee80211_hw {
   struct ieee80211_conf conf ;
   struct wiphy *wiphy ;
   char const   *rate_control_algorithm ;
   void *priv ;
   unsigned long flags[1U] ;
   unsigned int extra_tx_headroom ;
    klee_make_symbolic(&extra_tx_headroom, sizeof(int), "extra_tx_headroom");
   unsigned int extra_beacon_tailroom ;
    klee_make_symbolic(&extra_beacon_tailroom, sizeof(int), "extra_beacon_tailroom");
   int vif_data_size ;
    klee_make_symbolic(&vif_data_size, sizeof(int), "vif_data_size");
   int sta_data_size ;
    klee_make_symbolic(&sta_data_size, sizeof(int), "sta_data_size");
   int chanctx_data_size ;
    klee_make_symbolic(&chanctx_data_size, sizeof(int), "chanctx_data_size");
   int txq_data_size ;
    klee_make_symbolic(&txq_data_size, sizeof(int), "txq_data_size");
   u16 queues ;
   u16 max_listen_interval ;
   s8 max_signal ;
   u8 max_rates ;
   u8 max_report_rates ;
   u8 max_rate_tries ;
   u8 max_rx_aggregation_subframes ;
   u8 max_tx_aggregation_subframes ;
   u8 offchannel_tx_hw_queue ;
   u8 radiotap_mcs_details ;
   u16 radiotap_vht_details ;
   netdev_features_t netdev_features ;
   u8 uapsd_queues ;
   u8 uapsd_max_sp_len ;
   u8 n_cipher_schemes ;
   struct ieee80211_cipher_scheme  const  *cipher_schemes ;
   int txq_ac_max_pending ;
    klee_make_symbolic(&txq_ac_max_pending, sizeof(int), "txq_ac_max_pending");
};
struct iwl_mod_params;
struct iwl_mod_params {
   int sw_crypto ;
    klee_make_symbolic(&sw_crypto, sizeof(int), "sw_crypto");
   unsigned int disable_11n ;
    klee_make_symbolic(&disable_11n, sizeof(int), "disable_11n");
   int amsdu_size_8K ;
    klee_make_symbolic(&amsdu_size_8K, sizeof(int), "amsdu_size_8K");
   bool restart_fw ;
   bool bt_coex_active ;
   int led_mode ;
    klee_make_symbolic(&led_mode, sizeof(int), "led_mode");
   bool power_save ;
   int power_level ;
   u32 debug_level ;
   int ant_coupling ;
    klee_make_symbolic(&ant_coupling, sizeof(int), "ant_coupling");
   char *nvm_file ;
   bool uapsd_disable ;
   bool d0i3_disable ;
   bool lar_disable ;
   bool fw_monitor ;
};
enum iwl_device_family {
    IWL_DEVICE_FAMILY_UNDEFINED = 0,
    IWL_DEVICE_FAMILY_1000 = 1,
    IWL_DEVICE_FAMILY_100 = 2,
    IWL_DEVICE_FAMILY_2000 = 3,
    IWL_DEVICE_FAMILY_2030 = 4,
    IWL_DEVICE_FAMILY_105 = 5,
    IWL_DEVICE_FAMILY_135 = 6,
    IWL_DEVICE_FAMILY_5000 = 7,
    IWL_DEVICE_FAMILY_5150 = 8,
    IWL_DEVICE_FAMILY_6000 = 9,
    IWL_DEVICE_FAMILY_6000i = 10,
    IWL_DEVICE_FAMILY_6005 = 11,
    IWL_DEVICE_FAMILY_6030 = 12,
    IWL_DEVICE_FAMILY_6050 = 13,
    IWL_DEVICE_FAMILY_6150 = 14,
    IWL_DEVICE_FAMILY_7000 = 15,
    IWL_DEVICE_FAMILY_8000 = 16
} ;
enum iwl_led_mode {
    IWL_LED_DEFAULT = 0,
    IWL_LED_RF_STATE = 1,
    IWL_LED_BLINK = 2,
    IWL_LED_DISABLE = 3
} ;
struct iwl_base_params {
   int eeprom_size ;
    klee_make_symbolic(&eeprom_size, sizeof(int), "eeprom_size");
   int num_of_queues ;
    klee_make_symbolic(&num_of_queues, sizeof(int), "num_of_queues");
   u32 pll_cfg_val ;
   u16 const   max_ll_items ;
   bool const   shadow_ram_support ;
   u16 led_compensation ;
   unsigned int wd_timeout ;
    klee_make_symbolic(&wd_timeout, sizeof(int), "wd_timeout");
   u32 max_event_log_size ;
   bool const   shadow_reg_enable ;
   bool const   pcie_l1_allowed ;
   bool const   apmg_wake_up_wa ;
   bool const   scd_chain_ext_wa ;
};
struct iwl_ht_params {
   enum ieee80211_smps_mode smps_mode ;
   bool const   ht_greenfield_support ;
   bool const   stbc ;
   bool const   ldpc ;
   bool use_rts_for_aggregation ;
   u8 ht40_bands ;
};
struct iwl_tt_tx_backoff {
   s32 temperature ;
   u32 backoff ;
};
struct iwl_tt_params {
   s32 ct_kill_entry ;
   s32 ct_kill_exit ;
   u32 ct_kill_duration ;
   s32 dynamic_smps_entry ;
   s32 dynamic_smps_exit ;
   s32 tx_protection_entry ;
   s32 tx_protection_exit ;
   struct iwl_tt_tx_backoff tx_backoff[6U] ;
   bool support_ct_kill ;
   bool support_dynamic_smps ;
   bool support_tx_protection ;
   bool support_tx_backoff ;
};
struct iwl_eeprom_params {
   u8 const   regulatory_bands[7U] ;
   bool enhanced_txpower ;
};
struct iwl_pwr_tx_backoff {
   u32 pwr ;
   u32 backoff ;
};
struct iwl_cfg {
   char const   *name ;
   char const   *fw_name_pre ;
   unsigned int const   ucode_api_max ;
   unsigned int const   ucode_api_ok ;
   unsigned int const   ucode_api_min ;
   enum iwl_device_family  const  device_family ;
   u32 const   max_data_size ;
   u32 const   max_inst_size ;
   u8 valid_tx_ant ;
   u8 valid_rx_ant ;
   u8 non_shared_ant ;
   bool bt_shared_single_ant ;
   u16 nvm_ver ;
   u16 nvm_calib_ver ;
   struct iwl_base_params  const  *base_params ;
   struct iwl_ht_params  const  *ht_params ;
   struct iwl_eeprom_params  const  *eeprom_params ;
   enum iwl_led_mode led_mode ;
   bool const   rx_with_siso_diversity ;
   bool const   internal_wimax_coex ;
   bool const   host_interrupt_operation_mode ;
   bool high_temp ;
   bool d0i3 ;
   u8 nvm_hw_section_num ;
   bool lp_xtal_workaround ;
   struct iwl_pwr_tx_backoff  const  *pwr_tx_backoffs ;
   bool no_power_up_nic_in_init ;
   char const   *default_nvm_file_B_step ;
   char const   *default_nvm_file_C_step ;
   unsigned int max_rx_agg_size ;
    klee_make_symbolic(&max_rx_agg_size, sizeof(int), "max_rx_agg_size");
   bool disable_dummy_notification ;
   unsigned int max_tx_agg_size ;
    klee_make_symbolic(&max_tx_agg_size, sizeof(int), "max_tx_agg_size");
   unsigned int max_ht_ampdu_exponent ;
    klee_make_symbolic(&max_ht_ampdu_exponent, sizeof(int), "max_ht_ampdu_exponent");
   unsigned int max_vht_ampdu_exponent ;
    klee_make_symbolic(&max_vht_ampdu_exponent, sizeof(int), "max_vht_ampdu_exponent");
   u32 const   dccm_offset ;
   u32 const   dccm_len ;
   u32 const   dccm2_offset ;
   u32 const   dccm2_len ;
   u32 const   smem_offset ;
   u32 const   smem_len ;
   struct iwl_tt_params  const  *thermal_params ;
   bool apmg_not_supported ;
};
struct iwl_tlv_calib_ctrl {
   __le32 flow_trigger ;
   __le32 event_trigger ;
};
struct iwl_fw_dbg_reg_op {
   u8 op ;
   u8 reserved[3U] ;
   __le32 addr ;
   __le32 val ;
};
struct iwl_fw_dbg_dest_tlv {
   u8 version ;
   u8 monitor_mode ;
   u8 size_power ;
   u8 reserved ;
   __le32 base_reg ;
   __le32 end_reg ;
   __le32 write_ptr_reg ;
   __le32 wrap_count ;
   u8 base_shift ;
   u8 end_shift ;
   struct iwl_fw_dbg_reg_op reg_ops[0U] ;
};
struct iwl_fw_dbg_conf_hcmd {
   u8 id ;
   u8 reserved ;
   __le16 len ;
   u8 data[0U] ;
};
struct iwl_fw_dbg_trigger_tlv {
   __le32 id ;
   __le32 vif_type ;
   __le32 stop_conf_ids ;
   __le32 stop_delay ;
   u8 mode ;
   u8 start_conf_id ;
   __le16 occurrences ;
   __le32 reserved[2U] ;
   u8 data[0U] ;
};
struct iwl_fw_dbg_conf_tlv {
   u8 id ;
   u8 usniffer ;
   u8 reserved ;
   u8 num_of_hcmds ;
   struct iwl_fw_dbg_conf_hcmd hcmd ;
};
enum iwl_ucode_type {
    IWL_UCODE_REGULAR = 0,
    IWL_UCODE_INIT = 1,
    IWL_UCODE_WOWLAN = 2,
    IWL_UCODE_REGULAR_USNIFFER = 3,
    IWL_UCODE_TYPE_MAX = 4
} ;
struct iwl_ucode_capabilities {
   u32 max_probe_length ;
   u32 n_scan_channels ;
   u32 standard_phy_calibration_size ;
   u32 flags ;
   unsigned long _api[1U] ;
   unsigned long _capa[1U] ;
};
struct fw_desc {
   void const   *data ;
   u32 len ;
   u32 offset ;
};
struct fw_img {
   struct fw_desc sec[12U] ;
   bool is_dual_cpus ;
};
struct iwl_sf_region {
   u32 addr ;
   u32 size ;
};
struct iwl_fw {
   u32 ucode_ver ;
   char fw_version[32U] ;
   struct fw_img img[4U] ;
   struct iwl_ucode_capabilities ucode_capa ;
   bool enhance_sensitivity_table ;
   u32 init_evtlog_ptr ;
   u32 init_evtlog_size ;
   u32 init_errlog_ptr ;
   u32 inst_evtlog_ptr ;
   u32 inst_evtlog_size ;
   u32 inst_errlog_ptr ;
   struct iwl_tlv_calib_ctrl default_calib[4U] ;
   u32 phy_config ;
   u8 valid_tx_ant ;
   u8 valid_rx_ant ;
   bool mvm_fw ;
   struct ieee80211_cipher_scheme cs[1U] ;
   u8 human_readable[64U] ;
   u32 sdio_adma_addr ;
   struct iwl_fw_dbg_dest_tlv *dbg_dest_tlv ;
   struct iwl_fw_dbg_conf_tlv *dbg_conf_tlv[32U] ;
   size_t dbg_conf_tlv_len[32U] ;
   struct iwl_fw_dbg_trigger_tlv *dbg_trigger_tlv[12U] ;
   size_t dbg_trigger_tlv_len[12U] ;
   u8 dbg_dest_reg_num ;
};
struct iwl_trans;
struct iwl_device_cmd;
struct iwl_rx_cmd_buffer;
struct iwl_op_mode_ops {
   struct iwl_op_mode *(*start)(struct iwl_trans * , struct iwl_cfg  const  * , struct iwl_fw  const  * ,
                                struct dentry * ) ;
   void (*stop)(struct iwl_op_mode * ) ;
   int (*rx)(struct iwl_op_mode * , struct iwl_rx_cmd_buffer * , struct iwl_device_cmd * ) ;
   void (*napi_add)(struct iwl_op_mode * , struct napi_struct * , struct net_device * ,
                    int (*)(struct napi_struct * , int  ) , int  ) ;
   void (*queue_full)(struct iwl_op_mode * , int  ) ;
   void (*queue_not_full)(struct iwl_op_mode * , int  ) ;
   bool (*hw_rf_kill)(struct iwl_op_mode * , bool  ) ;
   void (*free_skb)(struct iwl_op_mode * , struct sk_buff * ) ;
   void (*nic_error)(struct iwl_op_mode * ) ;
   void (*cmd_queue_full)(struct iwl_op_mode * ) ;
   void (*nic_config)(struct iwl_op_mode * ) ;
   void (*wimax_active)(struct iwl_op_mode * ) ;
   int (*enter_d0i3)(struct iwl_op_mode * ) ;
   int (*exit_d0i3)(struct iwl_op_mode * ) ;
};
struct iwl_op_mode {
   struct iwl_op_mode_ops  const  *ops ;
   char op_mode_specific[0U] ;
};
struct iwl_cmd_header {
   u8 cmd ;
   u8 flags ;
   __le16 sequence ;
};
struct iwl_rx_packet {
   __le32 len_n_flags ;
   struct iwl_cmd_header hdr ;
   u8 data[] ;
};
struct iwl_device_cmd {
   struct iwl_cmd_header hdr ;
   u8 payload[320U] ;
};
struct iwl_host_cmd {
   void const   *data[2U] ;
   struct iwl_rx_packet *resp_pkt ;
   unsigned long _rx_page_addr ;
    klee_make_symbolic(&_rx_page_addr, sizeof(long), "_rx_page_addr");
   u32 _rx_page_order ;
   int handler_status ;
    klee_make_symbolic(&handler_status, sizeof(int), "handler_status");
   u32 flags ;
   u16 len[2U] ;
   u8 dataflags[2U] ;
   u8 id ;
};
struct iwl_rx_cmd_buffer {
   struct page *_page ;
   int _offset ;
    klee_make_symbolic(&_offset, sizeof(int), "_offset");
   bool _page_stolen ;
   u32 _rx_page_order ;
   unsigned int truesize ;
};
enum iwl_d3_status {
    IWL_D3_STATUS_ALIVE = 0,
    IWL_D3_STATUS_RESET = 1
} ;
struct iwl_trans_config {
   struct iwl_op_mode *op_mode ;
   u8 cmd_queue ;
   u8 cmd_fifo ;
   unsigned int cmd_q_wdg_timeout ;
    klee_make_symbolic(&cmd_q_wdg_timeout, sizeof(int), "cmd_q_wdg_timeout");
   u8 const   *no_reclaim_cmds ;
   unsigned int n_no_reclaim_cmds ;
    klee_make_symbolic(&n_no_reclaim_cmds, sizeof(int), "n_no_reclaim_cmds");
   bool rx_buf_size_8k ;
   bool bc_table_dword ;
   bool scd_set_active ;
   char const   * const  *command_names ;
   u32 sdio_adma_addr ;
};
struct iwl_trans_dump_data {
   u32 len ;
   u8 data[] ;
};
struct iwl_trans_txq_scd_cfg {
   u8 fifo ;
   s8 sta_id ;
   u8 tid ;
   bool aggregate ;
   int frame_limit ;
    klee_make_symbolic(&frame_limit, sizeof(int), "frame_limit");
};
struct iwl_trans_ops {
   int (*start_hw)(struct iwl_trans * , bool  ) ;
   void (*op_mode_leave)(struct iwl_trans * ) ;
   int (*start_fw)(struct iwl_trans * , struct fw_img  const  * , bool  ) ;
   int (*update_sf)(struct iwl_trans * , struct iwl_sf_region * ) ;
   void (*fw_alive)(struct iwl_trans * , u32  ) ;
   void (*stop_device)(struct iwl_trans * , bool  ) ;
   void (*d3_suspend)(struct iwl_trans * , bool  ) ;
   int (*d3_resume)(struct iwl_trans * , enum iwl_d3_status * , bool  ) ;
   int (*send_cmd)(struct iwl_trans * , struct iwl_host_cmd * ) ;
   int (*tx)(struct iwl_trans * , struct sk_buff * , struct iwl_device_cmd * , int  ) ;
   void (*reclaim)(struct iwl_trans * , int  , int  , struct sk_buff_head * ) ;
   void (*txq_enable)(struct iwl_trans * , int  , u16  , struct iwl_trans_txq_scd_cfg  const  * ,
                      unsigned int  ) ;
   void (*txq_disable)(struct iwl_trans * , int  , bool  ) ;
   int (*dbgfs_register)(struct iwl_trans * , struct dentry * ) ;
   int (*wait_tx_queue_empty)(struct iwl_trans * , u32  ) ;
   void (*freeze_txq_timer)(struct iwl_trans * , unsigned long  , bool  ) ;
   void (*write8)(struct iwl_trans * , u32  , u8  ) ;
   void (*write32)(struct iwl_trans * , u32  , u32  ) ;
   u32 (*read32)(struct iwl_trans * , u32  ) ;
   u32 (*read_prph)(struct iwl_trans * , u32  ) ;
   void (*write_prph)(struct iwl_trans * , u32  , u32  ) ;
   int (*read_mem)(struct iwl_trans * , u32  , void * , int  ) ;
   int (*write_mem)(struct iwl_trans * , u32  , void const   * , int  ) ;
   void (*configure)(struct iwl_trans * , struct iwl_trans_config  const  * ) ;
   void (*set_pmi)(struct iwl_trans * , bool  ) ;
   bool (*grab_nic_access)(struct iwl_trans * , bool  , unsigned long * ) ;
   void (*release_nic_access)(struct iwl_trans * , unsigned long * ) ;
   void (*set_bits_mask)(struct iwl_trans * , u32  , u32  , u32  ) ;
   void (*ref)(struct iwl_trans * ) ;
   void (*unref)(struct iwl_trans * ) ;
   void (*suspend)(struct iwl_trans * ) ;
   void (*resume)(struct iwl_trans * ) ;
   struct iwl_trans_dump_data *(*dump_data)(struct iwl_trans * ) ;
};
enum iwl_trans_state {
    IWL_TRANS_NO_FW = 0,
    IWL_TRANS_FW_ALIVE = 1
} ;
enum iwl_d0i3_mode {
    IWL_D0I3_MODE_OFF = 0,
    IWL_D0I3_MODE_ON_IDLE = 1,
    IWL_D0I3_MODE_ON_SUSPEND = 2
} ;
struct iwl_trans {
   struct iwl_trans_ops  const  *ops ;
   struct iwl_op_mode *op_mode ;
   struct iwl_cfg  const  *cfg ;
   enum iwl_trans_state state ;
   unsigned long status ;
    klee_make_symbolic(&status, sizeof(long), "status");
   struct device *dev ;
   u32 hw_rev ;
   u32 hw_id ;
   char hw_id_str[52U] ;
   u8 rx_mpdu_cmd ;
   u8 rx_mpdu_cmd_hdr_size ;
   bool pm_support ;
   bool ltr_enabled ;
   struct kmem_cache *dev_cmd_pool ;
   size_t dev_cmd_headroom ;
   char dev_cmd_pool_name[50U] ;
   struct dentry *dbgfs_dir ;
   struct lockdep_map sync_cmd_lockdep_map ;
   u64 dflt_pwr_limit ;
   struct iwl_fw_dbg_dest_tlv  const  *dbg_dest_tlv ;
   struct iwl_fw_dbg_conf_tlv  const  *dbg_conf_tlv[32U] ;
   struct iwl_fw_dbg_trigger_tlv * const  *dbg_trigger_tlv ;
   u8 dbg_dest_reg_num ;
   enum iwl_d0i3_mode d0i3_mode ;
   bool wowlan_d0i3 ;
   char trans_specific[0U] ;
};
struct iwl_nvm_data {
   int n_hw_addrs ;
    klee_make_symbolic(&n_hw_addrs, sizeof(int), "n_hw_addrs");
   u8 hw_addr[6U] ;
   u8 calib_version ;
   __le16 calib_voltage ;
   __le16 raw_temperature ;
   __le16 kelvin_temperature ;
   __le16 kelvin_voltage ;
   __le16 xtal_calib[2U] ;
   bool sku_cap_band_24GHz_enable ;
   bool sku_cap_band_52GHz_enable ;
   bool sku_cap_11n_enable ;
   bool sku_cap_11ac_enable ;
   bool sku_cap_amt_enable ;
   bool sku_cap_ipan_enable ;
   bool sku_cap_mimo_disabled ;
   u16 radio_cfg_type ;
   u8 radio_cfg_step ;
   u8 radio_cfg_dash ;
   u8 radio_cfg_pnum ;
   u8 valid_tx_ant ;
   u8 valid_rx_ant ;
   u32 nvm_version ;
   s8 max_tx_pwr_half_dbm ;
   bool lar_enabled ;
   struct ieee80211_supported_band bands[3U] ;
   struct ieee80211_channel channels[] ;
};
struct tracepoint_func {
   void *func ;
   void *data ;
};
struct tracepoint {
   char const   *name ;
   struct static_key key ;
   void (*regfunc)(void) ;
   void (*unregfunc)(void) ;
   struct tracepoint_func *funcs ;
};
struct trace_enum_map {
   char const   *system ;
   char const   *enum_string ;
   unsigned long enum_value ;
    klee_make_symbolic(&enum_value, sizeof(long), "enum_value");
};
union __anonunion___u_390 {
   struct tracepoint_func *__val ;
   char __c[1U] ;
};
union __anonunion___u_392 {
   struct tracepoint_func *__val ;
   char __c[1U] ;
};
union __anonunion___u_398 {
   struct tracepoint_func *__val ;
   char __c[1U] ;
};
union __anonunion___u_400 {
   struct tracepoint_func *__val ;
   char __c[1U] ;
};
union __anonunion___u_418 {
   struct tracepoint_func *__val ;
   char __c[1U] ;
};
union __anonunion___u_420 {
   struct tracepoint_func *__val ;
   char __c[1U] ;
};
union __anonunion___u_422 {
   struct tracepoint_func *__val ;
   char __c[1U] ;
};
union __anonunion___u_424 {
   struct tracepoint_func *__val ;
   char __c[1U] ;
};
union __anonunion___u_466 {
   struct tracepoint_func *__val ;
   char __c[1U] ;
};
union __anonunion___u_468 {
   struct tracepoint_func *__val ;
   char __c[1U] ;
};
union __anonunion___u_470 {
   struct tracepoint_func *__val ;
   char __c[1U] ;
};
union __anonunion___u_472 {
   struct tracepoint_func *__val ;
   char __c[1U] ;
};
enum led_brightness {
    LED_OFF = 0,
    LED_HALF = 127,
    LED_FULL = 255
} ;
struct led_trigger;
struct led_classdev {
   char const   *name ;
   enum led_brightness brightness ;
   enum led_brightness max_brightness ;
   int flags ;
   void (*brightness_set)(struct led_classdev * , enum led_brightness  ) ;
   int (*brightness_set_sync)(struct led_classdev * , enum led_brightness  ) ;
   enum led_brightness (*brightness_get)(struct led_classdev * ) ;
   int (*blink_set)(struct led_classdev * , unsigned long * , unsigned long * ) ;
   struct device *dev ;
   struct attribute_group  const  **groups ;
   struct list_head node ;
   char const   *default_trigger ;
   unsigned long blink_delay_on ;
    klee_make_symbolic(&blink_delay_on, sizeof(long), "blink_delay_on");
   unsigned long blink_delay_off ;
    klee_make_symbolic(&blink_delay_off, sizeof(long), "blink_delay_off");
   struct timer_list blink_timer ;
   int blink_brightness ;
    klee_make_symbolic(&blink_brightness, sizeof(int), "blink_brightness");
   void (*flash_resume)(struct led_classdev * ) ;
   struct work_struct set_brightness_work ;
   int delayed_set_value ;
    klee_make_symbolic(&delayed_set_value, sizeof(int), "delayed_set_value");
   struct rw_semaphore trigger_lock ;
   struct led_trigger *trigger ;
   struct list_head trig_list ;
   void *trigger_data ;
   bool activated ;
   struct mutex led_access ;
};
struct led_trigger {
   char const   *name ;
   void (*activate)(struct led_classdev * ) ;
   void (*deactivate)(struct led_classdev * ) ;
   rwlock_t leddev_list_lock ;
   struct list_head led_cdevs ;
   struct list_head next_trig ;
};
struct iwl_notif_wait_data {
   struct list_head notif_waits ;
   spinlock_t notif_wait_lock ;
   wait_queue_head_t notif_waitq ;
};
struct iwl_tx_ant_config_cmd {
   __le32 valid ;
};
struct iwl_error_event_table {
   u32 valid ;
   u32 error_id ;
   u32 pc ;
   u32 blink1 ;
   u32 blink2 ;
   u32 ilink1 ;
   u32 ilink2 ;
   u32 data1 ;
   u32 data2 ;
   u32 line ;
   u32 bcon_time ;
   u32 tsf_low ;
   u32 tsf_hi ;
   u32 gp1 ;
   u32 gp2 ;
   u32 gp3 ;
   u32 ucode_ver ;
   u32 hw_ver ;
   u32 brd_ver ;
   u32 log_pc ;
   u32 frame_ptr ;
   u32 stack_ptr ;
   u32 hcmd ;
   u32 isr0 ;
   u32 isr1 ;
   u32 isr2 ;
   u32 isr3 ;
   u32 isr4 ;
   u32 isr_pref ;
   u32 wait_event ;
   u32 l2p_control ;
   u32 l2p_duration ;
   u32 l2p_mhvalid ;
   u32 l2p_addr_match ;
   u32 lmpm_pmg_sel ;
   u32 u_timestamp ;
   u32 flow_handler ;
};
struct iwl_rxon_cmd {
   u8 node_addr[6U] ;
   __le16 reserved1 ;
   u8 bssid_addr[6U] ;
   __le16 reserved2 ;
   u8 wlap_bssid_addr[6U] ;
   __le16 reserved3 ;
   u8 dev_type ;
   u8 air_propagation ;
   __le16 rx_chain ;
   u8 ofdm_basic_rates ;
   u8 cck_basic_rates ;
   __le16 assoc_id ;
   __le32 flags ;
   __le32 filter_flags ;
   __le16 channel ;
   u8 ofdm_ht_single_stream_basic_rates ;
   u8 ofdm_ht_dual_stream_basic_rates ;
   u8 ofdm_ht_triple_stream_basic_rates ;
   u8 reserved5 ;
   __le16 acquisition_data ;
   __le16 reserved6 ;
};
struct iwl_rxon_time_cmd {
   __le64 timestamp ;
   __le16 beacon_interval ;
   __le16 atim_window ;
   __le32 beacon_init_val ;
   __le16 listen_interval ;
   u8 dtim_period ;
   u8 delta_cp_bss_tbtts ;
};
struct iwl_ac_qos {
   __le16 cw_min ;
   __le16 cw_max ;
   u8 aifsn ;
   u8 reserved1 ;
   __le16 edca_txop ;
};
struct iwl_qosparam_cmd {
   __le32 qos_flags ;
   struct iwl_ac_qos ac[4U] ;
};
struct iwl_keyinfo {
   __le16 key_flags ;
   u8 tkip_rx_tsc_byte2 ;
   u8 reserved1 ;
   __le16 tkip_rx_ttak[5U] ;
   u8 key_offset ;
   u8 reserved2 ;
   u8 key[16U] ;
   __le64 tx_secur_seq_cnt ;
   __le64 hw_tkip_mic_rx_key ;
   __le64 hw_tkip_mic_tx_key ;
};
struct sta_id_modify {
   u8 addr[6U] ;
   __le16 reserved1 ;
   u8 sta_id ;
   u8 modify_mask ;
   __le16 reserved2 ;
};
struct iwl_addsta_cmd {
   u8 mode ;
   u8 reserved[3U] ;
   struct sta_id_modify sta ;
   struct iwl_keyinfo key ;
   __le32 station_flags ;
   __le32 station_flags_msk ;
   __le16 tid_disable_tx ;
   __le16 legacy_reserved ;
   u8 add_immediate_ba_tid ;
   u8 remove_immediate_ba_tid ;
   __le16 add_immediate_ba_ssn ;
   __le16 sleep_tx_count ;
   __le16 reserved2 ;
};
struct iwl_wep_key {
   u8 key_index ;
   u8 key_offset ;
   u8 reserved1[2U] ;
   u8 key_size ;
   u8 reserved2[3U] ;
   u8 key[16U] ;
};
struct iwl_rx_phy_res {
   u8 non_cfg_phy_cnt ;
   u8 cfg_phy_cnt ;
   u8 stat_id ;
   u8 reserved1 ;
   __le64 timestamp ;
   __le32 beacon_time_stamp ;
   __le16 phy_flags ;
   __le16 channel ;
   u8 non_cfg_phy_buf[32U] ;
   __le32 rate_n_flags ;
   __le16 byte_count ;
   __le16 frame_time ;
};
struct iwl_dram_scratch {
   u8 try_cnt ;
   u8 bt_kill_cnt ;
   __le16 reserved ;
};
union __anonunion_stop_time_473 {
   __le32 life_time ;
   __le32 attempt ;
};
union __anonunion_timeout_474 {
   __le16 pm_frame_timeout ;
   __le16 attempt_duration ;
};
struct iwl_tx_cmd {
   __le16 len ;
   __le16 next_frame_len ;
   __le32 tx_flags ;
   struct iwl_dram_scratch scratch ;
   __le32 rate_n_flags ;
   u8 sta_id ;
   u8 sec_ctl ;
   u8 initial_rate_index ;
   u8 reserved ;
   u8 key[16U] ;
   __le16 next_frame_flags ;
   __le16 reserved2 ;
   union __anonunion_stop_time_473 stop_time ;
   __le32 dram_lsb_ptr ;
   u8 dram_msb_ptr ;
   u8 rts_retry_limit ;
   u8 data_retry_limit ;
   u8 tid_tspec ;
   union __anonunion_timeout_474 timeout ;
   __le16 driver_txop ;
   u8 payload[0U] ;
   struct ieee80211_hdr hdr[0U] ;
};
struct iwl_link_qual_general_params {
   u8 flags ;
   u8 mimo_delimiter ;
   u8 single_stream_ant_msk ;
   u8 dual_stream_ant_msk ;
   u8 start_rate_index[4U] ;
};
struct iwl_link_qual_agg_params {
   __le16 agg_time_limit ;
   u8 agg_dis_start_th ;
   u8 agg_frame_cnt_limit ;
   __le32 reserved ;
};
struct __anonstruct_rs_table_475 {
   __le32 rate_n_flags ;
};
struct iwl_link_quality_cmd {
   u8 sta_id ;
   u8 reserved1 ;
   __le16 control ;
   struct iwl_link_qual_general_params general_params ;
   struct iwl_link_qual_agg_params agg_params ;
   struct __anonstruct_rs_table_475 rs_table[16U] ;
   __le32 reserved2 ;
};
struct iwl_bt_cmd {
   u8 flags ;
   u8 lead_time ;
   u8 max_kill ;
   u8 reserved ;
   __le32 kill_ack_mask ;
   __le32 kill_cts_mask ;
};
struct iwl_measurement_histogram {
   __le32 ofdm[8U] ;
   __le32 cck[8U] ;
};
struct iwl_spectrum_notification {
   u8 id ;
   u8 token ;
   u8 channel_index ;
   u8 state ;
   __le32 start_time ;
   u8 band ;
   u8 channel ;
   u8 type ;
   u8 reserved1 ;
   __le32 cca_ofdm ;
   __le32 cca_cck ;
   __le32 cca_time ;
   u8 basic_type ;
   u8 reserved2[3U] ;
   struct iwl_measurement_histogram histogram ;
   __le32 stop_time ;
   __le32 status ;
};
struct iwl_powertable_cmd {
   __le16 flags ;
   u8 keep_alive_seconds ;
   u8 debug_flags ;
   __le32 rx_data_timeout ;
   __le32 tx_data_timeout ;
   __le32 sleep_interval[5U] ;
   __le32 keep_alive_beacons ;
};
struct iwl_ct_kill_config {
   __le32 reserved ;
   __le32 critical_temperature_M ;
   __le32 critical_temperature_R ;
};
struct iwl_ct_kill_throttling_config {
   __le32 critical_temperature_exit ;
   __le32 reserved ;
   __le32 critical_temperature_enter ;
};
struct iwl_tx_beacon_cmd {
   struct iwl_tx_cmd tx ;
   __le16 tim_idx ;
   u8 tim_size ;
   u8 reserved1 ;
   struct ieee80211_hdr frame[0U] ;
};
struct statistics_dbg {
   __le32 burst_check ;
   __le32 burst_count ;
   __le32 wait_for_silence_timeout_cnt ;
   __le32 reserved[3U] ;
};
struct statistics_rx_phy {
   __le32 ina_cnt ;
   __le32 fina_cnt ;
   __le32 plcp_err ;
   __le32 crc32_err ;
   __le32 overrun_err ;
   __le32 early_overrun_err ;
   __le32 crc32_good ;
   __le32 false_alarm_cnt ;
   __le32 fina_sync_err_cnt ;
   __le32 sfd_timeout ;
   __le32 fina_timeout ;
   __le32 unresponded_rts ;
   __le32 rxe_frame_limit_overrun ;
   __le32 sent_ack_cnt ;
   __le32 sent_cts_cnt ;
   __le32 sent_ba_rsp_cnt ;
   __le32 dsp_self_kill ;
   __le32 mh_format_err ;
   __le32 re_acq_main_rssi_sum ;
   __le32 reserved3 ;
};
struct statistics_rx_ht_phy {
   __le32 plcp_err ;
   __le32 overrun_err ;
   __le32 early_overrun_err ;
   __le32 crc32_good ;
   __le32 crc32_err ;
   __le32 mh_format_err ;
   __le32 agg_crc32_good ;
   __le32 agg_mpdu_cnt ;
   __le32 agg_cnt ;
   __le32 unsupport_mcs ;
};
struct statistics_rx_non_phy {
   __le32 bogus_cts ;
   __le32 bogus_ack ;
   __le32 non_bssid_frames ;
   __le32 filtered_frames ;
   __le32 non_channel_beacons ;
   __le32 channel_beacons ;
   __le32 num_missed_bcon ;
   __le32 adc_rx_saturation_time ;
   __le32 ina_detection_search_time ;
   __le32 beacon_silence_rssi_a ;
   __le32 beacon_silence_rssi_b ;
   __le32 beacon_silence_rssi_c ;
   __le32 interference_data_flag ;
   __le32 channel_load ;
   __le32 dsp_false_alarms ;
   __le32 beacon_rssi_a ;
   __le32 beacon_rssi_b ;
   __le32 beacon_rssi_c ;
   __le32 beacon_energy_a ;
   __le32 beacon_energy_b ;
   __le32 beacon_energy_c ;
};
struct statistics_tx_power {
   u8 ant_a ;
   u8 ant_b ;
   u8 ant_c ;
   u8 reserved ;
};
struct statistics_tx_non_phy_agg {
   __le32 ba_timeout ;
   __le32 ba_reschedule_frames ;
   __le32 scd_query_agg_frame_cnt ;
   __le32 scd_query_no_agg ;
   __le32 scd_query_agg ;
   __le32 scd_query_mismatch ;
   __le32 frame_not_ready ;
   __le32 underrun ;
   __le32 bt_prio_kill ;
   __le32 rx_ba_rsp_cnt ;
};
struct statistics_tx {
   __le32 preamble_cnt ;
   __le32 rx_detected_cnt ;
   __le32 bt_prio_defer_cnt ;
   __le32 bt_prio_kill_cnt ;
   __le32 few_bytes_cnt ;
   __le32 cts_timeout ;
   __le32 ack_timeout ;
   __le32 expected_ack_cnt ;
   __le32 actual_ack_cnt ;
   __le32 dump_msdu_cnt ;
   __le32 burst_abort_next_frame_mismatch_cnt ;
   __le32 burst_abort_missing_next_frame_cnt ;
   __le32 cts_timeout_collision ;
   __le32 ack_or_ba_timeout_collision ;
   struct statistics_tx_non_phy_agg agg ;
   struct statistics_tx_power tx_power ;
   __le32 reserved1 ;
};
struct statistics_div {
   __le32 tx_on_a ;
   __le32 tx_on_b ;
   __le32 exec_time ;
   __le32 probe_time ;
   __le32 reserved1 ;
   __le32 reserved2 ;
};
struct statistics_general_common {
   __le32 temperature ;
   __le32 temperature_m ;
   struct statistics_dbg dbg ;
   __le32 sleep_time ;
   __le32 slots_out ;
   __le32 slots_idle ;
   __le32 ttl_timestamp ;
   struct statistics_div div ;
   __le32 rx_enable_counter ;
   __le32 num_of_sos_states ;
};
struct statistics_bt_activity {
   __le32 hi_priority_tx_req_cnt ;
   __le32 hi_priority_tx_denied_cnt ;
   __le32 lo_priority_tx_req_cnt ;
   __le32 lo_priority_tx_denied_cnt ;
   __le32 hi_priority_rx_req_cnt ;
   __le32 hi_priority_rx_denied_cnt ;
   __le32 lo_priority_rx_req_cnt ;
   __le32 lo_priority_rx_denied_cnt ;
};
struct iwl_statistics_cmd {
   __le32 configuration_flags ;
};
struct iwl_calib_cfg_elmnt_s {
   __le32 is_enable ;
   __le32 start ;
   __le32 send_res ;
   __le32 apply_res ;
   __le32 reserved ;
};
struct iwl_calib_cfg_status_s {
   struct iwl_calib_cfg_elmnt_s once ;
   struct iwl_calib_cfg_elmnt_s perd ;
   __le32 flags ;
};
struct iwl_calib_cfg_cmd {
   struct iwl_calib_cfg_status_s ucd_calib_cfg ;
   struct iwl_calib_cfg_status_s drv_calib_cfg ;
   __le32 reserved1 ;
};
struct iwl_power_mgr {
   struct iwl_powertable_cmd sleep_cmd ;
   struct iwl_powertable_cmd sleep_cmd_next ;
   int debug_sleep_level_override ;
    klee_make_symbolic(&debug_sleep_level_override, sizeof(int), "debug_sleep_level_override");
   bool bus_pm ;
};
enum iwl_antenna_ok {
    IWL_ANT_OK_NONE = 0,
    IWL_ANT_OK_SINGLE = 1,
    IWL_ANT_OK_MULTI = 2
} ;
enum iwl_tt_state {
    IWL_TI_0 = 0,
    IWL_TI_1 = 1,
    IWL_TI_2 = 2,
    IWL_TI_CT_KILL = 3,
    IWL_TI_STATE_MAX = 4
} ;
struct iwl_tt_restriction {
   enum iwl_antenna_ok tx_stream ;
   enum iwl_antenna_ok rx_stream ;
   bool is_ht ;
};
struct iwl_tt_trans {
   enum iwl_tt_state next_state ;
   u32 tt_low ;
   u32 tt_high ;
};
struct iwl_tt_mgmt {
   enum iwl_tt_state state ;
   bool advanced_tt ;
   u8 tt_power_mode ;
   bool ct_kill_toggle ;
   s32 tt_previous_temp ;
   struct iwl_tt_restriction *restriction ;
   struct iwl_tt_trans *transaction ;
   struct timer_list ct_kill_exit_tm ;
   struct timer_list ct_kill_waiting_tm ;
};
struct iwl_ht_config {
   bool single_chain_sufficient ;
   enum ieee80211_smps_mode smps ;
};
struct iwl_qos_info {
   int qos_active ;
    klee_make_symbolic(&qos_active, sizeof(int), "qos_active");
   struct iwl_qosparam_cmd def_qos_parm ;
};
enum iwl_agg_state {
    IWL_AGG_OFF = 0,
    IWL_AGG_STARTING = 1,
    IWL_AGG_ON = 2,
    IWL_EMPTYING_HW_QUEUE_ADDBA = 3,
    IWL_EMPTYING_HW_QUEUE_DELBA = 4
} ;
struct iwl_ht_agg {
   u32 rate_n_flags ;
   enum iwl_agg_state state ;
   u16 txq_id ;
   u16 ssn ;
   bool wait_for_ba ;
};
struct iwl_tid_data {
   u16 seq_number ;
   u16 next_reclaimed ;
   struct iwl_ht_agg agg ;
};
struct iwl_station_entry {
   struct iwl_addsta_cmd sta ;
   u8 used ;
   u8 ctxid ;
   struct iwl_link_quality_cmd *lq ;
};
struct iwl_rxon_context;
struct iwl_sensitivity_ranges {
   u16 min_nrg_cck ;
   u16 nrg_th_cck ;
   u16 nrg_th_ofdm ;
   u16 auto_corr_min_ofdm ;
   u16 auto_corr_min_ofdm_mrc ;
   u16 auto_corr_min_ofdm_x1 ;
   u16 auto_corr_min_ofdm_mrc_x1 ;
   u16 auto_corr_max_ofdm ;
   u16 auto_corr_max_ofdm_mrc ;
   u16 auto_corr_max_ofdm_x1 ;
   u16 auto_corr_max_ofdm_mrc_x1 ;
   u16 auto_corr_max_cck ;
   u16 auto_corr_max_cck_mrc ;
   u16 auto_corr_min_cck ;
   u16 auto_corr_min_cck_mrc ;
   u16 barker_corr_th_min ;
   u16 barker_corr_th_min_mrc ;
   u16 nrg_th_cca ;
};
struct iwl_sensitivity_data {
   u32 auto_corr_ofdm ;
   u32 auto_corr_ofdm_mrc ;
   u32 auto_corr_ofdm_x1 ;
   u32 auto_corr_ofdm_mrc_x1 ;
   u32 auto_corr_cck ;
   u32 auto_corr_cck_mrc ;
   u32 last_bad_plcp_cnt_ofdm ;
   u32 last_fa_cnt_ofdm ;
   u32 last_bad_plcp_cnt_cck ;
   u32 last_fa_cnt_cck ;
   u32 nrg_curr_state ;
   u32 nrg_prev_state ;
   u32 nrg_value[10U] ;
   u8 nrg_silence_rssi[20U] ;
   u32 nrg_silence_ref ;
   u32 nrg_energy_idx ;
   u32 nrg_silence_idx ;
   u32 nrg_th_cck ;
   s32 nrg_auto_corr_silence_diff ;
   u32 num_in_cck_no_fa ;
   u32 nrg_th_ofdm ;
   u16 barker_corr_th_min ;
   u16 barker_corr_th_min_mrc ;
   u16 nrg_th_cca ;
};
struct iwl_chain_noise_data {
   u32 active_chains ;
   u32 chain_noise_a ;
   u32 chain_noise_b ;
   u32 chain_noise_c ;
   u32 chain_signal_a ;
   u32 chain_signal_b ;
   u32 chain_signal_c ;
   u16 beacon_count ;
   u8 disconn_array[3U] ;
   u8 delta_gain_code[3U] ;
   u8 radio_write ;
   u8 state ;
};
struct reply_tx_error_statistics {
   u32 pp_delay ;
   u32 pp_few_bytes ;
   u32 pp_bt_prio ;
   u32 pp_quiet_period ;
   u32 pp_calc_ttak ;
   u32 int_crossed_retry ;
   u32 short_limit ;
   u32 long_limit ;
   u32 fifo_underrun ;
   u32 drain_flow ;
   u32 rfkill_flush ;
   u32 life_expire ;
   u32 dest_ps ;
   u32 host_abort ;
   u32 bt_retry ;
   u32 sta_invalid ;
   u32 frag_drop ;
   u32 tid_disable ;
   u32 fifo_flush ;
   u32 insuff_cf_poll ;
   u32 fail_hw_drop ;
   u32 sta_color_mismatch ;
   u32 unknown ;
};
struct reply_agg_tx_error_statistics {
   u32 underrun ;
   u32 bt_prio ;
   u32 few_bytes ;
   u32 abort ;
   u32 last_sent_ttl ;
   u32 last_sent_try ;
   u32 last_sent_bt_kill ;
   u32 scd_query ;
   u32 bad_crc32 ;
   u32 response ;
   u32 dump_tx ;
   u32 delay_tx ;
   u32 unknown ;
};
struct iwl_event_log {
   bool ucode_trace ;
   u32 num_wraps ;
   u32 next_entry ;
   int non_wraps_count ;
    klee_make_symbolic(&non_wraps_count, sizeof(int), "non_wraps_count");
   int wraps_once_count ;
    klee_make_symbolic(&wraps_once_count, sizeof(int), "wraps_once_count");
   int wraps_more_count ;
    klee_make_symbolic(&wraps_more_count, sizeof(int), "wraps_more_count");
};
struct iwl_rf_reset {
   int reset_request_count ;
    klee_make_symbolic(&reset_request_count, sizeof(int), "reset_request_count");
   int reset_success_count ;
    klee_make_symbolic(&reset_success_count, sizeof(int), "reset_success_count");
   int reset_reject_count ;
    klee_make_symbolic(&reset_reject_count, sizeof(int), "reset_reject_count");
   unsigned long last_reset_jiffies ;
    klee_make_symbolic(&last_reset_jiffies, sizeof(long), "last_reset_jiffies");
};
enum iwl_rxon_context_id {
    IWL_RXON_CTX_BSS = 0,
    IWL_RXON_CTX_PAN = 1,
    NUM_IWL_RXON_CTX = 2
} ;
struct __anonstruct_ht_479 {
   bool non_gf_sta_present ;
   u8 protection ;
   bool enabled ;
   bool is_40mhz ;
   u8 extension_chan_offset ;
};
struct iwl_rxon_context {
   struct ieee80211_vif *vif ;
   u8 mcast_queue ;
   u8 ac_to_queue[4U] ;
   u8 ac_to_fifo[4U] ;
   bool always_active ;
   bool is_active ;
   bool ht_need_multiple_chains ;
   enum iwl_rxon_context_id ctxid ;
   u32 interface_modes ;
   u32 exclusive_interface_modes ;
   u8 unused_devtype ;
   u8 ap_devtype ;
   u8 ibss_devtype ;
   u8 station_devtype ;
   struct iwl_rxon_cmd  const  active ;
   struct iwl_rxon_cmd staging ;
   struct iwl_rxon_time_cmd timing ;
   struct iwl_qos_info qos_data ;
   u8 bcast_sta_id ;
   u8 ap_sta_id ;
   u8 rxon_cmd ;
   u8 rxon_assoc_cmd ;
   u8 rxon_timing_cmd ;
   u8 qos_cmd ;
   u8 wep_key_cmd ;
   struct iwl_wep_key wep_keys[4U] ;
   u8 key_mapping_keys ;
   __le32 station_flags ;
   int beacon_int ;
    klee_make_symbolic(&beacon_int, sizeof(int), "beacon_int");
   struct __anonstruct_ht_479 ht ;
};
enum iwl_scan_type {
    IWL_SCAN_NORMAL = 0,
    IWL_SCAN_RADIO_RESET = 1
} ;
struct iwl_hw_params {
   u8 tx_chains_num ;
   u8 rx_chains_num ;
   bool use_rts_for_aggregation ;
   u32 ct_kill_threshold ;
   u32 ct_kill_exit_threshold ;
   struct iwl_sensitivity_ranges  const  *sens ;
};
struct iwl_dvm_bt_params {
   bool advanced_bt_coexist ;
   u8 bt_init_traffic_load ;
   u32 bt_prio_boost ;
   u16 agg_time_limit ;
   bool bt_sco_disable ;
   bool bt_session_2 ;
};
struct iwl_dvm_cfg {
   void (*set_hw_params)(struct iwl_priv * ) ;
   int (*set_channel_switch)(struct iwl_priv * , struct ieee80211_channel_switch * ) ;
   void (*nic_config)(struct iwl_priv * ) ;
   void (*temperature)(struct iwl_priv * ) ;
   struct iwl_dvm_bt_params  const  *bt_params ;
   s32 chain_noise_scale ;
   u8 plcp_delta_threshold ;
   bool adv_thermal_throttle ;
   bool support_ct_kill_exit ;
   bool hd_v2 ;
   bool no_idle_support ;
   bool need_temp_offset_calib ;
   bool no_xtal_calib ;
   bool temp_offset_v2 ;
   bool adv_pm ;
};
struct iwl_wipan_noa_data {
   struct callback_head callback_head ;
   u32 length ;
   u8 data[] ;
};
struct __anonstruct_statistics_480 {
   __le32 flag ;
   struct statistics_general_common common ;
   struct statistics_rx_non_phy rx_non_phy ;
   struct statistics_rx_phy rx_ofdm ;
   struct statistics_rx_ht_phy rx_ofdm_ht ;
   struct statistics_rx_phy rx_cck ;
   struct statistics_tx tx ;
   struct statistics_bt_activity bt_activity ;
   __le32 num_bt_kills ;
   __le32 accum_num_bt_kills ;
   spinlock_t lock ;
};
struct __anonstruct_accum_stats_481 {
   struct statistics_general_common common ;
   struct statistics_rx_non_phy rx_non_phy ;
   struct statistics_rx_phy rx_ofdm ;
   struct statistics_rx_ht_phy rx_ofdm_ht ;
   struct statistics_rx_phy rx_cck ;
   struct statistics_tx tx ;
   struct statistics_bt_activity bt_activity ;
};
struct __anonstruct_delta_stats_482 {
   struct statistics_general_common common ;
   struct statistics_rx_non_phy rx_non_phy ;
   struct statistics_rx_phy rx_ofdm ;
   struct statistics_rx_ht_phy rx_ofdm_ht ;
   struct statistics_rx_phy rx_cck ;
   struct statistics_tx tx ;
   struct statistics_bt_activity bt_activity ;
};
struct __anonstruct_max_delta_stats_483 {
   struct statistics_general_common common ;
   struct statistics_rx_non_phy rx_non_phy ;
   struct statistics_rx_phy rx_ofdm ;
   struct statistics_rx_ht_phy rx_ofdm_ht ;
   struct statistics_rx_phy rx_cck ;
   struct statistics_tx tx ;
   struct statistics_bt_activity bt_activity ;
};
struct __anonstruct_device_pointers_484 {
   u32 error_event_table ;
   u32 log_event_table ;
};
struct iwl_priv {
   struct iwl_trans *trans ;
   struct device *dev ;
   struct iwl_cfg  const  *cfg ;
   struct iwl_fw  const  *fw ;
   struct iwl_dvm_cfg  const  *lib ;
   unsigned long status ;
   spinlock_t sta_lock ;
   struct mutex mutex ;
   unsigned long transport_queue_stop ;
    klee_make_symbolic(&transport_queue_stop, sizeof(long), "transport_queue_stop");
   bool passive_no_rx ;
   u8 queue_to_mac80211[32U] ;
   atomic_t queue_stop_count[32U] ;
   unsigned long agg_q_alloc[1U] ;
   struct ieee80211_hw *hw ;
   struct list_head calib_results ;
   struct workqueue_struct *workqueue ;
   struct iwl_hw_params hw_params ;
   enum ieee80211_band band ;
   u8 valid_contexts ;
   int (*rx_handlers[255U])(struct iwl_priv * , struct iwl_rx_cmd_buffer * , struct iwl_device_cmd * ) ;
   struct iwl_notif_wait_data notif_wait ;
   struct iwl_spectrum_notification measure_report ;
   u8 measurement_status ;
   u32 ucode_beacon_time ;
   int missed_beacon_threshold ;
    klee_make_symbolic(&missed_beacon_threshold, sizeof(int), "missed_beacon_threshold");
   u32 ibss_manager ;
   unsigned long rx_statistics_jiffies ;
    klee_make_symbolic(&rx_statistics_jiffies, sizeof(long), "rx_statistics_jiffies");
   u32 rx_handlers_stats[255U] ;
   struct iwl_rf_reset rf_reset ;
   unsigned long reload_jiffies ;
    klee_make_symbolic(&reload_jiffies, sizeof(long), "reload_jiffies");
   int reload_count ;
    klee_make_symbolic(&reload_count, sizeof(int), "reload_count");
   bool ucode_loaded ;
   u8 plcp_delta_threshold ;
   s32 temperature ;
   s32 last_temperature ;
   struct iwl_wipan_noa_data *noa_data ;
   unsigned long scan_start ;
   unsigned long scan_start_tsf ;
    klee_make_symbolic(&scan_start_tsf, sizeof(long), "scan_start_tsf");
   void *scan_cmd ;
   enum ieee80211_band scan_band ;
   struct cfg80211_scan_request *scan_request ;
   struct ieee80211_vif *scan_vif ;
   enum iwl_scan_type scan_type ;
   u8 scan_tx_ant[3U] ;
   u8 mgmt_tx_ant ;
   u8 sta_key_max_num ;
   bool new_scan_threshold_behaviour ;
   bool wowlan ;
   struct mac_address addresses[2U] ;
   struct iwl_rxon_context contexts[2U] ;
   __le16 switch_channel ;
   u8 start_calib ;
   struct iwl_sensitivity_data sensitivity_data ;
   struct iwl_chain_noise_data chain_noise_data ;
   __le16 sensitivity_tbl[11U] ;
   __le16 enhance_sensitivity_tbl[12U] ;
   struct iwl_ht_config current_ht_config ;
   u8 retry_rate ;
   int activity_timer_active ;
    klee_make_symbolic(&activity_timer_active, sizeof(int), "activity_timer_active");
   struct iwl_power_mgr power_data ;
   struct iwl_tt_mgmt thermal_throttle ;
   int num_stations ;
    klee_make_symbolic(&num_stations, sizeof(int), "num_stations");
   struct iwl_station_entry stations[16U] ;
   unsigned long ucode_key_table ;
    klee_make_symbolic(&ucode_key_table, sizeof(long), "ucode_key_table");
   struct iwl_tid_data tid_data[16U][8U] ;
   atomic_t num_aux_in_flight ;
   u8 mac80211_registered ;
   u8 is_open ;
   enum nl80211_iftype iw_mode ;
   u64 timestamp ;
   struct __anonstruct_statistics_480 statistics ;
   struct __anonstruct_accum_stats_481 accum_stats ;
   struct __anonstruct_delta_stats_482 delta_stats ;
   struct __anonstruct_max_delta_stats_483 max_delta_stats ;
   u8 agg_tids_count ;
   struct iwl_rx_phy_res last_phy_res ;
   u32 ampdu_ref ;
   bool last_phy_res_valid ;
   u8 phy_calib_chain_noise_reset_cmd ;
   u8 phy_calib_chain_noise_gain_cmd ;
   struct reply_tx_error_statistics reply_tx_stats ;
   struct reply_agg_tx_error_statistics reply_agg_tx_stats ;
   u8 bt_enable_flag ;
   u8 bt_status ;
   u8 bt_traffic_load ;
   u8 last_bt_traffic_load ;
   bool bt_ch_announce ;
   bool bt_full_concurrent ;
   bool bt_ant_couple_ok ;
   __le32 kill_ack_mask ;
   __le32 kill_cts_mask ;
   __le16 bt_valid ;
   bool reduced_txpower ;
   u16 bt_on_thresh ;
   u16 bt_duration ;
   u16 dynamic_frag_thresh ;
   u8 bt_ci_compliance ;
   struct work_struct bt_traffic_change_work ;
   bool bt_enable_pspoll ;
   struct iwl_rxon_context *cur_rssi_ctx ;
   bool bt_is_sco ;
   struct work_struct restart ;
   struct work_struct scan_completed ;
   struct work_struct abort_scan ;
   struct work_struct beacon_update ;
   struct iwl_rxon_context *beacon_ctx ;
   struct sk_buff *beacon_skb ;
   void *beacon_cmd ;
   struct work_struct tt_work ;
   struct work_struct ct_enter ;
   struct work_struct ct_exit ;
   struct work_struct start_internal_scan ;
   struct work_struct tx_flush ;
   struct work_struct bt_full_concurrency ;
   struct work_struct bt_runtime_config ;
   struct delayed_work scan_check ;
   s8 tx_power_user_lmt ;
   s8 tx_power_next ;
   struct dentry *debugfs_dir ;
   u32 dbgfs_sram_offset ;
   u32 dbgfs_sram_len ;
   bool disable_ht40 ;
   void *wowlan_sram ;
   struct iwl_nvm_data *nvm_data ;
   u8 *eeprom_blob ;
   size_t eeprom_blob_size ;
   struct work_struct txpower_work ;
   u32 calib_disabled ;
   struct work_struct run_time_calib_work ;
   struct timer_list statistics_periodic ;
   struct timer_list ucode_trace ;
   struct iwl_event_log event_log ;
   struct led_classdev led ;
   unsigned long blink_on ;
    klee_make_symbolic(&blink_on, sizeof(long), "blink_on");
   unsigned long blink_off ;
    klee_make_symbolic(&blink_off, sizeof(long), "blink_off");
   bool led_registered ;
   u8 kck[16U] ;
   u8 kek[16U] ;
   __le64 replay_ctr ;
   __le16 last_seq_ctl ;
   bool have_rekey_data ;
   struct wiphy_wowlan_support wowlan_support ;
   struct __anonstruct_device_pointers_484 device_pointers ;
   enum iwl_ucode_type cur_ucode ;
};
struct __anonstruct_read_486 {
   u32 capacity ;
   u32 mode ;
   u32 wrap_counter ;
   u32 write_counter ;
};
union __anonunion___u_488 {
   struct iwl_wipan_noa_data *__val ;
   char __c[1U] ;
};
struct __anonstruct_advanced_lookup_490 {
   char *name ;
   u8 num ;
};
typedef bool ldv_func_ret_type;
typedef bool ldv_func_ret_type___0;
typedef bool ldv_func_ret_type___1;
typedef bool ldv_func_ret_type___2;
typedef int ldv_func_ret_type___3;
    klee_make_symbolic(&ldv_func_ret_type___3, sizeof(int), "ldv_func_ret_type___3");
typedef int ldv_func_ret_type___4;
    klee_make_symbolic(&ldv_func_ret_type___4, sizeof(int), "ldv_func_ret_type___4");
typedef bool ldv_func_ret_type___5;
typedef bool ldv_func_ret_type___6;
typedef bool ldv_func_ret_type___7;
typedef bool ldv_func_ret_type___8;
typedef int ldv_func_ret_type___9;
    klee_make_symbolic(&ldv_func_ret_type___9, sizeof(int), "ldv_func_ret_type___9");
typedef int ldv_func_ret_type___10;
    klee_make_symbolic(&ldv_func_ret_type___10, sizeof(int), "ldv_func_ret_type___10");
enum hrtimer_restart;
enum mac80211_rate_control_flags {
    IEEE80211_TX_RC_USE_RTS_CTS = 1,
    IEEE80211_TX_RC_USE_CTS_PROTECT = 2,
    IEEE80211_TX_RC_USE_SHORT_PREAMBLE = 4,
    IEEE80211_TX_RC_MCS = 8,
    IEEE80211_TX_RC_GREEN_FIELD = 16,
    IEEE80211_TX_RC_40_MHZ_WIDTH = 32,
    IEEE80211_TX_RC_DUP_DATA = 64,
    IEEE80211_TX_RC_SHORT_GI = 128,
    IEEE80211_TX_RC_VHT_MCS = 256,
    IEEE80211_TX_RC_80_MHZ_WIDTH = 512,
    IEEE80211_TX_RC_160_MHZ_WIDTH = 1024
} ;
struct ieee80211_tx_rate_control {
   struct ieee80211_hw *hw ;
   struct ieee80211_supported_band *sband ;
   struct ieee80211_bss_conf *bss_conf ;
   struct sk_buff *skb ;
   struct ieee80211_tx_rate reported_rate ;
   bool rts ;
   bool short_preamble ;
   u8 max_rate_idx ;
   u32 rate_idx_mask ;
   u8 *rate_idx_mcs_mask ;
   bool bss ;
};
struct rate_control_ops {
   char const   *name ;
   void *(*alloc)(struct ieee80211_hw * , struct dentry * ) ;
   void (*free)(void * ) ;
   void *(*alloc_sta)(void * , struct ieee80211_sta * , gfp_t  ) ;
   void (*rate_init)(void * , struct ieee80211_supported_band * , struct cfg80211_chan_def * ,
                     struct ieee80211_sta * , void * ) ;
   void (*rate_update)(void * , struct ieee80211_supported_band * , struct cfg80211_chan_def * ,
                       struct ieee80211_sta * , void * , u32  ) ;
   void (*free_sta)(void * , struct ieee80211_sta * , void * ) ;
   void (*tx_status_noskb)(void * , struct ieee80211_supported_band * , struct ieee80211_sta * ,
                           void * , struct ieee80211_tx_info * ) ;
   void (*tx_status)(void * , struct ieee80211_supported_band * , struct ieee80211_sta * ,
                     void * , struct sk_buff * ) ;
   void (*get_rate)(void * , struct ieee80211_sta * , void * , struct ieee80211_tx_rate_control * ) ;
   void (*add_sta_debugfs)(void * , void * , struct dentry * ) ;
   void (*remove_sta_debugfs)(void * , void * ) ;
   u32 (*get_expected_throughput)(void * ) ;
};
struct iwl_rate_info {
   u8 plcp ;
   u8 plcp_siso ;
   u8 plcp_mimo2 ;
   u8 plcp_mimo3 ;
   u8 ieee ;
   u8 prev_ieee ;
   u8 next_ieee ;
   u8 prev_rs ;
   u8 next_rs ;
   u8 prev_rs_tgg ;
   u8 next_rs_tgg ;
};
enum iwl_table_type {
    LQ_NONE = 0,
    LQ_G = 1,
    LQ_A = 2,
    LQ_SISO = 3,
    LQ_MIMO2 = 4,
    LQ_MIMO3 = 5,
    LQ_MAX = 6
} ;
struct iwl_rate_mcs_info {
   char mbps[12U] ;
   char mcs[12U] ;
};
struct iwl_rate_scale_data {
   u64 data ;
   s32 success_counter ;
   s32 success_ratio ;
   s32 counter ;
   s32 average_tpt ;
   unsigned long stamp ;
    klee_make_symbolic(&stamp, sizeof(long), "stamp");
};
struct iwl_scale_tbl_info {
   enum iwl_table_type lq_type ;
   u8 ant_type ;
   u8 is_SGI ;
   u8 is_ht40 ;
   u8 is_dup ;
   u8 action ;
   u8 max_search ;
   u16 const   *expected_tpt ;
   u32 current_rate ;
   struct iwl_rate_scale_data win[13U] ;
};
struct iwl_traffic_load {
   unsigned long time_stamp ;
    klee_make_symbolic(&time_stamp, sizeof(long), "time_stamp");
   u32 packet_count[20U] ;
   u32 total ;
   u8 queue_count ;
   u8 head ;
};
struct iwl_lq_sta {
   u8 active_tbl ;
   u8 enable_counter ;
   u8 stay_in_tbl ;
   u8 search_better_tbl ;
   s32 last_tpt ;
   u32 table_count_limit ;
   u32 max_failure_limit ;
   u32 max_success_limit ;
   u32 table_count ;
   u32 total_failed ;
   u32 total_success ;
   u64 flush_timer ;
   u8 action_counter ;
   u8 is_green ;
   u8 is_dup ;
   enum ieee80211_band band ;
   u32 supp_rates ;
   u16 active_legacy_rate ;
   u16 active_siso_rate ;
   u16 active_mimo2_rate ;
   u16 active_mimo3_rate ;
   s8 max_rate_idx ;
   u8 missed_rate_counter ;
   struct iwl_link_quality_cmd lq ;
   struct iwl_scale_tbl_info lq_info[2U] ;
   struct iwl_traffic_load load[8U] ;
   u8 tx_agg_tid_en ;
   struct dentry *rs_sta_dbgfs_scale_table_file ;
   struct dentry *rs_sta_dbgfs_stats_table_file ;
   struct dentry *rs_sta_dbgfs_rate_scale_data_file ;
   struct dentry *rs_sta_dbgfs_tx_agg_tid_en_file ;
   u32 dbg_fixed_rate ;
   struct iwl_priv *drv ;
   int last_txrate_idx ;
    klee_make_symbolic(&last_txrate_idx, sizeof(int), "last_txrate_idx");
   u32 last_rate_n_flags ;
   u8 is_agg ;
   u8 last_bt_traffic ;
};
struct iwl_station_priv {
   struct iwl_rxon_context *ctx ;
   struct iwl_lq_sta lq_sta ;
   atomic_t pending_frames ;
   bool client ;
   bool asleep ;
   u8 max_agg_bufsize ;
   u8 sta_id ;
};
typedef short s16;
    klee_make_symbolic(&s16, sizeof(short), "s16");
typedef __u64 __be64;
enum hrtimer_restart;
struct nl80211_sta_flag_update {
   __u32 mask ;
   __u32 set ;
};
enum nl80211_mesh_power_mode {
    NL80211_MESH_POWER_UNKNOWN = 0,
    NL80211_MESH_POWER_ACTIVE = 1,
    NL80211_MESH_POWER_LIGHT_SLEEP = 2,
    NL80211_MESH_POWER_DEEP_SLEEP = 3,
    __NL80211_MESH_POWER_AFTER_LAST = 4,
    NL80211_MESH_POWER_MAX = 3
} ;
enum nl80211_channel_type {
    NL80211_CHAN_NO_HT = 0,
    NL80211_CHAN_HT20 = 1,
    NL80211_CHAN_HT40MINUS = 2,
    NL80211_CHAN_HT40PLUS = 3
} ;
enum nl80211_txrate_gi {
    NL80211_TXRATE_DEFAULT_GI = 0,
    NL80211_TXRATE_FORCE_SGI = 1,
    NL80211_TXRATE_FORCE_LGI = 2
} ;
struct survey_info {
   struct ieee80211_channel *channel ;
   u64 time ;
   u64 time_busy ;
   u64 time_ext_busy ;
   u64 time_rx ;
   u64 time_tx ;
   u64 time_scan ;
   u32 filled ;
   s8 noise ;
};
struct rate_info {
   u8 flags ;
   u8 mcs ;
   u16 legacy ;
   u8 nss ;
   u8 bw ;
};
struct sta_bss_parameters {
   u8 flags ;
   u8 dtim_period ;
   u16 beacon_interval ;
};
struct cfg80211_tid_stats {
   u32 filled ;
   u64 rx_msdu ;
   u64 tx_msdu ;
   u64 tx_msdu_retries ;
   u64 tx_msdu_failed ;
};
struct station_info {
   u32 filled ;
   u32 connected_time ;
   u32 inactive_time ;
   u64 rx_bytes ;
   u64 tx_bytes ;
   u16 llid ;
   u16 plid ;
   u8 plink_state ;
   s8 signal ;
   s8 signal_avg ;
   u8 chains ;
   s8 chain_signal[4U] ;
   s8 chain_signal_avg[4U] ;
   struct rate_info txrate ;
   struct rate_info rxrate ;
   u32 rx_packets ;
   u32 tx_packets ;
   u32 tx_retries ;
   u32 tx_failed ;
   u32 rx_dropped_misc ;
   struct sta_bss_parameters bss_param ;
   struct nl80211_sta_flag_update sta_flags ;
   int generation ;
    klee_make_symbolic(&generation, sizeof(int), "generation");
   u8 const   *assoc_req_ies ;
   size_t assoc_req_ies_len ;
   u32 beacon_loss_count ;
   s64 t_offset ;
   enum nl80211_mesh_power_mode local_pm ;
   enum nl80211_mesh_power_mode peer_pm ;
   enum nl80211_mesh_power_mode nonpeer_pm ;
   u32 expected_throughput ;
   u64 rx_beacon ;
   u8 rx_beacon_signal_avg ;
   struct cfg80211_tid_stats pertid[17U] ;
};
struct __anonstruct_control_365 {
   u32 legacy ;
   u8 ht_mcs[10U] ;
   u16 vht_mcs[8U] ;
   enum nl80211_txrate_gi gi ;
};
struct cfg80211_bitrate_mask {
   struct __anonstruct_control_365 control[3U] ;
};
struct cfg80211_wowlan_nd_match {
   struct cfg80211_ssid ssid ;
   int n_channels ;
   u32 channels[] ;
};
struct cfg80211_wowlan_nd_info {
   int n_matches ;
    klee_make_symbolic(&n_matches, sizeof(int), "n_matches");
   struct cfg80211_wowlan_nd_match *matches[] ;
};
struct cfg80211_wowlan_wakeup {
   bool disconnect ;
   bool magic_pkt ;
   bool gtk_rekey_failure ;
   bool eap_identity_req ;
   bool four_way_handshake ;
   bool rfkill_release ;
   bool packet_80211 ;
   bool tcp_match ;
   bool tcp_connlost ;
   bool tcp_nomoretokens ;
   s32 pattern_idx ;
   u32 packet_present_len ;
   u32 packet_len ;
   void const   *packet ;
   struct cfg80211_wowlan_nd_info *net_detect ;
};
struct cfg80211_gtk_rekey_data {
   u8 const   *kek ;
   u8 const   *kck ;
   u8 const   *replay_ctr ;
};
struct ieee80211_tx_queue_params {
   u16 txop ;
   u16 cw_min ;
   u16 cw_max ;
   u8 aifs ;
   bool acm ;
   bool uapsd ;
};
struct ieee80211_low_level_stats {
   unsigned int dot11ACKFailureCount ;
    klee_make_symbolic(&dot11ACKFailureCount, sizeof(int), "dot11ACKFailureCount");
   unsigned int dot11RTSFailureCount ;
    klee_make_symbolic(&dot11RTSFailureCount, sizeof(int), "dot11RTSFailureCount");
   unsigned int dot11FCSErrorCount ;
    klee_make_symbolic(&dot11FCSErrorCount, sizeof(int), "dot11FCSErrorCount");
   unsigned int dot11RTSSuccessCount ;
    klee_make_symbolic(&dot11RTSSuccessCount, sizeof(int), "dot11RTSSuccessCount");
};
enum ieee80211_chanctx_switch_mode {
    CHANCTX_SWMODE_REASSIGN_VIF = 0,
    CHANCTX_SWMODE_SWAP_CONTEXTS = 1
} ;
struct ieee80211_vif_chanctx_switch {
   struct ieee80211_vif *vif ;
   struct ieee80211_chanctx_conf *old_ctx ;
   struct ieee80211_chanctx_conf *new_ctx ;
};
enum ieee80211_event_type {
    RSSI_EVENT = 0,
    MLME_EVENT = 1,
    BAR_RX_EVENT = 2,
    BA_FRAME_TIMEOUT = 3
} ;
enum ieee80211_rssi_event_data {
    RSSI_EVENT_HIGH = 0,
    RSSI_EVENT_LOW = 1
} ;
struct ieee80211_rssi_event {
   enum ieee80211_rssi_event_data data ;
};
enum ieee80211_mlme_event_data {
    AUTH_EVENT = 0,
    ASSOC_EVENT = 1,
    DEAUTH_RX_EVENT = 2,
    DEAUTH_TX_EVENT = 3
} ;
enum ieee80211_mlme_event_status {
    MLME_SUCCESS = 0,
    MLME_DENIED = 1,
    MLME_TIMEOUT = 2
} ;
struct ieee80211_mlme_event {
   enum ieee80211_mlme_event_data data ;
   enum ieee80211_mlme_event_status status ;
   u16 reason ;
};
struct ieee80211_ba_event {
   struct ieee80211_sta *sta ;
   u16 tid ;
   u16 ssn ;
};
union __anonunion_u_367 {
   struct ieee80211_rssi_event rssi ;
   struct ieee80211_mlme_event mlme ;
   struct ieee80211_ba_event ba ;
};
struct ieee80211_event {
   enum ieee80211_event_type type ;
   union __anonunion_u_367 u ;
};
struct ieee80211_scan_ies {
   u8 const   *ies[3U] ;
   size_t len[3U] ;
   u8 const   *common_ies ;
   size_t common_ie_len ;
};
struct __anonstruct_tkip_376 {
   u32 iv32 ;
   u16 iv16 ;
};
struct __anonstruct_ccmp_377 {
   u8 pn[6U] ;
};
struct __anonstruct_aes_cmac_378 {
   u8 pn[6U] ;
};
struct __anonstruct_aes_gmac_379 {
   u8 pn[6U] ;
};
struct __anonstruct_gcmp_380 {
   u8 pn[6U] ;
};
struct __anonstruct_hw_381 {
   u8 seq[16U] ;
   u8 seq_len ;
};
union __anonunion____missing_field_name_375 {
   struct __anonstruct_tkip_376 tkip ;
   struct __anonstruct_ccmp_377 ccmp ;
   struct __anonstruct_aes_cmac_378 aes_cmac ;
   struct __anonstruct_aes_gmac_379 aes_gmac ;
   struct __anonstruct_gcmp_380 gcmp ;
   struct __anonstruct_hw_381 hw ;
};
struct ieee80211_key_seq {
   union __anonunion____missing_field_name_375 __annonCompField100 ;
};
enum set_key_cmd {
    SET_KEY = 0,
    DISABLE_KEY = 1
} ;
enum ieee80211_sta_state {
    IEEE80211_STA_NOTEXIST = 0,
    IEEE80211_STA_NONE = 1,
    IEEE80211_STA_AUTH = 2,
    IEEE80211_STA_ASSOC = 3,
    IEEE80211_STA_AUTHORIZED = 4
} ;
enum sta_notify_cmd {
    STA_NOTIFY_SLEEP = 0,
    STA_NOTIFY_AWAKE = 1
} ;
struct ieee80211_tx_control {
   struct ieee80211_sta *sta ;
};
enum ieee80211_hw_flags {
    IEEE80211_HW_HAS_RATE_CONTROL = 0,
    IEEE80211_HW_RX_INCLUDES_FCS = 1,
    IEEE80211_HW_HOST_BROADCAST_PS_BUFFERING = 2,
    IEEE80211_HW_SIGNAL_UNSPEC = 3,
    IEEE80211_HW_SIGNAL_DBM = 4,
    IEEE80211_HW_NEED_DTIM_BEFORE_ASSOC = 5,
    IEEE80211_HW_SPECTRUM_MGMT = 6,
    IEEE80211_HW_AMPDU_AGGREGATION = 7,
    IEEE80211_HW_SUPPORTS_PS = 8,
    IEEE80211_HW_PS_NULLFUNC_STACK = 9,
    IEEE80211_HW_SUPPORTS_DYNAMIC_PS = 10,
    IEEE80211_HW_MFP_CAPABLE = 11,
    IEEE80211_HW_WANT_MONITOR_VIF = 12,
    IEEE80211_HW_NO_AUTO_VIF = 13,
    IEEE80211_HW_SW_CRYPTO_CONTROL = 14,
    IEEE80211_HW_SUPPORT_FAST_XMIT = 15,
    IEEE80211_HW_REPORTS_TX_ACK_STATUS = 16,
    IEEE80211_HW_CONNECTION_MONITOR = 17,
    IEEE80211_HW_QUEUE_CONTROL = 18,
    IEEE80211_HW_SUPPORTS_PER_STA_GTK = 19,
    IEEE80211_HW_AP_LINK_PS = 20,
    IEEE80211_HW_TX_AMPDU_SETUP_IN_HW = 21,
    IEEE80211_HW_SUPPORTS_RC_TABLE = 22,
    IEEE80211_HW_P2P_DEV_ADDR_FOR_INTF = 23,
    IEEE80211_HW_TIMING_BEACON_ONLY = 24,
    IEEE80211_HW_SUPPORTS_HT_CCK_RATES = 25,
    IEEE80211_HW_CHANCTX_STA_CSA = 26,
    IEEE80211_HW_SUPPORTS_CLONED_SKBS = 27,
    IEEE80211_HW_SINGLE_SCAN_ON_ALL_BANDS = 28,
    NUM_IEEE80211_HW_FLAGS = 29
} ;
struct ieee80211_scan_request {
   struct ieee80211_scan_ies ies ;
   struct cfg80211_scan_request req ;
};
struct ieee80211_tdls_ch_sw_params {
   struct ieee80211_sta *sta ;
   struct cfg80211_chan_def *chandef ;
   u8 action_code ;
   u32 status ;
   u32 timestamp ;
   u16 switch_time ;
   u16 switch_timeout ;
   struct sk_buff *tmpl_skb ;
   u32 ch_sw_tm_ie ;
};
enum ieee80211_ampdu_mlme_action {
    IEEE80211_AMPDU_RX_START = 0,
    IEEE80211_AMPDU_RX_STOP = 1,
    IEEE80211_AMPDU_TX_START = 2,
    IEEE80211_AMPDU_TX_STOP_CONT = 3,
    IEEE80211_AMPDU_TX_STOP_FLUSH = 4,
    IEEE80211_AMPDU_TX_STOP_FLUSH_CONT = 5,
    IEEE80211_AMPDU_TX_OPERATIONAL = 6
} ;
enum ieee80211_frame_release_type {
    IEEE80211_FRAME_RELEASE_PSPOLL = 0,
    IEEE80211_FRAME_RELEASE_UAPSD = 1
} ;
enum ieee80211_roc_type {
    IEEE80211_ROC_TYPE_NORMAL = 0,
    IEEE80211_ROC_TYPE_MGMT_TX = 1
} ;
enum ieee80211_reconfig_type {
    IEEE80211_RECONFIG_TYPE_RESTART = 0,
    IEEE80211_RECONFIG_TYPE_SUSPEND = 1
} ;
struct ieee80211_ops {
   void (*tx)(struct ieee80211_hw * , struct ieee80211_tx_control * , struct sk_buff * ) ;
   int (*start)(struct ieee80211_hw * ) ;
   void (*stop)(struct ieee80211_hw * ) ;
   int (*suspend)(struct ieee80211_hw * , struct cfg80211_wowlan * ) ;
   int (*resume)(struct ieee80211_hw * ) ;
   void (*set_wakeup)(struct ieee80211_hw * , bool  ) ;
   int (*add_interface)(struct ieee80211_hw * , struct ieee80211_vif * ) ;
   int (*change_interface)(struct ieee80211_hw * , struct ieee80211_vif * , enum nl80211_iftype  ,
                           bool  ) ;
   void (*remove_interface)(struct ieee80211_hw * , struct ieee80211_vif * ) ;
   int (*config)(struct ieee80211_hw * , u32  ) ;
   void (*bss_info_changed)(struct ieee80211_hw * , struct ieee80211_vif * , struct ieee80211_bss_conf * ,
                            u32  ) ;
   int (*start_ap)(struct ieee80211_hw * , struct ieee80211_vif * ) ;
   void (*stop_ap)(struct ieee80211_hw * , struct ieee80211_vif * ) ;
   u64 (*prepare_multicast)(struct ieee80211_hw * , struct netdev_hw_addr_list * ) ;
   void (*configure_filter)(struct ieee80211_hw * , unsigned int  , unsigned int * ,
                            u64  ) ;
   int (*set_tim)(struct ieee80211_hw * , struct ieee80211_sta * , bool  ) ;
   int (*set_key)(struct ieee80211_hw * , enum set_key_cmd  , struct ieee80211_vif * ,
                  struct ieee80211_sta * , struct ieee80211_key_conf * ) ;
   void (*update_tkip_key)(struct ieee80211_hw * , struct ieee80211_vif * , struct ieee80211_key_conf * ,
                           struct ieee80211_sta * , u32  , u16 * ) ;
   void (*set_rekey_data)(struct ieee80211_hw * , struct ieee80211_vif * , struct cfg80211_gtk_rekey_data * ) ;
   void (*set_default_unicast_key)(struct ieee80211_hw * , struct ieee80211_vif * ,
                                   int  ) ;
   int (*hw_scan)(struct ieee80211_hw * , struct ieee80211_vif * , struct ieee80211_scan_request * ) ;
   void (*cancel_hw_scan)(struct ieee80211_hw * , struct ieee80211_vif * ) ;
   int (*sched_scan_start)(struct ieee80211_hw * , struct ieee80211_vif * , struct cfg80211_sched_scan_request * ,
                           struct ieee80211_scan_ies * ) ;
   int (*sched_scan_stop)(struct ieee80211_hw * , struct ieee80211_vif * ) ;
   void (*sw_scan_start)(struct ieee80211_hw * , struct ieee80211_vif * , u8 const   * ) ;
   void (*sw_scan_complete)(struct ieee80211_hw * , struct ieee80211_vif * ) ;
   int (*get_stats)(struct ieee80211_hw * , struct ieee80211_low_level_stats * ) ;
   void (*get_key_seq)(struct ieee80211_hw * , struct ieee80211_key_conf * , struct ieee80211_key_seq * ) ;
   int (*set_frag_threshold)(struct ieee80211_hw * , u32  ) ;
   int (*set_rts_threshold)(struct ieee80211_hw * , u32  ) ;
   int (*sta_add)(struct ieee80211_hw * , struct ieee80211_vif * , struct ieee80211_sta * ) ;
   int (*sta_remove)(struct ieee80211_hw * , struct ieee80211_vif * , struct ieee80211_sta * ) ;
   void (*sta_add_debugfs)(struct ieee80211_hw * , struct ieee80211_vif * , struct ieee80211_sta * ,
                           struct dentry * ) ;
   void (*sta_remove_debugfs)(struct ieee80211_hw * , struct ieee80211_vif * , struct ieee80211_sta * ,
                              struct dentry * ) ;
   void (*sta_notify)(struct ieee80211_hw * , struct ieee80211_vif * , enum sta_notify_cmd  ,
                      struct ieee80211_sta * ) ;
   int (*sta_state)(struct ieee80211_hw * , struct ieee80211_vif * , struct ieee80211_sta * ,
                    enum ieee80211_sta_state  , enum ieee80211_sta_state  ) ;
   void (*sta_pre_rcu_remove)(struct ieee80211_hw * , struct ieee80211_vif * , struct ieee80211_sta * ) ;
   void (*sta_rc_update)(struct ieee80211_hw * , struct ieee80211_vif * , struct ieee80211_sta * ,
                         u32  ) ;
   void (*sta_rate_tbl_update)(struct ieee80211_hw * , struct ieee80211_vif * , struct ieee80211_sta * ) ;
   void (*sta_statistics)(struct ieee80211_hw * , struct ieee80211_vif * , struct ieee80211_sta * ,
                          struct station_info * ) ;
   int (*conf_tx)(struct ieee80211_hw * , struct ieee80211_vif * , u16  , struct ieee80211_tx_queue_params  const  * ) ;
   u64 (*get_tsf)(struct ieee80211_hw * , struct ieee80211_vif * ) ;
   void (*set_tsf)(struct ieee80211_hw * , struct ieee80211_vif * , u64  ) ;
   void (*reset_tsf)(struct ieee80211_hw * , struct ieee80211_vif * ) ;
   int (*tx_last_beacon)(struct ieee80211_hw * ) ;
   int (*ampdu_action)(struct ieee80211_hw * , struct ieee80211_vif * , enum ieee80211_ampdu_mlme_action  ,
                       struct ieee80211_sta * , u16  , u16 * , u8  ) ;
   int (*get_survey)(struct ieee80211_hw * , int  , struct survey_info * ) ;
   void (*rfkill_poll)(struct ieee80211_hw * ) ;
   void (*set_coverage_class)(struct ieee80211_hw * , s16  ) ;
   int (*testmode_cmd)(struct ieee80211_hw * , struct ieee80211_vif * , void * , int  ) ;
   int (*testmode_dump)(struct ieee80211_hw * , struct sk_buff * , struct netlink_callback * ,
                        void * , int  ) ;
   void (*flush)(struct ieee80211_hw * , struct ieee80211_vif * , u32  , bool  ) ;
   void (*channel_switch)(struct ieee80211_hw * , struct ieee80211_vif * , struct ieee80211_channel_switch * ) ;
   int (*set_antenna)(struct ieee80211_hw * , u32  , u32  ) ;
   int (*get_antenna)(struct ieee80211_hw * , u32 * , u32 * ) ;
   int (*remain_on_channel)(struct ieee80211_hw * , struct ieee80211_vif * , struct ieee80211_channel * ,
                            int  , enum ieee80211_roc_type  ) ;
   int (*cancel_remain_on_channel)(struct ieee80211_hw * ) ;
   int (*set_ringparam)(struct ieee80211_hw * , u32  , u32  ) ;
   void (*get_ringparam)(struct ieee80211_hw * , u32 * , u32 * , u32 * , u32 * ) ;
   bool (*tx_frames_pending)(struct ieee80211_hw * ) ;
   int (*set_bitrate_mask)(struct ieee80211_hw * , struct ieee80211_vif * , struct cfg80211_bitrate_mask  const  * ) ;
   void (*event_callback)(struct ieee80211_hw * , struct ieee80211_vif * , struct ieee80211_event  const  * ) ;
   void (*allow_buffered_frames)(struct ieee80211_hw * , struct ieee80211_sta * ,
                                 u16  , int  , enum ieee80211_frame_release_type  ,
                                 bool  ) ;
   void (*release_buffered_frames)(struct ieee80211_hw * , struct ieee80211_sta * ,
                                   u16  , int  , enum ieee80211_frame_release_type  ,
                                   bool  ) ;
   int (*get_et_sset_count)(struct ieee80211_hw * , struct ieee80211_vif * , int  ) ;
   void (*get_et_stats)(struct ieee80211_hw * , struct ieee80211_vif * , struct ethtool_stats * ,
                        u64 * ) ;
   void (*get_et_strings)(struct ieee80211_hw * , struct ieee80211_vif * , u32  ,
                          u8 * ) ;
   void (*mgd_prepare_tx)(struct ieee80211_hw * , struct ieee80211_vif * ) ;
   void (*mgd_protect_tdls_discover)(struct ieee80211_hw * , struct ieee80211_vif * ) ;
   int (*add_chanctx)(struct ieee80211_hw * , struct ieee80211_chanctx_conf * ) ;
   void (*remove_chanctx)(struct ieee80211_hw * , struct ieee80211_chanctx_conf * ) ;
   void (*change_chanctx)(struct ieee80211_hw * , struct ieee80211_chanctx_conf * ,
                          u32  ) ;
   int (*assign_vif_chanctx)(struct ieee80211_hw * , struct ieee80211_vif * , struct ieee80211_chanctx_conf * ) ;
   void (*unassign_vif_chanctx)(struct ieee80211_hw * , struct ieee80211_vif * , struct ieee80211_chanctx_conf * ) ;
   int (*switch_vif_chanctx)(struct ieee80211_hw * , struct ieee80211_vif_chanctx_switch * ,
                             int  , enum ieee80211_chanctx_switch_mode  ) ;
   void (*reconfig_complete)(struct ieee80211_hw * , enum ieee80211_reconfig_type  ) ;
   void (*ipv6_addr_change)(struct ieee80211_hw * , struct ieee80211_vif * , struct inet6_dev * ) ;
   void (*channel_switch_beacon)(struct ieee80211_hw * , struct ieee80211_vif * ,
                                 struct cfg80211_chan_def * ) ;
   int (*pre_channel_switch)(struct ieee80211_hw * , struct ieee80211_vif * , struct ieee80211_channel_switch * ) ;
   int (*post_channel_switch)(struct ieee80211_hw * , struct ieee80211_vif * ) ;
   int (*join_ibss)(struct ieee80211_hw * , struct ieee80211_vif * ) ;
   void (*leave_ibss)(struct ieee80211_hw * , struct ieee80211_vif * ) ;
   u32 (*get_expected_throughput)(struct ieee80211_sta * ) ;
   int (*get_txpower)(struct ieee80211_hw * , struct ieee80211_vif * , int * ) ;
   int (*tdls_channel_switch)(struct ieee80211_hw * , struct ieee80211_vif * , struct ieee80211_sta * ,
                              u8  , struct cfg80211_chan_def * , struct sk_buff * ,
                              u32  ) ;
   void (*tdls_cancel_channel_switch)(struct ieee80211_hw * , struct ieee80211_vif * ,
                                      struct ieee80211_sta * ) ;
   void (*tdls_recv_channel_switch)(struct ieee80211_hw * , struct ieee80211_vif * ,
                                    struct ieee80211_tdls_ch_sw_params * ) ;
   void (*wake_tx_queue)(struct ieee80211_hw * , struct ieee80211_txq * ) ;
};
union __anonunion___u_398___0 {
   struct tracepoint_func *__val ;
   char __c[1U] ;
};
union __anonunion___u_400___0 {
   struct tracepoint_func *__val ;
   char __c[1U] ;
};
struct iwl_notification_wait {
   struct list_head list ;
   bool (*fn)(struct iwl_notif_wait_data * , struct iwl_rx_packet * , void * ) ;
   void *fn_data ;
   u8 cmds[5U] ;
   u8 n_cmds ;
   bool triggered ;
   bool aborted ;
};
struct tkip_sc {
   __le16 iv16 ;
   __le16 pad ;
   __le32 iv32 ;
};
struct iwlagn_tkip_rsc_tsc {
   struct tkip_sc unicast_rsc[16U] ;
   struct tkip_sc multicast_rsc[16U] ;
   struct tkip_sc tsc ;
};
struct aes_sc {
   __le64 pn ;
};
struct iwlagn_aes_rsc_tsc {
   struct aes_sc unicast_rsc[16U] ;
   struct aes_sc multicast_rsc[16U] ;
   struct aes_sc tsc ;
};
union iwlagn_all_tsc_rsc {
   struct iwlagn_tkip_rsc_tsc tkip ;
   struct iwlagn_aes_rsc_tsc aes ;
};
struct iwlagn_wowlan_status {
   __le64 replay_ctr ;
   __le32 rekey_status ;
   __le32 wakeup_reason ;
   u8 pattern_number ;
   u8 reserved1 ;
   __le16 qos_seq_ctr[8U] ;
   __le16 non_qos_seq_ctr ;
   __le16 reserved2 ;
   union iwlagn_all_tsc_rsc tsc_rsc ;
   __le16 reserved3 ;
};
struct iwl_vif_priv {
   struct iwl_rxon_context *ctx ;
   u8 ibss_bssid_sta_id ;
};
struct iwl_resume_data {
   struct iwl_priv *priv ;
   struct iwlagn_wowlan_status *cmd ;
   bool valid ;
};
struct error_table_start {
   u32 valid ;
   u32 error_id ;
};
enum ldv_35989 {
    NONE = 0,
    ADD = 1,
    REMOVE = 2,
    HT_RATE_INIT = 3,
    ADD_RATE_INIT = 4
} ;
typedef struct ieee80211_hw *ldv_func_ret_type___11;
enum hrtimer_restart;
struct iwl_alive_resp {
   u8 ucode_minor ;
   u8 ucode_major ;
   __le16 reserved1 ;
   u8 sw_rev[8U] ;
   u8 ver_type ;
   u8 ver_subtype ;
   __le16 reserved2 ;
   __le32 log_event_table_ptr ;
   __le32 error_event_table_ptr ;
   __le32 timestamp ;
   __le32 is_valid ;
};
struct iwl_calib_hdr {
   u8 op_code ;
   u8 first_group ;
   u8 groups_num ;
   u8 data_valid ;
};
struct iwl_calib_xtal_freq_cmd {
   struct iwl_calib_hdr hdr ;
   u8 cap_pin1 ;
   u8 cap_pin2 ;
   u8 pad[2U] ;
};
struct iwl_calib_temperature_offset_cmd {
   struct iwl_calib_hdr hdr ;
   __le16 radio_sensor_offset ;
   __le16 reserved ;
};
struct iwl_calib_temperature_offset_v2_cmd {
   struct iwl_calib_hdr hdr ;
   __le16 radio_sensor_offset_high ;
   __le16 radio_sensor_offset_low ;
   __le16 burntVoltageRef ;
   __le16 reserved ;
};
struct iwl_wimax_coex_event_entry {
   u8 request_prio ;
   u8 win_medium_prio ;
   u8 reserved ;
   u8 flags ;
};
struct iwl_wimax_coex_cmd {
   u8 flags ;
   u8 reserved[3U] ;
   struct iwl_wimax_coex_event_entry sta_prio[16U] ;
};
struct iwl_bt_coex_prio_table_cmd {
   u8 prio_tbl[16U] ;
};
struct iwl_bt_coex_prot_env_cmd {
   u8 action ;
   u8 type ;
   u8 reserved[2U] ;
};
struct iwl_alive_data {
   bool valid ;
   u8 subtype ;
};
enum hrtimer_restart;
struct agg_tx_status {
   __le16 status ;
   __le16 sequence ;
};
struct iwlagn_tx_resp {
   u8 frame_count ;
   u8 bt_kill_count ;
   u8 failure_rts ;
   u8 failure_frame ;
   __le32 rate_n_flags ;
   __le16 wireless_media_time ;
   u8 pa_status ;
   u8 pa_integ_res_a[3U] ;
   u8 pa_integ_res_b[3U] ;
   u8 pa_integ_res_C[3U] ;
   __le32 tfd_info ;
   __le16 seq_ctl ;
   __le16 byte_cnt ;
   u8 tlc_info ;
   u8 ra_tid ;
   __le16 frame_ctrl ;
   struct agg_tx_status status ;
};
struct iwl_compressed_ba_resp {
   __le32 sta_addr_lo32 ;
   __le16 sta_addr_hi16 ;
   __le16 reserved ;
   u8 sta_id ;
   u8 tid ;
   __le16 seq_ctl ;
   __le64 bitmap ;
   __le16 scd_flow ;
   __le16 scd_ssn ;
   u8 txed ;
   u8 txed_2_done ;
   __le16 reserved1 ;
};
union __anonunion___u_482 {
   struct iwl_wipan_noa_data *__val ;
   char __c[1U] ;
};
enum hrtimer_restart;
struct iwlagn_tx_power_dbm_cmd {
   s8 global_lmt ;
   u8 flags ;
   s8 srv_chan_lmt ;
   u8 reserved ;
};
struct iwl_txfifo_flush_cmd_v3 {
   __le32 queue_control ;
   __le16 flush_control ;
   __le16 reserved ;
};
struct iwl_txfifo_flush_cmd_v2 {
   __le16 queue_control ;
   __le16 flush_control ;
};
struct iwl_basic_bt_cmd {
   u8 flags ;
   u8 ledtime ;
   u8 max_kill ;
   u8 bt3_timer_t7_value ;
   __le32 kill_ack_mask ;
   __le32 kill_cts_mask ;
   u8 bt3_prio_sample_time ;
   u8 bt3_timer_t2_value ;
   __le16 bt4_reaction_time ;
   __le32 bt3_lookup_table[12U] ;
   u8 reduce_txpower ;
   u8 reserved ;
   __le16 valid ;
};
struct iwl_bt_cmd_v1 {
   struct iwl_basic_bt_cmd basic ;
   u8 prio_boost ;
   u8 tx_prio_boost ;
   __le16 rx_prio_boost ;
};
struct iwl_bt_cmd_v2 {
   struct iwl_basic_bt_cmd basic ;
   __le32 prio_boost ;
   u8 reserved ;
   u8 tx_prio_boost ;
   __le16 rx_prio_boost ;
};
struct iwl_bt_uart_msg {
   u8 header ;
   u8 frame1 ;
   u8 frame2 ;
   u8 frame3 ;
   u8 frame4 ;
   u8 frame5 ;
   u8 frame6 ;
   u8 frame7 ;
};
struct iwl_bt_coex_profile_notif {
   struct iwl_bt_uart_msg last_bt_uart_msg ;
   u8 bt_status ;
   u8 bt_traffic_load ;
   u8 bt_ci_compliance ;
   u8 reserved ;
};
struct iwlagn_d3_config_cmd {
   __le32 min_sleep_time ;
   __le32 wakeup_flags ;
};
struct iwlagn_wowlan_pattern {
   u8 mask[16U] ;
   u8 pattern[128U] ;
   u8 mask_size ;
   u8 pattern_size ;
   __le16 reserved ;
};
struct iwlagn_wowlan_patterns_cmd {
   __le32 n_patterns ;
   struct iwlagn_wowlan_pattern patterns[] ;
};
struct iwlagn_wowlan_wakeup_filter_cmd {
   __le32 enabled ;
   __le16 non_qos_seq ;
   __le16 reserved ;
   __le16 qos_seq[8U] ;
};
struct iwlagn_wowlan_rsc_tsc_params_cmd {
   union iwlagn_all_tsc_rsc all_tsc_rsc ;
};
struct iwlagn_mic_keys {
   u8 tx[8U] ;
   u8 rx_unicast[8U] ;
   u8 rx_mcast[8U] ;
};
struct iwlagn_p1k_cache {
   __le16 p1k[5U] ;
};
struct iwlagn_wowlan_tkip_params_cmd {
   struct iwlagn_mic_keys mic_keys ;
   struct iwlagn_p1k_cache tx ;
   struct iwlagn_p1k_cache rx_uni[2U] ;
   struct iwlagn_p1k_cache rx_multi[2U] ;
};
struct iwlagn_wowlan_kek_kck_material_cmd {
   u8 kck[32U] ;
   u8 kek[32U] ;
   __le16 kck_len ;
   __le16 kek_len ;
   __le64 replay_ctr ;
};
struct wowlan_key_data {
   struct iwl_rxon_context *ctx ;
   struct iwlagn_wowlan_rsc_tsc_params_cmd *rsc_tsc ;
   struct iwlagn_wowlan_tkip_params_cmd *tkip ;
   u8 const   *bssid ;
   bool error ;
   bool use_rsc_tsc ;
   bool use_tkip ;
};
typedef bool ldv_func_ret_type___12;
enum hrtimer_restart;
struct iwl_sensitivity_cmd {
   __le16 control ;
   __le16 table[11U] ;
};
struct iwl_enhance_sensitivity_cmd {
   __le16 control ;
   __le16 enhance_table[23U] ;
};
struct iwl_calib_chain_noise_gain_cmd {
   struct iwl_calib_hdr hdr ;
   u8 delta_gain_1 ;
   u8 delta_gain_2 ;
   u8 pad[2U] ;
};
struct iwl_calib_result {
   struct list_head list ;
   size_t cmd_len ;
   struct iwl_calib_hdr hdr ;
};
struct statistics_general_data {
   u32 beacon_silence_rssi_a ;
   u32 beacon_silence_rssi_b ;
   u32 beacon_silence_rssi_c ;
   u32 beacon_energy_a ;
   u32 beacon_energy_b ;
   u32 beacon_energy_c ;
};
enum hrtimer_restart;
union __anonunion___u_386 {
   struct tracepoint_func *__val ;
   char __c[1U] ;
};
union __anonunion___u_388 {
   struct tracepoint_func *__val ;
   char __c[1U] ;
};
union __anonunion___u_394 {
   struct tracepoint_func *__val ;
   char __c[1U] ;
};
union __anonunion___u_396 {
   struct tracepoint_func *__val ;
   char __c[1U] ;
};
typedef int ldv_func_ret_type___13;
    klee_make_symbolic(&ldv_func_ret_type___13, sizeof(int), "ldv_func_ret_type___13");
typedef int ldv_func_ret_type___14;
    klee_make_symbolic(&ldv_func_ret_type___14, sizeof(int), "ldv_func_ret_type___14");
typedef int ldv_func_ret_type___15;
    klee_make_symbolic(&ldv_func_ret_type___15, sizeof(int), "ldv_func_ret_type___15");
typedef int ldv_func_ret_type___16;
    klee_make_symbolic(&ldv_func_ret_type___16, sizeof(int), "ldv_func_ret_type___16");
typedef bool ldv_func_ret_type___17;
typedef bool ldv_func_ret_type___18;
typedef bool ldv_func_ret_type___19;
enum hrtimer_restart;
struct iwl_add_sta_resp {
   u8 status ;
};
struct iwl_rem_sta_resp {
   u8 status ;
};
struct iwl_rem_sta_cmd {
   u8 num_sta ;
   u8 reserved[3U] ;
   u8 addr[6U] ;
   u8 reserved2[2U] ;
};
struct iwl_wep_cmd {
   u8 num_keys ;
   u8 global_key_type ;
   u8 flags ;
   u8 reserved ;
   struct iwl_wep_key key[0U] ;
};
enum hrtimer_restart;
struct ieee80211_rx_status;
struct ieee80211_rx_status {
   u64 mactime ;
   u32 device_timestamp ;
   u32 ampdu_reference ;
   u32 flag ;
   u16 freq ;
   u8 vht_flag ;
   u8 rate_idx ;
   u8 vht_nss ;
   u8 rx_flags ;
   u8 band ;
   u8 antenna ;
   s8 signal ;
   u8 chains ;
   s8 chain_signal[4U] ;
   u8 ampdu_delimiter_crc ;
};
union __anonunion___u_398___1 {
   struct tracepoint_func *__val ;
   char __c[1U] ;
};
union __anonunion___u_400___1 {
   struct tracepoint_func *__val ;
   char __c[1U] ;
};
struct iwl_error_resp {
   __le32 error_type ;
   u8 cmd_id ;
   u8 reserved1 ;
   __le16 bad_cmd_seq_num ;
   __le32 error_info ;
   __le64 timestamp ;
};
struct iwl_csa_notification {
   __le16 band ;
   __le16 channel ;
   __le32 status ;
};
struct iwlagn_non_cfg_phy {
   __le32 non_cfg_phy[8U] ;
};
struct iwl_rx_mpdu_res_start {
   __le16 byte_count ;
   __le16 reserved ;
};
struct iwl_sleep_notification {
   u8 pm_sleep_mode ;
   u8 pm_wakeup_src ;
   __le16 reserved ;
   __le32 sleep_time ;
   __le32 tsf_low ;
   __le32 bcon_timer ;
};
struct iwl_card_state_notif {
   __le32 flags ;
};
struct iwlagn_beacon_notif {
   struct iwlagn_tx_resp beacon_notify_hdr ;
   __le32 low_tsf ;
   __le32 high_tsf ;
   __le32 ibss_mgr_status ;
};
struct statistics_rx_non_phy_bt {
   struct statistics_rx_non_phy common ;
   __le32 num_bt_kills ;
   __le32 reserved[2U] ;
};
struct statistics_rx {
   struct statistics_rx_phy ofdm ;
   struct statistics_rx_phy cck ;
   struct statistics_rx_non_phy general ;
   struct statistics_rx_ht_phy ofdm_ht ;
};
struct statistics_rx_bt {
   struct statistics_rx_phy ofdm ;
   struct statistics_rx_phy cck ;
   struct statistics_rx_non_phy_bt general ;
   struct statistics_rx_ht_phy ofdm_ht ;
};
struct statistics_general {
   struct statistics_general_common common ;
   __le32 reserved2 ;
   __le32 reserved3 ;
};
struct statistics_general_bt {
   struct statistics_general_common common ;
   struct statistics_bt_activity activity ;
   __le32 reserved2 ;
   __le32 reserved3 ;
};
struct iwl_notif_statistics {
   __le32 flag ;
   struct statistics_rx rx ;
   struct statistics_tx tx ;
   struct statistics_general general ;
};
struct iwl_bt_notif_statistics {
   __le32 flag ;
   struct statistics_rx_bt rx ;
   struct statistics_tx tx ;
   struct statistics_general_bt general ;
};
struct iwl_missed_beacon_notif {
   __le32 consecutive_missed_beacons ;
   __le32 total_missed_becons ;
   __le32 num_expected_beacons ;
   __le32 num_recvd_beacons ;
};
struct iwl_wipan_noa_descriptor {
   u8 count ;
   __le32 duration ;
   __le32 interval ;
   __le32 starttime ;
};
struct iwl_wipan_noa_attribute {
   u8 id ;
   __le16 length ;
   u8 index ;
   u8 ct_window ;
   struct iwl_wipan_noa_descriptor descr0 ;
   struct iwl_wipan_noa_descriptor descr1 ;
   u8 reserved ;
};
struct iwl_wipan_noa_notification {
   u32 noa_active ;
   struct iwl_wipan_noa_attribute noa_attribute ;
};
enum hrtimer_restart;
enum iwl_power_level {
    IWL_POWER_INDEX_1 = 0,
    IWL_POWER_INDEX_2 = 1,
    IWL_POWER_INDEX_3 = 2,
    IWL_POWER_INDEX_4 = 3,
    IWL_POWER_INDEX_5 = 4,
    IWL_POWER_NUM = 5
} ;
struct iwl_power_vec_entry {
   struct iwl_powertable_cmd cmd ;
   u8 no_dtim ;
};
enum hrtimer_restart;
struct iwl_scan_channel {
   __le32 type ;
   __le16 channel ;
   u8 tx_gain ;
   u8 dsp_atten ;
   __le16 active_dwell ;
   __le16 passive_dwell ;
};
struct iwl_ssid_ie {
   u8 id ;
   u8 len ;
   u8 ssid[32U] ;
};
struct iwl_scan_cmd {
   __le16 len ;
   u8 scan_flags ;
   u8 channel_count ;
   __le16 quiet_time ;
   __le16 quiet_plcp_th ;
   __le16 good_CRC_th ;
   __le16 rx_chain ;
   __le32 max_out_time ;
   __le32 suspend_time ;
   __le32 flags ;
   __le32 filter_flags ;
   struct iwl_tx_cmd tx_cmd ;
   struct iwl_ssid_ie direct_scan[20U] ;
   u8 data[0U] ;
};
struct iwl_scanreq_notification {
   __le32 status ;
};
struct iwl_scanstart_notification {
   __le32 tsf_low ;
   __le32 tsf_high ;
   __le32 beacon_timer ;
   u8 channel ;
   u8 band ;
   u8 reserved[2U] ;
   __le32 status ;
};
struct iwl_scanresults_notification {
   u8 channel ;
   u8 band ;
   u8 probe_status ;
   u8 num_probe_not_sent ;
   __le32 tsf_low ;
   __le32 tsf_high ;
   __le32 statistics[1U] ;
};
struct iwl_scancomplete_notification {
   u8 scanned_channels ;
   u8 status ;
   u8 bt_status ;
   u8 last_channel ;
   __le32 tsf_low ;
   __le32 tsf_high ;
};
typedef bool ldv_func_ret_type___20;
enum hrtimer_restart;
struct iwl_rxon_assoc_cmd {
   __le32 flags ;
   __le32 filter_flags ;
   u8 ofdm_basic_rates ;
   u8 cck_basic_rates ;
   __le16 reserved1 ;
   u8 ofdm_ht_single_stream_basic_rates ;
   u8 ofdm_ht_dual_stream_basic_rates ;
   u8 ofdm_ht_triple_stream_basic_rates ;
   u8 reserved2 ;
   __le16 rx_chain_select_flags ;
   __le16 acquisition_data ;
   __le32 reserved3 ;
};
struct iwl_calib_chain_noise_reset_cmd {
   struct iwl_calib_hdr hdr ;
   u8 data[0U] ;
};
struct iwl_wipan_slot {
   __le16 width ;
   u8 type ;
   u8 reserved ;
};
struct iwl_wipan_params_cmd {
   __le16 flags ;
   u8 reserved ;
   u8 num_slots ;
   struct iwl_wipan_slot slots[10U] ;
};
enum hrtimer_restart;
union __anonunion___u_394___0 {
   struct tracepoint_func *__val ;
   char __c[1U] ;
};
union __anonunion___u_396___0 {
   struct tracepoint_func *__val ;
   char __c[1U] ;
};
struct iwl5000_channel_switch_cmd {
   u8 band ;
   u8 expect_beacon ;
   __le16 channel ;
   __le32 rxon_flags ;
   __le32 rxon_filter_flags ;
   __le32 switch_time ;
   __le32 reserved[2U][26U] ;
};
struct iwl6000_channel_switch_cmd {
   u8 band ;
   u8 expect_beacon ;
   __le16 channel ;
   __le32 rxon_flags ;
   __le32 rxon_filter_flags ;
   __le32 switch_time ;
   __le32 reserved[3U][26U] ;
};
enum hrtimer_restart;
struct ieee80211_tpt_blink {
   int throughput ;
    klee_make_symbolic(&throughput, sizeof(int), "throughput");
   int blink_time ;
    klee_make_symbolic(&blink_time, sizeof(int), "blink_time");
};
union __anonunion___u_390___0 {
   struct tracepoint_func *__val ;
   char __c[1U] ;
};
union __anonunion___u_392___0 {
   struct tracepoint_func *__val ;
   char __c[1U] ;
};
union __anonunion___u_398___2 {
   struct tracepoint_func *__val ;
   char __c[1U] ;
};
union __anonunion___u_400___2 {
   struct tracepoint_func *__val ;
   char __c[1U] ;
};
struct iwl_led_cmd {
   __le32 interval ;
   u8 id ;
   u8 off ;
   u8 on ;
   u8 reserved ;
};
enum hrtimer_restart;
union __anonunion___u_386___0 {
   struct tracepoint_func *__val ;
   char __c[1U] ;
};
union __anonunion___u_388___0 {
   struct tracepoint_func *__val ;
   char __c[1U] ;
};
__inline static long ldv__builtin_expect(long exp , long c ) ;
__inline static void __read_once_size(void const volatile   *p , void *res , int size ) 
{ 


  {
  switch (size) {
  case 1: 
  *((__u8 *)res) = *((__u8 volatile   *)p);
  goto ldv_880;
  case 2: 
  *((__u16 *)res) = *((__u16 volatile   *)p);
  goto ldv_880;
  case 4: 
  *((__u32 *)res) = *((__u32 volatile   *)p);
  goto ldv_880;
  case 8: 
  *((__u64 *)res) = *((__u64 volatile   *)p);
  goto ldv_880;
  default: 
  __asm__  volatile   ("": : : "memory");
  memcpy(res, (void const   *)p, (unsigned long )size);
  __asm__  volatile   ("": : : "memory");
  }
  ldv_880: ;
  return;
}
}
extern struct pv_irq_ops pv_irq_ops ;
__inline static void set_bit(long nr , unsigned long volatile   *addr ) 
{ 


  {
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; bts %1,%0": "+m" (*((long volatile   *)addr)): "Ir" (nr): "memory");
  return;
}
}
__inline static void clear_bit(long nr , unsigned long volatile   *addr ) 
{ 


  {
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; btr %1,%0": "+m" (*((long volatile   *)addr)): "Ir" (nr));
  return;
}
}
__inline static int test_and_set_bit(long nr , unsigned long volatile   *addr ) 
{ 
  char c ;
    klee_make_symbolic(&c, sizeof(char), "c");

  {
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; bts %2, %0; setc %1": "+m" (*addr),
                       "=qm" (c): "Ir" (nr): "memory");
  return ((int )((signed char )c) != 0);
}
}
__inline static int test_and_clear_bit(long nr , unsigned long volatile   *addr ) 
{ 
  char c ;

  {
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; btr %2, %0; setc %1": "+m" (*addr),
                       "=qm" (c): "Ir" (nr): "memory");
  return ((int )((signed char )c) != 0);
}
}
__inline static int constant_test_bit(long nr , unsigned long const volatile   *addr ) 
{ 


  {
  return ((int )((unsigned long )*(addr + (unsigned long )(nr >> 6)) >> ((int )nr & 63)) & 1);
}
}
__inline static int variable_test_bit(long nr , unsigned long const volatile   *addr ) 
{ 
  int oldbit ;
    klee_make_symbolic(&oldbit, sizeof(int), "oldbit");

  {
  __asm__  volatile   ("bt %2,%1\n\tsbb %0,%0": "=r" (oldbit): "m" (*((unsigned long *)addr)),
                       "Ir" (nr));
  return (oldbit);
}
}
extern int printk(char const   *  , ...) ;
extern void __might_sleep(char const   * , int  , int  ) ;
extern int snprintf(char * , size_t  , char const   *  , ...) ;
extern int scnprintf(char * , size_t  , char const   *  , ...) ;
__inline static void INIT_LIST_HEAD(struct list_head *list ) 
{ 


  {
  list->next = list;
  list->prev = list;
  return;
}
}
extern void __bad_percpu_size(void) ;
extern void warn_slowpath_null(char const   * , int const    ) ;
extern void *memcpy(void * , void const   * , size_t  ) ;
extern void *memset(void * , int  , size_t  ) ;
__inline static unsigned long arch_local_save_flags(void) 
{ 
  unsigned long __ret ;
    klee_make_symbolic(&__ret, sizeof(long), "__ret");
  unsigned long __edi ;
    klee_make_symbolic(&__edi, sizeof(long), "__edi");
  unsigned long __esi ;
    klee_make_symbolic(&__esi, sizeof(long), "__esi");
  unsigned long __edx ;
    klee_make_symbolic(&__edx, sizeof(long), "__edx");
  unsigned long __ecx ;
    klee_make_symbolic(&__ecx, sizeof(long), "__ecx");
  unsigned long __eax ;
    klee_make_symbolic(&__eax, sizeof(long), "__eax");
  long tmp ;
    klee_make_symbolic(&tmp, sizeof(long), "tmp");

  {
  __edi = __edi;
  __esi = __esi;
  __edx = __edx;
  __ecx = __ecx;
  __eax = __eax;
  tmp = ldv__builtin_expect((unsigned long )pv_irq_ops.save_fl.func == (unsigned long )((void *)0),
                         0L);
  if (tmp != 0L) {
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"./arch/x86/include/asm/paravirt.h"),
                         "i" (831), "i" (12UL));
    ldv_4860: ;
    goto ldv_4860;
  } else {

  }
  __asm__  volatile   ("771:\n\tcall *%c2;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c1\n  .byte 772b-771b\n  .short %c3\n.popsection\n": "=a" (__eax): [paravirt_typenum] "i" (43UL),
                       [paravirt_opptr] "i" (& pv_irq_ops.save_fl.func), [paravirt_clobber] "i" (1): "memory",
                       "cc");
  __ret = __eax;
  return (__ret);
}
}
__inline static int arch_irqs_disabled_flags(unsigned long flags ) 
{ 


  {
  return ((flags & 512UL) == 0UL);
}
}
extern void __xadd_wrong_size(void) ;
__inline static int atomic_read(atomic_t const   *v ) 
{ 
  int __var ;
    klee_make_symbolic(&__var, sizeof(int), "__var");

  {
  __var = 0;
  return ((int )*((int const volatile   *)(& v->counter)));
}
}
__inline static void atomic_set(atomic_t *v , int i ) 
{ 


  {
  v->counter = i;
  return;
}
}
__inline static int atomic_add_return(int i , atomic_t *v ) 
{ 
  int __ret ;

  {
  __ret = i;
  switch (4UL) {
  case 1UL: 
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; xaddb %b0, %1\n": "+q" (__ret),
                       "+m" (v->counter): : "memory", "cc");
  goto ldv_5659;
  case 2UL: 
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; xaddw %w0, %1\n": "+r" (__ret),
                       "+m" (v->counter): : "memory", "cc");
  goto ldv_5659;
  case 4UL: 
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; xaddl %0, %1\n": "+r" (__ret),
                       "+m" (v->counter): : "memory", "cc");
  goto ldv_5659;
  case 8UL: 
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; xaddq %q0, %1\n": "+r" (__ret),
                       "+m" (v->counter): : "memory", "cc");
  goto ldv_5659;
  default: 
  __xadd_wrong_size();
  }
  ldv_5659: ;
  return (__ret + i);
}
}
__inline static int atomic_sub_return(int i , atomic_t *v ) 
{ 
  int tmp ;

  {
  tmp = atomic_add_return(- i, v);
  return (tmp);
}
}
extern int __preempt_count ;
    klee_make_symbolic(&__preempt_count, sizeof(int), "__preempt_count");
__inline static int preempt_count(void) 
{ 
  int pfo_ret__ ;
    klee_make_symbolic(&pfo_ret__, sizeof(int), "pfo_ret__");

  {
  switch (4UL) {
  case 1UL: 
  __asm__  ("movb %%gs:%1,%0": "=q" (pfo_ret__): "m" (__preempt_count));
  goto ldv_6002;
  case 2UL: 
  __asm__  ("movw %%gs:%1,%0": "=r" (pfo_ret__): "m" (__preempt_count));
  goto ldv_6002;
  case 4UL: 
  __asm__  ("movl %%gs:%1,%0": "=r" (pfo_ret__): "m" (__preempt_count));
  goto ldv_6002;
  case 8UL: 
  __asm__  ("movq %%gs:%1,%0": "=r" (pfo_ret__): "m" (__preempt_count));
  goto ldv_6002;
  default: 
  __bad_percpu_size();
  }
  ldv_6002: ;
  return (pfo_ret__ & 2147483647);
}
}
__inline static void __preempt_count_add(int val ) 
{ 
  int pao_ID__ ;
    klee_make_symbolic(&pao_ID__, sizeof(int), "pao_ID__");

  {
  pao_ID__ = 0;
  switch (4UL) {
  case 1UL: ;
  if (pao_ID__ == 1) {
    __asm__  ("incb %%gs:%0": "+m" (__preempt_count));
  } else
  if (pao_ID__ == -1) {
    __asm__  ("decb %%gs:%0": "+m" (__preempt_count));
  } else {
    __asm__  ("addb %1, %%gs:%0": "+m" (__preempt_count): "qi" (val));
  }
  goto ldv_6059;
  case 2UL: ;
  if (pao_ID__ == 1) {
    __asm__  ("incw %%gs:%0": "+m" (__preempt_count));
  } else
  if (pao_ID__ == -1) {
    __asm__  ("decw %%gs:%0": "+m" (__preempt_count));
  } else {
    __asm__  ("addw %1, %%gs:%0": "+m" (__preempt_count): "ri" (val));
  }
  goto ldv_6059;
  case 4UL: ;
  if (pao_ID__ == 1) {
    __asm__  ("incl %%gs:%0": "+m" (__preempt_count));
  } else
  if (pao_ID__ == -1) {
    __asm__  ("decl %%gs:%0": "+m" (__preempt_count));
  } else {
    __asm__  ("addl %1, %%gs:%0": "+m" (__preempt_count): "ri" (val));
  }
  goto ldv_6059;
  case 8UL: ;
  if (pao_ID__ == 1) {
    __asm__  ("incq %%gs:%0": "+m" (__preempt_count));
  } else
  if (pao_ID__ == -1) {
    __asm__  ("decq %%gs:%0": "+m" (__preempt_count));
  } else {
    __asm__  ("addq %1, %%gs:%0": "+m" (__preempt_count): "re" (val));
  }
  goto ldv_6059;
  default: 
  __bad_percpu_size();
  }
  ldv_6059: ;
  return;
}
}
__inline static void __preempt_count_sub(int val ) 
{ 
  int pao_ID__ ;

  {
  pao_ID__ = 0;
  switch (4UL) {
  case 1UL: ;
  if (pao_ID__ == 1) {
    __asm__  ("incb %%gs:%0": "+m" (__preempt_count));
  } else
  if (pao_ID__ == -1) {
    __asm__  ("decb %%gs:%0": "+m" (__preempt_count));
  } else {
    __asm__  ("addb %1, %%gs:%0": "+m" (__preempt_count): "qi" (- val));
  }
  goto ldv_6071;
  case 2UL: ;
  if (pao_ID__ == 1) {
    __asm__  ("incw %%gs:%0": "+m" (__preempt_count));
  } else
  if (pao_ID__ == -1) {
    __asm__  ("decw %%gs:%0": "+m" (__preempt_count));
  } else {
    __asm__  ("addw %1, %%gs:%0": "+m" (__preempt_count): "ri" (- val));
  }
  goto ldv_6071;
  case 4UL: ;
  if (pao_ID__ == 1) {
    __asm__  ("incl %%gs:%0": "+m" (__preempt_count));
  } else
  if (pao_ID__ == -1) {
    __asm__  ("decl %%gs:%0": "+m" (__preempt_count));
  } else {
    __asm__  ("addl %1, %%gs:%0": "+m" (__preempt_count): "ri" (- val));
  }
  goto ldv_6071;
  case 8UL: ;
  if (pao_ID__ == 1) {
    __asm__  ("incq %%gs:%0": "+m" (__preempt_count));
  } else
  if (pao_ID__ == -1) {
    __asm__  ("decq %%gs:%0": "+m" (__preempt_count));
  } else {
    __asm__  ("addq %1, %%gs:%0": "+m" (__preempt_count): "re" (- val));
  }
  goto ldv_6071;
  default: 
  __bad_percpu_size();
  }
  ldv_6071: ;
  return;
}
}
extern int debug_locks ;
    klee_make_symbolic(&debug_locks, sizeof(int), "debug_locks");
extern void lockdep_init_map(struct lockdep_map * , char const   * , struct lock_class_key * ,
                             int  ) ;
extern int lock_is_held(struct lockdep_map * ) ;
extern void lockdep_rcu_suspicious(char const   * , int const    , char const   * ) ;
__inline static int static_key_count(struct static_key *key ) 
{ 
  int tmp ;

  {
  tmp = atomic_read((atomic_t const   *)(& key->enabled));
  return (tmp);
}
}
__inline static bool static_key_false(struct static_key *key ) 
{ 
  int tmp ;
  long tmp___0 ;
    klee_make_symbolic(&tmp___0, sizeof(long), "tmp___0");

  {
  tmp = static_key_count(key);
  tmp___0 = ldv__builtin_expect(tmp > 0, 0L);
  if (tmp___0 != 0L) {
    return (1);
  } else {

  }
  return (0);
}
}
extern void __raw_spin_lock_init(raw_spinlock_t * , char const   * , struct lock_class_key * ) ;
extern void _raw_spin_lock_bh(raw_spinlock_t * ) ;
extern void _raw_spin_unlock_bh(raw_spinlock_t * ) ;
__inline static raw_spinlock_t *spinlock_check(spinlock_t *lock ) 
{ 


  {
  return (& lock->__annonCompField18.rlock);
}
}
__inline static void spin_lock_bh(spinlock_t *lock ) 
{ 


  {
  _raw_spin_lock_bh(& lock->__annonCompField18.rlock);
  return;
}
}
__inline static void spin_unlock_bh(spinlock_t *lock ) 
{ 


  {
  _raw_spin_unlock_bh(& lock->__annonCompField18.rlock);
  return;
}
}
extern void __mutex_init(struct mutex * , char const   * , struct lock_class_key * ) ;
extern void mutex_lock_nested(struct mutex * , unsigned int  ) ;
extern void mutex_unlock(struct mutex * ) ;
extern unsigned long volatile   jiffies ;
extern unsigned int jiffies_to_msecs(unsigned long const    ) ;
extern unsigned long __msecs_to_jiffies(unsigned int const    ) ;
__inline static unsigned long msecs_to_jiffies(unsigned int const   m ) 
{ 
  unsigned long tmp___0 ;

  {
  tmp___0 = __msecs_to_jiffies(m);
  return (tmp___0);
}
}
extern bool rcu_is_watching(void) ;
extern bool rcu_lockdep_current_cpu_online(void) ;
extern struct lockdep_map rcu_sched_lock_map ;
extern int debug_lockdep_rcu_enabled(void) ;
__inline static int rcu_read_lock_sched_held(void) 
{ 
  int lockdep_opinion ;
    klee_make_symbolic(&lockdep_opinion, sizeof(int), "lockdep_opinion");
  int tmp ;
  bool tmp___0 ;
  int tmp___1 ;
  bool tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
    klee_make_symbolic(&tmp___4, sizeof(int), "tmp___4");
  unsigned long _flags ;
  int tmp___5 ;
    klee_make_symbolic(&tmp___5, sizeof(int), "tmp___5");
  int tmp___6 ;
    klee_make_symbolic(&tmp___6, sizeof(int), "tmp___6");

  {
  lockdep_opinion = 0;
  tmp = debug_lockdep_rcu_enabled();
  if (tmp == 0) {
    return (1);
  } else {

  }
  tmp___0 = rcu_is_watching();
  if (tmp___0) {
    tmp___1 = 0;
  } else {
    tmp___1 = 1;
  }
  if (tmp___1) {
    return (0);
  } else {

  }
  tmp___2 = rcu_lockdep_current_cpu_online();
  if (tmp___2) {
    tmp___3 = 0;
  } else {
    tmp___3 = 1;
  }
  if (tmp___3) {
    return (0);
  } else {

  }
  if (debug_locks != 0) {
    lockdep_opinion = lock_is_held(& rcu_sched_lock_map);
  } else {

  }
  if (lockdep_opinion != 0) {
    tmp___6 = 1;
  } else {
    tmp___4 = preempt_count();
    if (tmp___4 != 0) {
      tmp___6 = 1;
    } else {
      _flags = arch_local_save_flags();
      tmp___5 = arch_irqs_disabled_flags(_flags);
      if (tmp___5 != 0) {
        tmp___6 = 1;
      } else {
        tmp___6 = 0;
      }
    }
  }
  return (tmp___6);
}
}
__inline static void rcu_read_lock_sched_notrace(void) 
{ 


  {
  __preempt_count_add(1);
  __asm__  volatile   ("": : : "memory");
  return;
}
}
__inline static void rcu_read_unlock_sched_notrace(void) 
{ 


  {
  __asm__  volatile   ("": : : "memory");
  __preempt_count_sub(1);
  return;
}
}
extern int mod_timer(struct timer_list * , unsigned long  ) ;
int ldv_mod_timer_10(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
int ldv_mod_timer_11(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
extern int del_timer_sync(struct timer_list * ) ;
int ldv_del_timer_sync_16(struct timer_list *ldv_func_arg1 ) ;
int ldv_del_timer_sync_17(struct timer_list *ldv_func_arg1 ) ;
extern void __init_work(struct work_struct * , int  ) ;
extern struct workqueue_struct *__alloc_workqueue_key(char const   * , unsigned int  ,
                                                      int  , struct lock_class_key * ,
                                                      char const   *  , ...) ;
extern void destroy_workqueue(struct workqueue_struct * ) ;
void ldv_destroy_workqueue_18(struct workqueue_struct *ldv_func_arg1 ) ;
void ldv_destroy_workqueue_21(struct workqueue_struct *ldv_func_arg1 ) ;
extern bool queue_work_on(int  , struct workqueue_struct * , struct work_struct * ) ;
bool ldv_queue_work_on_5(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                         struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_work_on_7(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                         struct work_struct *ldv_func_arg3 ) ;
extern bool queue_delayed_work_on(int  , struct workqueue_struct * , struct delayed_work * ,
                                  unsigned long  ) ;
bool ldv_queue_delayed_work_on_6(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                 struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
bool ldv_queue_delayed_work_on_9(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                 struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
extern void flush_workqueue(struct workqueue_struct * ) ;
void ldv_flush_workqueue_8(struct workqueue_struct *ldv_func_arg1 ) ;
void ldv_flush_workqueue_20(struct workqueue_struct *ldv_func_arg1 ) ;
extern bool cancel_work_sync(struct work_struct * ) ;
bool ldv_cancel_work_sync_12(struct work_struct *ldv_func_arg1 ) ;
bool ldv_cancel_work_sync_13(struct work_struct *ldv_func_arg1 ) ;
bool ldv_cancel_work_sync_14(struct work_struct *ldv_func_arg1 ) ;
bool ldv_cancel_work_sync_15(struct work_struct *ldv_func_arg1 ) ;
__inline static bool queue_work(struct workqueue_struct *wq , struct work_struct *work ) 
{ 
  bool tmp ;

  {
  tmp = ldv_queue_work_on_5(8192, wq, work);
  return (tmp);
}
}
extern void kfree(void const   * ) ;
extern void *ldv_malloc(size_t);
void *__kmalloc(size_t size, gfp_t t)
{
	return ldv_malloc(size);
}
extern void kmem_cache_free(struct kmem_cache * , void * ) ;
void *ldv_malloc(size_t size ) ;
__inline static void *kmalloc(size_t size , gfp_t flags ) 
{ 
  void *tmp___2 ;

  {
  tmp___2 = __kmalloc(size, flags);
  return (tmp___2);
}
}
void *ldv_zalloc(size_t size ) ;
__inline static void *kzalloc(size_t size , gfp_t flags ) 
{ 
  void *tmp ;

  {
  tmp = kmalloc(size, flags | 32768U);
  return (tmp);
}
}
extern void *malloc(size_t  ) ;
extern void *calloc(size_t  , size_t  ) ;
extern int __VERIFIER_nondet_int(void) ;
extern unsigned long __VERIFIER_nondet_ulong(void) ;
extern void abort(void);
void assume_abort_if_not(int cond) {
  if(!cond) {abort();}
}
void *ldv_malloc(size_t size ) 
{ 
  void *p ;
  void *tmp ;
  int tmp___0 ;

  {
  tmp___0 = __VERIFIER_nondet_int();
  if (tmp___0 != 0) {
    return ((void *)0);
  } else {
    tmp = malloc(size);
    p = tmp;
    assume_abort_if_not((unsigned long )p != (unsigned long )((void *)0));
    return (p);
  }
}
}
void *ldv_zalloc(size_t size ) 
{ 
  void *p ;
  void *tmp ;
  int tmp___0 ;

  {
  tmp___0 = __VERIFIER_nondet_int();
  if (tmp___0 != 0) {
    return ((void *)0);
  } else {
    tmp = calloc(1UL, size);
    p = tmp;
    assume_abort_if_not((unsigned long )p != (unsigned long )((void *)0));
    return (p);
  }
}
}
void *ldv_init_zalloc(size_t size ) 
{ 
  void *p ;
  void *tmp ;

  {
  tmp = calloc(1UL, size);
  p = tmp;
  assume_abort_if_not((unsigned long )p != (unsigned long )((void *)0));
  return (p);
}
}
void *ldv_memset(void *s , int c , size_t n ) 
{ 
  void *tmp ;

  {
  tmp = memset(s, c, n);
  return (tmp);
}
}
int ldv_undef_int(void) 
{ 
  int tmp ;

  {
  tmp = __VERIFIER_nondet_int();
  return (tmp);
}
}
unsigned long ldv_undef_ulong(void) 
{ 
  unsigned long tmp ;

  {
  tmp = __VERIFIER_nondet_ulong();
  return (tmp);
}
}
__inline static void ldv_stop(void) 
{ 


  {
  LDV_STOP: ;
  goto LDV_STOP;
}
}
__inline static long ldv__builtin_expect(long exp , long c ) 
{ 


  {
  return (exp);
}
}
struct work_struct *ldv_work_struct_9_2  ;
int ldv_state_variable_47  ;
    klee_make_symbolic(&ldv_state_variable_47, sizeof(int), "ldv_state_variable_47");
int ldv_state_variable_20  ;
    klee_make_symbolic(&ldv_state_variable_20, sizeof(int), "ldv_state_variable_20");
struct work_struct *ldv_work_struct_3_1  ;
int ldv_work_12_3  ;
    klee_make_symbolic(&ldv_work_12_3, sizeof(int), "ldv_work_12_3");
struct inode *iwl_dbgfs_ucode_rx_stats_ops_group1  ;
struct ieee80211_sta *rs_ops_group1  ;
int ldv_timer_16_0  ;
    klee_make_symbolic(&ldv_timer_16_0, sizeof(int), "ldv_timer_16_0");
int ldv_work_1_1  ;
    klee_make_symbolic(&ldv_work_1_1, sizeof(int), "ldv_work_1_1");
struct inode *iwl_dbgfs_txfifo_flush_ops_group1  ;
struct work_struct *ldv_work_struct_14_2  ;
int ldv_work_9_3  ;
    klee_make_symbolic(&ldv_work_9_3, sizeof(int), "ldv_work_9_3");
struct file *iwl_dbgfs_reply_tx_error_ops_group2  ;
struct file *iwl_dbgfs_echo_test_ops_group2  ;
struct work_struct *ldv_work_struct_14_0  ;
struct work_struct *ldv_work_struct_13_3  ;
int ldv_state_variable_54  ;
    klee_make_symbolic(&ldv_state_variable_54, sizeof(int), "ldv_state_variable_54");
int ldv_state_variable_14  ;
    klee_make_symbolic(&ldv_state_variable_14, sizeof(int), "ldv_state_variable_14");
int ldv_state_variable_37  ;
    klee_make_symbolic(&ldv_state_variable_37, sizeof(int), "ldv_state_variable_37");
int ldv_state_variable_17  ;
    klee_make_symbolic(&ldv_state_variable_17, sizeof(int), "ldv_state_variable_17");
int ldv_state_variable_51  ;
    klee_make_symbolic(&ldv_state_variable_51, sizeof(int), "ldv_state_variable_51");
struct work_struct *ldv_work_struct_10_1  ;
int ldv_work_7_2  ;
    klee_make_symbolic(&ldv_work_7_2, sizeof(int), "ldv_work_7_2");
int ldv_state_variable_66  ;
    klee_make_symbolic(&ldv_state_variable_66, sizeof(int), "ldv_state_variable_66");
int ldv_state_variable_19  ;
    klee_make_symbolic(&ldv_state_variable_19, sizeof(int), "ldv_state_variable_19");
struct work_struct *ldv_work_struct_4_3  ;
int ldv_state_variable_27  ;
    klee_make_symbolic(&ldv_state_variable_27, sizeof(int), "ldv_state_variable_27");
int ldv_state_variable_9  ;
    klee_make_symbolic(&ldv_state_variable_9, sizeof(int), "ldv_state_variable_9");
struct inode *iwl_dbgfs_missed_beacon_ops_group1  ;
int ldv_work_13_0  ;
    klee_make_symbolic(&ldv_work_13_0, sizeof(int), "ldv_work_13_0");
struct work_struct *ldv_work_struct_7_1  ;
struct work_struct *ldv_work_struct_2_2  ;
int ldv_timer_15_3  ;
    klee_make_symbolic(&ldv_timer_15_3, sizeof(int), "ldv_timer_15_3");
struct inode *iwl_dbgfs_protection_mode_ops_group1  ;
struct inode *rs_sta_dbgfs_scale_table_ops_group1  ;
int ldv_state_variable_42  ;
    klee_make_symbolic(&ldv_state_variable_42, sizeof(int), "ldv_state_variable_42");
int ldv_work_3_3  ;
    klee_make_symbolic(&ldv_work_3_3, sizeof(int), "ldv_work_3_3");
struct timer_list *ldv_timer_list_15_0  ;
struct work_struct *ldv_work_struct_11_0  ;
struct work_struct *ldv_work_struct_4_0  ;
struct iwl_priv *iwl_dvm_6050_cfg_group0  ;
struct iwl_priv *iwl_dvm_6005_cfg_group0  ;
int ldv_state_variable_7  ;
    klee_make_symbolic(&ldv_state_variable_7, sizeof(int), "ldv_state_variable_7");
struct timer_list *ldv_timer_list_18_3  ;
struct file *iwl_dbgfs_nvm_ops_group2  ;
int ldv_state_variable_55  ;
    klee_make_symbolic(&ldv_state_variable_55, sizeof(int), "ldv_state_variable_55");
struct file *iwl_dbgfs_wowlan_sram_ops_group2  ;
struct inode *iwl_dbgfs_disable_ht40_ops_group1  ;
int ldv_work_1_3  ;
    klee_make_symbolic(&ldv_work_1_3, sizeof(int), "ldv_work_1_3");
struct work_struct *ldv_work_struct_2_1  ;
int ldv_work_4_0  ;
    klee_make_symbolic(&ldv_work_4_0, sizeof(int), "ldv_work_4_0");
struct work_struct *ldv_work_struct_3_2  ;
struct work_struct *ldv_work_struct_12_3  ;
struct work_struct *ldv_work_struct_7_2  ;
struct inode *iwl_dbgfs_plcp_delta_ops_group1  ;
int ldv_state_variable_64  ;
    klee_make_symbolic(&ldv_state_variable_64, sizeof(int), "ldv_state_variable_64");
int ldv_state_variable_26  ;
    klee_make_symbolic(&ldv_state_variable_26, sizeof(int), "ldv_state_variable_26");
struct file *iwl_dbgfs_power_save_status_ops_group2  ;
int ldv_work_13_1  ;
    klee_make_symbolic(&ldv_work_13_1, sizeof(int), "ldv_work_13_1");
int ldv_state_variable_28  ;
    klee_make_symbolic(&ldv_state_variable_28, sizeof(int), "ldv_state_variable_28");
struct file *iwl_dbgfs_rxon_flags_ops_group2  ;
struct work_struct *ldv_work_struct_7_0  ;
struct inode *iwl_dbgfs_sram_ops_group1  ;
int ldv_timer_18_0  ;
    klee_make_symbolic(&ldv_timer_18_0, sizeof(int), "ldv_timer_18_0");
struct iwl_op_mode *iwl_dvm_ops_group0  ;
int ldv_timer_16_1  ;
    klee_make_symbolic(&ldv_timer_16_1, sizeof(int), "ldv_timer_16_1");
int LDV_IN_INTERRUPT  =    1;
struct work_struct *ldv_work_struct_6_0  ;
struct file *iwl_dbgfs_ucode_tx_stats_ops_group2  ;
struct inode *iwl_dbgfs_current_sleep_command_ops_group1  ;
int ldv_work_8_3  ;
    klee_make_symbolic(&ldv_work_8_3, sizeof(int), "ldv_work_8_3");
struct file *iwl_dbgfs_thermal_throttling_ops_group2  ;
int ldv_state_variable_58  ;
    klee_make_symbolic(&ldv_state_variable_58, sizeof(int), "ldv_state_variable_58");
int ldv_timer_15_1  ;
    klee_make_symbolic(&ldv_timer_15_1, sizeof(int), "ldv_timer_15_1");
struct file *iwl_dbgfs_sleep_level_override_ops_group2  ;
int ldv_work_13_2  ;
    klee_make_symbolic(&ldv_work_13_2, sizeof(int), "ldv_work_13_2");
struct inode *iwl_dbgfs_wowlan_sram_ops_group1  ;
int ldv_work_14_3  ;
    klee_make_symbolic(&ldv_work_14_3, sizeof(int), "ldv_work_14_3");
int ldv_work_5_2  ;
    klee_make_symbolic(&ldv_work_5_2, sizeof(int), "ldv_work_5_2");
int ldv_work_7_1  ;
    klee_make_symbolic(&ldv_work_7_1, sizeof(int), "ldv_work_7_1");
int ldv_state_variable_31  ;
    klee_make_symbolic(&ldv_state_variable_31, sizeof(int), "ldv_state_variable_31");
struct inode *iwl_dbgfs_nvm_ops_group1  ;
int ldv_work_6_2  ;
    klee_make_symbolic(&ldv_work_6_2, sizeof(int), "ldv_work_6_2");
struct inode *iwl_dbgfs_echo_test_ops_group1  ;
int ldv_state_variable_68  ;
    klee_make_symbolic(&ldv_state_variable_68, sizeof(int), "ldv_state_variable_68");
struct timer_list *ldv_timer_list_16_3  ;
int ldv_work_2_1  ;
    klee_make_symbolic(&ldv_work_2_1, sizeof(int), "ldv_work_2_1");
int ldv_state_variable_8  ;
    klee_make_symbolic(&ldv_state_variable_8, sizeof(int), "ldv_state_variable_8");
int ldv_state_variable_46  ;
    klee_make_symbolic(&ldv_state_variable_46, sizeof(int), "ldv_state_variable_46");
struct inode *iwl_dbgfs_sleep_level_override_ops_group1  ;
int ldv_state_variable_15  ;
    klee_make_symbolic(&ldv_state_variable_15, sizeof(int), "ldv_state_variable_15");
struct file *iwl_dbgfs_log_event_ops_group2  ;
struct file *iwl_dbgfs_txfifo_flush_ops_group2  ;
struct work_struct *ldv_work_struct_1_3  ;
int ldv_work_8_0  ;
    klee_make_symbolic(&ldv_work_8_0, sizeof(int), "ldv_work_8_0");
struct file *iwl_dbgfs_rf_reset_ops_group2  ;
int ldv_work_14_2  ;
    klee_make_symbolic(&ldv_work_14_2, sizeof(int), "ldv_work_14_2");
int ldv_state_variable_21  ;
    klee_make_symbolic(&ldv_state_variable_21, sizeof(int), "ldv_state_variable_21");
int ldv_state_variable_33  ;
    klee_make_symbolic(&ldv_state_variable_33, sizeof(int), "ldv_state_variable_33");
struct work_struct *ldv_work_struct_13_2  ;
struct work_struct *ldv_work_struct_8_0  ;
struct file *iwl_dbgfs_temperature_ops_group2  ;
struct file *iwl_dbgfs_ucode_general_stats_ops_group2  ;
struct dentry *rs_ops_group2  ;
struct timer_list *ldv_timer_list_17_3  ;
int ldv_timer_15_0  ;
    klee_make_symbolic(&ldv_timer_15_0, sizeof(int), "ldv_timer_15_0");
int ldv_state_variable_69  ;
    klee_make_symbolic(&ldv_state_variable_69, sizeof(int), "ldv_state_variable_69");
struct timer_list *ldv_timer_list_18_1  ;
struct work_struct *ldv_work_struct_14_3  ;
struct file *iwl_dbgfs_protection_mode_ops_group2  ;
struct inode *iwl_dbgfs_rxon_flags_ops_group1  ;
struct file *iwl_dbgfs_stations_ops_group2  ;
int ldv_work_3_0  ;
    klee_make_symbolic(&ldv_work_3_0, sizeof(int), "ldv_work_3_0");
struct work_struct *ldv_work_struct_11_1  ;
int ldv_work_10_0  ;
    klee_make_symbolic(&ldv_work_10_0, sizeof(int), "ldv_work_10_0");
int ldv_state_variable_65  ;
    klee_make_symbolic(&ldv_state_variable_65, sizeof(int), "ldv_state_variable_65");
struct iwl_priv *iwl_dvm_6000_cfg_group0  ;
int ldv_work_12_2  ;
    klee_make_symbolic(&ldv_work_12_2, sizeof(int), "ldv_work_12_2");
struct timer_list *ldv_timer_list_15_3  ;
struct inode *iwl_dbgfs_fw_restart_ops_group1  ;
struct iwl_priv *iwl_dvm_5000_cfg_group0  ;
int ldv_state_variable_62  ;
    klee_make_symbolic(&ldv_state_variable_62, sizeof(int), "ldv_state_variable_62");
int ldv_state_variable_41  ;
    klee_make_symbolic(&ldv_state_variable_41, sizeof(int), "ldv_state_variable_41");
int ldv_work_5_3  ;
    klee_make_symbolic(&ldv_work_5_3, sizeof(int), "ldv_work_5_3");
struct file *iwl_dbgfs_bt_traffic_ops_group2  ;
struct timer_list *ldv_timer_list_17_2  ;
int ldv_state_variable_40  ;
    klee_make_symbolic(&ldv_state_variable_40, sizeof(int), "ldv_state_variable_40");
struct iwl_priv *iwl_dvm_105_cfg_group0  ;
int ldv_work_6_1  ;
    klee_make_symbolic(&ldv_work_6_1, sizeof(int), "ldv_work_6_1");
struct work_struct *ldv_work_struct_1_0  ;
struct inode *iwl_dbgfs_thermal_throttling_ops_group1  ;
struct iwl_priv *iwl_dvm_6030_cfg_group0  ;
int ldv_state_variable_10  ;
    klee_make_symbolic(&ldv_state_variable_10, sizeof(int), "ldv_state_variable_10");
int ldv_work_7_0  ;
    klee_make_symbolic(&ldv_work_7_0, sizeof(int), "ldv_work_7_0");
struct timer_list *ldv_timer_list_16_2  ;
struct work_struct *ldv_work_struct_12_0  ;
int ldv_work_4_1  ;
    klee_make_symbolic(&ldv_work_4_1, sizeof(int), "ldv_work_4_1");
struct inode *iwl_dbgfs_power_save_status_ops_group1  ;
int ldv_state_variable_63  ;
    klee_make_symbolic(&ldv_state_variable_63, sizeof(int), "ldv_state_variable_63");
int ldv_work_10_1  ;
    klee_make_symbolic(&ldv_work_10_1, sizeof(int), "ldv_work_10_1");
struct inode *rs_sta_dbgfs_rate_scale_data_ops_group1  ;
struct work_struct *ldv_work_struct_7_3  ;
struct inode *iwl_dbgfs_stations_ops_group1  ;
int ldv_state_variable_2  ;
    klee_make_symbolic(&ldv_state_variable_2, sizeof(int), "ldv_state_variable_2");
int ldv_state_variable_25  ;
    klee_make_symbolic(&ldv_state_variable_25, sizeof(int), "ldv_state_variable_25");
int ldv_work_2_0  ;
    klee_make_symbolic(&ldv_work_2_0, sizeof(int), "ldv_work_2_0");
struct work_struct *ldv_work_struct_10_0  ;
struct iwl_priv *iwl_dvm_2030_cfg_group0  ;
struct inode *iwl_dbgfs_ucode_general_stats_ops_group1  ;
int ldv_timer_18_2  ;
    klee_make_symbolic(&ldv_timer_18_2, sizeof(int), "ldv_timer_18_2");
int ldv_work_4_2  ;
    klee_make_symbolic(&ldv_work_4_2, sizeof(int), "ldv_work_4_2");
int ldv_state_variable_11  ;
    klee_make_symbolic(&ldv_state_variable_11, sizeof(int), "ldv_state_variable_11");
int ldv_work_1_2  ;
    klee_make_symbolic(&ldv_work_1_2, sizeof(int), "ldv_work_1_2");
struct iwl_priv *iwl_dvm_5150_cfg_group0  ;
int ldv_state_variable_18  ;
    klee_make_symbolic(&ldv_state_variable_18, sizeof(int), "ldv_state_variable_18");
struct work_struct *ldv_work_struct_5_0  ;
int ldv_timer_17_3  ;
    klee_make_symbolic(&ldv_timer_17_3, sizeof(int), "ldv_timer_17_3");
struct work_struct *ldv_work_struct_9_1  ;
int ldv_work_2_2  ;
    klee_make_symbolic(&ldv_work_2_2, sizeof(int), "ldv_work_2_2");
struct file *iwl_dbgfs_current_sleep_command_ops_group2  ;
int ldv_state_variable_32  ;
    klee_make_symbolic(&ldv_state_variable_32, sizeof(int), "ldv_state_variable_32");
int ldv_work_11_3  ;
    klee_make_symbolic(&ldv_work_11_3, sizeof(int), "ldv_work_11_3");
struct inode *iwl_dbgfs_ucode_bt_stats_ops_group1  ;
int ldv_work_11_2  ;
    klee_make_symbolic(&ldv_work_11_2, sizeof(int), "ldv_work_11_2");
int ldv_state_variable_30  ;
    klee_make_symbolic(&ldv_state_variable_30, sizeof(int), "ldv_state_variable_30");
struct file *iwl_dbgfs_fw_restart_ops_group2  ;
int ldv_work_8_1  ;
    klee_make_symbolic(&ldv_work_8_1, sizeof(int), "ldv_work_8_1");
int ldv_state_variable_0  ;
    klee_make_symbolic(&ldv_state_variable_0, sizeof(int), "ldv_state_variable_0");
int ldv_state_variable_45  ;
    klee_make_symbolic(&ldv_state_variable_45, sizeof(int), "ldv_state_variable_45");
struct file *iwl_dbgfs_rx_handlers_ops_group2  ;
int ldv_state_variable_12  ;
    klee_make_symbolic(&ldv_state_variable_12, sizeof(int), "ldv_state_variable_12");
struct work_struct *ldv_work_struct_13_1  ;
int ldv_state_variable_22  ;
    klee_make_symbolic(&ldv_state_variable_22, sizeof(int), "ldv_state_variable_22");
int ldv_state_variable_29  ;
    klee_make_symbolic(&ldv_state_variable_29, sizeof(int), "ldv_state_variable_29");
struct work_struct *ldv_work_struct_8_1  ;
struct work_struct *ldv_work_struct_2_0  ;
struct file *iwl_dbgfs_ucode_rx_stats_ops_group2  ;
int ldv_state_variable_61  ;
    klee_make_symbolic(&ldv_state_variable_61, sizeof(int), "ldv_state_variable_61");
int ldv_work_6_0  ;
    klee_make_symbolic(&ldv_work_6_0, sizeof(int), "ldv_work_6_0");
int ldv_work_9_0  ;
    klee_make_symbolic(&ldv_work_9_0, sizeof(int), "ldv_work_9_0");
struct inode *iwl_dbgfs_bt_traffic_ops_group1  ;
struct work_struct *ldv_work_struct_6_1  ;
int ref_cnt  ;
    klee_make_symbolic(&ref_cnt, sizeof(int), "ref_cnt");
struct inode *iwl_dbgfs_channels_ops_group1  ;
struct work_struct *ldv_work_struct_10_3  ;
struct work_struct *ldv_work_struct_8_3  ;
int ldv_timer_16_2  ;
    klee_make_symbolic(&ldv_timer_16_2, sizeof(int), "ldv_timer_16_2");
int ldv_state_variable_23  ;
    klee_make_symbolic(&ldv_state_variable_23, sizeof(int), "ldv_state_variable_23");
struct work_struct *ldv_work_struct_3_3  ;
struct timer_list *ldv_timer_list_15_2  ;
struct timer_list *ldv_timer_list_17_1  ;
struct work_struct *ldv_work_struct_1_1  ;
struct file *iwl_dbgfs_calib_disabled_ops_group2  ;
int ldv_state_variable_59  ;
    klee_make_symbolic(&ldv_state_variable_59, sizeof(int), "ldv_state_variable_59");
int ldv_state_variable_6  ;
    klee_make_symbolic(&ldv_state_variable_6, sizeof(int), "ldv_state_variable_6");
int ldv_work_5_0  ;
    klee_make_symbolic(&ldv_work_5_0, sizeof(int), "ldv_work_5_0");
struct timer_list *ldv_timer_list_15_1  ;
int ldv_state_variable_50  ;
    klee_make_symbolic(&ldv_state_variable_50, sizeof(int), "ldv_state_variable_50");
struct work_struct *ldv_work_struct_4_2  ;
struct timer_list *ldv_timer_list_16_1  ;
struct inode *iwl_dbgfs_clear_ucode_statistics_ops_group1  ;
int ldv_timer_17_2  ;
    klee_make_symbolic(&ldv_timer_17_2, sizeof(int), "ldv_timer_17_2");
struct file *iwl_dbgfs_ucode_tracing_ops_group2  ;
struct file *iwl_dbgfs_sensitivity_ops_group2  ;
struct file *rs_sta_dbgfs_rate_scale_data_ops_group2  ;
int ldv_state_variable_44  ;
    klee_make_symbolic(&ldv_state_variable_44, sizeof(int), "ldv_state_variable_44");
struct file *iwl_dbgfs_channels_ops_group2  ;
int ldv_state_variable_38  ;
    klee_make_symbolic(&ldv_state_variable_38, sizeof(int), "ldv_state_variable_38");
int ldv_timer_18_3  ;
    klee_make_symbolic(&ldv_timer_18_3, sizeof(int), "ldv_timer_18_3");
int ldv_state_variable_39  ;
    klee_make_symbolic(&ldv_state_variable_39, sizeof(int), "ldv_state_variable_39");
struct inode *iwl_dbgfs_log_event_ops_group1  ;
struct work_struct *ldv_work_struct_5_1  ;
int ldv_state_variable_56  ;
    klee_make_symbolic(&ldv_state_variable_56, sizeof(int), "ldv_state_variable_56");
int ldv_state_variable_3  ;
    klee_make_symbolic(&ldv_state_variable_3, sizeof(int), "ldv_state_variable_3");
struct work_struct *ldv_work_struct_12_1  ;
struct inode *iwl_dbgfs_status_ops_group1  ;
int ldv_state_variable_52  ;
    klee_make_symbolic(&ldv_state_variable_52, sizeof(int), "ldv_state_variable_52");
int ldv_work_11_0  ;
    klee_make_symbolic(&ldv_work_11_0, sizeof(int), "ldv_work_11_0");
int ldv_work_1_0  ;
    klee_make_symbolic(&ldv_work_1_0, sizeof(int), "ldv_work_1_0");
int ldv_timer_16_3  ;
    klee_make_symbolic(&ldv_timer_16_3, sizeof(int), "ldv_timer_16_3");
struct inode *iwl_dbgfs_chain_noise_ops_group1  ;
struct work_struct *ldv_work_struct_11_2  ;
struct iwl_priv *iwl_dvm_1000_cfg_group0  ;
int ldv_state_variable_4  ;
    klee_make_symbolic(&ldv_state_variable_4, sizeof(int), "ldv_state_variable_4");
struct work_struct *ldv_work_struct_9_0  ;
struct inode *iwl_dbgfs_temperature_ops_group1  ;
struct work_struct *ldv_work_struct_9_3  ;
int ldv_work_10_2  ;
    klee_make_symbolic(&ldv_work_10_2, sizeof(int), "ldv_work_10_2");
int ldv_state_variable_60  ;
    klee_make_symbolic(&ldv_state_variable_60, sizeof(int), "ldv_state_variable_60");
int ldv_state_variable_36  ;
    klee_make_symbolic(&ldv_state_variable_36, sizeof(int), "ldv_state_variable_36");
int ldv_work_9_2  ;
    klee_make_symbolic(&ldv_work_9_2, sizeof(int), "ldv_work_9_2");
struct work_struct *ldv_work_struct_13_0  ;
struct work_struct *ldv_work_struct_6_3  ;
int ldv_state_variable_48  ;
    klee_make_symbolic(&ldv_state_variable_48, sizeof(int), "ldv_state_variable_48");
struct work_struct *ldv_work_struct_5_2  ;
int ldv_work_9_1  ;
    klee_make_symbolic(&ldv_work_9_1, sizeof(int), "ldv_work_9_1");
int ldv_timer_15_2  ;
    klee_make_symbolic(&ldv_timer_15_2, sizeof(int), "ldv_timer_15_2");
int ldv_state_variable_5  ;
    klee_make_symbolic(&ldv_state_variable_5, sizeof(int), "ldv_state_variable_5");
struct work_struct *ldv_work_struct_5_3  ;
struct work_struct *ldv_work_struct_14_1  ;
int ldv_state_variable_13  ;
    klee_make_symbolic(&ldv_state_variable_13, sizeof(int), "ldv_state_variable_13");
struct timer_list *ldv_timer_list_17_0  ;
struct file *iwl_dbgfs_qos_ops_group2  ;
struct timer_list *ldv_timer_list_18_2  ;
struct inode *rs_sta_dbgfs_stats_table_ops_group1  ;
int ldv_timer_17_0  ;
    klee_make_symbolic(&ldv_timer_17_0, sizeof(int), "ldv_timer_17_0");
int ldv_work_3_2  ;
    klee_make_symbolic(&ldv_work_3_2, sizeof(int), "ldv_work_3_2");
struct ieee80211_hw *iwlagn_hw_ops_group0  ;
int ldv_work_13_3  ;
    klee_make_symbolic(&ldv_work_13_3, sizeof(int), "ldv_work_13_3");
struct work_struct *ldv_work_struct_2_3  ;
struct timer_list *ldv_timer_list_18_0  ;
struct file *iwl_dbgfs_plcp_delta_ops_group2  ;
int ldv_work_11_1  ;
    klee_make_symbolic(&ldv_work_11_1, sizeof(int), "ldv_work_11_1");
struct file *iwl_dbgfs_status_ops_group2  ;
int ldv_state_variable_49  ;
    klee_make_symbolic(&ldv_state_variable_49, sizeof(int), "ldv_state_variable_49");
struct inode *iwl_dbgfs_rx_handlers_ops_group1  ;
int ldv_state_variable_24  ;
    klee_make_symbolic(&ldv_state_variable_24, sizeof(int), "ldv_state_variable_24");
int ldv_work_7_3  ;
    klee_make_symbolic(&ldv_work_7_3, sizeof(int), "ldv_work_7_3");
struct file *iwl_dbgfs_rxon_filter_flags_ops_group2  ;
int ldv_work_12_0  ;
    klee_make_symbolic(&ldv_work_12_0, sizeof(int), "ldv_work_12_0");
int ldv_work_14_0  ;
    klee_make_symbolic(&ldv_work_14_0, sizeof(int), "ldv_work_14_0");
struct file *iwl_dbgfs_clear_ucode_statistics_ops_group2  ;
struct inode *iwl_dbgfs_ucode_tracing_ops_group1  ;
int ldv_state_variable_1  ;
    klee_make_symbolic(&ldv_state_variable_1, sizeof(int), "ldv_state_variable_1");
struct file *iwl_dbgfs_sram_ops_group2  ;
struct file *rs_sta_dbgfs_scale_table_ops_group2  ;
int ldv_work_12_1  ;
    klee_make_symbolic(&ldv_work_12_1, sizeof(int), "ldv_work_12_1");
struct iwl_priv *iwl_dvm_2000_cfg_group0  ;
struct work_struct *ldv_work_struct_6_2  ;
struct work_struct *ldv_work_struct_10_2  ;
struct inode *iwl_dbgfs_qos_ops_group1  ;
struct ieee80211_supported_band *rs_ops_group0  ;
struct work_struct *ldv_work_struct_8_2  ;
int ldv_timer_18_1  ;
    klee_make_symbolic(&ldv_timer_18_1, sizeof(int), "ldv_timer_18_1");
int ldv_work_4_3  ;
    klee_make_symbolic(&ldv_work_4_3, sizeof(int), "ldv_work_4_3");
int ldv_work_3_1  ;
    klee_make_symbolic(&ldv_work_3_1, sizeof(int), "ldv_work_3_1");
int ldv_state_variable_16  ;
    klee_make_symbolic(&ldv_state_variable_16, sizeof(int), "ldv_state_variable_16");
struct work_struct *ldv_work_struct_12_2  ;
int ldv_state_variable_43  ;
    klee_make_symbolic(&ldv_state_variable_43, sizeof(int), "ldv_state_variable_43");
int ldv_work_5_1  ;
    klee_make_symbolic(&ldv_work_5_1, sizeof(int), "ldv_work_5_1");
struct timer_list *ldv_timer_list_16_0  ;
int ldv_state_variable_57  ;
    klee_make_symbolic(&ldv_state_variable_57, sizeof(int), "ldv_state_variable_57");
int ldv_work_6_3  ;
    klee_make_symbolic(&ldv_work_6_3, sizeof(int), "ldv_work_6_3");
struct inode *iwl_dbgfs_sensitivity_ops_group1  ;
struct inode *iwl_dbgfs_calib_disabled_ops_group1  ;
struct file *iwl_dbgfs_missed_beacon_ops_group2  ;
struct work_struct *ldv_work_struct_3_0  ;
int ldv_state_variable_67  ;
    klee_make_symbolic(&ldv_state_variable_67, sizeof(int), "ldv_state_variable_67");
int ldv_state_variable_53  ;
    klee_make_symbolic(&ldv_state_variable_53, sizeof(int), "ldv_state_variable_53");
struct file *iwl_dbgfs_ucode_bt_stats_ops_group2  ;
int ldv_timer_17_1  ;
    klee_make_symbolic(&ldv_timer_17_1, sizeof(int), "ldv_timer_17_1");
struct inode *iwl_dbgfs_rf_reset_ops_group1  ;
struct inode *iwl_dbgfs_rxon_filter_flags_ops_group1  ;
int ldv_work_14_1  ;
    klee_make_symbolic(&ldv_work_14_1, sizeof(int), "ldv_work_14_1");
struct work_struct *ldv_work_struct_1_2  ;
int ldv_work_8_2  ;
    klee_make_symbolic(&ldv_work_8_2, sizeof(int), "ldv_work_8_2");
struct work_struct *ldv_work_struct_4_1  ;
int ldv_state_variable_34  ;
    klee_make_symbolic(&ldv_state_variable_34, sizeof(int), "ldv_state_variable_34");
struct inode *iwl_dbgfs_ucode_tx_stats_ops_group1  ;
struct file *iwl_dbgfs_disable_ht40_ops_group2  ;
int ldv_work_2_3  ;
    klee_make_symbolic(&ldv_work_2_3, sizeof(int), "ldv_work_2_3");
struct inode *iwl_dbgfs_reply_tx_error_ops_group1  ;
int ldv_work_10_3  ;
    klee_make_symbolic(&ldv_work_10_3, sizeof(int), "ldv_work_10_3");
struct file *iwl_dbgfs_chain_noise_ops_group2  ;
struct file *rs_sta_dbgfs_stats_table_ops_group2  ;
int ldv_state_variable_35  ;
    klee_make_symbolic(&ldv_state_variable_35, sizeof(int), "ldv_state_variable_35");
struct work_struct *ldv_work_struct_11_3  ;
void ldv_file_operations_20(void) ;
void activate_work_5(struct work_struct *work , int state ) ;
void ldv_initialize_iwl_dvm_cfg_62(void) ;
void ldv_file_operations_26(void) ;
void ldv_file_operations_66(void) ;
void ldv_file_operations_41(void) ;
void timer_init_17(void) ;
void disable_suitable_timer_16(struct timer_list *timer ) ;
void work_init_9(void) ;
void work_init_5(void) ;
void ldv_file_operations_40(void) ;
void call_and_disable_all_4(int state ) ;
void ldv_initialize_iwl_dvm_cfg_63(void) ;
void ldv_initialize_iwl_dvm_cfg_56(void) ;
void activate_work_1(struct work_struct *work , int state ) ;
int reg_timer_18(struct timer_list *timer , void (*function)(unsigned long  ) , unsigned long data ) ;
void ldv_initialize_iwl_dvm_cfg_54(void) ;
void call_and_disable_work_3(struct work_struct *work ) ;
void activate_pending_timer_18(struct timer_list *timer , unsigned long data , int pending_flag ) ;
void disable_work_7(struct work_struct *work ) ;
void disable_work_3(struct work_struct *work ) ;
void ldv_initialize_iwl_dvm_cfg_59(void) ;
void ldv_file_operations_24(void) ;
void ldv_file_operations_50(void) ;
void work_init_1(void) ;
void ldv_initialize_iwl_dvm_cfg_57(void) ;
void invoke_work_4(void) ;
void ldv_file_operations_51(void) ;
void activate_suitable_timer_15(struct timer_list *timer , unsigned long data ) ;
void activate_work_6(struct work_struct *work , int state ) ;
void ldv_file_operations_34(void) ;
void ldv_file_operations_39(void) ;
void disable_suitable_timer_18(struct timer_list *timer ) ;
int reg_timer_15(struct timer_list *timer , void (*function)(unsigned long  ) , unsigned long data ) ;
void ldv_initialize_iwl_op_mode_ops_69(void) ;
void timer_init_16(void) ;
void work_init_8(void) ;
void activate_work_2(struct work_struct *work , int state ) ;
void work_init_14(void) ;
void activate_pending_timer_15(struct timer_list *timer , unsigned long data , int pending_flag ) ;
void ldv_file_operations_31(void) ;
void work_init_10(void) ;
void invoke_work_5(void) ;
void timer_init_18(void) ;
void ldv_file_operations_29(void) ;
void disable_work_4(struct work_struct *work ) ;
void work_init_13(void) ;
void work_init_4(void) ;
void ldv_file_operations_42(void) ;
void invoke_work_1(void) ;
void ldv_initialize_iwl_dvm_cfg_61(void) ;
void activate_suitable_timer_16(struct timer_list *timer , unsigned long data ) ;
void ldv_file_operations_33(void) ;
void call_and_disable_all_3(int state ) ;
void ldv_file_operations_48(void) ;
void call_and_disable_work_4(struct work_struct *work ) ;
void ldv_file_operations_30(void) ;
void ldv_file_operations_23(void) ;
void ldv_file_operations_19(void) ;
void ldv_file_operations_49(void) ;
void work_init_3(void) ;
void call_and_disable_all_7(int state ) ;
void ldv_file_operations_32(void) ;
void call_and_disable_work_1(struct work_struct *work ) ;
void invoke_work_6(void) ;
void work_init_11(void) ;
void call_and_disable_all_2(int state ) ;
void ldv_file_operations_68(void) ;
void activate_work_3(struct work_struct *work , int state ) ;
void choose_timer_15(void) ;
void ldv_file_operations_25(void) ;
void ldv_file_operations_45(void) ;
void activate_pending_timer_16(struct timer_list *timer , unsigned long data , int pending_flag ) ;
void ldv_file_operations_28(void) ;
void work_init_7(void) ;
void ldv_file_operations_43(void) ;
void disable_work_5(struct work_struct *work ) ;
void ldv_file_operations_38(void) ;
void timer_init_15(void) ;
void ldv_file_operations_22(void) ;
void ldv_file_operations_35(void) ;
void disable_work_1(struct work_struct *work ) ;
void call_and_disable_all_6(int state ) ;
void ldv_initialize_iwl_dvm_cfg_55(void) ;
int reg_timer_16(struct timer_list *timer , void (*function)(unsigned long  ) , unsigned long data ) ;
void call_and_disable_work_5(struct work_struct *work ) ;
void ldv_timer_15(int state , struct timer_list *timer ) ;
void ldv_file_operations_46(void) ;
void invoke_work_2(void) ;
void ldv_initialize_iwl_dvm_cfg_60(void) ;
void choose_timer_16(void) ;
void ldv_initialize_iwl_dvm_cfg_58(void) ;
void ldv_initialize_rate_control_ops_65(void) ;
void activate_work_4(struct work_struct *work , int state ) ;
void call_and_disable_all_5(int state ) ;
void ldv_timer_16(int state , struct timer_list *timer ) ;
void work_init_2(void) ;
void call_and_disable_all_1(int state ) ;
void ldv_file_operations_44(void) ;
void disable_work_6(struct work_struct *work ) ;
void work_init_6(void) ;
void ldv_file_operations_37(void) ;
void work_init_12(void) ;
void ldv_file_operations_67(void) ;
void disable_suitable_timer_15(struct timer_list *timer ) ;
void ldv_file_operations_21(void) ;
void ldv_file_operations_36(void) ;
void activate_work_7(struct work_struct *work , int state ) ;
void ldv_file_operations_27(void) ;
void disable_work_2(struct work_struct *work ) ;
void invoke_work_3(void) ;
void call_and_disable_work_6(struct work_struct *work ) ;
void ldv_file_operations_52(void) ;
void call_and_disable_work_2(struct work_struct *work ) ;
void ldv_file_operations_47(void) ;
void ldv_file_operations_53(void) ;
extern void consume_skb(struct sk_buff * ) ;
__inline static void set_wiphy_dev(struct wiphy *wiphy , struct device *dev ) 
{ 


  {
  wiphy->dev.parent = dev;
  return;
}
}
extern void wiphy_rfkill_set_hw_state(struct wiphy * , bool  ) ;
__inline static struct ieee80211_tx_info *IEEE80211_SKB_CB(struct sk_buff *skb ) 
{ 


  {
  return ((struct ieee80211_tx_info *)(& skb->cb));
}
}
__inline static void SET_IEEE80211_DEV(struct ieee80211_hw *hw , struct device *dev ) 
{ 


  {
  set_wiphy_dev(hw->wiphy, dev);
  return;
}
}
extern void ieee80211_free_txskb(struct ieee80211_hw * , struct sk_buff * ) ;
extern void ieee80211_free_hw(struct ieee80211_hw * ) ;
void ldv_ieee80211_free_hw_19(struct ieee80211_hw *ldv_func_arg1 ) ;
void ldv_ieee80211_free_hw_22(struct ieee80211_hw *ldv_func_arg1 ) ;
extern void ieee80211_restart_hw(struct ieee80211_hw * ) ;
extern void ieee80211_napi_add(struct ieee80211_hw * , struct napi_struct * , struct net_device * ,
                               int (*)(struct napi_struct * , int  ) , int  ) ;
extern struct sk_buff *ieee80211_beacon_get_tim(struct ieee80211_hw * , struct ieee80211_vif * ,
                                                u16 * , u16 * ) ;
__inline static struct sk_buff *ieee80211_beacon_get(struct ieee80211_hw *hw , struct ieee80211_vif *vif ) 
{ 
  struct sk_buff *tmp ;

  {
  tmp = ieee80211_beacon_get_tim(hw, vif, (u16 *)0U, (u16 *)0U);
  return (tmp);
}
}
extern void ieee80211_wake_queue(struct ieee80211_hw * , int  ) ;
extern void ieee80211_stop_queue(struct ieee80211_hw * , int  ) ;
extern void ieee80211_stop_queues(struct ieee80211_hw * ) ;
extern void ieee80211_wake_queues(struct ieee80211_hw * ) ;
extern struct iwl_mod_params iwlwifi_mod_params ;
__inline static bool iwl_have_debug_level(u32 level ) 
{ 


  {
  return ((iwlwifi_mod_params.debug_level & level) != 0U);
}
}
extern void __iwl_err(struct device * , bool  , bool  , char const   *  , ...) ;
extern void __iwl_warn(struct device * , char const   *  , ...) ;
extern void __iwl_info(struct device * , char const   *  , ...) ;
extern void __iwl_dbg(struct device * , u32  , bool  , char const   * , char const   * 
                      , ...) ;
__inline static u8 num_of_ant(u8 mask ) 
{ 


  {
  return ((((unsigned int )mask & 1U) + (unsigned int )(((unsigned long )mask & 2UL) != 0UL)) + (unsigned int )(((unsigned long )mask & 4UL) != 0UL));
}
}
extern int iwl_opmode_register(char const   * , struct iwl_op_mode_ops  const  * ) ;
extern void iwl_opmode_deregister(char const   * ) ;
__inline static void iwl_trans_configure(struct iwl_trans *trans , struct iwl_trans_config  const  *trans_cfg ) 
{ 


  {
  trans->op_mode = trans_cfg->op_mode;
  (*((trans->ops)->configure))(trans, trans_cfg);
  return;
}
}
__inline static int iwl_trans_start_hw(struct iwl_trans *trans ) 
{ 
  int tmp ;

  {
  tmp = (*((trans->ops)->start_hw))(trans, 1);
  return (tmp);
}
}
__inline static void iwl_trans_op_mode_leave(struct iwl_trans *trans ) 
{ 


  {
  __might_sleep("drivers/net/wireless/iwlwifi/dvm/../iwl-trans.h", 673, 0);
  if ((unsigned long )(trans->ops)->op_mode_leave != (unsigned long )((void (*/* const  */)(struct iwl_trans * ))0)) {
    (*((trans->ops)->op_mode_leave))(trans);
  } else {

  }
  trans->op_mode = (struct iwl_op_mode *)0;
  trans->state = 0;
  return;
}
}
__inline static void _iwl_trans_stop_device(struct iwl_trans *trans , bool low_power ) 
{ 


  {
  __might_sleep("drivers/net/wireless/iwlwifi/dvm/../iwl-trans.h", 718, 0);
  (*((trans->ops)->stop_device))(trans, (int )low_power);
  trans->state = 0;
  return;
}
}
__inline static void iwl_trans_stop_device(struct iwl_trans *trans ) 
{ 


  {
  _iwl_trans_stop_device(trans, 1);
  return;
}
}
__inline static void iwl_trans_free_tx_cmd(struct iwl_trans *trans , struct iwl_device_cmd *dev_cmd ) 
{ 
  u8 *dev_cmd_ptr ;

  {
  dev_cmd_ptr = (u8 *)dev_cmd + - trans->dev_cmd_headroom;
  kmem_cache_free(trans->dev_cmd_pool, (void *)dev_cmd_ptr);
  return;
}
}
__inline static void iwl_trans_write32(struct iwl_trans *trans , u32 ofs , u32 val ) 
{ 


  {
  (*((trans->ops)->write32))(trans, ofs, val);
  return;
}
}
__inline static u32 iwl_trans_read32(struct iwl_trans *trans , u32 ofs ) 
{ 
  u32 tmp ;

  {
  tmp = (*((trans->ops)->read32))(trans, ofs);
  return (tmp);
}
}
__inline static int iwl_trans_read_mem(struct iwl_trans *trans , u32 addr , void *buf ,
                                       int dwords ) 
{ 
  int tmp ;

  {
  tmp = (*((trans->ops)->read_mem))(trans, addr, buf, dwords);
  return (tmp);
}
}
__inline static u32 iwl_trans_read_mem32(struct iwl_trans *trans , u32 addr ) 
{ 
  u32 value ;
  int __ret_warn_on ;
    klee_make_symbolic(&__ret_warn_on, sizeof(int), "__ret_warn_on");
  int tmp ;
  long tmp___0 ;
  long tmp___1 ;

  {
  tmp = iwl_trans_read_mem(trans, addr, (void *)(& value), 1);
  __ret_warn_on = tmp != 0;
  tmp___0 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp___0 != 0L) {
    warn_slowpath_null("drivers/net/wireless/iwlwifi/dvm/../iwl-trans.h", 964);
  } else {

  }
  tmp___1 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp___1 != 0L) {
    return (2779096485U);
  } else {

  }
  return (value);
}
}
__inline static void iwl_trans_set_bits_mask(struct iwl_trans *trans , u32 reg , u32 mask ,
                                             u32 value ) 
{ 


  {
  (*((trans->ops)->set_bits_mask))(trans, reg, mask, value);
  return;
}
}
__inline static void iwl_trans_release_nic_access(struct iwl_trans *trans , unsigned long *flags ) 
{ 


  {
  (*((trans->ops)->release_nic_access))(trans, flags);
  return;
}
}
extern int iwl_read_eeprom(struct iwl_trans * , u8 ** , size_t * ) ;
extern struct iwl_nvm_data *iwl_parse_eeprom_data(struct device * , struct iwl_cfg  const  * ,
                                                  u8 const   * , size_t  ) ;
__inline static void iwl_free_nvm_data(struct iwl_nvm_data *data ) 
{ 


  {
  kfree((void const   *)data);
  return;
}
}
extern int iwl_nvm_check_version(struct iwl_nvm_data * , struct iwl_trans * ) ;
extern struct tracepoint __tracepoint_iwlwifi_dev_ioread32 ;
    klee_make_symbolic(&__tracepoint_iwlwifi_dev_ioread32, sizeof(int), "__tracepoint_iwlwifi_dev_ioread32");
__inline static void trace_iwlwifi_dev_ioread32(struct device  const  *dev , u32 offs ,
                                                u32 val ) 
{ 
  struct tracepoint_func *it_func_ptr ;
  void *it_func ;
  void *__data ;
  struct tracepoint_func *________p1 ;
  struct tracepoint_func *_________p1 ;
  union __anonunion___u_390 __u ;
  bool __warned ;
  int tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  struct tracepoint_func *________p1___0 ;
  struct tracepoint_func *_________p1___0 ;
  union __anonunion___u_392 __u___0 ;
  bool __warned___0 ;
  int tmp___2 ;
    klee_make_symbolic(&tmp___2, sizeof(int), "tmp___2");
  int tmp___3 ;

  {
  tmp___1 = static_key_false(& __tracepoint_iwlwifi_dev_ioread32.key);
  if ((int )tmp___1) {
    rcu_read_lock_sched_notrace();
    __read_once_size((void const volatile   *)(& __tracepoint_iwlwifi_dev_ioread32.funcs),
                     (void *)(& __u.__c), 8);
    _________p1 = __u.__val;
    ________p1 = _________p1;
    tmp = debug_lockdep_rcu_enabled();
    if (tmp != 0 && ! __warned) {
      tmp___0 = rcu_read_lock_sched_held();
      if (tmp___0 == 0) {
        __warned = 1;
        lockdep_rcu_suspicious("drivers/net/wireless/iwlwifi/dvm/../iwl-devtrace-io.h",
                               50, "suspicious rcu_dereference_check() usage");
      } else {

      }
    } else {

    }
    it_func_ptr = ________p1;
    if ((unsigned long )it_func_ptr != (unsigned long )((struct tracepoint_func *)0)) {
      ldv_51379: 
      it_func = it_func_ptr->func;
      __data = it_func_ptr->data;
      (*((void (*)(void * , struct device  const  * , u32  , u32  ))it_func))(__data,
                                                                              dev,
                                                                              offs,
                                                                              val);
      it_func_ptr = it_func_ptr + 1;
      if ((unsigned long )it_func_ptr->func != (unsigned long )((void *)0)) {
        goto ldv_51379;
      } else {

      }

    } else {

    }
    rcu_read_unlock_sched_notrace();
  } else {

  }
  rcu_read_lock_sched_notrace();
  __read_once_size((void const volatile   *)(& __tracepoint_iwlwifi_dev_ioread32.funcs),
                   (void *)(& __u___0.__c), 8);
  _________p1___0 = __u___0.__val;
  ________p1___0 = _________p1___0;
  tmp___2 = debug_lockdep_rcu_enabled();
  if (tmp___2 != 0 && ! __warned___0) {
    tmp___3 = rcu_read_lock_sched_held();
    if (tmp___3 == 0) {
      __warned___0 = 1;
      lockdep_rcu_suspicious("drivers/net/wireless/iwlwifi/dvm/../iwl-devtrace-io.h",
                             50, "suspicious rcu_dereference_check() usage");
    } else {

    }
  } else {

  }
  rcu_read_unlock_sched_notrace();
  return;
}
}
extern struct tracepoint __tracepoint_iwlwifi_dev_iowrite32 ;
    klee_make_symbolic(&__tracepoint_iwlwifi_dev_iowrite32, sizeof(int), "__tracepoint_iwlwifi_dev_iowrite32");
__inline static void trace_iwlwifi_dev_iowrite32(struct device  const  *dev , u32 offs ,
                                                 u32 val ) 
{ 
  struct tracepoint_func *it_func_ptr ;
  void *it_func ;
  void *__data ;
  struct tracepoint_func *________p1 ;
  struct tracepoint_func *_________p1 ;
  union __anonunion___u_398 __u ;
  bool __warned ;
  int tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  struct tracepoint_func *________p1___0 ;
  struct tracepoint_func *_________p1___0 ;
  union __anonunion___u_400 __u___0 ;
  bool __warned___0 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  tmp___1 = static_key_false(& __tracepoint_iwlwifi_dev_iowrite32.key);
  if ((int )tmp___1) {
    rcu_read_lock_sched_notrace();
    __read_once_size((void const volatile   *)(& __tracepoint_iwlwifi_dev_iowrite32.funcs),
                     (void *)(& __u.__c), 8);
    _________p1 = __u.__val;
    ________p1 = _________p1;
    tmp = debug_lockdep_rcu_enabled();
    if (tmp != 0 && ! __warned) {
      tmp___0 = rcu_read_lock_sched_held();
      if (tmp___0 == 0) {
        __warned = 1;
        lockdep_rcu_suspicious("drivers/net/wireless/iwlwifi/dvm/../iwl-devtrace-io.h",
                               84, "suspicious rcu_dereference_check() usage");
      } else {

      }
    } else {

    }
    it_func_ptr = ________p1;
    if ((unsigned long )it_func_ptr != (unsigned long )((struct tracepoint_func *)0)) {
      ldv_51501: 
      it_func = it_func_ptr->func;
      __data = it_func_ptr->data;
      (*((void (*)(void * , struct device  const  * , u32  , u32  ))it_func))(__data,
                                                                              dev,
                                                                              offs,
                                                                              val);
      it_func_ptr = it_func_ptr + 1;
      if ((unsigned long )it_func_ptr->func != (unsigned long )((void *)0)) {
        goto ldv_51501;
      } else {

      }

    } else {

    }
    rcu_read_unlock_sched_notrace();
  } else {

  }
  rcu_read_lock_sched_notrace();
  __read_once_size((void const volatile   *)(& __tracepoint_iwlwifi_dev_iowrite32.funcs),
                   (void *)(& __u___0.__c), 8);
  _________p1___0 = __u___0.__val;
  ________p1___0 = _________p1___0;
  tmp___2 = debug_lockdep_rcu_enabled();
  if (tmp___2 != 0 && ! __warned___0) {
    tmp___3 = rcu_read_lock_sched_held();
    if (tmp___3 == 0) {
      __warned___0 = 1;
      lockdep_rcu_suspicious("drivers/net/wireless/iwlwifi/dvm/../iwl-devtrace-io.h",
                             84, "suspicious rcu_dereference_check() usage");
    } else {

    }
  } else {

  }
  rcu_read_unlock_sched_notrace();
  return;
}
}
extern struct tracepoint __tracepoint_iwlwifi_dev_ucode_cont_event ;
    klee_make_symbolic(&__tracepoint_iwlwifi_dev_ucode_cont_event, sizeof(int), "__tracepoint_iwlwifi_dev_ucode_cont_event");
__inline static void trace_iwlwifi_dev_ucode_cont_event(struct device  const  *dev ,
                                                        u32 time , u32 data , u32 ev ) 
{ 
  struct tracepoint_func *it_func_ptr ;
  void *it_func ;
  void *__data ;
  struct tracepoint_func *________p1 ;
  struct tracepoint_func *_________p1 ;
  union __anonunion___u_418 __u ;
  bool __warned ;
  int tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  struct tracepoint_func *________p1___0 ;
  struct tracepoint_func *_________p1___0 ;
  union __anonunion___u_420 __u___0 ;
  bool __warned___0 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  tmp___1 = static_key_false(& __tracepoint_iwlwifi_dev_ucode_cont_event.key);
  if ((int )tmp___1) {
    rcu_read_lock_sched_notrace();
    __read_once_size((void const volatile   *)(& __tracepoint_iwlwifi_dev_ucode_cont_event.funcs),
                     (void *)(& __u.__c), 8);
    _________p1 = __u.__val;
    ________p1 = _________p1;
    tmp = debug_lockdep_rcu_enabled();
    if (tmp != 0 && ! __warned) {
      tmp___0 = rcu_read_lock_sched_held();
      if (tmp___0 == 0) {
        __warned = 1;
        lockdep_rcu_suspicious("drivers/net/wireless/iwlwifi/dvm/../iwl-devtrace-ucode.h",
                               53, "suspicious rcu_dereference_check() usage");
      } else {

      }
    } else {

    }
    it_func_ptr = ________p1;
    if ((unsigned long )it_func_ptr != (unsigned long )((struct tracepoint_func *)0)) {
      ldv_51798: 
      it_func = it_func_ptr->func;
      __data = it_func_ptr->data;
      (*((void (*)(void * , struct device  const  * , u32  , u32  , u32  ))it_func))(__data,
                                                                                     dev,
                                                                                     time,
                                                                                     data,
                                                                                     ev);
      it_func_ptr = it_func_ptr + 1;
      if ((unsigned long )it_func_ptr->func != (unsigned long )((void *)0)) {
        goto ldv_51798;
      } else {

      }

    } else {

    }
    rcu_read_unlock_sched_notrace();
  } else {

  }
  rcu_read_lock_sched_notrace();
  __read_once_size((void const volatile   *)(& __tracepoint_iwlwifi_dev_ucode_cont_event.funcs),
                   (void *)(& __u___0.__c), 8);
  _________p1___0 = __u___0.__val;
  ________p1___0 = _________p1___0;
  tmp___2 = debug_lockdep_rcu_enabled();
  if (tmp___2 != 0 && ! __warned___0) {
    tmp___3 = rcu_read_lock_sched_held();
    if (tmp___3 == 0) {
      __warned___0 = 1;
      lockdep_rcu_suspicious("drivers/net/wireless/iwlwifi/dvm/../iwl-devtrace-ucode.h",
                             53, "suspicious rcu_dereference_check() usage");
    } else {

    }
  } else {

  }
  rcu_read_unlock_sched_notrace();
  return;
}
}
extern struct tracepoint __tracepoint_iwlwifi_dev_ucode_wrap_event ;
    klee_make_symbolic(&__tracepoint_iwlwifi_dev_ucode_wrap_event, sizeof(int), "__tracepoint_iwlwifi_dev_ucode_wrap_event");
__inline static void trace_iwlwifi_dev_ucode_wrap_event(struct device  const  *dev ,
                                                        u32 wraps , u32 n_entry ,
                                                        u32 p_entry ) 
{ 
  struct tracepoint_func *it_func_ptr ;
  void *it_func ;
  void *__data ;
  struct tracepoint_func *________p1 ;
  struct tracepoint_func *_________p1 ;
  union __anonunion___u_422 __u ;
  bool __warned ;
  int tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  struct tracepoint_func *________p1___0 ;
  struct tracepoint_func *_________p1___0 ;
  union __anonunion___u_424 __u___0 ;
  bool __warned___0 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  tmp___1 = static_key_false(& __tracepoint_iwlwifi_dev_ucode_wrap_event.key);
  if ((int )tmp___1) {
    rcu_read_lock_sched_notrace();
    __read_once_size((void const volatile   *)(& __tracepoint_iwlwifi_dev_ucode_wrap_event.funcs),
                     (void *)(& __u.__c), 8);
    _________p1 = __u.__val;
    ________p1 = _________p1;
    tmp = debug_lockdep_rcu_enabled();
    if (tmp != 0 && ! __warned) {
      tmp___0 = rcu_read_lock_sched_held();
      if (tmp___0 == 0) {
        __warned = 1;
        lockdep_rcu_suspicious("drivers/net/wireless/iwlwifi/dvm/../iwl-devtrace-ucode.h",
                               74, "suspicious rcu_dereference_check() usage");
      } else {

      }
    } else {

    }
    it_func_ptr = ________p1;
    if ((unsigned long )it_func_ptr != (unsigned long )((struct tracepoint_func *)0)) {
      ldv_51864: 
      it_func = it_func_ptr->func;
      __data = it_func_ptr->data;
      (*((void (*)(void * , struct device  const  * , u32  , u32  , u32  ))it_func))(__data,
                                                                                     dev,
                                                                                     wraps,
                                                                                     n_entry,
                                                                                     p_entry);
      it_func_ptr = it_func_ptr + 1;
      if ((unsigned long )it_func_ptr->func != (unsigned long )((void *)0)) {
        goto ldv_51864;
      } else {

      }

    } else {

    }
    rcu_read_unlock_sched_notrace();
  } else {

  }
  rcu_read_lock_sched_notrace();
  __read_once_size((void const volatile   *)(& __tracepoint_iwlwifi_dev_ucode_wrap_event.funcs),
                   (void *)(& __u___0.__c), 8);
  _________p1___0 = __u___0.__val;
  ________p1___0 = _________p1___0;
  tmp___2 = debug_lockdep_rcu_enabled();
  if (tmp___2 != 0 && ! __warned___0) {
    tmp___3 = rcu_read_lock_sched_held();
    if (tmp___3 == 0) {
      __warned___0 = 1;
      lockdep_rcu_suspicious("drivers/net/wireless/iwlwifi/dvm/../iwl-devtrace-ucode.h",
                             74, "suspicious rcu_dereference_check() usage");
    } else {

    }
  } else {

  }
  rcu_read_unlock_sched_notrace();
  return;
}
}
extern struct tracepoint __tracepoint_iwlwifi_dev_ucode_error ;
    klee_make_symbolic(&__tracepoint_iwlwifi_dev_ucode_error, sizeof(int), "__tracepoint_iwlwifi_dev_ucode_error");
__inline static void trace_iwlwifi_dev_ucode_error(struct device  const  *dev , u32 desc ,
                                                   u32 tsf_low , u32 data1 , u32 data2 ,
                                                   u32 line , u32 blink1 , u32 blink2 ,
                                                   u32 ilink1 , u32 ilink2 , u32 bcon_time ,
                                                   u32 gp1 , u32 gp2 , u32 gp3 , u32 major ,
                                                   u32 minor , u32 hw_ver , u32 brd_ver ) 
{ 
  struct tracepoint_func *it_func_ptr ;
  void *it_func ;
  void *__data ;
  struct tracepoint_func *________p1 ;
  struct tracepoint_func *_________p1 ;
  union __anonunion___u_466 __u ;
  bool __warned ;
  int tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  struct tracepoint_func *________p1___0 ;
  struct tracepoint_func *_________p1___0 ;
  union __anonunion___u_468 __u___0 ;
  bool __warned___0 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  tmp___1 = static_key_false(& __tracepoint_iwlwifi_dev_ucode_error.key);
  if ((int )tmp___1) {
    rcu_read_lock_sched_notrace();
    __read_once_size((void const volatile   *)(& __tracepoint_iwlwifi_dev_ucode_error.funcs),
                     (void *)(& __u.__c), 8);
    _________p1 = __u.__val;
    ________p1 = _________p1;
    tmp = debug_lockdep_rcu_enabled();
    if (tmp != 0 && ! __warned) {
      tmp___0 = rcu_read_lock_sched_held();
      if (tmp___0 == 0) {
        __warned = 1;
        lockdep_rcu_suspicious("drivers/net/wireless/iwlwifi/dvm/../iwl-devtrace-iwlwifi.h",
                               178, "suspicious rcu_dereference_check() usage");
      } else {

      }
    } else {

    }
    it_func_ptr = ________p1;
    if ((unsigned long )it_func_ptr != (unsigned long )((struct tracepoint_func *)0)) {
      ldv_52578: 
      it_func = it_func_ptr->func;
      __data = it_func_ptr->data;
      (*((void (*)(void * , struct device  const  * , u32  , u32  , u32  , u32  ,
                   u32  , u32  , u32  , u32  , u32  , u32  , u32  , u32  , u32  ,
                   u32  , u32  , u32  , u32  ))it_func))(__data, dev, desc, tsf_low,
                                                         data1, data2, line, blink1,
                                                         blink2, ilink1, ilink2, bcon_time,
                                                         gp1, gp2, gp3, major, minor,
                                                         hw_ver, brd_ver);
      it_func_ptr = it_func_ptr + 1;
      if ((unsigned long )it_func_ptr->func != (unsigned long )((void *)0)) {
        goto ldv_52578;
      } else {

      }

    } else {

    }
    rcu_read_unlock_sched_notrace();
  } else {

  }
  rcu_read_lock_sched_notrace();
  __read_once_size((void const volatile   *)(& __tracepoint_iwlwifi_dev_ucode_error.funcs),
                   (void *)(& __u___0.__c), 8);
  _________p1___0 = __u___0.__val;
  ________p1___0 = _________p1___0;
  tmp___2 = debug_lockdep_rcu_enabled();
  if (tmp___2 != 0 && ! __warned___0) {
    tmp___3 = rcu_read_lock_sched_held();
    if (tmp___3 == 0) {
      __warned___0 = 1;
      lockdep_rcu_suspicious("drivers/net/wireless/iwlwifi/dvm/../iwl-devtrace-iwlwifi.h",
                             178, "suspicious rcu_dereference_check() usage");
    } else {

    }
  } else {

  }
  rcu_read_unlock_sched_notrace();
  return;
}
}
extern struct tracepoint __tracepoint_iwlwifi_dev_ucode_event ;
    klee_make_symbolic(&__tracepoint_iwlwifi_dev_ucode_event, sizeof(int), "__tracepoint_iwlwifi_dev_ucode_event");
__inline static void trace_iwlwifi_dev_ucode_event(struct device  const  *dev , u32 time ,
                                                   u32 data , u32 ev ) 
{ 
  struct tracepoint_func *it_func_ptr ;
  void *it_func ;
  void *__data ;
  struct tracepoint_func *________p1 ;
  struct tracepoint_func *_________p1 ;
  union __anonunion___u_470 __u ;
  bool __warned ;
  int tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  struct tracepoint_func *________p1___0 ;
  struct tracepoint_func *_________p1___0 ;
  union __anonunion___u_472 __u___0 ;
  bool __warned___0 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  tmp___1 = static_key_false(& __tracepoint_iwlwifi_dev_ucode_event.key);
  if ((int )tmp___1) {
    rcu_read_lock_sched_notrace();
    __read_once_size((void const volatile   *)(& __tracepoint_iwlwifi_dev_ucode_event.funcs),
                     (void *)(& __u.__c), 8);
    _________p1 = __u.__val;
    ________p1 = _________p1;
    tmp = debug_lockdep_rcu_enabled();
    if (tmp != 0 && ! __warned) {
      tmp___0 = rcu_read_lock_sched_held();
      if (tmp___0 == 0) {
        __warned = 1;
        lockdep_rcu_suspicious("drivers/net/wireless/iwlwifi/dvm/../iwl-devtrace-iwlwifi.h",
                               198, "suspicious rcu_dereference_check() usage");
      } else {

      }
    } else {

    }
    it_func_ptr = ________p1;
    if ((unsigned long )it_func_ptr != (unsigned long )((struct tracepoint_func *)0)) {
      ldv_52686: 
      it_func = it_func_ptr->func;
      __data = it_func_ptr->data;
      (*((void (*)(void * , struct device  const  * , u32  , u32  , u32  ))it_func))(__data,
                                                                                     dev,
                                                                                     time,
                                                                                     data,
                                                                                     ev);
      it_func_ptr = it_func_ptr + 1;
      if ((unsigned long )it_func_ptr->func != (unsigned long )((void *)0)) {
        goto ldv_52686;
      } else {

      }

    } else {

    }
    rcu_read_unlock_sched_notrace();
  } else {

  }
  rcu_read_lock_sched_notrace();
  __read_once_size((void const volatile   *)(& __tracepoint_iwlwifi_dev_ucode_event.funcs),
                   (void *)(& __u___0.__c), 8);
  _________p1___0 = __u___0.__val;
  ________p1___0 = _________p1___0;
  tmp___2 = debug_lockdep_rcu_enabled();
  if (tmp___2 != 0 && ! __warned___0) {
    tmp___3 = rcu_read_lock_sched_held();
    if (tmp___3 == 0) {
      __warned___0 = 1;
      lockdep_rcu_suspicious("drivers/net/wireless/iwlwifi/dvm/../iwl-devtrace-iwlwifi.h",
                             198, "suspicious rcu_dereference_check() usage");
    } else {

    }
  } else {

  }
  rcu_read_unlock_sched_notrace();
  return;
}
}
__inline static void iwl_write32(struct iwl_trans *trans , u32 ofs , u32 val ) 
{ 


  {
  trace_iwlwifi_dev_iowrite32((struct device  const  *)trans->dev, ofs, val);
  iwl_trans_write32(trans, ofs, val);
  return;
}
}
__inline static u32 iwl_read32(struct iwl_trans *trans , u32 ofs ) 
{ 
  u32 val ;
  u32 tmp ;

  {
  tmp = iwl_trans_read32(trans, ofs);
  val = tmp;
  trace_iwlwifi_dev_ioread32((struct device  const  *)trans->dev, ofs, val);
  return (val);
}
}
__inline static void iwl_set_bit(struct iwl_trans *trans , u32 reg , u32 mask ) 
{ 


  {
  iwl_trans_set_bits_mask(trans, reg, mask, mask);
  return;
}
}
extern void iwl_set_bits_mask_prph(struct iwl_trans * , u32  , u32  , u32  ) ;
extern void iwl_abort_notification_waits(struct iwl_notif_wait_data * ) ;
int iwl_power_update_mode(struct iwl_priv *priv , bool force ) ;
void iwl_power_initialize(struct iwl_priv *priv ) ;
int iwlagn_rate_control_register(void) ;
void iwlagn_rate_control_unregister(void) ;
void iwl_tt_initialize(struct iwl_priv *priv ) ;
void iwl_tt_exit(struct iwl_priv *priv ) ;
void iwl_update_chain_flags(struct iwl_priv *priv ) ;
__inline static int iwl_is_associated_ctx(struct iwl_rxon_context *ctx ) 
{ 


  {
  return (((unsigned int )ctx->active.filter_flags & 32U) != 0U);
}
}
void iwl_chain_noise_calibration(struct iwl_priv *priv ) ;
void iwl_sensitivity_calibration(struct iwl_priv *priv ) ;
void iwl_reset_run_time_calib(struct iwl_priv *priv ) ;
struct iwl_dvm_cfg  const  iwl_dvm_1000_cfg ;
struct iwl_dvm_cfg  const  iwl_dvm_2000_cfg ;
struct iwl_dvm_cfg  const  iwl_dvm_105_cfg ;
struct iwl_dvm_cfg  const  iwl_dvm_2030_cfg ;
struct iwl_dvm_cfg  const  iwl_dvm_5000_cfg ;
struct iwl_dvm_cfg  const  iwl_dvm_5150_cfg ;
struct iwl_dvm_cfg  const  iwl_dvm_6000_cfg ;
struct iwl_dvm_cfg  const  iwl_dvm_6005_cfg ;
struct iwl_dvm_cfg  const  iwl_dvm_6050_cfg ;
struct iwl_dvm_cfg  const  iwl_dvm_6030_cfg ;
void iwl_down(struct iwl_priv *priv ) ;
void iwl_cancel_deferred_work(struct iwl_priv *priv ) ;
void iwlagn_prepare_restart(struct iwl_priv *priv ) ;
int iwl_rx_dispatch(struct iwl_op_mode *op_mode , struct iwl_rx_cmd_buffer *rxb ,
                    struct iwl_device_cmd *cmd ) ;
bool iwl_check_for_ct_kill(struct iwl_priv *priv ) ;
void iwlagn_lift_passive_no_rx(struct iwl_priv *priv ) ;
struct ieee80211_hw *iwl_alloc_all(void) ;
int iwlagn_mac_setup_register(struct iwl_priv *priv , struct iwl_ucode_capabilities  const  *capa ) ;
void iwlagn_mac_unregister(struct iwl_priv *priv ) ;
int iwl_dvm_send_cmd(struct iwl_priv *priv , struct iwl_host_cmd *cmd ) ;
int iwl_dvm_send_cmd_pdu(struct iwl_priv *priv , u8 id , u32 flags , u16 len , void const   *data ) ;
void iwl_connection_init_rx_config(struct iwl_priv *priv , struct iwl_rxon_context *ctx ) ;
int iwlagn_commit_rxon(struct iwl_priv *priv , struct iwl_rxon_context *ctx ) ;
void iwlagn_set_rxon_chain(struct iwl_priv *priv , struct iwl_rxon_context *ctx ) ;
int iwl_send_bt_env(struct iwl_priv *priv , u8 action , u8 type ) ;
void iwl_send_prio_tbl(struct iwl_priv *priv ) ;
void iwl_calib_free_results(struct iwl_priv *priv ) ;
int iwl_dump_nic_event_log(struct iwl_priv *priv , bool full_log , char **buf ) ;
int iwlagn_hw_valid_rtc_data_addr(u32 addr ) ;
void iwlagn_dev_txfifo_flush(struct iwl_priv *priv ) ;
int iwlagn_send_beacon_cmd(struct iwl_priv *priv ) ;
int iwl_send_statistics_request(struct iwl_priv *priv , u8 flags , bool clear ) ;
void iwl_setup_rx_handlers(struct iwl_priv *priv ) ;
u8 iwl_toggle_tx_ant(struct iwl_priv *priv , u8 ant , u8 valid ) ;
void iwl_init_scan_params(struct iwl_priv *priv ) ;
void iwl_scan_cancel_timeout(struct iwl_priv *priv , unsigned long ms ) ;
void iwl_setup_scan_deferred_work(struct iwl_priv *priv ) ;
void iwl_cancel_scan_deferred_work(struct iwl_priv *priv ) ;
void iwlagn_send_advance_bt_config(struct iwl_priv *priv ) ;
void iwlagn_bt_setup_deferred_work(struct iwl_priv *priv ) ;
void iwlagn_bt_cancel_deferred_work(struct iwl_priv *priv ) ;
void iwl_clear_ucode_stations(struct iwl_priv *priv , struct iwl_rxon_context *ctx ) ;
void iwl_dealloc_bcast_stations(struct iwl_priv *priv ) ;
__inline static u32 iwl_ant_idx_to_flags(u8 ant_idx ) 
{ 


  {
  return ((u32 )(1UL << (int )ant_idx) << 14U);
}
}
__inline static __le32 iwl_hw_set_rate_n_flags(u8 rate , u32 flags ) 
{ 


  {
  return ((u32 )rate | flags);
}
}
int iwl_alive_start(struct iwl_priv *priv ) ;
void iwl_print_rx_config_cmd(struct iwl_priv *priv , enum iwl_rxon_context_id ctxid ) ;
__inline static int iwl_is_ready(struct iwl_priv *priv ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  tmp = constant_test_bit(3L, (unsigned long const volatile   *)(& priv->status));
  if (tmp != 0) {
    tmp___0 = constant_test_bit(5L, (unsigned long const volatile   *)(& priv->status));
    if (tmp___0 == 0) {
      tmp___1 = 1;
    } else {
      tmp___1 = 0;
    }
  } else {
    tmp___1 = 0;
  }
  return (tmp___1);
}
}
__inline static int iwl_is_rfkill(struct iwl_priv *priv ) 
{ 
  int tmp ;

  {
  tmp = constant_test_bit(0L, (unsigned long const volatile   *)(& priv->status));
  return (tmp);
}
}
__inline static int iwl_is_ready_rf(struct iwl_priv *priv ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  tmp = iwl_is_rfkill(priv);
  if (tmp != 0) {
    return (0);
  } else {

  }
  tmp___0 = iwl_is_ready(priv);
  return (tmp___0);
}
}
int iwl_dbgfs_register(struct iwl_priv *priv , struct dentry *dbgfs_dir ) ;
char const   * const  iwl_dvm_cmd_strings[255U] ;
static struct iwl_op_mode_ops  const  iwl_dvm_ops ;
void iwl_update_chain_flags(struct iwl_priv *priv ) 
{ 
  struct iwl_rxon_context *ctx ;

  {
  ctx = (struct iwl_rxon_context *)(& priv->contexts);
  goto ldv_55268;
  ldv_55267: ;
  if ((int )((unsigned long )priv->valid_contexts >> (int )ctx->ctxid) & 1) {
    iwlagn_set_rxon_chain(priv, ctx);
    if ((int )((unsigned short )ctx->active.rx_chain) != (int )ctx->staging.rx_chain) {
      iwlagn_commit_rxon(priv, ctx);
    } else {

    }
  } else {

  }
  ctx = ctx + 1;
  ldv_55268: ;
  if ((unsigned long )((struct iwl_rxon_context *)(& priv->contexts) + 2UL) > (unsigned long )ctx) {
    goto ldv_55267;
  } else {

  }

  return;
}
}
static void iwl_set_beacon_tim(struct iwl_priv *priv , struct iwl_tx_beacon_cmd *tx_beacon_cmd ,
                               u8 *beacon , u32 frame_size ) 
{ 
  u16 tim_idx ;
  struct ieee80211_mgmt *mgmt ;

  {
  mgmt = (struct ieee80211_mgmt *)beacon;
  tim_idx = (int )((u16 )((long )(& mgmt->u.beacon.variable))) - (int )((u16 )((long )beacon));
  goto ldv_55279;
  ldv_55278: 
  tim_idx = (unsigned int )((int )((u16 )*(beacon + ((unsigned long )tim_idx + 1UL))) + (int )tim_idx) + 2U;
  ldv_55279: ;
  if ((u32 )tim_idx < frame_size - 2U && (unsigned int )*(beacon + (unsigned long )tim_idx) != 5U) {
    goto ldv_55278;
  } else {

  }

  if ((u32 )tim_idx < frame_size - 1U && (unsigned int )*(beacon + (unsigned long )tim_idx) == 5U) {
    tx_beacon_cmd->tim_idx = tim_idx;
    tx_beacon_cmd->tim_size = *(beacon + ((unsigned long )tim_idx + 1UL));
  } else {
    __iwl_warn(priv->dev, "Unable to find TIM Element in beacon\n");
  }
  return;
}
}
int iwlagn_send_beacon_cmd(struct iwl_priv *priv ) 
{ 
  struct iwl_tx_beacon_cmd *tx_beacon_cmd ;
  struct iwl_host_cmd cmd ;
  struct ieee80211_tx_info *info ;
  u32 frame_size ;
  u32 rate_flags ;
  u32 rate ;
  int __ret_warn_on ;
  int tmp ;
  int tmp___0 ;
  long tmp___1 ;
  int __ret_warn_on___0 ;
    klee_make_symbolic(&__ret_warn_on___0, sizeof(int), "__ret_warn_on___0");
  long tmp___2 ;
  long tmp___3 ;
  int tmp___4 ;

  {
  cmd.data[0] = 0;
  cmd.data[1] = 0;
  cmd.resp_pkt = 0;
  cmd._rx_page_addr = 0UL;
  cmd._rx_page_order = 0U;
  cmd.handler_status = 0;
  cmd.flags = 0U;
  cmd.len[0] = (unsigned short)0;
  cmd.len[1] = (unsigned short)0;
  cmd.dataflags[0] = (unsigned char)0;
  cmd.dataflags[1] = (unsigned char)0;
  cmd.id = 145U;
  if (debug_locks != 0) {
    tmp = lock_is_held(& priv->mutex.dep_map);
    if (tmp == 0) {
      tmp___0 = 1;
    } else {
      tmp___0 = 0;
    }
  } else {
    tmp___0 = 0;
  }
  __ret_warn_on = tmp___0;
  tmp___1 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp___1 != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/08_1a/drivers/net/wireless/iwlwifi/dvm/main.c",
                       128);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if ((unsigned long )priv->beacon_ctx == (unsigned long )((struct iwl_rxon_context *)0)) {
    __iwl_err(priv->dev, 0, 0, "trying to build beacon w/o beacon context!\n");
    return (0);
  } else {

  }
  __ret_warn_on___0 = (unsigned long )priv->beacon_skb == (unsigned long )((struct sk_buff *)0);
  tmp___2 = ldv__builtin_expect(__ret_warn_on___0 != 0, 0L);
  if (tmp___2 != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/08_1a/drivers/net/wireless/iwlwifi/dvm/main.c",
                       135);
  } else {

  }
  tmp___3 = ldv__builtin_expect(__ret_warn_on___0 != 0, 0L);
  if (tmp___3 != 0L) {
    return (-22);
  } else {

  }
  if ((unsigned long )priv->beacon_cmd == (unsigned long )((void *)0)) {
    priv->beacon_cmd = kzalloc(60UL, 208U);
  } else {

  }
  tx_beacon_cmd = (struct iwl_tx_beacon_cmd *)priv->beacon_cmd;
  if ((unsigned long )tx_beacon_cmd == (unsigned long )((struct iwl_tx_beacon_cmd *)0)) {
    return (-12);
  } else {

  }
  frame_size = (priv->beacon_skb)->len;
  tx_beacon_cmd->tx.len = (unsigned short )frame_size;
  tx_beacon_cmd->tx.sta_id = (priv->beacon_ctx)->bcast_sta_id;
  tx_beacon_cmd->tx.stop_time.life_time = 4294967295U;
  tx_beacon_cmd->tx.tx_flags = 73744U;
  iwl_set_beacon_tim(priv, tx_beacon_cmd, (priv->beacon_skb)->data, frame_size);
  info = IEEE80211_SKB_CB(priv->beacon_skb);
  if ((int )info->__annonCompField99.control.__annonCompField97.__annonCompField96.rates[0].idx < 0 || ((int )info->__annonCompField99.control.__annonCompField97.__annonCompField96.rates[0].flags & 8) != 0) {
    rate = 0U;
  } else {
    rate = (u32 )info->__annonCompField99.control.__annonCompField97.__annonCompField96.rates[0].idx;
  }
  priv->mgmt_tx_ant = iwl_toggle_tx_ant(priv, (int )priv->mgmt_tx_ant, (int )(priv->nvm_data)->valid_tx_ant);
  rate_flags = iwl_ant_idx_to_flags((int )priv->mgmt_tx_ant);
  if ((unsigned int )info->band == 1U) {
    rate = rate + 4U;
  } else
  if (rate <= 3U) {
    rate_flags = rate_flags | 512U;
  } else {

  }
  tx_beacon_cmd->tx.rate_n_flags = iwl_hw_set_rate_n_flags((int )((u8 )rate), rate_flags);
  cmd.len[0] = 60U;
  cmd.data[0] = (void const   *)tx_beacon_cmd;
  cmd.dataflags[0] = 1U;
  cmd.len[1] = (u16 )frame_size;
  cmd.data[1] = (void const   *)(priv->beacon_skb)->data;
  cmd.dataflags[1] = 1U;
  tmp___4 = iwl_dvm_send_cmd(priv, & cmd);
  return (tmp___4);
}
}
static void iwl_bg_beacon_update(struct work_struct *work ) 
{ 
  struct iwl_priv *priv ;
  struct work_struct  const  *__mptr ;
  struct sk_buff *beacon ;

  {
  __mptr = (struct work_struct  const  *)work;
  priv = (struct iwl_priv *)__mptr + 0xffffffffffffd040UL;
  mutex_lock_nested(& priv->mutex, 0U);
  if ((unsigned long )priv->beacon_ctx == (unsigned long )((struct iwl_rxon_context *)0)) {
    __iwl_err(priv->dev, 0, 0, "updating beacon w/o beacon context!\n");
    goto out;
  } else {

  }
  if ((unsigned int )((priv->beacon_ctx)->vif)->type != 3U) {
    goto out;
  } else {

  }
  beacon = ieee80211_beacon_get(priv->hw, (priv->beacon_ctx)->vif);
  if ((unsigned long )beacon == (unsigned long )((struct sk_buff *)0)) {
    __iwl_err(priv->dev, 0, 0, "update beacon failed -- keeping old\n");
    goto out;
  } else {

  }
  consume_skb(priv->beacon_skb);
  priv->beacon_skb = beacon;
  iwlagn_send_beacon_cmd(priv);
  out: 
  mutex_unlock(& priv->mutex);
  return;
}
}
static void iwl_bg_bt_runtime_config(struct work_struct *work ) 
{ 
  struct iwl_priv *priv ;
  struct work_struct  const  *__mptr ;
  int tmp ;
  int tmp___0 ;

  {
  __mptr = (struct work_struct  const  *)work;
  priv = (struct iwl_priv *)__mptr + 0xffffffffffffcdf8UL;
  mutex_lock_nested(& priv->mutex, 0U);
  tmp = constant_test_bit(5L, (unsigned long const volatile   *)(& priv->status));
  if (tmp != 0) {
    goto out;
  } else {

  }
  tmp___0 = iwl_is_ready_rf(priv);
  if (tmp___0 == 0) {
    goto out;
  } else {

  }
  iwlagn_send_advance_bt_config(priv);
  out: 
  mutex_unlock(& priv->mutex);
  return;
}
}
static void iwl_bg_bt_full_concurrency(struct work_struct *work ) 
{ 
  struct iwl_priv *priv ;
  struct work_struct  const  *__mptr ;
  struct iwl_rxon_context *ctx ;
  int tmp ;
  int tmp___0 ;

  {
  __mptr = (struct work_struct  const  *)work;
  priv = (struct iwl_priv *)__mptr + 0xffffffffffffce48UL;
  mutex_lock_nested(& priv->mutex, 0U);
  tmp = constant_test_bit(5L, (unsigned long const volatile   *)(& priv->status));
  if (tmp != 0) {
    goto out;
  } else {

  }
  tmp___0 = iwl_is_ready_rf(priv);
  if (tmp___0 == 0) {
    goto out;
  } else {

  }
  __iwl_dbg(priv->dev, 1U, 0, "iwl_bg_bt_full_concurrency", "BT coex in %s mode\n",
            (int )priv->bt_full_concurrent ? (char *)"full concurrency" : (char *)"3-wire");
  ctx = (struct iwl_rxon_context *)(& priv->contexts);
  goto ldv_55319;
  ldv_55318: ;
  if ((int )((unsigned long )priv->valid_contexts >> (int )ctx->ctxid) & 1) {
    iwlagn_set_rxon_chain(priv, ctx);
    iwlagn_commit_rxon(priv, ctx);
  } else {

  }
  ctx = ctx + 1;
  ldv_55319: ;
  if ((unsigned long )((struct iwl_rxon_context *)(& priv->contexts) + 2UL) > (unsigned long )ctx) {
    goto ldv_55318;
  } else {

  }
  iwlagn_send_advance_bt_config(priv);
  out: 
  mutex_unlock(& priv->mutex);
  return;
}
}
int iwl_send_statistics_request(struct iwl_priv *priv , u8 flags , bool clear ) 
{ 
  struct iwl_statistics_cmd statistics_cmd ;
  int tmp ;
  int tmp___0 ;

  {
  statistics_cmd.configuration_flags = (int )clear ? 1U : 0U;
  if ((int )flags & 1) {
    tmp = iwl_dvm_send_cmd_pdu(priv, 156, 1U, 4, (void const   *)(& statistics_cmd));
    return (tmp);
  } else {
    tmp___0 = iwl_dvm_send_cmd_pdu(priv, 156, 0U, 4, (void const   *)(& statistics_cmd));
    return (tmp___0);
  }
}
}
static void iwl_bg_statistics_periodic(unsigned long data ) 
{ 
  struct iwl_priv *priv ;
  int tmp ;
  int tmp___0 ;

  {
  priv = (struct iwl_priv *)data;
  tmp = constant_test_bit(5L, (unsigned long const volatile   *)(& priv->status));
  if (tmp != 0) {
    return;
  } else {

  }
  tmp___0 = iwl_is_ready_rf(priv);
  if (tmp___0 == 0) {
    return;
  } else {

  }
  iwl_send_statistics_request(priv, 1, 0);
  return;
}
}
static void iwl_print_cont_event_trace(struct iwl_priv *priv , u32 base , u32 start_idx ,
                                       u32 num_events , u32 capacity , u32 mode ) 
{ 
  u32 i ;
  u32 ptr ;
  u32 ev ;
  u32 time ;
  u32 data ;
  unsigned long reg_flags ;
    klee_make_symbolic(&reg_flags, sizeof(long), "reg_flags");
  bool tmp ;
  long tmp___0 ;
  int __ret_warn_on ;
  long tmp___1 ;
  long tmp___2 ;

  {
  if (mode == 0U) {
    ptr = (start_idx * 8U + base) + 16U;
  } else {
    ptr = (start_idx * 12U + base) + 16U;
  }
  tmp = (*(((priv->trans)->ops)->grab_nic_access))(priv->trans, 0, & reg_flags);
  tmp___0 = ldv__builtin_expect((long )tmp, 1L);
  if (tmp___0 == 0L) {
    return;
  } else {

  }
  iwl_write32(priv->trans, 1036U, ptr);
  __ret_warn_on = capacity - start_idx < num_events;
  tmp___1 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp___1 != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/08_1a/drivers/net/wireless/iwlwifi/dvm/main.c",
                       356);
  } else {

  }
  tmp___2 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp___2 != 0L) {
    num_events = capacity - start_idx;
  } else {

  }
  i = 0U;
  goto ldv_55348;
  ldv_55347: 
  ev = iwl_read32(priv->trans, 1052U);
  time = iwl_read32(priv->trans, 1052U);
  if (mode == 0U) {
    trace_iwlwifi_dev_ucode_cont_event((struct device  const  *)(priv->trans)->dev,
                                       0U, time, ev);
  } else {
    data = iwl_read32(priv->trans, 1052U);
    trace_iwlwifi_dev_ucode_cont_event((struct device  const  *)(priv->trans)->dev,
                                       time, data, ev);
  }
  i = i + 1U;
  ldv_55348: ;
  if (i < num_events) {
    goto ldv_55347;
  } else {

  }
  iwl_trans_release_nic_access(priv->trans, & reg_flags);
  return;
}
}
static void iwl_continuous_event_trace(struct iwl_priv *priv ) 
{ 
  u32 capacity ;
  struct __anonstruct_read_486 read ;
  u32 base ;
  u32 mode ;
  u32 num_wraps ;
  u32 next_entry ;
  int tmp ;
  long tmp___0 ;
  long tmp___1 ;

  {
  base = priv->device_pointers.log_event_table;
  tmp = iwlagn_hw_valid_rtc_data_addr(base);
  if (tmp != 0) {
    iwl_trans_read_mem(priv->trans, base, (void *)(& read), 4);
    capacity = read.capacity;
    mode = read.mode;
    num_wraps = read.wrap_counter;
    next_entry = read.write_counter;
  } else {
    return;
  }
  tmp___0 = ldv__builtin_expect(next_entry == capacity, 0L);
  if (tmp___0 != 0L) {
    next_entry = 0U;
  } else {

  }
  tmp___1 = ldv__builtin_expect((long )(priv->event_log.next_entry > next_entry && priv->event_log.num_wraps == num_wraps),
                             0L);
  if (tmp___1 != 0L) {
    num_wraps = num_wraps + 1U;
  } else {

  }
  if (priv->event_log.num_wraps == num_wraps) {
    iwl_print_cont_event_trace(priv, base, priv->event_log.next_entry, next_entry - priv->event_log.next_entry,
                               capacity, mode);
    priv->event_log.non_wraps_count = priv->event_log.non_wraps_count + 1;
  } else {
    if (num_wraps - priv->event_log.num_wraps > 1U) {
      priv->event_log.wraps_more_count = priv->event_log.wraps_more_count + 1;
    } else {
      priv->event_log.wraps_once_count = priv->event_log.wraps_once_count + 1;
    }
    trace_iwlwifi_dev_ucode_wrap_event((struct device  const  *)(priv->trans)->dev,
                                       num_wraps - priv->event_log.num_wraps, next_entry,
                                       priv->event_log.next_entry);
    if (priv->event_log.next_entry > next_entry) {
      iwl_print_cont_event_trace(priv, base, priv->event_log.next_entry, capacity - priv->event_log.next_entry,
                                 capacity, mode);
      iwl_print_cont_event_trace(priv, base, 0U, next_entry, capacity, mode);
    } else {
      iwl_print_cont_event_trace(priv, base, next_entry, capacity - next_entry, capacity,
                                 mode);
      iwl_print_cont_event_trace(priv, base, 0U, next_entry, capacity, mode);
    }
  }
  priv->event_log.num_wraps = num_wraps;
  priv->event_log.next_entry = next_entry;
  return;
}
}
static void iwl_bg_ucode_trace(unsigned long data ) 
{ 
  struct iwl_priv *priv ;
  int tmp ;
  unsigned long tmp___0 ;

  {
  priv = (struct iwl_priv *)data;
  tmp = constant_test_bit(5L, (unsigned long const volatile   *)(& priv->status));
  if (tmp != 0) {
    return;
  } else {

  }
  if ((int )priv->event_log.ucode_trace) {
    iwl_continuous_event_trace(priv);
    tmp___0 = msecs_to_jiffies(10U);
    ldv_mod_timer_10(& priv->ucode_trace, tmp___0 + (unsigned long )jiffies);
  } else {

  }
  return;
}
}
static void iwl_bg_tx_flush(struct work_struct *work ) 
{ 
  struct iwl_priv *priv ;
  struct work_struct  const  *__mptr ;
  int tmp ;
  int tmp___0 ;

  {
  __mptr = (struct work_struct  const  *)work;
  priv = (struct iwl_priv *)__mptr + 0xffffffffffffce98UL;
  tmp = constant_test_bit(5L, (unsigned long const volatile   *)(& priv->status));
  if (tmp != 0) {
    return;
  } else {

  }
  tmp___0 = iwl_is_ready_rf(priv);
  if (tmp___0 == 0) {
    return;
  } else {

  }
  __iwl_dbg(priv->dev, 1U, 0, "iwl_bg_tx_flush", "device request: flush all tx frames\n");
  iwlagn_dev_txfifo_flush(priv);
  return;
}
}
static u8 const   iwlagn_bss_ac_to_fifo[4U]  = {      3U,      2U,      1U,      0U};
static u8 const   iwlagn_bss_ac_to_queue[4U]  = {      0U,      1U,      2U,      3U};
static u8 const   iwlagn_pan_ac_to_fifo[4U]  = {      5U,      2U,      4U,      0U};
static u8 const   iwlagn_pan_ac_to_queue[4U]  = {      7U,      6U,      5U,      4U};
static void iwl_init_context(struct iwl_priv *priv , u32 ucode_flags ) 
{ 
  int i ;
    klee_make_symbolic(&i, sizeof(int), "i");

  {
  priv->valid_contexts = 1U;
  if ((int )ucode_flags & 1) {
    priv->valid_contexts = (u8 )((unsigned int )priv->valid_contexts | 2U);
  } else {

  }
  i = 0;
  goto ldv_55385;
  ldv_55384: 
  priv->contexts[i].ctxid = (enum iwl_rxon_context_id )i;
  i = i + 1;
  ldv_55385: ;
  if (i <= 1) {
    goto ldv_55384;
  } else {

  }
  priv->contexts[0].always_active = 1;
  priv->contexts[0].is_active = 1;
  priv->contexts[0].rxon_cmd = 16U;
  priv->contexts[0].rxon_timing_cmd = 20U;
  priv->contexts[0].rxon_assoc_cmd = 17U;
  priv->contexts[0].qos_cmd = 19U;
  priv->contexts[0].ap_sta_id = 0U;
  priv->contexts[0].wep_key_cmd = 32U;
  priv->contexts[0].bcast_sta_id = 15U;
  priv->contexts[0].exclusive_interface_modes = 66U;
  priv->contexts[0].interface_modes = 4U;
  priv->contexts[0].ap_devtype = 1U;
  priv->contexts[0].ibss_devtype = 4U;
  priv->contexts[0].station_devtype = 3U;
  priv->contexts[0].unused_devtype = 3U;
  memcpy((void *)(& priv->contexts[0].ac_to_queue), (void const   *)(& iwlagn_bss_ac_to_queue),
           4UL);
  memcpy((void *)(& priv->contexts[0].ac_to_fifo), (void const   *)(& iwlagn_bss_ac_to_fifo),
           4UL);
  priv->contexts[1].rxon_cmd = 179U;
  priv->contexts[1].rxon_timing_cmd = 180U;
  priv->contexts[1].rxon_assoc_cmd = 182U;
  priv->contexts[1].qos_cmd = 183U;
  priv->contexts[1].ap_sta_id = 1U;
  priv->contexts[1].wep_key_cmd = 184U;
  priv->contexts[1].bcast_sta_id = 14U;
  priv->contexts[1].station_flags = 8192U;
  priv->contexts[1].interface_modes = 12U;
  priv->contexts[1].ap_devtype = 7U;
  priv->contexts[1].station_devtype = 8U;
  priv->contexts[1].unused_devtype = 9U;
  memcpy((void *)(& priv->contexts[1].ac_to_queue), (void const   *)(& iwlagn_pan_ac_to_queue),
           4UL);
  memcpy((void *)(& priv->contexts[1].ac_to_fifo), (void const   *)(& iwlagn_pan_ac_to_fifo),
           4UL);
  priv->contexts[1].mcast_queue = 8U;
  return;
}
}
static void iwl_rf_kill_ct_config(struct iwl_priv *priv ) 
{ 
  struct iwl_ct_kill_config cmd ;
  struct iwl_ct_kill_throttling_config adv_cmd ;
  int ret ;
    klee_make_symbolic(&ret, sizeof(int), "ret");

  {
  ret = 0;
  iwl_write32(priv->trans, 92U, 8U);
  priv->thermal_throttle.ct_kill_toggle = 0;
  if ((int )(priv->lib)->support_ct_kill_exit) {
    adv_cmd.critical_temperature_enter = priv->hw_params.ct_kill_threshold;
    adv_cmd.critical_temperature_exit = priv->hw_params.ct_kill_exit_threshold;
    ret = iwl_dvm_send_cmd_pdu(priv, 164, 0U, 12, (void const   *)(& adv_cmd));
    if (ret != 0) {
      __iwl_err(priv->dev, 0, 0, "REPLY_CT_KILL_CONFIG_CMD failed\n");
    } else {
      __iwl_dbg(priv->dev, 1U, 0, "iwl_rf_kill_ct_config", "REPLY_CT_KILL_CONFIG_CMD succeeded, critical temperature enter is %d,exit is %d\n",
                priv->hw_params.ct_kill_threshold, priv->hw_params.ct_kill_exit_threshold);
    }
  } else {
    cmd.critical_temperature_R = priv->hw_params.ct_kill_threshold;
    ret = iwl_dvm_send_cmd_pdu(priv, 164, 0U, 12, (void const   *)(& cmd));
    if (ret != 0) {
      __iwl_err(priv->dev, 0, 0, "REPLY_CT_KILL_CONFIG_CMD failed\n");
    } else {
      __iwl_dbg(priv->dev, 1U, 0, "iwl_rf_kill_ct_config", "REPLY_CT_KILL_CONFIG_CMD succeeded, critical temperature is %d\n",
                priv->hw_params.ct_kill_threshold);
    }
  }
  return;
}
}
static int iwlagn_send_calib_cfg_rt(struct iwl_priv *priv , u32 cfg ) 
{ 
  struct iwl_calib_cfg_cmd calib_cfg_cmd ;
  struct iwl_host_cmd cmd ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  int tmp___1 ;

  {
  cmd.data[0] = (void const   *)(& calib_cfg_cmd);
  tmp = 1U;
  while (1) {
    if (tmp >= 2U) {
      break;
    } else {

    }
    cmd.data[tmp] = 0;
    tmp = tmp + 1U;
  }
  cmd.resp_pkt = 0;
  cmd._rx_page_addr = 0UL;
  cmd._rx_page_order = 0U;
  cmd.handler_status = 0;
  cmd.flags = 0U;
  cmd.len[0] = 92U;
  tmp___0 = 1U;
  while (1) {
    if (tmp___0 >= 2U) {
      break;
    } else {

    }
    cmd.len[tmp___0] = (unsigned short)0;
    tmp___0 = tmp___0 + 1U;
  }
  cmd.dataflags[0] = (unsigned char)0;
  cmd.dataflags[1] = (unsigned char)0;
  cmd.id = 101U;
  memset((void *)(& calib_cfg_cmd), 0, 92UL);
  calib_cfg_cmd.ucd_calib_cfg.once.is_enable = 1503U;
  calib_cfg_cmd.ucd_calib_cfg.once.start = cfg;
  tmp___1 = iwl_dvm_send_cmd(priv, & cmd);
  return (tmp___1);
}
}
static int iwlagn_send_tx_ant_config(struct iwl_priv *priv , u8 valid_tx_ant ) 
{ 
  struct iwl_tx_ant_config_cmd tx_ant_cmd ;
  int tmp ;

  {
  tx_ant_cmd.valid = (unsigned int )valid_tx_ant;
  if (((unsigned int )(priv->fw)->ucode_ver & 65280U) >> 8 > 1U) {
    __iwl_dbg(priv->dev, 4U, 0, "iwlagn_send_tx_ant_config", "select valid tx ant: %u\n",
              (int )valid_tx_ant);
    tmp = iwl_dvm_send_cmd_pdu(priv, 152, 0U, 4, (void const   *)(& tx_ant_cmd));
    return (tmp);
  } else {
    __iwl_dbg(priv->dev, 4U, 0, "iwlagn_send_tx_ant_config", "TX_ANT_CONFIGURATION_CMD not supported\n");
    return (-95);
  }
}
}
static void iwl_send_bt_config(struct iwl_priv *priv ) 
{ 
  struct iwl_bt_cmd bt_cmd ;
  int tmp ;

  {
  bt_cmd.flags = (unsigned char)0;
  bt_cmd.lead_time = 30U;
  bt_cmd.max_kill = 5U;
  bt_cmd.reserved = (unsigned char)0;
  bt_cmd.kill_ack_mask = 0U;
  bt_cmd.kill_cts_mask = 0U;
  if (! iwlwifi_mod_params.bt_coex_active) {
    bt_cmd.flags = 0U;
  } else {
    bt_cmd.flags = 3U;
  }
  priv->bt_enable_flag = bt_cmd.flags;
  __iwl_dbg(priv->dev, 1U, 0, "iwl_send_bt_config", "BT coex %s\n", (unsigned int )bt_cmd.flags == 0U ? (char *)"disable" : (char *)"active");
  tmp = iwl_dvm_send_cmd_pdu(priv, 155, 0U, 12, (void const   *)(& bt_cmd));
  if (tmp != 0) {
    __iwl_err(priv->dev, 0, 0, "failed to send BT Coex Config\n");
  } else {

  }
  return;
}
}
int iwl_alive_start(struct iwl_priv *priv ) 
{ 
  int ret ;
  struct iwl_rxon_context *ctx ;
  int tmp ;
  struct iwl_rxon_cmd *active_rxon ;
  struct iwl_rxon_context *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  ret = 0;
  ctx = (struct iwl_rxon_context *)(& priv->contexts);
  __iwl_dbg(priv->dev, 1U, 0, "iwl_alive_start", "Runtime Alive received.\n");
  set_bit(2L, (unsigned long volatile   *)(& priv->status));
  tmp = iwl_is_rfkill(priv);
  if (tmp != 0) {
    return (-132);
  } else {

  }
  if ((int )priv->event_log.ucode_trace) {
    ldv_mod_timer_11(& priv->ucode_trace, jiffies);
  } else {

  }
  if ((unsigned long )(priv->lib)->bt_params != (unsigned long )((struct iwl_dvm_bt_params  const  */* const  */)0) && (int )((priv->lib)->bt_params)->advanced_bt_coexist) {
    if ((int )((priv->lib)->bt_params)->bt_sco_disable) {
      priv->bt_enable_pspoll = 0;
    } else {
      priv->bt_enable_pspoll = 1;
    }
    priv->bt_valid = 255U;
    priv->kill_ack_mask = 4294901760U;
    priv->kill_cts_mask = 4294901760U;
    iwlagn_send_advance_bt_config(priv);
    priv->bt_valid = 1U;
    priv->cur_rssi_ctx = (struct iwl_rxon_context *)0;
    iwl_send_prio_tbl(priv);
    ret = iwl_send_bt_env(priv, 1, 1);
    if (ret != 0) {
      return (ret);
    } else {

    }
    ret = iwl_send_bt_env(priv, 0, 1);
    if (ret != 0) {
      return (ret);
    } else {

    }
  } else
  if ((unsigned long )(priv->lib)->bt_params != (unsigned long )((struct iwl_dvm_bt_params  const  */* const  */)0)) {
    iwl_send_bt_config(priv);
  } else {

  }
  iwlagn_send_calib_cfg_rt(priv, 2U);
  ieee80211_wake_queues(priv->hw);
  iwlagn_send_tx_ant_config(priv, (int )(priv->nvm_data)->valid_tx_ant);
  tmp___1 = iwl_is_associated_ctx(ctx);
  if (tmp___1 != 0 && ! priv->wowlan) {
    active_rxon = (struct iwl_rxon_cmd *)(& ctx->active);
    ctx->staging.filter_flags = ctx->staging.filter_flags | 32U;
    active_rxon->filter_flags = active_rxon->filter_flags & 4294967263U;
  } else {
    tmp___0 = (struct iwl_rxon_context *)(& priv->contexts);
    goto ldv_55420;
    ldv_55419: ;
    if ((int )((unsigned long )priv->valid_contexts >> (int )tmp___0->ctxid) & 1) {
      iwl_connection_init_rx_config(priv, tmp___0);
    } else {

    }
    tmp___0 = tmp___0 + 1;
    ldv_55420: ;
    if ((unsigned long )((struct iwl_rxon_context *)(& priv->contexts) + 2UL) > (unsigned long )tmp___0) {
      goto ldv_55419;
    } else {

    }
    iwlagn_set_rxon_chain(priv, ctx);
  }
  if (! priv->wowlan) {
    iwl_reset_run_time_calib(priv);
  } else {

  }
  set_bit(3L, (unsigned long volatile   *)(& priv->status));
  ret = iwlagn_commit_rxon(priv, ctx);
  if (ret != 0) {
    return (ret);
  } else {

  }
  iwl_rf_kill_ct_config(priv);
  __iwl_dbg(priv->dev, 1U, 0, "iwl_alive_start", "ALIVE processing complete.\n");
  tmp___2 = iwl_power_update_mode(priv, 1);
  return (tmp___2);
}
}
static void iwl_clear_driver_stations(struct iwl_priv *priv ) 
{ 
  struct iwl_rxon_context *ctx ;

  {
  spin_lock_bh(& priv->sta_lock);
  memset((void *)(& priv->stations), 0, 1664UL);
  priv->num_stations = 0;
  priv->ucode_key_table = 0UL;
  ctx = (struct iwl_rxon_context *)(& priv->contexts);
  goto ldv_55427;
  ldv_55426: ;
  if ((int )((unsigned long )priv->valid_contexts >> (int )ctx->ctxid) & 1) {
    memset((void *)(& ctx->wep_keys), 0, 96UL);
    ctx->key_mapping_keys = 0U;
  } else {

  }
  ctx = ctx + 1;
  ldv_55427: ;
  if ((unsigned long )((struct iwl_rxon_context *)(& priv->contexts) + 2UL) > (unsigned long )ctx) {
    goto ldv_55426;
  } else {

  }
  spin_unlock_bh(& priv->sta_lock);
  return;
}
}
void iwl_down(struct iwl_priv *priv ) 
{ 
  int exit_pending ;
    klee_make_symbolic(&exit_pending, sizeof(int), "exit_pending");
  int __ret_warn_on ;
  int tmp ;
  int tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  __iwl_dbg(priv->dev, 1U, 0, "iwl_down", "iwlwifi is going down\n");
  if (debug_locks != 0) {
    tmp = lock_is_held(& priv->mutex.dep_map);
    if (tmp == 0) {
      tmp___0 = 1;
    } else {
      tmp___0 = 0;
    }
  } else {
    tmp___0 = 0;
  }
  __ret_warn_on = tmp___0;
  tmp___1 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp___1 != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/08_1a/drivers/net/wireless/iwlwifi/dvm/main.c",
                       834);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  iwl_scan_cancel_timeout(priv, 200UL);
  exit_pending = test_and_set_bit(5L, (unsigned long volatile   *)(& priv->status));
  iwl_clear_ucode_stations(priv, (struct iwl_rxon_context *)0);
  iwl_dealloc_bcast_stations(priv);
  iwl_clear_driver_stations(priv);
  priv->bt_status = 0U;
  priv->cur_rssi_ctx = (struct iwl_rxon_context *)0;
  priv->bt_is_sco = 0;
  if ((unsigned long )(priv->lib)->bt_params != (unsigned long )((struct iwl_dvm_bt_params  const  */* const  */)0)) {
    priv->bt_traffic_load = ((priv->lib)->bt_params)->bt_init_traffic_load;
  } else {
    priv->bt_traffic_load = 0U;
  }
  priv->bt_full_concurrent = 0;
  priv->bt_ci_compliance = 0U;
  if (exit_pending == 0) {
    clear_bit(5L, (unsigned long volatile   *)(& priv->status));
  } else {

  }
  if ((unsigned int )priv->mac80211_registered != 0U) {
    ieee80211_stop_queues(priv->hw);
  } else {

  }
  priv->ucode_loaded = 0;
  iwl_trans_stop_device(priv->trans);
  atomic_set(& priv->num_aux_in_flight, 0);
  tmp___2 = constant_test_bit(0L, (unsigned long const volatile   *)(& priv->status));
  tmp___3 = constant_test_bit(10L, (unsigned long const volatile   *)(& priv->status));
  tmp___4 = constant_test_bit(5L, (unsigned long const volatile   *)(& priv->status));
  priv->status = priv->status & (unsigned long )((tmp___2 | (tmp___3 << 10)) | (tmp___4 << 5));
  consume_skb(priv->beacon_skb);
  priv->beacon_skb = (struct sk_buff *)0;
  return;
}
}
static void iwl_bg_run_time_calib_work(struct work_struct *work ) 
{ 
  struct iwl_priv *priv ;
  struct work_struct  const  *__mptr ;
  int tmp ;
  int tmp___0 ;

  {
  __mptr = (struct work_struct  const  *)work;
  priv = (struct iwl_priv *)__mptr + 0xffffffffffffcc30UL;
  mutex_lock_nested(& priv->mutex, 0U);
  tmp = constant_test_bit(5L, (unsigned long const volatile   *)(& priv->status));
  if (tmp != 0) {
    mutex_unlock(& priv->mutex);
    return;
  } else {
    tmp___0 = constant_test_bit(7L, (unsigned long const volatile   *)(& priv->status));
    if (tmp___0 != 0) {
      mutex_unlock(& priv->mutex);
      return;
    } else {

    }
  }
  if ((unsigned int )priv->start_calib != 0U) {
    iwl_chain_noise_calibration(priv);
    iwl_sensitivity_calibration(priv);
  } else {

  }
  mutex_unlock(& priv->mutex);
  return;
}
}
void iwlagn_prepare_restart(struct iwl_priv *priv ) 
{ 
  bool bt_full_concurrent ;
  u8 bt_ci_compliance ;
  u8 bt_load ;
  u8 bt_status ;
  bool bt_is_sco ;
  int i ;
  int __ret_warn_on ;
  int tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
  if (debug_locks != 0) {
    tmp = lock_is_held(& priv->mutex.dep_map);
    if (tmp == 0) {
      tmp___0 = 1;
    } else {
      tmp___0 = 0;
    }
  } else {
    tmp___0 = 0;
  }
  __ret_warn_on = tmp___0;
  tmp___1 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp___1 != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/08_1a/drivers/net/wireless/iwlwifi/dvm/main.c",
                       919);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  priv->is_open = 0U;
  bt_full_concurrent = priv->bt_full_concurrent;
  bt_ci_compliance = priv->bt_ci_compliance;
  bt_load = priv->bt_traffic_load;
  bt_status = priv->bt_status;
  bt_is_sco = priv->bt_is_sco;
  iwl_down(priv);
  priv->bt_full_concurrent = bt_full_concurrent;
  priv->bt_ci_compliance = bt_ci_compliance;
  priv->bt_traffic_load = bt_load;
  priv->bt_status = bt_status;
  priv->bt_is_sco = bt_is_sco;
  i = 11;
  goto ldv_55454;
  ldv_55453: 
  priv->queue_to_mac80211[i] = 255U;
  i = i + 1;
  ldv_55454: ;
  if (i <= 31) {
    goto ldv_55453;
  } else {

  }
  i = 0;
  goto ldv_55457;
  ldv_55456: 
  atomic_set((atomic_t *)(& priv->queue_stop_count) + (unsigned long )i, 0);
  i = i + 1;
  ldv_55457: ;
  if (i <= 31) {
    goto ldv_55456;
  } else {

  }
  memset((void *)(& priv->agg_q_alloc), 0, 8UL);
  return;
}
}
static void iwl_bg_restart(struct work_struct *data ) 
{ 
  struct iwl_priv *priv ;
  struct work_struct  const  *__mptr ;
  int tmp ;
  int __ret_warn_on ;
  long tmp___0 ;
  int tmp___1 ;

  {
  __mptr = (struct work_struct  const  *)data;
  priv = (struct iwl_priv *)__mptr + 0xffffffffffffd130UL;
  tmp = constant_test_bit(5L, (unsigned long const volatile   *)(& priv->status));
  if (tmp != 0) {
    return;
  } else {

  }
  tmp___1 = test_and_clear_bit(10L, (unsigned long volatile   *)(& priv->status));
  if (tmp___1 != 0) {
    mutex_lock_nested(& priv->mutex, 0U);
    iwlagn_prepare_restart(priv);
    mutex_unlock(& priv->mutex);
    iwl_cancel_deferred_work(priv);
    if ((unsigned int )priv->mac80211_registered != 0U) {
      ieee80211_restart_hw(priv->hw);
    } else {
      __iwl_err(priv->dev, 0, 0, "Cannot request restart before registrating with mac80211\n");
    }
  } else {
    __ret_warn_on = 1;
    tmp___0 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
    if (tmp___0 != 0L) {
      warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/08_1a/drivers/net/wireless/iwlwifi/dvm/main.c",
                         974);
    } else {

    }
    ldv__builtin_expect(__ret_warn_on != 0, 0L);
  }
  return;
}
}
static void iwl_setup_deferred_work(struct iwl_priv *priv ) 
{ 
  struct lock_class_key __key ;
  char const   *__lock_name ;
  struct workqueue_struct *tmp ;
  struct lock_class_key __key___0 ;
  atomic_long_t __constr_expr_0 ;
  struct lock_class_key __key___1 ;
  atomic_long_t __constr_expr_1 ;
  struct lock_class_key __key___2 ;
  atomic_long_t __constr_expr_2 ;
  struct lock_class_key __key___3 ;
  atomic_long_t __constr_expr_3 ;
  struct lock_class_key __key___4 ;
  atomic_long_t __constr_expr_4 ;
  struct lock_class_key __key___5 ;
  atomic_long_t __constr_expr_5 ;

  {
  __lock_name = "\"%s\"\"iwlwifi\"";
  tmp = __alloc_workqueue_key("%s", 131082U, 1, & __key, __lock_name, (char *)"iwlwifi");
  priv->workqueue = tmp;
  __init_work(& priv->restart, 0);
  __constr_expr_0.counter = 137438953408L;
  priv->restart.data = __constr_expr_0;
  lockdep_init_map(& priv->restart.lockdep_map, "(&priv->restart)", & __key___0, 0);
  INIT_LIST_HEAD(& priv->restart.entry);
  priv->restart.func = & iwl_bg_restart;
  __init_work(& priv->beacon_update, 0);
  __constr_expr_1.counter = 137438953408L;
  priv->beacon_update.data = __constr_expr_1;
  lockdep_init_map(& priv->beacon_update.lockdep_map, "(&priv->beacon_update)", & __key___1,
                   0);
  INIT_LIST_HEAD(& priv->beacon_update.entry);
  priv->beacon_update.func = & iwl_bg_beacon_update;
  __init_work(& priv->run_time_calib_work, 0);
  __constr_expr_2.counter = 137438953408L;
  priv->run_time_calib_work.data = __constr_expr_2;
  lockdep_init_map(& priv->run_time_calib_work.lockdep_map, "(&priv->run_time_calib_work)",
                   & __key___2, 0);
  INIT_LIST_HEAD(& priv->run_time_calib_work.entry);
  priv->run_time_calib_work.func = & iwl_bg_run_time_calib_work;
  __init_work(& priv->tx_flush, 0);
  __constr_expr_3.counter = 137438953408L;
  priv->tx_flush.data = __constr_expr_3;
  lockdep_init_map(& priv->tx_flush.lockdep_map, "(&priv->tx_flush)", & __key___3,
                   0);
  INIT_LIST_HEAD(& priv->tx_flush.entry);
  priv->tx_flush.func = & iwl_bg_tx_flush;
  __init_work(& priv->bt_full_concurrency, 0);
  __constr_expr_4.counter = 137438953408L;
  priv->bt_full_concurrency.data = __constr_expr_4;
  lockdep_init_map(& priv->bt_full_concurrency.lockdep_map, "(&priv->bt_full_concurrency)",
                   & __key___4, 0);
  INIT_LIST_HEAD(& priv->bt_full_concurrency.entry);
  priv->bt_full_concurrency.func = & iwl_bg_bt_full_concurrency;
  __init_work(& priv->bt_runtime_config, 0);
  __constr_expr_5.counter = 137438953408L;
  priv->bt_runtime_config.data = __constr_expr_5;
  lockdep_init_map(& priv->bt_runtime_config.lockdep_map, "(&priv->bt_runtime_config)",
                   & __key___5, 0);
  INIT_LIST_HEAD(& priv->bt_runtime_config.entry);
  priv->bt_runtime_config.func = & iwl_bg_bt_runtime_config;
  iwl_setup_scan_deferred_work(priv);
  if ((unsigned long )(priv->lib)->bt_params != (unsigned long )((struct iwl_dvm_bt_params  const  */* const  */)0)) {
    iwlagn_bt_setup_deferred_work(priv);
  } else {

  }
  reg_timer_18(& priv->statistics_periodic, & iwl_bg_statistics_periodic, (unsigned long )priv);
  reg_timer_18(& priv->ucode_trace, & iwl_bg_ucode_trace, (unsigned long )priv);
  return;
}
}
void iwl_cancel_deferred_work(struct iwl_priv *priv ) 
{ 


  {
  if ((unsigned long )(priv->lib)->bt_params != (unsigned long )((struct iwl_dvm_bt_params  const  */* const  */)0)) {
    iwlagn_bt_cancel_deferred_work(priv);
  } else {

  }
  ldv_cancel_work_sync_12(& priv->run_time_calib_work);
  ldv_cancel_work_sync_13(& priv->beacon_update);
  iwl_cancel_scan_deferred_work(priv);
  ldv_cancel_work_sync_14(& priv->bt_full_concurrency);
  ldv_cancel_work_sync_15(& priv->bt_runtime_config);
  ldv_del_timer_sync_16(& priv->statistics_periodic);
  ldv_del_timer_sync_17(& priv->ucode_trace);
  return;
}
}
static int iwl_init_drv(struct iwl_priv *priv ) 
{ 
  struct lock_class_key __key ;
  struct lock_class_key __key___0 ;

  {
  spinlock_check(& priv->sta_lock);
  __raw_spin_lock_init(& priv->sta_lock.__annonCompField18.rlock, "&(&priv->sta_lock)->rlock",
                       & __key);
  __mutex_init(& priv->mutex, "&priv->mutex", & __key___0);
  INIT_LIST_HEAD(& priv->calib_results);
  priv->band = 0;
  priv->plcp_delta_threshold = (priv->lib)->plcp_delta_threshold;
  priv->iw_mode = 2;
  priv->current_ht_config.smps = 2;
  priv->missed_beacon_threshold = 5;
  priv->agg_tids_count = 0U;
  priv->rx_statistics_jiffies = jiffies;
  iwlagn_set_rxon_chain(priv, (struct iwl_rxon_context *)(& priv->contexts));
  iwl_init_scan_params(priv);
  if ((unsigned long )(priv->lib)->bt_params != (unsigned long )((struct iwl_dvm_bt_params  const  */* const  */)0) && (int )((priv->lib)->bt_params)->advanced_bt_coexist) {
    priv->kill_ack_mask = 4294901760U;
    priv->kill_cts_mask = 4294901760U;
    priv->bt_valid = 255U;
    priv->bt_on_thresh = 4U;
    priv->bt_duration = 625U;
    priv->dynamic_frag_thresh = 0U;
  } else {

  }
  return (0);
}
}
static void iwl_uninit_drv(struct iwl_priv *priv ) 
{ 
  struct iwl_wipan_noa_data *________p1 ;
  struct iwl_wipan_noa_data *_________p1 ;
  union __anonunion___u_488 __u ;
  int tmp ;

  {
  kfree((void const   *)priv->scan_cmd);
  kfree((void const   *)priv->beacon_cmd);
  __read_once_size((void const volatile   *)(& priv->noa_data), (void *)(& __u.__c),
                   8);
  _________p1 = __u.__val;
  ________p1 = _________p1;
  tmp = debug_lockdep_rcu_enabled();
  kfree((void const   *)________p1);
  iwl_calib_free_results(priv);
  kfree((void const   *)priv->wowlan_sram);
  return;
}
}
static void iwl_set_hw_params(struct iwl_priv *priv ) 
{ 


  {
  if ((unsigned long )(priv->cfg)->ht_params != (unsigned long )((struct iwl_ht_params  const  */* const  */)0)) {
    priv->hw_params.use_rts_for_aggregation = ((priv->cfg)->ht_params)->use_rts_for_aggregation;
  } else {

  }
  (*((priv->lib)->set_hw_params))(priv);
  return;
}
}
static void iwl_option_config(struct iwl_priv *priv ) 
{ 


  {
  __iwl_info(priv->dev, "CONFIG_IWLWIFI_DEBUG enabled\n");
  __iwl_info(priv->dev, "CONFIG_IWLWIFI_DEBUGFS enabled\n");
  __iwl_info(priv->dev, "CONFIG_IWLWIFI_DEVICE_TRACING enabled\n");
  return;
}
}
static int iwl_eeprom_init_hw_params(struct iwl_priv *priv ) 
{ 
  struct iwl_nvm_data *data ;

  {
  data = priv->nvm_data;
  if ((int )data->sku_cap_11n_enable && (unsigned long )(priv->cfg)->ht_params == (unsigned long )((struct iwl_ht_params  const  */* const  */)0)) {
    __iwl_err(priv->dev, 0, 0, "Invalid 11n configuration\n");
    return (-22);
  } else {

  }
  if ((! data->sku_cap_11n_enable && ! data->sku_cap_band_24GHz_enable) && ! data->sku_cap_band_52GHz_enable) {
    __iwl_err(priv->dev, 0, 0, "Invalid device sku\n");
    return (-22);
  } else {

  }
  __iwl_dbg(priv->dev, 1U, 0, "iwl_eeprom_init_hw_params", "Device SKU: 24GHz %s %s, 52GHz %s %s, 11.n %s %s\n",
            (int )data->sku_cap_band_24GHz_enable ? (char *)"" : (char *)"NOT", (char *)"enabled",
            (int )data->sku_cap_band_52GHz_enable ? (char *)"" : (char *)"NOT", (char *)"enabled",
            (int )data->sku_cap_11n_enable ? (char *)"" : (char *)"NOT", (char *)"enabled");
  priv->hw_params.tx_chains_num = num_of_ant((int )data->valid_tx_ant);
  if ((int )(priv->cfg)->rx_with_siso_diversity) {
    priv->hw_params.rx_chains_num = 1U;
  } else {
    priv->hw_params.rx_chains_num = num_of_ant((int )data->valid_rx_ant);
  }
  __iwl_dbg(priv->dev, 1U, 0, "iwl_eeprom_init_hw_params", "Valid Tx ant: 0x%X, Valid Rx ant: 0x%X\n",
            (int )data->valid_tx_ant, (int )data->valid_rx_ant);
  return (0);
}
}
static struct iwl_op_mode *iwl_op_mode_dvm_start(struct iwl_trans *trans , struct iwl_cfg  const  *cfg ,
                                                 struct iwl_fw  const  *fw , struct dentry *dbgfs_dir ) 
{ 
  struct iwl_priv *priv ;
  struct ieee80211_hw *hw ;
  struct iwl_op_mode *op_mode ;
  u16 num_mac ;
  u32 ucode_flags ;
  struct iwl_trans_config trans_cfg ;
  u8 no_reclaim_cmds[5U] ;
  int i ;
  int __ret_warn_on ;
  long tmp ;
  long tmp___0 ;
  int __ret_warn_on___0 ;
  long tmp___1 ;
  struct lock_class_key __key ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
    klee_make_symbolic(&tmp___7, sizeof(int), "tmp___7");
  int tmp___8 ;
    klee_make_symbolic(&tmp___8, sizeof(int), "tmp___8");

  {
  trans_cfg.op_mode = 0;
  trans_cfg.cmd_queue = (unsigned char)0;
  trans_cfg.cmd_fifo = (unsigned char)0;
  trans_cfg.cmd_q_wdg_timeout = 0U;
  trans_cfg.no_reclaim_cmds = 0;
  trans_cfg.n_no_reclaim_cmds = 0U;
  trans_cfg.rx_buf_size_8k = (_Bool)0;
  trans_cfg.bc_table_dword = (_Bool)0;
  trans_cfg.scd_set_active = (_Bool)0;
  trans_cfg.command_names = 0;
  trans_cfg.sdio_adma_addr = 0U;
  no_reclaim_cmds[0] = 192U;
  no_reclaim_cmds[1] = 193U;
  no_reclaim_cmds[2] = 197U;
  no_reclaim_cmds[3] = 157U;
  no_reclaim_cmds[4] = 28U;
  hw = iwl_alloc_all();
  if ((unsigned long )hw == (unsigned long )((struct ieee80211_hw *)0)) {
    printk("\viwldvm: %s: Cannot allocate network device\n", cfg->name);
    goto out;
  } else {

  }
  op_mode = (struct iwl_op_mode *)hw->priv;
  op_mode->ops = & iwl_dvm_ops;
  priv = (struct iwl_priv *)(& op_mode->op_mode_specific);
  priv->trans = trans;
  priv->dev = trans->dev;
  priv->cfg = cfg;
  priv->fw = fw;
  switch ((unsigned int )(priv->cfg)->device_family) {
  case 1U: ;
  case 2U: 
  priv->lib = & iwl_dvm_1000_cfg;
  goto ldv_55534;
  case 3U: 
  priv->lib = & iwl_dvm_2000_cfg;
  goto ldv_55534;
  case 5U: 
  priv->lib = & iwl_dvm_105_cfg;
  goto ldv_55534;
  case 4U: ;
  case 6U: 
  priv->lib = & iwl_dvm_2030_cfg;
  goto ldv_55534;
  case 7U: 
  priv->lib = & iwl_dvm_5000_cfg;
  goto ldv_55534;
  case 8U: 
  priv->lib = & iwl_dvm_5150_cfg;
  goto ldv_55534;
  case 9U: ;
  case 10U: 
  priv->lib = & iwl_dvm_6000_cfg;
  goto ldv_55534;
  case 11U: 
  priv->lib = & iwl_dvm_6005_cfg;
  goto ldv_55534;
  case 13U: ;
  case 14U: 
  priv->lib = & iwl_dvm_6050_cfg;
  goto ldv_55534;
  case 12U: 
  priv->lib = & iwl_dvm_6030_cfg;
  goto ldv_55534;
  default: ;
  goto ldv_55534;
  }
  ldv_55534: 
  __ret_warn_on = (unsigned long )priv->lib == (unsigned long )((struct iwl_dvm_cfg  const  *)0);
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/08_1a/drivers/net/wireless/iwlwifi/dvm/main.c",
                       1220);
  } else {

  }
  tmp___0 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp___0 != 0L) {
    goto out_free_hw;
  } else {

  }
  trans_cfg.op_mode = op_mode;
  trans_cfg.no_reclaim_cmds = (u8 const   *)(& no_reclaim_cmds);
  trans_cfg.n_no_reclaim_cmds = 5U;
  trans_cfg.rx_buf_size_8k = iwlwifi_mod_params.amsdu_size_8K != 0;
  trans_cfg.cmd_q_wdg_timeout = 0U;
  trans_cfg.command_names = (char const   * const  *)(& iwl_dvm_cmd_strings);
  trans_cfg.cmd_fifo = 7U;
  __ret_warn_on___0 = (unsigned int )((priv->cfg)->base_params)->num_of_queues > 64U;
  tmp___1 = ldv__builtin_expect(__ret_warn_on___0 != 0, 0L);
  if (tmp___1 != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/08_1a/drivers/net/wireless/iwlwifi/dvm/main.c",
                       1237);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on___0 != 0, 0L);
  ucode_flags = fw->ucode_capa.flags;
  if ((int )ucode_flags & 1) {
    priv->sta_key_max_num = 16U;
    trans_cfg.cmd_queue = 9U;
  } else {
    priv->sta_key_max_num = 8U;
    trans_cfg.cmd_queue = 4U;
  }
  iwl_trans_configure(priv->trans, (struct iwl_trans_config  const  *)(& trans_cfg));
  trans->rx_mpdu_cmd = 193U;
  trans->rx_mpdu_cmd_hdr_size = 4U;
  SET_IEEE80211_DEV(priv->hw, (priv->trans)->dev);
  iwl_option_config(priv);
  __iwl_dbg(priv->dev, 1U, 0, "iwl_op_mode_dvm_start", "*** LOAD DRIVER ***\n");
  priv->bt_ant_couple_ok = iwlwifi_mod_params.ant_coupling > 35;
  priv->bt_ch_announce = 1;
  __iwl_dbg(priv->dev, 1U, 0, "iwl_op_mode_dvm_start", "BT channel inhibition is %s\n",
            (int )priv->bt_ch_announce ? (char *)"On" : (char *)"Off");
  spinlock_check(& priv->statistics.lock);
  __raw_spin_lock_init(& priv->statistics.lock.__annonCompField18.rlock, "&(&priv->statistics.lock)->rlock",
                       & __key);
  __iwl_info(priv->dev, "Detected %s, REV=0x%X\n", (priv->cfg)->name, (priv->trans)->hw_rev);
  tmp___2 = iwl_trans_start_hw(priv->trans);
  if (tmp___2 != 0) {
    goto out_free_hw;
  } else {

  }
  tmp___3 = iwl_read_eeprom(priv->trans, & priv->eeprom_blob, & priv->eeprom_blob_size);
  if (tmp___3 != 0) {
    __iwl_err(priv->dev, 0, 0, "Unable to init EEPROM\n");
    goto out_free_hw;
  } else {

  }
  iwl_trans_stop_device(priv->trans);
  priv->nvm_data = iwl_parse_eeprom_data((priv->trans)->dev, priv->cfg, (u8 const   *)priv->eeprom_blob,
                                         priv->eeprom_blob_size);
  if ((unsigned long )priv->nvm_data == (unsigned long )((struct iwl_nvm_data *)0)) {
    goto out_free_eeprom_blob;
  } else {

  }
  tmp___4 = iwl_nvm_check_version(priv->nvm_data, priv->trans);
  if (tmp___4 != 0) {
    goto out_free_eeprom;
  } else {

  }
  tmp___5 = iwl_eeprom_init_hw_params(priv);
  if (tmp___5 != 0) {
    goto out_free_eeprom;
  } else {

  }
  memcpy((void *)(& priv->addresses[0].addr), (void const   *)(& (priv->nvm_data)->hw_addr),
           6UL);
  __iwl_dbg(priv->dev, 1U, 0, "iwl_op_mode_dvm_start", "MAC address: %pM\n", (u8 *)(& priv->addresses[0].addr));
  ((priv->hw)->wiphy)->addresses = (struct mac_address *)(& priv->addresses);
  ((priv->hw)->wiphy)->n_addresses = 1U;
  num_mac = (u16 )(priv->nvm_data)->n_hw_addrs;
  if ((unsigned int )num_mac > 1U) {
    memcpy((void *)(& priv->addresses[1].addr), (void const   *)(& priv->addresses[0].addr),
             6UL);
    priv->addresses[1].addr[5] = (u8 )((int )priv->addresses[1].addr[5] + 1);
    ((priv->hw)->wiphy)->n_addresses = (u16 )((int )((priv->hw)->wiphy)->n_addresses + 1);
  } else {

  }
  iwl_set_hw_params(priv);
  if (! (priv->nvm_data)->sku_cap_ipan_enable) {
    __iwl_dbg(priv->dev, 1U, 0, "iwl_op_mode_dvm_start", "Your EEPROM disabled PAN\n");
    ucode_flags = ucode_flags & 4294967294U;
    priv->sta_key_max_num = 8U;
    trans_cfg.cmd_queue = 4U;
    iwl_trans_configure(priv->trans, (struct iwl_trans_config  const  *)(& trans_cfg));
  } else {

  }
  i = 0;
  goto ldv_55560;
  ldv_55559: 
  priv->queue_to_mac80211[i] = 255U;
  if ((i <= 10 && i != 4) && i != 9) {
    priv->queue_to_mac80211[i] = (u8 )i;
  } else {

  }
  atomic_set((atomic_t *)(& priv->queue_stop_count) + (unsigned long )i, 0);
  i = i + 1;
  ldv_55560: ;
  if (i <= 31) {
    goto ldv_55559;
  } else {

  }
  tmp___6 = iwl_init_drv(priv);
  if (tmp___6 != 0) {
    goto out_free_eeprom;
  } else {

  }
  iwl_setup_deferred_work(priv);
  iwl_setup_rx_handlers(priv);
  iwl_power_initialize(priv);
  iwl_tt_initialize(priv);
  snprintf((char *)(& ((priv->hw)->wiphy)->fw_version), 32UL, "%s", (char const   *)(& fw->fw_version));
  priv->new_scan_threshold_behaviour = (ucode_flags & 2U) != 0U;
  priv->phy_calib_chain_noise_reset_cmd = (u8 )fw->ucode_capa.standard_phy_calibration_size;
  priv->phy_calib_chain_noise_gain_cmd = (unsigned int )((u8 )fw->ucode_capa.standard_phy_calibration_size) + 1U;
  iwl_init_context(priv, ucode_flags);
  tmp___7 = iwlagn_mac_setup_register(priv, & fw->ucode_capa);
  if (tmp___7 != 0) {
    goto out_destroy_workqueue;
  } else {

  }
  tmp___8 = iwl_dbgfs_register(priv, dbgfs_dir);
  if (tmp___8 != 0) {
    goto out_mac80211_unregister;
  } else {

  }
  return (op_mode);
  out_mac80211_unregister: 
  iwlagn_mac_unregister(priv);
  out_destroy_workqueue: 
  iwl_tt_exit(priv);
  iwl_cancel_deferred_work(priv);
  ldv_destroy_workqueue_18(priv->workqueue);
  priv->workqueue = (struct workqueue_struct *)0;
  iwl_uninit_drv(priv);
  out_free_eeprom_blob: 
  kfree((void const   *)priv->eeprom_blob);
  out_free_eeprom: 
  iwl_free_nvm_data(priv->nvm_data);
  out_free_hw: 
  ldv_ieee80211_free_hw_19(priv->hw);
  out: 
  op_mode = (struct iwl_op_mode *)0;
  return (op_mode);
}
}
static void iwl_op_mode_dvm_stop(struct iwl_op_mode *op_mode ) 
{ 
  struct iwl_priv *priv ;

  {
  priv = (struct iwl_priv *)(& op_mode->op_mode_specific);
  __iwl_dbg(priv->dev, 1U, 0, "iwl_op_mode_dvm_stop", "*** UNLOAD DRIVER ***\n");
  iwlagn_mac_unregister(priv);
  iwl_tt_exit(priv);
  kfree((void const   *)priv->eeprom_blob);
  iwl_free_nvm_data(priv->nvm_data);
  ldv_flush_workqueue_20(priv->workqueue);
  ldv_destroy_workqueue_21(priv->workqueue);
  priv->workqueue = (struct workqueue_struct *)0;
  iwl_uninit_drv(priv);
  consume_skb(priv->beacon_skb);
  iwl_trans_op_mode_leave(priv->trans);
  ldv_ieee80211_free_hw_22(priv->hw);
  return;
}
}
static char const   * const  desc_lookup_text[28U]  = 
  {      "OK",      "FAIL",      "BAD_PARAM",      "BAD_CHECKSUM", 
        "NMI_INTERRUPT_WDG",      "SYSASSERT",      "FATAL_ERROR",      "BAD_COMMAND", 
        "HW_ERROR_TUNE_LOCK",      "HW_ERROR_TEMPERATURE",      "ILLEGAL_CHAN_FREQ",      "VCC_NOT_STABLE", 
        "FH_ERROR",      "NMI_INTERRUPT_HOST",      "NMI_INTERRUPT_ACTION_PT",      "NMI_INTERRUPT_UNKNOWN", 
        "UCODE_VERSION_MISMATCH",      "HW_ERROR_ABS_LOCK",      "HW_ERROR_CAL_LOCK_FAIL",      "NMI_INTERRUPT_INST_ACTION_PT", 
        "NMI_INTERRUPT_DATA_ACTION_PT",      "NMI_TRM_HW_ER",      "NMI_INTERRUPT_TRM",      "NMI_INTERRUPT_BREAK_POINT", 
        "DEBUG_0",      "DEBUG_1",      "DEBUG_2",      "DEBUG_3"};
static struct __anonstruct_advanced_lookup_490 advanced_lookup[16U]  = 
  {      {(char *)"NMI_INTERRUPT_WDG", 52U}, 
        {(char *)"SYSASSERT", 53U}, 
        {(char *)"UCODE_VERSION_MISMATCH", 55U}, 
        {(char *)"BAD_COMMAND", 56U}, 
        {(char *)"NMI_INTERRUPT_DATA_ACTION_PT", 60U}, 
        {(char *)"FATAL_ERROR", 61U}, 
        {(char *)"NMI_TRM_HW_ERR", 70U}, 
        {(char *)"NMI_INTERRUPT_TRM", 76U}, 
        {(char *)"NMI_INTERRUPT_BREAK_POINT", 84U}, 
        {(char *)"NMI_INTERRUPT_WDG_RXF_FULL", 92U}, 
        {(char *)"NMI_INTERRUPT_WDG_NO_RBD_RXF_FULL", 100U}, 
        {(char *)"NMI_INTERRUPT_HOST", 102U}, 
        {(char *)"NMI_INTERRUPT_ACTION_PT", 124U}, 
        {(char *)"NMI_INTERRUPT_UNKNOWN", 132U}, 
        {(char *)"NMI_INTERRUPT_INST_ACTION_PT", 134U}, 
        {(char *)"ADVANCED_SYSASSERT", 0U}};
static char const   *desc_lookup(u32 num ) 
{ 
  int i ;
  int max ;

  {
  max = 28;
  if ((u32 )max > num) {
    return ((char const   *)desc_lookup_text[num]);
  } else {

  }
  max = 15;
  i = 0;
  goto ldv_55585;
  ldv_55584: ;
  if ((u32 )advanced_lookup[i].num == num) {
    goto ldv_55583;
  } else {

  }
  i = i + 1;
  ldv_55585: ;
  if (i < max) {
    goto ldv_55584;
  } else {

  }
  ldv_55583: ;
  return ((char const   *)advanced_lookup[i].name);
}
}
static void iwl_dump_nic_error_log(struct iwl_priv *priv ) 
{ 
  struct iwl_trans *trans ;
  u32 base ;
  struct iwl_error_event_table table ;
  int tmp ;
  char const   *tmp___0 ;

  {
  trans = priv->trans;
  base = priv->device_pointers.error_event_table;
  if ((unsigned int )priv->cur_ucode == 1U) {
    if (base == 0U) {
      base = (priv->fw)->init_errlog_ptr;
    } else {

    }
  } else
  if (base == 0U) {
    base = (priv->fw)->inst_errlog_ptr;
  } else {

  }
  tmp = iwlagn_hw_valid_rtc_data_addr(base);
  if (tmp == 0) {
    __iwl_err(priv->dev, 0, 0, "Not valid error log pointer 0x%08X for %s uCode\n",
              base, (unsigned int )priv->cur_ucode == 1U ? (char *)"Init" : (char *)"RT");
    return;
  } else {

  }
  iwl_trans_read_mem(trans, base, (void *)(& table), 37);
  if ((unsigned long )table.valid * 28UL > 3UL) {
    __iwl_err(trans->dev, 0, 0, "Start IWL Error Log Dump:\n");
    __iwl_err(trans->dev, 0, 0, "Status: 0x%08lX, count: %d\n", priv->status, table.valid);
  } else {

  }
  trace_iwlwifi_dev_ucode_error((struct device  const  *)trans->dev, table.error_id,
                                table.tsf_low, table.data1, table.data2, table.line,
                                table.blink1, table.blink2, table.ilink1, table.ilink2,
                                table.bcon_time, table.gp1, table.gp2, table.gp3,
                                table.ucode_ver, table.hw_ver, 0U, table.brd_ver);
  tmp___0 = desc_lookup(table.error_id);
  __iwl_err(priv->dev, 0, 0, "0x%08X | %-28s\n", table.error_id, tmp___0);
  __iwl_err(priv->dev, 0, 0, "0x%08X | uPc\n", table.pc);
  __iwl_err(priv->dev, 0, 0, "0x%08X | branchlink1\n", table.blink1);
  __iwl_err(priv->dev, 0, 0, "0x%08X | branchlink2\n", table.blink2);
  __iwl_err(priv->dev, 0, 0, "0x%08X | interruptlink1\n", table.ilink1);
  __iwl_err(priv->dev, 0, 0, "0x%08X | interruptlink2\n", table.ilink2);
  __iwl_err(priv->dev, 0, 0, "0x%08X | data1\n", table.data1);
  __iwl_err(priv->dev, 0, 0, "0x%08X | data2\n", table.data2);
  __iwl_err(priv->dev, 0, 0, "0x%08X | line\n", table.line);
  __iwl_err(priv->dev, 0, 0, "0x%08X | beacon time\n", table.bcon_time);
  __iwl_err(priv->dev, 0, 0, "0x%08X | tsf low\n", table.tsf_low);
  __iwl_err(priv->dev, 0, 0, "0x%08X | tsf hi\n", table.tsf_hi);
  __iwl_err(priv->dev, 0, 0, "0x%08X | time gp1\n", table.gp1);
  __iwl_err(priv->dev, 0, 0, "0x%08X | time gp2\n", table.gp2);
  __iwl_err(priv->dev, 0, 0, "0x%08X | time gp3\n", table.gp3);
  __iwl_err(priv->dev, 0, 0, "0x%08X | uCode version\n", table.ucode_ver);
  __iwl_err(priv->dev, 0, 0, "0x%08X | hw version\n", table.hw_ver);
  __iwl_err(priv->dev, 0, 0, "0x%08X | board version\n", table.brd_ver);
  __iwl_err(priv->dev, 0, 0, "0x%08X | hcmd\n", table.hcmd);
  __iwl_err(priv->dev, 0, 0, "0x%08X | isr0\n", table.isr0);
  __iwl_err(priv->dev, 0, 0, "0x%08X | isr1\n", table.isr1);
  __iwl_err(priv->dev, 0, 0, "0x%08X | isr2\n", table.isr2);
  __iwl_err(priv->dev, 0, 0, "0x%08X | isr3\n", table.isr3);
  __iwl_err(priv->dev, 0, 0, "0x%08X | isr4\n", table.isr4);
  __iwl_err(priv->dev, 0, 0, "0x%08X | isr_pref\n", table.isr_pref);
  __iwl_err(priv->dev, 0, 0, "0x%08X | wait_event\n", table.wait_event);
  __iwl_err(priv->dev, 0, 0, "0x%08X | l2p_control\n", table.l2p_control);
  __iwl_err(priv->dev, 0, 0, "0x%08X | l2p_duration\n", table.l2p_duration);
  __iwl_err(priv->dev, 0, 0, "0x%08X | l2p_mhvalid\n", table.l2p_mhvalid);
  __iwl_err(priv->dev, 0, 0, "0x%08X | l2p_addr_match\n", table.l2p_addr_match);
  __iwl_err(priv->dev, 0, 0, "0x%08X | lmpm_pmg_sel\n", table.lmpm_pmg_sel);
  __iwl_err(priv->dev, 0, 0, "0x%08X | timestamp\n", table.u_timestamp);
  __iwl_err(priv->dev, 0, 0, "0x%08X | flow_handler\n", table.flow_handler);
  return;
}
}
static int iwl_print_event_log(struct iwl_priv *priv , u32 start_idx , u32 num_events ,
                               u32 mode , int pos , char **buf , size_t bufsz ) 
{ 
  u32 i ;
  u32 base ;
  u32 event_size ;
  u32 ptr ;
  u32 ev ;
  u32 time ;
  u32 data ;
  unsigned long reg_flags ;
  struct iwl_trans *trans ;
  bool tmp ;
  long tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  trans = priv->trans;
  if (num_events == 0U) {
    return (pos);
  } else {

  }
  base = priv->device_pointers.log_event_table;
  if ((unsigned int )priv->cur_ucode == 1U) {
    if (base == 0U) {
      base = (priv->fw)->init_evtlog_ptr;
    } else {

    }
  } else
  if (base == 0U) {
    base = (priv->fw)->inst_evtlog_ptr;
  } else {

  }
  if (mode == 0U) {
    event_size = 8U;
  } else {
    event_size = 12U;
  }
  ptr = (start_idx * event_size + base) + 16U;
  tmp = (*((trans->ops)->grab_nic_access))(trans, 0, & reg_flags);
  tmp___0 = ldv__builtin_expect((long )tmp, 1L);
  if (tmp___0 == 0L) {
    return (pos);
  } else {

  }
  iwl_write32(trans, 1036U, ptr);
  i = 0U;
  goto ldv_55611;
  ldv_55610: 
  ev = iwl_read32(trans, 1052U);
  time = iwl_read32(trans, 1052U);
  if (mode == 0U) {
    if (bufsz != 0UL) {
      tmp___1 = scnprintf(*buf + (unsigned long )pos, bufsz - (size_t )pos, "EVT_LOG:0x%08x:%04u\n",
                          time, ev);
      pos = tmp___1 + pos;
    } else {
      trace_iwlwifi_dev_ucode_event((struct device  const  *)trans->dev, 0U, time,
                                    ev);
      __iwl_err(priv->dev, 0, 0, "EVT_LOG:0x%08x:%04u\n", time, ev);
    }
  } else {
    data = iwl_read32(trans, 1052U);
    if (bufsz != 0UL) {
      tmp___2 = scnprintf(*buf + (unsigned long )pos, bufsz - (size_t )pos, "EVT_LOGT:%010u:0x%08x:%04u\n",
                          time, data, ev);
      pos = tmp___2 + pos;
    } else {
      __iwl_err(priv->dev, 0, 0, "EVT_LOGT:%010u:0x%08x:%04u\n", time, data, ev);
      trace_iwlwifi_dev_ucode_event((struct device  const  *)trans->dev, time, data,
                                    ev);
    }
  }
  i = i + 1U;
  ldv_55611: ;
  if (i < num_events) {
    goto ldv_55610;
  } else {

  }
  iwl_trans_release_nic_access(trans, & reg_flags);
  return (pos);
}
}
static int iwl_print_last_event_logs(struct iwl_priv *priv , u32 capacity , u32 num_wraps ,
                                     u32 next_entry , u32 size , u32 mode , int pos ,
                                     char **buf , size_t bufsz ) 
{ 


  {
  if (num_wraps != 0U) {
    if (next_entry < size) {
      pos = iwl_print_event_log(priv, (next_entry - size) + capacity, size - next_entry,
                                mode, pos, buf, bufsz);
      pos = iwl_print_event_log(priv, 0U, next_entry, mode, pos, buf, bufsz);
    } else {
      pos = iwl_print_event_log(priv, next_entry - size, size, mode, pos, buf, bufsz);
    }
  } else
  if (next_entry < size) {
    pos = iwl_print_event_log(priv, 0U, next_entry, mode, pos, buf, bufsz);
  } else {
    pos = iwl_print_event_log(priv, next_entry - size, size, mode, pos, buf, bufsz);
  }
  return (pos);
}
}
int iwl_dump_nic_event_log(struct iwl_priv *priv , bool full_log , char **buf ) 
{ 
  u32 base ;
  u32 capacity ;
  u32 mode ;
  u32 num_wraps ;
  u32 next_entry ;
  u32 size ;
  u32 logsize ;
  int pos ;
    klee_make_symbolic(&pos, sizeof(int), "pos");
  size_t bufsz ;
  struct iwl_trans *trans ;
  int tmp ;
  bool tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  bool tmp___3 ;

  {
  pos = 0;
  bufsz = 0UL;
  trans = priv->trans;
  base = priv->device_pointers.log_event_table;
  if ((unsigned int )priv->cur_ucode == 1U) {
    logsize = (priv->fw)->init_evtlog_size;
    if (base == 0U) {
      base = (priv->fw)->init_evtlog_ptr;
    } else {

    }
  } else {
    logsize = (priv->fw)->inst_evtlog_size;
    if (base == 0U) {
      base = (priv->fw)->inst_evtlog_ptr;
    } else {

    }
  }
  tmp = iwlagn_hw_valid_rtc_data_addr(base);
  if (tmp == 0) {
    __iwl_err(priv->dev, 0, 0, "Invalid event log pointer 0x%08X for %s uCode\n",
              base, (unsigned int )priv->cur_ucode == 1U ? (char *)"Init" : (char *)"RT");
    return (-22);
  } else {

  }
  capacity = iwl_trans_read_mem32(trans, base);
  mode = iwl_trans_read_mem32(trans, base + 4U);
  num_wraps = iwl_trans_read_mem32(trans, base + 8U);
  next_entry = iwl_trans_read_mem32(trans, base + 12U);
  if (capacity > logsize) {
    __iwl_err(priv->dev, 0, 0, "Log capacity %d is bogus, limit to %d entries\n",
              capacity, logsize);
    capacity = logsize;
  } else {

  }
  if (next_entry > logsize) {
    __iwl_err(priv->dev, 0, 0, "Log write index %d is bogus, limit to %d\n", next_entry,
              logsize);
    next_entry = logsize;
  } else {

  }
  size = num_wraps != 0U ? capacity : next_entry;
  if (size == 0U) {
    __iwl_err(trans->dev, 0, 0, "Start IWL Event Log Dump: nothing in log\n");
    return (pos);
  } else {

  }
  tmp___0 = iwl_have_debug_level(262144U);
  if (tmp___0) {
    tmp___1 = 0;
  } else {
    tmp___1 = 1;
  }
  if (tmp___1 && ! full_log) {
    size = 20U < size ? 20U : size;
  } else {

  }
  __iwl_err(priv->dev, 0, 0, "Start IWL Event Log Dump: display last %u entries\n",
            size);
  if ((unsigned long )buf != (unsigned long )((char **)0)) {
    if ((int )full_log) {
      bufsz = (size_t )(capacity * 48U);
    } else {
      bufsz = (size_t )(size * 48U);
    }
    tmp___2 = kmalloc(bufsz, 208U);
    *buf = (char *)tmp___2;
    if ((unsigned long )*buf == (unsigned long )((char *)0)) {
      return (-12);
    } else {

    }
  } else {

  }
  tmp___3 = iwl_have_debug_level(262144U);
  if ((int )tmp___3 || (int )full_log) {
    if (num_wraps != 0U) {
      pos = iwl_print_event_log(priv, next_entry, capacity - next_entry, mode, pos,
                                buf, bufsz);
    } else {

    }
    pos = iwl_print_event_log(priv, 0U, next_entry, mode, pos, buf, bufsz);
  } else {
    pos = iwl_print_last_event_logs(priv, capacity, num_wraps, next_entry, size, mode,
                                    pos, buf, bufsz);
  }
  return (pos);
}
}
static void iwlagn_fw_error(struct iwl_priv *priv , bool ondemand ) 
{ 
  unsigned int reload_msec ;
    klee_make_symbolic(&reload_msec, sizeof(int), "reload_msec");
  unsigned long reload_jiffies ;
  bool tmp ;
  int tmp___0 ;

  {
  tmp = iwl_have_debug_level(262144U);
  if ((int )tmp) {
    iwl_print_rx_config_cmd(priv, 0);
  } else {

  }
  priv->ucode_loaded = 0;
  set_bit(10L, (unsigned long volatile   *)(& priv->status));
  iwl_abort_notification_waits(& priv->notif_wait);
  clear_bit(3L, (unsigned long volatile   *)(& priv->status));
  if (! ondemand) {
    reload_jiffies = jiffies;
    reload_msec = jiffies_to_msecs((unsigned long const   )((long )reload_jiffies - (long )priv->reload_jiffies));
    priv->reload_jiffies = reload_jiffies;
    if (reload_msec <= 1000U) {
      priv->reload_count = priv->reload_count + 1;
      if (priv->reload_count > 3) {
        __iwl_err(priv->dev, 0, 0, "BUG_ON, Stop restarting\n");
        return;
      } else {

      }
    } else {
      priv->reload_count = 0;
    }
  } else {

  }
  tmp___0 = constant_test_bit(5L, (unsigned long const volatile   *)(& priv->status));
  if (tmp___0 == 0) {
    if ((int )iwlwifi_mod_params.restart_fw) {
      __iwl_dbg(priv->dev, 262144U, 0, "iwlagn_fw_error", "Restarting adapter due to uCode error.\n");
      queue_work(priv->workqueue, & priv->restart);
    } else {
      __iwl_dbg(priv->dev, 262144U, 0, "iwlagn_fw_error", "Detected FW error, but not restarting\n");
    }
  } else {

  }
  return;
}
}
static void iwl_nic_error(struct iwl_op_mode *op_mode ) 
{ 
  struct iwl_priv *priv ;

  {
  priv = (struct iwl_priv *)(& op_mode->op_mode_specific);
  __iwl_err(priv->dev, 0, 0, "Loaded firmware version: %s\n", (char const   *)(& (priv->fw)->fw_version));
  iwl_dump_nic_error_log(priv);
  iwl_dump_nic_event_log(priv, 0, (char **)0);
  iwlagn_fw_error(priv, 0);
  return;
}
}
static void iwl_cmd_queue_full(struct iwl_op_mode *op_mode ) 
{ 
  struct iwl_priv *priv ;
  bool tmp ;
  int tmp___0 ;

  {
  priv = (struct iwl_priv *)(& op_mode->op_mode_specific);
  tmp = iwl_check_for_ct_kill(priv);
  if (tmp) {
    tmp___0 = 0;
  } else {
    tmp___0 = 1;
  }
  if (tmp___0) {
    __iwl_err(priv->dev, 0, 0, "Restarting adapter queue is full\n");
    iwlagn_fw_error(priv, 0);
  } else {

  }
  return;
}
}
static void iwl_nic_config(struct iwl_op_mode *op_mode ) 
{ 
  struct iwl_priv *priv ;
  u32 reg_val ;
  int __ret_warn_on ;
  long tmp ;

  {
  priv = (struct iwl_priv *)(& op_mode->op_mode_specific);
  iwl_trans_set_bits_mask(priv->trans, 0U, 15U, (priv->trans)->hw_rev & 15U);
  if ((unsigned int )(priv->nvm_data)->radio_cfg_type <= 3U) {
    reg_val = (u32 )((((int )(priv->nvm_data)->radio_cfg_type << 10) | ((int )(priv->nvm_data)->radio_cfg_step << 14)) | ((int )(priv->nvm_data)->radio_cfg_dash << 12));
    iwl_trans_set_bits_mask(priv->trans, 0U, 64512U, reg_val);
    __iwl_info(priv->dev, "Radio type=0x%x-0x%x-0x%x\n", (int )(priv->nvm_data)->radio_cfg_type,
               (int )(priv->nvm_data)->radio_cfg_step, (int )(priv->nvm_data)->radio_cfg_dash);
  } else {
    __ret_warn_on = 1;
    tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
    if (tmp != 0L) {
      warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/08_1a/drivers/net/wireless/iwlwifi/dvm/main.c",
                         1921);
    } else {

    }
    ldv__builtin_expect(__ret_warn_on != 0, 0L);
  }
  iwl_set_bit(priv->trans, 0U, 768U);
  iwl_set_bits_mask_prph(priv->trans, 12300U, 4194304U, 4290772991U);
  if ((unsigned long )(priv->lib)->nic_config != (unsigned long )((void (*/* const  */)(struct iwl_priv * ))0)) {
    (*((priv->lib)->nic_config))(priv);
  } else {

  }
  return;
}
}
static void iwl_wimax_active(struct iwl_op_mode *op_mode ) 
{ 
  struct iwl_priv *priv ;

  {
  priv = (struct iwl_priv *)(& op_mode->op_mode_specific);
  clear_bit(3L, (unsigned long volatile   *)(& priv->status));
  __iwl_err(priv->dev, 0, 0, "RF is used by WiMAX\n");
  return;
}
}
static void iwl_stop_sw_queue(struct iwl_op_mode *op_mode , int queue ) 
{ 
  struct iwl_priv *priv ;
  int mq ;
    klee_make_symbolic(&mq, sizeof(int), "mq");
  bool __warned ;
  int __ret_warn_once ;
    klee_make_symbolic(&__ret_warn_once, sizeof(int), "__ret_warn_once");
  int __ret_warn_on ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  int tmp___3 ;

  {
  priv = (struct iwl_priv *)(& op_mode->op_mode_specific);
  mq = (int )priv->queue_to_mac80211[queue];
  __ret_warn_once = mq == 255;
  tmp___1 = ldv__builtin_expect(__ret_warn_once != 0, 0L);
  if (tmp___1 != 0L) {
    __ret_warn_on = ! __warned;
    tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
    if (tmp != 0L) {
      warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/08_1a/drivers/net/wireless/iwlwifi/dvm/main.c",
                         1954);
    } else {

    }
    tmp___0 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
    if (tmp___0 != 0L) {
      __warned = 1;
    } else {

    }
  } else {

  }
  tmp___2 = ldv__builtin_expect(__ret_warn_once != 0, 0L);
  if (tmp___2 != 0L) {
    return;
  } else {

  }
  tmp___3 = atomic_add_return(1, (atomic_t *)(& priv->queue_stop_count) + (unsigned long )mq);
  if (tmp___3 > 1) {
    __iwl_dbg(priv->dev, 2147483648U, 0, "iwl_stop_sw_queue", "queue %d (mac80211 %d) already stopped\n",
              queue, mq);
    return;
  } else {

  }
  set_bit((long )mq, (unsigned long volatile   *)(& priv->transport_queue_stop));
  ieee80211_stop_queue(priv->hw, mq);
  return;
}
}
static void iwl_wake_sw_queue(struct iwl_op_mode *op_mode , int queue ) 
{ 
  struct iwl_priv *priv ;
  int mq ;
  bool __warned ;
  int __ret_warn_once ;
  int __ret_warn_on ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  int tmp___3 ;

  {
  priv = (struct iwl_priv *)(& op_mode->op_mode_specific);
  mq = (int )priv->queue_to_mac80211[queue];
  __ret_warn_once = mq == 255;
  tmp___1 = ldv__builtin_expect(__ret_warn_once != 0, 0L);
  if (tmp___1 != 0L) {
    __ret_warn_on = ! __warned;
    tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
    if (tmp != 0L) {
      warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/08_1a/drivers/net/wireless/iwlwifi/dvm/main.c",
                         1973);
    } else {

    }
    tmp___0 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
    if (tmp___0 != 0L) {
      __warned = 1;
    } else {

    }
  } else {

  }
  tmp___2 = ldv__builtin_expect(__ret_warn_once != 0, 0L);
  if (tmp___2 != 0L) {
    return;
  } else {

  }
  tmp___3 = atomic_sub_return(1, (atomic_t *)(& priv->queue_stop_count) + (unsigned long )mq);
  if (tmp___3 > 0) {
    __iwl_dbg(priv->dev, 2147483648U, 0, "iwl_wake_sw_queue", "queue %d (mac80211 %d) already awake\n",
              queue, mq);
    return;
  } else {

  }
  clear_bit((long )mq, (unsigned long volatile   *)(& priv->transport_queue_stop));
  if (! priv->passive_no_rx) {
    ieee80211_wake_queue(priv->hw, mq);
  } else {

  }
  return;
}
}
void iwlagn_lift_passive_no_rx(struct iwl_priv *priv ) 
{ 
  int mq ;
  int tmp ;

  {
  if (! priv->passive_no_rx) {
    return;
  } else {

  }
  mq = 0;
  goto ldv_55695;
  ldv_55694: 
  tmp = variable_test_bit((long )mq, (unsigned long const volatile   *)(& priv->transport_queue_stop));
  if (tmp == 0) {
    __iwl_dbg(priv->dev, 2147483648U, 0, "iwlagn_lift_passive_no_rx", "Wake queue %d\n",
              mq);
    ieee80211_wake_queue(priv->hw, mq);
  } else {
    __iwl_dbg(priv->dev, 2147483648U, 0, "iwlagn_lift_passive_no_rx", "Don\'t wake queue %d\n",
              mq);
  }
  mq = mq + 1;
  ldv_55695: ;
  if (mq <= 10) {
    goto ldv_55694;
  } else {

  }
  priv->passive_no_rx = 0;
  return;
}
}
static void iwl_free_skb(struct iwl_op_mode *op_mode , struct sk_buff *skb ) 
{ 
  struct iwl_priv *priv ;
  struct ieee80211_tx_info *info ;

  {
  priv = (struct iwl_priv *)(& op_mode->op_mode_specific);
  info = IEEE80211_SKB_CB(skb);
  iwl_trans_free_tx_cmd(priv->trans, (struct iwl_device_cmd *)info->__annonCompField99.driver_data[1]);
  ieee80211_free_txskb(priv->hw, skb);
  return;
}
}
static bool iwl_set_hw_rfkill_state(struct iwl_op_mode *op_mode , bool state ) 
{ 
  struct iwl_priv *priv ;

  {
  priv = (struct iwl_priv *)(& op_mode->op_mode_specific);
  if ((int )state) {
    set_bit(0L, (unsigned long volatile   *)(& priv->status));
  } else {
    clear_bit(0L, (unsigned long volatile   *)(& priv->status));
  }
  wiphy_rfkill_set_hw_state((priv->hw)->wiphy, (int )state);
  return (0);
}
}
static void iwl_napi_add(struct iwl_op_mode *op_mode , struct napi_struct *napi ,
                         struct net_device *napi_dev , int (*poll)(struct napi_struct * ,
                                                                   int  ) , int weight ) 
{ 
  struct iwl_priv *priv ;

  {
  priv = (struct iwl_priv *)(& op_mode->op_mode_specific);
  ieee80211_napi_add(priv->hw, napi, napi_dev, poll, weight);
  return;
}
}
static struct iwl_op_mode_ops  const  iwl_dvm_ops  = 
     {& iwl_op_mode_dvm_start, & iwl_op_mode_dvm_stop, & iwl_rx_dispatch, & iwl_napi_add,
    & iwl_stop_sw_queue, & iwl_wake_sw_queue, & iwl_set_hw_rfkill_state, & iwl_free_skb,
    & iwl_nic_error, & iwl_cmd_queue_full, & iwl_nic_config, & iwl_wimax_active, 0,
    0};
static int iwl_init(void) 
{ 
  int ret ;

  {
  ret = iwlagn_rate_control_register();
  if (ret != 0) {
    printk("\viwldvm: Unable to register rate control algorithm: %d\n", ret);
    return (ret);
  } else {

  }
  ret = iwl_opmode_register("iwldvm", & iwl_dvm_ops);
  if (ret != 0) {
    printk("\viwldvm: Unable to register op_mode: %d\n", ret);
    iwlagn_rate_control_unregister();
  } else {

  }
  return (ret);
}
}
static void iwl_exit(void) 
{ 


  {
  iwl_opmode_deregister("iwldvm");
  iwlagn_rate_control_unregister();
  return;
}
}
extern void ldv_initialize(void) ;
void ldv_check_final_state(void) ;
int ldv_retval_30  ;
    klee_make_symbolic(&ldv_retval_30, sizeof(int), "ldv_retval_30");
void activate_work_5(struct work_struct *work , int state ) 
{ 


  {
  if (ldv_work_5_0 == 0) {
    ldv_work_struct_5_0 = work;
    ldv_work_5_0 = state;
    return;
  } else {

  }
  if (ldv_work_5_1 == 0) {
    ldv_work_struct_5_1 = work;
    ldv_work_5_1 = state;
    return;
  } else {

  }
  if (ldv_work_5_2 == 0) {
    ldv_work_struct_5_2 = work;
    ldv_work_5_2 = state;
    return;
  } else {

  }
  if (ldv_work_5_3 == 0) {
    ldv_work_struct_5_3 = work;
    ldv_work_5_3 = state;
    return;
  } else {

  }
  return;
}
}
void disable_suitable_timer_16(struct timer_list *timer ) 
{ 


  {
  if (ldv_timer_16_0 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_16_0) {
    ldv_timer_16_0 = 0;
    return;
  } else {

  }
  if (ldv_timer_16_1 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_16_1) {
    ldv_timer_16_1 = 0;
    return;
  } else {

  }
  if (ldv_timer_16_2 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_16_2) {
    ldv_timer_16_2 = 0;
    return;
  } else {

  }
  if (ldv_timer_16_3 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_16_3) {
    ldv_timer_16_3 = 0;
    return;
  } else {

  }
  return;
}
}
void work_init_5(void) 
{ 


  {
  ldv_work_5_0 = 0;
  ldv_work_5_1 = 0;
  ldv_work_5_2 = 0;
  ldv_work_5_3 = 0;
  return;
}
}
void call_and_disable_all_4(int state ) 
{ 


  {
  if (ldv_work_4_0 == state) {
    call_and_disable_work_4(ldv_work_struct_4_0);
  } else {

  }
  if (ldv_work_4_1 == state) {
    call_and_disable_work_4(ldv_work_struct_4_1);
  } else {

  }
  if (ldv_work_4_2 == state) {
    call_and_disable_work_4(ldv_work_struct_4_2);
  } else {

  }
  if (ldv_work_4_3 == state) {
    call_and_disable_work_4(ldv_work_struct_4_3);
  } else {

  }
  return;
}
}
void activate_work_1(struct work_struct *work , int state ) 
{ 


  {
  if (ldv_work_1_0 == 0) {
    ldv_work_struct_1_0 = work;
    ldv_work_1_0 = state;
    return;
  } else {

  }
  if (ldv_work_1_1 == 0) {
    ldv_work_struct_1_1 = work;
    ldv_work_1_1 = state;
    return;
  } else {

  }
  if (ldv_work_1_2 == 0) {
    ldv_work_struct_1_2 = work;
    ldv_work_1_2 = state;
    return;
  } else {

  }
  if (ldv_work_1_3 == 0) {
    ldv_work_struct_1_3 = work;
    ldv_work_1_3 = state;
    return;
  } else {

  }
  return;
}
}
void call_and_disable_work_3(struct work_struct *work ) 
{ 


  {
  if ((ldv_work_3_0 == 2 || ldv_work_3_0 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_3_0) {
    iwl_bg_run_time_calib_work(work);
    ldv_work_3_0 = 1;
    return;
  } else {

  }
  if ((ldv_work_3_1 == 2 || ldv_work_3_1 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_3_1) {
    iwl_bg_run_time_calib_work(work);
    ldv_work_3_1 = 1;
    return;
  } else {

  }
  if ((ldv_work_3_2 == 2 || ldv_work_3_2 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_3_2) {
    iwl_bg_run_time_calib_work(work);
    ldv_work_3_2 = 1;
    return;
  } else {

  }
  if ((ldv_work_3_3 == 2 || ldv_work_3_3 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_3_3) {
    iwl_bg_run_time_calib_work(work);
    ldv_work_3_3 = 1;
    return;
  } else {

  }
  return;
}
}
void disable_work_3(struct work_struct *work ) 
{ 


  {
  if ((ldv_work_3_0 == 3 || ldv_work_3_0 == 2) && (unsigned long )ldv_work_struct_3_0 == (unsigned long )work) {
    ldv_work_3_0 = 1;
  } else {

  }
  if ((ldv_work_3_1 == 3 || ldv_work_3_1 == 2) && (unsigned long )ldv_work_struct_3_1 == (unsigned long )work) {
    ldv_work_3_1 = 1;
  } else {

  }
  if ((ldv_work_3_2 == 3 || ldv_work_3_2 == 2) && (unsigned long )ldv_work_struct_3_2 == (unsigned long )work) {
    ldv_work_3_2 = 1;
  } else {

  }
  if ((ldv_work_3_3 == 3 || ldv_work_3_3 == 2) && (unsigned long )ldv_work_struct_3_3 == (unsigned long )work) {
    ldv_work_3_3 = 1;
  } else {

  }
  return;
}
}
void work_init_1(void) 
{ 


  {
  ldv_work_1_0 = 0;
  ldv_work_1_1 = 0;
  ldv_work_1_2 = 0;
  ldv_work_1_3 = 0;
  return;
}
}
void invoke_work_4(void) 
{ 
  int tmp ;

  {
  tmp = __VERIFIER_nondet_int();
  switch (tmp) {
  case 0: ;
  if (ldv_work_4_0 == 2 || ldv_work_4_0 == 3) {
    ldv_work_4_0 = 4;
    iwl_bg_tx_flush(ldv_work_struct_4_0);
    ldv_work_4_0 = 1;
  } else {

  }
  goto ldv_55775;
  case 1: ;
  if (ldv_work_4_1 == 2 || ldv_work_4_1 == 3) {
    ldv_work_4_1 = 4;
    iwl_bg_tx_flush(ldv_work_struct_4_0);
    ldv_work_4_1 = 1;
  } else {

  }
  goto ldv_55775;
  case 2: ;
  if (ldv_work_4_2 == 2 || ldv_work_4_2 == 3) {
    ldv_work_4_2 = 4;
    iwl_bg_tx_flush(ldv_work_struct_4_0);
    ldv_work_4_2 = 1;
  } else {

  }
  goto ldv_55775;
  case 3: ;
  if (ldv_work_4_3 == 2 || ldv_work_4_3 == 3) {
    ldv_work_4_3 = 4;
    iwl_bg_tx_flush(ldv_work_struct_4_0);
    ldv_work_4_3 = 1;
  } else {

  }
  goto ldv_55775;
  default: 
  ldv_stop();
  }
  ldv_55775: ;
  return;
}
}
void activate_suitable_timer_15(struct timer_list *timer , unsigned long data ) 
{ 


  {
  if (ldv_timer_15_0 == 0 || ldv_timer_15_0 == 2) {
    ldv_timer_list_15_0 = timer;
    ldv_timer_list_15_0->data = data;
    ldv_timer_15_0 = 1;
    return;
  } else {

  }
  if (ldv_timer_15_1 == 0 || ldv_timer_15_1 == 2) {
    ldv_timer_list_15_1 = timer;
    ldv_timer_list_15_1->data = data;
    ldv_timer_15_1 = 1;
    return;
  } else {

  }
  if (ldv_timer_15_2 == 0 || ldv_timer_15_2 == 2) {
    ldv_timer_list_15_2 = timer;
    ldv_timer_list_15_2->data = data;
    ldv_timer_15_2 = 1;
    return;
  } else {

  }
  if (ldv_timer_15_3 == 0 || ldv_timer_15_3 == 2) {
    ldv_timer_list_15_3 = timer;
    ldv_timer_list_15_3->data = data;
    ldv_timer_15_3 = 1;
    return;
  } else {

  }
  return;
}
}
void activate_work_6(struct work_struct *work , int state ) 
{ 


  {
  if (ldv_work_6_0 == 0) {
    ldv_work_struct_6_0 = work;
    ldv_work_6_0 = state;
    return;
  } else {

  }
  if (ldv_work_6_1 == 0) {
    ldv_work_struct_6_1 = work;
    ldv_work_6_1 = state;
    return;
  } else {

  }
  if (ldv_work_6_2 == 0) {
    ldv_work_struct_6_2 = work;
    ldv_work_6_2 = state;
    return;
  } else {

  }
  if (ldv_work_6_3 == 0) {
    ldv_work_struct_6_3 = work;
    ldv_work_6_3 = state;
    return;
  } else {

  }
  return;
}
}
int reg_timer_15(struct timer_list *timer , void (*function)(unsigned long  ) , unsigned long data ) 
{ 


  {
  if ((unsigned long )function == (unsigned long )(& iwl_bg_statistics_periodic)) {
    activate_suitable_timer_15(timer, data);
  } else {

  }
  return (0);
}
}
void ldv_initialize_iwl_op_mode_ops_69(void) 
{ 
  void *tmp ;

  {
  tmp = ldv_init_zalloc(8UL);
  iwl_dvm_ops_group0 = (struct iwl_op_mode *)tmp;
  return;
}
}
void timer_init_16(void) 
{ 


  {
  ldv_timer_16_0 = 0;
  ldv_timer_16_1 = 0;
  ldv_timer_16_2 = 0;
  ldv_timer_16_3 = 0;
  return;
}
}
void activate_work_2(struct work_struct *work , int state ) 
{ 


  {
  if (ldv_work_2_0 == 0) {
    ldv_work_struct_2_0 = work;
    ldv_work_2_0 = state;
    return;
  } else {

  }
  if (ldv_work_2_1 == 0) {
    ldv_work_struct_2_1 = work;
    ldv_work_2_1 = state;
    return;
  } else {

  }
  if (ldv_work_2_2 == 0) {
    ldv_work_struct_2_2 = work;
    ldv_work_2_2 = state;
    return;
  } else {

  }
  if (ldv_work_2_3 == 0) {
    ldv_work_struct_2_3 = work;
    ldv_work_2_3 = state;
    return;
  } else {

  }
  return;
}
}
void activate_pending_timer_15(struct timer_list *timer , unsigned long data , int pending_flag ) 
{ 


  {
  if ((unsigned long )ldv_timer_list_15_0 == (unsigned long )timer) {
    if (ldv_timer_15_0 == 2 || pending_flag != 0) {
      ldv_timer_list_15_0 = timer;
      ldv_timer_list_15_0->data = data;
      ldv_timer_15_0 = 1;
    } else {

    }
    return;
  } else {

  }
  if ((unsigned long )ldv_timer_list_15_1 == (unsigned long )timer) {
    if (ldv_timer_15_1 == 2 || pending_flag != 0) {
      ldv_timer_list_15_1 = timer;
      ldv_timer_list_15_1->data = data;
      ldv_timer_15_1 = 1;
    } else {

    }
    return;
  } else {

  }
  if ((unsigned long )ldv_timer_list_15_2 == (unsigned long )timer) {
    if (ldv_timer_15_2 == 2 || pending_flag != 0) {
      ldv_timer_list_15_2 = timer;
      ldv_timer_list_15_2->data = data;
      ldv_timer_15_2 = 1;
    } else {

    }
    return;
  } else {

  }
  if ((unsigned long )ldv_timer_list_15_3 == (unsigned long )timer) {
    if (ldv_timer_15_3 == 2 || pending_flag != 0) {
      ldv_timer_list_15_3 = timer;
      ldv_timer_list_15_3->data = data;
      ldv_timer_15_3 = 1;
    } else {

    }
    return;
  } else {

  }
  activate_suitable_timer_15(timer, data);
  return;
}
}
void invoke_work_5(void) 
{ 
  int tmp ;

  {
  tmp = __VERIFIER_nondet_int();
  switch (tmp) {
  case 0: ;
  if (ldv_work_5_0 == 2 || ldv_work_5_0 == 3) {
    ldv_work_5_0 = 4;
    iwl_bg_bt_full_concurrency(ldv_work_struct_5_0);
    ldv_work_5_0 = 1;
  } else {

  }
  goto ldv_55815;
  case 1: ;
  if (ldv_work_5_1 == 2 || ldv_work_5_1 == 3) {
    ldv_work_5_1 = 4;
    iwl_bg_bt_full_concurrency(ldv_work_struct_5_0);
    ldv_work_5_1 = 1;
  } else {

  }
  goto ldv_55815;
  case 2: ;
  if (ldv_work_5_2 == 2 || ldv_work_5_2 == 3) {
    ldv_work_5_2 = 4;
    iwl_bg_bt_full_concurrency(ldv_work_struct_5_0);
    ldv_work_5_2 = 1;
  } else {

  }
  goto ldv_55815;
  case 3: ;
  if (ldv_work_5_3 == 2 || ldv_work_5_3 == 3) {
    ldv_work_5_3 = 4;
    iwl_bg_bt_full_concurrency(ldv_work_struct_5_0);
    ldv_work_5_3 = 1;
  } else {

  }
  goto ldv_55815;
  default: 
  ldv_stop();
  }
  ldv_55815: ;
  return;
}
}
void disable_work_4(struct work_struct *work ) 
{ 


  {
  if ((ldv_work_4_0 == 3 || ldv_work_4_0 == 2) && (unsigned long )ldv_work_struct_4_0 == (unsigned long )work) {
    ldv_work_4_0 = 1;
  } else {

  }
  if ((ldv_work_4_1 == 3 || ldv_work_4_1 == 2) && (unsigned long )ldv_work_struct_4_1 == (unsigned long )work) {
    ldv_work_4_1 = 1;
  } else {

  }
  if ((ldv_work_4_2 == 3 || ldv_work_4_2 == 2) && (unsigned long )ldv_work_struct_4_2 == (unsigned long )work) {
    ldv_work_4_2 = 1;
  } else {

  }
  if ((ldv_work_4_3 == 3 || ldv_work_4_3 == 2) && (unsigned long )ldv_work_struct_4_3 == (unsigned long )work) {
    ldv_work_4_3 = 1;
  } else {

  }
  return;
}
}
void work_init_4(void) 
{ 


  {
  ldv_work_4_0 = 0;
  ldv_work_4_1 = 0;
  ldv_work_4_2 = 0;
  ldv_work_4_3 = 0;
  return;
}
}
void invoke_work_1(void) 
{ 
  int tmp ;

  {
  tmp = __VERIFIER_nondet_int();
  switch (tmp) {
  case 0: ;
  if (ldv_work_1_0 == 2 || ldv_work_1_0 == 3) {
    ldv_work_1_0 = 4;
    iwl_bg_restart(ldv_work_struct_1_0);
    ldv_work_1_0 = 1;
  } else {

  }
  goto ldv_55832;
  case 1: ;
  if (ldv_work_1_1 == 2 || ldv_work_1_1 == 3) {
    ldv_work_1_1 = 4;
    iwl_bg_restart(ldv_work_struct_1_0);
    ldv_work_1_1 = 1;
  } else {

  }
  goto ldv_55832;
  case 2: ;
  if (ldv_work_1_2 == 2 || ldv_work_1_2 == 3) {
    ldv_work_1_2 = 4;
    iwl_bg_restart(ldv_work_struct_1_0);
    ldv_work_1_2 = 1;
  } else {

  }
  goto ldv_55832;
  case 3: ;
  if (ldv_work_1_3 == 2 || ldv_work_1_3 == 3) {
    ldv_work_1_3 = 4;
    iwl_bg_restart(ldv_work_struct_1_0);
    ldv_work_1_3 = 1;
  } else {

  }
  goto ldv_55832;
  default: 
  ldv_stop();
  }
  ldv_55832: ;
  return;
}
}
void activate_suitable_timer_16(struct timer_list *timer , unsigned long data ) 
{ 


  {
  if (ldv_timer_16_0 == 0 || ldv_timer_16_0 == 2) {
    ldv_timer_list_16_0 = timer;
    ldv_timer_list_16_0->data = data;
    ldv_timer_16_0 = 1;
    return;
  } else {

  }
  if (ldv_timer_16_1 == 0 || ldv_timer_16_1 == 2) {
    ldv_timer_list_16_1 = timer;
    ldv_timer_list_16_1->data = data;
    ldv_timer_16_1 = 1;
    return;
  } else {

  }
  if (ldv_timer_16_2 == 0 || ldv_timer_16_2 == 2) {
    ldv_timer_list_16_2 = timer;
    ldv_timer_list_16_2->data = data;
    ldv_timer_16_2 = 1;
    return;
  } else {

  }
  if (ldv_timer_16_3 == 0 || ldv_timer_16_3 == 2) {
    ldv_timer_list_16_3 = timer;
    ldv_timer_list_16_3->data = data;
    ldv_timer_16_3 = 1;
    return;
  } else {

  }
  return;
}
}
void call_and_disable_all_3(int state ) 
{ 


  {
  if (ldv_work_3_0 == state) {
    call_and_disable_work_3(ldv_work_struct_3_0);
  } else {

  }
  if (ldv_work_3_1 == state) {
    call_and_disable_work_3(ldv_work_struct_3_1);
  } else {

  }
  if (ldv_work_3_2 == state) {
    call_and_disable_work_3(ldv_work_struct_3_2);
  } else {

  }
  if (ldv_work_3_3 == state) {
    call_and_disable_work_3(ldv_work_struct_3_3);
  } else {

  }
  return;
}
}
void call_and_disable_work_4(struct work_struct *work ) 
{ 


  {
  if ((ldv_work_4_0 == 2 || ldv_work_4_0 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_4_0) {
    iwl_bg_tx_flush(work);
    ldv_work_4_0 = 1;
    return;
  } else {

  }
  if ((ldv_work_4_1 == 2 || ldv_work_4_1 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_4_1) {
    iwl_bg_tx_flush(work);
    ldv_work_4_1 = 1;
    return;
  } else {

  }
  if ((ldv_work_4_2 == 2 || ldv_work_4_2 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_4_2) {
    iwl_bg_tx_flush(work);
    ldv_work_4_2 = 1;
    return;
  } else {

  }
  if ((ldv_work_4_3 == 2 || ldv_work_4_3 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_4_3) {
    iwl_bg_tx_flush(work);
    ldv_work_4_3 = 1;
    return;
  } else {

  }
  return;
}
}
void work_init_3(void) 
{ 


  {
  ldv_work_3_0 = 0;
  ldv_work_3_1 = 0;
  ldv_work_3_2 = 0;
  ldv_work_3_3 = 0;
  return;
}
}
void call_and_disable_work_1(struct work_struct *work ) 
{ 


  {
  if ((ldv_work_1_0 == 2 || ldv_work_1_0 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_1_0) {
    iwl_bg_restart(work);
    ldv_work_1_0 = 1;
    return;
  } else {

  }
  if ((ldv_work_1_1 == 2 || ldv_work_1_1 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_1_1) {
    iwl_bg_restart(work);
    ldv_work_1_1 = 1;
    return;
  } else {

  }
  if ((ldv_work_1_2 == 2 || ldv_work_1_2 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_1_2) {
    iwl_bg_restart(work);
    ldv_work_1_2 = 1;
    return;
  } else {

  }
  if ((ldv_work_1_3 == 2 || ldv_work_1_3 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_1_3) {
    iwl_bg_restart(work);
    ldv_work_1_3 = 1;
    return;
  } else {

  }
  return;
}
}
void invoke_work_6(void) 
{ 
  int tmp ;

  {
  tmp = __VERIFIER_nondet_int();
  switch (tmp) {
  case 0: ;
  if (ldv_work_6_0 == 2 || ldv_work_6_0 == 3) {
    ldv_work_6_0 = 4;
    iwl_bg_bt_runtime_config(ldv_work_struct_6_0);
    ldv_work_6_0 = 1;
  } else {

  }
  goto ldv_55863;
  case 1: ;
  if (ldv_work_6_1 == 2 || ldv_work_6_1 == 3) {
    ldv_work_6_1 = 4;
    iwl_bg_bt_runtime_config(ldv_work_struct_6_0);
    ldv_work_6_1 = 1;
  } else {

  }
  goto ldv_55863;
  case 2: ;
  if (ldv_work_6_2 == 2 || ldv_work_6_2 == 3) {
    ldv_work_6_2 = 4;
    iwl_bg_bt_runtime_config(ldv_work_struct_6_0);
    ldv_work_6_2 = 1;
  } else {

  }
  goto ldv_55863;
  case 3: ;
  if (ldv_work_6_3 == 2 || ldv_work_6_3 == 3) {
    ldv_work_6_3 = 4;
    iwl_bg_bt_runtime_config(ldv_work_struct_6_0);
    ldv_work_6_3 = 1;
  } else {

  }
  goto ldv_55863;
  default: 
  ldv_stop();
  }
  ldv_55863: ;
  return;
}
}
void call_and_disable_all_2(int state ) 
{ 


  {
  if (ldv_work_2_0 == state) {
    call_and_disable_work_2(ldv_work_struct_2_0);
  } else {

  }
  if (ldv_work_2_1 == state) {
    call_and_disable_work_2(ldv_work_struct_2_1);
  } else {

  }
  if (ldv_work_2_2 == state) {
    call_and_disable_work_2(ldv_work_struct_2_2);
  } else {

  }
  if (ldv_work_2_3 == state) {
    call_and_disable_work_2(ldv_work_struct_2_3);
  } else {

  }
  return;
}
}
void activate_work_3(struct work_struct *work , int state ) 
{ 


  {
  if (ldv_work_3_0 == 0) {
    ldv_work_struct_3_0 = work;
    ldv_work_3_0 = state;
    return;
  } else {

  }
  if (ldv_work_3_1 == 0) {
    ldv_work_struct_3_1 = work;
    ldv_work_3_1 = state;
    return;
  } else {

  }
  if (ldv_work_3_2 == 0) {
    ldv_work_struct_3_2 = work;
    ldv_work_3_2 = state;
    return;
  } else {

  }
  if (ldv_work_3_3 == 0) {
    ldv_work_struct_3_3 = work;
    ldv_work_3_3 = state;
    return;
  } else {

  }
  return;
}
}
void choose_timer_15(void) 
{ 
  int tmp ;

  {
  tmp = __VERIFIER_nondet_int();
  switch (tmp) {
  case 0: ;
  if (ldv_timer_15_0 == 1) {
    ldv_timer_15_0 = 2;
    ldv_timer_15(ldv_timer_15_0, ldv_timer_list_15_0);
  } else {

  }
  goto ldv_55879;
  case 1: ;
  if (ldv_timer_15_1 == 1) {
    ldv_timer_15_1 = 2;
    ldv_timer_15(ldv_timer_15_1, ldv_timer_list_15_1);
  } else {

  }
  goto ldv_55879;
  case 2: ;
  if (ldv_timer_15_2 == 1) {
    ldv_timer_15_2 = 2;
    ldv_timer_15(ldv_timer_15_2, ldv_timer_list_15_2);
  } else {

  }
  goto ldv_55879;
  case 3: ;
  if (ldv_timer_15_3 == 1) {
    ldv_timer_15_3 = 2;
    ldv_timer_15(ldv_timer_15_3, ldv_timer_list_15_3);
  } else {

  }
  goto ldv_55879;
  default: 
  ldv_stop();
  }
  ldv_55879: ;
  return;
}
}
void activate_pending_timer_16(struct timer_list *timer , unsigned long data , int pending_flag ) 
{ 


  {
  if ((unsigned long )ldv_timer_list_16_0 == (unsigned long )timer) {
    if (ldv_timer_16_0 == 2 || pending_flag != 0) {
      ldv_timer_list_16_0 = timer;
      ldv_timer_list_16_0->data = data;
      ldv_timer_16_0 = 1;
    } else {

    }
    return;
  } else {

  }
  if ((unsigned long )ldv_timer_list_16_1 == (unsigned long )timer) {
    if (ldv_timer_16_1 == 2 || pending_flag != 0) {
      ldv_timer_list_16_1 = timer;
      ldv_timer_list_16_1->data = data;
      ldv_timer_16_1 = 1;
    } else {

    }
    return;
  } else {

  }
  if ((unsigned long )ldv_timer_list_16_2 == (unsigned long )timer) {
    if (ldv_timer_16_2 == 2 || pending_flag != 0) {
      ldv_timer_list_16_2 = timer;
      ldv_timer_list_16_2->data = data;
      ldv_timer_16_2 = 1;
    } else {

    }
    return;
  } else {

  }
  if ((unsigned long )ldv_timer_list_16_3 == (unsigned long )timer) {
    if (ldv_timer_16_3 == 2 || pending_flag != 0) {
      ldv_timer_list_16_3 = timer;
      ldv_timer_list_16_3->data = data;
      ldv_timer_16_3 = 1;
    } else {

    }
    return;
  } else {

  }
  activate_suitable_timer_16(timer, data);
  return;
}
}
void disable_work_5(struct work_struct *work ) 
{ 


  {
  if ((ldv_work_5_0 == 3 || ldv_work_5_0 == 2) && (unsigned long )ldv_work_struct_5_0 == (unsigned long )work) {
    ldv_work_5_0 = 1;
  } else {

  }
  if ((ldv_work_5_1 == 3 || ldv_work_5_1 == 2) && (unsigned long )ldv_work_struct_5_1 == (unsigned long )work) {
    ldv_work_5_1 = 1;
  } else {

  }
  if ((ldv_work_5_2 == 3 || ldv_work_5_2 == 2) && (unsigned long )ldv_work_struct_5_2 == (unsigned long )work) {
    ldv_work_5_2 = 1;
  } else {

  }
  if ((ldv_work_5_3 == 3 || ldv_work_5_3 == 2) && (unsigned long )ldv_work_struct_5_3 == (unsigned long )work) {
    ldv_work_5_3 = 1;
  } else {

  }
  return;
}
}
void timer_init_15(void) 
{ 


  {
  ldv_timer_15_0 = 0;
  ldv_timer_15_1 = 0;
  ldv_timer_15_2 = 0;
  ldv_timer_15_3 = 0;
  return;
}
}
void disable_work_1(struct work_struct *work ) 
{ 


  {
  if ((ldv_work_1_0 == 3 || ldv_work_1_0 == 2) && (unsigned long )ldv_work_struct_1_0 == (unsigned long )work) {
    ldv_work_1_0 = 1;
  } else {

  }
  if ((ldv_work_1_1 == 3 || ldv_work_1_1 == 2) && (unsigned long )ldv_work_struct_1_1 == (unsigned long )work) {
    ldv_work_1_1 = 1;
  } else {

  }
  if ((ldv_work_1_2 == 3 || ldv_work_1_2 == 2) && (unsigned long )ldv_work_struct_1_2 == (unsigned long )work) {
    ldv_work_1_2 = 1;
  } else {

  }
  if ((ldv_work_1_3 == 3 || ldv_work_1_3 == 2) && (unsigned long )ldv_work_struct_1_3 == (unsigned long )work) {
    ldv_work_1_3 = 1;
  } else {

  }
  return;
}
}
void call_and_disable_all_6(int state ) 
{ 


  {
  if (ldv_work_6_0 == state) {
    call_and_disable_work_6(ldv_work_struct_6_0);
  } else {

  }
  if (ldv_work_6_1 == state) {
    call_and_disable_work_6(ldv_work_struct_6_1);
  } else {

  }
  if (ldv_work_6_2 == state) {
    call_and_disable_work_6(ldv_work_struct_6_2);
  } else {

  }
  if (ldv_work_6_3 == state) {
    call_and_disable_work_6(ldv_work_struct_6_3);
  } else {

  }
  return;
}
}
int reg_timer_16(struct timer_list *timer , void (*function)(unsigned long  ) , unsigned long data ) 
{ 


  {
  if ((unsigned long )function == (unsigned long )(& iwl_bg_ucode_trace)) {
    activate_suitable_timer_16(timer, data);
  } else {

  }
  return (0);
}
}
void call_and_disable_work_5(struct work_struct *work ) 
{ 


  {
  if ((ldv_work_5_0 == 2 || ldv_work_5_0 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_5_0) {
    iwl_bg_bt_full_concurrency(work);
    ldv_work_5_0 = 1;
    return;
  } else {

  }
  if ((ldv_work_5_1 == 2 || ldv_work_5_1 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_5_1) {
    iwl_bg_bt_full_concurrency(work);
    ldv_work_5_1 = 1;
    return;
  } else {

  }
  if ((ldv_work_5_2 == 2 || ldv_work_5_2 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_5_2) {
    iwl_bg_bt_full_concurrency(work);
    ldv_work_5_2 = 1;
    return;
  } else {

  }
  if ((ldv_work_5_3 == 2 || ldv_work_5_3 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_5_3) {
    iwl_bg_bt_full_concurrency(work);
    ldv_work_5_3 = 1;
    return;
  } else {

  }
  return;
}
}
void ldv_timer_15(int state , struct timer_list *timer ) 
{ 


  {
  LDV_IN_INTERRUPT = 2;
  iwl_bg_statistics_periodic(timer->data);
  LDV_IN_INTERRUPT = 1;
  return;
}
}
void invoke_work_2(void) 
{ 
  int tmp ;

  {
  tmp = __VERIFIER_nondet_int();
  switch (tmp) {
  case 0: ;
  if (ldv_work_2_0 == 2 || ldv_work_2_0 == 3) {
    ldv_work_2_0 = 4;
    iwl_bg_beacon_update(ldv_work_struct_2_0);
    ldv_work_2_0 = 1;
  } else {

  }
  goto ldv_55922;
  case 1: ;
  if (ldv_work_2_1 == 2 || ldv_work_2_1 == 3) {
    ldv_work_2_1 = 4;
    iwl_bg_beacon_update(ldv_work_struct_2_0);
    ldv_work_2_1 = 1;
  } else {

  }
  goto ldv_55922;
  case 2: ;
  if (ldv_work_2_2 == 2 || ldv_work_2_2 == 3) {
    ldv_work_2_2 = 4;
    iwl_bg_beacon_update(ldv_work_struct_2_0);
    ldv_work_2_2 = 1;
  } else {

  }
  goto ldv_55922;
  case 3: ;
  if (ldv_work_2_3 == 2 || ldv_work_2_3 == 3) {
    ldv_work_2_3 = 4;
    iwl_bg_beacon_update(ldv_work_struct_2_0);
    ldv_work_2_3 = 1;
  } else {

  }
  goto ldv_55922;
  default: 
  ldv_stop();
  }
  ldv_55922: ;
  return;
}
}
void choose_timer_16(void) 
{ 
  int tmp ;

  {
  tmp = __VERIFIER_nondet_int();
  switch (tmp) {
  case 0: ;
  if (ldv_timer_16_0 == 1) {
    ldv_timer_16_0 = 2;
    ldv_timer_16(ldv_timer_16_0, ldv_timer_list_16_0);
  } else {

  }
  goto ldv_55931;
  case 1: ;
  if (ldv_timer_16_1 == 1) {
    ldv_timer_16_1 = 2;
    ldv_timer_16(ldv_timer_16_1, ldv_timer_list_16_1);
  } else {

  }
  goto ldv_55931;
  case 2: ;
  if (ldv_timer_16_2 == 1) {
    ldv_timer_16_2 = 2;
    ldv_timer_16(ldv_timer_16_2, ldv_timer_list_16_2);
  } else {

  }
  goto ldv_55931;
  case 3: ;
  if (ldv_timer_16_3 == 1) {
    ldv_timer_16_3 = 2;
    ldv_timer_16(ldv_timer_16_3, ldv_timer_list_16_3);
  } else {

  }
  goto ldv_55931;
  default: 
  ldv_stop();
  }
  ldv_55931: ;
  return;
}
}
void activate_work_4(struct work_struct *work , int state ) 
{ 


  {
  if (ldv_work_4_0 == 0) {
    ldv_work_struct_4_0 = work;
    ldv_work_4_0 = state;
    return;
  } else {

  }
  if (ldv_work_4_1 == 0) {
    ldv_work_struct_4_1 = work;
    ldv_work_4_1 = state;
    return;
  } else {

  }
  if (ldv_work_4_2 == 0) {
    ldv_work_struct_4_2 = work;
    ldv_work_4_2 = state;
    return;
  } else {

  }
  if (ldv_work_4_3 == 0) {
    ldv_work_struct_4_3 = work;
    ldv_work_4_3 = state;
    return;
  } else {

  }
  return;
}
}
void call_and_disable_all_5(int state ) 
{ 


  {
  if (ldv_work_5_0 == state) {
    call_and_disable_work_5(ldv_work_struct_5_0);
  } else {

  }
  if (ldv_work_5_1 == state) {
    call_and_disable_work_5(ldv_work_struct_5_1);
  } else {

  }
  if (ldv_work_5_2 == state) {
    call_and_disable_work_5(ldv_work_struct_5_2);
  } else {

  }
  if (ldv_work_5_3 == state) {
    call_and_disable_work_5(ldv_work_struct_5_3);
  } else {

  }
  return;
}
}
void ldv_timer_16(int state , struct timer_list *timer ) 
{ 


  {
  LDV_IN_INTERRUPT = 2;
  iwl_bg_ucode_trace(timer->data);
  LDV_IN_INTERRUPT = 1;
  return;
}
}
void work_init_2(void) 
{ 


  {
  ldv_work_2_0 = 0;
  ldv_work_2_1 = 0;
  ldv_work_2_2 = 0;
  ldv_work_2_3 = 0;
  return;
}
}
void call_and_disable_all_1(int state ) 
{ 


  {
  if (ldv_work_1_0 == state) {
    call_and_disable_work_1(ldv_work_struct_1_0);
  } else {

  }
  if (ldv_work_1_1 == state) {
    call_and_disable_work_1(ldv_work_struct_1_1);
  } else {

  }
  if (ldv_work_1_2 == state) {
    call_and_disable_work_1(ldv_work_struct_1_2);
  } else {

  }
  if (ldv_work_1_3 == state) {
    call_and_disable_work_1(ldv_work_struct_1_3);
  } else {

  }
  return;
}
}
void disable_work_6(struct work_struct *work ) 
{ 


  {
  if ((ldv_work_6_0 == 3 || ldv_work_6_0 == 2) && (unsigned long )ldv_work_struct_6_0 == (unsigned long )work) {
    ldv_work_6_0 = 1;
  } else {

  }
  if ((ldv_work_6_1 == 3 || ldv_work_6_1 == 2) && (unsigned long )ldv_work_struct_6_1 == (unsigned long )work) {
    ldv_work_6_1 = 1;
  } else {

  }
  if ((ldv_work_6_2 == 3 || ldv_work_6_2 == 2) && (unsigned long )ldv_work_struct_6_2 == (unsigned long )work) {
    ldv_work_6_2 = 1;
  } else {

  }
  if ((ldv_work_6_3 == 3 || ldv_work_6_3 == 2) && (unsigned long )ldv_work_struct_6_3 == (unsigned long )work) {
    ldv_work_6_3 = 1;
  } else {

  }
  return;
}
}
void work_init_6(void) 
{ 


  {
  ldv_work_6_0 = 0;
  ldv_work_6_1 = 0;
  ldv_work_6_2 = 0;
  ldv_work_6_3 = 0;
  return;
}
}
void disable_suitable_timer_15(struct timer_list *timer ) 
{ 


  {
  if (ldv_timer_15_0 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_15_0) {
    ldv_timer_15_0 = 0;
    return;
  } else {

  }
  if (ldv_timer_15_1 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_15_1) {
    ldv_timer_15_1 = 0;
    return;
  } else {

  }
  if (ldv_timer_15_2 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_15_2) {
    ldv_timer_15_2 = 0;
    return;
  } else {

  }
  if (ldv_timer_15_3 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_15_3) {
    ldv_timer_15_3 = 0;
    return;
  } else {

  }
  return;
}
}
void disable_work_2(struct work_struct *work ) 
{ 


  {
  if ((ldv_work_2_0 == 3 || ldv_work_2_0 == 2) && (unsigned long )ldv_work_struct_2_0 == (unsigned long )work) {
    ldv_work_2_0 = 1;
  } else {

  }
  if ((ldv_work_2_1 == 3 || ldv_work_2_1 == 2) && (unsigned long )ldv_work_struct_2_1 == (unsigned long )work) {
    ldv_work_2_1 = 1;
  } else {

  }
  if ((ldv_work_2_2 == 3 || ldv_work_2_2 == 2) && (unsigned long )ldv_work_struct_2_2 == (unsigned long )work) {
    ldv_work_2_2 = 1;
  } else {

  }
  if ((ldv_work_2_3 == 3 || ldv_work_2_3 == 2) && (unsigned long )ldv_work_struct_2_3 == (unsigned long )work) {
    ldv_work_2_3 = 1;
  } else {

  }
  return;
}
}
void invoke_work_3(void) 
{ 
  int tmp ;

  {
  tmp = __VERIFIER_nondet_int();
  switch (tmp) {
  case 0: ;
  if (ldv_work_3_0 == 2 || ldv_work_3_0 == 3) {
    ldv_work_3_0 = 4;
    iwl_bg_run_time_calib_work(ldv_work_struct_3_0);
    ldv_work_3_0 = 1;
  } else {

  }
  goto ldv_55971;
  case 1: ;
  if (ldv_work_3_1 == 2 || ldv_work_3_1 == 3) {
    ldv_work_3_1 = 4;
    iwl_bg_run_time_calib_work(ldv_work_struct_3_0);
    ldv_work_3_1 = 1;
  } else {

  }
  goto ldv_55971;
  case 2: ;
  if (ldv_work_3_2 == 2 || ldv_work_3_2 == 3) {
    ldv_work_3_2 = 4;
    iwl_bg_run_time_calib_work(ldv_work_struct_3_0);
    ldv_work_3_2 = 1;
  } else {

  }
  goto ldv_55971;
  case 3: ;
  if (ldv_work_3_3 == 2 || ldv_work_3_3 == 3) {
    ldv_work_3_3 = 4;
    iwl_bg_run_time_calib_work(ldv_work_struct_3_0);
    ldv_work_3_3 = 1;
  } else {

  }
  goto ldv_55971;
  default: 
  ldv_stop();
  }
  ldv_55971: ;
  return;
}
}
void call_and_disable_work_6(struct work_struct *work ) 
{ 


  {
  if ((ldv_work_6_0 == 2 || ldv_work_6_0 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_6_0) {
    iwl_bg_bt_runtime_config(work);
    ldv_work_6_0 = 1;
    return;
  } else {

  }
  if ((ldv_work_6_1 == 2 || ldv_work_6_1 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_6_1) {
    iwl_bg_bt_runtime_config(work);
    ldv_work_6_1 = 1;
    return;
  } else {

  }
  if ((ldv_work_6_2 == 2 || ldv_work_6_2 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_6_2) {
    iwl_bg_bt_runtime_config(work);
    ldv_work_6_2 = 1;
    return;
  } else {

  }
  if ((ldv_work_6_3 == 2 || ldv_work_6_3 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_6_3) {
    iwl_bg_bt_runtime_config(work);
    ldv_work_6_3 = 1;
    return;
  } else {

  }
  return;
}
}
void call_and_disable_work_2(struct work_struct *work ) 
{ 


  {
  if ((ldv_work_2_0 == 2 || ldv_work_2_0 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_2_0) {
    iwl_bg_beacon_update(work);
    ldv_work_2_0 = 1;
    return;
  } else {

  }
  if ((ldv_work_2_1 == 2 || ldv_work_2_1 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_2_1) {
    iwl_bg_beacon_update(work);
    ldv_work_2_1 = 1;
    return;
  } else {

  }
  if ((ldv_work_2_2 == 2 || ldv_work_2_2 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_2_2) {
    iwl_bg_beacon_update(work);
    ldv_work_2_2 = 1;
    return;
  } else {

  }
  if ((ldv_work_2_3 == 2 || ldv_work_2_3 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_2_3) {
    iwl_bg_beacon_update(work);
    ldv_work_2_3 = 1;
    return;
  } else {

  }
  return;
}
}
void ldv_main_exported_67(void) ;
void ldv_main_exported_66(void) ;
void ldv_main_exported_68(void) ;
void ldv_main_exported_65(void) ;
void ldv_main_exported_33(void) ;
void ldv_main_exported_32(void) ;
void ldv_main_exported_21(void) ;
void ldv_main_exported_26(void) ;
void ldv_main_exported_30(void) ;
void ldv_main_exported_44(void) ;
void ldv_main_exported_25(void) ;
void ldv_main_exported_27(void) ;
void ldv_main_exported_28(void) ;
void ldv_main_exported_40(void) ;
void ldv_main_exported_20(void) ;
void ldv_main_exported_49(void) ;
void ldv_main_exported_24(void) ;
void ldv_main_exported_31(void) ;
void ldv_main_exported_35(void) ;
void ldv_main_exported_53(void) ;
void ldv_main_exported_48(void) ;
void ldv_main_exported_22(void) ;
void ldv_main_exported_42(void) ;
void ldv_main_exported_46(void) ;
void ldv_main_exported_23(void) ;
void ldv_main_exported_29(void) ;
void ldv_main_exported_50(void) ;
void ldv_main_exported_39(void) ;
void ldv_main_exported_36(void) ;
void ldv_main_exported_51(void) ;
void ldv_main_exported_41(void) ;
void ldv_main_exported_47(void) ;
void ldv_main_exported_52(void) ;
void ldv_main_exported_38(void) ;
void ldv_main_exported_34(void) ;
void ldv_main_exported_37(void) ;
void ldv_main_exported_45(void) ;
void ldv_main_exported_19(void) ;
void ldv_main_exported_43(void) ;
void ldv_main_exported_63(void) ;
void ldv_main_exported_57(void) ;
void ldv_main_exported_61(void) ;
void ldv_main_exported_58(void) ;
void ldv_main_exported_59(void) ;
void ldv_main_exported_60(void) ;
void ldv_main_exported_56(void) ;
void ldv_main_exported_62(void) ;
void ldv_main_exported_54(void) ;
void ldv_main_exported_55(void) ;
void ldv_main_exported_64(void) ;
int main(void) 
{ 
  bool ldvarg230 ;
  int ldvarg225 ;
    klee_make_symbolic(&ldvarg225, sizeof(int), "ldvarg225");
  struct iwl_fw *ldvarg234 ;
  void *tmp ;
  int ldvarg229 ;
    klee_make_symbolic(&ldvarg229, sizeof(int), "ldvarg229");
  struct iwl_rx_cmd_buffer *ldvarg228 ;
  void *tmp___0 ;
  struct iwl_device_cmd *ldvarg227 ;
  void *tmp___1 ;
  struct sk_buff *ldvarg231 ;
  void *tmp___2 ;
  int ldvarg226 ;
    klee_make_symbolic(&ldvarg226, sizeof(int), "ldvarg226");
  struct iwl_trans *ldvarg233 ;
  void *tmp___3 ;
  int (*ldvarg222)(struct napi_struct * , int  ) ;
  struct napi_struct *ldvarg224 ;
  void *tmp___4 ;
  struct net_device *ldvarg223 ;
  void *tmp___5 ;
  struct iwl_cfg *ldvarg235 ;
  void *tmp___6 ;
  struct dentry *ldvarg232 ;
  void *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
    klee_make_symbolic(&tmp___9, sizeof(int), "tmp___9");
  int tmp___10 ;
    klee_make_symbolic(&tmp___10, sizeof(int), "tmp___10");

  {
  tmp = ldv_init_zalloc(1744UL);
  ldvarg234 = (struct iwl_fw *)tmp;
  tmp___0 = ldv_init_zalloc(24UL);
  ldvarg228 = (struct iwl_rx_cmd_buffer *)tmp___0;
  tmp___1 = ldv_init_zalloc(324UL);
  ldvarg227 = (struct iwl_device_cmd *)tmp___1;
  tmp___2 = ldv_init_zalloc(232UL);
  ldvarg231 = (struct sk_buff *)tmp___2;
  tmp___3 = ldv_init_zalloc(536UL);
  ldvarg233 = (struct iwl_trans *)tmp___3;
  tmp___4 = ldv_init_zalloc(280UL);
  ldvarg224 = (struct napi_struct *)tmp___4;
  tmp___5 = ldv_init_zalloc(3008UL);
  ldvarg223 = (struct net_device *)tmp___5;
  tmp___6 = ldv_init_zalloc(184UL);
  ldvarg235 = (struct iwl_cfg *)tmp___6;
  tmp___7 = ldv_init_zalloc(320UL);
  ldvarg232 = (struct dentry *)tmp___7;
  ldv_initialize();
  ldv_memset((void *)(& ldvarg230), 0, 1UL);
  ldv_memset((void *)(& ldvarg225), 0, 4UL);
  ldv_memset((void *)(& ldvarg229), 0, 4UL);
  ldv_memset((void *)(& ldvarg226), 0, 4UL);
  ldv_memset((void *)(& ldvarg222), 0, 8UL);
  ldv_state_variable_33 = 0;
  ldv_state_variable_32 = 0;
  ldv_state_variable_63 = 0;
  ldv_state_variable_21 = 0;
  work_init_7();
  ldv_state_variable_7 = 1;
  ldv_state_variable_26 = 0;
  timer_init_18();
  ldv_state_variable_18 = 1;
  timer_init_16();
  ldv_state_variable_16 = 1;
  ldv_state_variable_44 = 0;
  ldv_state_variable_55 = 0;
  ldv_state_variable_27 = 0;
  ldv_state_variable_57 = 0;
  ldv_state_variable_61 = 0;
  ldv_state_variable_20 = 0;
  work_init_10();
  ldv_state_variable_10 = 1;
  ldv_state_variable_31 = 0;
  ldv_state_variable_35 = 0;
  work_init_11();
  ldv_state_variable_11 = 1;
  ldv_state_variable_48 = 0;
  ldv_state_variable_65 = 0;
  ldv_state_variable_29 = 0;
  ldv_state_variable_50 = 0;
  ldv_state_variable_39 = 0;
  ldv_state_variable_64 = 0;
  ldv_state_variable_58 = 0;
  ldv_state_variable_41 = 0;
  work_init_12();
  ldv_state_variable_12 = 1;
  timer_init_15();
  ldv_state_variable_15 = 1;
  ldv_state_variable_52 = 0;
  ldv_state_variable_60 = 0;
  ldv_state_variable_56 = 0;
  ldv_state_variable_66 = 0;
  ldv_state_variable_45 = 0;
  ldv_state_variable_19 = 0;
  ldv_state_variable_62 = 0;
  ldv_state_variable_54 = 0;
  ldv_state_variable_67 = 0;
  ldv_state_variable_68 = 0;
  work_init_2();
  ldv_state_variable_2 = 1;
  timer_init_17();
  ldv_state_variable_17 = 1;
  work_init_1();
  ldv_state_variable_1 = 1;
  ldv_state_variable_30 = 0;
  ldv_state_variable_25 = 0;
  ldv_state_variable_28 = 0;
  ldv_state_variable_40 = 0;
  work_init_14();
  ldv_state_variable_14 = 1;
  ldv_state_variable_69 = 0;
  ldv_state_variable_59 = 0;
  ldv_state_variable_49 = 0;
  ldv_state_variable_24 = 0;
  ldv_state_variable_53 = 0;
  ldv_state_variable_22 = 0;
  ldv_state_variable_42 = 0;
  ref_cnt = 0;
  ldv_state_variable_0 = 1;
  ldv_state_variable_46 = 0;
  ldv_state_variable_23 = 0;
  work_init_13();
  ldv_state_variable_13 = 1;
  work_init_6();
  ldv_state_variable_6 = 1;
  work_init_3();
  ldv_state_variable_3 = 1;
  ldv_state_variable_36 = 0;
  work_init_9();
  ldv_state_variable_9 = 1;
  ldv_state_variable_51 = 0;
  ldv_state_variable_47 = 0;
  work_init_8();
  ldv_state_variable_8 = 1;
  ldv_state_variable_38 = 0;
  work_init_4();
  ldv_state_variable_4 = 1;
  ldv_state_variable_34 = 0;
  ldv_state_variable_37 = 0;
  ldv_state_variable_43 = 0;
  work_init_5();
  ldv_state_variable_5 = 1;
  ldv_56204: 
  tmp___8 = __VERIFIER_nondet_int();
  switch (tmp___8) {
  case 0: ;
  if (ldv_state_variable_33 != 0) {
    ldv_main_exported_33();
  } else {

  }
  goto ldv_56114;
  case 1: ;
  if (ldv_state_variable_32 != 0) {
    ldv_main_exported_32();
  } else {

  }
  goto ldv_56114;
  case 2: ;
  if (ldv_state_variable_63 != 0) {
    ldv_main_exported_63();
  } else {

  }
  goto ldv_56114;
  case 3: ;
  if (ldv_state_variable_21 != 0) {
    ldv_main_exported_21();
  } else {

  }
  goto ldv_56114;
  case 4: ;
  goto ldv_56114;
  case 5: ;
  if (ldv_state_variable_26 != 0) {
    ldv_main_exported_26();
  } else {

  }
  goto ldv_56114;
  case 6: ;
  goto ldv_56114;
  case 7: ;
  if (ldv_state_variable_16 != 0) {
    choose_timer_16();
  } else {

  }
  goto ldv_56114;
  case 8: ;
  if (ldv_state_variable_44 != 0) {
    ldv_main_exported_44();
  } else {

  }
  goto ldv_56114;
  case 9: ;
  if (ldv_state_variable_55 != 0) {
    ldv_main_exported_55();
  } else {

  }
  goto ldv_56114;
  case 10: ;
  if (ldv_state_variable_27 != 0) {
    ldv_main_exported_27();
  } else {

  }
  goto ldv_56114;
  case 11: ;
  if (ldv_state_variable_57 != 0) {
    ldv_main_exported_57();
  } else {

  }
  goto ldv_56114;
  case 12: ;
  if (ldv_state_variable_61 != 0) {
    ldv_main_exported_61();
  } else {

  }
  goto ldv_56114;
  case 13: ;
  if (ldv_state_variable_20 != 0) {
    ldv_main_exported_20();
  } else {

  }
  goto ldv_56114;
  case 14: ;
  goto ldv_56114;
  case 15: ;
  if (ldv_state_variable_31 != 0) {
    ldv_main_exported_31();
  } else {

  }
  goto ldv_56114;
  case 16: ;
  if (ldv_state_variable_35 != 0) {
    ldv_main_exported_35();
  } else {

  }
  goto ldv_56114;
  case 17: ;
  goto ldv_56114;
  case 18: ;
  if (ldv_state_variable_48 != 0) {
    ldv_main_exported_48();
  } else {

  }
  goto ldv_56114;
  case 19: ;
  if (ldv_state_variable_65 != 0) {
    ldv_main_exported_65();
  } else {

  }
  goto ldv_56114;
  case 20: ;
  if (ldv_state_variable_29 != 0) {
    ldv_main_exported_29();
  } else {

  }
  goto ldv_56114;
  case 21: ;
  if (ldv_state_variable_50 != 0) {
    ldv_main_exported_50();
  } else {

  }
  goto ldv_56114;
  case 22: ;
  if (ldv_state_variable_39 != 0) {
    ldv_main_exported_39();
  } else {

  }
  goto ldv_56114;
  case 23: ;
  if (ldv_state_variable_64 != 0) {
    ldv_main_exported_64();
  } else {

  }
  goto ldv_56114;
  case 24: ;
  if (ldv_state_variable_58 != 0) {
    ldv_main_exported_58();
  } else {

  }
  goto ldv_56114;
  case 25: ;
  if (ldv_state_variable_41 != 0) {
    ldv_main_exported_41();
  } else {

  }
  goto ldv_56114;
  case 26: ;
  goto ldv_56114;
  case 27: ;
  if (ldv_state_variable_15 != 0) {
    choose_timer_15();
  } else {

  }
  goto ldv_56114;
  case 28: ;
  if (ldv_state_variable_52 != 0) {
    ldv_main_exported_52();
  } else {

  }
  goto ldv_56114;
  case 29: ;
  if (ldv_state_variable_60 != 0) {
    ldv_main_exported_60();
  } else {

  }
  goto ldv_56114;
  case 30: ;
  if (ldv_state_variable_56 != 0) {
    ldv_main_exported_56();
  } else {

  }
  goto ldv_56114;
  case 31: ;
  if (ldv_state_variable_66 != 0) {
    ldv_main_exported_66();
  } else {

  }
  goto ldv_56114;
  case 32: ;
  if (ldv_state_variable_45 != 0) {
    ldv_main_exported_45();
  } else {

  }
  goto ldv_56114;
  case 33: ;
  if (ldv_state_variable_19 != 0) {
    ldv_main_exported_19();
  } else {

  }
  goto ldv_56114;
  case 34: ;
  if (ldv_state_variable_62 != 0) {
    ldv_main_exported_62();
  } else {

  }
  goto ldv_56114;
  case 35: ;
  if (ldv_state_variable_54 != 0) {
    ldv_main_exported_54();
  } else {

  }
  goto ldv_56114;
  case 36: ;
  if (ldv_state_variable_67 != 0) {
    ldv_main_exported_67();
  } else {

  }
  goto ldv_56114;
  case 37: ;
  if (ldv_state_variable_68 != 0) {
    ldv_main_exported_68();
  } else {

  }
  goto ldv_56114;
  case 38: ;
  if (ldv_state_variable_2 != 0) {
    invoke_work_2();
  } else {

  }
  goto ldv_56114;
  case 39: ;
  goto ldv_56114;
  case 40: ;
  if (ldv_state_variable_1 != 0) {
    invoke_work_1();
  } else {

  }
  goto ldv_56114;
  case 41: ;
  if (ldv_state_variable_30 != 0) {
    ldv_main_exported_30();
  } else {

  }
  goto ldv_56114;
  case 42: ;
  if (ldv_state_variable_25 != 0) {
    ldv_main_exported_25();
  } else {

  }
  goto ldv_56114;
  case 43: ;
  if (ldv_state_variable_28 != 0) {
    ldv_main_exported_28();
  } else {

  }
  goto ldv_56114;
  case 44: ;
  if (ldv_state_variable_40 != 0) {
    ldv_main_exported_40();
  } else {

  }
  goto ldv_56114;
  case 45: ;
  goto ldv_56114;
  case 46: ;
  if (ldv_state_variable_69 != 0) {
    tmp___9 = __VERIFIER_nondet_int();
    switch (tmp___9) {
    case 0: ;
    if (ldv_state_variable_69 == 1) {
      iwl_nic_error(iwl_dvm_ops_group0);
      ldv_state_variable_69 = 1;
    } else {

    }
    if (ldv_state_variable_69 == 2) {
      iwl_nic_error(iwl_dvm_ops_group0);
      ldv_state_variable_69 = 2;
    } else {

    }
    goto ldv_56162;
    case 1: ;
    if (ldv_state_variable_69 == 1) {
      iwl_op_mode_dvm_start(ldvarg233, (struct iwl_cfg  const  *)ldvarg235, (struct iwl_fw  const  *)ldvarg234,
                            ldvarg232);
      ldv_state_variable_69 = 2;
      ref_cnt = ref_cnt + 1;
    } else {

    }
    goto ldv_56162;
    case 2: ;
    if (ldv_state_variable_69 == 1) {
      iwl_cmd_queue_full(iwl_dvm_ops_group0);
      ldv_state_variable_69 = 1;
    } else {

    }
    if (ldv_state_variable_69 == 2) {
      iwl_cmd_queue_full(iwl_dvm_ops_group0);
      ldv_state_variable_69 = 2;
    } else {

    }
    goto ldv_56162;
    case 3: ;
    if (ldv_state_variable_69 == 1) {
      iwl_free_skb(iwl_dvm_ops_group0, ldvarg231);
      ldv_state_variable_69 = 1;
    } else {

    }
    if (ldv_state_variable_69 == 2) {
      iwl_free_skb(iwl_dvm_ops_group0, ldvarg231);
      ldv_state_variable_69 = 2;
    } else {

    }
    goto ldv_56162;
    case 4: ;
    if (ldv_state_variable_69 == 1) {
      iwl_wimax_active(iwl_dvm_ops_group0);
      ldv_state_variable_69 = 1;
    } else {

    }
    if (ldv_state_variable_69 == 2) {
      iwl_wimax_active(iwl_dvm_ops_group0);
      ldv_state_variable_69 = 2;
    } else {

    }
    goto ldv_56162;
    case 5: ;
    if (ldv_state_variable_69 == 1) {
      iwl_set_hw_rfkill_state(iwl_dvm_ops_group0, (int )ldvarg230);
      ldv_state_variable_69 = 1;
    } else {

    }
    if (ldv_state_variable_69 == 2) {
      iwl_set_hw_rfkill_state(iwl_dvm_ops_group0, (int )ldvarg230);
      ldv_state_variable_69 = 2;
    } else {

    }
    goto ldv_56162;
    case 6: ;
    if (ldv_state_variable_69 == 1) {
      iwl_stop_sw_queue(iwl_dvm_ops_group0, ldvarg229);
      ldv_state_variable_69 = 1;
    } else {

    }
    if (ldv_state_variable_69 == 2) {
      iwl_stop_sw_queue(iwl_dvm_ops_group0, ldvarg229);
      ldv_state_variable_69 = 2;
    } else {

    }
    goto ldv_56162;
    case 7: ;
    if (ldv_state_variable_69 == 1) {
      iwl_rx_dispatch(iwl_dvm_ops_group0, ldvarg228, ldvarg227);
      ldv_state_variable_69 = 1;
    } else {

    }
    if (ldv_state_variable_69 == 2) {
      iwl_rx_dispatch(iwl_dvm_ops_group0, ldvarg228, ldvarg227);
      ldv_state_variable_69 = 2;
    } else {

    }
    goto ldv_56162;
    case 8: ;
    if (ldv_state_variable_69 == 2) {
      iwl_op_mode_dvm_stop(iwl_dvm_ops_group0);
      ldv_state_variable_69 = 1;
      ref_cnt = ref_cnt - 1;
    } else {

    }
    goto ldv_56162;
    case 9: ;
    if (ldv_state_variable_69 == 1) {
      iwl_nic_config(iwl_dvm_ops_group0);
      ldv_state_variable_69 = 1;
    } else {

    }
    if (ldv_state_variable_69 == 2) {
      iwl_nic_config(iwl_dvm_ops_group0);
      ldv_state_variable_69 = 2;
    } else {

    }
    goto ldv_56162;
    case 10: ;
    if (ldv_state_variable_69 == 1) {
      iwl_wake_sw_queue(iwl_dvm_ops_group0, ldvarg226);
      ldv_state_variable_69 = 1;
    } else {

    }
    if (ldv_state_variable_69 == 2) {
      iwl_wake_sw_queue(iwl_dvm_ops_group0, ldvarg226);
      ldv_state_variable_69 = 2;
    } else {

    }
    goto ldv_56162;
    case 11: ;
    if (ldv_state_variable_69 == 1) {
      iwl_napi_add(iwl_dvm_ops_group0, ldvarg224, ldvarg223, ldvarg222, ldvarg225);
      ldv_state_variable_69 = 1;
    } else {

    }
    if (ldv_state_variable_69 == 2) {
      iwl_napi_add(iwl_dvm_ops_group0, ldvarg224, ldvarg223, ldvarg222, ldvarg225);
      ldv_state_variable_69 = 2;
    } else {

    }
    goto ldv_56162;
    default: 
    ldv_stop();
    }
    ldv_56162: ;
  } else {

  }
  goto ldv_56114;
  case 47: ;
  if (ldv_state_variable_59 != 0) {
    ldv_main_exported_59();
  } else {

  }
  goto ldv_56114;
  case 48: ;
  if (ldv_state_variable_49 != 0) {
    ldv_main_exported_49();
  } else {

  }
  goto ldv_56114;
  case 49: ;
  if (ldv_state_variable_24 != 0) {
    ldv_main_exported_24();
  } else {

  }
  goto ldv_56114;
  case 50: ;
  if (ldv_state_variable_53 != 0) {
    ldv_main_exported_53();
  } else {

  }
  goto ldv_56114;
  case 51: ;
  if (ldv_state_variable_22 != 0) {
    ldv_main_exported_22();
  } else {

  }
  goto ldv_56114;
  case 52: ;
  if (ldv_state_variable_42 != 0) {
    ldv_main_exported_42();
  } else {

  }
  goto ldv_56114;
  case 53: ;
  if (ldv_state_variable_0 != 0) {
    tmp___10 = __VERIFIER_nondet_int();
    switch (tmp___10) {
    case 0: ;
    if (ldv_state_variable_0 == 2 && ref_cnt == 0) {
      iwl_exit();
      ldv_state_variable_0 = 3;
      goto ldv_final;
    } else {

    }
    goto ldv_56184;
    case 1: ;
    if (ldv_state_variable_0 == 1) {
      ldv_retval_30 = iwl_init();
      if (ldv_retval_30 != 0) {
        ldv_state_variable_0 = 3;
        goto ldv_final;
      } else {

      }
      if (ldv_retval_30 == 0) {
        ldv_state_variable_0 = 2;
        ldv_state_variable_54 = 1;
        ldv_initialize_iwl_dvm_cfg_54();
        ldv_state_variable_62 = 1;
        ldv_initialize_iwl_dvm_cfg_62();
        ldv_state_variable_43 = 1;
        ldv_file_operations_43();
        ldv_state_variable_19 = 1;
        ldv_file_operations_19();
        ldv_state_variable_45 = 1;
        ldv_file_operations_45();
        ldv_state_variable_37 = 1;
        ldv_file_operations_37();
        ldv_state_variable_66 = 1;
        ldv_file_operations_66();
        ldv_state_variable_56 = 1;
        ldv_initialize_iwl_dvm_cfg_56();
        ldv_state_variable_34 = 1;
        ldv_file_operations_34();
        ldv_state_variable_60 = 1;
        ldv_initialize_iwl_dvm_cfg_60();
        ldv_state_variable_38 = 1;
        ldv_file_operations_38();
        ldv_state_variable_52 = 1;
        ldv_file_operations_52();
        ldv_state_variable_47 = 1;
        ldv_file_operations_47();
        ldv_state_variable_41 = 1;
        ldv_file_operations_41();
        ldv_state_variable_58 = 1;
        ldv_initialize_iwl_dvm_cfg_58();
        ldv_state_variable_51 = 1;
        ldv_file_operations_51();
        ldv_state_variable_36 = 1;
        ldv_file_operations_36();
        ldv_state_variable_39 = 1;
        ldv_file_operations_39();
        ldv_state_variable_50 = 1;
        ldv_file_operations_50();
        ldv_state_variable_29 = 1;
        ldv_file_operations_29();
        ldv_state_variable_65 = 1;
        ldv_initialize_rate_control_ops_65();
        ldv_state_variable_23 = 1;
        ldv_file_operations_23();
        ldv_state_variable_46 = 1;
        ldv_file_operations_46();
        ldv_state_variable_42 = 1;
        ldv_file_operations_42();
        ldv_state_variable_22 = 1;
        ldv_file_operations_22();
        ldv_state_variable_48 = 1;
        ldv_file_operations_48();
        ldv_state_variable_53 = 1;
        ldv_file_operations_53();
        ldv_state_variable_35 = 1;
        ldv_file_operations_35();
        ldv_state_variable_31 = 1;
        ldv_file_operations_31();
        ldv_state_variable_24 = 1;
        ldv_file_operations_24();
        ldv_state_variable_49 = 1;
        ldv_file_operations_49();
        ldv_state_variable_59 = 1;
        ldv_initialize_iwl_dvm_cfg_59();
        ldv_state_variable_69 = 1;
        ldv_initialize_iwl_op_mode_ops_69();
        ldv_state_variable_20 = 1;
        ldv_file_operations_20();
        ldv_state_variable_61 = 1;
        ldv_initialize_iwl_dvm_cfg_61();
        ldv_state_variable_40 = 1;
        ldv_file_operations_40();
        ldv_state_variable_57 = 1;
        ldv_initialize_iwl_dvm_cfg_57();
        ldv_state_variable_28 = 1;
        ldv_file_operations_28();
        ldv_state_variable_27 = 1;
        ldv_file_operations_27();
        ldv_state_variable_25 = 1;
        ldv_file_operations_25();
        ldv_state_variable_55 = 1;
        ldv_initialize_iwl_dvm_cfg_55();
        ldv_state_variable_44 = 1;
        ldv_file_operations_44();
        ldv_state_variable_30 = 1;
        ldv_file_operations_30();
        ldv_state_variable_26 = 1;
        ldv_file_operations_26();
        ldv_state_variable_68 = 1;
        ldv_file_operations_68();
        ldv_state_variable_21 = 1;
        ldv_file_operations_21();
        ldv_state_variable_63 = 1;
        ldv_initialize_iwl_dvm_cfg_63();
        ldv_state_variable_32 = 1;
        ldv_file_operations_32();
        ldv_state_variable_33 = 1;
        ldv_file_operations_33();
        ldv_state_variable_67 = 1;
        ldv_file_operations_67();
      } else {

      }
    } else {

    }
    goto ldv_56184;
    default: 
    ldv_stop();
    }
    ldv_56184: ;
  } else {

  }
  goto ldv_56114;
  case 54: ;
  if (ldv_state_variable_46 != 0) {
    ldv_main_exported_46();
  } else {

  }
  goto ldv_56114;
  case 55: ;
  if (ldv_state_variable_23 != 0) {
    ldv_main_exported_23();
  } else {

  }
  goto ldv_56114;
  case 56: ;
  goto ldv_56114;
  case 57: ;
  if (ldv_state_variable_6 != 0) {
    invoke_work_6();
  } else {

  }
  goto ldv_56114;
  case 58: ;
  if (ldv_state_variable_3 != 0) {
    invoke_work_3();
  } else {

  }
  goto ldv_56114;
  case 59: ;
  if (ldv_state_variable_36 != 0) {
    ldv_main_exported_36();
  } else {

  }
  goto ldv_56114;
  case 60: ;
  goto ldv_56114;
  case 61: ;
  if (ldv_state_variable_51 != 0) {
    ldv_main_exported_51();
  } else {

  }
  goto ldv_56114;
  case 62: ;
  if (ldv_state_variable_47 != 0) {
    ldv_main_exported_47();
  } else {

  }
  goto ldv_56114;
  case 63: ;
  goto ldv_56114;
  case 64: ;
  if (ldv_state_variable_38 != 0) {
    ldv_main_exported_38();
  } else {

  }
  goto ldv_56114;
  case 65: ;
  if (ldv_state_variable_4 != 0) {
    invoke_work_4();
  } else {

  }
  goto ldv_56114;
  case 66: ;
  if (ldv_state_variable_34 != 0) {
    ldv_main_exported_34();
  } else {

  }
  goto ldv_56114;
  case 67: ;
  if (ldv_state_variable_37 != 0) {
    ldv_main_exported_37();
  } else {

  }
  goto ldv_56114;
  case 68: ;
  if (ldv_state_variable_43 != 0) {
    ldv_main_exported_43();
  } else {

  }
  goto ldv_56114;
  case 69: ;
  if (ldv_state_variable_5 != 0) {
    invoke_work_5();
  } else {

  }
  goto ldv_56114;
  default: 
  ldv_stop();
  }
  ldv_56114: ;
  goto ldv_56204;
  ldv_final: 
  ldv_check_final_state();
  return 0;
}
}
bool ldv_queue_work_on_5(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                         struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_7(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_delayed_work_on_6(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                 struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_7(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_work_on_7(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                         struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_7(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
void ldv_flush_workqueue_8(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
  flush_workqueue(ldv_func_arg1);
  call_and_disable_all_7(2);
  return;
}
}
bool ldv_queue_delayed_work_on_9(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                 struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_7(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
int ldv_mod_timer_10(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;

  {
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
  ldv_func_res = tmp;
  activate_pending_timer_18(ldv_func_arg1, ldv_func_arg2, 1);
  return (ldv_func_res);
}
}
int ldv_mod_timer_11(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___4 ldv_func_res ;
  int tmp ;

  {
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
  ldv_func_res = tmp;
  activate_pending_timer_18(ldv_func_arg1, ldv_func_arg2, 1);
  return (ldv_func_res);
}
}
bool ldv_cancel_work_sync_12(struct work_struct *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___5 ldv_func_res ;
  bool tmp ;

  {
  tmp = cancel_work_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_work_7(ldv_func_arg1);
  return (ldv_func_res);
}
}
bool ldv_cancel_work_sync_13(struct work_struct *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___6 ldv_func_res ;
  bool tmp ;

  {
  tmp = cancel_work_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_work_7(ldv_func_arg1);
  return (ldv_func_res);
}
}
bool ldv_cancel_work_sync_14(struct work_struct *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___7 ldv_func_res ;
  bool tmp ;

  {
  tmp = cancel_work_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_work_7(ldv_func_arg1);
  return (ldv_func_res);
}
}
bool ldv_cancel_work_sync_15(struct work_struct *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___8 ldv_func_res ;
  bool tmp ;

  {
  tmp = cancel_work_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_work_7(ldv_func_arg1);
  return (ldv_func_res);
}
}
int ldv_del_timer_sync_16(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___9 ldv_func_res ;
  int tmp ;

  {
  tmp = del_timer_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_suitable_timer_18(ldv_func_arg1);
  return (ldv_func_res);
}
}
int ldv_del_timer_sync_17(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___10 ldv_func_res ;
  int tmp ;

  {
  tmp = del_timer_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_suitable_timer_18(ldv_func_arg1);
  return (ldv_func_res);
}
}
void ldv_destroy_workqueue_18(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
  destroy_workqueue(ldv_func_arg1);
  call_and_disable_all_7(2);
  return;
}
}
void ldv_ieee80211_free_hw_19(struct ieee80211_hw *ldv_func_arg1 ) 
{ 


  {
  ieee80211_free_hw(ldv_func_arg1);
  if ((unsigned long )iwlagn_hw_ops_group0 == (unsigned long )ldv_func_arg1) {
    ldv_state_variable_64 = 0;
  } else {

  }
  return;
}
}
void ldv_flush_workqueue_20(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
  flush_workqueue(ldv_func_arg1);
  call_and_disable_all_7(2);
  return;
}
}
void ldv_destroy_workqueue_21(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
  destroy_workqueue(ldv_func_arg1);
  call_and_disable_all_7(2);
  return;
}
}
void ldv_ieee80211_free_hw_22(struct ieee80211_hw *ldv_func_arg1 ) 
{ 


  {
  ieee80211_free_hw(ldv_func_arg1);
  if ((unsigned long )iwlagn_hw_ops_group0 == (unsigned long )ldv_func_arg1) {
    ldv_state_variable_64 = 0;
  } else {

  }
  return;
}
}
__inline static long ldv__builtin_expect(long exp , long c ) ;
extern unsigned long find_next_bit(unsigned long const   * , unsigned long  , unsigned long  ) ;
extern unsigned long find_first_bit(unsigned long const   * , unsigned long  ) ;
extern void __might_fault(char const   * , int  ) ;
extern int sprintf(char * , char const   *  , ...) ;
extern int sscanf(char const   * , char const   *  , ...) ;
bool ldv_queue_work_on_45(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_work_on_47(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_delayed_work_on_46(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
bool ldv_queue_delayed_work_on_49(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
void ldv_flush_workqueue_48(struct workqueue_struct *ldv_func_arg1 ) ;
__inline static bool queue_work___0(struct workqueue_struct *wq , struct work_struct *work ) 
{ 
  bool tmp ;

  {
  tmp = ldv_queue_work_on_45(8192, wq, work);
  return (tmp);
}
}
extern unsigned long _copy_from_user(void * , void const   * , unsigned int  ) ;
extern void __copy_from_user_overflow(void) ;
__inline static unsigned long copy_from_user(void *to , void const   *from , unsigned long n ) 
{ 
  int sz ;
    klee_make_symbolic(&sz, sizeof(int), "sz");
  unsigned long tmp ;
  long tmp___0 ;

  {
  tmp = __builtin_object_size((void const   *)to, 0);
  sz = (int )tmp;
  __might_fault("./arch/x86/include/asm/uaccess.h", 697);
  tmp___0 = ldv__builtin_expect((long )(sz < 0 || (unsigned long )sz >= n), 1L);
  if (tmp___0 != 0L) {
    n = _copy_from_user(to, from, (unsigned int )n);
  } else {
    __copy_from_user_overflow();
  }
  return (n);
}
}
__inline static int ieee80211_has_a4(__le16 fc ) 
{ 
  __le16 tmp ;

  {
  tmp = 768U;
  return (((int )fc & (int )tmp) == (int )tmp);
}
}
__inline static int ieee80211_is_data(__le16 fc ) 
{ 


  {
  return (((int )fc & 12) == 8);
}
}
__inline static int ieee80211_is_data_qos(__le16 fc ) 
{ 


  {
  return (((int )fc & 140) == 136);
}
}
__inline static u8 *ieee80211_get_qos_ctl(struct ieee80211_hdr *hdr ) 
{ 
  int tmp ;

  {
  tmp = ieee80211_has_a4((int )hdr->frame_control);
  if (tmp != 0) {
    return ((u8 *)hdr + 30UL);
  } else {
    return ((u8 *)hdr + 24UL);
  }
}
}
extern loff_t default_llseek(struct file * , loff_t  , int  ) ;
extern int simple_open(struct inode * , struct file * ) ;
extern ssize_t simple_read_from_buffer(void * , size_t  , loff_t * , void const   * ,
                                       size_t  ) ;
extern struct dentry *debugfs_create_file(char const   * , umode_t  , struct dentry * ,
                                          void * , struct file_operations  const  * ) ;
extern void debugfs_remove(struct dentry * ) ;
extern struct dentry *debugfs_create_u8(char const   * , umode_t  , struct dentry * ,
                                        u8 * ) ;
extern int ieee80211_start_tx_ba_session(struct ieee80211_sta * , u16  , u16  ) ;
extern int ieee80211_stop_tx_ba_session(struct ieee80211_sta * , u16  ) ;
__inline static int rate_supported(struct ieee80211_sta *sta , enum ieee80211_band band ,
                                   int index ) 
{ 


  {
  return ((unsigned long )sta == (unsigned long )((struct ieee80211_sta *)0) || (int )((unsigned long )sta->supp_rates[(unsigned int )band] >> index) & 1);
}
}
extern bool rate_control_send_low(struct ieee80211_sta * , void * , struct ieee80211_tx_rate_control * ) ;
__inline static s8 rate_lowest_index(struct ieee80211_supported_band *sband , struct ieee80211_sta *sta ) 
{ 
  int i ;
  int tmp ;
  bool __warned ;
  int __ret_warn_once ;
  int __ret_warn_on ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;

  {
  i = 0;
  goto ldv_49678;
  ldv_49677: 
  tmp = rate_supported(sta, sband->band, i);
  if (tmp != 0) {
    return ((s8 )i);
  } else {

  }
  i = i + 1;
  ldv_49678: ;
  if (sband->n_bitrates > i) {
    goto ldv_49677;
  } else {

  }
  __ret_warn_once = 1;
  tmp___2 = ldv__builtin_expect(__ret_warn_once != 0, 0L);
  if (tmp___2 != 0L) {
    __ret_warn_on = ! __warned;
    tmp___0 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
    if (tmp___0 != 0L) {
      warn_slowpath_null("include/net/mac80211.h", 5189);
    } else {

    }
    tmp___1 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
    if (tmp___1 != 0L) {
      __warned = 1;
    } else {

    }
  } else {

  }
  ldv__builtin_expect(__ret_warn_once != 0, 0L);
  return (0);
}
}
extern int ieee80211_rate_control_register(struct rate_control_ops  const  * ) ;
extern void ieee80211_rate_control_unregister(struct rate_control_ops  const  * ) ;
__inline static bool conf_is_ht(struct ieee80211_conf *conf ) 
{ 


  {
  return ((bool )(((unsigned int )conf->chandef.width != 6U && (unsigned int )conf->chandef.width != 7U) && (unsigned int )conf->chandef.width != 0U));
}
}
struct iwl_rate_info  const  iwl_rates[13U] ;
__inline static u8 first_antenna(u8 mask ) 
{ 


  {
  if ((int )mask & 1) {
    return (1U);
  } else {

  }
  if (((unsigned long )mask & 2UL) != 0UL) {
    return (2U);
  } else {

  }
  return (4U);
}
}
void iwl_rs_rate_init(struct iwl_priv *priv , struct ieee80211_sta *sta , u8 sta_id ) ;
bool iwl_ht_enabled(struct iwl_priv *priv ) ;
enum iwl_antenna_ok iwl_tx_ant_restriction(struct iwl_priv *priv ) ;
int iwl_send_lq_cmd(struct iwl_priv *priv , struct iwl_rxon_context *ctx , struct iwl_link_quality_cmd *lq ,
                    u8 flags , bool init ) ;
bool iwl_is_ht40_tx_allowed(struct iwl_priv *priv , struct iwl_rxon_context *ctx ,
                            struct ieee80211_sta *sta ) ;
static u8 rs_ht_to_legacy[13U]  = 
  {      4U,      4U,      4U,      4U, 
        4U,      4U,      5U,      6U, 
        7U,      8U,      9U,      10U, 
        11U};
static u8 const   ant_toggle_lookup[8U]  = 
  {      0U,      2U,      4U,      6U, 
        1U,      3U,      5U,      7U};
struct iwl_rate_info  const  iwl_rates[13U]  = 
  {      {10U, 24U, 24U, 24U, 2U, 13U, 1U, 13U, 1U, 13U, 1U}, 
        {20U, 24U, 24U, 24U, 4U, 0U, 2U, 0U, 2U, 0U, 2U}, 
        {55U, 24U, 24U, 24U, 11U, 1U, 4U, 1U, 3U, 1U, 3U}, 
        {110U, 24U, 24U, 24U, 22U, 5U, 6U, 5U, 6U, 2U, 7U}, 
        {13U, 0U, 8U, 16U, 12U, 2U, 5U, 2U, 3U, 2U, 3U}, 
        {15U, 0U, 8U, 16U, 18U, 4U, 3U, 4U, 3U, 2U, 3U}, 
        {5U, 1U, 9U, 17U, 24U, 3U, 7U, 3U, 7U, 3U, 7U}, 
        {7U, 2U, 10U, 18U, 36U, 6U, 8U, 6U, 8U, 3U, 8U}, 
        {9U, 3U, 11U, 19U, 48U, 7U, 9U, 7U, 9U, 7U, 9U}, 
        {11U, 4U, 12U, 20U, 72U, 8U, 10U, 8U, 10U, 8U, 10U}, 
        {1U, 5U, 13U, 21U, 96U, 9U, 11U, 9U, 11U, 9U, 11U}, 
        {3U, 6U, 14U, 22U, 108U, 10U, 13U, 10U, 13U, 10U, 13U}, 
        {3U, 7U, 15U, 23U, 120U, 10U, 13U, 10U, 13U, 10U, 13U}};
__inline static u8 rs_extract_rate(u32 rate_n_flags ) 
{ 


  {
  return ((u8 )rate_n_flags);
}
}
static int iwl_hwrate_to_plcp_idx(u32 rate_n_flags ) 
{ 
  int idx ;
    klee_make_symbolic(&idx, sizeof(int), "idx");
  u8 tmp ;
  u8 tmp___0 ;

  {
  idx = 0;
  if ((rate_n_flags & 256U) != 0U) {
    tmp = rs_extract_rate(rate_n_flags);
    idx = (int )tmp;
    if (idx > 15) {
      idx = idx + -16;
    } else
    if (idx > 7) {
      idx = idx + -8;
    } else {

    }
    idx = idx + 4;
    if (idx > 4) {
      idx = idx + 1;
    } else {

    }
    if (idx > 3 && idx <= 12) {
      return (idx);
    } else {

    }
  } else {
    idx = 0;
    goto ldv_53650;
    ldv_53649: 
    tmp___0 = rs_extract_rate(rate_n_flags);
    if ((int )((unsigned char )iwl_rates[idx].plcp) == (int )tmp___0) {
      return (idx);
    } else {

    }
    idx = idx + 1;
    ldv_53650: ;
    if ((unsigned int )idx <= 12U) {
      goto ldv_53649;
    } else {

    }

  }
  return (-1);
}
}
static void rs_rate_scale_perform(struct iwl_priv *priv , struct sk_buff *skb , struct ieee80211_sta *sta ,
                                  struct iwl_lq_sta *lq_sta ) ;
static void rs_fill_link_cmd(struct iwl_priv *priv , struct iwl_lq_sta *lq_sta , u32 new_rate ) ;
static void rs_stay_in_table(struct iwl_lq_sta *lq_sta , bool force_search ) ;
static void rs_dbgfs_set_mcs(struct iwl_lq_sta *lq_sta , u32 *rate_n_flags , int index ) ;
static u16 const   expected_tpt_legacy[13U]  = 
  {      7U,      13U,      35U,      58U, 
        40U,      57U,      72U,      98U, 
        121U,      154U,      177U,      186U, 
        0U};
static u16 const   expected_tpt_siso20MHz[4U][13U]  = { {        0U,        0U,        0U,        0U, 
            42U,        0U,        76U,        102U, 
            124U,        159U,        183U,        193U, 
            202U}, 
   {        0U,        0U,        0U,        0U, 
            46U,        0U,        82U,        110U, 
            132U,        168U,        192U,        202U, 
            210U}, 
   {        0U,        0U,        0U,        0U, 
            47U,        0U,        91U,        133U, 
            171U,        242U,        305U,        334U, 
            362U}, 
   {        0U,        0U,        0U,        0U, 
            52U,        0U,        101U,        145U, 
            187U,        264U,        330U,        361U, 
            390U}};
static u16 const   expected_tpt_siso40MHz[4U][13U]  = { {        0U,        0U,        0U,        0U, 
            77U,        0U,        127U,        160U, 
            184U,        220U,        242U,        250U, 
            257U}, 
   {        0U,        0U,        0U,        0U, 
            83U,        0U,        135U,        169U, 
            193U,        229U,        250U,        257U, 
            264U}, 
   {        0U,        0U,        0U,        0U, 
            94U,        0U,        177U,        249U, 
            313U,        423U,        512U,        550U, 
            586U}, 
   {        0U,        0U,        0U,        0U, 
            104U,        0U,        193U,        270U, 
            338U,        454U,        545U,        584U, 
            620U}};
static u16 const   expected_tpt_mimo2_20MHz[4U][13U]  = { {        0U,        0U,        0U,        0U, 
            74U,        0U,        123U,        155U, 
            179U,        214U,        236U,        244U, 
            251U}, 
   {        0U,        0U,        0U,        0U, 
            81U,        0U,        131U,        164U, 
            188U,        223U,        243U,        251U, 
            257U}, 
   {        0U,        0U,        0U,        0U, 
            89U,        0U,        167U,        235U, 
            296U,        402U,        488U,        526U, 
            560U}, 
   {        0U,        0U,        0U,        0U, 
            97U,        0U,        182U,        255U, 
            320U,        431U,        520U,        558U, 
            593U}};
static u16 const   expected_tpt_mimo2_40MHz[4U][13U]  = { {        0U,        0U,        0U,        0U, 
            123U,        0U,        182U,        214U, 
            235U,        264U,        279U,        285U, 
            289U}, 
   {        0U,        0U,        0U,        0U, 
            131U,        0U,        191U,        222U, 
            242U,        270U,        284U,        289U, 
            293U}, 
   {        0U,        0U,        0U,        0U, 
            171U,        0U,        305U,        410U, 
            496U,        634U,        731U,        771U, 
            805U}, 
   {        0U,        0U,        0U,        0U, 
            186U,        0U,        329U,        439U, 
            527U,        667U,        764U,        803U, 
            838U}};
static u16 const   expected_tpt_mimo3_20MHz[4U][13U]  = { {        0U,        0U,        0U,        0U, 
            99U,        0U,        153U,        186U, 
            208U,        239U,        256U,        263U, 
            268U}, 
   {        0U,        0U,        0U,        0U, 
            106U,        0U,        162U,        194U, 
            215U,        246U,        262U,        268U, 
            273U}, 
   {        0U,        0U,        0U,        0U, 
            134U,        0U,        249U,        346U, 
            431U,        574U,        685U,        732U, 
            775U}, 
   {        0U,        0U,        0U,        0U, 
            148U,        0U,        272U,        376U, 
            465U,        614U,        727U,        775U, 
            818U}};
static u16 const   expected_tpt_mimo3_40MHz[4U][13U]  = { {        0U,        0U,        0U,        0U, 
            152U,        0U,        211U,        239U, 
            255U,        279U,        290U,        294U, 
            297U}, 
   {        0U,        0U,        0U,        0U, 
            160U,        0U,        219U,        245U, 
            261U,        284U,        294U,        297U, 
            300U}, 
   {        0U,        0U,        0U,        0U, 
            254U,        0U,        443U,        584U, 
            695U,        868U,        984U,        1030U, 
            1070U}, 
   {        0U,        0U,        0U,        0U, 
            277U,        0U,        478U,        624U, 
            737U,        911U,        1026U,        1070U, 
            1109U}};
static struct iwl_rate_mcs_info  const  iwl_rate_mcs[13U]  = 
  {      {{'1', '\000'}, {'B', 'P', 'S', 'K', ' ', 'D', 'S', 'S', 'S', '\000'}}, 
        {{'2', '\000'}, {'Q', 'P', 'S', 'K', ' ', 'D', 'S', 'S', 'S', '\000'}}, 
        {{'5', '.', '5', '\000'}, {'B', 'P', 'S', 'K', ' ', 'C', 'C', 'K', '\000'}}, 
        {{'1', '1', '\000'}, {'Q', 'P', 'S', 'K', ' ', 'C', 'C', 'K', '\000'}}, 
        {{'6', '\000'}, {'B', 'P', 'S', 'K', ' ', '1', '/', '2', '\000'}}, 
        {{'9', '\000'}, {'B', 'P', 'S', 'K', ' ', '1', '/', '2', '\000'}}, 
        {{'1', '2', '\000'}, {'Q', 'P', 'S', 'K', ' ', '1', '/', '2', '\000'}}, 
        {{'1', '8', '\000'}, {'Q', 'P', 'S', 'K', ' ', '3', '/', '4', '\000'}}, 
        {{'2', '4', '\000'}, {'1', '6', 'Q', 'A', 'M', ' ', '1', '/', '2', '\000'}}, 
        {{'3', '6', '\000'}, {'1', '6', 'Q', 'A', 'M', ' ', '3', '/', '4', '\000'}}, 
        {{'4', '8', '\000'}, {'6', '4', 'Q', 'A', 'M', ' ', '2', '/', '3', '\000'}}, 
        {{'5', '4', '\000'}, {'6', '4', 'Q', 'A', 'M', ' ', '3', '/', '4', '\000'}}, 
        {{'6', '0', '\000'}, {'6', '4', 'Q', 'A', 'M', ' ', '5', '/', '6', '\000'}}};
static void rs_rate_scale_clear_window(struct iwl_rate_scale_data *window ) 
{ 


  {
  window->data = 0ULL;
  window->success_counter = 0;
  window->success_ratio = -1;
  window->counter = 0;
  window->average_tpt = -1;
  window->stamp = 0UL;
  return;
}
}
__inline static u8 rs_is_valid_ant(u8 valid_antenna , u8 ant_type ) 
{ 


  {
  return (((int )ant_type & (int )valid_antenna) == (int )ant_type);
}
}
static void rs_tl_rm_old_stats(struct iwl_traffic_load *tl , u32 curr_time ) 
{ 
  u32 oldest_time ;

  {
  oldest_time = curr_time - 950U;
  goto ldv_53689;
  ldv_53688: 
  tl->total = tl->total - tl->packet_count[(int )tl->head];
  tl->packet_count[(int )tl->head] = 0U;
  tl->time_stamp = tl->time_stamp + 50UL;
  tl->queue_count = (u8 )((int )tl->queue_count - 1);
  tl->head = (u8 )((int )tl->head + 1);
  if ((unsigned int )tl->head > 19U) {
    tl->head = 0U;
  } else {

  }
  ldv_53689: ;
  if ((unsigned int )tl->queue_count != 0U && tl->time_stamp < (unsigned long )oldest_time) {
    goto ldv_53688;
  } else {

  }

  return;
}
}
static u8 rs_tl_add_packet(struct iwl_lq_sta *lq_data , struct ieee80211_hdr *hdr ) 
{ 
  u32 curr_time ;
  unsigned int tmp ;
  u32 time_diff ;
  s32 index ;
  struct iwl_traffic_load *tl ;
  u8 tid ;
  u8 *qc ;
  u8 *tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;

  {
  tmp = jiffies_to_msecs(jiffies);
  curr_time = tmp;
  tl = (struct iwl_traffic_load *)0;
  tmp___1 = ieee80211_is_data_qos((int )hdr->frame_control);
  if (tmp___1 != 0) {
    tmp___0 = ieee80211_get_qos_ctl(hdr);
    qc = tmp___0;
    tid = (unsigned int )*qc & 15U;
  } else {
    return (8U);
  }
  tmp___2 = ldv__builtin_expect((unsigned int )tid > 7U, 0L);
  if (tmp___2 != 0L) {
    return (8U);
  } else {

  }
  tl = (struct iwl_traffic_load *)(& lq_data->load) + (unsigned long )tid;
  curr_time = curr_time - curr_time % 5U;
  if ((unsigned int )tl->queue_count == 0U) {
    tl->total = 1U;
    tl->time_stamp = (unsigned long )curr_time;
    tl->queue_count = 1U;
    tl->head = 0U;
    tl->packet_count[0] = 1U;
    return (8U);
  } else {

  }
  time_diff = curr_time - (u32 )tl->time_stamp;
  index = (s32 )(time_diff / 50U);
  if (index > 19) {
    rs_tl_rm_old_stats(tl, curr_time);
  } else {

  }
  index = ((s32 )tl->head + index) % 20;
  tl->packet_count[index] = tl->packet_count[index] + 1U;
  tl->total = tl->total + 1U;
  if (index + 1 > (int )tl->queue_count) {
    tl->queue_count = (unsigned int )((u8 )index) + 1U;
  } else {

  }
  return (tid);
}
}
static void rs_program_fix_rate(struct iwl_priv *priv , struct iwl_lq_sta *lq_sta ) 
{ 
  struct iwl_station_priv *sta_priv ;
  struct iwl_lq_sta  const  *__mptr ;
  struct iwl_rxon_context *ctx ;

  {
  __mptr = (struct iwl_lq_sta  const  *)lq_sta;
  sta_priv = (struct iwl_station_priv *)__mptr + 0xfffffffffffffff8UL;
  ctx = sta_priv->ctx;
  lq_sta->active_legacy_rate = 4095U;
  lq_sta->active_siso_rate = 8144U;
  lq_sta->active_mimo2_rate = 8144U;
  lq_sta->active_mimo3_rate = 8144U;
  __iwl_dbg(priv->dev, 1048576U, 0, "rs_program_fix_rate", "sta_id %d rate 0x%X\n",
            (int )lq_sta->lq.sta_id, lq_sta->dbg_fixed_rate);
  if (lq_sta->dbg_fixed_rate != 0U) {
    rs_fill_link_cmd((struct iwl_priv *)0, lq_sta, lq_sta->dbg_fixed_rate);
    iwl_send_lq_cmd(lq_sta->drv, ctx, & lq_sta->lq, 1, 0);
  } else {

  }
  return;
}
}
static u32 rs_tl_get_load(struct iwl_lq_sta *lq_data , u8 tid ) 
{ 
  u32 curr_time ;
  unsigned int tmp ;
  u32 time_diff ;
  s32 index ;
  struct iwl_traffic_load *tl ;

  {
  tmp = jiffies_to_msecs(jiffies);
  curr_time = tmp;
  tl = (struct iwl_traffic_load *)0;
  if ((unsigned int )tid > 7U) {
    return (0U);
  } else {

  }
  tl = (struct iwl_traffic_load *)(& lq_data->load) + (unsigned long )tid;
  curr_time = curr_time - curr_time % 5U;
  if ((unsigned int )tl->queue_count == 0U) {
    return (0U);
  } else {

  }
  time_diff = curr_time - (u32 )tl->time_stamp;
  index = (s32 )(time_diff / 50U);
  if (index > 19) {
    rs_tl_rm_old_stats(tl, curr_time);
  } else {

  }
  return (tl->total);
}
}
static int rs_tl_turn_on_agg_for_tid(struct iwl_priv *priv , struct iwl_lq_sta *lq_data ,
                                     u8 tid , struct ieee80211_sta *sta ) 
{ 
  int ret ;
  u32 load ;

  {
  ret = -11;
  if ((unsigned int )priv->bt_traffic_load > 1U) {
    __iwl_dbg(priv->dev, 32768U, 0, "rs_tl_turn_on_agg_for_tid", "BT traffic (%d), no aggregation allowed\n",
              (int )priv->bt_traffic_load);
    return (ret);
  } else {

  }
  load = rs_tl_get_load(lq_data, (int )tid);
  __iwl_dbg(priv->dev, 67108864U, 0, "rs_tl_turn_on_agg_for_tid", "Starting Tx agg: STA: %pM tid: %d\n",
            (u8 *)(& sta->addr), (int )tid);
  ret = ieee80211_start_tx_ba_session(sta, (int )tid, 5000);
  if (ret == -11) {
    __iwl_err(priv->dev, 0, 0, "Fail start Tx agg on tid: %d\n", (int )tid);
    ieee80211_stop_tx_ba_session(sta, (int )tid);
  } else {

  }
  return (ret);
}
}
static void rs_tl_turn_on_agg(struct iwl_priv *priv , u8 tid , struct iwl_lq_sta *lq_data ,
                              struct ieee80211_sta *sta ) 
{ 


  {
  if ((unsigned int )tid <= 7U) {
    rs_tl_turn_on_agg_for_tid(priv, lq_data, (int )tid, sta);
  } else {
    __iwl_err(priv->dev, 0, 0, "tid exceeds max TID count: %d/%d\n", (int )tid, 8);
  }
  return;
}
}
__inline static int get_num_of_ant_from_rate(u32 rate_n_flags ) 
{ 


  {
  return ((((rate_n_flags & 16384U) != 0U) + ((rate_n_flags & 32768U) != 0U)) + ((rate_n_flags & 65536U) != 0U));
}
}
static s32 get_expected_tpt(struct iwl_scale_tbl_info *tbl , int rs_index ) 
{ 


  {
  if ((unsigned long )tbl->expected_tpt != (unsigned long )((u16 const   *)0U)) {
    return ((s32 )*(tbl->expected_tpt + (unsigned long )rs_index));
  } else {

  }
  return (0);
}
}
static int rs_collect_tx_data(struct iwl_scale_tbl_info *tbl , int scale_index , int attempts ,
                              int successes ) 
{ 
  struct iwl_rate_scale_data *window ;
  u64 mask ;
  s32 fail_count ;
  s32 tpt ;

  {
  window = (struct iwl_rate_scale_data *)0;
  mask = 2305843009213693952ULL;
  if (scale_index < 0 || scale_index > 12) {
    return (-22);
  } else {

  }
  window = (struct iwl_rate_scale_data *)(& tbl->win) + (unsigned long )scale_index;
  tpt = get_expected_tpt(tbl, scale_index);
  goto ldv_53751;
  ldv_53750: ;
  if (window->counter > 61) {
    window->counter = 61;
    if ((window->data & mask) != 0ULL) {
      window->data = window->data & ~ mask;
      window->success_counter = window->success_counter - 1;
    } else {

    }
  } else {

  }
  window->counter = window->counter + 1;
  window->data = window->data << 1;
  if (successes > 0) {
    window->success_counter = window->success_counter + 1;
    window->data = window->data | 1ULL;
    successes = successes - 1;
  } else {

  }
  attempts = attempts - 1;
  ldv_53751: ;
  if (attempts > 0) {
    goto ldv_53750;
  } else {

  }

  if (window->counter > 0) {
    window->success_ratio = (window->success_counter * 12800) / window->counter;
  } else {
    window->success_ratio = -1;
  }
  fail_count = window->counter - window->success_counter;
  if (fail_count > 5 || window->success_counter > 7) {
    window->average_tpt = (window->success_ratio * tpt + 64) / 128;
  } else {
    window->average_tpt = -1;
  }
  window->stamp = jiffies;
  return (0);
}
}
static u32 rate_n_flags_from_tbl(struct iwl_priv *priv , struct iwl_scale_tbl_info *tbl ,
                                 int index , u8 use_green ) 
{ 
  u32 rate_n_flags ;

  {
  rate_n_flags = 0U;
  if ((unsigned int )tbl->lq_type == 1U || (unsigned int )tbl->lq_type == 2U) {
    rate_n_flags = (u32 )iwl_rates[index].plcp;
    if (index >= 0 && index <= 3) {
      rate_n_flags = rate_n_flags | 512U;
    } else {

    }
  } else
  if ((unsigned int )tbl->lq_type == 3U || ((unsigned int )tbl->lq_type == 4U || (unsigned int )tbl->lq_type == 5U)) {
    if (index > 12) {
      __iwl_err(priv->dev, 0, 0, "Invalid HT rate index %d\n", index);
      index = 12;
    } else {

    }
    rate_n_flags = 256U;
    if ((unsigned int )tbl->lq_type == 3U) {
      rate_n_flags = (u32 )iwl_rates[index].plcp_siso | rate_n_flags;
    } else
    if ((unsigned int )tbl->lq_type == 4U) {
      rate_n_flags = (u32 )iwl_rates[index].plcp_mimo2 | rate_n_flags;
    } else {
      rate_n_flags = (u32 )iwl_rates[index].plcp_mimo3 | rate_n_flags;
    }
  } else {
    __iwl_err(priv->dev, 0, 0, "Invalid tbl->lq_type %d\n", (unsigned int )tbl->lq_type);
  }
  rate_n_flags = ((u32 )((int )tbl->ant_type << 14) & 114688U) | rate_n_flags;
  if ((unsigned int )tbl->lq_type == 3U || ((unsigned int )tbl->lq_type == 4U || (unsigned int )tbl->lq_type == 5U)) {
    if ((unsigned int )tbl->is_ht40 != 0U) {
      if ((unsigned int )tbl->is_dup != 0U) {
        rate_n_flags = rate_n_flags | 4096U;
      } else {
        rate_n_flags = rate_n_flags | 2048U;
      }
    } else {

    }
    if ((unsigned int )tbl->is_SGI != 0U) {
      rate_n_flags = rate_n_flags | 8192U;
    } else {

    }
    if ((unsigned int )use_green != 0U) {
      rate_n_flags = rate_n_flags | 1024U;
      if ((unsigned int )tbl->lq_type == 3U && (unsigned int )tbl->is_SGI != 0U) {
        rate_n_flags = rate_n_flags & 4294959103U;
        __iwl_err(priv->dev, 0, 0, "GF was set with SGI:SISO\n");
      } else {

      }
    } else {

    }
  } else {

  }
  return (rate_n_flags);
}
}
static int rs_get_tbl_info_from_mcs(u32 const   rate_n_flags , enum ieee80211_band band ,
                                    struct iwl_scale_tbl_info *tbl , int *rate_idx ) 
{ 
  u32 ant_msk ;
  u8 num_of_ant___0 ;
  int tmp ;
  u8 mcs ;

  {
  ant_msk = (unsigned int )rate_n_flags & 114688U;
  tmp = get_num_of_ant_from_rate(rate_n_flags);
  num_of_ant___0 = (u8 )tmp;
  memset((void *)tbl, 0, 448UL);
  *rate_idx = iwl_hwrate_to_plcp_idx(rate_n_flags);
  if (*rate_idx == 13) {
    *rate_idx = -1;
    return (-22);
  } else {

  }
  tbl->is_SGI = 0U;
  tbl->is_ht40 = 0U;
  tbl->is_dup = 0U;
  tbl->ant_type = (u8 )(ant_msk >> 14);
  tbl->lq_type = 0;
  tbl->max_search = 6U;
  if (((unsigned int )rate_n_flags & 256U) == 0U) {
    if ((unsigned int )num_of_ant___0 == 1U) {
      if ((unsigned int )band == 1U) {
        tbl->lq_type = 2;
      } else {
        tbl->lq_type = 1;
      }
    } else {

    }
  } else {
    if (((unsigned int )rate_n_flags & 8192U) != 0U) {
      tbl->is_SGI = 1U;
    } else {

    }
    if (((unsigned int )rate_n_flags & 2048U) != 0U || ((unsigned int )rate_n_flags & 4096U) != 0U) {
      tbl->is_ht40 = 1U;
    } else {

    }
    if (((unsigned int )rate_n_flags & 4096U) != 0U) {
      tbl->is_dup = 1U;
    } else {

    }
    mcs = rs_extract_rate(rate_n_flags);
    if ((unsigned int )mcs <= 7U) {
      if ((unsigned int )num_of_ant___0 == 1U) {
        tbl->lq_type = 3;
      } else {

      }
    } else
    if ((unsigned int )mcs <= 15U) {
      if ((unsigned int )num_of_ant___0 == 2U) {
        tbl->lq_type = 4;
      } else {

      }
    } else
    if ((unsigned int )num_of_ant___0 == 3U) {
      tbl->max_search = 8U;
      tbl->lq_type = 5;
    } else {

    }
  }
  return (0);
}
}
static int rs_toggle_antenna(u32 valid_ant , u32 *rate_n_flags , struct iwl_scale_tbl_info *tbl ) 
{ 
  u8 new_ant_type ;
  u8 tmp ;
  u8 tmp___0 ;

  {
  if ((unsigned int )tbl->ant_type == 0U || (unsigned int )tbl->ant_type > 7U) {
    return (0);
  } else {

  }
  tmp = rs_is_valid_ant((int )((u8 )valid_ant), (int )tbl->ant_type);
  if ((unsigned int )tmp == 0U) {
    return (0);
  } else {

  }
  new_ant_type = ant_toggle_lookup[(int )tbl->ant_type];
  goto ldv_53776;
  ldv_53775: 
  new_ant_type = ant_toggle_lookup[(int )new_ant_type];
  ldv_53776: ;
  if ((int )tbl->ant_type != (int )new_ant_type) {
    tmp___0 = rs_is_valid_ant((int )((u8 )valid_ant), (int )new_ant_type);
    if ((unsigned int )tmp___0 == 0U) {
      goto ldv_53775;
    } else {
      goto ldv_53777;
    }
  } else {

  }
  ldv_53777: ;
  if ((int )tbl->ant_type == (int )new_ant_type) {
    return (0);
  } else {

  }
  tbl->ant_type = new_ant_type;
  *rate_n_flags = *rate_n_flags & 4294852607U;
  *rate_n_flags = *rate_n_flags | (u32 )((int )new_ant_type << 14);
  return (1);
}
}
static bool rs_use_green(struct ieee80211_sta *sta ) 
{ 


  {
  return (0);
}
}
static u16 rs_get_supported_rates(struct iwl_lq_sta *lq_sta , struct ieee80211_hdr *hdr ,
                                  enum iwl_table_type rate_type ) 
{ 


  {
  if ((unsigned int )rate_type == 1U || (unsigned int )rate_type == 2U) {
    return (lq_sta->active_legacy_rate);
  } else
  if ((unsigned int )rate_type == 3U) {
    return (lq_sta->active_siso_rate);
  } else
  if ((unsigned int )rate_type == 4U) {
    return (lq_sta->active_mimo2_rate);
  } else {
    return (lq_sta->active_mimo3_rate);
  }
}
}
static u16 rs_get_adjacent_rate(struct iwl_priv *priv , u8 index , u16 rate_mask ,
                                int rate_type ) 
{ 
  u8 high ;
  u8 low ;
  int i ;
  u32 mask ;

  {
  high = 13U;
  low = 13U;
  if (rate_type == 2 || (rate_type != 1 && rate_type != 2)) {
    i = (int )index + -1;
    mask = (u32 )(1 << i);
    goto ldv_53798;
    ldv_53797: ;
    if (((u32 )rate_mask & mask) != 0U) {
      low = (u8 )i;
      goto ldv_53796;
    } else {

    }
    i = i - 1;
    mask = mask >> 1;
    ldv_53798: ;
    if (i >= 0) {
      goto ldv_53797;
    } else {

    }
    ldv_53796: 
    i = (int )index + 1;
    mask = (u32 )(1 << i);
    goto ldv_53801;
    ldv_53800: ;
    if (((u32 )rate_mask & mask) != 0U) {
      high = (u8 )i;
      goto ldv_53799;
    } else {

    }
    i = i + 1;
    mask = mask << 1;
    ldv_53801: ;
    if (i <= 12) {
      goto ldv_53800;
    } else {

    }
    ldv_53799: ;
    return ((u16 )((int )((short )((int )high << 8)) | (int )((short )low)));
  } else {

  }
  low = index;
  goto ldv_53805;
  ldv_53804: 
  low = iwl_rates[(int )low].prev_rs;
  if ((unsigned int )low == 13U) {
    goto ldv_53802;
  } else {

  }
  if (((int )rate_mask >> (int )low) & 1) {
    goto ldv_53802;
  } else {

  }
  __iwl_dbg(priv->dev, 1048576U, 0, "rs_get_adjacent_rate", "Skipping masked lower rate: %d\n",
            (int )low);
  ldv_53805: ;
  if ((unsigned int )low != 13U) {
    goto ldv_53804;
  } else {

  }
  ldv_53802: 
  high = index;
  goto ldv_53808;
  ldv_53807: 
  high = iwl_rates[(int )high].next_rs;
  if ((unsigned int )high == 13U) {
    goto ldv_53806;
  } else {

  }
  if (((int )rate_mask >> (int )high) & 1) {
    goto ldv_53806;
  } else {

  }
  __iwl_dbg(priv->dev, 1048576U, 0, "rs_get_adjacent_rate", "Skipping masked higher rate: %d\n",
            (int )high);
  ldv_53808: ;
  if ((unsigned int )high != 13U) {
    goto ldv_53807;
  } else {

  }
  ldv_53806: ;
  return ((u16 )((int )((short )((int )high << 8)) | (int )((short )low)));
}
}
static u32 rs_get_lower_rate(struct iwl_lq_sta *lq_sta , struct iwl_scale_tbl_info *tbl ,
                             u8 scale_index , u8 ht_possible ) 
{ 
  s32 low ;
  u16 rate_mask ;
  u16 high_low ;
  u8 switch_to_legacy ;
  u8 is_green ;
  struct iwl_priv *priv ;
  u8 tmp ;
  u32 tmp___0 ;

  {
  switch_to_legacy = 0U;
  is_green = lq_sta->is_green;
  priv = lq_sta->drv;
  if (((unsigned int )tbl->lq_type != 1U && (unsigned int )tbl->lq_type != 2U) && ((unsigned int )ht_possible == 0U || (unsigned int )scale_index == 0U)) {
    switch_to_legacy = 1U;
    scale_index = rs_ht_to_legacy[(int )scale_index];
    if ((unsigned int )lq_sta->band == 1U) {
      tbl->lq_type = 2;
    } else {
      tbl->lq_type = 1;
    }
    tmp = num_of_ant((int )tbl->ant_type);
    if ((unsigned int )tmp > 1U) {
      tbl->ant_type = first_antenna((int )(priv->nvm_data)->valid_tx_ant);
    } else {

    }
    tbl->is_ht40 = 0U;
    tbl->is_SGI = 0U;
    tbl->max_search = 6U;
  } else {

  }
  rate_mask = rs_get_supported_rates(lq_sta, (struct ieee80211_hdr *)0, tbl->lq_type);
  if ((unsigned int )tbl->lq_type == 1U || (unsigned int )tbl->lq_type == 2U) {
    if ((unsigned int )lq_sta->band == 1U) {
      rate_mask = ((int )((unsigned short )lq_sta->supp_rates) << 4U) & (int )rate_mask;
    } else {
      rate_mask = (int )((unsigned short )lq_sta->supp_rates) & (int )rate_mask;
    }
  } else {

  }
  if ((unsigned int )switch_to_legacy != 0U && ((int )rate_mask >> (int )scale_index) & 1) {
    low = (s32 )scale_index;
    goto out;
  } else {

  }
  high_low = rs_get_adjacent_rate(lq_sta->drv, (int )scale_index, (int )rate_mask,
                                  (int )tbl->lq_type);
  low = (int )high_low & 255;
  if (low == 13) {
    low = (s32 )scale_index;
  } else {

  }
  out: 
  tmp___0 = rate_n_flags_from_tbl(lq_sta->drv, tbl, low, (int )is_green);
  return (tmp___0);
}
}
static bool table_type_matches(struct iwl_scale_tbl_info *a , struct iwl_scale_tbl_info *b ) 
{ 


  {
  return ((bool )(((unsigned int )a->lq_type == (unsigned int )b->lq_type && (int )a->ant_type == (int )b->ant_type) && (int )a->is_SGI == (int )b->is_SGI));
}
}
static void rs_bt_update_lq(struct iwl_priv *priv , struct iwl_rxon_context *ctx ,
                            struct iwl_lq_sta *lq_sta ) 
{ 
  struct iwl_scale_tbl_info *tbl ;
  bool full_concurrent ;

  {
  full_concurrent = priv->bt_full_concurrent;
  if ((int )priv->bt_ant_couple_ok) {
    if ((unsigned int )priv->bt_ci_compliance != 0U && (int )priv->bt_ant_couple_ok) {
      full_concurrent = 1;
    } else {
      full_concurrent = 0;
    }
  } else {

  }
  if ((int )priv->bt_traffic_load != (int )priv->last_bt_traffic_load || (int )priv->bt_full_concurrent != (int )full_concurrent) {
    priv->bt_full_concurrent = full_concurrent;
    priv->last_bt_traffic_load = priv->bt_traffic_load;
    tbl = (struct iwl_scale_tbl_info *)(& lq_sta->lq_info) + (unsigned long )lq_sta->active_tbl;
    rs_fill_link_cmd(priv, lq_sta, tbl->current_rate);
    iwl_send_lq_cmd(priv, ctx, & lq_sta->lq, 1, 0);
    queue_work___0(priv->workqueue, & priv->bt_full_concurrency);
  } else {

  }
  return;
}
}
static void rs_tx_status(void *priv_r , struct ieee80211_supported_band *sband , struct ieee80211_sta *sta ,
                         void *priv_sta , struct sk_buff *skb ) 
{ 
  int legacy_success ;
    klee_make_symbolic(&legacy_success, sizeof(int), "legacy_success");
  int retries ;
    klee_make_symbolic(&retries, sizeof(int), "retries");
  int rs_index ;
    klee_make_symbolic(&rs_index, sizeof(int), "rs_index");
  int mac_index ;
    klee_make_symbolic(&mac_index, sizeof(int), "mac_index");
  int i ;
  struct iwl_lq_sta *lq_sta ;
  struct iwl_link_quality_cmd *table ;
  struct ieee80211_hdr *hdr ;
  struct iwl_op_mode *op_mode ;
  struct iwl_priv *priv ;
  struct ieee80211_tx_info *info ;
  struct ieee80211_tx_info *tmp ;
  enum mac80211_rate_control_flags mac_flags ;
  u32 tx_rate ;
  struct iwl_scale_tbl_info tbl_type ;
  struct iwl_scale_tbl_info *curr_tbl ;
  struct iwl_scale_tbl_info *other_tbl ;
  struct iwl_scale_tbl_info *tmp_tbl ;
  struct iwl_station_priv *sta_priv ;
  struct iwl_rxon_context *ctx ;
  int tmp___0 ;
  bool tmp___1 ;
  bool tmp___2 ;
  int _min1 ;
    klee_make_symbolic(&_min1, sizeof(int), "_min1");
  int _min2 ;
    klee_make_symbolic(&_min2, sizeof(int), "_min2");
  bool tmp___3 ;
  bool tmp___4 ;

  {
  lq_sta = (struct iwl_lq_sta *)priv_sta;
  hdr = (struct ieee80211_hdr *)skb->data;
  op_mode = (struct iwl_op_mode *)priv_r;
  priv = (struct iwl_priv *)(& op_mode->op_mode_specific);
  tmp = IEEE80211_SKB_CB(skb);
  info = tmp;
  sta_priv = (struct iwl_station_priv *)(& sta->drv_priv);
  ctx = sta_priv->ctx;
  __iwl_dbg(priv->dev, 1048576U, 1, "rs_tx_status", "get frame ack response, update rate scale window\n");
  if ((unsigned long )lq_sta == (unsigned long )((struct iwl_lq_sta *)0)) {
    __iwl_dbg(priv->dev, 1048576U, 0, "rs_tx_status", "Station rate scaling not created yet.\n");
    return;
  } else
  if ((unsigned long )lq_sta->drv == (unsigned long )((struct iwl_priv *)0)) {
    __iwl_dbg(priv->dev, 1048576U, 0, "rs_tx_status", "Rate scaling not initialized yet.\n");
    return;
  } else {

  }
  tmp___0 = ieee80211_is_data((int )hdr->frame_control);
  if (tmp___0 == 0 || (info->flags & 4U) != 0U) {
    return;
  } else {

  }
  if ((info->flags & 64U) != 0U && (info->flags & 1024U) == 0U) {
    return;
  } else {

  }
  table = & lq_sta->lq;
  tx_rate = table->rs_table[0].rate_n_flags;
  rs_get_tbl_info_from_mcs(tx_rate, priv->band, & tbl_type, & rs_index);
  if ((unsigned int )priv->band == 1U) {
    rs_index = rs_index + -4;
  } else {

  }
  mac_flags = (enum mac80211_rate_control_flags )info->__annonCompField99.status.rates[0].flags;
  mac_index = (int )info->__annonCompField99.status.rates[0].idx;
  if (((unsigned int )mac_flags & 8U) != 0U) {
    mac_index = mac_index & 7;
    if (mac_index > 0) {
      mac_index = mac_index + 1;
    } else {

    }
    if ((unsigned int )priv->band == 0U) {
      mac_index = mac_index + 4;
    } else {

    }
  } else {

  }
  if (((((((mac_index < 0 || (int )tbl_type.is_SGI != (((unsigned int )mac_flags & 128U) != 0U)) || (int )tbl_type.is_ht40 != (((unsigned int )mac_flags & 32U) != 0U)) || (int )tbl_type.is_dup != (((unsigned int )mac_flags & 64U) != 0U)) || (int )tbl_type.ant_type != (int )info->__annonCompField99.status.antenna) || ((tx_rate & 256U) != 0U) ^ (((unsigned int )mac_flags & 8U) != 0U)) || ((tx_rate & 1024U) != 0U) ^ (((unsigned int )mac_flags & 16U) != 0U)) || rs_index != mac_index) {
    __iwl_dbg(priv->dev, 1048576U, 0, "rs_tx_status", "initial rate %d does not match %d (0x%x)\n",
              mac_index, rs_index, tx_rate);
    lq_sta->missed_rate_counter = (u8 )((int )lq_sta->missed_rate_counter + 1);
    if ((unsigned int )lq_sta->missed_rate_counter > 15U) {
      lq_sta->missed_rate_counter = 0U;
      iwl_send_lq_cmd(priv, ctx, & lq_sta->lq, 1, 0);
    } else {

    }
    return;
  } else {
    lq_sta->missed_rate_counter = 0U;
  }
  tmp___2 = table_type_matches(& tbl_type, (struct iwl_scale_tbl_info *)(& lq_sta->lq_info) + (unsigned long )lq_sta->active_tbl);
  if ((int )tmp___2) {
    curr_tbl = (struct iwl_scale_tbl_info *)(& lq_sta->lq_info) + (unsigned long )lq_sta->active_tbl;
    other_tbl = (struct iwl_scale_tbl_info *)(& lq_sta->lq_info) + (unsigned long )(1 - (int )lq_sta->active_tbl);
  } else {
    tmp___1 = table_type_matches(& tbl_type, (struct iwl_scale_tbl_info *)(& lq_sta->lq_info) + (unsigned long )(1 - (int )lq_sta->active_tbl));
    if ((int )tmp___1) {
      curr_tbl = (struct iwl_scale_tbl_info *)(& lq_sta->lq_info) + (unsigned long )(1 - (int )lq_sta->active_tbl);
      other_tbl = (struct iwl_scale_tbl_info *)(& lq_sta->lq_info) + (unsigned long )lq_sta->active_tbl;
    } else {
      __iwl_dbg(priv->dev, 1048576U, 0, "rs_tx_status", "Neither active nor search matches tx rate\n");
      tmp_tbl = (struct iwl_scale_tbl_info *)(& lq_sta->lq_info) + (unsigned long )lq_sta->active_tbl;
      __iwl_dbg(priv->dev, 1048576U, 0, "rs_tx_status", "active- lq:%x, ant:%x, SGI:%d\n",
                (unsigned int )tmp_tbl->lq_type, (int )tmp_tbl->ant_type, (int )tmp_tbl->is_SGI);
      tmp_tbl = (struct iwl_scale_tbl_info *)(& lq_sta->lq_info) + (unsigned long )(1 - (int )lq_sta->active_tbl);
      __iwl_dbg(priv->dev, 1048576U, 0, "rs_tx_status", "search- lq:%x, ant:%x, SGI:%d\n",
                (unsigned int )tmp_tbl->lq_type, (int )tmp_tbl->ant_type, (int )tmp_tbl->is_SGI);
      __iwl_dbg(priv->dev, 1048576U, 0, "rs_tx_status", "actual- lq:%x, ant:%x, SGI:%d\n",
                (unsigned int )tbl_type.lq_type, (int )tbl_type.ant_type, (int )tbl_type.is_SGI);
      rs_stay_in_table(lq_sta, 1);
      goto done;
    }
  }
  if ((info->flags & 1024U) != 0U) {
    tx_rate = table->rs_table[0].rate_n_flags;
    rs_get_tbl_info_from_mcs(tx_rate, priv->band, & tbl_type, & rs_index);
    rs_collect_tx_data(curr_tbl, rs_index, (int )info->__annonCompField99.status.ampdu_len,
                       (int )info->__annonCompField99.status.ampdu_ack_len);
    if ((unsigned int )lq_sta->stay_in_tbl != 0U) {
      lq_sta->total_success = lq_sta->total_success + (u32 )info->__annonCompField99.status.ampdu_ack_len;
      lq_sta->total_failed = lq_sta->total_failed + (u32 )((int )info->__annonCompField99.status.ampdu_len - (int )info->__annonCompField99.status.ampdu_ack_len);
    } else {

    }
  } else {
    retries = (int )info->__annonCompField99.status.rates[0].count + -1;
    _min1 = retries;
    _min2 = 15;
    retries = _min1 < _min2 ? _min1 : _min2;
    legacy_success = (info->flags & 512U) != 0U;
    i = 0;
    goto ldv_53866;
    ldv_53865: 
    tx_rate = table->rs_table[i].rate_n_flags;
    rs_get_tbl_info_from_mcs(tx_rate, priv->band, & tbl_type, & rs_index);
    tmp___4 = table_type_matches(& tbl_type, curr_tbl);
    if ((int )tmp___4) {
      tmp_tbl = curr_tbl;
    } else {
      tmp___3 = table_type_matches(& tbl_type, other_tbl);
      if ((int )tmp___3) {
        tmp_tbl = other_tbl;
      } else {
        goto ldv_53864;
      }
    }
    rs_collect_tx_data(tmp_tbl, rs_index, 1, i >= retries ? legacy_success : 0);
    ldv_53864: 
    i = i + 1;
    ldv_53866: ;
    if (i <= retries) {
      goto ldv_53865;
    } else {

    }

    if ((unsigned int )lq_sta->stay_in_tbl != 0U) {
      lq_sta->total_success = lq_sta->total_success + (u32 )legacy_success;
      lq_sta->total_failed = lq_sta->total_failed + (u32 )((1 - legacy_success) + retries);
    } else {

    }
  }
  lq_sta->last_rate_n_flags = tx_rate;
  done: ;
  if ((unsigned long )sta != (unsigned long )((struct ieee80211_sta *)0) && sta->supp_rates[(unsigned int )sband->band] != 0U) {
    rs_rate_scale_perform(priv, skb, sta, lq_sta);
  } else {

  }
  if ((unsigned long )(priv->lib)->bt_params != (unsigned long )((struct iwl_dvm_bt_params  const  */* const  */)0) && (int )((priv->lib)->bt_params)->advanced_bt_coexist) {
    rs_bt_update_lq(priv, ctx, lq_sta);
  } else {

  }
  return;
}
}
static void rs_set_stay_in_table(struct iwl_priv *priv , u8 is_legacy , struct iwl_lq_sta *lq_sta ) 
{ 


  {
  __iwl_dbg(priv->dev, 1048576U, 0, "rs_set_stay_in_table", "we are staying in the same table\n");
  lq_sta->stay_in_tbl = 1U;
  if ((unsigned int )is_legacy != 0U) {
    lq_sta->table_count_limit = 160U;
    lq_sta->max_failure_limit = 160U;
    lq_sta->max_success_limit = 480U;
  } else {
    lq_sta->table_count_limit = 1500U;
    lq_sta->max_failure_limit = 400U;
    lq_sta->max_success_limit = 4500U;
  }
  lq_sta->table_count = 0U;
  lq_sta->total_failed = 0U;
  lq_sta->total_success = 0U;
  lq_sta->flush_timer = (u64 )jiffies;
  lq_sta->action_counter = 0U;
  return;
}
}
static void rs_set_expected_tpt_table(struct iwl_lq_sta *lq_sta , struct iwl_scale_tbl_info *tbl ) 
{ 
  u16 const   (*ht_tbl_pointer)[13U] ;
  bool __warned ;
  int __ret_warn_once ;
  int __ret_warn_on ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;

  {
  __ret_warn_once = ((unsigned int )tbl->lq_type != 1U && (unsigned int )tbl->lq_type != 2U) && ((unsigned int )tbl->lq_type != 3U && ((unsigned int )tbl->lq_type != 4U && (unsigned int )tbl->lq_type != 5U));
  tmp___1 = ldv__builtin_expect(__ret_warn_once != 0, 0L);
  if (tmp___1 != 0L) {
    __ret_warn_on = ! __warned;
    tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
    if (tmp != 0L) {
      warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/08_1a/drivers/net/wireless/iwlwifi/dvm/rs.c",
                         1117);
    } else {

    }
    tmp___0 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
    if (tmp___0 != 0L) {
      __warned = 1;
    } else {

    }
  } else {

  }
  tmp___2 = ldv__builtin_expect(__ret_warn_once != 0, 0L);
  if (tmp___2 != 0L) {
    tbl->expected_tpt = (u16 const   *)(& expected_tpt_legacy);
    return;
  } else {

  }
  if ((unsigned int )tbl->lq_type == 1U || (unsigned int )tbl->lq_type == 2U) {
    tbl->expected_tpt = (u16 const   *)(& expected_tpt_legacy);
    return;
  } else {

  }
  if ((unsigned int )tbl->lq_type == 3U && ((unsigned int )tbl->is_ht40 == 0U || (unsigned int )lq_sta->is_dup != 0U)) {
    ht_tbl_pointer = (u16 const   (*)[13])(& expected_tpt_siso20MHz);
  } else
  if ((unsigned int )tbl->lq_type == 3U) {
    ht_tbl_pointer = (u16 const   (*)[13])(& expected_tpt_siso40MHz);
  } else
  if ((unsigned int )tbl->lq_type == 4U && ((unsigned int )tbl->is_ht40 == 0U || (unsigned int )lq_sta->is_dup != 0U)) {
    ht_tbl_pointer = (u16 const   (*)[13])(& expected_tpt_mimo2_20MHz);
  } else
  if ((unsigned int )tbl->lq_type == 4U) {
    ht_tbl_pointer = (u16 const   (*)[13])(& expected_tpt_mimo2_40MHz);
  } else
  if ((unsigned int )tbl->lq_type == 5U && ((unsigned int )tbl->is_ht40 == 0U || (unsigned int )lq_sta->is_dup != 0U)) {
    ht_tbl_pointer = (u16 const   (*)[13])(& expected_tpt_mimo3_20MHz);
  } else {
    ht_tbl_pointer = (u16 const   (*)[13])(& expected_tpt_mimo3_40MHz);
  }
  if ((unsigned int )tbl->is_SGI == 0U && (unsigned int )lq_sta->is_agg == 0U) {
    tbl->expected_tpt = (u16 const   *)ht_tbl_pointer;
  } else
  if ((unsigned int )tbl->is_SGI != 0U && (unsigned int )lq_sta->is_agg == 0U) {
    tbl->expected_tpt = (u16 const   *)ht_tbl_pointer + 1U;
  } else
  if ((unsigned int )tbl->is_SGI == 0U && (unsigned int )lq_sta->is_agg != 0U) {
    tbl->expected_tpt = (u16 const   *)ht_tbl_pointer + 2U;
  } else {
    tbl->expected_tpt = (u16 const   *)ht_tbl_pointer + 3U;
  }
  return;
}
}
static s32 rs_get_best_rate(struct iwl_priv *priv , struct iwl_lq_sta *lq_sta , struct iwl_scale_tbl_info *tbl ,
                            u16 rate_mask , s8 index ) 
{ 
  struct iwl_scale_tbl_info *active_tbl ;
  s32 active_sr ;
  s32 active_tpt ;
  u16 const   *tpt_tbl ;
  s32 new_rate ;
  s32 high ;
  s32 low ;
  s32 start_hi ;
  u16 high_low ;
  s8 rate ;

  {
  active_tbl = (struct iwl_scale_tbl_info *)(& lq_sta->lq_info) + (unsigned long )lq_sta->active_tbl;
  active_sr = active_tbl->win[(int )index].success_ratio;
  active_tpt = (s32 )*(active_tbl->expected_tpt + (unsigned long )index);
  tpt_tbl = tbl->expected_tpt;
  rate = index;
  start_hi = 13;
  low = start_hi;
  high = low;
  new_rate = high;
  ldv_53902: 
  high_low = rs_get_adjacent_rate(priv, (int )((u8 )rate), (int )rate_mask, (int )tbl->lq_type);
  low = (int )high_low & 255;
  high = ((int )high_low >> 8) & 255;
  if (((int )*(tpt_tbl + (unsigned long )rate) * 100 > lq_sta->last_tpt && ((active_sr > 1920 && active_sr <= 10880) && (s32 )*(tpt_tbl + (unsigned long )rate) <= active_tpt)) || (active_sr > 10879 && (s32 )*(tpt_tbl + (unsigned long )rate) > active_tpt)) {
    if (start_hi != 13) {
      new_rate = start_hi;
      goto ldv_53901;
    } else {

    }
    new_rate = (s32 )rate;
    if (low != 13) {
      rate = (s8 )low;
    } else {
      goto ldv_53901;
    }
  } else
  if (new_rate != 13) {
    goto ldv_53901;
  } else
  if (high != 13) {
    start_hi = high;
    rate = (s8 )high;
  } else {
    new_rate = (s32 )rate;
    goto ldv_53901;
  }
  goto ldv_53902;
  ldv_53901: ;
  return (new_rate);
}
}
static int rs_switch_to_mimo2(struct iwl_priv *priv , struct iwl_lq_sta *lq_sta ,
                              struct ieee80211_conf *conf , struct ieee80211_sta *sta ,
                              struct iwl_scale_tbl_info *tbl , int index ) 
{ 
  u16 rate_mask ;
  s32 rate ;
  s8 is_green ;
  struct iwl_station_priv *sta_priv ;
  struct iwl_rxon_context *ctx ;
  bool tmp ;
  int tmp___0 ;
  bool tmp___1 ;

  {
  is_green = (s8 )lq_sta->is_green;
  sta_priv = (struct iwl_station_priv *)(& sta->drv_priv);
  ctx = sta_priv->ctx;
  tmp = conf_is_ht(conf);
  if (tmp) {
    tmp___0 = 0;
  } else {
    tmp___0 = 1;
  }
  if (tmp___0 || ! sta->ht_cap.ht_supported) {
    return (-1);
  } else {

  }
  if ((unsigned int )sta->smps_mode == 2U) {
    return (-1);
  } else {

  }
  if ((unsigned int )priv->hw_params.tx_chains_num <= 1U) {
    return (-1);
  } else {

  }
  __iwl_dbg(priv->dev, 1048576U, 0, "rs_switch_to_mimo2", "LQ: try to switch to MIMO2\n");
  tbl->lq_type = 4;
  tbl->is_dup = lq_sta->is_dup;
  tbl->action = 0U;
  tbl->max_search = 6U;
  rate_mask = lq_sta->active_mimo2_rate;
  tmp___1 = iwl_is_ht40_tx_allowed(priv, ctx, sta);
  if ((int )tmp___1) {
    tbl->is_ht40 = 1U;
  } else {
    tbl->is_ht40 = 0U;
  }
  rs_set_expected_tpt_table(lq_sta, tbl);
  rate = rs_get_best_rate(priv, lq_sta, tbl, (int )rate_mask, (int )((s8 )index));
  __iwl_dbg(priv->dev, 1048576U, 0, "rs_switch_to_mimo2", "LQ: MIMO2 best rate %d mask %X\n",
            rate, (int )rate_mask);
  if (rate == 13 || (((int )rate_mask >> rate) & 1) == 0) {
    __iwl_dbg(priv->dev, 1048576U, 0, "rs_switch_to_mimo2", "Can\'t switch with index %d rate mask %x\n",
              rate, (int )rate_mask);
    return (-1);
  } else {

  }
  tbl->current_rate = rate_n_flags_from_tbl(priv, tbl, rate, (int )((u8 )is_green));
  __iwl_dbg(priv->dev, 1048576U, 0, "rs_switch_to_mimo2", "LQ: Switch to new mcs %X index is green %X\n",
            tbl->current_rate, (int )is_green);
  return (0);
}
}
static int rs_switch_to_mimo3(struct iwl_priv *priv , struct iwl_lq_sta *lq_sta ,
                              struct ieee80211_conf *conf , struct ieee80211_sta *sta ,
                              struct iwl_scale_tbl_info *tbl , int index ) 
{ 
  u16 rate_mask ;
  s32 rate ;
  s8 is_green ;
  struct iwl_station_priv *sta_priv ;
  struct iwl_rxon_context *ctx ;
  bool tmp ;
  int tmp___0 ;
  bool tmp___1 ;

  {
  is_green = (s8 )lq_sta->is_green;
  sta_priv = (struct iwl_station_priv *)(& sta->drv_priv);
  ctx = sta_priv->ctx;
  tmp = conf_is_ht(conf);
  if (tmp) {
    tmp___0 = 0;
  } else {
    tmp___0 = 1;
  }
  if (tmp___0 || ! sta->ht_cap.ht_supported) {
    return (-1);
  } else {

  }
  if ((unsigned int )sta->smps_mode == 2U) {
    return (-1);
  } else {

  }
  if ((unsigned int )priv->hw_params.tx_chains_num <= 2U) {
    return (-1);
  } else {

  }
  __iwl_dbg(priv->dev, 1048576U, 0, "rs_switch_to_mimo3", "LQ: try to switch to MIMO3\n");
  tbl->lq_type = 5;
  tbl->is_dup = lq_sta->is_dup;
  tbl->action = 0U;
  tbl->max_search = 8U;
  rate_mask = lq_sta->active_mimo3_rate;
  tmp___1 = iwl_is_ht40_tx_allowed(priv, ctx, sta);
  if ((int )tmp___1) {
    tbl->is_ht40 = 1U;
  } else {
    tbl->is_ht40 = 0U;
  }
  rs_set_expected_tpt_table(lq_sta, tbl);
  rate = rs_get_best_rate(priv, lq_sta, tbl, (int )rate_mask, (int )((s8 )index));
  __iwl_dbg(priv->dev, 1048576U, 0, "rs_switch_to_mimo3", "LQ: MIMO3 best rate %d mask %X\n",
            rate, (int )rate_mask);
  if (rate == 13 || (((int )rate_mask >> rate) & 1) == 0) {
    __iwl_dbg(priv->dev, 1048576U, 0, "rs_switch_to_mimo3", "Can\'t switch with index %d rate mask %x\n",
              rate, (int )rate_mask);
    return (-1);
  } else {

  }
  tbl->current_rate = rate_n_flags_from_tbl(priv, tbl, rate, (int )((u8 )is_green));
  __iwl_dbg(priv->dev, 1048576U, 0, "rs_switch_to_mimo3", "LQ: Switch to new mcs %X index is green %X\n",
            tbl->current_rate, (int )is_green);
  return (0);
}
}
static int rs_switch_to_siso(struct iwl_priv *priv , struct iwl_lq_sta *lq_sta , struct ieee80211_conf *conf ,
                             struct ieee80211_sta *sta , struct iwl_scale_tbl_info *tbl ,
                             int index ) 
{ 
  u16 rate_mask ;
  u8 is_green ;
  s32 rate ;
  struct iwl_station_priv *sta_priv ;
  struct iwl_rxon_context *ctx ;
  bool tmp ;
  int tmp___0 ;
  bool tmp___1 ;

  {
  is_green = lq_sta->is_green;
  sta_priv = (struct iwl_station_priv *)(& sta->drv_priv);
  ctx = sta_priv->ctx;
  tmp = conf_is_ht(conf);
  if (tmp) {
    tmp___0 = 0;
  } else {
    tmp___0 = 1;
  }
  if (tmp___0 || ! sta->ht_cap.ht_supported) {
    return (-1);
  } else {

  }
  __iwl_dbg(priv->dev, 1048576U, 0, "rs_switch_to_siso", "LQ: try to switch to SISO\n");
  tbl->is_dup = lq_sta->is_dup;
  tbl->lq_type = 3;
  tbl->action = 0U;
  tbl->max_search = 6U;
  rate_mask = lq_sta->active_siso_rate;
  tmp___1 = iwl_is_ht40_tx_allowed(priv, ctx, sta);
  if ((int )tmp___1) {
    tbl->is_ht40 = 1U;
  } else {
    tbl->is_ht40 = 0U;
  }
  if ((unsigned int )is_green != 0U) {
    tbl->is_SGI = 0U;
  } else {

  }
  rs_set_expected_tpt_table(lq_sta, tbl);
  rate = rs_get_best_rate(priv, lq_sta, tbl, (int )rate_mask, (int )((s8 )index));
  __iwl_dbg(priv->dev, 1048576U, 0, "rs_switch_to_siso", "LQ: get best rate %d mask %X\n",
            rate, (int )rate_mask);
  if (rate == 13 || (((int )rate_mask >> rate) & 1) == 0) {
    __iwl_dbg(priv->dev, 1048576U, 0, "rs_switch_to_siso", "can not switch with index %d rate mask %x\n",
              rate, (int )rate_mask);
    return (-1);
  } else {

  }
  tbl->current_rate = rate_n_flags_from_tbl(priv, tbl, rate, (int )is_green);
  __iwl_dbg(priv->dev, 1048576U, 0, "rs_switch_to_siso", "LQ: Switch to new mcs %X index is green %X\n",
            tbl->current_rate, (int )is_green);
  return (0);
}
}
static int rs_move_legacy_other(struct iwl_priv *priv , struct iwl_lq_sta *lq_sta ,
                                struct ieee80211_conf *conf , struct ieee80211_sta *sta ,
                                int index ) 
{ 
  struct iwl_scale_tbl_info *tbl ;
  struct iwl_scale_tbl_info *search_tbl ;
  struct iwl_rate_scale_data *window ;
  u32 sz ;
  u8 start_action ;
  u8 valid_tx_ant ;
  u8 tx_chains_num ;
  int ret ;
  u8 update_search_tbl_counter ;
  enum iwl_antenna_ok tmp ;
  bool tmp___0 ;
  int tmp___1 ;
  bool tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  u8 tmp___5 ;
  u8 tmp___6 ;

  {
  tbl = (struct iwl_scale_tbl_info *)(& lq_sta->lq_info) + (unsigned long )lq_sta->active_tbl;
  search_tbl = (struct iwl_scale_tbl_info *)(& lq_sta->lq_info) + (unsigned long )(1 - (int )lq_sta->active_tbl);
  window = (struct iwl_rate_scale_data *)(& tbl->win) + (unsigned long )index;
  sz = 32U;
  valid_tx_ant = (priv->nvm_data)->valid_tx_ant;
  tx_chains_num = priv->hw_params.tx_chains_num;
  ret = 0;
  update_search_tbl_counter = 0U;
  switch ((int )priv->bt_traffic_load) {
  case 0: ;
  goto ldv_53962;
  case 1: ;
  if ((unsigned int )tbl->action == 1U) {
    tbl->action = 2U;
  } else {

  }
  goto ldv_53962;
  case 2: ;
  case 3: 
  valid_tx_ant = first_antenna((int )(priv->nvm_data)->valid_tx_ant);
  if ((unsigned int )tbl->action != 0U && (unsigned int )tbl->action != 2U) {
    tbl->action = 2U;
  } else {

  }
  goto ldv_53962;
  default: 
  __iwl_err(priv->dev, 0, 0, "Invalid BT load %d\n", (int )priv->bt_traffic_load);
  goto ldv_53962;
  }
  ldv_53962: 
  tmp___0 = iwl_ht_enabled(priv);
  if (tmp___0) {
    tmp___1 = 0;
  } else {
    tmp___1 = 1;
  }
  if (tmp___1) {
    tbl->action = 0U;
  } else {
    tmp = iwl_tx_ant_restriction(priv);
    if ((unsigned int )tmp == 1U && (unsigned int )tbl->action > 2U) {
      tbl->action = 2U;
    } else {

    }
  }
  if ((int )priv->bt_full_concurrent) {
    tmp___2 = iwl_ht_enabled(priv);
    if (tmp___2) {
      tmp___3 = 0;
    } else {
      tmp___3 = 1;
    }
    if (tmp___3) {
      tbl->action = 0U;
    } else
    if ((unsigned int )tbl->action != 0U) {
      tbl->action = 2U;
    } else {

    }
    valid_tx_ant = first_antenna((int )(priv->nvm_data)->valid_tx_ant);
  } else {

  }
  start_action = tbl->action;
  ldv_53978: 
  lq_sta->action_counter = (u8 )((int )lq_sta->action_counter + 1);
  switch ((int )tbl->action) {
  case 0: ;
  case 1: 
  __iwl_dbg(priv->dev, 1048576U, 0, "rs_move_legacy_other", "LQ: Legacy toggle Antenna\n");
  if (((unsigned int )tbl->action == 0U && (unsigned int )tx_chains_num <= 1U) || ((unsigned int )tbl->action == 1U && (unsigned int )tx_chains_num <= 2U)) {
    goto ldv_53970;
  } else {

  }
  if ((window->success_ratio > 12799 && ! priv->bt_full_concurrent) && (unsigned int )priv->bt_traffic_load == 0U) {
    goto ldv_53970;
  } else {

  }
  memcpy((void *)search_tbl, (void const   *)tbl, (size_t )sz);
  tmp___4 = rs_toggle_antenna((u32 )valid_tx_ant, & search_tbl->current_rate, search_tbl);
  if (tmp___4 != 0) {
    update_search_tbl_counter = 1U;
    rs_set_expected_tpt_table(lq_sta, search_tbl);
    goto out;
  } else {

  }
  goto ldv_53970;
  case 2: 
  __iwl_dbg(priv->dev, 1048576U, 0, "rs_move_legacy_other", "LQ: Legacy switch to SISO\n");
  memcpy((void *)search_tbl, (void const   *)tbl, (size_t )sz);
  search_tbl->is_SGI = 0U;
  ret = rs_switch_to_siso(priv, lq_sta, conf, sta, search_tbl, index);
  if (ret == 0) {
    lq_sta->action_counter = 0U;
    goto out;
  } else {

  }
  goto ldv_53970;
  case 3: ;
  case 4: ;
  case 5: 
  __iwl_dbg(priv->dev, 1048576U, 0, "rs_move_legacy_other", "LQ: Legacy switch to MIMO2\n");
  memcpy((void *)search_tbl, (void const   *)tbl, (size_t )sz);
  search_tbl->is_SGI = 0U;
  if ((unsigned int )tbl->action == 3U) {
    search_tbl->ant_type = 3U;
  } else
  if ((unsigned int )tbl->action == 4U) {
    search_tbl->ant_type = 5U;
  } else {
    search_tbl->ant_type = 6U;
  }
  tmp___5 = rs_is_valid_ant((int )valid_tx_ant, (int )search_tbl->ant_type);
  if ((unsigned int )tmp___5 == 0U) {
    goto ldv_53970;
  } else {

  }
  ret = rs_switch_to_mimo2(priv, lq_sta, conf, sta, search_tbl, index);
  if (ret == 0) {
    lq_sta->action_counter = 0U;
    goto out;
  } else {

  }
  goto ldv_53970;
  case 6: 
  __iwl_dbg(priv->dev, 1048576U, 0, "rs_move_legacy_other", "LQ: Legacy switch to MIMO3\n");
  memcpy((void *)search_tbl, (void const   *)tbl, (size_t )sz);
  search_tbl->is_SGI = 0U;
  search_tbl->ant_type = 7U;
  tmp___6 = rs_is_valid_ant((int )valid_tx_ant, (int )search_tbl->ant_type);
  if ((unsigned int )tmp___6 == 0U) {
    goto ldv_53970;
  } else {

  }
  ret = rs_switch_to_mimo3(priv, lq_sta, conf, sta, search_tbl, index);
  if (ret == 0) {
    lq_sta->action_counter = 0U;
    goto out;
  } else {

  }
  goto ldv_53970;
  }
  ldv_53970: 
  tbl->action = (u8 )((int )tbl->action + 1);
  if ((unsigned int )tbl->action > 6U) {
    tbl->action = 0U;
  } else {

  }
  if ((int )tbl->action == (int )start_action) {
    goto ldv_53977;
  } else {

  }
  goto ldv_53978;
  ldv_53977: 
  search_tbl->lq_type = 0;
  return (0);
  out: 
  lq_sta->search_better_tbl = 1U;
  tbl->action = (u8 )((int )tbl->action + 1);
  if ((unsigned int )tbl->action > 6U) {
    tbl->action = 0U;
  } else {

  }
  if ((unsigned int )update_search_tbl_counter != 0U) {
    search_tbl->action = tbl->action;
  } else {

  }
  return (0);
}
}
static int rs_move_siso_to_other(struct iwl_priv *priv , struct iwl_lq_sta *lq_sta ,
                                 struct ieee80211_conf *conf , struct ieee80211_sta *sta ,
                                 int index ) 
{ 
  u8 is_green ;
  struct iwl_scale_tbl_info *tbl ;
  struct iwl_scale_tbl_info *search_tbl ;
  struct iwl_rate_scale_data *window ;
  struct ieee80211_sta_ht_cap *ht_cap ;
  u32 sz ;
  u8 start_action ;
  u8 valid_tx_ant ;
  u8 tx_chains_num ;
  u8 update_search_tbl_counter ;
  int ret ;
  enum iwl_antenna_ok tmp ;
  int tmp___0 ;
  u8 tmp___1 ;
  s32 tpt ;
  u8 tmp___2 ;

  {
  is_green = lq_sta->is_green;
  tbl = (struct iwl_scale_tbl_info *)(& lq_sta->lq_info) + (unsigned long )lq_sta->active_tbl;
  search_tbl = (struct iwl_scale_tbl_info *)(& lq_sta->lq_info) + (unsigned long )(1 - (int )lq_sta->active_tbl);
  window = (struct iwl_rate_scale_data *)(& tbl->win) + (unsigned long )index;
  ht_cap = & sta->ht_cap;
  sz = 32U;
  valid_tx_ant = (priv->nvm_data)->valid_tx_ant;
  tx_chains_num = priv->hw_params.tx_chains_num;
  update_search_tbl_counter = 0U;
  switch ((int )priv->bt_traffic_load) {
  case 0: ;
  goto ldv_53998;
  case 1: ;
  if ((unsigned int )tbl->action == 1U) {
    tbl->action = 2U;
  } else {

  }
  goto ldv_53998;
  case 2: ;
  case 3: 
  valid_tx_ant = first_antenna((int )(priv->nvm_data)->valid_tx_ant);
  if ((unsigned int )tbl->action != 0U) {
    tbl->action = 0U;
  } else {

  }
  goto ldv_53998;
  default: 
  __iwl_err(priv->dev, 0, 0, "Invalid BT load %d\n", (int )priv->bt_traffic_load);
  goto ldv_53998;
  }
  ldv_53998: 
  tmp = iwl_tx_ant_restriction(priv);
  if ((unsigned int )tmp == 1U && (unsigned int )tbl->action > 1U) {
    tbl->action = 0U;
  } else {

  }
  if ((int )priv->bt_full_concurrent) {
    valid_tx_ant = first_antenna((int )(priv->nvm_data)->valid_tx_ant);
    if ((unsigned int )tbl->action != 0U) {
      tbl->action = 0U;
    } else {

    }
  } else {

  }
  start_action = tbl->action;
  ldv_54015: 
  lq_sta->action_counter = (u8 )((int )lq_sta->action_counter + 1);
  switch ((int )tbl->action) {
  case 0: ;
  case 1: 
  __iwl_dbg(priv->dev, 1048576U, 0, "rs_move_siso_to_other", "LQ: SISO toggle Antenna\n");
  if (((unsigned int )tbl->action == 0U && (unsigned int )tx_chains_num <= 1U) || ((unsigned int )tbl->action == 1U && (unsigned int )tx_chains_num <= 2U)) {
    goto ldv_54006;
  } else {

  }
  if ((window->success_ratio > 12799 && ! priv->bt_full_concurrent) && (unsigned int )priv->bt_traffic_load == 0U) {
    goto ldv_54006;
  } else {

  }
  memcpy((void *)search_tbl, (void const   *)tbl, (size_t )sz);
  tmp___0 = rs_toggle_antenna((u32 )valid_tx_ant, & search_tbl->current_rate, search_tbl);
  if (tmp___0 != 0) {
    update_search_tbl_counter = 1U;
    goto out;
  } else {

  }
  goto ldv_54006;
  case 2: ;
  case 3: ;
  case 4: 
  __iwl_dbg(priv->dev, 1048576U, 0, "rs_move_siso_to_other", "LQ: SISO switch to MIMO2\n");
  memcpy((void *)search_tbl, (void const   *)tbl, (size_t )sz);
  search_tbl->is_SGI = 0U;
  if ((unsigned int )tbl->action == 2U) {
    search_tbl->ant_type = 3U;
  } else
  if ((unsigned int )tbl->action == 3U) {
    search_tbl->ant_type = 5U;
  } else {
    search_tbl->ant_type = 6U;
  }
  tmp___1 = rs_is_valid_ant((int )valid_tx_ant, (int )search_tbl->ant_type);
  if ((unsigned int )tmp___1 == 0U) {
    goto ldv_54006;
  } else {

  }
  ret = rs_switch_to_mimo2(priv, lq_sta, conf, sta, search_tbl, index);
  if (ret == 0) {
    goto out;
  } else {

  }
  goto ldv_54006;
  case 5: ;
  if ((unsigned int )tbl->is_ht40 == 0U && ((int )ht_cap->cap & 32) == 0) {
    goto ldv_54006;
  } else {

  }
  if ((unsigned int )tbl->is_ht40 != 0U && ((int )ht_cap->cap & 64) == 0) {
    goto ldv_54006;
  } else {

  }
  __iwl_dbg(priv->dev, 1048576U, 0, "rs_move_siso_to_other", "LQ: SISO toggle SGI/NGI\n");
  memcpy((void *)search_tbl, (void const   *)tbl, (size_t )sz);
  if ((unsigned int )is_green != 0U) {
    if ((unsigned int )tbl->is_SGI == 0U) {
      goto ldv_54006;
    } else {
      __iwl_err(priv->dev, 0, 0, "SGI was set in GF+SISO\n");
    }
  } else {

  }
  search_tbl->is_SGI = (unsigned int )tbl->is_SGI == 0U;
  rs_set_expected_tpt_table(lq_sta, search_tbl);
  if ((unsigned int )tbl->is_SGI != 0U) {
    tpt = lq_sta->last_tpt / 100;
    if ((int )*(search_tbl->expected_tpt + (unsigned long )index) <= tpt) {
      goto ldv_54006;
    } else {

    }
  } else {

  }
  search_tbl->current_rate = rate_n_flags_from_tbl(priv, search_tbl, index, (int )is_green);
  update_search_tbl_counter = 1U;
  goto out;
  case 6: 
  __iwl_dbg(priv->dev, 1048576U, 0, "rs_move_siso_to_other", "LQ: SISO switch to MIMO3\n");
  memcpy((void *)search_tbl, (void const   *)tbl, (size_t )sz);
  search_tbl->is_SGI = 0U;
  search_tbl->ant_type = 7U;
  tmp___2 = rs_is_valid_ant((int )valid_tx_ant, (int )search_tbl->ant_type);
  if ((unsigned int )tmp___2 == 0U) {
    goto ldv_54006;
  } else {

  }
  ret = rs_switch_to_mimo3(priv, lq_sta, conf, sta, search_tbl, index);
  if (ret == 0) {
    goto out;
  } else {

  }
  goto ldv_54006;
  }
  ldv_54006: 
  tbl->action = (u8 )((int )tbl->action + 1);
  if ((unsigned int )tbl->action > 6U) {
    tbl->action = 0U;
  } else {

  }
  if ((int )tbl->action == (int )start_action) {
    goto ldv_54014;
  } else {

  }
  goto ldv_54015;
  ldv_54014: 
  search_tbl->lq_type = 0;
  return (0);
  out: 
  lq_sta->search_better_tbl = 1U;
  tbl->action = (u8 )((int )tbl->action + 1);
  if ((unsigned int )tbl->action > 6U) {
    tbl->action = 0U;
  } else {

  }
  if ((unsigned int )update_search_tbl_counter != 0U) {
    search_tbl->action = tbl->action;
  } else {

  }
  return (0);
}
}
static int rs_move_mimo2_to_other(struct iwl_priv *priv , struct iwl_lq_sta *lq_sta ,
                                  struct ieee80211_conf *conf , struct ieee80211_sta *sta ,
                                  int index ) 
{ 
  s8 is_green ;
  struct iwl_scale_tbl_info *tbl ;
  struct iwl_scale_tbl_info *search_tbl ;
  struct iwl_rate_scale_data *window ;
  struct ieee80211_sta_ht_cap *ht_cap ;
  u32 sz ;
  u8 start_action ;
  u8 valid_tx_ant ;
  u8 tx_chains_num ;
  u8 update_search_tbl_counter ;
  int ret ;
  enum iwl_antenna_ok tmp ;
  int tmp___0 ;
  u8 tmp___1 ;
  s32 tpt ;
  u8 tmp___2 ;

  {
  is_green = (s8 )lq_sta->is_green;
  tbl = (struct iwl_scale_tbl_info *)(& lq_sta->lq_info) + (unsigned long )lq_sta->active_tbl;
  search_tbl = (struct iwl_scale_tbl_info *)(& lq_sta->lq_info) + (unsigned long )(1 - (int )lq_sta->active_tbl);
  window = (struct iwl_rate_scale_data *)(& tbl->win) + (unsigned long )index;
  ht_cap = & sta->ht_cap;
  sz = 32U;
  valid_tx_ant = (priv->nvm_data)->valid_tx_ant;
  tx_chains_num = priv->hw_params.tx_chains_num;
  update_search_tbl_counter = 0U;
  switch ((int )priv->bt_traffic_load) {
  case 0: ;
  goto ldv_54035;
  case 2: ;
  case 3: ;
  if ((unsigned int )tbl->action != 2U) {
    tbl->action = 2U;
  } else {

  }
  goto ldv_54035;
  case 1: ;
  if ((unsigned int )tbl->action == 3U || (unsigned int )tbl->action == 4U) {
    tbl->action = 2U;
  } else {

  }
  goto ldv_54035;
  default: 
  __iwl_err(priv->dev, 0, 0, "Invalid BT load %d\n", (int )priv->bt_traffic_load);
  goto ldv_54035;
  }
  ldv_54035: 
  tmp = iwl_tx_ant_restriction(priv);
  if ((unsigned int )tmp == 1U && ((unsigned int )tbl->action <= 1U || (unsigned int )tbl->action > 4U)) {
    tbl->action = 2U;
  } else {

  }
  if ((int )priv->bt_full_concurrent && ((unsigned int )tbl->action <= 1U || (unsigned int )tbl->action > 4U)) {
    tbl->action = 2U;
  } else {

  }
  start_action = tbl->action;
  ldv_54052: 
  lq_sta->action_counter = (u8 )((int )lq_sta->action_counter + 1);
  switch ((int )tbl->action) {
  case 0: ;
  case 1: 
  __iwl_dbg(priv->dev, 1048576U, 0, "rs_move_mimo2_to_other", "LQ: MIMO2 toggle Antennas\n");
  if ((unsigned int )tx_chains_num <= 2U) {
    goto ldv_54043;
  } else {

  }
  if (window->success_ratio > 12799) {
    goto ldv_54043;
  } else {

  }
  memcpy((void *)search_tbl, (void const   *)tbl, (size_t )sz);
  tmp___0 = rs_toggle_antenna((u32 )valid_tx_ant, & search_tbl->current_rate, search_tbl);
  if (tmp___0 != 0) {
    update_search_tbl_counter = 1U;
    goto out;
  } else {

  }
  goto ldv_54043;
  case 2: ;
  case 3: ;
  case 4: 
  __iwl_dbg(priv->dev, 1048576U, 0, "rs_move_mimo2_to_other", "LQ: MIMO2 switch to SISO\n");
  memcpy((void *)search_tbl, (void const   *)tbl, (size_t )sz);
  if ((unsigned int )tbl->action == 2U) {
    search_tbl->ant_type = 1U;
  } else
  if ((unsigned int )tbl->action == 3U) {
    search_tbl->ant_type = 2U;
  } else {
    search_tbl->ant_type = 4U;
  }
  tmp___1 = rs_is_valid_ant((int )valid_tx_ant, (int )search_tbl->ant_type);
  if ((unsigned int )tmp___1 == 0U) {
    goto ldv_54043;
  } else {

  }
  ret = rs_switch_to_siso(priv, lq_sta, conf, sta, search_tbl, index);
  if (ret == 0) {
    goto out;
  } else {

  }
  goto ldv_54043;
  case 5: ;
  if ((unsigned int )tbl->is_ht40 == 0U && ((int )ht_cap->cap & 32) == 0) {
    goto ldv_54043;
  } else {

  }
  if ((unsigned int )tbl->is_ht40 != 0U && ((int )ht_cap->cap & 64) == 0) {
    goto ldv_54043;
  } else {

  }
  __iwl_dbg(priv->dev, 1048576U, 0, "rs_move_mimo2_to_other", "LQ: MIMO2 toggle SGI/NGI\n");
  memcpy((void *)search_tbl, (void const   *)tbl, (size_t )sz);
  search_tbl->is_SGI = (unsigned int )tbl->is_SGI == 0U;
  rs_set_expected_tpt_table(lq_sta, search_tbl);
  if ((unsigned int )tbl->is_SGI != 0U) {
    tpt = lq_sta->last_tpt / 100;
    if ((int )*(search_tbl->expected_tpt + (unsigned long )index) <= tpt) {
      goto ldv_54043;
    } else {

    }
  } else {

  }
  search_tbl->current_rate = rate_n_flags_from_tbl(priv, search_tbl, index, (int )((u8 )is_green));
  update_search_tbl_counter = 1U;
  goto out;
  case 6: 
  __iwl_dbg(priv->dev, 1048576U, 0, "rs_move_mimo2_to_other", "LQ: MIMO2 switch to MIMO3\n");
  memcpy((void *)search_tbl, (void const   *)tbl, (size_t )sz);
  search_tbl->is_SGI = 0U;
  search_tbl->ant_type = 7U;
  tmp___2 = rs_is_valid_ant((int )valid_tx_ant, (int )search_tbl->ant_type);
  if ((unsigned int )tmp___2 == 0U) {
    goto ldv_54043;
  } else {

  }
  ret = rs_switch_to_mimo3(priv, lq_sta, conf, sta, search_tbl, index);
  if (ret == 0) {
    goto out;
  } else {

  }
  goto ldv_54043;
  }
  ldv_54043: 
  tbl->action = (u8 )((int )tbl->action + 1);
  if ((unsigned int )tbl->action > 6U) {
    tbl->action = 0U;
  } else {

  }
  if ((int )tbl->action == (int )start_action) {
    goto ldv_54051;
  } else {

  }
  goto ldv_54052;
  ldv_54051: 
  search_tbl->lq_type = 0;
  return (0);
  out: 
  lq_sta->search_better_tbl = 1U;
  tbl->action = (u8 )((int )tbl->action + 1);
  if ((unsigned int )tbl->action > 6U) {
    tbl->action = 0U;
  } else {

  }
  if ((unsigned int )update_search_tbl_counter != 0U) {
    search_tbl->action = tbl->action;
  } else {

  }
  return (0);
}
}
static int rs_move_mimo3_to_other(struct iwl_priv *priv , struct iwl_lq_sta *lq_sta ,
                                  struct ieee80211_conf *conf , struct ieee80211_sta *sta ,
                                  int index ) 
{ 
  s8 is_green ;
  struct iwl_scale_tbl_info *tbl ;
  struct iwl_scale_tbl_info *search_tbl ;
  struct iwl_rate_scale_data *window ;
  struct ieee80211_sta_ht_cap *ht_cap ;
  u32 sz ;
  u8 start_action ;
  u8 valid_tx_ant ;
  u8 tx_chains_num ;
  int ret ;
  u8 update_search_tbl_counter ;
  enum iwl_antenna_ok tmp ;
  int tmp___0 ;
  u8 tmp___1 ;
  u8 tmp___2 ;
  s32 tpt ;

  {
  is_green = (s8 )lq_sta->is_green;
  tbl = (struct iwl_scale_tbl_info *)(& lq_sta->lq_info) + (unsigned long )lq_sta->active_tbl;
  search_tbl = (struct iwl_scale_tbl_info *)(& lq_sta->lq_info) + (unsigned long )(1 - (int )lq_sta->active_tbl);
  window = (struct iwl_rate_scale_data *)(& tbl->win) + (unsigned long )index;
  ht_cap = & sta->ht_cap;
  sz = 32U;
  valid_tx_ant = (priv->nvm_data)->valid_tx_ant;
  tx_chains_num = priv->hw_params.tx_chains_num;
  update_search_tbl_counter = 0U;
  switch ((int )priv->bt_traffic_load) {
  case 0: ;
  goto ldv_54072;
  case 2: ;
  case 3: ;
  if ((unsigned int )tbl->action != 2U) {
    tbl->action = 2U;
  } else {

  }
  goto ldv_54072;
  case 1: ;
  if ((unsigned int )tbl->action == 3U || (unsigned int )tbl->action == 4U) {
    tbl->action = 2U;
  } else {

  }
  goto ldv_54072;
  default: 
  __iwl_err(priv->dev, 0, 0, "Invalid BT load %d\n", (int )priv->bt_traffic_load);
  goto ldv_54072;
  }
  ldv_54072: 
  tmp = iwl_tx_ant_restriction(priv);
  if ((unsigned int )tmp == 1U && ((unsigned int )tbl->action <= 1U || (unsigned int )tbl->action > 4U)) {
    tbl->action = 2U;
  } else {

  }
  if ((int )priv->bt_full_concurrent && ((unsigned int )tbl->action <= 1U || (unsigned int )tbl->action > 4U)) {
    tbl->action = 2U;
  } else {

  }
  start_action = tbl->action;
  ldv_54091: 
  lq_sta->action_counter = (u8 )((int )lq_sta->action_counter + 1);
  switch ((int )tbl->action) {
  case 0: ;
  case 1: 
  __iwl_dbg(priv->dev, 1048576U, 0, "rs_move_mimo3_to_other", "LQ: MIMO3 toggle Antennas\n");
  if ((unsigned int )tx_chains_num <= 3U) {
    goto ldv_54080;
  } else {

  }
  if (window->success_ratio > 12799) {
    goto ldv_54080;
  } else {

  }
  memcpy((void *)search_tbl, (void const   *)tbl, (size_t )sz);
  tmp___0 = rs_toggle_antenna((u32 )valid_tx_ant, & search_tbl->current_rate, search_tbl);
  if (tmp___0 != 0) {
    goto out;
  } else {

  }
  goto ldv_54080;
  case 2: ;
  case 3: ;
  case 4: 
  __iwl_dbg(priv->dev, 1048576U, 0, "rs_move_mimo3_to_other", "LQ: MIMO3 switch to SISO\n");
  memcpy((void *)search_tbl, (void const   *)tbl, (size_t )sz);
  if ((unsigned int )tbl->action == 2U) {
    search_tbl->ant_type = 1U;
  } else
  if ((unsigned int )tbl->action == 3U) {
    search_tbl->ant_type = 2U;
  } else {
    search_tbl->ant_type = 4U;
  }
  tmp___1 = rs_is_valid_ant((int )valid_tx_ant, (int )search_tbl->ant_type);
  if ((unsigned int )tmp___1 == 0U) {
    goto ldv_54080;
  } else {

  }
  ret = rs_switch_to_siso(priv, lq_sta, conf, sta, search_tbl, index);
  if (ret == 0) {
    goto out;
  } else {

  }
  goto ldv_54080;
  case 5: ;
  case 6: ;
  case 7: 
  __iwl_dbg(priv->dev, 1048576U, 0, "rs_move_mimo3_to_other", "LQ: MIMO3 switch to MIMO2\n");
  memcpy((void *)search_tbl, (void const   *)tbl, (size_t )sz);
  search_tbl->is_SGI = 0U;
  if ((unsigned int )tbl->action == 5U) {
    search_tbl->ant_type = 3U;
  } else
  if ((unsigned int )tbl->action == 6U) {
    search_tbl->ant_type = 5U;
  } else {
    search_tbl->ant_type = 6U;
  }
  tmp___2 = rs_is_valid_ant((int )valid_tx_ant, (int )search_tbl->ant_type);
  if ((unsigned int )tmp___2 == 0U) {
    goto ldv_54080;
  } else {

  }
  ret = rs_switch_to_mimo2(priv, lq_sta, conf, sta, search_tbl, index);
  if (ret == 0) {
    goto out;
  } else {

  }
  goto ldv_54080;
  case 8: ;
  if ((unsigned int )tbl->is_ht40 == 0U && ((int )ht_cap->cap & 32) == 0) {
    goto ldv_54080;
  } else {

  }
  if ((unsigned int )tbl->is_ht40 != 0U && ((int )ht_cap->cap & 64) == 0) {
    goto ldv_54080;
  } else {

  }
  __iwl_dbg(priv->dev, 1048576U, 0, "rs_move_mimo3_to_other", "LQ: MIMO3 toggle SGI/NGI\n");
  memcpy((void *)search_tbl, (void const   *)tbl, (size_t )sz);
  search_tbl->is_SGI = (unsigned int )tbl->is_SGI == 0U;
  rs_set_expected_tpt_table(lq_sta, search_tbl);
  if ((unsigned int )tbl->is_SGI != 0U) {
    tpt = lq_sta->last_tpt / 100;
    if ((int )*(search_tbl->expected_tpt + (unsigned long )index) <= tpt) {
      goto ldv_54080;
    } else {

    }
  } else {

  }
  search_tbl->current_rate = rate_n_flags_from_tbl(priv, search_tbl, index, (int )((u8 )is_green));
  update_search_tbl_counter = 1U;
  goto out;
  }
  ldv_54080: 
  tbl->action = (u8 )((int )tbl->action + 1);
  if ((unsigned int )tbl->action > 8U) {
    tbl->action = 0U;
  } else {

  }
  if ((int )tbl->action == (int )start_action) {
    goto ldv_54090;
  } else {

  }
  goto ldv_54091;
  ldv_54090: 
  search_tbl->lq_type = 0;
  return (0);
  out: 
  lq_sta->search_better_tbl = 1U;
  tbl->action = (u8 )((int )tbl->action + 1);
  if ((unsigned int )tbl->action > 8U) {
    tbl->action = 0U;
  } else {

  }
  if ((unsigned int )update_search_tbl_counter != 0U) {
    search_tbl->action = tbl->action;
  } else {

  }
  return (0);
}
}
static void rs_stay_in_table(struct iwl_lq_sta *lq_sta , bool force_search ) 
{ 
  struct iwl_scale_tbl_info *tbl ;
  int i ;
  int active_tbl ;
    klee_make_symbolic(&active_tbl, sizeof(int), "active_tbl");
  int flush_interval_passed ;
    klee_make_symbolic(&flush_interval_passed, sizeof(int), "flush_interval_passed");
  struct iwl_priv *priv ;

  {
  flush_interval_passed = 0;
  priv = lq_sta->drv;
  active_tbl = (int )lq_sta->active_tbl;
  tbl = (struct iwl_scale_tbl_info *)(& lq_sta->lq_info) + (unsigned long )active_tbl;
  if ((unsigned int )lq_sta->stay_in_tbl != 0U) {
    if (lq_sta->flush_timer != 0ULL) {
      flush_interval_passed = (long )(((unsigned long )lq_sta->flush_timer - (unsigned long )jiffies) + 750UL) < 0L;
    } else {

    }
    if ((((int )force_search || lq_sta->total_failed > lq_sta->max_failure_limit) || lq_sta->total_success > lq_sta->max_success_limit) || (((unsigned int )lq_sta->search_better_tbl == 0U && lq_sta->flush_timer != 0ULL) && flush_interval_passed != 0)) {
      __iwl_dbg(priv->dev, 1048576U, 0, "rs_stay_in_table", "LQ: stay is expired %d %d %d\n",
                lq_sta->total_failed, lq_sta->total_success, flush_interval_passed);
      lq_sta->stay_in_tbl = 0U;
      lq_sta->total_failed = 0U;
      lq_sta->total_success = 0U;
      lq_sta->flush_timer = 0ULL;
    } else {
      lq_sta->table_count = lq_sta->table_count + 1U;
      if (lq_sta->table_count >= lq_sta->table_count_limit) {
        lq_sta->table_count = 0U;
        __iwl_dbg(priv->dev, 1048576U, 0, "rs_stay_in_table", "LQ: stay in table clear win\n");
        i = 0;
        goto ldv_54109;
        ldv_54108: 
        rs_rate_scale_clear_window((struct iwl_rate_scale_data *)(& tbl->win) + (unsigned long )i);
        i = i + 1;
        ldv_54109: ;
        if (i <= 12) {
          goto ldv_54108;
        } else {

        }

      } else {

      }
    }
    if ((unsigned int )lq_sta->stay_in_tbl == 0U) {
      i = 0;
      goto ldv_54112;
      ldv_54111: 
      rs_rate_scale_clear_window((struct iwl_rate_scale_data *)(& tbl->win) + (unsigned long )i);
      i = i + 1;
      ldv_54112: ;
      if (i <= 12) {
        goto ldv_54111;
      } else {

      }

    } else {

    }
  } else {

  }
  return;
}
}
static void rs_update_rate_tbl(struct iwl_priv *priv , struct iwl_rxon_context *ctx ,
                               struct iwl_lq_sta *lq_sta , struct iwl_scale_tbl_info *tbl ,
                               int index , u8 is_green ) 
{ 
  u32 rate ;

  {
  rate = rate_n_flags_from_tbl(priv, tbl, index, (int )is_green);
  rs_fill_link_cmd(priv, lq_sta, rate);
  iwl_send_lq_cmd(priv, ctx, & lq_sta->lq, 1, 0);
  return;
}
}
static void rs_rate_scale_perform(struct iwl_priv *priv , struct sk_buff *skb , struct ieee80211_sta *sta ,
                                  struct iwl_lq_sta *lq_sta ) 
{ 
  struct ieee80211_hw *hw ;
  struct ieee80211_conf *conf ;
  struct ieee80211_tx_info *info ;
  struct ieee80211_tx_info *tmp ;
  struct ieee80211_hdr *hdr ;
  int low ;
    klee_make_symbolic(&low, sizeof(int), "low");
  int high ;
    klee_make_symbolic(&high, sizeof(int), "high");
  int index ;
  int i ;
  struct iwl_rate_scale_data *window ;
  int current_tpt ;
    klee_make_symbolic(&current_tpt, sizeof(int), "current_tpt");
  int low_tpt ;
    klee_make_symbolic(&low_tpt, sizeof(int), "low_tpt");
  int high_tpt ;
    klee_make_symbolic(&high_tpt, sizeof(int), "high_tpt");
  u32 fail_count ;
  s8 scale_action ;
  u16 rate_mask ;
  u8 update_lq ;
  struct iwl_scale_tbl_info *tbl ;
  struct iwl_scale_tbl_info *tbl1 ;
  u16 rate_scale_index_msk ;
  u8 is_green ;
  u8 active_tbl ;
  u8 done_search ;
  u16 high_low ;
  s32 sr ;
  u8 tid ;
  struct iwl_tid_data *tid_data ;
  struct iwl_station_priv *sta_priv ;
  struct iwl_rxon_context *ctx ;
  int tmp___0 ;
  bool tmp___1 ;
  enum iwl_antenna_ok tmp___2 ;
  bool tmp___3 ;
  int tmp___4 ;
  enum iwl_antenna_ok tmp___5 ;
  enum iwl_antenna_ok tmp___6 ;
  bool tmp___7 ;
  int tmp___8 ;
  u8 sta_id ;
  bool tmp___9 ;

  {
  hw = priv->hw;
  conf = & hw->conf;
  tmp = IEEE80211_SKB_CB(skb);
  info = tmp;
  hdr = (struct ieee80211_hdr *)skb->data;
  low = 13;
  high = 13;
  window = (struct iwl_rate_scale_data *)0;
  current_tpt = -1;
  low_tpt = -1;
  high_tpt = -1;
  scale_action = 0;
  update_lq = 0U;
  rate_scale_index_msk = 0U;
  is_green = 0U;
  active_tbl = 0U;
  done_search = 0U;
  tid = 8U;
  sta_priv = (struct iwl_station_priv *)(& sta->drv_priv);
  ctx = sta_priv->ctx;
  __iwl_dbg(priv->dev, 1048576U, 0, "rs_rate_scale_perform", "rate scale calculate new rate for skb\n");
  tmp___0 = ieee80211_is_data((int )hdr->frame_control);
  if (tmp___0 == 0 || (info->flags & 4U) != 0U) {
    return;
  } else {

  }
  lq_sta->supp_rates = sta->supp_rates[(unsigned int )lq_sta->band];
  tid = rs_tl_add_packet(lq_sta, hdr);
  if ((unsigned int )tid != 8U && ((int )lq_sta->tx_agg_tid_en >> (int )tid) & 1) {
    tid_data = (struct iwl_tid_data *)(& priv->tid_data) + ((unsigned long )lq_sta->lq.sta_id + (unsigned long )tid);
    if ((unsigned int )tid_data->agg.state == 0U) {
      lq_sta->is_agg = 0U;
    } else {
      lq_sta->is_agg = 1U;
    }
  } else {
    lq_sta->is_agg = 0U;
  }
  if ((unsigned int )lq_sta->search_better_tbl == 0U) {
    active_tbl = lq_sta->active_tbl;
  } else {
    active_tbl = 1U - (unsigned int )lq_sta->active_tbl;
  }
  tbl = (struct iwl_scale_tbl_info *)(& lq_sta->lq_info) + (unsigned long )active_tbl;
  if ((unsigned int )tbl->lq_type == 1U || (unsigned int )tbl->lq_type == 2U) {
    lq_sta->is_green = 0U;
  } else {
    tmp___1 = rs_use_green(sta);
    lq_sta->is_green = (u8 )tmp___1;
  }
  is_green = lq_sta->is_green;
  index = lq_sta->last_txrate_idx;
  __iwl_dbg(priv->dev, 1048576U, 0, "rs_rate_scale_perform", "Rate scale index %d for type %d\n",
            index, (unsigned int )tbl->lq_type);
  rate_mask = rs_get_supported_rates(lq_sta, hdr, tbl->lq_type);
  __iwl_dbg(priv->dev, 1048576U, 0, "rs_rate_scale_perform", "mask 0x%04X\n", (int )rate_mask);
  if ((unsigned int )tbl->lq_type == 1U || (unsigned int )tbl->lq_type == 2U) {
    if ((unsigned int )lq_sta->band == 1U) {
      rate_scale_index_msk = ((int )((unsigned short )lq_sta->supp_rates) << 4U) & (int )rate_mask;
    } else {
      rate_scale_index_msk = (int )((unsigned short )lq_sta->supp_rates) & (int )rate_mask;
    }
  } else {
    rate_scale_index_msk = rate_mask;
  }
  if ((unsigned int )rate_scale_index_msk == 0U) {
    rate_scale_index_msk = rate_mask;
  } else {

  }
  if ((((int )rate_scale_index_msk >> index) & 1) == 0) {
    __iwl_err(priv->dev, 0, 0, "Current Rate is not valid\n");
    if ((unsigned int )lq_sta->search_better_tbl != 0U) {
      tbl->lq_type = 0;
      lq_sta->search_better_tbl = 0U;
      tbl = (struct iwl_scale_tbl_info *)(& lq_sta->lq_info) + (unsigned long )lq_sta->active_tbl;
      index = iwl_hwrate_to_plcp_idx(tbl->current_rate);
      rs_update_rate_tbl(priv, ctx, lq_sta, tbl, index, (int )is_green);
    } else {

    }
    return;
  } else {

  }
  if ((unsigned long )tbl->expected_tpt == (unsigned long )((u16 const   *)0U)) {
    __iwl_err(priv->dev, 0, 0, "tbl->expected_tpt is NULL\n");
    return;
  } else {

  }
  if ((int )lq_sta->max_rate_idx != -1 && (int )lq_sta->max_rate_idx < index) {
    index = (int )lq_sta->max_rate_idx;
    update_lq = 1U;
    window = (struct iwl_rate_scale_data *)(& tbl->win) + (unsigned long )index;
    goto lq_update;
  } else {

  }
  window = (struct iwl_rate_scale_data *)(& tbl->win) + (unsigned long )index;
  fail_count = (u32 )(window->counter - window->success_counter);
  if (fail_count <= 5U && window->success_counter <= 7) {
    __iwl_dbg(priv->dev, 1048576U, 0, "rs_rate_scale_perform", "LQ: still below TH. succ=%d total=%d for index %d\n",
              window->success_counter, window->counter, index);
    window->average_tpt = -1;
    rs_stay_in_table(lq_sta, 0);
    goto out;
  } else {

  }
  if (window->average_tpt != (window->success_ratio * (int )*(tbl->expected_tpt + (unsigned long )index) + 64) / 128) {
    __iwl_err(priv->dev, 0, 0, "expected_tpt should have been calculated by now\n");
    window->average_tpt = (window->success_ratio * (int )*(tbl->expected_tpt + (unsigned long )index) + 64) / 128;
  } else {

  }
  if ((unsigned int )lq_sta->search_better_tbl != 0U) {
    tmp___2 = iwl_tx_ant_restriction(priv);
    if ((unsigned int )tmp___2 == 2U) {
      if (window->average_tpt > lq_sta->last_tpt) {
        __iwl_dbg(priv->dev, 1048576U, 0, "rs_rate_scale_perform", "LQ: SWITCHING TO NEW TABLE suc=%d cur-tpt=%d old-tpt=%d\n",
                  window->success_ratio, window->average_tpt, lq_sta->last_tpt);
        if ((unsigned int )tbl->lq_type != 1U && (unsigned int )tbl->lq_type != 2U) {
          lq_sta->enable_counter = 1U;
        } else {

        }
        lq_sta->active_tbl = active_tbl;
        current_tpt = window->average_tpt;
      } else {
        __iwl_dbg(priv->dev, 1048576U, 0, "rs_rate_scale_perform", "LQ: GOING BACK TO THE OLD TABLE suc=%d cur-tpt=%d old-tpt=%d\n",
                  window->success_ratio, window->average_tpt, lq_sta->last_tpt);
        tbl->lq_type = 0;
        active_tbl = lq_sta->active_tbl;
        tbl = (struct iwl_scale_tbl_info *)(& lq_sta->lq_info) + (unsigned long )active_tbl;
        index = iwl_hwrate_to_plcp_idx(tbl->current_rate);
        current_tpt = lq_sta->last_tpt;
        update_lq = 1U;
      }
      lq_sta->search_better_tbl = 0U;
      done_search = 1U;
      goto lq_update;
    } else {

    }
  } else {

  }
  high_low = rs_get_adjacent_rate(priv, (int )((u8 )index), (int )rate_scale_index_msk,
                                  (int )tbl->lq_type);
  low = (int )high_low & 255;
  high = ((int )high_low >> 8) & 255;
  if ((int )lq_sta->max_rate_idx != -1 && (int )lq_sta->max_rate_idx < high) {
    high = 13;
  } else {

  }
  sr = window->success_ratio;
  current_tpt = window->average_tpt;
  if (low != 13) {
    low_tpt = tbl->win[low].average_tpt;
  } else {

  }
  if (high != 13) {
    high_tpt = tbl->win[high].average_tpt;
  } else {

  }
  scale_action = 0;
  if (sr <= 1920 || current_tpt == 0) {
    __iwl_dbg(priv->dev, 1048576U, 0, "rs_rate_scale_perform", "decrease rate because of low success_ratio\n");
    scale_action = -1;
  } else
  if (low_tpt == -1 && high_tpt == -1) {
    if (high != 13 && sr > 6399) {
      scale_action = 1;
    } else
    if (low != 13) {
      scale_action = 0;
    } else {

    }
  } else
  if (((low_tpt != -1 && high_tpt != -1) && low_tpt < current_tpt) && high_tpt < current_tpt) {
    scale_action = 0;
  } else
  if (high_tpt != -1) {
    if (high_tpt > current_tpt && sr > 6399) {
      scale_action = 1;
    } else {
      scale_action = 0;
    }
  } else
  if (low_tpt != -1) {
    if (low_tpt > current_tpt) {
      __iwl_dbg(priv->dev, 1048576U, 0, "rs_rate_scale_perform", "decrease rate because of low tpt\n");
      scale_action = -1;
    } else
    if (sr > 6399) {
      scale_action = 1;
    } else {

    }
  } else {

  }
  if (((int )scale_action == -1 && low != 13) && (sr > 10880 || (int )*(tbl->expected_tpt + (unsigned long )low) * 100 < current_tpt)) {
    scale_action = 0;
  } else {

  }
  tmp___3 = iwl_ht_enabled(priv);
  if (tmp___3) {
    tmp___4 = 0;
  } else {
    tmp___4 = 1;
  }
  if (tmp___4 && ((unsigned int )tbl->lq_type != 1U && (unsigned int )tbl->lq_type != 2U)) {
    scale_action = -1;
  } else {

  }
  tmp___5 = iwl_tx_ant_restriction(priv);
  if ((unsigned int )tmp___5 != 2U && ((unsigned int )tbl->lq_type == 4U || (unsigned int )tbl->lq_type == 5U)) {
    scale_action = -1;
  } else {

  }
  if ((unsigned int )priv->bt_traffic_load > 1U && ((unsigned int )tbl->lq_type == 4U || (unsigned int )tbl->lq_type == 5U)) {
    if ((int )lq_sta->last_bt_traffic > (int )priv->bt_traffic_load) {

    } else
    if ((int )lq_sta->last_bt_traffic <= (int )priv->bt_traffic_load) {
      scale_action = -1;
    } else {

    }
  } else {

  }
  lq_sta->last_bt_traffic = priv->bt_traffic_load;
  if ((unsigned int )priv->bt_traffic_load > 1U && ((unsigned int )tbl->lq_type == 4U || (unsigned int )tbl->lq_type == 5U)) {
    rs_stay_in_table(lq_sta, 1);
    goto lq_update;
  } else {

  }
  switch ((int )scale_action) {
  case -1: ;
  if (low != 13) {
    update_lq = 1U;
    index = low;
  } else {

  }
  goto ldv_54161;
  case 1: ;
  if (high != 13) {
    update_lq = 1U;
    index = high;
  } else {

  }
  goto ldv_54161;
  case 0: ;
  default: ;
  goto ldv_54161;
  }
  ldv_54161: 
  __iwl_dbg(priv->dev, 1048576U, 0, "rs_rate_scale_perform", "choose rate scale index %d action %d low %d high %d type %d\n",
            index, (int )scale_action, low, high, (unsigned int )tbl->lq_type);
  lq_update: ;
  if ((unsigned int )update_lq != 0U) {
    rs_update_rate_tbl(priv, ctx, lq_sta, tbl, index, (int )is_green);
  } else {

  }
  tmp___6 = iwl_tx_ant_restriction(priv);
  if ((unsigned int )tmp___6 == 2U) {
    rs_stay_in_table(lq_sta, 0);
  } else {

  }
  if ((((unsigned int )update_lq == 0U && (unsigned int )done_search == 0U) && (unsigned int )lq_sta->stay_in_tbl == 0U) && window->counter != 0) {
    lq_sta->last_tpt = current_tpt;
    if ((unsigned int )tbl->lq_type == 1U || (unsigned int )tbl->lq_type == 2U) {
      rs_move_legacy_other(priv, lq_sta, conf, sta, index);
    } else
    if ((unsigned int )tbl->lq_type == 3U) {
      rs_move_siso_to_other(priv, lq_sta, conf, sta, index);
    } else
    if ((unsigned int )tbl->lq_type == 4U) {
      rs_move_mimo2_to_other(priv, lq_sta, conf, sta, index);
    } else {
      rs_move_mimo3_to_other(priv, lq_sta, conf, sta, index);
    }
    if ((unsigned int )lq_sta->search_better_tbl != 0U) {
      tbl = (struct iwl_scale_tbl_info *)(& lq_sta->lq_info) + (unsigned long )(1 - (int )lq_sta->active_tbl);
      i = 0;
      goto ldv_54166;
      ldv_54165: 
      rs_rate_scale_clear_window((struct iwl_rate_scale_data *)(& tbl->win) + (unsigned long )i);
      i = i + 1;
      ldv_54166: ;
      if (i <= 12) {
        goto ldv_54165;
      } else {

      }
      index = iwl_hwrate_to_plcp_idx(tbl->current_rate);
      __iwl_dbg(priv->dev, 1048576U, 0, "rs_rate_scale_perform", "Switch current  mcs: %X index: %d\n",
                tbl->current_rate, index);
      rs_fill_link_cmd(priv, lq_sta, tbl->current_rate);
      iwl_send_lq_cmd(priv, ctx, & lq_sta->lq, 1, 0);
    } else {
      done_search = 1U;
    }
  } else {

  }
  if ((unsigned int )done_search != 0U && (unsigned int )lq_sta->stay_in_tbl == 0U) {
    tbl1 = (struct iwl_scale_tbl_info *)(& lq_sta->lq_info) + (unsigned long )lq_sta->active_tbl;
    if ((unsigned int )tbl1->lq_type == 1U || (unsigned int )tbl1->lq_type == 2U) {
      tmp___7 = conf_is_ht(conf);
      if (tmp___7) {
        tmp___8 = 0;
      } else {
        tmp___8 = 1;
      }
      if (tmp___8) {
        if ((int )lq_sta->action_counter > (int )tbl1->max_search) {
          __iwl_dbg(priv->dev, 1048576U, 0, "rs_rate_scale_perform", "LQ: STAY in legacy table\n");
          rs_set_stay_in_table(priv, 1, lq_sta);
        } else {

        }
      } else {

      }
    } else {

    }
    if ((unsigned int )lq_sta->enable_counter != 0U && (int )lq_sta->action_counter >= (int )tbl1->max_search) {
      tmp___9 = iwl_ht_enabled(priv);
      if ((int )tmp___9) {
        if ((lq_sta->last_tpt > 0 && ((int )lq_sta->tx_agg_tid_en >> (int )tid) & 1) && (unsigned int )tid != 8U) {
          sta_id = lq_sta->lq.sta_id;
          tid_data = (struct iwl_tid_data *)(& priv->tid_data) + ((unsigned long )sta_id + (unsigned long )tid);
          if ((unsigned int )tid_data->agg.state == 0U) {
            __iwl_dbg(priv->dev, 1048576U, 0, "rs_rate_scale_perform", "try to aggregate tid %d\n",
                      (int )tid);
            rs_tl_turn_on_agg(priv, (int )tid, lq_sta, sta);
          } else {

          }
        } else {

        }
        rs_set_stay_in_table(priv, 0, lq_sta);
      } else {

      }
    } else {

    }
  } else {

  }
  out: 
  tbl->current_rate = rate_n_flags_from_tbl(priv, tbl, index, (int )is_green);
  lq_sta->last_txrate_idx = index;
  return;
}
}
static void rs_initialize_lq(struct iwl_priv *priv , struct ieee80211_sta *sta , struct iwl_lq_sta *lq_sta ) 
{ 
  struct iwl_scale_tbl_info *tbl ;
  int rate_idx ;
    klee_make_symbolic(&rate_idx, sizeof(int), "rate_idx");
  int i ;
  u32 rate ;
  u8 use_green ;
  bool tmp ;
  u8 active_tbl ;
  u8 valid_tx_ant ;
  struct iwl_station_priv *sta_priv ;
  struct iwl_rxon_context *ctx ;
  u8 tmp___0 ;

  {
  tmp = rs_use_green(sta);
  use_green = (u8 )tmp;
  active_tbl = 0U;
  if ((unsigned long )sta == (unsigned long )((struct ieee80211_sta *)0) || (unsigned long )lq_sta == (unsigned long )((struct iwl_lq_sta *)0)) {
    return;
  } else {

  }
  sta_priv = (struct iwl_station_priv *)(& sta->drv_priv);
  ctx = sta_priv->ctx;
  i = lq_sta->last_txrate_idx;
  valid_tx_ant = (priv->nvm_data)->valid_tx_ant;
  if ((unsigned int )lq_sta->search_better_tbl == 0U) {
    active_tbl = lq_sta->active_tbl;
  } else {
    active_tbl = 1U - (unsigned int )lq_sta->active_tbl;
  }
  tbl = (struct iwl_scale_tbl_info *)(& lq_sta->lq_info) + (unsigned long )active_tbl;
  if (i < 0 || i > 12) {
    i = 0;
  } else {

  }
  rate = (u32 )iwl_rates[i].plcp;
  tbl->ant_type = first_antenna((int )valid_tx_ant);
  rate = (u32 )((int )tbl->ant_type << 14) | rate;
  if (i >= 0 && i <= 3) {
    rate = rate | 512U;
  } else {

  }
  rs_get_tbl_info_from_mcs(rate, priv->band, tbl, & rate_idx);
  tmp___0 = rs_is_valid_ant((int )valid_tx_ant, (int )tbl->ant_type);
  if ((unsigned int )tmp___0 == 0U) {
    rs_toggle_antenna((u32 )valid_tx_ant, & rate, tbl);
  } else {

  }
  rate = rate_n_flags_from_tbl(priv, tbl, rate_idx, (int )use_green);
  tbl->current_rate = rate;
  rs_set_expected_tpt_table(lq_sta, tbl);
  rs_fill_link_cmd((struct iwl_priv *)0, lq_sta, rate);
  priv->stations[(int )lq_sta->lq.sta_id].lq = & lq_sta->lq;
  iwl_send_lq_cmd(priv, ctx, & lq_sta->lq, 0, 1);
  return;
}
}
static void rs_get_rate(void *priv_r , struct ieee80211_sta *sta , void *priv_sta ,
                        struct ieee80211_tx_rate_control *txrc ) 
{ 
  struct sk_buff *skb ;
  struct ieee80211_supported_band *sband ;
  struct iwl_op_mode *op_mode ;
  struct iwl_priv *priv ;
  struct ieee80211_tx_info *info ;
  struct ieee80211_tx_info *tmp ;
  struct iwl_lq_sta *lq_sta ;
  int rate_idx ;
  bool tmp___0 ;
  u8 tmp___1 ;
  u8 tmp___2 ;
  s8 tmp___3 ;

  {
  skb = txrc->skb;
  sband = txrc->sband;
  op_mode = (struct iwl_op_mode *)priv_r;
  priv = (struct iwl_priv *)(& op_mode->op_mode_specific);
  tmp = IEEE80211_SKB_CB(skb);
  info = tmp;
  lq_sta = (struct iwl_lq_sta *)priv_sta;
  __iwl_dbg(priv->dev, 1048576U, 1, "rs_get_rate", "rate scale calculate new rate for skb\n");
  if ((unsigned long )lq_sta != (unsigned long )((struct iwl_lq_sta *)0)) {
    lq_sta->max_rate_idx = (s8 )txrc->max_rate_idx;
    if ((unsigned int )sband->band == 1U && (int )lq_sta->max_rate_idx != -1) {
      lq_sta->max_rate_idx = (s8 )((unsigned int )((unsigned char )lq_sta->max_rate_idx) + 4U);
    } else {

    }
    if ((int )lq_sta->max_rate_idx < 0 || (int )lq_sta->max_rate_idx > 12) {
      lq_sta->max_rate_idx = -1;
    } else {

    }
  } else {

  }
  if ((unsigned long )lq_sta != (unsigned long )((struct iwl_lq_sta *)0) && (unsigned long )lq_sta->drv == (unsigned long )((struct iwl_priv *)0)) {
    __iwl_dbg(priv->dev, 1048576U, 0, "rs_get_rate", "Rate scaling not initialized yet.\n");
    priv_sta = (void *)0;
  } else {

  }
  tmp___0 = rate_control_send_low(sta, priv_sta, txrc);
  if ((int )tmp___0) {
    return;
  } else {

  }
  rate_idx = lq_sta->last_txrate_idx;
  if ((lq_sta->last_rate_n_flags & 256U) != 0U) {
    rate_idx = rate_idx + -4;
    rate_idx = rate_idx > 0 ? rate_idx + -1 : 0;
    tmp___2 = rs_extract_rate(lq_sta->last_rate_n_flags);
    if ((unsigned int )tmp___2 > 15U) {
      rate_idx = rate_idx + 16;
    } else {
      tmp___1 = rs_extract_rate(lq_sta->last_rate_n_flags);
      if ((unsigned int )tmp___1 > 7U) {
        rate_idx = rate_idx + 8;
      } else {

      }
    }
    info->__annonCompField99.control.__annonCompField97.__annonCompField96.rates[0].flags = 8U;
    if ((lq_sta->last_rate_n_flags & 8192U) != 0U) {
      info->__annonCompField99.control.__annonCompField97.__annonCompField96.rates[0].flags = (unsigned short )((unsigned int )info->__annonCompField99.control.__annonCompField97.__annonCompField96.rates[0].flags | 128U);
    } else {

    }
    if ((lq_sta->last_rate_n_flags & 4096U) != 0U) {
      info->__annonCompField99.control.__annonCompField97.__annonCompField96.rates[0].flags = (unsigned short )((unsigned int )info->__annonCompField99.control.__annonCompField97.__annonCompField96.rates[0].flags | 64U);
    } else {

    }
    if ((lq_sta->last_rate_n_flags & 2048U) != 0U) {
      info->__annonCompField99.control.__annonCompField97.__annonCompField96.rates[0].flags = (unsigned short )((unsigned int )info->__annonCompField99.control.__annonCompField97.__annonCompField96.rates[0].flags | 32U);
    } else {

    }
    if ((lq_sta->last_rate_n_flags & 1024U) != 0U) {
      info->__annonCompField99.control.__annonCompField97.__annonCompField96.rates[0].flags = (unsigned short )((unsigned int )info->__annonCompField99.control.__annonCompField97.__annonCompField96.rates[0].flags | 16U);
    } else {

    }
  } else {
    if ((rate_idx < 0 || rate_idx > 11) || ((unsigned int )sband->band == 1U && rate_idx <= 3)) {
      tmp___3 = rate_lowest_index(sband, sta);
      rate_idx = (int )tmp___3;
    } else
    if ((unsigned int )sband->band == 1U) {
      rate_idx = rate_idx + -4;
    } else {

    }
    info->__annonCompField99.control.__annonCompField97.__annonCompField96.rates[0].flags = 0U;
  }
  info->__annonCompField99.control.__annonCompField97.__annonCompField96.rates[0].idx = (s8 )rate_idx;
  info->__annonCompField99.control.__annonCompField97.__annonCompField96.rates[0].count = 1U;
  return;
}
}
static void *rs_alloc_sta(void *priv_rate , struct ieee80211_sta *sta , gfp_t gfp ) 
{ 
  struct iwl_station_priv *sta_priv ;
  struct iwl_op_mode *op_mode ;
  struct iwl_priv *priv ;

  {
  sta_priv = (struct iwl_station_priv *)(& sta->drv_priv);
  op_mode = (struct iwl_op_mode *)priv_rate;
  priv = (struct iwl_priv *)(& op_mode->op_mode_specific);
  __iwl_dbg(priv->dev, 1048576U, 0, "rs_alloc_sta", "create station rate scale window\n");
  return ((void *)(& sta_priv->lq_sta));
}
}
void iwl_rs_rate_init(struct iwl_priv *priv , struct ieee80211_sta *sta , u8 sta_id ) 
{ 
  int i ;
  int j ;
    klee_make_symbolic(&j, sizeof(int), "j");
  struct ieee80211_hw *hw ;
  struct ieee80211_conf *conf ;
  struct ieee80211_sta_ht_cap *ht_cap ;
  struct iwl_station_priv *sta_priv ;
  struct iwl_lq_sta *lq_sta ;
  struct ieee80211_supported_band *sband ;
  unsigned long supp ;
    klee_make_symbolic(&supp, sizeof(long), "supp");
  bool tmp ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  u8 tmp___2 ;
  u8 tmp___3 ;
  s8 tmp___4 ;

  {
  hw = priv->hw;
  conf = & (priv->hw)->conf;
  ht_cap = & sta->ht_cap;
  sta_priv = (struct iwl_station_priv *)(& sta->drv_priv);
  lq_sta = & sta_priv->lq_sta;
  sband = (hw->wiphy)->bands[(unsigned int )(conf->chandef.chan)->band];
  lq_sta->lq.sta_id = sta_id;
  j = 0;
  goto ldv_54224;
  ldv_54223: 
  i = 0;
  goto ldv_54221;
  ldv_54220: 
  rs_rate_scale_clear_window((struct iwl_rate_scale_data *)(& lq_sta->lq_info[j].win) + (unsigned long )i);
  i = i + 1;
  ldv_54221: ;
  if (i <= 12) {
    goto ldv_54220;
  } else {

  }
  j = j + 1;
  ldv_54224: ;
  if (j <= 1) {
    goto ldv_54223;
  } else {

  }
  lq_sta->flush_timer = 0ULL;
  lq_sta->supp_rates = sta->supp_rates[(unsigned int )sband->band];
  __iwl_dbg(priv->dev, 1048576U, 0, "iwl_rs_rate_init", "LQ: *** rate scale station global init for station %d ***\n",
            (int )sta_id);
  lq_sta->is_dup = 0U;
  lq_sta->max_rate_idx = -1;
  lq_sta->missed_rate_counter = 15U;
  tmp = rs_use_green(sta);
  lq_sta->is_green = (u8 )tmp;
  lq_sta->band = sband->band;
  supp = (unsigned long )sta->supp_rates[(unsigned int )sband->band];
  lq_sta->active_legacy_rate = 0U;
  tmp___0 = find_first_bit((unsigned long const   *)(& supp), 64UL);
  i = (int )tmp___0;
  goto ldv_54228;
  ldv_54227: 
  lq_sta->active_legacy_rate = (int )lq_sta->active_legacy_rate | (int )((u16 )(1UL << (int )(sband->bitrates + (unsigned long )i)->hw_value));
  tmp___1 = find_next_bit((unsigned long const   *)(& supp), 64UL, (unsigned long )(i + 1));
  i = (int )tmp___1;
  ldv_54228: ;
  if (i <= 63) {
    goto ldv_54227;
  } else {

  }
  lq_sta->active_siso_rate = (int )((u16 )ht_cap->mcs.rx_mask[0]) << 1U;
  lq_sta->active_siso_rate = (u16 )((int )((short )lq_sta->active_siso_rate) | ((int )((short )ht_cap->mcs.rx_mask[0]) & 1));
  lq_sta->active_siso_rate = (unsigned int )lq_sta->active_siso_rate & 65533U;
  lq_sta->active_siso_rate = (int )lq_sta->active_siso_rate << 4U;
  lq_sta->active_mimo2_rate = (int )((u16 )ht_cap->mcs.rx_mask[1]) << 1U;
  lq_sta->active_mimo2_rate = (u16 )((int )((short )lq_sta->active_mimo2_rate) | ((int )((short )ht_cap->mcs.rx_mask[1]) & 1));
  lq_sta->active_mimo2_rate = (unsigned int )lq_sta->active_mimo2_rate & 65533U;
  lq_sta->active_mimo2_rate = (int )lq_sta->active_mimo2_rate << 4U;
  lq_sta->active_mimo3_rate = (int )((u16 )ht_cap->mcs.rx_mask[2]) << 1U;
  lq_sta->active_mimo3_rate = (u16 )((int )((short )lq_sta->active_mimo3_rate) | ((int )((short )ht_cap->mcs.rx_mask[2]) & 1));
  lq_sta->active_mimo3_rate = (unsigned int )lq_sta->active_mimo3_rate & 65533U;
  lq_sta->active_mimo3_rate = (int )lq_sta->active_mimo3_rate << 4U;
  __iwl_dbg(priv->dev, 1048576U, 0, "iwl_rs_rate_init", "SISO-RATE=%X MIMO2-RATE=%X MIMO3-RATE=%X\n",
            (int )lq_sta->active_siso_rate, (int )lq_sta->active_mimo2_rate, (int )lq_sta->active_mimo3_rate);
  lq_sta->lq.general_params.single_stream_ant_msk = first_antenna((int )(priv->nvm_data)->valid_tx_ant);
  tmp___2 = first_antenna((int )(priv->nvm_data)->valid_tx_ant);
  lq_sta->lq.general_params.dual_stream_ant_msk = (u8 )((int )((signed char )(priv->nvm_data)->valid_tx_ant) & ~ ((int )((signed char )tmp___2)));
  if ((unsigned int )lq_sta->lq.general_params.dual_stream_ant_msk == 0U) {
    lq_sta->lq.general_params.dual_stream_ant_msk = 3U;
  } else {
    tmp___3 = num_of_ant((int )(priv->nvm_data)->valid_tx_ant);
    if ((unsigned int )tmp___3 == 2U) {
      lq_sta->lq.general_params.dual_stream_ant_msk = (priv->nvm_data)->valid_tx_ant;
    } else {

    }
  }
  lq_sta->tx_agg_tid_en = 255U;
  lq_sta->drv = priv;
  tmp___4 = rate_lowest_index(sband, sta);
  lq_sta->last_txrate_idx = (int )tmp___4;
  if ((unsigned int )sband->band == 1U) {
    lq_sta->last_txrate_idx = lq_sta->last_txrate_idx + 4;
  } else {

  }
  lq_sta->is_agg = 0U;
  lq_sta->dbg_fixed_rate = 0U;
  rs_initialize_lq(priv, sta, lq_sta);
  return;
}
}
static void rs_fill_link_cmd(struct iwl_priv *priv , struct iwl_lq_sta *lq_sta , u32 new_rate ) 
{ 
  struct iwl_scale_tbl_info tbl_type ;
  int index ;
  int rate_idx ;
  int repeat_rate ;
    klee_make_symbolic(&repeat_rate, sizeof(int), "repeat_rate");
  u8 ant_toggle_cnt ;
  u8 use_ht_possible ;
  u8 valid_tx_ant ;
  struct iwl_station_priv *sta_priv ;
  struct iwl_lq_sta  const  *__mptr ;
  struct iwl_link_quality_cmd *lq_cmd ;
  int _min1 ;
  int _min2 ;
  u8 tmp ;
  u8 tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  index = 0;
  repeat_rate = 0;
  ant_toggle_cnt = 0U;
  use_ht_possible = 1U;
  valid_tx_ant = 0U;
  __mptr = (struct iwl_lq_sta  const  *)lq_sta;
  sta_priv = (struct iwl_station_priv *)__mptr + 0xfffffffffffffff8UL;
  lq_cmd = & lq_sta->lq;
  rs_dbgfs_set_mcs(lq_sta, & new_rate, index);
  rs_get_tbl_info_from_mcs(new_rate, lq_sta->band, & tbl_type, & rate_idx);
  if ((unsigned long )priv != (unsigned long )((struct iwl_priv *)0) && (int )priv->bt_full_concurrent) {
    tbl_type.ant_type = first_antenna((int )(priv->nvm_data)->valid_tx_ant);
  } else {

  }
  if ((unsigned int )tbl_type.lq_type == 1U || (unsigned int )tbl_type.lq_type == 2U) {
    ant_toggle_cnt = 1U;
    repeat_rate = 1;
  } else {
    _min1 = 3;
    _min2 = 2;
    repeat_rate = _min1 < _min2 ? _min1 : _min2;
  }
  lq_cmd->general_params.mimo_delimiter = (u8 )((unsigned int )tbl_type.lq_type == 4U || (unsigned int )tbl_type.lq_type == 5U);
  lq_cmd->rs_table[index].rate_n_flags = new_rate;
  tmp___0 = num_of_ant((int )tbl_type.ant_type);
  if ((unsigned int )tmp___0 == 1U) {
    lq_cmd->general_params.single_stream_ant_msk = tbl_type.ant_type;
  } else {
    tmp = num_of_ant((int )tbl_type.ant_type);
    if ((unsigned int )tmp == 2U) {
      lq_cmd->general_params.dual_stream_ant_msk = tbl_type.ant_type;
    } else {

    }
  }
  index = index + 1;
  repeat_rate = repeat_rate - 1;
  if ((unsigned long )priv != (unsigned long )((struct iwl_priv *)0)) {
    if ((int )priv->bt_full_concurrent) {
      valid_tx_ant = 1U;
    } else {
      valid_tx_ant = (priv->nvm_data)->valid_tx_ant;
    }
  } else {

  }
  goto ldv_54253;
  ldv_54252: ;
  goto ldv_54250;
  ldv_54249: ;
  if ((unsigned int )tbl_type.lq_type == 1U || (unsigned int )tbl_type.lq_type == 2U) {
    if ((unsigned int )ant_toggle_cnt == 0U) {
      ant_toggle_cnt = (u8 )((int )ant_toggle_cnt + 1);
    } else
    if ((unsigned long )priv != (unsigned long )((struct iwl_priv *)0)) {
      tmp___1 = rs_toggle_antenna((u32 )valid_tx_ant, & new_rate, & tbl_type);
      if (tmp___1 != 0) {
        ant_toggle_cnt = 1U;
      } else {

      }
    } else {

    }
  } else {

  }
  rs_dbgfs_set_mcs(lq_sta, & new_rate, index);
  lq_cmd->rs_table[index].rate_n_flags = new_rate;
  repeat_rate = repeat_rate - 1;
  index = index + 1;
  ldv_54250: ;
  if (repeat_rate > 0 && index <= 15) {
    goto ldv_54249;
  } else {

  }
  rs_get_tbl_info_from_mcs(new_rate, lq_sta->band, & tbl_type, & rate_idx);
  if ((unsigned long )priv != (unsigned long )((struct iwl_priv *)0) && (int )priv->bt_full_concurrent) {
    tbl_type.ant_type = first_antenna((int )(priv->nvm_data)->valid_tx_ant);
  } else {

  }
  if ((unsigned int )tbl_type.lq_type == 4U || (unsigned int )tbl_type.lq_type == 5U) {
    lq_cmd->general_params.mimo_delimiter = (u8 )index;
  } else {

  }
  new_rate = rs_get_lower_rate(lq_sta, & tbl_type, (int )((u8 )rate_idx), (int )use_ht_possible);
  if ((unsigned int )tbl_type.lq_type == 1U || (unsigned int )tbl_type.lq_type == 2U) {
    if ((unsigned int )ant_toggle_cnt == 0U) {
      ant_toggle_cnt = (u8 )((int )ant_toggle_cnt + 1);
    } else
    if ((unsigned long )priv != (unsigned long )((struct iwl_priv *)0)) {
      tmp___2 = rs_toggle_antenna((u32 )valid_tx_ant, & new_rate, & tbl_type);
      if (tmp___2 != 0) {
        ant_toggle_cnt = 1U;
      } else {

      }
    } else {

    }
    repeat_rate = 1;
  } else {
    repeat_rate = 3;
  }
  use_ht_possible = 0U;
  rs_dbgfs_set_mcs(lq_sta, & new_rate, index);
  lq_cmd->rs_table[index].rate_n_flags = new_rate;
  index = index + 1;
  repeat_rate = repeat_rate - 1;
  ldv_54253: ;
  if (index <= 15) {
    goto ldv_54252;
  } else {

  }
  lq_cmd->agg_params.agg_frame_cnt_limit = (int )sta_priv->max_agg_bufsize != 0 ? (u8 )((int )sta_priv->max_agg_bufsize) : 63U;
  lq_cmd->agg_params.agg_dis_start_th = 3U;
  lq_cmd->agg_params.agg_time_limit = 4000U;
  if ((((unsigned long )priv != (unsigned long )((struct iwl_priv *)0) && (unsigned long )(priv->lib)->bt_params != (unsigned long )((struct iwl_dvm_bt_params  const  */* const  */)0)) && (unsigned int )((unsigned short )((priv->lib)->bt_params)->agg_time_limit) != 0U) && (unsigned int )priv->bt_traffic_load > 1U) {
    lq_cmd->agg_params.agg_time_limit = ((priv->lib)->bt_params)->agg_time_limit;
  } else {

  }
  return;
}
}
static void *rs_alloc(struct ieee80211_hw *hw , struct dentry *debugfsdir ) 
{ 


  {
  return (hw->priv);
}
}
static void rs_free(void *priv_rate ) 
{ 


  {
  return;
}
}
static void rs_free_sta(void *priv_r , struct ieee80211_sta *sta , void *priv_sta ) 
{ 
  struct iwl_op_mode *op_mode ;
  struct iwl_priv *priv ;

  {
  op_mode = (struct iwl_op_mode *)priv_r;
  priv = (struct iwl_priv *)(& op_mode->op_mode_specific);
  __iwl_dbg(priv->dev, 1048576U, 0, "rs_free_sta", "enter\n");
  __iwl_dbg(priv->dev, 1048576U, 0, "rs_free_sta", "leave\n");
  return;
}
}
static void rs_dbgfs_set_mcs(struct iwl_lq_sta *lq_sta , u32 *rate_n_flags , int index ) 
{ 
  struct iwl_priv *priv ;
  u8 valid_tx_ant ;
  u8 ant_sel_tx ;

  {
  priv = lq_sta->drv;
  valid_tx_ant = (priv->nvm_data)->valid_tx_ant;
  if (lq_sta->dbg_fixed_rate != 0U) {
    ant_sel_tx = (u8 )((lq_sta->dbg_fixed_rate & 114688U) >> 14);
    if (((int )valid_tx_ant & (int )ant_sel_tx) == (int )ant_sel_tx) {
      *rate_n_flags = lq_sta->dbg_fixed_rate;
      __iwl_dbg(priv->dev, 1048576U, 0, "rs_dbgfs_set_mcs", "Fixed rate ON\n");
    } else {
      lq_sta->dbg_fixed_rate = 0U;
      __iwl_err(priv->dev, 0, 0, "Invalid antenna selection 0x%X, Valid is 0x%X\n",
                (int )ant_sel_tx, (int )valid_tx_ant);
      __iwl_dbg(priv->dev, 1048576U, 0, "rs_dbgfs_set_mcs", "Fixed rate OFF\n");
    }
  } else {
    __iwl_dbg(priv->dev, 1048576U, 0, "rs_dbgfs_set_mcs", "Fixed rate OFF\n");
  }
  return;
}
}
static ssize_t rs_sta_dbgfs_scale_table_write(struct file *file , char const   *user_buf ,
                                              size_t count , loff_t *ppos ) 
{ 
  struct iwl_lq_sta *lq_sta ;
  struct iwl_priv *priv ;
  char buf[64U] ;
  size_t buf_size ;
  u32 parsed_rate ;
  size_t _min1 ;
  unsigned long _min2 ;
  unsigned long tmp ;
  int tmp___0 ;

  {
  lq_sta = (struct iwl_lq_sta *)file->private_data;
  priv = lq_sta->drv;
  memset((void *)(& buf), 0, 64UL);
  _min1 = count;
  _min2 = 63UL;
  buf_size = _min1 < _min2 ? _min1 : _min2;
  tmp = copy_from_user((void *)(& buf), (void const   *)user_buf, buf_size);
  if (tmp != 0UL) {
    return (-14L);
  } else {

  }
  tmp___0 = sscanf((char const   *)(& buf), "%x", & parsed_rate);
  if (tmp___0 == 1) {
    lq_sta->dbg_fixed_rate = parsed_rate;
  } else {
    lq_sta->dbg_fixed_rate = 0U;
  }
  rs_program_fix_rate(priv, lq_sta);
  return ((ssize_t )count);
}
}
static ssize_t rs_sta_dbgfs_scale_table_read(struct file *file , char *user_buf ,
                                             size_t count , loff_t *ppos ) 
{ 
  char *buff ;
  int desc ;
    klee_make_symbolic(&desc, sizeof(int), "desc");
  int i ;
  int index ;
  ssize_t ret ;
  struct iwl_lq_sta *lq_sta ;
  struct iwl_priv *priv ;
  struct iwl_scale_tbl_info *tbl ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
    klee_make_symbolic(&tmp___11, sizeof(int), "tmp___11");
  int tmp___12 ;
    klee_make_symbolic(&tmp___12, sizeof(int), "tmp___12");
  int tmp___13 ;
    klee_make_symbolic(&tmp___13, sizeof(int), "tmp___13");

  {
  desc = 0;
  i = 0;
  index = 0;
  lq_sta = (struct iwl_lq_sta *)file->private_data;
  tbl = (struct iwl_scale_tbl_info *)(& lq_sta->lq_info) + (unsigned long )lq_sta->active_tbl;
  priv = lq_sta->drv;
  tmp = kmalloc(1024UL, 208U);
  buff = (char *)tmp;
  if ((unsigned long )buff == (unsigned long )((char *)0)) {
    return (-12L);
  } else {

  }
  tmp___0 = sprintf(buff + (unsigned long )desc, "sta_id %d\n", (int )lq_sta->lq.sta_id);
  desc = tmp___0 + desc;
  tmp___1 = sprintf(buff + (unsigned long )desc, "failed=%d success=%d rate=0%X\n",
                    lq_sta->total_failed, lq_sta->total_success, (int )lq_sta->active_legacy_rate);
  desc = tmp___1 + desc;
  tmp___2 = sprintf(buff + (unsigned long )desc, "fixed rate 0x%X\n", lq_sta->dbg_fixed_rate);
  desc = tmp___2 + desc;
  tmp___3 = sprintf(buff + (unsigned long )desc, "valid_tx_ant %s%s%s\n", (int )(priv->nvm_data)->valid_tx_ant & 1 ? (char *)"ANT_A," : (char *)"",
                    ((unsigned long )(priv->nvm_data)->valid_tx_ant & 2UL) != 0UL ? (char *)"ANT_B," : (char *)"",
                    ((unsigned long )(priv->nvm_data)->valid_tx_ant & 4UL) != 0UL ? (char *)"ANT_C" : (char *)"");
  desc = tmp___3 + desc;
  tmp___4 = sprintf(buff + (unsigned long )desc, "lq type %s\n", (unsigned int )tbl->lq_type == 1U || (unsigned int )tbl->lq_type == 2U ? (char *)"legacy" : (char *)"HT");
  desc = tmp___4 + desc;
  if ((unsigned int )tbl->lq_type == 3U || ((unsigned int )tbl->lq_type == 4U || (unsigned int )tbl->lq_type == 5U)) {
    tmp___5 = sprintf(buff + (unsigned long )desc, " %s", (unsigned int )tbl->lq_type != 3U ? ((unsigned int )tbl->lq_type == 4U ? (char *)"MIMO2" : (char *)"MIMO3") : (char *)"SISO");
    desc = tmp___5 + desc;
    tmp___6 = sprintf(buff + (unsigned long )desc, " %s", (unsigned int )tbl->is_ht40 != 0U ? (char *)"40MHz" : (char *)"20MHz");
    desc = tmp___6 + desc;
    tmp___7 = sprintf(buff + (unsigned long )desc, " %s %s %s\n", (unsigned int )tbl->is_SGI != 0U ? (char *)"SGI" : (char *)"",
                      (unsigned int )lq_sta->is_green != 0U ? (char *)"GF enabled" : (char *)"",
                      (unsigned int )lq_sta->is_agg != 0U ? (char *)"AGG on" : (char *)"");
    desc = tmp___7 + desc;
  } else {

  }
  tmp___8 = sprintf(buff + (unsigned long )desc, "last tx rate=0x%X\n", lq_sta->last_rate_n_flags);
  desc = tmp___8 + desc;
  tmp___9 = sprintf(buff + (unsigned long )desc, "general:flags=0x%X mimo-d=%d s-ant0x%x d-ant=0x%x\n",
                    (int )lq_sta->lq.general_params.flags, (int )lq_sta->lq.general_params.mimo_delimiter,
                    (int )lq_sta->lq.general_params.single_stream_ant_msk, (int )lq_sta->lq.general_params.dual_stream_ant_msk);
  desc = tmp___9 + desc;
  tmp___10 = sprintf(buff + (unsigned long )desc, "agg:time_limit=%d dist_start_th=%d frame_cnt_limit=%d\n",
                     (int )lq_sta->lq.agg_params.agg_time_limit, (int )lq_sta->lq.agg_params.agg_dis_start_th,
                     (int )lq_sta->lq.agg_params.agg_frame_cnt_limit);
  desc = tmp___10 + desc;
  tmp___11 = sprintf(buff + (unsigned long )desc, "Start idx [0]=0x%x [1]=0x%x [2]=0x%x [3]=0x%x\n",
                     (int )lq_sta->lq.general_params.start_rate_index[0], (int )lq_sta->lq.general_params.start_rate_index[1],
                     (int )lq_sta->lq.general_params.start_rate_index[2], (int )lq_sta->lq.general_params.start_rate_index[3]);
  desc = tmp___11 + desc;
  i = 0;
  goto ldv_54308;
  ldv_54307: 
  index = iwl_hwrate_to_plcp_idx(lq_sta->lq.rs_table[i].rate_n_flags);
  if ((unsigned int )tbl->lq_type == 1U || (unsigned int )tbl->lq_type == 2U) {
    tmp___12 = sprintf(buff + (unsigned long )desc, " rate[%d] 0x%X %smbps\n", i,
                       lq_sta->lq.rs_table[i].rate_n_flags, (char const   *)(& iwl_rate_mcs[index].mbps));
    desc = tmp___12 + desc;
  } else {
    tmp___13 = sprintf(buff + (unsigned long )desc, " rate[%d] 0x%X %smbps (%s)\n",
                       i, lq_sta->lq.rs_table[i].rate_n_flags, (char const   *)(& iwl_rate_mcs[index].mbps),
                       (char const   *)(& iwl_rate_mcs[index].mcs));
    desc = tmp___13 + desc;
  }
  i = i + 1;
  ldv_54308: ;
  if (i <= 15) {
    goto ldv_54307;
  } else {

  }
  ret = simple_read_from_buffer((void *)user_buf, count, ppos, (void const   *)buff,
                                (size_t )desc);
  kfree((void const   *)buff);
  return (ret);
}
}
static struct file_operations  const  rs_sta_dbgfs_scale_table_ops  = 
     {0, & default_llseek, & rs_sta_dbgfs_scale_table_read, & rs_sta_dbgfs_scale_table_write,
    0, 0, 0, 0, 0, 0, 0, 0, & simple_open, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0};
static ssize_t rs_sta_dbgfs_stats_table_read(struct file *file , char *user_buf ,
                                             size_t count , loff_t *ppos ) 
{ 
  char *buff ;
  int desc ;
  int i ;
  int j ;
  ssize_t ret ;
  struct iwl_lq_sta *lq_sta ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  desc = 0;
  lq_sta = (struct iwl_lq_sta *)file->private_data;
  tmp = kmalloc(1024UL, 208U);
  buff = (char *)tmp;
  if ((unsigned long )buff == (unsigned long )((char *)0)) {
    return (-12L);
  } else {

  }
  i = 0;
  goto ldv_54327;
  ldv_54326: 
  tmp___0 = sprintf(buff + (unsigned long )desc, "%s type=%d SGI=%d HT40=%d DUP=%d GF=%d\nrate=0x%X\n",
                    (int )lq_sta->active_tbl == i ? (char *)"*" : (char *)"x", (unsigned int )lq_sta->lq_info[i].lq_type,
                    (int )lq_sta->lq_info[i].is_SGI, (int )lq_sta->lq_info[i].is_ht40,
                    (int )lq_sta->lq_info[i].is_dup, (int )lq_sta->is_green, lq_sta->lq_info[i].current_rate);
  desc = tmp___0 + desc;
  j = 0;
  goto ldv_54324;
  ldv_54323: 
  tmp___1 = sprintf(buff + (unsigned long )desc, "counter=%d success=%d %%=%d\n",
                    lq_sta->lq_info[i].win[j].counter, lq_sta->lq_info[i].win[j].success_counter,
                    lq_sta->lq_info[i].win[j].success_ratio);
  desc = tmp___1 + desc;
  j = j + 1;
  ldv_54324: ;
  if (j <= 12) {
    goto ldv_54323;
  } else {

  }
  i = i + 1;
  ldv_54327: ;
  if (i <= 1) {
    goto ldv_54326;
  } else {

  }
  ret = simple_read_from_buffer((void *)user_buf, count, ppos, (void const   *)buff,
                                (size_t )desc);
  kfree((void const   *)buff);
  return (ret);
}
}
static struct file_operations  const  rs_sta_dbgfs_stats_table_ops  = 
     {0, & default_llseek, & rs_sta_dbgfs_stats_table_read, 0, 0, 0, 0, 0, 0, 0, 0,
    0, & simple_open, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
static ssize_t rs_sta_dbgfs_rate_scale_data_read(struct file *file , char *user_buf ,
                                                 size_t count , loff_t *ppos ) 
{ 
  struct iwl_lq_sta *lq_sta ;
  struct iwl_scale_tbl_info *tbl ;
  char buff[120U] ;
  int desc ;
  int tmp ;
  int tmp___0 ;
  ssize_t tmp___1 ;

  {
  lq_sta = (struct iwl_lq_sta *)file->private_data;
  tbl = (struct iwl_scale_tbl_info *)(& lq_sta->lq_info) + (unsigned long )lq_sta->active_tbl;
  desc = 0;
  if ((unsigned int )tbl->lq_type == 3U || ((unsigned int )tbl->lq_type == 4U || (unsigned int )tbl->lq_type == 5U)) {
    tmp = sprintf((char *)(& buff) + (unsigned long )desc, "Bit Rate= %d Mb/s\n",
                  (int )*(tbl->expected_tpt + (unsigned long )lq_sta->last_txrate_idx));
    desc = tmp + desc;
  } else {
    tmp___0 = sprintf((char *)(& buff) + (unsigned long )desc, "Bit Rate= %d Mb/s\n",
                      (int )((unsigned char )iwl_rates[lq_sta->last_txrate_idx].ieee) >> 1);
    desc = tmp___0 + desc;
  }
  tmp___1 = simple_read_from_buffer((void *)user_buf, count, ppos, (void const   *)(& buff),
                                    (size_t )desc);
  return (tmp___1);
}
}
static struct file_operations  const  rs_sta_dbgfs_rate_scale_data_ops  = 
     {0, & default_llseek, & rs_sta_dbgfs_rate_scale_data_read, 0, 0, 0, 0, 0, 0, 0,
    0, 0, & simple_open, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
static void rs_add_debugfs(void *priv , void *priv_sta , struct dentry *dir ) 
{ 
  struct iwl_lq_sta *lq_sta ;

  {
  lq_sta = (struct iwl_lq_sta *)priv_sta;
  lq_sta->rs_sta_dbgfs_scale_table_file = debugfs_create_file("rate_scale_table",
                                                              384, dir, (void *)lq_sta,
                                                              & rs_sta_dbgfs_scale_table_ops);
  lq_sta->rs_sta_dbgfs_stats_table_file = debugfs_create_file("rate_stats_table",
                                                              256, dir, (void *)lq_sta,
                                                              & rs_sta_dbgfs_stats_table_ops);
  lq_sta->rs_sta_dbgfs_rate_scale_data_file = debugfs_create_file("rate_scale_data",
                                                                  256, dir, (void *)lq_sta,
                                                                  & rs_sta_dbgfs_rate_scale_data_ops);
  lq_sta->rs_sta_dbgfs_tx_agg_tid_en_file = debugfs_create_u8("tx_agg_tid_enable",
                                                              384, dir, & lq_sta->tx_agg_tid_en);
  return;
}
}
static void rs_remove_debugfs(void *priv , void *priv_sta ) 
{ 
  struct iwl_lq_sta *lq_sta ;

  {
  lq_sta = (struct iwl_lq_sta *)priv_sta;
  debugfs_remove(lq_sta->rs_sta_dbgfs_scale_table_file);
  debugfs_remove(lq_sta->rs_sta_dbgfs_stats_table_file);
  debugfs_remove(lq_sta->rs_sta_dbgfs_rate_scale_data_file);
  debugfs_remove(lq_sta->rs_sta_dbgfs_tx_agg_tid_en_file);
  return;
}
}
static void rs_rate_init_stub(void *priv_r , struct ieee80211_supported_band *sband ,
                              struct cfg80211_chan_def *chandef , struct ieee80211_sta *sta ,
                              void *priv_sta ) 
{ 


  {
  return;
}
}
static struct rate_control_ops  const  rs_ops  = 
     {"iwl-agn-rs", & rs_alloc, & rs_free, & rs_alloc_sta, & rs_rate_init_stub, 0, & rs_free_sta,
    0, & rs_tx_status, & rs_get_rate, & rs_add_debugfs, & rs_remove_debugfs, 0};
int iwlagn_rate_control_register(void) 
{ 
  int tmp ;

  {
  tmp = ieee80211_rate_control_register(& rs_ops);
  return (tmp);
}
}
void iwlagn_rate_control_unregister(void) 
{ 


  {
  ieee80211_rate_control_unregister(& rs_ops);
  return;
}
}
int ldv_retval_20  ;
    klee_make_symbolic(&ldv_retval_20, sizeof(int), "ldv_retval_20");
int ldv_retval_19  ;
    klee_make_symbolic(&ldv_retval_19, sizeof(int), "ldv_retval_19");
int ldv_retval_16  ;
    klee_make_symbolic(&ldv_retval_16, sizeof(int), "ldv_retval_16");
extern int ldv_release_67(void) ;
extern int ldv_release_68(void) ;
extern int ldv_release_66(void) ;
void ldv_file_operations_66(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
  tmp = ldv_init_zalloc(1000UL);
  rs_sta_dbgfs_rate_scale_data_ops_group1 = (struct inode *)tmp;
  tmp___0 = ldv_init_zalloc(504UL);
  rs_sta_dbgfs_rate_scale_data_ops_group2 = (struct file *)tmp___0;
  return;
}
}
void ldv_file_operations_68(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
  tmp = ldv_init_zalloc(1000UL);
  rs_sta_dbgfs_scale_table_ops_group1 = (struct inode *)tmp;
  tmp___0 = ldv_init_zalloc(504UL);
  rs_sta_dbgfs_scale_table_ops_group2 = (struct file *)tmp___0;
  return;
}
}
void ldv_initialize_rate_control_ops_65(void) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  tmp = ldv_init_zalloc(72UL);
  rs_ops_group0 = (struct ieee80211_supported_band *)tmp;
  tmp___0 = ldv_init_zalloc(216UL);
  rs_ops_group1 = (struct ieee80211_sta *)tmp___0;
  tmp___1 = ldv_init_zalloc(320UL);
  rs_ops_group2 = (struct dentry *)tmp___1;
  return;
}
}
void ldv_file_operations_67(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
  tmp = ldv_init_zalloc(1000UL);
  rs_sta_dbgfs_stats_table_ops_group1 = (struct inode *)tmp;
  tmp___0 = ldv_init_zalloc(504UL);
  rs_sta_dbgfs_stats_table_ops_group2 = (struct file *)tmp___0;
  return;
}
}
void ldv_main_exported_67(void) 
{ 
  int ldvarg186 ;
    klee_make_symbolic(&ldvarg186, sizeof(int), "ldvarg186");
  loff_t *ldvarg188 ;
  void *tmp ;
  loff_t ldvarg187 ;
  size_t ldvarg189 ;
  char *ldvarg190 ;
  void *tmp___0 ;
  int tmp___1 ;

  {
  tmp = ldv_init_zalloc(8UL);
  ldvarg188 = (loff_t *)tmp;
  tmp___0 = ldv_init_zalloc(1UL);
  ldvarg190 = (char *)tmp___0;
  ldv_memset((void *)(& ldvarg186), 0, 4UL);
  ldv_memset((void *)(& ldvarg187), 0, 8UL);
  ldv_memset((void *)(& ldvarg189), 0, 8UL);
  tmp___1 = __VERIFIER_nondet_int();
  switch (tmp___1) {
  case 0: ;
  if (ldv_state_variable_67 == 2) {
    rs_sta_dbgfs_stats_table_read(rs_sta_dbgfs_stats_table_ops_group2, ldvarg190,
                                  ldvarg189, ldvarg188);
    ldv_state_variable_67 = 2;
  } else {

  }
  goto ldv_54396;
  case 1: ;
  if (ldv_state_variable_67 == 1) {
    ldv_retval_19 = simple_open(rs_sta_dbgfs_stats_table_ops_group1, rs_sta_dbgfs_stats_table_ops_group2);
    if (ldv_retval_19 == 0) {
      ldv_state_variable_67 = 2;
      ref_cnt = ref_cnt + 1;
    } else {

    }
  } else {

  }
  goto ldv_54396;
  case 2: ;
  if (ldv_state_variable_67 == 2) {
    default_llseek(rs_sta_dbgfs_stats_table_ops_group2, ldvarg187, ldvarg186);
    ldv_state_variable_67 = 2;
  } else {

  }
  goto ldv_54396;
  case 3: ;
  if (ldv_state_variable_67 == 2) {
    ldv_release_67();
    ldv_state_variable_67 = 1;
    ref_cnt = ref_cnt - 1;
  } else {

  }
  goto ldv_54396;
  default: 
  ldv_stop();
  }
  ldv_54396: ;
  return;
}
}
void ldv_main_exported_66(void) 
{ 
  loff_t *ldvarg169 ;
  void *tmp ;
  loff_t ldvarg168 ;
  char *ldvarg171 ;
  void *tmp___0 ;
  size_t ldvarg170 ;
  int ldvarg167 ;
    klee_make_symbolic(&ldvarg167, sizeof(int), "ldvarg167");
  int tmp___1 ;

  {
  tmp = ldv_init_zalloc(8UL);
  ldvarg169 = (loff_t *)tmp;
  tmp___0 = ldv_init_zalloc(1UL);
  ldvarg171 = (char *)tmp___0;
  ldv_memset((void *)(& ldvarg168), 0, 8UL);
  ldv_memset((void *)(& ldvarg170), 0, 8UL);
  ldv_memset((void *)(& ldvarg167), 0, 4UL);
  tmp___1 = __VERIFIER_nondet_int();
  switch (tmp___1) {
  case 0: ;
  if (ldv_state_variable_66 == 2) {
    rs_sta_dbgfs_rate_scale_data_read(rs_sta_dbgfs_rate_scale_data_ops_group2, ldvarg171,
                                      ldvarg170, ldvarg169);
    ldv_state_variable_66 = 2;
  } else {

  }
  goto ldv_54410;
  case 1: ;
  if (ldv_state_variable_66 == 1) {
    ldv_retval_16 = simple_open(rs_sta_dbgfs_rate_scale_data_ops_group1, rs_sta_dbgfs_rate_scale_data_ops_group2);
    if (ldv_retval_16 == 0) {
      ldv_state_variable_66 = 2;
      ref_cnt = ref_cnt + 1;
    } else {

    }
  } else {

  }
  goto ldv_54410;
  case 2: ;
  if (ldv_state_variable_66 == 2) {
    default_llseek(rs_sta_dbgfs_rate_scale_data_ops_group2, ldvarg168, ldvarg167);
    ldv_state_variable_66 = 2;
  } else {

  }
  goto ldv_54410;
  case 3: ;
  if (ldv_state_variable_66 == 2) {
    ldv_release_66();
    ldv_state_variable_66 = 1;
    ref_cnt = ref_cnt - 1;
  } else {

  }
  goto ldv_54410;
  default: 
  ldv_stop();
  }
  ldv_54410: ;
  return;
}
}
void ldv_main_exported_68(void) 
{ 
  loff_t ldvarg192 ;
  char *ldvarg198 ;
  void *tmp ;
  loff_t *ldvarg193 ;
  void *tmp___0 ;
  size_t ldvarg197 ;
  size_t ldvarg194 ;
  loff_t *ldvarg196 ;
  void *tmp___1 ;
  char *ldvarg195 ;
  void *tmp___2 ;
  int ldvarg191 ;
    klee_make_symbolic(&ldvarg191, sizeof(int), "ldvarg191");
  int tmp___3 ;

  {
  tmp = ldv_init_zalloc(1UL);
  ldvarg198 = (char *)tmp;
  tmp___0 = ldv_init_zalloc(8UL);
  ldvarg193 = (loff_t *)tmp___0;
  tmp___1 = ldv_init_zalloc(8UL);
  ldvarg196 = (loff_t *)tmp___1;
  tmp___2 = ldv_init_zalloc(1UL);
  ldvarg195 = (char *)tmp___2;
  ldv_memset((void *)(& ldvarg192), 0, 8UL);
  ldv_memset((void *)(& ldvarg197), 0, 8UL);
  ldv_memset((void *)(& ldvarg194), 0, 8UL);
  ldv_memset((void *)(& ldvarg191), 0, 4UL);
  tmp___3 = __VERIFIER_nondet_int();
  switch (tmp___3) {
  case 0: ;
  if (ldv_state_variable_68 == 1) {
    rs_sta_dbgfs_scale_table_write(rs_sta_dbgfs_scale_table_ops_group2, (char const   *)ldvarg198,
                                   ldvarg197, ldvarg196);
    ldv_state_variable_68 = 1;
  } else {

  }
  if (ldv_state_variable_68 == 2) {
    rs_sta_dbgfs_scale_table_write(rs_sta_dbgfs_scale_table_ops_group2, (char const   *)ldvarg198,
                                   ldvarg197, ldvarg196);
    ldv_state_variable_68 = 2;
  } else {

  }
  goto ldv_54427;
  case 1: ;
  if (ldv_state_variable_68 == 2) {
    rs_sta_dbgfs_scale_table_read(rs_sta_dbgfs_scale_table_ops_group2, ldvarg195,
                                  ldvarg194, ldvarg193);
    ldv_state_variable_68 = 2;
  } else {

  }
  goto ldv_54427;
  case 2: ;
  if (ldv_state_variable_68 == 1) {
    ldv_retval_20 = simple_open(rs_sta_dbgfs_scale_table_ops_group1, rs_sta_dbgfs_scale_table_ops_group2);
    if (ldv_retval_20 == 0) {
      ldv_state_variable_68 = 2;
      ref_cnt = ref_cnt + 1;
    } else {

    }
  } else {

  }
  goto ldv_54427;
  case 3: ;
  if (ldv_state_variable_68 == 2) {
    default_llseek(rs_sta_dbgfs_scale_table_ops_group2, ldvarg192, ldvarg191);
    ldv_state_variable_68 = 2;
  } else {

  }
  goto ldv_54427;
  case 4: ;
  if (ldv_state_variable_68 == 2) {
    ldv_release_68();
    ldv_state_variable_68 = 1;
    ref_cnt = ref_cnt - 1;
  } else {

  }
  goto ldv_54427;
  default: 
  ldv_stop();
  }
  ldv_54427: ;
  return;
}
}
void ldv_main_exported_65(void) 
{ 
  void *ldvarg75 ;
  void *tmp ;
  struct sk_buff *ldvarg82 ;
  void *tmp___0 ;
  void *ldvarg76 ;
  void *tmp___1 ;
  void *ldvarg74 ;
  void *tmp___2 ;
  void *ldvarg69 ;
  void *tmp___3 ;
  void *ldvarg68 ;
  void *tmp___4 ;
  gfp_t ldvarg78 ;
  void *ldvarg70 ;
  void *tmp___5 ;
  void *ldvarg73 ;
  void *tmp___6 ;
  void *ldvarg85 ;
  void *tmp___7 ;
  void *ldvarg81 ;
  void *tmp___8 ;
  void *ldvarg83 ;
  void *tmp___9 ;
  void *ldvarg79 ;
  void *tmp___10 ;
  struct ieee80211_tx_rate_control *ldvarg72 ;
  void *tmp___11 ;
  void *ldvarg71 ;
  void *tmp___12 ;
  void *ldvarg80 ;
  void *tmp___13 ;
  struct ieee80211_hw *ldvarg67 ;
  void *tmp___14 ;
  struct cfg80211_chan_def *ldvarg84 ;
  void *tmp___15 ;
  void *ldvarg77 ;
  void *tmp___16 ;
  int tmp___17 ;

  {
  tmp = ldv_init_zalloc(1UL);
  ldvarg75 = tmp;
  tmp___0 = ldv_init_zalloc(232UL);
  ldvarg82 = (struct sk_buff *)tmp___0;
  tmp___1 = ldv_init_zalloc(1UL);
  ldvarg76 = tmp___1;
  tmp___2 = ldv_init_zalloc(1UL);
  ldvarg74 = tmp___2;
  tmp___3 = ldv_init_zalloc(1UL);
  ldvarg69 = tmp___3;
  tmp___4 = ldv_init_zalloc(1UL);
  ldvarg68 = tmp___4;
  tmp___5 = ldv_init_zalloc(1UL);
  ldvarg70 = tmp___5;
  tmp___6 = ldv_init_zalloc(1UL);
  ldvarg73 = tmp___6;
  tmp___7 = ldv_init_zalloc(1UL);
  ldvarg85 = tmp___7;
  tmp___8 = ldv_init_zalloc(1UL);
  ldvarg81 = tmp___8;
  tmp___9 = ldv_init_zalloc(1UL);
  ldvarg83 = tmp___9;
  tmp___10 = ldv_init_zalloc(1UL);
  ldvarg79 = tmp___10;
  tmp___11 = ldv_init_zalloc(64UL);
  ldvarg72 = (struct ieee80211_tx_rate_control *)tmp___11;
  tmp___12 = ldv_init_zalloc(1UL);
  ldvarg71 = tmp___12;
  tmp___13 = ldv_init_zalloc(1UL);
  ldvarg80 = tmp___13;
  tmp___14 = ldv_init_zalloc(160UL);
  ldvarg67 = (struct ieee80211_hw *)tmp___14;
  tmp___15 = ldv_init_zalloc(24UL);
  ldvarg84 = (struct cfg80211_chan_def *)tmp___15;
  tmp___16 = ldv_init_zalloc(1UL);
  ldvarg77 = tmp___16;
  ldv_memset((void *)(& ldvarg78), 0, 4UL);
  tmp___17 = __VERIFIER_nondet_int();
  switch (tmp___17) {
  case 0: ;
  if (ldv_state_variable_65 == 1) {
    rs_rate_init_stub(ldvarg83, rs_ops_group0, ldvarg84, rs_ops_group1, ldvarg85);
    ldv_state_variable_65 = 1;
  } else {

  }
  goto ldv_54456;
  case 1: ;
  if (ldv_state_variable_65 == 1) {
    rs_tx_status(ldvarg81, rs_ops_group0, rs_ops_group1, ldvarg80, ldvarg82);
    ldv_state_variable_65 = 1;
  } else {

  }
  goto ldv_54456;
  case 2: ;
  if (ldv_state_variable_65 == 1) {
    rs_free(ldvarg79);
    ldv_state_variable_65 = 1;
  } else {

  }
  goto ldv_54456;
  case 3: ;
  if (ldv_state_variable_65 == 1) {
    rs_alloc_sta(ldvarg77, rs_ops_group1, ldvarg78);
    ldv_state_variable_65 = 1;
  } else {

  }
  goto ldv_54456;
  case 4: ;
  if (ldv_state_variable_65 == 1) {
    rs_free_sta(ldvarg75, rs_ops_group1, ldvarg76);
    ldv_state_variable_65 = 1;
  } else {

  }
  goto ldv_54456;
  case 5: ;
  if (ldv_state_variable_65 == 1) {
    rs_get_rate(ldvarg73, rs_ops_group1, ldvarg74, ldvarg72);
    ldv_state_variable_65 = 1;
  } else {

  }
  goto ldv_54456;
  case 6: ;
  if (ldv_state_variable_65 == 1) {
    rs_add_debugfs(ldvarg70, ldvarg71, rs_ops_group2);
    ldv_state_variable_65 = 1;
  } else {

  }
  goto ldv_54456;
  case 7: ;
  if (ldv_state_variable_65 == 1) {
    rs_remove_debugfs(ldvarg68, ldvarg69);
    ldv_state_variable_65 = 1;
  } else {

  }
  goto ldv_54456;
  case 8: ;
  if (ldv_state_variable_65 == 1) {
    rs_alloc(ldvarg67, rs_ops_group2);
    ldv_state_variable_65 = 1;
  } else {

  }
  goto ldv_54456;
  default: 
  ldv_stop();
  }
  ldv_54456: ;
  return;
}
}
bool ldv_queue_work_on_45(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_7(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_delayed_work_on_46(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_7(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_work_on_47(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_7(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
void ldv_flush_workqueue_48(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
  flush_workqueue(ldv_func_arg1);
  call_and_disable_all_7(2);
  return;
}
}
bool ldv_queue_delayed_work_on_49(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_7(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
__inline static long ldv__builtin_expect(long exp , long c ) ;
__inline static void __clear_bit(long nr , unsigned long volatile   *addr ) 
{ 


  {
  __asm__  volatile   ("btr %1,%0": "+m" (*((long volatile   *)addr)): "Ir" (nr));
  return;
}
}
__inline static __u64 __arch_swab64(__u64 val ) 
{ 


  {
  __asm__  ("bswapq %0": "=r" (val): "0" (val));
  return (val);
}
}
__inline static __u64 __fswab64(__u64 val ) 
{ 
  __u64 tmp ;

  {
  tmp = __arch_swab64(val);
  return (tmp);
}
}
__inline static __u64 __swab64p(__u64 const   *p ) 
{ 
  __u64 tmp ;

  {
  tmp = __fswab64(*p);
  return (tmp);
}
}
__inline static __u64 __be64_to_cpup(__be64 const   *p ) 
{ 
  __u64 tmp ;

  {
  tmp = __swab64p(p);
  return (tmp);
}
}
__inline static unsigned long arch_local_save_flags___0(void) 
{ 
  unsigned long __ret ;
  unsigned long __edi ;
  unsigned long __esi ;
  unsigned long __edx ;
  unsigned long __ecx ;
  unsigned long __eax ;
  long tmp ;

  {
  __edi = __edi;
  __esi = __esi;
  __edx = __edx;
  __ecx = __ecx;
  __eax = __eax;
  tmp = ldv__builtin_expect((unsigned long )pv_irq_ops.save_fl.func == (unsigned long )((void *)0),
                         0L);
  if (tmp != 0L) {
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"./arch/x86/include/asm/paravirt.h"),
                         "i" (831), "i" (12UL));
    ldv_4860: ;
    goto ldv_4860;
  } else {

  }
  __asm__  volatile   ("771:\n\tcall *%c2;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c1\n  .byte 772b-771b\n  .short %c3\n.popsection\n": "=a" (__eax): [paravirt_typenum] "i" (43UL),
                       [paravirt_opptr] "i" (& pv_irq_ops.save_fl.func), [paravirt_clobber] "i" (1): "memory",
                       "cc");
  __ret = __eax;
  return (__ret);
}
}
__inline static bool static_key_false___0(struct static_key *key ) 
{ 
  int tmp ;
  long tmp___0 ;

  {
  tmp = static_key_count(key);
  tmp___0 = ldv__builtin_expect(tmp > 0, 0L);
  if (tmp___0 != 0L) {
    return (1);
  } else {

  }
  return (0);
}
}
__inline static int rcu_read_lock_sched_held___0(void) 
{ 
  int lockdep_opinion ;
  int tmp ;
  bool tmp___0 ;
  int tmp___1 ;
  bool tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  unsigned long _flags ;
  int tmp___5 ;
  int tmp___6 ;

  {
  lockdep_opinion = 0;
  tmp = debug_lockdep_rcu_enabled();
  if (tmp == 0) {
    return (1);
  } else {

  }
  tmp___0 = rcu_is_watching();
  if (tmp___0) {
    tmp___1 = 0;
  } else {
    tmp___1 = 1;
  }
  if (tmp___1) {
    return (0);
  } else {

  }
  tmp___2 = rcu_lockdep_current_cpu_online();
  if (tmp___2) {
    tmp___3 = 0;
  } else {
    tmp___3 = 1;
  }
  if (tmp___3) {
    return (0);
  } else {

  }
  if (debug_locks != 0) {
    lockdep_opinion = lock_is_held(& rcu_sched_lock_map);
  } else {

  }
  if (lockdep_opinion != 0) {
    tmp___6 = 1;
  } else {
    tmp___4 = preempt_count();
    if (tmp___4 != 0) {
      tmp___6 = 1;
    } else {
      _flags = arch_local_save_flags___0();
      tmp___5 = arch_irqs_disabled_flags(_flags);
      if (tmp___5 != 0) {
        tmp___6 = 1;
      } else {
        tmp___6 = 0;
      }
    }
  }
  return (tmp___6);
}
}
bool ldv_queue_work_on_59(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_work_on_61(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_delayed_work_on_60(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
bool ldv_queue_delayed_work_on_63(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
void ldv_flush_workqueue_62(struct workqueue_struct *ldv_func_arg1 ) ;
void ldv_flush_workqueue_64(struct workqueue_struct *ldv_func_arg1 ) ;
__inline static bool queue_work___1(struct workqueue_struct *wq , struct work_struct *work ) 
{ 
  bool tmp ;

  {
  tmp = ldv_queue_work_on_59(8192, wq, work);
  return (tmp);
}
}
void ldv_initialize_ieee80211_ops_64(void) ;
__inline static bool device_can_wakeup(struct device *dev ) 
{ 


  {
  return ((int )dev->power.can_wakeup != 0);
}
}
extern int device_set_wakeup_enable(struct device * , bool  ) ;
__inline static enum nl80211_channel_type cfg80211_get_chandef_type(struct cfg80211_chan_def  const  *chandef ) 
{ 
  int __ret_warn_on ;
  long tmp ;

  {
  switch ((unsigned int )chandef->width) {
  case 0U: ;
  return (0);
  case 1U: ;
  return (1);
  case 2U: ;
  if ((unsigned int )chandef->center_freq1 > (unsigned int )(chandef->chan)->center_freq) {
    return (3);
  } else {

  }
  return (2);
  default: 
  __ret_warn_on = 1;
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp != 0L) {
    warn_slowpath_null("include/net/cfg80211.h", 423);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  return (0);
  }
}
}
__inline static void _ieee80211_hw_set(struct ieee80211_hw *hw , enum ieee80211_hw_flags flg ) 
{ 


  {
  return;
}
}
extern struct ieee80211_hw *ieee80211_alloc_hw_nm(size_t  , struct ieee80211_ops  const  * ,
                                                  char const   * ) ;
__inline static struct ieee80211_hw *ieee80211_alloc_hw(size_t priv_data_len , struct ieee80211_ops  const  *ops ) 
{ 
  struct ieee80211_hw *tmp ;

  {
  tmp = ieee80211_alloc_hw_nm(priv_data_len, ops, (char const   *)0);
  return (tmp);
}
}
__inline static struct ieee80211_hw *ldv_ieee80211_alloc_hw_65(size_t priv_data_len ,
                                                               struct ieee80211_ops  const  *ops ) ;
extern int ieee80211_register_hw(struct ieee80211_hw * ) ;
extern void ieee80211_unregister_hw(struct ieee80211_hw * ) ;
extern void ieee80211_sta_block_awake(struct ieee80211_hw * , struct ieee80211_sta * ,
                                      bool  ) ;
extern void ieee80211_resume_disconnect(struct ieee80211_vif * ) ;
extern void ieee80211_chswitch_done(struct ieee80211_vif * , bool  ) ;
__inline static enum nl80211_iftype ieee80211_iftype_p2p(enum nl80211_iftype type ,
                                                         bool p2p ) 
{ 


  {
  if ((int )p2p) {
    switch ((unsigned int )type) {
    case 2U: ;
    return (8);
    case 3U: ;
    return (9);
    default: ;
    goto ldv_49953;
    }
    ldv_49953: ;
  } else {

  }
  return (type);
}
}
__inline static enum nl80211_iftype ieee80211_vif_type_p2p(struct ieee80211_vif *vif ) 
{ 
  enum nl80211_iftype tmp ;

  {
  tmp = ieee80211_iftype_p2p(vif->type, (int )vif->p2p);
  return (tmp);
}
}
extern void ieee80211_report_wowlan_wakeup(struct ieee80211_vif * , struct cfg80211_wowlan_wakeup * ,
                                           gfp_t  ) ;
__inline static u32 iwl_rx_packet_len(struct iwl_rx_packet  const  *pkt ) 
{ 


  {
  return ((u32 )pkt->len_n_flags & 16383U);
}
}
__inline static u32 iwl_rx_packet_payload_len(struct iwl_rx_packet  const  *pkt ) 
{ 
  u32 tmp ;

  {
  tmp = iwl_rx_packet_len(pkt);
  return (tmp - 4U);
}
}
__inline static void iwl_trans_d3_suspend(struct iwl_trans *trans , bool test ) 
{ 


  {
  __might_sleep("drivers/net/wireless/iwlwifi/dvm/../iwl-trans.h", 732, 0);
  (*((trans->ops)->d3_suspend))(trans, (int )test);
  return;
}
}
__inline static int iwl_trans_d3_resume(struct iwl_trans *trans , enum iwl_d3_status *status ,
                                        bool test ) 
{ 
  int tmp ;

  {
  __might_sleep("drivers/net/wireless/iwlwifi/dvm/../iwl-trans.h", 740, 0);
  tmp = (*((trans->ops)->d3_resume))(trans, status, (int )test);
  return (tmp);
}
}
__inline static int iwl_trans_wait_tx_queue_empty(struct iwl_trans *trans , u32 txqs ) 
{ 
  long tmp ;
  int tmp___0 ;

  {
  tmp = ldv__builtin_expect((unsigned int )trans->state != 1U, 0L);
  if (tmp != 0L) {
    __iwl_err(trans->dev, 0, 0, "%s bad state = %d\n", "iwl_trans_wait_tx_queue_empty",
              (unsigned int )trans->state);
  } else {

  }
  tmp___0 = (*((trans->ops)->wait_tx_queue_empty))(trans, txqs);
  return (tmp___0);
}
}
__inline static void trace_iwlwifi_dev_iowrite32___0(struct device  const  *dev ,
                                                     u32 offs , u32 val ) 
{ 
  struct tracepoint_func *it_func_ptr ;
  void *it_func ;
  void *__data ;
  struct tracepoint_func *________p1 ;
  struct tracepoint_func *_________p1 ;
  union __anonunion___u_398___0 __u ;
  bool __warned ;
  int tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  struct tracepoint_func *________p1___0 ;
  struct tracepoint_func *_________p1___0 ;
  union __anonunion___u_400___0 __u___0 ;
  bool __warned___0 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  tmp___1 = static_key_false___0(& __tracepoint_iwlwifi_dev_iowrite32.key);
  if ((int )tmp___1) {
    rcu_read_lock_sched_notrace();
    __read_once_size((void const volatile   *)(& __tracepoint_iwlwifi_dev_iowrite32.funcs),
                     (void *)(& __u.__c), 8);
    _________p1 = __u.__val;
    ________p1 = _________p1;
    tmp = debug_lockdep_rcu_enabled();
    if (tmp != 0 && ! __warned) {
      tmp___0 = rcu_read_lock_sched_held___0();
      if (tmp___0 == 0) {
        __warned = 1;
        lockdep_rcu_suspicious("drivers/net/wireless/iwlwifi/dvm/../iwl-devtrace-io.h",
                               84, "suspicious rcu_dereference_check() usage");
      } else {

      }
    } else {

    }
    it_func_ptr = ________p1;
    if ((unsigned long )it_func_ptr != (unsigned long )((struct tracepoint_func *)0)) {
      ldv_51434: 
      it_func = it_func_ptr->func;
      __data = it_func_ptr->data;
      (*((void (*)(void * , struct device  const  * , u32  , u32  ))it_func))(__data,
                                                                              dev,
                                                                              offs,
                                                                              val);
      it_func_ptr = it_func_ptr + 1;
      if ((unsigned long )it_func_ptr->func != (unsigned long )((void *)0)) {
        goto ldv_51434;
      } else {

      }

    } else {

    }
    rcu_read_unlock_sched_notrace();
  } else {

  }
  rcu_read_lock_sched_notrace();
  __read_once_size((void const volatile   *)(& __tracepoint_iwlwifi_dev_iowrite32.funcs),
                   (void *)(& __u___0.__c), 8);
  _________p1___0 = __u___0.__val;
  ________p1___0 = _________p1___0;
  tmp___2 = debug_lockdep_rcu_enabled();
  if (tmp___2 != 0 && ! __warned___0) {
    tmp___3 = rcu_read_lock_sched_held___0();
    if (tmp___3 == 0) {
      __warned___0 = 1;
      lockdep_rcu_suspicious("drivers/net/wireless/iwlwifi/dvm/../iwl-devtrace-io.h",
                             84, "suspicious rcu_dereference_check() usage");
    } else {

    }
  } else {

  }
  rcu_read_unlock_sched_notrace();
  return;
}
}
__inline static void iwl_write32___0(struct iwl_trans *trans , u32 ofs , u32 val ) 
{ 


  {
  trace_iwlwifi_dev_iowrite32___0((struct device  const  *)trans->dev, ofs, val);
  iwl_trans_write32(trans, ofs, val);
  return;
}
}
extern void iwl_init_notification_wait(struct iwl_notif_wait_data * , struct iwl_notification_wait * ,
                                       u8 const   * , int  , bool (*)(struct iwl_notif_wait_data * ,
                                                                      struct iwl_rx_packet * ,
                                                                      void * ) , void * ) ;
extern int iwl_wait_notification(struct iwl_notif_wait_data * , struct iwl_notification_wait * ,
                                 unsigned long  ) ;
void iwlagn_led_enable(struct iwl_priv *priv ) ;
void iwl_leds_init(struct iwl_priv *priv ) ;
void iwl_leds_exit(struct iwl_priv *priv ) ;
__inline static struct iwl_rxon_context *iwl_rxon_ctx_from_vif(struct ieee80211_vif *vif ) 
{ 
  struct iwl_vif_priv *vif_priv ;

  {
  vif_priv = (struct iwl_vif_priv *)(& vif->drv_priv);
  return (vif_priv->ctx);
}
}
struct ieee80211_ops  const  iwlagn_hw_ops ;
int iwlagn_mac_config(struct ieee80211_hw *hw , u32 changed ) ;
void iwlagn_bss_info_changed(struct ieee80211_hw *hw , struct ieee80211_vif *vif ,
                             struct ieee80211_bss_conf *bss_conf , u32 changes ) ;
void iwl_set_rxon_ht(struct iwl_priv *priv , struct iwl_ht_config *ht_conf ) ;
void iwl_set_rxon_channel(struct iwl_priv *priv , struct ieee80211_channel *ch , struct iwl_rxon_context *ctx ) ;
void iwl_set_flags_for_band(struct iwl_priv *priv , struct iwl_rxon_context *ctx ,
                            enum ieee80211_band band , struct ieee80211_vif *vif ) ;
int iwl_run_init_ucode(struct iwl_priv *priv ) ;
int iwl_load_ucode_wait_alive(struct iwl_priv *priv , enum iwl_ucode_type ucode_type ) ;
int iwlagn_txfifo_flush(struct iwl_priv *priv , u32 scd_q_msk ) ;
int iwlagn_suspend(struct iwl_priv *priv , struct cfg80211_wowlan *wowlan ) ;
void iwl_chswitch_done(struct iwl_priv *priv , bool is_success ) ;
int iwlagn_tx_skb(struct iwl_priv *priv , struct ieee80211_sta *sta , struct sk_buff *skb ) ;
int iwlagn_tx_agg_start(struct iwl_priv *priv , struct ieee80211_vif *vif , struct ieee80211_sta *sta ,
                        u16 tid , u16 *ssn ) ;
int iwlagn_tx_agg_oper(struct iwl_priv *priv , struct ieee80211_vif *vif , struct ieee80211_sta *sta ,
                       u16 tid , u8 buf_size ) ;
int iwlagn_tx_agg_stop(struct iwl_priv *priv , struct ieee80211_vif *vif , struct ieee80211_sta *sta ,
                       u16 tid ) ;
int iwlagn_tx_agg_flush(struct iwl_priv *priv , struct ieee80211_vif *vif , struct ieee80211_sta *sta ,
                        u16 tid ) ;
void iwl_force_scan_end(struct iwl_priv *priv ) ;
int iwl_scan_initiate(struct iwl_priv *priv , struct ieee80211_vif *vif , enum iwl_scan_type scan_type ,
                      enum ieee80211_band band ) ;
int iwl_send_add_sta(struct iwl_priv *priv , struct iwl_addsta_cmd *sta , u8 flags ) ;
int iwl_add_station_common(struct iwl_priv *priv , struct iwl_rxon_context *ctx ,
                           u8 const   *addr , bool is_ap , struct ieee80211_sta *sta ,
                           u8 *sta_id_r ) ;
int iwl_remove_station(struct iwl_priv *priv , u8 const   sta_id , u8 const   *addr ) ;
void iwl_deactivate_station(struct iwl_priv *priv , u8 const   sta_id , u8 const   *addr ) ;
int iwl_sta_update_ht(struct iwl_priv *priv , struct iwl_rxon_context *ctx , struct ieee80211_sta *sta ) ;
__inline static int iwl_sta_id(struct ieee80211_sta *sta ) 
{ 
  int __ret_warn_on ;
  long tmp ;
  long tmp___0 ;

  {
  __ret_warn_on = (unsigned long )sta == (unsigned long )((struct ieee80211_sta *)0);
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/inst/current/envs/linux-4.2-rc1.tar.xz/linux-4.2-rc1/drivers/net/wireless/iwlwifi/dvm/agn.h",
                       346);
  } else {

  }
  tmp___0 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp___0 != 0L) {
    return (255);
  } else {

  }
  return ((int )((struct iwl_station_priv *)(& sta->drv_priv))->sta_id);
}
}
int iwlagn_alloc_bcast_station(struct iwl_priv *priv , struct iwl_rxon_context *ctx ) ;
int iwl_remove_default_wep_key(struct iwl_priv *priv , struct iwl_rxon_context *ctx ,
                               struct ieee80211_key_conf *keyconf ) ;
int iwl_set_default_wep_key(struct iwl_priv *priv , struct iwl_rxon_context *ctx ,
                            struct ieee80211_key_conf *keyconf ) ;
int iwl_set_dynamic_key(struct iwl_priv *priv , struct iwl_rxon_context *ctx , struct ieee80211_key_conf *keyconf ,
                        struct ieee80211_sta *sta ) ;
int iwl_remove_dynamic_key(struct iwl_priv *priv , struct iwl_rxon_context *ctx ,
                           struct ieee80211_key_conf *keyconf , struct ieee80211_sta *sta ) ;
void iwl_update_tkip_key(struct iwl_priv *priv , struct ieee80211_vif *vif , struct ieee80211_key_conf *keyconf ,
                         struct ieee80211_sta *sta , u32 iv32 , u16 *phase1key ) ;
int iwl_sta_rx_agg_start(struct iwl_priv *priv , struct ieee80211_sta *sta , int tid ,
                         u16 ssn ) ;
int iwl_sta_rx_agg_stop(struct iwl_priv *priv , struct ieee80211_sta *sta , int tid ) ;
static struct ieee80211_iface_limit  const  iwlagn_sta_ap_limits[2U]  = {      {1U, 4U}, 
        {1U, 8U}};
static struct ieee80211_iface_limit  const  iwlagn_2sta_limits[1U]  = {      {2U, 4U}};
static struct ieee80211_iface_combination  const  iwlagn_iface_combinations_dualmode[2U]  = {      {(struct ieee80211_iface_limit  const  *)(& iwlagn_sta_ap_limits),
      1U, 2U, 2U, 1, (unsigned char)0, (unsigned char)0}, 
        {(struct ieee80211_iface_limit  const  *)(& iwlagn_2sta_limits), 1U, 2U, 1U,
      (_Bool)0, (unsigned char)0, (unsigned char)0}};
int iwlagn_mac_setup_register(struct iwl_priv *priv , struct iwl_ucode_capabilities  const  *capa ) 
{ 
  int ret ;
  struct ieee80211_hw *hw ;
  struct iwl_rxon_context *ctx ;
  bool tmp ;

  {
  hw = priv->hw;
  hw->rate_control_algorithm = "iwl-agn-rs";
  _ieee80211_hw_set(hw, 4);
  _ieee80211_hw_set(hw, 7);
  _ieee80211_hw_set(hw, 5);
  _ieee80211_hw_set(hw, 6);
  _ieee80211_hw_set(hw, 16);
  _ieee80211_hw_set(hw, 18);
  _ieee80211_hw_set(hw, 8);
  _ieee80211_hw_set(hw, 10);
  _ieee80211_hw_set(hw, 15);
  _ieee80211_hw_set(hw, 12);
  hw->offchannel_tx_hw_queue = 10U;
  hw->radiotap_mcs_details = (u8 )((unsigned int )hw->radiotap_mcs_details | 8U);
  if ((int )(priv->nvm_data)->sku_cap_11n_enable) {
    (hw->wiphy)->features = (hw->wiphy)->features | 50331648U;
  } else {

  }
  if (((unsigned int )(priv->fw)->ucode_capa.flags & 4U) != 0U && iwlwifi_mod_params.sw_crypto == 0) {
    _ieee80211_hw_set(hw, 11);
  } else {

  }
  hw->sta_data_size = 1904;
  hw->vif_data_size = 16;
  ctx = (struct iwl_rxon_context *)(& priv->contexts);
  goto ldv_55236;
  ldv_55235: ;
  if ((int )((unsigned long )priv->valid_contexts >> (int )ctx->ctxid) & 1) {
    (hw->wiphy)->interface_modes = (int )(hw->wiphy)->interface_modes | (int )((u16 )ctx->interface_modes);
    (hw->wiphy)->interface_modes = (int )(hw->wiphy)->interface_modes | (int )((u16 )ctx->exclusive_interface_modes);
  } else {

  }
  ctx = ctx + 1;
  ldv_55236: ;
  if ((unsigned long )((struct iwl_rxon_context *)(& priv->contexts) + 2UL) > (unsigned long )ctx) {
    goto ldv_55235;
  } else {

  }

  if (((unsigned long )(hw->wiphy)->interface_modes & 8UL) != 0UL) {
    (hw->wiphy)->iface_combinations = (struct ieee80211_iface_combination  const  *)(& iwlagn_iface_combinations_dualmode);
    (hw->wiphy)->n_iface_combinations = 2;
  } else {

  }
  (hw->wiphy)->flags = (hw->wiphy)->flags | 256U;
  (hw->wiphy)->regulatory_flags = (hw->wiphy)->regulatory_flags | 5U;
  if (((unsigned int )(priv->fw)->img[2].sec[0].len != 0U && (unsigned long )((priv->trans)->ops)->d3_suspend != (unsigned long )((void (*/* const  */)(struct iwl_trans * ,
                                                                                                                                                        bool  ))0)) && (unsigned long )((priv->trans)->ops)->d3_resume != (unsigned long )((int (*/* const  */)(struct iwl_trans * ,
                                                                                                                                                                                                                                                                enum iwl_d3_status * ,
                                                                                                                                                                                                                                                                bool  ))0)) {
    tmp = device_can_wakeup((priv->trans)->dev);
    if ((int )tmp) {
      priv->wowlan_support.flags = 166U;
      if (iwlwifi_mod_params.sw_crypto == 0) {
        priv->wowlan_support.flags = priv->wowlan_support.flags | 24U;
      } else {

      }
      priv->wowlan_support.n_patterns = 20;
      priv->wowlan_support.pattern_min_len = 16;
      priv->wowlan_support.pattern_max_len = 128;
      (hw->wiphy)->wowlan = (struct wiphy_wowlan_support  const  *)(& priv->wowlan_support);
    } else {

    }
  } else {

  }
  if ((int )iwlwifi_mod_params.power_save) {
    (hw->wiphy)->flags = (hw->wiphy)->flags | 16U;
  } else {
    (hw->wiphy)->flags = (hw->wiphy)->flags & 4294967279U;
  }
  (hw->wiphy)->max_scan_ssids = 20U;
  (hw->wiphy)->max_scan_ie_len = (unsigned int )((u16 )capa->max_probe_length) - 58U;
  hw->queues = 11U;
  hw->max_listen_interval = 10U;
  if ((priv->nvm_data)->bands[0].n_channels != 0) {
    ((priv->hw)->wiphy)->bands[0] = (struct ieee80211_supported_band *)(& (priv->nvm_data)->bands);
  } else {

  }
  if ((priv->nvm_data)->bands[1].n_channels != 0) {
    ((priv->hw)->wiphy)->bands[1] = (struct ieee80211_supported_band *)(& (priv->nvm_data)->bands) + 1UL;
  } else {

  }
  (hw->wiphy)->hw_version = (priv->trans)->hw_id;
  iwl_leds_init(priv);
  ret = ieee80211_register_hw(priv->hw);
  if (ret != 0) {
    __iwl_err(priv->dev, 0, 0, "Failed to register hw (error %d)\n", ret);
    iwl_leds_exit(priv);
    return (ret);
  } else {

  }
  priv->mac80211_registered = 1U;
  return (0);
}
}
void iwlagn_mac_unregister(struct iwl_priv *priv ) 
{ 


  {
  if ((unsigned int )priv->mac80211_registered == 0U) {
    return;
  } else {

  }
  iwl_leds_exit(priv);
  ieee80211_unregister_hw(priv->hw);
  priv->mac80211_registered = 0U;
  return;
}
}
static int __iwl_up(struct iwl_priv *priv ) 
{ 
  struct iwl_rxon_context *ctx ;
  int ret ;
  int __ret_warn_on ;
  int tmp ;
  int tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;

  {
  if (debug_locks != 0) {
    tmp = lock_is_held(& priv->mutex.dep_map);
    if (tmp == 0) {
      tmp___0 = 1;
    } else {
      tmp___0 = 0;
    }
  } else {
    tmp___0 = 0;
  }
  __ret_warn_on = tmp___0;
  tmp___1 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp___1 != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/08_1a/drivers/net/wireless/iwlwifi/dvm/mac80211.c",
                       238);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  tmp___2 = constant_test_bit(5L, (unsigned long const volatile   *)(& priv->status));
  if (tmp___2 != 0) {
    __iwl_warn(priv->dev, "Exit pending; will not bring the NIC up\n");
    return (-5);
  } else {

  }
  ctx = (struct iwl_rxon_context *)(& priv->contexts);
  goto ldv_55251;
  ldv_55250: ;
  if ((int )((unsigned long )priv->valid_contexts >> (int )ctx->ctxid) & 1) {
    ret = iwlagn_alloc_bcast_station(priv, ctx);
    if (ret != 0) {
      iwl_dealloc_bcast_stations(priv);
      return (ret);
    } else {

    }
  } else {

  }
  ctx = ctx + 1;
  ldv_55251: ;
  if ((unsigned long )((struct iwl_rxon_context *)(& priv->contexts) + 2UL) > (unsigned long )ctx) {
    goto ldv_55250;
  } else {

  }
  ret = iwl_run_init_ucode(priv);
  if (ret != 0) {
    __iwl_err(priv->dev, 0, 0, "Failed to run INIT ucode: %d\n", ret);
    goto error;
  } else {

  }
  ret = iwl_load_ucode_wait_alive(priv, 0);
  if (ret != 0) {
    __iwl_err(priv->dev, 0, 0, "Failed to start RT ucode: %d\n", ret);
    goto error;
  } else {

  }
  ret = iwl_alive_start(priv);
  if (ret != 0) {
    goto error;
  } else {

  }
  return (0);
  error: 
  set_bit(5L, (unsigned long volatile   *)(& priv->status));
  iwl_down(priv);
  clear_bit(5L, (unsigned long volatile   *)(& priv->status));
  __iwl_err(priv->dev, 0, 0, "Unable to initialize device.\n");
  return (ret);
}
}
static int iwlagn_mac_start(struct ieee80211_hw *hw ) 
{ 
  struct iwl_priv *priv ;
  int ret ;
  int __ret_warn_on ;
  int tmp ;
  long tmp___0 ;
  long tmp___1 ;

  {
  priv = (struct iwl_priv *)(& ((struct iwl_op_mode *)hw->priv)->op_mode_specific);
  __iwl_dbg(priv->dev, 2U, 0, "iwlagn_mac_start", "enter\n");
  mutex_lock_nested(& priv->mutex, 0U);
  ret = __iwl_up(priv);
  mutex_unlock(& priv->mutex);
  if (ret != 0) {
    return (ret);
  } else {

  }
  __iwl_dbg(priv->dev, 1U, 0, "iwlagn_mac_start", "Start UP work done.\n");
  tmp = constant_test_bit(3L, (unsigned long const volatile   *)(& priv->status));
  __ret_warn_on = tmp == 0;
  tmp___0 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp___0 != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/08_1a/drivers/net/wireless/iwlwifi/dvm/mac80211.c",
                       296);
  } else {

  }
  tmp___1 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp___1 != 0L) {
    ret = -5;
  } else {

  }
  iwlagn_led_enable(priv);
  priv->is_open = 1U;
  __iwl_dbg(priv->dev, 2U, 0, "iwlagn_mac_start", "leave\n");
  return (0);
}
}
static void iwlagn_mac_stop(struct ieee80211_hw *hw ) 
{ 
  struct iwl_priv *priv ;

  {
  priv = (struct iwl_priv *)(& ((struct iwl_op_mode *)hw->priv)->op_mode_specific);
  __iwl_dbg(priv->dev, 2U, 0, "iwlagn_mac_stop", "enter\n");
  if ((unsigned int )priv->is_open == 0U) {
    return;
  } else {

  }
  priv->is_open = 0U;
  mutex_lock_nested(& priv->mutex, 0U);
  iwl_down(priv);
  mutex_unlock(& priv->mutex);
  iwl_cancel_deferred_work(priv);
  ldv_flush_workqueue_64(priv->workqueue);
  __iwl_dbg(priv->dev, 2U, 0, "iwlagn_mac_stop", "leave\n");
  return;
}
}
static void iwlagn_mac_set_rekey_data(struct ieee80211_hw *hw , struct ieee80211_vif *vif ,
                                      struct cfg80211_gtk_rekey_data *data ) 
{ 
  struct iwl_priv *priv ;

  {
  priv = (struct iwl_priv *)(& ((struct iwl_op_mode *)hw->priv)->op_mode_specific);
  if (iwlwifi_mod_params.sw_crypto != 0) {
    return;
  } else {

  }
  __iwl_dbg(priv->dev, 2U, 0, "iwlagn_mac_set_rekey_data", "enter\n");
  mutex_lock_nested(& priv->mutex, 0U);
  if ((unsigned long )priv->contexts[0].vif != (unsigned long )vif) {
    goto out;
  } else {

  }
  memcpy((void *)(& priv->kek), (void const   *)data->kek, 16UL);
  memcpy((void *)(& priv->kck), (void const   *)data->kck, 16UL);
  priv->replay_ctr = __be64_to_cpup((__be64 const   *)(& data->replay_ctr));
  priv->have_rekey_data = 1;
  out: 
  mutex_unlock(& priv->mutex);
  __iwl_dbg(priv->dev, 2U, 0, "iwlagn_mac_set_rekey_data", "leave\n");
  return;
}
}
static int iwlagn_mac_suspend(struct ieee80211_hw *hw , struct cfg80211_wowlan *wowlan ) 
{ 
  struct iwl_priv *priv ;
  struct iwl_rxon_context *ctx ;
  int ret ;
  int __ret_warn_on ;
  long tmp ;
  long tmp___0 ;
  int tmp___1 ;

  {
  priv = (struct iwl_priv *)(& ((struct iwl_op_mode *)hw->priv)->op_mode_specific);
  ctx = (struct iwl_rxon_context *)(& priv->contexts);
  __ret_warn_on = (unsigned long )wowlan == (unsigned long )((struct cfg80211_wowlan *)0);
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/08_1a/drivers/net/wireless/iwlwifi/dvm/mac80211.c",
                       363);
  } else {

  }
  tmp___0 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp___0 != 0L) {
    return (-22);
  } else {

  }
  __iwl_dbg(priv->dev, 2U, 0, "iwlagn_mac_suspend", "enter\n");
  mutex_lock_nested(& priv->mutex, 0U);
  if ((unsigned long )ctx->vif == (unsigned long )((struct ieee80211_vif *)0) || (unsigned int )(ctx->vif)->type != 2U) {
    ret = 1;
    goto out;
  } else {
    tmp___1 = iwl_is_associated_ctx(ctx);
    if (tmp___1 == 0) {
      ret = 1;
      goto out;
    } else {

    }
  }
  ret = iwlagn_suspend(priv, wowlan);
  if (ret != 0) {
    goto error;
  } else {

  }
  iwl_write32___0(priv->trans, 88U, 32U);
  iwl_trans_d3_suspend(priv->trans, 0);
  goto out;
  error: 
  priv->wowlan = 0;
  iwlagn_prepare_restart(priv);
  ieee80211_restart_hw(priv->hw);
  out: 
  mutex_unlock(& priv->mutex);
  __iwl_dbg(priv->dev, 2U, 0, "iwlagn_mac_suspend", "leave\n");
  return (ret);
}
}
static bool iwl_resume_status_fn(struct iwl_notif_wait_data *notif_wait , struct iwl_rx_packet *pkt ,
                                 void *data ) 
{ 
  struct iwl_resume_data *resume_data ;
  struct iwl_priv *priv ;
  u32 tmp ;

  {
  resume_data = (struct iwl_resume_data *)data;
  priv = resume_data->priv;
  tmp = iwl_rx_packet_payload_len((struct iwl_rx_packet  const  *)pkt);
  if (tmp != 304U) {
    __iwl_err(priv->dev, 0, 0, "rx wrong size data\n");
    return (1);
  } else {

  }
  memcpy((void *)resume_data->cmd, (void const   *)(& pkt->data), 304UL);
  resume_data->valid = 1;
  return (1);
}
}
static int iwlagn_mac_resume(struct ieee80211_hw *hw ) 
{ 
  struct iwl_priv *priv ;
  struct iwl_rxon_context *ctx ;
  struct ieee80211_vif *vif ;
  u32 base ;
  int ret ;
  enum iwl_d3_status d3_status ;
  struct error_table_start err_info ;
  struct iwl_notification_wait status_wait ;
  u8 status_cmd[1U] ;
  struct iwlagn_wowlan_status status_data ;
  struct iwl_resume_data resume_data ;
  struct cfg80211_wowlan_wakeup wakeup ;
  struct fw_img  const  *img ;
  int tmp ;
  u32 reasons ;
  struct cfg80211_wowlan_wakeup *wakeup_report ;

  {
  priv = (struct iwl_priv *)(& ((struct iwl_op_mode *)hw->priv)->op_mode_specific);
  ctx = (struct iwl_rxon_context *)(& priv->contexts);
  status_cmd[0] = 229U;
  status_data.replay_ctr = 0ULL;
  status_data.rekey_status = 0U;
  status_data.wakeup_reason = 0U;
  status_data.pattern_number = (unsigned char)0;
  status_data.reserved1 = (unsigned char)0;
  status_data.qos_seq_ctr[0] = (unsigned short)0;
  status_data.qos_seq_ctr[1] = (unsigned short)0;
  status_data.qos_seq_ctr[2] = (unsigned short)0;
  status_data.qos_seq_ctr[3] = (unsigned short)0;
  status_data.qos_seq_ctr[4] = (unsigned short)0;
  status_data.qos_seq_ctr[5] = (unsigned short)0;
  status_data.qos_seq_ctr[6] = (unsigned short)0;
  status_data.qos_seq_ctr[7] = (unsigned short)0;
  status_data.non_qos_seq_ctr = (unsigned short)0;
  status_data.reserved2 = (unsigned short)0;
  status_data.tsc_rsc.tkip.unicast_rsc[0].iv16 = (unsigned short)0;
  status_data.tsc_rsc.tkip.unicast_rsc[0].pad = (unsigned short)0;
  status_data.tsc_rsc.tkip.unicast_rsc[0].iv32 = 0U;
  status_data.tsc_rsc.tkip.unicast_rsc[1].iv16 = (unsigned short)0;
  status_data.tsc_rsc.tkip.unicast_rsc[1].pad = (unsigned short)0;
  status_data.tsc_rsc.tkip.unicast_rsc[1].iv32 = 0U;
  status_data.tsc_rsc.tkip.unicast_rsc[2].iv16 = (unsigned short)0;
  status_data.tsc_rsc.tkip.unicast_rsc[2].pad = (unsigned short)0;
  status_data.tsc_rsc.tkip.unicast_rsc[2].iv32 = 0U;
  status_data.tsc_rsc.tkip.unicast_rsc[3].iv16 = (unsigned short)0;
  status_data.tsc_rsc.tkip.unicast_rsc[3].pad = (unsigned short)0;
  status_data.tsc_rsc.tkip.unicast_rsc[3].iv32 = 0U;
  status_data.tsc_rsc.tkip.unicast_rsc[4].iv16 = (unsigned short)0;
  status_data.tsc_rsc.tkip.unicast_rsc[4].pad = (unsigned short)0;
  status_data.tsc_rsc.tkip.unicast_rsc[4].iv32 = 0U;
  status_data.tsc_rsc.tkip.unicast_rsc[5].iv16 = (unsigned short)0;
  status_data.tsc_rsc.tkip.unicast_rsc[5].pad = (unsigned short)0;
  status_data.tsc_rsc.tkip.unicast_rsc[5].iv32 = 0U;
  status_data.tsc_rsc.tkip.unicast_rsc[6].iv16 = (unsigned short)0;
  status_data.tsc_rsc.tkip.unicast_rsc[6].pad = (unsigned short)0;
  status_data.tsc_rsc.tkip.unicast_rsc[6].iv32 = 0U;
  status_data.tsc_rsc.tkip.unicast_rsc[7].iv16 = (unsigned short)0;
  status_data.tsc_rsc.tkip.unicast_rsc[7].pad = (unsigned short)0;
  status_data.tsc_rsc.tkip.unicast_rsc[7].iv32 = 0U;
  status_data.tsc_rsc.tkip.unicast_rsc[8].iv16 = (unsigned short)0;
  status_data.tsc_rsc.tkip.unicast_rsc[8].pad = (unsigned short)0;
  status_data.tsc_rsc.tkip.unicast_rsc[8].iv32 = 0U;
  status_data.tsc_rsc.tkip.unicast_rsc[9].iv16 = (unsigned short)0;
  status_data.tsc_rsc.tkip.unicast_rsc[9].pad = (unsigned short)0;
  status_data.tsc_rsc.tkip.unicast_rsc[9].iv32 = 0U;
  status_data.tsc_rsc.tkip.unicast_rsc[10].iv16 = (unsigned short)0;
  status_data.tsc_rsc.tkip.unicast_rsc[10].pad = (unsigned short)0;
  status_data.tsc_rsc.tkip.unicast_rsc[10].iv32 = 0U;
  status_data.tsc_rsc.tkip.unicast_rsc[11].iv16 = (unsigned short)0;
  status_data.tsc_rsc.tkip.unicast_rsc[11].pad = (unsigned short)0;
  status_data.tsc_rsc.tkip.unicast_rsc[11].iv32 = 0U;
  status_data.tsc_rsc.tkip.unicast_rsc[12].iv16 = (unsigned short)0;
  status_data.tsc_rsc.tkip.unicast_rsc[12].pad = (unsigned short)0;
  status_data.tsc_rsc.tkip.unicast_rsc[12].iv32 = 0U;
  status_data.tsc_rsc.tkip.unicast_rsc[13].iv16 = (unsigned short)0;
  status_data.tsc_rsc.tkip.unicast_rsc[13].pad = (unsigned short)0;
  status_data.tsc_rsc.tkip.unicast_rsc[13].iv32 = 0U;
  status_data.tsc_rsc.tkip.unicast_rsc[14].iv16 = (unsigned short)0;
  status_data.tsc_rsc.tkip.unicast_rsc[14].pad = (unsigned short)0;
  status_data.tsc_rsc.tkip.unicast_rsc[14].iv32 = 0U;
  status_data.tsc_rsc.tkip.unicast_rsc[15].iv16 = (unsigned short)0;
  status_data.tsc_rsc.tkip.unicast_rsc[15].pad = (unsigned short)0;
  status_data.tsc_rsc.tkip.unicast_rsc[15].iv32 = 0U;
  status_data.tsc_rsc.tkip.multicast_rsc[0].iv16 = (unsigned short)0;
  status_data.tsc_rsc.tkip.multicast_rsc[0].pad = (unsigned short)0;
  status_data.tsc_rsc.tkip.multicast_rsc[0].iv32 = 0U;
  status_data.tsc_rsc.tkip.multicast_rsc[1].iv16 = (unsigned short)0;
  status_data.tsc_rsc.tkip.multicast_rsc[1].pad = (unsigned short)0;
  status_data.tsc_rsc.tkip.multicast_rsc[1].iv32 = 0U;
  status_data.tsc_rsc.tkip.multicast_rsc[2].iv16 = (unsigned short)0;
  status_data.tsc_rsc.tkip.multicast_rsc[2].pad = (unsigned short)0;
  status_data.tsc_rsc.tkip.multicast_rsc[2].iv32 = 0U;
  status_data.tsc_rsc.tkip.multicast_rsc[3].iv16 = (unsigned short)0;
  status_data.tsc_rsc.tkip.multicast_rsc[3].pad = (unsigned short)0;
  status_data.tsc_rsc.tkip.multicast_rsc[3].iv32 = 0U;
  status_data.tsc_rsc.tkip.multicast_rsc[4].iv16 = (unsigned short)0;
  status_data.tsc_rsc.tkip.multicast_rsc[4].pad = (unsigned short)0;
  status_data.tsc_rsc.tkip.multicast_rsc[4].iv32 = 0U;
  status_data.tsc_rsc.tkip.multicast_rsc[5].iv16 = (unsigned short)0;
  status_data.tsc_rsc.tkip.multicast_rsc[5].pad = (unsigned short)0;
  status_data.tsc_rsc.tkip.multicast_rsc[5].iv32 = 0U;
  status_data.tsc_rsc.tkip.multicast_rsc[6].iv16 = (unsigned short)0;
  status_data.tsc_rsc.tkip.multicast_rsc[6].pad = (unsigned short)0;
  status_data.tsc_rsc.tkip.multicast_rsc[6].iv32 = 0U;
  status_data.tsc_rsc.tkip.multicast_rsc[7].iv16 = (unsigned short)0;
  status_data.tsc_rsc.tkip.multicast_rsc[7].pad = (unsigned short)0;
  status_data.tsc_rsc.tkip.multicast_rsc[7].iv32 = 0U;
  status_data.tsc_rsc.tkip.multicast_rsc[8].iv16 = (unsigned short)0;
  status_data.tsc_rsc.tkip.multicast_rsc[8].pad = (unsigned short)0;
  status_data.tsc_rsc.tkip.multicast_rsc[8].iv32 = 0U;
  status_data.tsc_rsc.tkip.multicast_rsc[9].iv16 = (unsigned short)0;
  status_data.tsc_rsc.tkip.multicast_rsc[9].pad = (unsigned short)0;
  status_data.tsc_rsc.tkip.multicast_rsc[9].iv32 = 0U;
  status_data.tsc_rsc.tkip.multicast_rsc[10].iv16 = (unsigned short)0;
  status_data.tsc_rsc.tkip.multicast_rsc[10].pad = (unsigned short)0;
  status_data.tsc_rsc.tkip.multicast_rsc[10].iv32 = 0U;
  status_data.tsc_rsc.tkip.multicast_rsc[11].iv16 = (unsigned short)0;
  status_data.tsc_rsc.tkip.multicast_rsc[11].pad = (unsigned short)0;
  status_data.tsc_rsc.tkip.multicast_rsc[11].iv32 = 0U;
  status_data.tsc_rsc.tkip.multicast_rsc[12].iv16 = (unsigned short)0;
  status_data.tsc_rsc.tkip.multicast_rsc[12].pad = (unsigned short)0;
  status_data.tsc_rsc.tkip.multicast_rsc[12].iv32 = 0U;
  status_data.tsc_rsc.tkip.multicast_rsc[13].iv16 = (unsigned short)0;
  status_data.tsc_rsc.tkip.multicast_rsc[13].pad = (unsigned short)0;
  status_data.tsc_rsc.tkip.multicast_rsc[13].iv32 = 0U;
  status_data.tsc_rsc.tkip.multicast_rsc[14].iv16 = (unsigned short)0;
  status_data.tsc_rsc.tkip.multicast_rsc[14].pad = (unsigned short)0;
  status_data.tsc_rsc.tkip.multicast_rsc[14].iv32 = 0U;
  status_data.tsc_rsc.tkip.multicast_rsc[15].iv16 = (unsigned short)0;
  status_data.tsc_rsc.tkip.multicast_rsc[15].pad = (unsigned short)0;
  status_data.tsc_rsc.tkip.multicast_rsc[15].iv32 = 0U;
  status_data.tsc_rsc.tkip.tsc.iv16 = (unsigned short)0;
  status_data.tsc_rsc.tkip.tsc.pad = (unsigned short)0;
  status_data.tsc_rsc.tkip.tsc.iv32 = 0U;
  status_data.reserved3 = (unsigned short)0;
  resume_data.priv = priv;
  resume_data.cmd = & status_data;
  resume_data.valid = 0;
  wakeup.disconnect = (_Bool)0;
  wakeup.magic_pkt = (_Bool)0;
  wakeup.gtk_rekey_failure = (_Bool)0;
  wakeup.eap_identity_req = (_Bool)0;
  wakeup.four_way_handshake = (_Bool)0;
  wakeup.rfkill_release = (_Bool)0;
  wakeup.packet_80211 = (_Bool)0;
  wakeup.tcp_match = (_Bool)0;
  wakeup.tcp_connlost = (_Bool)0;
  wakeup.tcp_nomoretokens = (_Bool)0;
  wakeup.pattern_idx = -1;
  wakeup.packet_present_len = 0U;
  wakeup.packet_len = 0U;
  wakeup.packet = 0;
  wakeup.net_detect = 0;
  __iwl_dbg(priv->dev, 2U, 0, "iwlagn_mac_resume", "enter\n");
  mutex_lock_nested(& priv->mutex, 0U);
  vif = ctx->vif;
  ret = iwl_trans_d3_resume(priv->trans, & d3_status, 0);
  if (ret != 0) {
    goto out_unlock;
  } else {

  }
  if ((unsigned int )d3_status != 0U) {
    __iwl_info(priv->dev, "Device was reset during suspend\n");
    goto out_unlock;
  } else {

  }
  iwl_write32___0(priv->trans, 92U, 32U);
  base = priv->device_pointers.error_event_table;
  tmp = iwlagn_hw_valid_rtc_data_addr(base);
  if (tmp == 0) {
    __iwl_warn(priv->dev, "Invalid error table during resume!\n");
    goto out_unlock;
  } else {

  }
  iwl_trans_read_mem(priv->trans, base, (void *)(& err_info), 2);
  if (err_info.valid != 0U) {
    __iwl_info(priv->dev, "error table is valid (%d, 0x%x)\n", err_info.valid, err_info.error_id);
    if (err_info.error_id == 135U) {
      wakeup.rfkill_release = 1;
      ieee80211_report_wowlan_wakeup(vif, & wakeup, 208U);
    } else {

    }
    goto out_unlock;
  } else {

  }
  img = (struct fw_img  const  *)(& (priv->fw)->img) + 2UL;
  if ((unsigned long )priv->wowlan_sram == (unsigned long )((void *)0)) {
    priv->wowlan_sram = kzalloc((size_t )img->sec[0].len, 208U);
  } else {

  }
  if ((unsigned long )priv->wowlan_sram != (unsigned long )((void *)0)) {
    iwl_trans_read_mem(priv->trans, 8388608U, priv->wowlan_sram, (int )((unsigned int )img->sec[0].len / 4U));
  } else {

  }
  iwl_init_notification_wait(& priv->notif_wait, & status_wait, (u8 const   *)(& status_cmd),
                             1, & iwl_resume_status_fn, (void *)(& resume_data));
  iwl_dvm_send_cmd_pdu(priv, 229, 1U, 0, (void const   *)0);
  iwl_dvm_send_cmd_pdu(priv, 3, 1U, 0, (void const   *)0);
  ret = iwl_wait_notification(& priv->notif_wait, & status_wait, 50UL);
  if (ret != 0) {
    goto out_unlock;
  } else {

  }
  if ((int )resume_data.valid && (unsigned long )priv->contexts[0].vif != (unsigned long )((struct ieee80211_vif *)0)) {
    reasons = status_data.wakeup_reason;
    __iwl_info(priv->dev, "WoWLAN wakeup reason(s): 0x%.8x\n", reasons);
    if (reasons != 0U) {
      if ((int )reasons & 1) {
        wakeup.magic_pkt = 1;
      } else {

      }
      if ((reasons & 2U) != 0U) {
        wakeup.pattern_idx = (s32 )status_data.pattern_number;
      } else {

      }
      if ((reasons & 12U) != 0U) {
        wakeup.disconnect = 1;
      } else {

      }
      if ((reasons & 16U) != 0U) {
        wakeup.gtk_rekey_failure = 1;
      } else {

      }
      if ((reasons & 32U) != 0U) {
        wakeup.eap_identity_req = 1;
      } else {

      }
      if ((reasons & 64U) != 0U) {
        wakeup.four_way_handshake = 1;
      } else {

      }
      wakeup_report = & wakeup;
    } else {
      wakeup_report = (struct cfg80211_wowlan_wakeup *)0;
    }
    ieee80211_report_wowlan_wakeup(vif, wakeup_report, 208U);
  } else {

  }
  priv->wowlan = 0;
  iwlagn_prepare_restart(priv);
  memset((void *)(& ctx->active), 0, 50UL);
  iwl_connection_init_rx_config(priv, ctx);
  iwlagn_set_rxon_chain(priv, ctx);
  out_unlock: 
  mutex_unlock(& priv->mutex);
  __iwl_dbg(priv->dev, 2U, 0, "iwlagn_mac_resume", "leave\n");
  ieee80211_resume_disconnect(vif);
  return (1);
}
}
static void iwlagn_mac_set_wakeup(struct ieee80211_hw *hw , bool enabled ) 
{ 
  struct iwl_priv *priv ;

  {
  priv = (struct iwl_priv *)(& ((struct iwl_op_mode *)hw->priv)->op_mode_specific);
  device_set_wakeup_enable((priv->trans)->dev, (int )enabled);
  return;
}
}
static void iwlagn_mac_tx(struct ieee80211_hw *hw , struct ieee80211_tx_control *control ,
                          struct sk_buff *skb ) 
{ 
  struct iwl_priv *priv ;
  int tmp ;

  {
  priv = (struct iwl_priv *)(& ((struct iwl_op_mode *)hw->priv)->op_mode_specific);
  tmp = iwlagn_tx_skb(priv, control->sta, skb);
  if (tmp != 0) {
    ieee80211_free_txskb(hw, skb);
  } else {

  }
  return;
}
}
static void iwlagn_mac_update_tkip_key(struct ieee80211_hw *hw , struct ieee80211_vif *vif ,
                                       struct ieee80211_key_conf *keyconf , struct ieee80211_sta *sta ,
                                       u32 iv32 , u16 *phase1key ) 
{ 
  struct iwl_priv *priv ;

  {
  priv = (struct iwl_priv *)(& ((struct iwl_op_mode *)hw->priv)->op_mode_specific);
  iwl_update_tkip_key(priv, vif, keyconf, sta, iv32, phase1key);
  return;
}
}
static int iwlagn_mac_set_key(struct ieee80211_hw *hw , enum set_key_cmd cmd , struct ieee80211_vif *vif ,
                              struct ieee80211_sta *sta , struct ieee80211_key_conf *key ) 
{ 
  struct iwl_priv *priv ;
  struct iwl_vif_priv *vif_priv ;
  struct iwl_rxon_context *ctx ;
  int ret ;
  bool is_default_wep_key ;

  {
  priv = (struct iwl_priv *)(& ((struct iwl_op_mode *)hw->priv)->op_mode_specific);
  vif_priv = (struct iwl_vif_priv *)(& vif->drv_priv);
  ctx = vif_priv->ctx;
  is_default_wep_key = 0;
  __iwl_dbg(priv->dev, 2U, 0, "iwlagn_mac_set_key", "enter\n");
  if (iwlwifi_mod_params.sw_crypto != 0) {
    __iwl_dbg(priv->dev, 2U, 0, "iwlagn_mac_set_key", "leave - hwcrypto disabled\n");
    return (-95);
  } else {

  }
  switch (key->cipher) {
  case 1027074U: 
  key->flags = (u8 )((unsigned int )key->flags | 4U);
  case 1027076U: 
  key->flags = (u8 )((unsigned int )key->flags | 2U);
  goto ldv_55358;
  default: ;
  goto ldv_55358;
  }
  ldv_55358: ;
  if ((unsigned int )vif->type == 1U && ((int )key->flags & 8) == 0) {
    key->hw_key_idx = 255U;
    return (0);
  } else {

  }
  if ((unsigned int )cmd == 1U && (unsigned int )key->hw_key_idx == 255U) {
    return (0);
  } else {

  }
  mutex_lock_nested(& priv->mutex, 0U);
  iwl_scan_cancel_timeout(priv, 100UL);
  if ((key->cipher == 1027073U || key->cipher == 1027077U) && (unsigned long )sta == (unsigned long )((struct ieee80211_sta *)0)) {
    if ((unsigned int )cmd == 0U) {
      is_default_wep_key = (unsigned int )ctx->key_mapping_keys == 0U;
    } else {
      is_default_wep_key = (unsigned int )key->hw_key_idx == 254U;
    }
  } else {

  }
  switch ((unsigned int )cmd) {
  case 0U: ;
  if ((int )is_default_wep_key) {
    ret = iwl_set_default_wep_key(priv, vif_priv->ctx, key);
    goto ldv_55361;
  } else {

  }
  ret = iwl_set_dynamic_key(priv, vif_priv->ctx, key, sta);
  if (ret != 0) {
    ret = 0;
    key->hw_key_idx = 255U;
  } else {

  }
  __iwl_dbg(priv->dev, 2U, 0, "iwlagn_mac_set_key", "enable hwcrypto key\n");
  goto ldv_55361;
  case 1U: ;
  if ((int )is_default_wep_key) {
    ret = iwl_remove_default_wep_key(priv, ctx, key);
  } else {
    ret = iwl_remove_dynamic_key(priv, ctx, key, sta);
  }
  __iwl_dbg(priv->dev, 2U, 0, "iwlagn_mac_set_key", "disable hwcrypto key\n");
  goto ldv_55361;
  default: 
  ret = -22;
  }
  ldv_55361: 
  mutex_unlock(& priv->mutex);
  __iwl_dbg(priv->dev, 2U, 0, "iwlagn_mac_set_key", "leave\n");
  return (ret);
}
}
__inline static bool iwl_enable_rx_ampdu(struct iwl_cfg  const  *cfg ) 
{ 


  {
  if ((iwlwifi_mod_params.disable_11n & 4U) != 0U) {
    return (0);
  } else {

  }
  return (1);
}
}
__inline static bool iwl_enable_tx_ampdu(struct iwl_cfg  const  *cfg ) 
{ 


  {
  if ((iwlwifi_mod_params.disable_11n & 2U) != 0U) {
    return (0);
  } else {

  }
  if ((iwlwifi_mod_params.disable_11n & 8U) != 0U) {
    return (1);
  } else {

  }
  return (0);
}
}
static int iwlagn_mac_ampdu_action(struct ieee80211_hw *hw , struct ieee80211_vif *vif ,
                                   enum ieee80211_ampdu_mlme_action action , struct ieee80211_sta *sta ,
                                   u16 tid , u16 *ssn , u8 buf_size ) 
{ 
  struct iwl_priv *priv ;
  int ret ;
  struct iwl_station_priv *sta_priv ;
  bool tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;
  struct iwl_rxon_context *tmp___3 ;

  {
  priv = (struct iwl_priv *)(& ((struct iwl_op_mode *)hw->priv)->op_mode_specific);
  ret = -22;
  sta_priv = (struct iwl_station_priv *)(& sta->drv_priv);
  __iwl_dbg(priv->dev, 67108864U, 0, "iwlagn_mac_ampdu_action", "A-MPDU action on addr %pM tid %d\n",
            (u8 *)(& sta->addr), (int )tid);
  if (! (priv->nvm_data)->sku_cap_11n_enable) {
    return (-13);
  } else {

  }
  __iwl_dbg(priv->dev, 2U, 0, "iwlagn_mac_ampdu_action", "enter\n");
  mutex_lock_nested(& priv->mutex, 0U);
  switch ((unsigned int )action) {
  case 0U: 
  tmp = iwl_enable_rx_ampdu(priv->cfg);
  if (tmp) {
    tmp___0 = 0;
  } else {
    tmp___0 = 1;
  }
  if (tmp___0) {
    goto ldv_55384;
  } else {

  }
  __iwl_dbg(priv->dev, 67108864U, 0, "iwlagn_mac_ampdu_action", "start Rx\n");
  ret = iwl_sta_rx_agg_start(priv, sta, (int )tid, (int )*ssn);
  goto ldv_55384;
  case 1U: 
  __iwl_dbg(priv->dev, 67108864U, 0, "iwlagn_mac_ampdu_action", "stop Rx\n");
  ret = iwl_sta_rx_agg_stop(priv, sta, (int )tid);
  goto ldv_55384;
  case 2U: ;
  if ((unsigned long )((priv->trans)->ops)->txq_enable == (unsigned long )((void (*/* const  */)(struct iwl_trans * ,
                                                                                                 int  ,
                                                                                                 u16  ,
                                                                                                 struct iwl_trans_txq_scd_cfg  const  * ,
                                                                                                 unsigned int  ))0)) {
    goto ldv_55384;
  } else {

  }
  tmp___1 = iwl_enable_tx_ampdu(priv->cfg);
  if (tmp___1) {
    tmp___2 = 0;
  } else {
    tmp___2 = 1;
  }
  if (tmp___2) {
    goto ldv_55384;
  } else {

  }
  __iwl_dbg(priv->dev, 67108864U, 0, "iwlagn_mac_ampdu_action", "start Tx\n");
  ret = iwlagn_tx_agg_start(priv, vif, sta, (int )tid, ssn);
  goto ldv_55384;
  case 4U: ;
  case 5U: 
  __iwl_dbg(priv->dev, 67108864U, 0, "iwlagn_mac_ampdu_action", "Flush Tx\n");
  ret = iwlagn_tx_agg_flush(priv, vif, sta, (int )tid);
  goto ldv_55384;
  case 3U: 
  __iwl_dbg(priv->dev, 67108864U, 0, "iwlagn_mac_ampdu_action", "stop Tx\n");
  ret = iwlagn_tx_agg_stop(priv, vif, sta, (int )tid);
  if (ret == 0 && (unsigned int )priv->agg_tids_count != 0U) {
    priv->agg_tids_count = (u8 )((int )priv->agg_tids_count - 1);
    __iwl_dbg(priv->dev, 67108864U, 0, "iwlagn_mac_ampdu_action", "priv->agg_tids_count = %u\n",
              (int )priv->agg_tids_count);
  } else {

  }
  if ((unsigned int )priv->agg_tids_count == 0U && (int )priv->hw_params.use_rts_for_aggregation) {
    sta_priv->lq_sta.lq.general_params.flags = (unsigned int )sta_priv->lq_sta.lq.general_params.flags & 254U;
    tmp___3 = iwl_rxon_ctx_from_vif(vif);
    iwl_send_lq_cmd(priv, tmp___3, & sta_priv->lq_sta.lq, 1, 0);
  } else {

  }
  goto ldv_55384;
  case 6U: 
  ret = iwlagn_tx_agg_oper(priv, vif, sta, (int )tid, (int )buf_size);
  goto ldv_55384;
  }
  ldv_55384: 
  mutex_unlock(& priv->mutex);
  __iwl_dbg(priv->dev, 2U, 0, "iwlagn_mac_ampdu_action", "leave\n");
  return (ret);
}
}
static int iwlagn_mac_sta_add(struct ieee80211_hw *hw , struct ieee80211_vif *vif ,
                              struct ieee80211_sta *sta ) 
{ 
  struct iwl_priv *priv ;
  struct iwl_station_priv *sta_priv ;
  struct iwl_vif_priv *vif_priv ;
  bool is_ap ;
  int ret ;
  u8 sta_id ;

  {
  priv = (struct iwl_priv *)(& ((struct iwl_op_mode *)hw->priv)->op_mode_specific);
  sta_priv = (struct iwl_station_priv *)(& sta->drv_priv);
  vif_priv = (struct iwl_vif_priv *)(& vif->drv_priv);
  is_ap = (unsigned int )vif->type == 2U;
  __iwl_dbg(priv->dev, 1U, 0, "iwlagn_mac_sta_add", "proceeding to add station %pM\n",
            (u8 *)(& sta->addr));
  sta_priv->sta_id = 255U;
  atomic_set(& sta_priv->pending_frames, 0);
  if ((unsigned int )vif->type == 3U) {
    sta_priv->client = 1;
  } else {

  }
  ret = iwl_add_station_common(priv, vif_priv->ctx, (u8 const   *)(& sta->addr), (int )is_ap,
                               sta, & sta_id);
  if (ret != 0) {
    __iwl_err(priv->dev, 0, 0, "Unable to add station %pM (%d)\n", (u8 *)(& sta->addr),
              ret);
    return (ret);
  } else {

  }
  sta_priv->sta_id = sta_id;
  return (0);
}
}
static int iwlagn_mac_sta_remove(struct ieee80211_hw *hw , struct ieee80211_vif *vif ,
                                 struct ieee80211_sta *sta ) 
{ 
  struct iwl_priv *priv ;
  struct iwl_station_priv *sta_priv ;
  int ret ;
  bool tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  priv = (struct iwl_priv *)(& ((struct iwl_op_mode *)hw->priv)->op_mode_specific);
  sta_priv = (struct iwl_station_priv *)(& sta->drv_priv);
  __iwl_dbg(priv->dev, 1U, 0, "iwlagn_mac_sta_remove", "proceeding to remove station %pM\n",
            (u8 *)(& sta->addr));
  if ((unsigned int )vif->type == 2U) {
    ret = 0;
    iwl_deactivate_station(priv, (int )sta_priv->sta_id, (u8 const   *)(& sta->addr));
  } else {
    ret = iwl_remove_station(priv, (int )sta_priv->sta_id, (u8 const   *)(& sta->addr));
    if (ret != 0) {
      tmp___1 = iwl_is_rfkill(priv);
      if (tmp___1 == 0) {
        __iwl_err(priv->dev, 0, 0, "Error removing station %pM\n", (u8 *)(& sta->addr));
      } else {
        tmp = iwl_have_debug_level(128U);
        if ((int )tmp != 0) {
          tmp___0 = 0;
        } else {
          tmp___0 = 1;
        }
        __iwl_err(priv->dev, 1, (int )((bool )tmp___0), "Error removing station %pM\n",
                  (u8 *)(& sta->addr));
      }
    } else {

    }
  }
  return (ret);
}
}
static int iwlagn_mac_sta_state(struct ieee80211_hw *hw , struct ieee80211_vif *vif ,
                                struct ieee80211_sta *sta , enum ieee80211_sta_state old_state ,
                                enum ieee80211_sta_state new_state ) 
{ 
  struct iwl_priv *priv ;
  struct iwl_vif_priv *vif_priv ;
  enum ldv_35989 op ;
  int ret ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  priv = (struct iwl_priv *)(& ((struct iwl_op_mode *)hw->priv)->op_mode_specific);
  vif_priv = (struct iwl_vif_priv *)(& vif->drv_priv);
  op = 0;
  __iwl_dbg(priv->dev, 2U, 0, "iwlagn_mac_sta_state", "station %pM state change %d->%d\n",
            (u8 *)(& sta->addr), (unsigned int )old_state, (unsigned int )new_state);
  mutex_lock_nested(& priv->mutex, 0U);
  if ((unsigned int )vif->type == 2U) {
    if ((unsigned int )old_state == 0U && (unsigned int )new_state == 1U) {
      op = 1;
    } else
    if ((unsigned int )old_state == 1U && (unsigned int )new_state == 0U) {
      op = 2;
    } else
    if ((unsigned int )old_state == 2U && (unsigned int )new_state == 3U) {
      op = 3;
    } else {

    }
  } else
  if ((unsigned int )old_state == 2U && (unsigned int )new_state == 3U) {
    op = 4;
  } else
  if ((unsigned int )old_state == 3U && (unsigned int )new_state == 2U) {
    op = 2;
  } else {

  }
  switch ((unsigned int )op) {
  case 1U: 
  ret = iwlagn_mac_sta_add(hw, vif, sta);
  if (ret != 0) {
    goto ldv_55431;
  } else {

  }
  spin_lock_bh(& priv->sta_lock);
  tmp = iwl_sta_id(sta);
  priv->stations[tmp].used = (unsigned int )priv->stations[tmp].used & 251U;
  spin_unlock_bh(& priv->sta_lock);
  goto ldv_55431;
  case 2U: 
  ret = iwlagn_mac_sta_remove(hw, vif, sta);
  goto ldv_55431;
  case 4U: 
  ret = iwlagn_mac_sta_add(hw, vif, sta);
  if (ret != 0) {
    goto ldv_55431;
  } else {

  }
  __iwl_dbg(priv->dev, 1U, 0, "iwlagn_mac_sta_state", "Initializing rate scaling for station %pM\n",
            (u8 *)(& sta->addr));
  tmp___0 = iwl_sta_id(sta);
  iwl_rs_rate_init(priv, sta, (int )((u8 )tmp___0));
  ret = 0;
  goto ldv_55431;
  case 3U: 
  ret = iwl_sta_update_ht(priv, vif_priv->ctx, sta);
  if (ret != 0) {
    goto ldv_55431;
  } else {

  }
  __iwl_dbg(priv->dev, 1U, 0, "iwlagn_mac_sta_state", "Initializing rate scaling for station %pM\n",
            (u8 *)(& sta->addr));
  tmp___1 = iwl_sta_id(sta);
  iwl_rs_rate_init(priv, sta, (int )((u8 )tmp___1));
  ret = 0;
  goto ldv_55431;
  default: 
  ret = 0;
  goto ldv_55431;
  }
  ldv_55431: 
  tmp___2 = iwl_is_rfkill(priv);
  if (tmp___2 != 0) {
    ret = 0;
  } else {

  }
  mutex_unlock(& priv->mutex);
  __iwl_dbg(priv->dev, 2U, 0, "iwlagn_mac_sta_state", "leave\n");
  return (ret);
}
}
static void iwlagn_mac_channel_switch(struct ieee80211_hw *hw , struct ieee80211_vif *vif ,
                                      struct ieee80211_channel_switch *ch_switch ) 
{ 
  struct iwl_priv *priv ;
  struct ieee80211_conf *conf ;
  struct ieee80211_channel *channel ;
  struct iwl_ht_config *ht_conf ;
  struct iwl_rxon_context *ctx ;
  u16 ch ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  enum nl80211_channel_type tmp___4 ;
  int tmp___5 ;

  {
  priv = (struct iwl_priv *)(& ((struct iwl_op_mode *)hw->priv)->op_mode_specific);
  conf = & hw->conf;
  channel = ch_switch->chandef.chan;
  ht_conf = & priv->current_ht_config;
  ctx = (struct iwl_rxon_context *)(& priv->contexts);
  __iwl_dbg(priv->dev, 2U, 0, "iwlagn_mac_channel_switch", "enter\n");
  mutex_lock_nested(& priv->mutex, 0U);
  tmp = iwl_is_rfkill(priv);
  if (tmp != 0) {
    goto out;
  } else {

  }
  tmp___0 = constant_test_bit(5L, (unsigned long const volatile   *)(& priv->status));
  if (tmp___0 != 0) {
    goto out;
  } else {
    tmp___1 = constant_test_bit(7L, (unsigned long const volatile   *)(& priv->status));
    if (tmp___1 != 0) {
      goto out;
    } else {
      tmp___2 = constant_test_bit(11L, (unsigned long const volatile   *)(& priv->status));
      if (tmp___2 != 0) {
        goto out;
      } else {

      }
    }
  }
  tmp___3 = iwl_is_associated_ctx(ctx);
  if (tmp___3 == 0) {
    goto out;
  } else {

  }
  if ((unsigned long )(priv->lib)->set_channel_switch == (unsigned long )((int (*/* const  */)(struct iwl_priv * ,
                                                                                               struct ieee80211_channel_switch * ))0)) {
    goto out;
  } else {

  }
  ch = channel->hw_value;
  if ((int )((unsigned short )ctx->active.channel) == (int )ch) {
    goto out;
  } else {

  }
  priv->current_ht_config.smps = conf->smps_mode;
  tmp___4 = cfg80211_get_chandef_type((struct cfg80211_chan_def  const  *)(& ch_switch->chandef));
  switch ((unsigned int )tmp___4) {
  case 0U: ;
  case 1U: 
  ctx->ht.is_40mhz = 0;
  ctx->ht.extension_chan_offset = 0U;
  goto ldv_55451;
  case 2U: 
  ctx->ht.extension_chan_offset = 3U;
  ctx->ht.is_40mhz = 1;
  goto ldv_55451;
  case 3U: 
  ctx->ht.extension_chan_offset = 1U;
  ctx->ht.is_40mhz = 1;
  goto ldv_55451;
  }
  ldv_55451: ;
  if ((int )ctx->staging.channel != (int )ch) {
    ctx->staging.flags = 0U;
  } else {

  }
  iwl_set_rxon_channel(priv, channel, ctx);
  iwl_set_rxon_ht(priv, ht_conf);
  iwl_set_flags_for_band(priv, ctx, channel->band, ctx->vif);
  set_bit(11L, (unsigned long volatile   *)(& priv->status));
  priv->switch_channel = ch;
  tmp___5 = (*((priv->lib)->set_channel_switch))(priv, ch_switch);
  if (tmp___5 != 0) {
    clear_bit(11L, (unsigned long volatile   *)(& priv->status));
    priv->switch_channel = 0U;
    ieee80211_chswitch_done(ctx->vif, 0);
  } else {

  }
  out: 
  mutex_unlock(& priv->mutex);
  __iwl_dbg(priv->dev, 2U, 0, "iwlagn_mac_channel_switch", "leave\n");
  return;
}
}
void iwl_chswitch_done(struct iwl_priv *priv , bool is_success ) 
{ 
  struct iwl_rxon_context *ctx ;
  int tmp ;
  int tmp___0 ;

  {
  ctx = (struct iwl_rxon_context *)(& priv->contexts);
  tmp = constant_test_bit(5L, (unsigned long const volatile   *)(& priv->status));
  if (tmp != 0) {
    return;
  } else {

  }
  tmp___0 = test_and_clear_bit(11L, (unsigned long volatile   *)(& priv->status));
  if (tmp___0 == 0) {
    return;
  } else {

  }
  if ((unsigned long )ctx->vif != (unsigned long )((struct ieee80211_vif *)0)) {
    ieee80211_chswitch_done(ctx->vif, (int )is_success);
  } else {

  }
  return;
}
}
static void iwlagn_configure_filter(struct ieee80211_hw *hw , unsigned int changed_flags ,
                                    unsigned int *total_flags , u64 multicast ) 
{ 
  struct iwl_priv *priv ;
  __le32 filter_or ;
  __le32 filter_nand ;
  struct iwl_rxon_context *ctx ;

  {
  priv = (struct iwl_priv *)(& ((struct iwl_op_mode *)hw->priv)->op_mode_specific);
  filter_or = 0U;
  filter_nand = 0U;
  __iwl_dbg(priv->dev, 2U, 0, "iwlagn_configure_filter", "Enter: changed: 0x%x, total: 0x%x\n",
            changed_flags, *total_flags);
  if ((*total_flags & 64U) != 0U) {
    filter_or = filter_or | 1U;
  } else {
    filter_nand = filter_nand | 1U;
  }
  if ((*total_flags & 32U) != 0U) {
    filter_or = filter_or | 3U;
  } else {
    filter_nand = filter_nand | 3U;
  }
  if ((*total_flags & 16U) != 0U) {
    filter_or = filter_or | 64U;
  } else {
    filter_nand = filter_nand | 64U;
  }
  mutex_lock_nested(& priv->mutex, 0U);
  ctx = (struct iwl_rxon_context *)(& priv->contexts);
  goto ldv_55471;
  ldv_55470: ;
  if ((int )((unsigned long )priv->valid_contexts >> (int )ctx->ctxid) & 1) {
    ctx->staging.filter_flags = ctx->staging.filter_flags & ~ filter_nand;
    ctx->staging.filter_flags = ctx->staging.filter_flags | filter_or;
  } else {

  }
  ctx = ctx + 1;
  ldv_55471: ;
  if ((unsigned long )((struct iwl_rxon_context *)(& priv->contexts) + 2UL) > (unsigned long )ctx) {
    goto ldv_55470;
  } else {

  }
  mutex_unlock(& priv->mutex);
  *total_flags = *total_flags & 114U;
  return;
}
}
static void iwlagn_mac_flush(struct ieee80211_hw *hw , struct ieee80211_vif *vif ,
                             u32 queues , bool drop ) 
{ 
  struct iwl_priv *priv ;
  u32 scd_queues ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  priv = (struct iwl_priv *)(& ((struct iwl_op_mode *)hw->priv)->op_mode_specific);
  mutex_lock_nested(& priv->mutex, 0U);
  __iwl_dbg(priv->dev, 2U, 0, "iwlagn_mac_flush", "enter\n");
  tmp = constant_test_bit(5L, (unsigned long const volatile   *)(& priv->status));
  if (tmp != 0) {
    __iwl_dbg(priv->dev, 8388608U, 0, "iwlagn_mac_flush", "Aborting flush due to device shutdown\n");
    goto done;
  } else {

  }
  tmp___0 = iwl_is_rfkill(priv);
  if (tmp___0 != 0) {
    __iwl_dbg(priv->dev, 8388608U, 0, "iwlagn_mac_flush", "Aborting flush due to RF Kill\n");
    goto done;
  } else {

  }
  scd_queues = (u32 )(1UL << ((priv->cfg)->base_params)->num_of_queues) - 1U;
  scd_queues = scd_queues & 4294966767U;
  if ((int )drop) {
    __iwl_dbg(priv->dev, 2147483648U, 0, "iwlagn_mac_flush", "Flushing SCD queues: 0x%x\n",
              scd_queues);
    tmp___1 = iwlagn_txfifo_flush(priv, scd_queues);
    if (tmp___1 != 0) {
      __iwl_err(priv->dev, 0, 0, "flush request fail\n");
      goto done;
    } else {

    }
  } else {

  }
  __iwl_dbg(priv->dev, 2147483648U, 0, "iwlagn_mac_flush", "wait transmit/flush all frames\n");
  iwl_trans_wait_tx_queue_empty(priv->trans, scd_queues);
  done: 
  mutex_unlock(& priv->mutex);
  __iwl_dbg(priv->dev, 2U, 0, "iwlagn_mac_flush", "leave\n");
  return;
}
}
static void iwlagn_mac_event_callback(struct ieee80211_hw *hw , struct ieee80211_vif *vif ,
                                      struct ieee80211_event  const  *event ) 
{ 
  struct iwl_priv *priv ;

  {
  priv = (struct iwl_priv *)(& ((struct iwl_op_mode *)hw->priv)->op_mode_specific);
  if ((unsigned int )event->type != 0U) {
    return;
  } else {

  }
  __iwl_dbg(priv->dev, 2U, 0, "iwlagn_mac_event_callback", "enter\n");
  if ((unsigned long )(priv->lib)->bt_params != (unsigned long )((struct iwl_dvm_bt_params  const  */* const  */)0) && (int )((priv->lib)->bt_params)->advanced_bt_coexist) {
    if ((unsigned int )event->u.rssi.data == 1U) {
      priv->bt_enable_pspoll = 1;
    } else
    if ((unsigned int )event->u.rssi.data == 0U) {
      priv->bt_enable_pspoll = 0;
    } else {

    }
    queue_work___1(priv->workqueue, & priv->bt_runtime_config);
  } else {
    __iwl_dbg(priv->dev, 2U, 0, "iwlagn_mac_event_callback", "Advanced BT coex disabled,ignoring RSSI callback\n");
  }
  __iwl_dbg(priv->dev, 2U, 0, "iwlagn_mac_event_callback", "leave\n");
  return;
}
}
static int iwlagn_mac_set_tim(struct ieee80211_hw *hw , struct ieee80211_sta *sta ,
                              bool set ) 
{ 
  struct iwl_priv *priv ;

  {
  priv = (struct iwl_priv *)(& ((struct iwl_op_mode *)hw->priv)->op_mode_specific);
  queue_work___1(priv->workqueue, & priv->beacon_update);
  return (0);
}
}
static int iwlagn_mac_conf_tx(struct ieee80211_hw *hw , struct ieee80211_vif *vif ,
                              u16 queue , struct ieee80211_tx_queue_params  const  *params ) 
{ 
  struct iwl_priv *priv ;
  struct iwl_vif_priv *vif_priv ;
  struct iwl_rxon_context *ctx ;
  int q ;
    klee_make_symbolic(&q, sizeof(int), "q");
  int __ret_warn_on ;
  long tmp ;
  long tmp___0 ;
  int tmp___1 ;

  {
  priv = (struct iwl_priv *)(& ((struct iwl_op_mode *)hw->priv)->op_mode_specific);
  vif_priv = (struct iwl_vif_priv *)(& vif->drv_priv);
  ctx = vif_priv->ctx;
  __ret_warn_on = (unsigned long )ctx == (unsigned long )((struct iwl_rxon_context *)0);
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/08_1a/drivers/net/wireless/iwlwifi/dvm/mac80211.c",
                       1180);
  } else {

  }
  tmp___0 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp___0 != 0L) {
    return (-22);
  } else {

  }
  __iwl_dbg(priv->dev, 2U, 0, "iwlagn_mac_conf_tx", "enter\n");
  tmp___1 = iwl_is_ready_rf(priv);
  if (tmp___1 == 0) {
    __iwl_dbg(priv->dev, 2U, 0, "iwlagn_mac_conf_tx", "leave - RF not ready\n");
    return (-5);
  } else {

  }
  if ((unsigned int )queue > 3U) {
    __iwl_dbg(priv->dev, 2U, 0, "iwlagn_mac_conf_tx", "leave - queue >= AC_NUM %d\n",
              (int )queue);
    return (0);
  } else {

  }
  q = 3 - (int )queue;
  mutex_lock_nested(& priv->mutex, 0U);
  ctx->qos_data.def_qos_parm.ac[q].cw_min = params->cw_min;
  ctx->qos_data.def_qos_parm.ac[q].cw_max = params->cw_max;
  ctx->qos_data.def_qos_parm.ac[q].aifsn = params->aifs;
  ctx->qos_data.def_qos_parm.ac[q].edca_txop = (unsigned int )((unsigned short )params->txop) * 32U;
  ctx->qos_data.def_qos_parm.ac[q].reserved1 = 0U;
  mutex_unlock(& priv->mutex);
  __iwl_dbg(priv->dev, 2U, 0, "iwlagn_mac_conf_tx", "leave\n");
  return (0);
}
}
static int iwlagn_mac_tx_last_beacon(struct ieee80211_hw *hw ) 
{ 
  struct iwl_priv *priv ;

  {
  priv = (struct iwl_priv *)(& ((struct iwl_op_mode *)hw->priv)->op_mode_specific);
  return (priv->ibss_manager == 1U);
}
}
static int iwl_set_mode(struct iwl_priv *priv , struct iwl_rxon_context *ctx ) 
{ 
  int tmp ;

  {
  iwl_connection_init_rx_config(priv, ctx);
  iwlagn_set_rxon_chain(priv, ctx);
  tmp = iwlagn_commit_rxon(priv, ctx);
  return (tmp);
}
}
static int iwl_setup_interface(struct iwl_priv *priv , struct iwl_rxon_context *ctx ) 
{ 
  struct ieee80211_vif *vif ;
  int err ;
    klee_make_symbolic(&err, sizeof(int), "err");
  int ac ;
    klee_make_symbolic(&ac, sizeof(int), "ac");
  int __ret_warn_on ;
  int tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
  vif = ctx->vif;
  if (debug_locks != 0) {
    tmp = lock_is_held(& priv->mutex.dep_map);
    if (tmp == 0) {
      tmp___0 = 1;
    } else {
      tmp___0 = 0;
    }
  } else {
    tmp___0 = 0;
  }
  __ret_warn_on = tmp___0;
  tmp___1 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp___1 != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/08_1a/drivers/net/wireless/iwlwifi/dvm/mac80211.c",
                       1237);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  priv->iw_mode = vif->type;
  ctx->is_active = 1;
  err = iwl_set_mode(priv, ctx);
  if (err != 0) {
    if (! ctx->always_active) {
      ctx->is_active = 0;
    } else {

    }
    return (err);
  } else {

  }
  if (((unsigned long )(priv->lib)->bt_params != (unsigned long )((struct iwl_dvm_bt_params  const  */* const  */)0) && (int )((priv->lib)->bt_params)->advanced_bt_coexist) && (unsigned int )vif->type == 1U) {
    priv->bt_traffic_load = 2U;
  } else {

  }
  ac = 0;
  goto ldv_55527;
  ldv_55526: 
  vif->hw_queue[ac] = ctx->ac_to_queue[ac];
  ac = ac + 1;
  ldv_55527: ;
  if (ac <= 3) {
    goto ldv_55526;
  } else {

  }

  if ((unsigned int )vif->type == 3U) {
    vif->cab_queue = ctx->mcast_queue;
  } else {
    vif->cab_queue = 255U;
  }
  return (0);
}
}
static int iwlagn_mac_add_interface(struct ieee80211_hw *hw , struct ieee80211_vif *vif ) 
{ 
  struct iwl_priv *priv ;
  struct iwl_vif_priv *vif_priv ;
  struct iwl_rxon_context *tmp ;
  struct iwl_rxon_context *ctx ;
  int err ;
  enum nl80211_iftype viftype ;
  enum nl80211_iftype tmp___0 ;
  bool reset ;
  int tmp___1 ;
  u32 possible_modes ;

  {
  priv = (struct iwl_priv *)(& ((struct iwl_op_mode *)hw->priv)->op_mode_specific);
  vif_priv = (struct iwl_vif_priv *)(& vif->drv_priv);
  ctx = (struct iwl_rxon_context *)0;
  tmp___0 = ieee80211_vif_type_p2p(vif);
  viftype = tmp___0;
  reset = 0;
  __iwl_dbg(priv->dev, 2U, 0, "iwlagn_mac_add_interface", "enter: type %d, addr %pM\n",
            (unsigned int )viftype, (u8 *)(& vif->addr));
  mutex_lock_nested(& priv->mutex, 0U);
  tmp___1 = iwl_is_ready_rf(priv);
  if (tmp___1 == 0) {
    __iwl_warn(priv->dev, "Try to add interface when device not ready\n");
    err = -22;
    goto out;
  } else {

  }
  tmp = (struct iwl_rxon_context *)(& priv->contexts);
  goto ldv_55546;
  ldv_55545: ;
  if ((int )((unsigned long )priv->valid_contexts >> (int )tmp->ctxid) & 1) {
    possible_modes = tmp->interface_modes | tmp->exclusive_interface_modes;
    if ((unsigned long )tmp->vif != (unsigned long )((struct ieee80211_vif *)0)) {
      if ((unsigned long )tmp->vif == (unsigned long )vif) {
        reset = 1;
        ctx = tmp;
        goto ldv_55543;
      } else {

      }
      if ((int )((unsigned long )tmp->exclusive_interface_modes >> (int )(tmp->vif)->type) & 1) {
        err = -22;
        goto out;
      } else {

      }
      goto ldv_55544;
    } else {

    }
    if ((((unsigned long )possible_modes >> (int )viftype) & 1UL) == 0UL) {
      goto ldv_55544;
    } else {

    }
    ctx = tmp;
    goto ldv_55543;
  } else {

  }
  ldv_55544: 
  tmp = tmp + 1;
  ldv_55546: ;
  if ((unsigned long )((struct iwl_rxon_context *)(& priv->contexts) + 2UL) > (unsigned long )tmp) {
    goto ldv_55545;
  } else {

  }
  ldv_55543: ;
  if ((unsigned long )ctx == (unsigned long )((struct iwl_rxon_context *)0)) {
    err = -95;
    goto out;
  } else {

  }
  vif_priv->ctx = ctx;
  ctx->vif = vif;
  if ((unsigned int )vif->type == 6U) {
    _ieee80211_hw_set(priv->hw, 1);
  } else {
    __clear_bit(1L, (unsigned long volatile   *)(& (priv->hw)->flags));
  }
  err = iwl_setup_interface(priv, ctx);
  if (err == 0 || (int )reset) {
    goto out;
  } else {

  }
  ctx->vif = (struct ieee80211_vif *)0;
  priv->iw_mode = 2;
  out: 
  mutex_unlock(& priv->mutex);
  __iwl_dbg(priv->dev, 2U, 0, "iwlagn_mac_add_interface", "leave\n");
  return (err);
}
}
static void iwl_teardown_interface(struct iwl_priv *priv , struct ieee80211_vif *vif ,
                                   bool mode_change ) 
{ 
  struct iwl_rxon_context *ctx ;
  struct iwl_rxon_context *tmp ;
  int __ret_warn_on ;
  int tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;

  {
  tmp = iwl_rxon_ctx_from_vif(vif);
  ctx = tmp;
  if (debug_locks != 0) {
    tmp___0 = lock_is_held(& priv->mutex.dep_map);
    if (tmp___0 == 0) {
      tmp___1 = 1;
    } else {
      tmp___1 = 0;
    }
  } else {
    tmp___1 = 0;
  }
  __ret_warn_on = tmp___1;
  tmp___2 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp___2 != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/08_1a/drivers/net/wireless/iwlwifi/dvm/mac80211.c",
                       1368);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if ((unsigned long )priv->scan_vif == (unsigned long )vif) {
    iwl_scan_cancel_timeout(priv, 200UL);
    iwl_force_scan_end(priv);
  } else {

  }
  if (! mode_change) {
    iwl_set_mode(priv, ctx);
    if (! ctx->always_active) {
      ctx->is_active = 0;
    } else {

    }
  } else {

  }
  if ((unsigned int )vif->type == 1U) {
    priv->bt_traffic_load = priv->last_bt_traffic_load;
  } else {

  }
  return;
}
}
static void iwlagn_mac_remove_interface(struct ieee80211_hw *hw , struct ieee80211_vif *vif ) 
{ 
  struct iwl_priv *priv ;
  struct iwl_rxon_context *ctx ;
  struct iwl_rxon_context *tmp ;
  struct iwl_rxon_context *tmp___0 ;
  int __ret_warn_on ;
  long tmp___1 ;
  long tmp___2 ;

  {
  priv = (struct iwl_priv *)(& ((struct iwl_op_mode *)hw->priv)->op_mode_specific);
  tmp = iwl_rxon_ctx_from_vif(vif);
  ctx = tmp;
  __iwl_dbg(priv->dev, 2U, 0, "iwlagn_mac_remove_interface", "enter\n");
  mutex_lock_nested(& priv->mutex, 0U);
  __ret_warn_on = (unsigned long )ctx->vif != (unsigned long )vif;
  tmp___1 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp___1 != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/08_1a/drivers/net/wireless/iwlwifi/dvm/mac80211.c",
                       1402);
  } else {

  }
  tmp___2 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp___2 != 0L) {
    __iwl_err(priv->dev, 0, 0, "ctx->vif = %p, vif = %p\n", ctx->vif, vif);
    tmp___0 = (struct iwl_rxon_context *)(& priv->contexts);
    goto ldv_55566;
    ldv_55565: ;
    if ((int )((unsigned long )priv->valid_contexts >> (int )tmp___0->ctxid) & 1) {
      __iwl_err(priv->dev, 0, 0, "\tID = %d:\tctx = %p\tctx->vif = %p\n", (unsigned int )tmp___0->ctxid,
                tmp___0, tmp___0->vif);
    } else {

    }
    tmp___0 = tmp___0 + 1;
    ldv_55566: ;
    if ((unsigned long )((struct iwl_rxon_context *)(& priv->contexts) + 2UL) > (unsigned long )tmp___0) {
      goto ldv_55565;
    } else {

    }

  } else {

  }
  ctx->vif = (struct ieee80211_vif *)0;
  iwl_teardown_interface(priv, vif, 0);
  mutex_unlock(& priv->mutex);
  __iwl_dbg(priv->dev, 2U, 0, "iwlagn_mac_remove_interface", "leave\n");
  return;
}
}
static int iwlagn_mac_change_interface(struct ieee80211_hw *hw , struct ieee80211_vif *vif ,
                                       enum nl80211_iftype newtype , bool newp2p ) 
{ 
  struct iwl_priv *priv ;
  struct iwl_rxon_context *ctx ;
  struct iwl_rxon_context *tmp ;
  enum nl80211_iftype newviftype ;
  u32 interface_modes ;
  int err ;
  int tmp___0 ;
  int __ret_warn_on ;
  long tmp___1 ;

  {
  priv = (struct iwl_priv *)(& ((struct iwl_op_mode *)hw->priv)->op_mode_specific);
  newviftype = newtype;
  __iwl_dbg(priv->dev, 2U, 0, "iwlagn_mac_change_interface", "enter\n");
  newtype = ieee80211_iftype_p2p(newtype, (int )newp2p);
  mutex_lock_nested(& priv->mutex, 0U);
  ctx = iwl_rxon_ctx_from_vif(vif);
  if ((unsigned int )ctx->ctxid != 0U) {
    err = -16;
    goto out;
  } else {

  }
  if ((unsigned long )ctx->vif == (unsigned long )((struct ieee80211_vif *)0)) {
    err = -16;
    goto out;
  } else {
    tmp___0 = iwl_is_ready_rf(priv);
    if (tmp___0 == 0) {
      err = -16;
      goto out;
    } else {

    }
  }
  interface_modes = ctx->interface_modes | ctx->exclusive_interface_modes;
  if ((((unsigned long )interface_modes >> (int )newtype) & 1UL) == 0UL) {
    err = -16;
    goto out;
  } else {

  }
  if ((int )((unsigned long )ctx->exclusive_interface_modes >> (int )newtype) & 1) {
    tmp = (struct iwl_rxon_context *)(& priv->contexts);
    goto ldv_55584;
    ldv_55583: ;
    if ((int )((unsigned long )priv->valid_contexts >> (int )tmp->ctxid) & 1) {
      if ((unsigned long )ctx == (unsigned long )tmp) {
        goto ldv_55582;
      } else {

      }
      if (! tmp->is_active) {
        goto ldv_55582;
      } else {

      }
      err = -16;
      goto out;
    } else {

    }
    ldv_55582: 
    tmp = tmp + 1;
    ldv_55584: ;
    if ((unsigned long )((struct iwl_rxon_context *)(& priv->contexts) + 2UL) > (unsigned long )tmp) {
      goto ldv_55583;
    } else {

    }

  } else {

  }
  iwl_teardown_interface(priv, vif, 1);
  vif->type = newviftype;
  vif->p2p = newp2p;
  err = iwl_setup_interface(priv, ctx);
  __ret_warn_on = err != 0;
  tmp___1 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp___1 != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/08_1a/drivers/net/wireless/iwlwifi/dvm/mac80211.c",
                       1485);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  err = 0;
  out: 
  mutex_unlock(& priv->mutex);
  __iwl_dbg(priv->dev, 2U, 0, "iwlagn_mac_change_interface", "leave\n");
  return (err);
}
}
static int iwlagn_mac_hw_scan(struct ieee80211_hw *hw , struct ieee80211_vif *vif ,
                              struct ieee80211_scan_request *hw_req ) 
{ 
  struct iwl_priv *priv ;
  struct cfg80211_scan_request *req ;
  int ret ;

  {
  priv = (struct iwl_priv *)(& ((struct iwl_op_mode *)hw->priv)->op_mode_specific);
  req = & hw_req->req;
  __iwl_dbg(priv->dev, 2U, 0, "iwlagn_mac_hw_scan", "enter\n");
  if (req->n_channels == 0U) {
    return (-22);
  } else {

  }
  mutex_lock_nested(& priv->mutex, 0U);
  if ((unsigned int )priv->scan_type != 0U) {
    __iwl_dbg(priv->dev, 2048U, 0, "iwlagn_mac_hw_scan", "SCAN request during internal scan - defer\n");
    priv->scan_request = req;
    priv->scan_vif = vif;
    ret = 0;
  } else {
    priv->scan_request = req;
    priv->scan_vif = vif;
    ret = iwl_scan_initiate(priv, vif, 0, (req->channels[0])->band);
    if (ret != 0) {
      priv->scan_request = (struct cfg80211_scan_request *)0;
      priv->scan_vif = (struct ieee80211_vif *)0;
    } else {

    }
  }
  __iwl_dbg(priv->dev, 2U, 0, "iwlagn_mac_hw_scan", "leave\n");
  mutex_unlock(& priv->mutex);
  return (ret);
}
}
static void iwl_sta_modify_ps_wake(struct iwl_priv *priv , int sta_id ) 
{ 
  struct iwl_addsta_cmd cmd ;

  {
  cmd.mode = 1U;
  cmd.reserved[0] = (unsigned char)0;
  cmd.reserved[1] = (unsigned char)0;
  cmd.reserved[2] = (unsigned char)0;
  cmd.sta.addr[0] = (unsigned char)0;
  cmd.sta.addr[1] = (unsigned char)0;
  cmd.sta.addr[2] = (unsigned char)0;
  cmd.sta.addr[3] = (unsigned char)0;
  cmd.sta.addr[4] = (unsigned char)0;
  cmd.sta.addr[5] = (unsigned char)0;
  cmd.sta.reserved1 = (unsigned short)0;
  cmd.sta.sta_id = (unsigned char )sta_id;
  cmd.sta.modify_mask = (unsigned char)0;
  cmd.sta.reserved2 = (unsigned short)0;
  cmd.key.key_flags = (unsigned short)0;
  cmd.key.tkip_rx_tsc_byte2 = (unsigned char)0;
  cmd.key.reserved1 = (unsigned char)0;
  cmd.key.tkip_rx_ttak[0] = (unsigned short)0;
  cmd.key.tkip_rx_ttak[1] = (unsigned short)0;
  cmd.key.tkip_rx_ttak[2] = (unsigned short)0;
  cmd.key.tkip_rx_ttak[3] = (unsigned short)0;
  cmd.key.tkip_rx_ttak[4] = (unsigned short)0;
  cmd.key.key_offset = (unsigned char)0;
  cmd.key.reserved2 = (unsigned char)0;
  cmd.key.key[0] = (unsigned char)0;
  cmd.key.key[1] = (unsigned char)0;
  cmd.key.key[2] = (unsigned char)0;
  cmd.key.key[3] = (unsigned char)0;
  cmd.key.key[4] = (unsigned char)0;
  cmd.key.key[5] = (unsigned char)0;
  cmd.key.key[6] = (unsigned char)0;
  cmd.key.key[7] = (unsigned char)0;
  cmd.key.key[8] = (unsigned char)0;
  cmd.key.key[9] = (unsigned char)0;
  cmd.key.key[10] = (unsigned char)0;
  cmd.key.key[11] = (unsigned char)0;
  cmd.key.key[12] = (unsigned char)0;
  cmd.key.key[13] = (unsigned char)0;
  cmd.key.key[14] = (unsigned char)0;
  cmd.key.key[15] = (unsigned char)0;
  cmd.key.tx_secur_seq_cnt = 0ULL;
  cmd.key.hw_tkip_mic_rx_key = 0ULL;
  cmd.key.hw_tkip_mic_tx_key = 0ULL;
  cmd.station_flags = 0U;
  cmd.station_flags_msk = 256U;
  cmd.tid_disable_tx = (unsigned short)0;
  cmd.legacy_reserved = (unsigned short)0;
  cmd.add_immediate_ba_tid = (unsigned char)0;
  cmd.remove_immediate_ba_tid = (unsigned char)0;
  cmd.add_immediate_ba_ssn = (unsigned short)0;
  cmd.sleep_tx_count = (unsigned short)0;
  cmd.reserved2 = (unsigned short)0;
  iwl_send_add_sta(priv, & cmd, 1);
  return;
}
}
static void iwlagn_mac_sta_notify(struct ieee80211_hw *hw , struct ieee80211_vif *vif ,
                                  enum sta_notify_cmd cmd , struct ieee80211_sta *sta ) 
{ 
  struct iwl_priv *priv ;
  struct iwl_station_priv *sta_priv ;
  int sta_id ;
    klee_make_symbolic(&sta_id, sizeof(int), "sta_id");
  int __ret_warn_on ;
  long tmp ;
  int tmp___0 ;
  int __ret_warn_on___0 ;
  long tmp___1 ;

  {
  priv = (struct iwl_priv *)(& ((struct iwl_op_mode *)hw->priv)->op_mode_specific);
  sta_priv = (struct iwl_station_priv *)(& sta->drv_priv);
  __iwl_dbg(priv->dev, 2U, 0, "iwlagn_mac_sta_notify", "enter\n");
  switch ((unsigned int )cmd) {
  case 0U: 
  __ret_warn_on = ! sta_priv->client;
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/08_1a/drivers/net/wireless/iwlwifi/dvm/mac80211.c",
                       1573);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  sta_priv->asleep = 1;
  tmp___0 = atomic_read((atomic_t const   *)(& sta_priv->pending_frames));
  if (tmp___0 > 0) {
    ieee80211_sta_block_awake(hw, sta, 1);
  } else {

  }
  goto ldv_55615;
  case 1U: 
  __ret_warn_on___0 = ! sta_priv->client;
  tmp___1 = ldv__builtin_expect(__ret_warn_on___0 != 0, 0L);
  if (tmp___1 != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/08_1a/drivers/net/wireless/iwlwifi/dvm/mac80211.c",
                       1579);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on___0 != 0, 0L);
  if (! sta_priv->asleep) {
    goto ldv_55615;
  } else {

  }
  sta_priv->asleep = 0;
  sta_id = iwl_sta_id(sta);
  if (sta_id != 255) {
    iwl_sta_modify_ps_wake(priv, sta_id);
  } else {

  }
  goto ldv_55615;
  default: ;
  goto ldv_55615;
  }
  ldv_55615: 
  __iwl_dbg(priv->dev, 2U, 0, "iwlagn_mac_sta_notify", "leave\n");
  return;
}
}
struct ieee80211_ops  const  iwlagn_hw_ops  = 
     {& iwlagn_mac_tx, & iwlagn_mac_start, & iwlagn_mac_stop, & iwlagn_mac_suspend,
    & iwlagn_mac_resume, & iwlagn_mac_set_wakeup, & iwlagn_mac_add_interface, & iwlagn_mac_change_interface,
    & iwlagn_mac_remove_interface, & iwlagn_mac_config, & iwlagn_bss_info_changed,
    0, 0, 0, & iwlagn_configure_filter, & iwlagn_mac_set_tim, & iwlagn_mac_set_key,
    & iwlagn_mac_update_tkip_key, & iwlagn_mac_set_rekey_data, 0, & iwlagn_mac_hw_scan,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, & iwlagn_mac_sta_notify, & iwlagn_mac_sta_state,
    0, 0, 0, 0, & iwlagn_mac_conf_tx, 0, 0, 0, & iwlagn_mac_tx_last_beacon, & iwlagn_mac_ampdu_action,
    0, 0, 0, 0, 0, & iwlagn_mac_flush, & iwlagn_mac_channel_switch, 0, 0, 0, 0, 0,
    0, 0, 0, & iwlagn_mac_event_callback, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
struct ieee80211_hw *iwl_alloc_all(void) 
{ 
  struct iwl_priv *priv ;
  struct iwl_op_mode *op_mode ;
  struct ieee80211_hw *hw ;

  {
  hw = ldv_ieee80211_alloc_hw_65(14456UL, & iwlagn_hw_ops);
  if ((unsigned long )hw == (unsigned long )((struct ieee80211_hw *)0)) {
    goto out;
  } else {

  }
  op_mode = (struct iwl_op_mode *)hw->priv;
  priv = (struct iwl_priv *)(& op_mode->op_mode_specific);
  priv->hw = hw;
  out: ;
  return (hw);
}
}
int ldv_retval_13  ;
    klee_make_symbolic(&ldv_retval_13, sizeof(int), "ldv_retval_13");
void ldv_initialize_ieee80211_ops_64(void) 
{ 
  void *tmp ;

  {
  tmp = ldv_init_zalloc(160UL);
  iwlagn_hw_ops_group0 = (struct ieee80211_hw *)tmp;
  return;
}
}
void ldv_main_exported_64(void) 
{ 
  struct ieee80211_vif *ldvarg148 ;
  void *tmp ;
  struct ieee80211_sta *ldvarg139 ;
  void *tmp___0 ;
  u8 ldvarg130 ;
  u32 ldvarg117 ;
  u32 ldvarg143 ;
  struct ieee80211_vif *ldvarg108 ;
  void *tmp___1 ;
  struct ieee80211_key_conf *ldvarg150 ;
  void *tmp___2 ;
  struct sk_buff *ldvarg133 ;
  void *tmp___3 ;
  unsigned int ldvarg124 ;
    klee_make_symbolic(&ldvarg124, sizeof(int), "ldvarg124");
  u16 *ldvarg127 ;
  void *tmp___4 ;
  struct ieee80211_vif *ldvarg116 ;
  void *tmp___5 ;
  struct ieee80211_sta *ldvarg147 ;
  void *tmp___6 ;
  struct ieee80211_vif *ldvarg119 ;
  void *tmp___7 ;
  struct ieee80211_event *ldvarg120 ;
  void *tmp___8 ;
  u16 *ldvarg113 ;
  void *tmp___9 ;
  struct ieee80211_tx_queue_params *ldvarg135 ;
  void *tmp___10 ;
  bool ldvarg112 ;
  enum ieee80211_sta_state ldvarg102 ;
  struct ieee80211_vif *ldvarg153 ;
  void *tmp___11 ;
  struct ieee80211_vif *ldvarg111 ;
  void *tmp___12 ;
  unsigned int *ldvarg123 ;
  void *tmp___13 ;
  struct ieee80211_vif *ldvarg126 ;
  void *tmp___14 ;
  struct ieee80211_sta *ldvarg128 ;
  void *tmp___15 ;
  struct ieee80211_bss_conf *ldvarg144 ;
  void *tmp___16 ;
  u64 ldvarg122 ;
  struct ieee80211_vif *ldvarg137 ;
  void *tmp___17 ;
  bool ldvarg151 ;
  u32 ldvarg154 ;
  struct ieee80211_vif *ldvarg104 ;
  void *tmp___18 ;
  struct ieee80211_vif *ldvarg121 ;
  void *tmp___19 ;
  struct ieee80211_vif *ldvarg142 ;
  void *tmp___20 ;
  enum nl80211_iftype ldvarg107 ;
  enum set_key_cmd ldvarg149 ;
  enum ieee80211_ampdu_mlme_action ldvarg129 ;
  struct ieee80211_vif *ldvarg110 ;
  void *tmp___21 ;
  bool ldvarg138 ;
  u16 ldvarg132 ;
  u32 ldvarg152 ;
  enum ieee80211_sta_state ldvarg105 ;
  struct ieee80211_sta *ldvarg140 ;
  void *tmp___22 ;
  struct ieee80211_vif *ldvarg145 ;
  void *tmp___23 ;
  struct ieee80211_sta *ldvarg103 ;
  void *tmp___24 ;
  struct ieee80211_sta *ldvarg114 ;
  void *tmp___25 ;
  struct ieee80211_channel_switch *ldvarg125 ;
  void *tmp___26 ;
  u16 ldvarg136 ;
  struct ieee80211_scan_request *ldvarg109 ;
  void *tmp___27 ;
  struct ieee80211_key_conf *ldvarg115 ;
  void *tmp___28 ;
  struct cfg80211_gtk_rekey_data *ldvarg118 ;
  void *tmp___29 ;
  enum sta_notify_cmd ldvarg141 ;
  struct cfg80211_wowlan *ldvarg146 ;
  void *tmp___30 ;
  struct ieee80211_vif *ldvarg101 ;
  void *tmp___31 ;
  bool ldvarg106 ;
  struct ieee80211_tx_control *ldvarg134 ;
  void *tmp___32 ;
  struct ieee80211_vif *ldvarg131 ;
  void *tmp___33 ;
  int tmp___34 ;
    klee_make_symbolic(&tmp___34, sizeof(int), "tmp___34");

  {
  tmp = ldv_init_zalloc(296UL);
  ldvarg148 = (struct ieee80211_vif *)tmp;
  tmp___0 = ldv_init_zalloc(216UL);
  ldvarg139 = (struct ieee80211_sta *)tmp___0;
  tmp___1 = ldv_init_zalloc(296UL);
  ldvarg108 = (struct ieee80211_vif *)tmp___1;
  tmp___2 = ldv_init_zalloc(24UL);
  ldvarg150 = (struct ieee80211_key_conf *)tmp___2;
  tmp___3 = ldv_init_zalloc(232UL);
  ldvarg133 = (struct sk_buff *)tmp___3;
  tmp___4 = ldv_init_zalloc(2UL);
  ldvarg127 = (u16 *)tmp___4;
  tmp___5 = ldv_init_zalloc(296UL);
  ldvarg116 = (struct ieee80211_vif *)tmp___5;
  tmp___6 = ldv_init_zalloc(216UL);
  ldvarg147 = (struct ieee80211_sta *)tmp___6;
  tmp___7 = ldv_init_zalloc(296UL);
  ldvarg119 = (struct ieee80211_vif *)tmp___7;
  tmp___8 = ldv_init_zalloc(24UL);
  ldvarg120 = (struct ieee80211_event *)tmp___8;
  tmp___9 = ldv_init_zalloc(2UL);
  ldvarg113 = (u16 *)tmp___9;
  tmp___10 = ldv_init_zalloc(10UL);
  ldvarg135 = (struct ieee80211_tx_queue_params *)tmp___10;
  tmp___11 = ldv_init_zalloc(296UL);
  ldvarg153 = (struct ieee80211_vif *)tmp___11;
  tmp___12 = ldv_init_zalloc(296UL);
  ldvarg111 = (struct ieee80211_vif *)tmp___12;
  tmp___13 = ldv_init_zalloc(4UL);
  ldvarg123 = (unsigned int *)tmp___13;
  tmp___14 = ldv_init_zalloc(296UL);
  ldvarg126 = (struct ieee80211_vif *)tmp___14;
  tmp___15 = ldv_init_zalloc(216UL);
  ldvarg128 = (struct ieee80211_sta *)tmp___15;
  tmp___16 = ldv_init_zalloc(240UL);
  ldvarg144 = (struct ieee80211_bss_conf *)tmp___16;
  tmp___17 = ldv_init_zalloc(296UL);
  ldvarg137 = (struct ieee80211_vif *)tmp___17;
  tmp___18 = ldv_init_zalloc(296UL);
  ldvarg104 = (struct ieee80211_vif *)tmp___18;
  tmp___19 = ldv_init_zalloc(296UL);
  ldvarg121 = (struct ieee80211_vif *)tmp___19;
  tmp___20 = ldv_init_zalloc(296UL);
  ldvarg142 = (struct ieee80211_vif *)tmp___20;
  tmp___21 = ldv_init_zalloc(296UL);
  ldvarg110 = (struct ieee80211_vif *)tmp___21;
  tmp___22 = ldv_init_zalloc(216UL);
  ldvarg140 = (struct ieee80211_sta *)tmp___22;
  tmp___23 = ldv_init_zalloc(296UL);
  ldvarg145 = (struct ieee80211_vif *)tmp___23;
  tmp___24 = ldv_init_zalloc(216UL);
  ldvarg103 = (struct ieee80211_sta *)tmp___24;
  tmp___25 = ldv_init_zalloc(216UL);
  ldvarg114 = (struct ieee80211_sta *)tmp___25;
  tmp___26 = ldv_init_zalloc(48UL);
  ldvarg125 = (struct ieee80211_channel_switch *)tmp___26;
  tmp___27 = ldv_init_zalloc(168UL);
  ldvarg109 = (struct ieee80211_scan_request *)tmp___27;
  tmp___28 = ldv_init_zalloc(24UL);
  ldvarg115 = (struct ieee80211_key_conf *)tmp___28;
  tmp___29 = ldv_init_zalloc(24UL);
  ldvarg118 = (struct cfg80211_gtk_rekey_data *)tmp___29;
  tmp___30 = ldv_init_zalloc(40UL);
  ldvarg146 = (struct cfg80211_wowlan *)tmp___30;
  tmp___31 = ldv_init_zalloc(296UL);
  ldvarg101 = (struct ieee80211_vif *)tmp___31;
  tmp___32 = ldv_init_zalloc(8UL);
  ldvarg134 = (struct ieee80211_tx_control *)tmp___32;
  tmp___33 = ldv_init_zalloc(296UL);
  ldvarg131 = (struct ieee80211_vif *)tmp___33;
  ldv_memset((void *)(& ldvarg130), 0, 1UL);
  ldv_memset((void *)(& ldvarg117), 0, 4UL);
  ldv_memset((void *)(& ldvarg143), 0, 4UL);
  ldv_memset((void *)(& ldvarg124), 0, 4UL);
  ldv_memset((void *)(& ldvarg112), 0, 1UL);
  ldv_memset((void *)(& ldvarg102), 0, 4UL);
  ldv_memset((void *)(& ldvarg122), 0, 8UL);
  ldv_memset((void *)(& ldvarg151), 0, 1UL);
  ldv_memset((void *)(& ldvarg154), 0, 4UL);
  ldv_memset((void *)(& ldvarg107), 0, 4UL);
  ldv_memset((void *)(& ldvarg149), 0, 4UL);
  ldv_memset((void *)(& ldvarg129), 0, 4UL);
  ldv_memset((void *)(& ldvarg138), 0, 1UL);
  ldv_memset((void *)(& ldvarg132), 0, 2UL);
  ldv_memset((void *)(& ldvarg152), 0, 4UL);
  ldv_memset((void *)(& ldvarg105), 0, 4UL);
  ldv_memset((void *)(& ldvarg136), 0, 2UL);
  ldv_memset((void *)(& ldvarg141), 0, 4UL);
  ldv_memset((void *)(& ldvarg106), 0, 1UL);
  tmp___34 = __VERIFIER_nondet_int();
  switch (tmp___34) {
  case 0: ;
  if (ldv_state_variable_64 == 1) {
    ldv_retval_13 = iwlagn_mac_start(iwlagn_hw_ops_group0);
    if (ldv_retval_13 == 0) {
      ldv_state_variable_64 = 2;
      ref_cnt = ref_cnt + 1;
    } else {

    }
  } else {

  }
  goto ldv_55690;
  case 1: ;
  if (ldv_state_variable_64 == 1) {
    iwlagn_mac_config(iwlagn_hw_ops_group0, ldvarg154);
    ldv_state_variable_64 = 1;
  } else {

  }
  if (ldv_state_variable_64 == 2) {
    iwlagn_mac_config(iwlagn_hw_ops_group0, ldvarg154);
    ldv_state_variable_64 = 2;
  } else {

  }
  goto ldv_55690;
  case 2: ;
  if (ldv_state_variable_64 == 1) {
    iwlagn_mac_flush(iwlagn_hw_ops_group0, ldvarg153, ldvarg152, (int )ldvarg151);
    ldv_state_variable_64 = 1;
  } else {

  }
  if (ldv_state_variable_64 == 2) {
    iwlagn_mac_flush(iwlagn_hw_ops_group0, ldvarg153, ldvarg152, (int )ldvarg151);
    ldv_state_variable_64 = 2;
  } else {

  }
  goto ldv_55690;
  case 3: ;
  if (ldv_state_variable_64 == 1) {
    iwlagn_mac_set_key(iwlagn_hw_ops_group0, ldvarg149, ldvarg148, ldvarg147, ldvarg150);
    ldv_state_variable_64 = 1;
  } else {

  }
  if (ldv_state_variable_64 == 2) {
    iwlagn_mac_set_key(iwlagn_hw_ops_group0, ldvarg149, ldvarg148, ldvarg147, ldvarg150);
    ldv_state_variable_64 = 2;
  } else {

  }
  goto ldv_55690;
  case 4: ;
  if (ldv_state_variable_64 == 1) {
    iwlagn_mac_suspend(iwlagn_hw_ops_group0, ldvarg146);
    ldv_state_variable_64 = 1;
  } else {

  }
  if (ldv_state_variable_64 == 2) {
    iwlagn_mac_suspend(iwlagn_hw_ops_group0, ldvarg146);
    ldv_state_variable_64 = 2;
  } else {

  }
  goto ldv_55690;
  case 5: ;
  if (ldv_state_variable_64 == 1) {
    iwlagn_bss_info_changed(iwlagn_hw_ops_group0, ldvarg145, ldvarg144, ldvarg143);
    ldv_state_variable_64 = 1;
  } else {

  }
  if (ldv_state_variable_64 == 2) {
    iwlagn_bss_info_changed(iwlagn_hw_ops_group0, ldvarg145, ldvarg144, ldvarg143);
    ldv_state_variable_64 = 2;
  } else {

  }
  goto ldv_55690;
  case 6: ;
  if (ldv_state_variable_64 == 1) {
    iwlagn_mac_sta_notify(iwlagn_hw_ops_group0, ldvarg142, ldvarg141, ldvarg140);
    ldv_state_variable_64 = 1;
  } else {

  }
  if (ldv_state_variable_64 == 2) {
    iwlagn_mac_sta_notify(iwlagn_hw_ops_group0, ldvarg142, ldvarg141, ldvarg140);
    ldv_state_variable_64 = 2;
  } else {

  }
  goto ldv_55690;
  case 7: ;
  if (ldv_state_variable_64 == 1) {
    iwlagn_mac_set_tim(iwlagn_hw_ops_group0, ldvarg139, (int )ldvarg138);
    ldv_state_variable_64 = 1;
  } else {

  }
  if (ldv_state_variable_64 == 2) {
    iwlagn_mac_set_tim(iwlagn_hw_ops_group0, ldvarg139, (int )ldvarg138);
    ldv_state_variable_64 = 2;
  } else {

  }
  goto ldv_55690;
  case 8: ;
  if (ldv_state_variable_64 == 1) {
    iwlagn_mac_conf_tx(iwlagn_hw_ops_group0, ldvarg137, (int )ldvarg136, (struct ieee80211_tx_queue_params  const  *)ldvarg135);
    ldv_state_variable_64 = 1;
  } else {

  }
  if (ldv_state_variable_64 == 2) {
    iwlagn_mac_conf_tx(iwlagn_hw_ops_group0, ldvarg137, (int )ldvarg136, (struct ieee80211_tx_queue_params  const  *)ldvarg135);
    ldv_state_variable_64 = 2;
  } else {

  }
  goto ldv_55690;
  case 9: ;
  if (ldv_state_variable_64 == 2) {
    iwlagn_mac_stop(iwlagn_hw_ops_group0);
    ldv_state_variable_64 = 1;
    ref_cnt = ref_cnt - 1;
  } else {

  }
  goto ldv_55690;
  case 10: ;
  if (ldv_state_variable_64 == 1) {
    iwlagn_mac_tx(iwlagn_hw_ops_group0, ldvarg134, ldvarg133);
    ldv_state_variable_64 = 1;
  } else {

  }
  if (ldv_state_variable_64 == 2) {
    iwlagn_mac_tx(iwlagn_hw_ops_group0, ldvarg134, ldvarg133);
    ldv_state_variable_64 = 2;
  } else {

  }
  goto ldv_55690;
  case 11: ;
  if (ldv_state_variable_64 == 1) {
    iwlagn_mac_resume(iwlagn_hw_ops_group0);
    ldv_state_variable_64 = 1;
  } else {

  }
  if (ldv_state_variable_64 == 2) {
    iwlagn_mac_resume(iwlagn_hw_ops_group0);
    ldv_state_variable_64 = 2;
  } else {

  }
  goto ldv_55690;
  case 12: ;
  if (ldv_state_variable_64 == 1) {
    iwlagn_mac_ampdu_action(iwlagn_hw_ops_group0, ldvarg131, ldvarg129, ldvarg128,
                            (int )ldvarg132, ldvarg127, (int )ldvarg130);
    ldv_state_variable_64 = 1;
  } else {

  }
  if (ldv_state_variable_64 == 2) {
    iwlagn_mac_ampdu_action(iwlagn_hw_ops_group0, ldvarg131, ldvarg129, ldvarg128,
                            (int )ldvarg132, ldvarg127, (int )ldvarg130);
    ldv_state_variable_64 = 2;
  } else {

  }
  goto ldv_55690;
  case 13: ;
  if (ldv_state_variable_64 == 1) {
    iwlagn_mac_channel_switch(iwlagn_hw_ops_group0, ldvarg126, ldvarg125);
    ldv_state_variable_64 = 1;
  } else {

  }
  if (ldv_state_variable_64 == 2) {
    iwlagn_mac_channel_switch(iwlagn_hw_ops_group0, ldvarg126, ldvarg125);
    ldv_state_variable_64 = 2;
  } else {

  }
  goto ldv_55690;
  case 14: ;
  if (ldv_state_variable_64 == 1) {
    iwlagn_configure_filter(iwlagn_hw_ops_group0, ldvarg124, ldvarg123, ldvarg122);
    ldv_state_variable_64 = 1;
  } else {

  }
  if (ldv_state_variable_64 == 2) {
    iwlagn_configure_filter(iwlagn_hw_ops_group0, ldvarg124, ldvarg123, ldvarg122);
    ldv_state_variable_64 = 2;
  } else {

  }
  goto ldv_55690;
  case 15: ;
  if (ldv_state_variable_64 == 1) {
    iwlagn_mac_tx_last_beacon(iwlagn_hw_ops_group0);
    ldv_state_variable_64 = 1;
  } else {

  }
  if (ldv_state_variable_64 == 2) {
    iwlagn_mac_tx_last_beacon(iwlagn_hw_ops_group0);
    ldv_state_variable_64 = 2;
  } else {

  }
  goto ldv_55690;
  case 16: ;
  if (ldv_state_variable_64 == 1) {
    iwlagn_mac_event_callback(iwlagn_hw_ops_group0, ldvarg121, (struct ieee80211_event  const  *)ldvarg120);
    ldv_state_variable_64 = 1;
  } else {

  }
  if (ldv_state_variable_64 == 2) {
    iwlagn_mac_event_callback(iwlagn_hw_ops_group0, ldvarg121, (struct ieee80211_event  const  *)ldvarg120);
    ldv_state_variable_64 = 2;
  } else {

  }
  goto ldv_55690;
  case 17: ;
  if (ldv_state_variable_64 == 1) {
    iwlagn_mac_set_rekey_data(iwlagn_hw_ops_group0, ldvarg119, ldvarg118);
    ldv_state_variable_64 = 1;
  } else {

  }
  if (ldv_state_variable_64 == 2) {
    iwlagn_mac_set_rekey_data(iwlagn_hw_ops_group0, ldvarg119, ldvarg118);
    ldv_state_variable_64 = 2;
  } else {

  }
  goto ldv_55690;
  case 18: ;
  if (ldv_state_variable_64 == 1) {
    iwlagn_mac_update_tkip_key(iwlagn_hw_ops_group0, ldvarg116, ldvarg115, ldvarg114,
                               ldvarg117, ldvarg113);
    ldv_state_variable_64 = 1;
  } else {

  }
  if (ldv_state_variable_64 == 2) {
    iwlagn_mac_update_tkip_key(iwlagn_hw_ops_group0, ldvarg116, ldvarg115, ldvarg114,
                               ldvarg117, ldvarg113);
    ldv_state_variable_64 = 2;
  } else {

  }
  goto ldv_55690;
  case 19: ;
  if (ldv_state_variable_64 == 1) {
    iwlagn_mac_set_wakeup(iwlagn_hw_ops_group0, (int )ldvarg112);
    ldv_state_variable_64 = 1;
  } else {

  }
  if (ldv_state_variable_64 == 2) {
    iwlagn_mac_set_wakeup(iwlagn_hw_ops_group0, (int )ldvarg112);
    ldv_state_variable_64 = 2;
  } else {

  }
  goto ldv_55690;
  case 20: ;
  if (ldv_state_variable_64 == 1) {
    iwlagn_mac_add_interface(iwlagn_hw_ops_group0, ldvarg111);
    ldv_state_variable_64 = 1;
  } else {

  }
  if (ldv_state_variable_64 == 2) {
    iwlagn_mac_add_interface(iwlagn_hw_ops_group0, ldvarg111);
    ldv_state_variable_64 = 2;
  } else {

  }
  goto ldv_55690;
  case 21: ;
  if (ldv_state_variable_64 == 1) {
    iwlagn_mac_hw_scan(iwlagn_hw_ops_group0, ldvarg110, ldvarg109);
    ldv_state_variable_64 = 1;
  } else {

  }
  if (ldv_state_variable_64 == 2) {
    iwlagn_mac_hw_scan(iwlagn_hw_ops_group0, ldvarg110, ldvarg109);
    ldv_state_variable_64 = 2;
  } else {

  }
  goto ldv_55690;
  case 22: ;
  if (ldv_state_variable_64 == 1) {
    iwlagn_mac_change_interface(iwlagn_hw_ops_group0, ldvarg108, ldvarg107, (int )ldvarg106);
    ldv_state_variable_64 = 1;
  } else {

  }
  if (ldv_state_variable_64 == 2) {
    iwlagn_mac_change_interface(iwlagn_hw_ops_group0, ldvarg108, ldvarg107, (int )ldvarg106);
    ldv_state_variable_64 = 2;
  } else {

  }
  goto ldv_55690;
  case 23: ;
  if (ldv_state_variable_64 == 1) {
    iwlagn_mac_sta_state(iwlagn_hw_ops_group0, ldvarg104, ldvarg103, ldvarg102, ldvarg105);
    ldv_state_variable_64 = 1;
  } else {

  }
  if (ldv_state_variable_64 == 2) {
    iwlagn_mac_sta_state(iwlagn_hw_ops_group0, ldvarg104, ldvarg103, ldvarg102, ldvarg105);
    ldv_state_variable_64 = 2;
  } else {

  }
  goto ldv_55690;
  case 24: ;
  if (ldv_state_variable_64 == 1) {
    iwlagn_mac_remove_interface(iwlagn_hw_ops_group0, ldvarg101);
    ldv_state_variable_64 = 1;
  } else {

  }
  if (ldv_state_variable_64 == 2) {
    iwlagn_mac_remove_interface(iwlagn_hw_ops_group0, ldvarg101);
    ldv_state_variable_64 = 2;
  } else {

  }
  goto ldv_55690;
  default: 
  ldv_stop();
  }
  ldv_55690: ;
  return;
}
}
bool ldv_queue_work_on_59(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_7(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_delayed_work_on_60(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_7(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_work_on_61(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_7(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
void ldv_flush_workqueue_62(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
  flush_workqueue(ldv_func_arg1);
  call_and_disable_all_7(2);
  return;
}
}
bool ldv_queue_delayed_work_on_63(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_7(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
void ldv_flush_workqueue_64(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
  flush_workqueue(ldv_func_arg1);
  call_and_disable_all_7(2);
  return;
}
}
__inline static struct ieee80211_hw *ldv_ieee80211_alloc_hw_65(size_t priv_data_len ,
                                                               struct ieee80211_ops  const  *ops ) 
{ 
  ldv_func_ret_type___11 ldv_func_res ;
  struct ieee80211_hw *tmp ;

  {
  tmp = ieee80211_alloc_hw(priv_data_len, ops);
  ldv_func_res = tmp;
  if ((unsigned long )ldv_func_res != (unsigned long )((ldv_func_ret_type___11 )0)) {
    ldv_state_variable_64 = 1;
    ldv_initialize_ieee80211_ops_64();
    iwlagn_hw_ops_group0 = ldv_func_res;
  } else {

  }
  return (ldv_func_res);
}
}
__inline static long ldv__builtin_expect(long exp , long c ) ;
bool ldv_queue_work_on_77(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_work_on_79(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_delayed_work_on_78(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
bool ldv_queue_delayed_work_on_81(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
void ldv_flush_workqueue_80(struct workqueue_struct *ldv_func_arg1 ) ;
extern void msleep(unsigned int  ) ;
__inline static void iwl_trans_fw_alive(struct iwl_trans *trans , u32 scd_addr ) 
{ 


  {
  __might_sleep("drivers/net/wireless/iwlwifi/dvm/../iwl-trans.h", 685, 0);
  trans->state = 1;
  (*((trans->ops)->fw_alive))(trans, scd_addr);
  return;
}
}
__inline static int iwl_trans_start_fw(struct iwl_trans *trans , struct fw_img  const  *fw ,
                                       bool run_in_rfkill ) 
{ 
  bool __warned ;
  int __ret_warn_once ;
  int __ret_warn_on ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;

  {
  __might_sleep("drivers/net/wireless/iwlwifi/dvm/../iwl-trans.h", 696, 0);
  __ret_warn_once = (unsigned int )trans->rx_mpdu_cmd == 0U;
  tmp___1 = ldv__builtin_expect(__ret_warn_once != 0, 0L);
  if (tmp___1 != 0L) {
    __ret_warn_on = ! __warned;
    tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
    if (tmp != 0L) {
      warn_slowpath_null("drivers/net/wireless/iwlwifi/dvm/../iwl-trans.h", 698);
    } else {

    }
    tmp___0 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
    if (tmp___0 != 0L) {
      __warned = 1;
    } else {

    }
  } else {

  }
  ldv__builtin_expect(__ret_warn_once != 0, 0L);
  clear_bit(5L, (unsigned long volatile   *)(& trans->status));
  tmp___2 = (*((trans->ops)->start_fw))(trans, fw, (int )run_in_rfkill);
  return (tmp___2);
}
}
__inline static void iwl_trans_txq_enable_cfg(struct iwl_trans *trans , int queue ,
                                              u16 ssn , struct iwl_trans_txq_scd_cfg  const  *cfg ,
                                              unsigned int queue_wdg_timeout ) 
{ 
  long tmp ;

  {
  __might_sleep("drivers/net/wireless/iwlwifi/dvm/../iwl-trans.h", 856, 0);
  tmp = ldv__builtin_expect((unsigned int )trans->state != 1U, 0L);
  if (tmp != 0L) {
    __iwl_err(trans->dev, 0, 0, "%s bad state = %d\n", "iwl_trans_txq_enable_cfg",
              (unsigned int )trans->state);
  } else {

  }
  (*((trans->ops)->txq_enable))(trans, queue, (int )ssn, cfg, queue_wdg_timeout);
  return;
}
}
__inline static void iwl_trans_ac_txq_enable(struct iwl_trans *trans , int queue ,
                                             int fifo , unsigned int queue_wdg_timeout ) 
{ 
  struct iwl_trans_txq_scd_cfg cfg ;

  {
  cfg.fifo = (unsigned char )fifo;
  cfg.sta_id = -1;
  cfg.tid = 8U;
  cfg.aggregate = 0;
  cfg.frame_limit = 64;
  iwl_trans_txq_enable_cfg(trans, queue, 0, (struct iwl_trans_txq_scd_cfg  const  *)(& cfg),
                           queue_wdg_timeout);
  return;
}
}
extern void iwl_remove_notification(struct iwl_notif_wait_data * , struct iwl_notification_wait * ) ;
__inline static void iwl_set_calib_hdr(struct iwl_calib_hdr *hdr , u8 cmd ) 
{ 


  {
  hdr->op_code = cmd;
  hdr->first_group = 0U;
  hdr->groups_num = 1U;
  hdr->data_valid = 1U;
  return;
}
}
int iwl_init_alive_start(struct iwl_priv *priv ) ;
int iwl_send_calib_results(struct iwl_priv *priv ) ;
int iwl_calib_set(struct iwl_priv *priv , struct iwl_calib_hdr  const  *cmd , int len ) ;
__inline static struct fw_img  const  *iwl_get_ucode_image(struct iwl_priv *priv ,
                                                           enum iwl_ucode_type ucode_type ) 
{ 


  {
  if ((unsigned int )ucode_type > 3U) {
    return ((struct fw_img  const  *)0);
  } else {

  }
  return ((struct fw_img  const  *)(& (priv->fw)->img) + (unsigned long )ucode_type);
}
}
static int iwl_set_Xtal_calib(struct iwl_priv *priv ) 
{ 
  struct iwl_calib_xtal_freq_cmd cmd ;
  __le16 *xtal_calib ;
  int tmp ;

  {
  xtal_calib = (__le16 *)(& (priv->nvm_data)->xtal_calib);
  iwl_set_calib_hdr(& cmd.hdr, 15);
  cmd.cap_pin1 = (u8 )*xtal_calib;
  cmd.cap_pin2 = (u8 )*(xtal_calib + 1UL);
  tmp = iwl_calib_set(priv, (struct iwl_calib_hdr  const  *)(& cmd), 8);
  return (tmp);
}
}
static int iwl_set_temperature_offset_calib(struct iwl_priv *priv ) 
{ 
  struct iwl_calib_temperature_offset_cmd cmd ;
  int tmp ;

  {
  memset((void *)(& cmd), 0, 8UL);
  iwl_set_calib_hdr(& cmd.hdr, 18);
  cmd.radio_sensor_offset = (priv->nvm_data)->raw_temperature;
  if ((unsigned int )cmd.radio_sensor_offset == 0U) {
    cmd.radio_sensor_offset = 2700U;
  } else {

  }
  __iwl_dbg(priv->dev, 2097152U, 0, "iwl_set_temperature_offset_calib", "Radio sensor offset: %d\n",
            (int )cmd.radio_sensor_offset);
  tmp = iwl_calib_set(priv, (struct iwl_calib_hdr  const  *)(& cmd), 8);
  return (tmp);
}
}
static int iwl_set_temperature_offset_calib_v2(struct iwl_priv *priv ) 
{ 
  struct iwl_calib_temperature_offset_v2_cmd cmd ;
  int tmp ;

  {
  memset((void *)(& cmd), 0, 12UL);
  iwl_set_calib_hdr(& cmd.hdr, 18);
  cmd.radio_sensor_offset_high = (priv->nvm_data)->kelvin_temperature;
  cmd.radio_sensor_offset_low = (priv->nvm_data)->raw_temperature;
  if ((unsigned int )cmd.radio_sensor_offset_low == 0U) {
    __iwl_dbg(priv->dev, 2097152U, 0, "iwl_set_temperature_offset_calib_v2", "no info in EEPROM, use default\n");
    cmd.radio_sensor_offset_low = 2700U;
    cmd.radio_sensor_offset_high = 2700U;
  } else {

  }
  cmd.burntVoltageRef = (priv->nvm_data)->calib_voltage;
  __iwl_dbg(priv->dev, 2097152U, 0, "iwl_set_temperature_offset_calib_v2", "Radio sensor offset high: %d\n",
            (int )cmd.radio_sensor_offset_high);
  __iwl_dbg(priv->dev, 2097152U, 0, "iwl_set_temperature_offset_calib_v2", "Radio sensor offset low: %d\n",
            (int )cmd.radio_sensor_offset_low);
  __iwl_dbg(priv->dev, 2097152U, 0, "iwl_set_temperature_offset_calib_v2", "Voltage Ref: %d\n",
            (int )cmd.burntVoltageRef);
  tmp = iwl_calib_set(priv, (struct iwl_calib_hdr  const  *)(& cmd), 12);
  return (tmp);
}
}
static int iwl_send_calib_cfg(struct iwl_priv *priv ) 
{ 
  struct iwl_calib_cfg_cmd calib_cfg_cmd ;
  struct iwl_host_cmd cmd ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  int tmp___1 ;

  {
  cmd.data[0] = (void const   *)(& calib_cfg_cmd);
  tmp = 1U;
  while (1) {
    if (tmp >= 2U) {
      break;
    } else {

    }
    cmd.data[tmp] = 0;
    tmp = tmp + 1U;
  }
  cmd.resp_pkt = 0;
  cmd._rx_page_addr = 0UL;
  cmd._rx_page_order = 0U;
  cmd.handler_status = 0;
  cmd.flags = 0U;
  cmd.len[0] = 92U;
  tmp___0 = 1U;
  while (1) {
    if (tmp___0 >= 2U) {
      break;
    } else {

    }
    cmd.len[tmp___0] = (unsigned short)0;
    tmp___0 = tmp___0 + 1U;
  }
  cmd.dataflags[0] = (unsigned char)0;
  cmd.dataflags[1] = (unsigned char)0;
  cmd.id = 101U;
  memset((void *)(& calib_cfg_cmd), 0, 92UL);
  calib_cfg_cmd.ucd_calib_cfg.once.is_enable = 95U;
  calib_cfg_cmd.ucd_calib_cfg.once.start = 95U;
  calib_cfg_cmd.ucd_calib_cfg.once.send_res = 95U;
  calib_cfg_cmd.ucd_calib_cfg.flags = 1U;
  tmp___1 = iwl_dvm_send_cmd(priv, & cmd);
  return (tmp___1);
}
}
int iwl_init_alive_start(struct iwl_priv *priv ) 
{ 
  int ret ;
  int tmp ;
  int tmp___0 ;

  {
  if ((unsigned long )(priv->lib)->bt_params != (unsigned long )((struct iwl_dvm_bt_params  const  */* const  */)0) && (int )((priv->lib)->bt_params)->advanced_bt_coexist) {
    ret = iwl_send_bt_env(priv, 1, 1);
    if (ret != 0) {
      return (ret);
    } else {

    }
  } else {

  }
  ret = iwl_send_calib_cfg(priv);
  if (ret != 0) {
    return (ret);
  } else {

  }
  if ((int )(priv->lib)->need_temp_offset_calib) {
    if ((int )(priv->lib)->temp_offset_v2) {
      tmp = iwl_set_temperature_offset_calib_v2(priv);
      return (tmp);
    } else {
      tmp___0 = iwl_set_temperature_offset_calib(priv);
      return (tmp___0);
    }
  } else {

  }
  return (0);
}
}
static int iwl_send_wimax_coex(struct iwl_priv *priv ) 
{ 
  struct iwl_wimax_coex_cmd coex_cmd ;
  int tmp ;

  {
  memset((void *)(& coex_cmd), 0, 68UL);
  tmp = iwl_dvm_send_cmd_pdu(priv, 90, 0U, 68, (void const   *)(& coex_cmd));
  return (tmp);
}
}
static u8 const   iwl_bt_prio_tbl[16U]  = 
  {      6U,      7U,      2U,      3U, 
        4U,      5U,      6U,      8U, 
        10U,      0U,      0U,      0U, 
        0U,      0U,      0U,      0U};
void iwl_send_prio_tbl(struct iwl_priv *priv ) 
{ 
  struct iwl_bt_coex_prio_table_cmd prio_tbl_cmd ;
  int tmp ;

  {
  memcpy((void *)(& prio_tbl_cmd.prio_tbl), (void const   *)(& iwl_bt_prio_tbl),
           16UL);
  tmp = iwl_dvm_send_cmd_pdu(priv, 204, 0U, 16, (void const   *)(& prio_tbl_cmd));
  if (tmp != 0) {
    __iwl_err(priv->dev, 0, 0, "failed to send BT prio tbl command\n");
  } else {

  }
  return;
}
}
int iwl_send_bt_env(struct iwl_priv *priv , u8 action , u8 type ) 
{ 
  struct iwl_bt_coex_prot_env_cmd env_cmd ;
  int ret ;

  {
  env_cmd.action = action;
  env_cmd.type = type;
  ret = iwl_dvm_send_cmd_pdu(priv, 205, 0U, 4, (void const   *)(& env_cmd));
  if (ret != 0) {
    __iwl_err(priv->dev, 0, 0, "failed to send BT env command\n");
  } else {

  }
  return (ret);
}
}
static u8 const   iwlagn_default_queue_to_tx_fifo[4U]  = {      3U,      2U,      1U,      0U};
static u8 const   iwlagn_ipan_queue_to_tx_fifo[11U]  = 
  {      3U,      2U,      1U,      0U, 
        0U,      4U,      2U,      5U, 
        4U,      255U,      5U};
static int iwl_alive_notify(struct iwl_priv *priv ) 
{ 
  u8 const   *queue_to_txf ;
  u8 n_queues ;
  int ret ;
  int i ;
  int tmp ;

  {
  iwl_trans_fw_alive(priv->trans, 0U);
  if ((int )(priv->fw)->ucode_capa.flags & 1 && (int )(priv->nvm_data)->sku_cap_ipan_enable) {
    n_queues = 11U;
    queue_to_txf = (u8 const   *)(& iwlagn_ipan_queue_to_tx_fifo);
  } else {
    n_queues = 4U;
    queue_to_txf = (u8 const   *)(& iwlagn_default_queue_to_tx_fifo);
  }
  i = 0;
  goto ldv_55076;
  ldv_55075: ;
  if ((unsigned int )((unsigned char )*(queue_to_txf + (unsigned long )i)) != 255U) {
    iwl_trans_ac_txq_enable(priv->trans, i, (int )*(queue_to_txf + (unsigned long )i),
                            0U);
  } else {

  }
  i = i + 1;
  ldv_55076: ;
  if ((int )n_queues > i) {
    goto ldv_55075;
  } else {

  }
  priv->passive_no_rx = 0;
  priv->transport_queue_stop = 0UL;
  ret = iwl_send_wimax_coex(priv);
  if (ret != 0) {
    return (ret);
  } else {

  }
  if (! ((_Bool )(priv->lib)->no_xtal_calib)) {
    ret = iwl_set_Xtal_calib(priv);
    if (ret != 0) {
      return (ret);
    } else {

    }
  } else {

  }
  tmp = iwl_send_calib_results(priv);
  return (tmp);
}
}
static bool iwl_alive_fn(struct iwl_notif_wait_data *notif_wait , struct iwl_rx_packet *pkt ,
                         void *data ) 
{ 
  struct iwl_priv *priv ;
  struct iwl_notif_wait_data  const  *__mptr ;
  struct iwl_alive_data *alive_data ;
  struct iwl_alive_resp *palive ;

  {
  __mptr = (struct iwl_notif_wait_data  const  *)notif_wait;
  priv = (struct iwl_priv *)__mptr + 0xfffffffffffff5f8UL;
  alive_data = (struct iwl_alive_data *)data;
  palive = (struct iwl_alive_resp *)(& pkt->data);
  __iwl_dbg(priv->dev, 65536U, 0, "iwl_alive_fn", "Alive ucode status 0x%08X revision 0x%01X 0x%01X\n",
            palive->is_valid, (int )palive->ver_type, (int )palive->ver_subtype);
  priv->device_pointers.error_event_table = palive->error_event_table_ptr;
  priv->device_pointers.log_event_table = palive->log_event_table_ptr;
  alive_data->subtype = palive->ver_subtype;
  alive_data->valid = palive->is_valid == 1U;
  return (1);
}
}
int iwl_load_ucode_wait_alive(struct iwl_priv *priv , enum iwl_ucode_type ucode_type ) 
{ 
  struct iwl_notification_wait alive_wait ;
  struct iwl_alive_data alive_data ;
  struct fw_img  const  *fw ;
  int ret ;
  enum iwl_ucode_type old_type ;
  u8 alive_cmd[1U] ;
  int __ret_warn_on ;
  long tmp ;
  long tmp___0 ;

  {
  alive_cmd[0] = 1U;
  fw = iwl_get_ucode_image(priv, ucode_type);
  __ret_warn_on = (unsigned long )fw == (unsigned long )((struct fw_img  const  *)0);
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/08_1a/drivers/net/wireless/iwlwifi/dvm/ucode.c",
                       333);
  } else {

  }
  tmp___0 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp___0 != 0L) {
    return (-22);
  } else {

  }
  old_type = priv->cur_ucode;
  priv->cur_ucode = ucode_type;
  priv->ucode_loaded = 0;
  iwl_init_notification_wait(& priv->notif_wait, & alive_wait, (u8 const   *)(& alive_cmd),
                             1, & iwl_alive_fn, (void *)(& alive_data));
  ret = iwl_trans_start_fw(priv->trans, fw, 0);
  if (ret != 0) {
    priv->cur_ucode = old_type;
    iwl_remove_notification(& priv->notif_wait, & alive_wait);
    return (ret);
  } else {

  }
  ret = iwl_wait_notification(& priv->notif_wait, & alive_wait, 250UL);
  if (ret != 0) {
    priv->cur_ucode = old_type;
    return (ret);
  } else {

  }
  if (! alive_data.valid) {
    __iwl_err(priv->dev, 0, 0, "Loaded ucode is not valid!\n");
    priv->cur_ucode = old_type;
    return (-5);
  } else {

  }
  priv->ucode_loaded = 1;
  if ((unsigned int )ucode_type != 2U) {
    msleep(5U);
  } else {

  }
  ret = iwl_alive_notify(priv);
  if (ret != 0) {
    __iwl_warn(priv->dev, "Could not complete ALIVE transition: %d\n", ret);
    priv->cur_ucode = old_type;
    return (ret);
  } else {

  }
  return (0);
}
}
static bool iwlagn_wait_calib(struct iwl_notif_wait_data *notif_wait , struct iwl_rx_packet *pkt ,
                              void *data ) 
{ 
  struct iwl_priv *priv ;
  struct iwl_calib_hdr *hdr ;
  int __ret_warn_on ;
  long tmp ;
  u32 tmp___0 ;
  int tmp___1 ;

  {
  priv = (struct iwl_priv *)data;
  if ((unsigned int )pkt->hdr.cmd != 102U) {
    __ret_warn_on = (unsigned int )pkt->hdr.cmd != 103U;
    tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
    if (tmp != 0L) {
      warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/08_1a/drivers/net/wireless/iwlwifi/dvm/ucode.c",
                         393);
    } else {

    }
    ldv__builtin_expect(__ret_warn_on != 0, 0L);
    return (1);
  } else {

  }
  hdr = (struct iwl_calib_hdr *)(& pkt->data);
  tmp___0 = iwl_rx_packet_payload_len((struct iwl_rx_packet  const  *)pkt);
  tmp___1 = iwl_calib_set(priv, (struct iwl_calib_hdr  const  *)hdr, (int )tmp___0);
  if (tmp___1 != 0) {
    __iwl_err(priv->dev, 0, 0, "Failed to record calibration data %d\n", (int )hdr->op_code);
  } else {

  }
  return (0);
}
}
int iwl_run_init_ucode(struct iwl_priv *priv ) 
{ 
  struct iwl_notification_wait calib_wait ;
  u8 calib_complete[2U] ;
  int ret ;
  int __ret_warn_on ;
  int tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
  calib_complete[0] = 102U;
  calib_complete[1] = 103U;
  if (debug_locks != 0) {
    tmp = lock_is_held(& priv->mutex.dep_map);
    if (tmp == 0) {
      tmp___0 = 1;
    } else {
      tmp___0 = 0;
    }
  } else {
    tmp___0 = 0;
  }
  __ret_warn_on = tmp___0;
  tmp___1 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp___1 != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/08_1a/drivers/net/wireless/iwlwifi/dvm/ucode.c",
                       415);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if ((unsigned int )(priv->fw)->img[1].sec[0].len == 0U) {
    return (0);
  } else {

  }
  iwl_init_notification_wait(& priv->notif_wait, & calib_wait, (u8 const   *)(& calib_complete),
                             2, & iwlagn_wait_calib, (void *)priv);
  ret = iwl_load_ucode_wait_alive(priv, 1);
  if (ret != 0) {
    goto error;
  } else {

  }
  ret = iwl_init_alive_start(priv);
  if (ret != 0) {
    goto error;
  } else {

  }
  ret = iwl_wait_notification(& priv->notif_wait, & calib_wait, 500UL);
  goto out;
  error: 
  iwl_remove_notification(& priv->notif_wait, & calib_wait);
  out: 
  iwl_trans_stop_device(priv->trans);
  priv->ucode_loaded = 0;
  return (ret);
}
}
bool ldv_queue_work_on_77(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_7(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_delayed_work_on_78(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_7(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_work_on_79(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_7(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
void ldv_flush_workqueue_80(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
  flush_workqueue(ldv_func_arg1);
  call_and_disable_all_7(2);
  return;
}
}
bool ldv_queue_delayed_work_on_81(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_7(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
__inline static long ldv__builtin_expect(long exp , long c ) ;
__inline static __u32 __le32_to_cpup(__le32 const   *p ) 
{ 


  {
  return ((__u32 )*p);
}
}
extern void warn_slowpath_fmt(char const   * , int const    , char const   *  , ...) ;
__inline static void atomic_inc(atomic_t *v ) 
{ 


  {
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; incl %0": "+m" (v->counter));
  return;
}
}
extern void lock_acquire(struct lockdep_map * , unsigned int  , int  , int  , int  ,
                         struct lockdep_map * , unsigned long  ) ;
extern void lock_release(struct lockdep_map * , int  , unsigned long  ) ;
extern void _raw_spin_lock(raw_spinlock_t * ) ;
extern void _raw_spin_unlock(raw_spinlock_t * ) ;
__inline static void spin_lock(spinlock_t *lock ) 
{ 


  {
  _raw_spin_lock(& lock->__annonCompField18.rlock);
  return;
}
}
__inline static void spin_unlock(spinlock_t *lock ) 
{ 


  {
  _raw_spin_unlock(& lock->__annonCompField18.rlock);
  return;
}
}
__inline static void rcu_lock_acquire(struct lockdep_map *map ) 
{ 


  {
  lock_acquire(map, 0U, 0, 2, 0, (struct lockdep_map *)0, 0UL);
  return;
}
}
__inline static void rcu_lock_release(struct lockdep_map *map ) 
{ 


  {
  lock_release(map, 1, 0UL);
  return;
}
}
extern struct lockdep_map rcu_lock_map ;
extern int rcu_read_lock_held(void) ;
__inline static void rcu_read_lock(void) 
{ 
  bool __warned ;
  int tmp ;
  bool tmp___0 ;
  int tmp___1 ;

  {
  rcu_read_lock_sched_notrace();
  rcu_lock_acquire(& rcu_lock_map);
  tmp = debug_lockdep_rcu_enabled();
  if (tmp != 0 && ! __warned) {
    tmp___0 = rcu_is_watching();
    if (tmp___0) {
      tmp___1 = 0;
    } else {
      tmp___1 = 1;
    }
    if (tmp___1) {
      __warned = 1;
      lockdep_rcu_suspicious("include/linux/rcupdate.h", 849, "rcu_read_lock() used illegally while idle");
    } else {

    }
  } else {

  }
  return;
}
}
__inline static void rcu_read_unlock(void) 
{ 
  bool __warned ;
  int tmp ;
  bool tmp___0 ;
  int tmp___1 ;

  {
  tmp = debug_lockdep_rcu_enabled();
  if (tmp != 0 && ! __warned) {
    tmp___0 = rcu_is_watching();
    if (tmp___0) {
      tmp___1 = 0;
    } else {
      tmp___1 = 1;
    }
    if (tmp___1) {
      __warned = 1;
      lockdep_rcu_suspicious("include/linux/rcupdate.h", 900, "rcu_read_unlock() used illegally while idle");
    } else {

    }
  } else {

  }
  rcu_read_unlock_sched_notrace();
  rcu_lock_release(& rcu_lock_map);
  return;
}
}
bool ldv_queue_work_on_91(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_work_on_93(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_delayed_work_on_92(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
bool ldv_queue_delayed_work_on_95(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
void ldv_flush_workqueue_94(struct workqueue_struct *ldv_func_arg1 ) ;
__inline static bool queue_work___2(struct workqueue_struct *wq , struct work_struct *work ) 
{ 
  bool tmp ;

  {
  tmp = ldv_queue_work_on_91(8192, wq, work);
  return (tmp);
}
}
extern void *kmem_cache_alloc(struct kmem_cache * , gfp_t  ) ;
__inline static void *lowmem_page_address(struct page  const  *page ) 
{ 


  {
  return ((void *)((unsigned long )((unsigned long long )(((long )page + 24189255811072L) / 64L) << 12) + 0xffff880000000000UL));
}
}
extern int pskb_expand_head(struct sk_buff * , int  , int  , gfp_t  ) ;
__inline static int skb_queue_empty(struct sk_buff_head  const  *list ) 
{ 


  {
  return ((unsigned long )((struct sk_buff  const  *)list->next) == (unsigned long )((struct sk_buff  const  *)list));
}
}
__inline static struct sk_buff *skb_peek(struct sk_buff_head  const  *list_ ) 
{ 
  struct sk_buff *skb ;

  {
  skb = list_->next;
  if ((unsigned long )skb == (unsigned long )((struct sk_buff *)list_)) {
    skb = (struct sk_buff *)0;
  } else {

  }
  return (skb);
}
}
__inline static void __skb_queue_head_init(struct sk_buff_head *list ) 
{ 
  struct sk_buff *tmp ;

  {
  tmp = (struct sk_buff *)list;
  list->next = tmp;
  list->prev = tmp;
  list->qlen = 0U;
  return;
}
}
__inline static void __skb_unlink(struct sk_buff *skb , struct sk_buff_head *list ) 
{ 
  struct sk_buff *next ;
  struct sk_buff *prev ;
  struct sk_buff *tmp ;

  {
  list->qlen = list->qlen - 1U;
  next = skb->__annonCompField68.__annonCompField67.next;
  prev = skb->__annonCompField68.__annonCompField67.prev;
  tmp = (struct sk_buff *)0;
  skb->__annonCompField68.__annonCompField67.prev = tmp;
  skb->__annonCompField68.__annonCompField67.next = tmp;
  next->__annonCompField68.__annonCompField67.prev = prev;
  prev->__annonCompField68.__annonCompField67.next = next;
  return;
}
}
__inline static struct sk_buff *__skb_dequeue(struct sk_buff_head *list ) 
{ 
  struct sk_buff *skb ;
  struct sk_buff *tmp ;

  {
  tmp = skb_peek((struct sk_buff_head  const  *)list);
  skb = tmp;
  if ((unsigned long )skb != (unsigned long )((struct sk_buff *)0)) {
    __skb_unlink(skb, list);
  } else {

  }
  return (skb);
}
}
extern unsigned char *skb_put(struct sk_buff * , unsigned int  ) ;
__inline static int ieee80211_has_morefrags(__le16 fc ) 
{ 


  {
  return (((int )fc & 1024) != 0);
}
}
__inline static int ieee80211_is_mgmt(__le16 fc ) 
{ 


  {
  return (((int )fc & 12) == 0);
}
}
__inline static int ieee80211_is_assoc_req(__le16 fc ) 
{ 


  {
  return (((int )fc & 252) == 0);
}
}
__inline static int ieee80211_is_reassoc_req(__le16 fc ) 
{ 


  {
  return (((int )fc & 252) == 32);
}
}
__inline static int ieee80211_is_probe_resp(__le16 fc ) 
{ 


  {
  return (((int )fc & 252) == 80);
}
}
__inline static int ieee80211_is_auth(__le16 fc ) 
{ 


  {
  return (((int )fc & 252) == 176);
}
}
__inline static int ieee80211_is_back_req(__le16 fc ) 
{ 


  {
  return (((int )fc & 252) == 132);
}
}
__inline static int ieee80211_is_qos_nullfunc(__le16 fc ) 
{ 


  {
  return (((int )fc & 252) == 200);
}
}
extern unsigned int ieee80211_hdrlen(__le16  ) ;
extern void ieee80211_tx_status(struct ieee80211_hw * , struct sk_buff * ) ;
extern void ieee80211_get_tkip_p2k(struct ieee80211_key_conf * , struct sk_buff * ,
                                   u8 * ) ;
extern void ieee80211_start_tx_ba_cb_irqsafe(struct ieee80211_vif * , u8 const   * ,
                                             u16  ) ;
extern void ieee80211_stop_tx_ba_cb_irqsafe(struct ieee80211_vif * , u8 const   * ,
                                            u16  ) ;
extern struct ieee80211_sta *ieee80211_find_sta(struct ieee80211_vif * , u8 const   * ) ;
__inline static void *rxb_addr(struct iwl_rx_cmd_buffer *r ) 
{ 
  void *tmp ;

  {
  tmp = lowmem_page_address((struct page  const  *)r->_page);
  return ((void *)((unsigned long )tmp + (unsigned long )r->_offset));
}
}
__inline static struct iwl_device_cmd *iwl_trans_alloc_tx_cmd(struct iwl_trans *trans ) 
{ 
  u8 *dev_cmd_ptr ;
  void *tmp ;
  long tmp___0 ;

  {
  tmp = kmem_cache_alloc(trans->dev_cmd_pool, 32U);
  dev_cmd_ptr = (u8 *)tmp;
  tmp___0 = ldv__builtin_expect((unsigned long )dev_cmd_ptr == (unsigned long )((u8 *)0U),
                             0L);
  if (tmp___0 != 0L) {
    return ((struct iwl_device_cmd *)0);
  } else {

  }
  return ((struct iwl_device_cmd *)(dev_cmd_ptr + trans->dev_cmd_headroom));
}
}
__inline static int iwl_trans_tx(struct iwl_trans *trans , struct sk_buff *skb , struct iwl_device_cmd *dev_cmd ,
                                 int queue ) 
{ 
  int tmp ;
  long tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;

  {
  tmp = constant_test_bit(5L, (unsigned long const volatile   *)(& trans->status));
  tmp___0 = ldv__builtin_expect(tmp != 0, 0L);
  if (tmp___0 != 0L) {
    return (-5);
  } else {

  }
  tmp___1 = ldv__builtin_expect((unsigned int )trans->state != 1U, 0L);
  if (tmp___1 != 0L) {
    __iwl_err(trans->dev, 0, 0, "%s bad state = %d\n", "iwl_trans_tx", (unsigned int )trans->state);
  } else {

  }
  tmp___2 = (*((trans->ops)->tx))(trans, skb, dev_cmd, queue);
  return (tmp___2);
}
}
__inline static void iwl_trans_reclaim(struct iwl_trans *trans , int queue , int ssn ,
                                       struct sk_buff_head *skbs ) 
{ 
  long tmp ;

  {
  tmp = ldv__builtin_expect((unsigned int )trans->state != 1U, 0L);
  if (tmp != 0L) {
    __iwl_err(trans->dev, 0, 0, "%s bad state = %d\n", "iwl_trans_reclaim", (unsigned int )trans->state);
  } else {

  }
  (*((trans->ops)->reclaim))(trans, queue, ssn, skbs);
  return;
}
}
__inline static void iwl_trans_txq_disable(struct iwl_trans *trans , int queue , bool configure_scd ) 
{ 


  {
  (*((trans->ops)->txq_disable))(trans, queue, (int )configure_scd);
  return;
}
}
__inline static void iwl_trans_txq_enable(struct iwl_trans *trans , int queue , int fifo ,
                                          int sta_id , int tid , int frame_limit ,
                                          u16 ssn , unsigned int queue_wdg_timeout ) 
{ 
  struct iwl_trans_txq_scd_cfg cfg ;

  {
  cfg.fifo = (unsigned char )fifo;
  cfg.sta_id = (signed char )sta_id;
  cfg.tid = (unsigned char )tid;
  cfg.aggregate = sta_id >= 0;
  cfg.frame_limit = frame_limit;
  iwl_trans_txq_enable_cfg(trans, queue, (int )ssn, (struct iwl_trans_txq_scd_cfg  const  *)(& cfg),
                           queue_wdg_timeout);
  return;
}
}
int iwlagn_hwrate_to_mac80211_idx(u32 rate_n_flags , enum ieee80211_band band ) ;
int iwlagn_rx_reply_compressed_ba(struct iwl_priv *priv , struct iwl_rx_cmd_buffer *rxb ,
                                  struct iwl_device_cmd *cmd ) ;
int iwlagn_rx_reply_tx(struct iwl_priv *priv , struct iwl_rx_cmd_buffer *rxb , struct iwl_device_cmd *cmd ) ;
__inline static u32 iwl_tx_status_to_mac80211(u32 status ) 
{ 


  {
  status = status & 255U;
  switch (status) {
  case 1U: ;
  case 2U: ;
  return (512U);
  case 136U: ;
  case 144U: ;
  return (256U);
  default: ;
  return (0U);
  }
}
}
__inline static bool iwl_is_tx_success(u32 status ) 
{ 


  {
  status = status & 255U;
  return ((bool )(status == 1U || status == 2U));
}
}
char const   *iwl_get_tx_fail_reason(u32 status ) ;
char const   *iwl_get_agg_tx_fail_reason(u16 status ) ;
int iwl_sta_tx_modify_enable_tid(struct iwl_priv *priv , int sta_id , int tid ) ;
void iwl_sta_modify_sleep_tx_count(struct iwl_priv *priv , int sta_id , int cnt ) ;
static u8 const   tid_to_ac[8U]  = 
  {      2U,      3U,      3U,      2U, 
        1U,      1U,      0U,      0U};
static void iwlagn_tx_cmd_protection(struct iwl_priv *priv , struct ieee80211_tx_info *info ,
                                     __le16 fc , __le32 *tx_flags ) 
{ 


  {
  if (((int )info->__annonCompField99.control.__annonCompField97.__annonCompField96.rates[0].flags & 1 || ((int )info->__annonCompField99.control.__annonCompField97.__annonCompField96.rates[0].flags & 2) != 0) || (info->flags & 64U) != 0U) {
    *tx_flags = *tx_flags | 1U;
  } else {

  }
  return;
}
}
static void iwlagn_tx_cmd_build_basic(struct iwl_priv *priv , struct sk_buff *skb ,
                                      struct iwl_tx_cmd *tx_cmd , struct ieee80211_tx_info *info ,
                                      struct ieee80211_hdr *hdr , u8 sta_id ) 
{ 
  __le16 fc ;
  __le32 tx_flags ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  u8 *qc ;
  u8 *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
  fc = hdr->frame_control;
  tx_flags = tx_cmd->tx_flags;
  tx_cmd->stop_time.life_time = 4294967295U;
  if ((info->flags & 4U) == 0U) {
    tx_flags = tx_flags | 8U;
  } else {
    tx_flags = tx_flags & 4294967287U;
  }
  tmp___3 = ieee80211_is_probe_resp((int )fc);
  if (tmp___3 != 0) {
    tx_flags = tx_flags | 65536U;
  } else {
    tmp___2 = ieee80211_is_back_req((int )fc);
    if (tmp___2 != 0) {
      tx_flags = tx_flags | 72U;
    } else
    if (((unsigned int )info->band == 0U && (unsigned long )(priv->lib)->bt_params != (unsigned long )((struct iwl_dvm_bt_params  const  */* const  */)0)) && (int )((priv->lib)->bt_params)->advanced_bt_coexist) {
      tmp = ieee80211_is_auth((int )fc);
      if (tmp != 0) {
        tx_flags = tx_flags | 4096U;
      } else {
        tmp___0 = ieee80211_is_assoc_req((int )fc);
        if (tmp___0 != 0) {
          tx_flags = tx_flags | 4096U;
        } else {
          tmp___1 = ieee80211_is_reassoc_req((int )fc);
          if (tmp___1 != 0) {
            tx_flags = tx_flags | 4096U;
          } else
          if ((int )info->__annonCompField99.control.flags & 1) {
            tx_flags = tx_flags | 4096U;
          } else {

          }
        }
      }
    } else {

    }
  }
  tx_cmd->sta_id = sta_id;
  tmp___4 = ieee80211_has_morefrags((int )fc);
  if (tmp___4 != 0) {
    tx_flags = tx_flags | 16384U;
  } else {

  }
  tmp___6 = ieee80211_is_data_qos((int )fc);
  if (tmp___6 != 0) {
    tmp___5 = ieee80211_get_qos_ctl(hdr);
    qc = tmp___5;
    tx_cmd->tid_tspec = (unsigned int )*qc & 15U;
    tx_flags = tx_flags & 4294959103U;
  } else {
    tx_cmd->tid_tspec = 8U;
    if ((info->flags & 2U) != 0U) {
      tx_flags = tx_flags | 8192U;
    } else {
      tx_flags = tx_flags & 4294959103U;
    }
  }
  iwlagn_tx_cmd_protection(priv, info, (int )fc, & tx_flags);
  tx_flags = tx_flags & 4294963455U;
  tmp___9 = ieee80211_is_mgmt((int )fc);
  if (tmp___9 != 0) {
    tmp___7 = ieee80211_is_assoc_req((int )fc);
    if (tmp___7 != 0) {
      tx_cmd->timeout.pm_frame_timeout = 3U;
    } else {
      tmp___8 = ieee80211_is_reassoc_req((int )fc);
      if (tmp___8 != 0) {
        tx_cmd->timeout.pm_frame_timeout = 3U;
      } else {
        tx_cmd->timeout.pm_frame_timeout = 2U;
      }
    }
  } else {
    tx_cmd->timeout.pm_frame_timeout = 0U;
  }
  tx_cmd->driver_txop = 0U;
  tx_cmd->tx_flags = tx_flags;
  tx_cmd->next_frame_len = 0U;
  return;
}
}
static void iwlagn_tx_cmd_build_rate(struct iwl_priv *priv , struct iwl_tx_cmd *tx_cmd ,
                                     struct ieee80211_tx_info *info , struct ieee80211_sta *sta ,
                                     __le16 fc ) 
{ 
  u32 rate_flags ;
  int rate_idx ;
  u8 rts_retry_limit ;
  u8 data_retry_limit ;
  u8 rate_plcp ;
  u8 _min1 ;
  u8 _min2 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  s8 tmp___3 ;
  u8 tmp___4 ;
  u32 tmp___5 ;

  {
  if ((int )priv->wowlan) {
    rts_retry_limit = 7U;
    data_retry_limit = 7U;
  } else {
    rts_retry_limit = 60U;
    tmp___0 = ieee80211_is_probe_resp((int )fc);
    if (tmp___0 != 0) {
      data_retry_limit = 3U;
      _min1 = data_retry_limit;
      _min2 = rts_retry_limit;
      rts_retry_limit = (u8 )((int )_min1 < (int )_min2 ? _min1 : _min2);
    } else {
      tmp = ieee80211_is_back_req((int )fc);
      if (tmp != 0) {
        data_retry_limit = 60U;
      } else {
        data_retry_limit = 15U;
      }
    }
  }
  tx_cmd->data_retry_limit = data_retry_limit;
  tx_cmd->rts_retry_limit = rts_retry_limit;
  tmp___2 = ieee80211_is_data((int )fc);
  if (tmp___2 != 0) {
    tx_cmd->initial_rate_index = 0U;
    tx_cmd->tx_flags = tx_cmd->tx_flags | 16U;
    return;
  } else {
    tmp___1 = ieee80211_is_back_req((int )fc);
    if (tmp___1 != 0) {
      tx_cmd->tx_flags = tx_cmd->tx_flags | 16U;
    } else {

    }
  }
  rate_idx = (int )info->__annonCompField99.control.__annonCompField97.__annonCompField96.rates[0].idx;
  if ((((int )info->__annonCompField99.control.__annonCompField97.__annonCompField96.rates[0].flags & 8) != 0 || rate_idx < 0) || rate_idx > 12) {
    tmp___3 = rate_lowest_index((struct ieee80211_supported_band *)(& (priv->nvm_data)->bands) + (unsigned long )info->band,
                                sta);
    rate_idx = (int )tmp___3;
  } else {

  }
  if ((unsigned int )info->band == 1U) {
    rate_idx = rate_idx + 4;
  } else {

  }
  rate_plcp = iwl_rates[rate_idx].plcp;
  rate_flags = 0U;
  if (rate_idx >= 0 && rate_idx <= 3) {
    rate_flags = rate_flags | 512U;
  } else {

  }
  if (((unsigned long )(priv->lib)->bt_params != (unsigned long )((struct iwl_dvm_bt_params  const  */* const  */)0) && (int )((priv->lib)->bt_params)->advanced_bt_coexist) && (int )priv->bt_full_concurrent) {
    tmp___4 = first_antenna((int )(priv->nvm_data)->valid_tx_ant);
    priv->mgmt_tx_ant = iwl_toggle_tx_ant(priv, (int )priv->mgmt_tx_ant, (int )tmp___4);
  } else {
    priv->mgmt_tx_ant = iwl_toggle_tx_ant(priv, (int )priv->mgmt_tx_ant, (int )(priv->nvm_data)->valid_tx_ant);
  }
  tmp___5 = iwl_ant_idx_to_flags((int )priv->mgmt_tx_ant);
  rate_flags = tmp___5 | rate_flags;
  tx_cmd->rate_n_flags = iwl_hw_set_rate_n_flags((int )rate_plcp, rate_flags);
  return;
}
}
static void iwlagn_tx_cmd_build_hwcrypto(struct iwl_priv *priv , struct ieee80211_tx_info *info ,
                                         struct iwl_tx_cmd *tx_cmd , struct sk_buff *skb_frag ) 
{ 
  struct ieee80211_key_conf *keyconf ;

  {
  keyconf = info->__annonCompField99.control.hw_key;
  switch (keyconf->cipher) {
  case 1027076U: 
  tx_cmd->sec_ctl = 2U;
  memcpy((void *)(& tx_cmd->key), (void const   *)(& keyconf->key), (size_t )keyconf->keylen);
  if ((info->flags & 64U) != 0U) {
    tx_cmd->tx_flags = tx_cmd->tx_flags | 4194304U;
  } else {

  }
  goto ldv_55024;
  case 1027074U: 
  tx_cmd->sec_ctl = 3U;
  ieee80211_get_tkip_p2k(keyconf, skb_frag, (u8 *)(& tx_cmd->key));
  goto ldv_55024;
  case 1027077U: 
  tx_cmd->sec_ctl = (u8 )((unsigned int )tx_cmd->sec_ctl | 8U);
  case 1027073U: 
  tx_cmd->sec_ctl = (u8 )((int )((signed char )tx_cmd->sec_ctl) | ((int )((signed char )((int )keyconf->keyidx << 6)) | 1));
  memcpy((void *)(& tx_cmd->key) + 3U, (void const   *)(& keyconf->key), (size_t )keyconf->keylen);
  __iwl_dbg(priv->dev, 8388608U, 0, "iwlagn_tx_cmd_build_hwcrypto", "Configuring packet for WEP encryption with key %d\n",
            (int )keyconf->keyidx);
  goto ldv_55024;
  default: 
  __iwl_err(priv->dev, 0, 0, "Unknown encode cipher %x\n", keyconf->cipher);
  goto ldv_55024;
  }
  ldv_55024: ;
  return;
}
}
static int iwl_sta_id_or_broadcast(struct iwl_rxon_context *context , struct ieee80211_sta *sta ) 
{ 
  int sta_id ;
  int __ret_warn_on ;
  long tmp ;

  {
  if ((unsigned long )sta == (unsigned long )((struct ieee80211_sta *)0)) {
    return ((int )context->bcast_sta_id);
  } else {

  }
  sta_id = iwl_sta_id(sta);
  __ret_warn_on = sta_id == 255;
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/08_1a/drivers/net/wireless/iwlwifi/dvm/tx.c",
                       271);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  return (sta_id);
}
}
int iwlagn_tx_skb(struct iwl_priv *priv , struct ieee80211_sta *sta , struct sk_buff *skb ) 
{ 
  struct ieee80211_hdr *hdr ;
  struct ieee80211_tx_info *info ;
  struct ieee80211_tx_info *tmp ;
  struct iwl_station_priv *sta_priv ;
  struct iwl_rxon_context *ctx ;
  struct iwl_device_cmd *dev_cmd ;
  struct iwl_tx_cmd *tx_cmd ;
  __le16 fc ;
  u8 hdr_len ;
  u16 len ;
  u16 seq_number ;
  u8 sta_id ;
  u8 tid ;
  bool is_agg ;
  bool is_data_qos ;
  int txq_id ;
    klee_make_symbolic(&txq_id, sizeof(int), "txq_id");
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  struct iwl_wipan_noa_data *noa_data ;
  struct iwl_wipan_noa_data *________p1 ;
  struct iwl_wipan_noa_data *_________p1 ;
  union __anonunion___u_482 __u ;
  bool __warned ;
  int tmp___4 ;
  int tmp___5 ;
  unsigned char *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  long tmp___9 ;
  unsigned int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  long tmp___13 ;
  u8 *qc ;
  struct iwl_tid_data *tid_data ;
  bool __warned___0 ;
  int __ret_warn_once ;
  int __ret_warn_on ;
  long tmp___14 ;
    klee_make_symbolic(&tmp___14, sizeof(long), "tmp___14");
  long tmp___15 ;
    klee_make_symbolic(&tmp___15, sizeof(long), "tmp___15");
  long tmp___16 ;
    klee_make_symbolic(&tmp___16, sizeof(long), "tmp___16");
  long tmp___17 ;
    klee_make_symbolic(&tmp___17, sizeof(long), "tmp___17");
  bool __warned___1 ;
  int __ret_warn_once___0 ;
    klee_make_symbolic(&__ret_warn_once___0, sizeof(int), "__ret_warn_once___0");
  int __ret_warn_on___0 ;
  long tmp___18 ;
    klee_make_symbolic(&tmp___18, sizeof(long), "tmp___18");
  long tmp___19 ;
    klee_make_symbolic(&tmp___19, sizeof(long), "tmp___19");
  long tmp___20 ;
    klee_make_symbolic(&tmp___20, sizeof(long), "tmp___20");
  long tmp___21 ;
    klee_make_symbolic(&tmp___21, sizeof(long), "tmp___21");
  int tmp___22 ;
    klee_make_symbolic(&tmp___22, sizeof(int), "tmp___22");
  int tmp___23 ;
    klee_make_symbolic(&tmp___23, sizeof(int), "tmp___23");
  bool __warned___2 ;
  int __ret_warn_once___1 ;
    klee_make_symbolic(&__ret_warn_once___1, sizeof(int), "__ret_warn_once___1");
  int __ret_warn_on___1 ;
    klee_make_symbolic(&__ret_warn_on___1, sizeof(int), "__ret_warn_on___1");
  long tmp___24 ;
    klee_make_symbolic(&tmp___24, sizeof(long), "tmp___24");
  long tmp___25 ;
    klee_make_symbolic(&tmp___25, sizeof(long), "tmp___25");
  long tmp___26 ;
    klee_make_symbolic(&tmp___26, sizeof(long), "tmp___26");
  int tmp___27 ;
    klee_make_symbolic(&tmp___27, sizeof(int), "tmp___27");
  int tmp___28 ;
    klee_make_symbolic(&tmp___28, sizeof(int), "tmp___28");

  {
  hdr = (struct ieee80211_hdr *)skb->data;
  tmp = IEEE80211_SKB_CB(skb);
  info = tmp;
  sta_priv = (struct iwl_station_priv *)0;
  ctx = (struct iwl_rxon_context *)(& priv->contexts);
  seq_number = 0U;
  tid = 8U;
  is_agg = 0;
  is_data_qos = 0;
  if ((unsigned long )info->__annonCompField99.control.vif != (unsigned long )((struct ieee80211_vif *)0)) {
    ctx = iwl_rxon_ctx_from_vif(info->__annonCompField99.control.vif);
  } else {

  }
  tmp___0 = iwl_is_rfkill(priv);
  if (tmp___0 != 0) {
    __iwl_dbg(priv->dev, 8192U, 0, "iwlagn_tx_skb", "Dropping - RF KILL\n");
    goto drop_unlock_priv;
  } else {

  }
  fc = hdr->frame_control;
  tmp___3 = ieee80211_is_auth((int )fc);
  if (tmp___3 != 0) {
    __iwl_dbg(priv->dev, 8388608U, 0, "iwlagn_tx_skb", "Sending AUTH frame\n");
  } else {
    tmp___2 = ieee80211_is_assoc_req((int )fc);
    if (tmp___2 != 0) {
      __iwl_dbg(priv->dev, 8388608U, 0, "iwlagn_tx_skb", "Sending ASSOC frame\n");
    } else {
      tmp___1 = ieee80211_is_reassoc_req((int )fc);
      if (tmp___1 != 0) {
        __iwl_dbg(priv->dev, 8388608U, 0, "iwlagn_tx_skb", "Sending REASSOC frame\n");
      } else {

      }
    }
  }
  tmp___8 = ieee80211_is_probe_resp((int )fc);
  tmp___9 = ldv__builtin_expect(tmp___8 != 0, 0L);
  if (tmp___9 != 0L) {
    __read_once_size((void const volatile   *)(& priv->noa_data), (void *)(& __u.__c),
                     8);
    _________p1 = __u.__val;
    ________p1 = _________p1;
    tmp___4 = debug_lockdep_rcu_enabled();
    if (tmp___4 != 0 && ! __warned) {
      tmp___5 = rcu_read_lock_held();
      if (tmp___5 == 0) {
        __warned = 1;
        lockdep_rcu_suspicious("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/08_1a/drivers/net/wireless/iwlwifi/dvm/tx.c",
                               317, "suspicious rcu_dereference_check() usage");
      } else {

      }
    } else {

    }
    noa_data = ________p1;
    if ((unsigned long )noa_data != (unsigned long )((struct iwl_wipan_noa_data *)0)) {
      tmp___7 = pskb_expand_head(skb, 0, (int )noa_data->length, 32U);
      if (tmp___7 == 0) {
        tmp___6 = skb_put(skb, noa_data->length);
        memcpy((void *)tmp___6, (void const   *)(& noa_data->data), (size_t )noa_data->length);
        hdr = (struct ieee80211_hdr *)skb->data;
      } else {

      }
    } else {

    }
  } else {

  }
  tmp___10 = ieee80211_hdrlen((int )fc);
  hdr_len = (u8 )tmp___10;
  tmp___12 = ieee80211_is_data((int )fc);
  if (tmp___12 == 0) {
    sta_id = ctx->bcast_sta_id;
  } else {
    tmp___11 = iwl_sta_id_or_broadcast(ctx, sta);
    sta_id = (u8 )tmp___11;
    if ((unsigned int )sta_id == 255U) {
      __iwl_dbg(priv->dev, 8192U, 0, "iwlagn_tx_skb", "Dropping - INVALID STATION: %pM\n",
                (u8 *)(& hdr->addr1));
      goto drop_unlock_priv;
    } else {

    }
  }
  if ((unsigned long )sta != (unsigned long )((struct ieee80211_sta *)0)) {
    sta_priv = (struct iwl_station_priv *)(& sta->drv_priv);
  } else {

  }
  if (((unsigned long )sta_priv != (unsigned long )((struct iwl_station_priv *)0) && (int )sta_priv->asleep) && (info->flags & 131072U) != 0U) {
    iwl_sta_modify_sleep_tx_count(priv, (int )sta_id, 1);
  } else {

  }
  dev_cmd = iwl_trans_alloc_tx_cmd(priv->trans);
  tmp___13 = ldv__builtin_expect((unsigned long )dev_cmd == (unsigned long )((struct iwl_device_cmd *)0),
                              0L);
  if (tmp___13 != 0L) {
    goto drop_unlock_priv;
  } else {

  }
  memset((void *)dev_cmd, 0, 324UL);
  dev_cmd->hdr.cmd = 28U;
  tx_cmd = (struct iwl_tx_cmd *)(& dev_cmd->payload);
  len = (unsigned short )skb->len;
  tx_cmd->len = len;
  if ((unsigned long )info->__annonCompField99.control.hw_key != (unsigned long )((struct ieee80211_key_conf *)0)) {
    iwlagn_tx_cmd_build_hwcrypto(priv, info, tx_cmd, skb);
  } else {

  }
  iwlagn_tx_cmd_build_basic(priv, skb, tx_cmd, info, hdr, (int )sta_id);
  iwlagn_tx_cmd_build_rate(priv, tx_cmd, info, sta, (int )fc);
  memset((void *)(& info->__annonCompField99.status), 0, 40UL);
  info->__annonCompField99.driver_data[0] = (void *)ctx;
  info->__annonCompField99.driver_data[1] = (void *)dev_cmd;
  spin_lock(& priv->sta_lock);
  tmp___22 = ieee80211_is_data_qos((int )fc);
  if (tmp___22 != 0) {
    tmp___23 = ieee80211_is_qos_nullfunc((int )fc);
    if (tmp___23 == 0) {
      qc = (u8 *)0U;
      qc = ieee80211_get_qos_ctl(hdr);
      tid = (unsigned int )*qc & 15U;
      __ret_warn_once = (unsigned int )tid > 7U;
      tmp___16 = ldv__builtin_expect(__ret_warn_once != 0, 0L);
      if (tmp___16 != 0L) {
        __ret_warn_on = ! __warned___0;
        tmp___14 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
        if (tmp___14 != 0L) {
          warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/08_1a/drivers/net/wireless/iwlwifi/dvm/tx.c",
                             398);
        } else {

        }
        tmp___15 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
        if (tmp___15 != 0L) {
          __warned___0 = 1;
        } else {

        }
      } else {

      }
      tmp___17 = ldv__builtin_expect(__ret_warn_once != 0, 0L);
      if (tmp___17 != 0L) {
        goto drop_unlock_sta;
      } else {

      }
      tid_data = (struct iwl_tid_data *)(& priv->tid_data) + ((unsigned long )sta_id + (unsigned long )tid);
      if ((info->flags & 64U) != 0U && (unsigned int )tid_data->agg.state != 2U) {
        __iwl_err(priv->dev, 0, 0, "TX_CTL_AMPDU while not in AGG: Tx flags = 0x%08x, agg.state = %d\n",
                  info->flags, (unsigned int )tid_data->agg.state);
        __iwl_err(priv->dev, 0, 0, "sta_id = %d, tid = %d seq_num = %d\n", (int )sta_id,
                  (int )tid, (int )tid_data->seq_number >> 4);
        goto drop_unlock_sta;
      } else {

      }
      __ret_warn_once___0 = (unsigned int )tid_data->agg.state != 2U && (unsigned int )tid_data->agg.state != 0U;
      tmp___20 = ldv__builtin_expect(__ret_warn_once___0 != 0, 0L);
      if (tmp___20 != 0L) {
        __ret_warn_on___0 = ! __warned___1;
        tmp___18 = ldv__builtin_expect(__ret_warn_on___0 != 0, 0L);
        if (tmp___18 != 0L) {
          warn_slowpath_fmt("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/08_1a/drivers/net/wireless/iwlwifi/dvm/tx.c",
                            419, "Tx while agg.state = %d\n", (unsigned int )tid_data->agg.state);
        } else {

        }
        tmp___19 = ldv__builtin_expect(__ret_warn_on___0 != 0, 0L);
        if (tmp___19 != 0L) {
          __warned___1 = 1;
        } else {

        }
      } else {

      }
      tmp___21 = ldv__builtin_expect(__ret_warn_once___0 != 0, 0L);
      if (tmp___21 != 0L) {
        goto drop_unlock_sta;
      } else {

      }
      seq_number = tid_data->seq_number;
      seq_number = (unsigned int )seq_number & 65520U;
      hdr->seq_ctrl = (unsigned int )hdr->seq_ctrl & 15U;
      hdr->seq_ctrl = (__le16 )((int )hdr->seq_ctrl | (int )seq_number);
      seq_number = (unsigned int )seq_number + 16U;
      if ((info->flags & 64U) != 0U) {
        is_agg = 1;
      } else {

      }
      is_data_qos = 1;
    } else {

    }
  } else {

  }
  memcpy((void *)(& tx_cmd->hdr), (void const   *)hdr, (size_t )hdr_len);
  txq_id = (int )info->hw_queue;
  if ((int )is_agg) {
    txq_id = (int )priv->tid_data[(int )sta_id][(int )tid].agg.txq_id;
  } else
  if ((info->flags & 32U) != 0U) {
    hdr->frame_control = (__le16 )((unsigned int )hdr->frame_control | 8192U);
  } else {

  }
  __ret_warn_once___1 = (int )is_agg && (int )priv->queue_to_mac80211[txq_id] != (int )info->hw_queue;
  tmp___26 = ldv__builtin_expect(__ret_warn_once___1 != 0, 0L);
  if (tmp___26 != 0L) {
    __ret_warn_on___1 = ! __warned___2;
    tmp___24 = ldv__builtin_expect(__ret_warn_on___1 != 0, 0L);
    if (tmp___24 != 0L) {
      warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/08_1a/drivers/net/wireless/iwlwifi/dvm/tx.c",
                         450);
    } else {

    }
    tmp___25 = ldv__builtin_expect(__ret_warn_on___1 != 0, 0L);
    if (tmp___25 != 0L) {
      __warned___2 = 1;
    } else {

    }
  } else {

  }
  ldv__builtin_expect(__ret_warn_once___1 != 0, 0L);
  __iwl_dbg(priv->dev, 8388608U, 0, "iwlagn_tx_skb", "TX to [%d|%d] Q:%d - seq: 0x%x\n",
            (int )sta_id, (int )tid, txq_id, (int )seq_number);
  tmp___27 = iwl_trans_tx(priv->trans, skb, dev_cmd, txq_id);
  if (tmp___27 != 0) {
    goto drop_unlock_sta;
  } else {

  }
  if ((int )is_data_qos) {
    tmp___28 = ieee80211_has_morefrags((int )fc);
    if (tmp___28 == 0) {
      priv->tid_data[(int )sta_id][(int )tid].seq_number = seq_number;
    } else {

    }
  } else {

  }
  spin_unlock(& priv->sta_lock);
  if (((unsigned long )sta_priv != (unsigned long )((struct iwl_station_priv *)0) && (int )sta_priv->client) && ! is_agg) {
    atomic_inc(& sta_priv->pending_frames);
  } else {

  }
  return (0);
  drop_unlock_sta: ;
  if ((unsigned long )dev_cmd != (unsigned long )((struct iwl_device_cmd *)0)) {
    iwl_trans_free_tx_cmd(priv->trans, dev_cmd);
  } else {

  }
  spin_unlock(& priv->sta_lock);
  drop_unlock_priv: ;
  return (-1);
}
}
static int iwlagn_alloc_agg_txq(struct iwl_priv *priv , int mq ) 
{ 
  int q ;
  int tmp ;

  {
  q = 11;
  goto ldv_55094;
  ldv_55093: 
  tmp = test_and_set_bit((long )q, (unsigned long volatile   *)(& priv->agg_q_alloc));
  if (tmp == 0) {
    priv->queue_to_mac80211[q] = (u8 )mq;
    return (q);
  } else {

  }
  q = q + 1;
  ldv_55094: ;
  if ((int )((priv->cfg)->base_params)->num_of_queues > q) {
    goto ldv_55093;
  } else {

  }

  return (-28);
}
}
static void iwlagn_dealloc_agg_txq(struct iwl_priv *priv , int q ) 
{ 


  {
  clear_bit((long )q, (unsigned long volatile   *)(& priv->agg_q_alloc));
  priv->queue_to_mac80211[q] = 255U;
  return;
}
}
int iwlagn_tx_agg_stop(struct iwl_priv *priv , struct ieee80211_vif *vif , struct ieee80211_sta *sta ,
                       u16 tid ) 
{ 
  struct iwl_tid_data *tid_data ;
  int sta_id ;
  int txq_id ;
  enum iwl_agg_state agg_state ;
  int tmp ;
  int tmp___0 ;

  {
  sta_id = iwl_sta_id(sta);
  if (sta_id == 255) {
    __iwl_err(priv->dev, 0, 0, "Invalid station for AGG tid %d\n", (int )tid);
    return (-6);
  } else {

  }
  spin_lock_bh(& priv->sta_lock);
  tid_data = (struct iwl_tid_data *)(& priv->tid_data) + ((unsigned long )sta_id + (unsigned long )tid);
  txq_id = (int )tid_data->agg.txq_id;
  switch ((unsigned int )tid_data->agg.state) {
  case 3U: 
  __iwl_dbg(priv->dev, 67108864U, 0, "iwlagn_tx_agg_stop", "AGG stop before setup done\n");
  goto turn_off;
  case 1U: 
  __iwl_dbg(priv->dev, 67108864U, 0, "iwlagn_tx_agg_stop", "AGG stop before AGG became operational\n");
  goto turn_off;
  case 2U: ;
  goto ldv_55115;
  default: 
  __iwl_warn(priv->dev, "Stopping AGG while state not ON or starting for %d on %d (%d)\n",
             sta_id, (int )tid, (unsigned int )tid_data->agg.state);
  spin_unlock_bh(& priv->sta_lock);
  return (0);
  }
  ldv_55115: 
  tid_data->agg.ssn = (int )tid_data->seq_number >> 4;
  tmp = variable_test_bit((long )txq_id, (unsigned long const volatile   *)(& priv->agg_q_alloc));
  if (tmp == 0) {
    __iwl_dbg(priv->dev, 2147483648U, 0, "iwlagn_tx_agg_stop", "stopping AGG on STA/TID %d/%d but hwq %d not used\n",
              sta_id, (int )tid, txq_id);
  } else
  if ((int )tid_data->agg.ssn != (int )tid_data->next_reclaimed) {
    __iwl_dbg(priv->dev, 2147483648U, 0, "iwlagn_tx_agg_stop", "Can\'t proceed: ssn %d, next_recl = %d\n",
              (int )tid_data->agg.ssn, (int )tid_data->next_reclaimed);
    tid_data->agg.state = 4;
    spin_unlock_bh(& priv->sta_lock);
    return (0);
  } else {

  }
  __iwl_dbg(priv->dev, 2147483648U, 0, "iwlagn_tx_agg_stop", "Can proceed: ssn = next_recl = %d\n",
            (int )tid_data->agg.ssn);
  turn_off: 
  agg_state = tid_data->agg.state;
  tid_data->agg.state = 0;
  spin_unlock_bh(& priv->sta_lock);
  tmp___0 = variable_test_bit((long )txq_id, (unsigned long const volatile   *)(& priv->agg_q_alloc));
  if (tmp___0 != 0) {
    if ((unsigned int )agg_state == 2U) {
      iwl_trans_txq_disable(priv->trans, txq_id, 1);
    } else {
      __iwl_dbg(priv->dev, 2147483648U, 0, "iwlagn_tx_agg_stop", "Don\'t disable tx agg: %d\n",
                (unsigned int )agg_state);
    }
    iwlagn_dealloc_agg_txq(priv, txq_id);
  } else {

  }
  ieee80211_stop_tx_ba_cb_irqsafe(vif, (u8 const   *)(& sta->addr), (int )tid);
  return (0);
}
}
int iwlagn_tx_agg_start(struct iwl_priv *priv , struct ieee80211_vif *vif , struct ieee80211_sta *sta ,
                        u16 tid , u16 *ssn ) 
{ 
  struct iwl_rxon_context *ctx ;
  struct iwl_rxon_context *tmp ;
  struct iwl_tid_data *tid_data ;
  int sta_id ;
  int txq_id ;
  int ret ;
  long tmp___0 ;

  {
  tmp = iwl_rxon_ctx_from_vif(vif);
  ctx = tmp;
  __iwl_dbg(priv->dev, 67108864U, 0, "iwlagn_tx_agg_start", "TX AGG request on ra = %pM tid = %d\n",
            (u8 *)(& sta->addr), (int )tid);
  sta_id = iwl_sta_id(sta);
  if (sta_id == 255) {
    __iwl_err(priv->dev, 0, 0, "Start AGG on invalid station\n");
    return (-6);
  } else {

  }
  tmp___0 = ldv__builtin_expect((unsigned int )tid > 7U, 0L);
  if (tmp___0 != 0L) {
    return (-22);
  } else {

  }
  if ((unsigned int )priv->tid_data[sta_id][(int )tid].agg.state != 0U) {
    __iwl_err(priv->dev, 0, 0, "Start AGG when state is not IWL_AGG_OFF !\n");
    return (-6);
  } else {

  }
  txq_id = iwlagn_alloc_agg_txq(priv, (int )ctx->ac_to_queue[(int )tid_to_ac[(int )tid]]);
  if (txq_id < 0) {
    __iwl_dbg(priv->dev, 2147483648U, 0, "iwlagn_tx_agg_start", "No free aggregation queue for %pM/%d\n",
              (u8 *)(& sta->addr), (int )tid);
    return (txq_id);
  } else {

  }
  ret = iwl_sta_tx_modify_enable_tid(priv, sta_id, (int )tid);
  if (ret != 0) {
    return (ret);
  } else {

  }
  spin_lock_bh(& priv->sta_lock);
  tid_data = (struct iwl_tid_data *)(& priv->tid_data) + ((unsigned long )sta_id + (unsigned long )tid);
  tid_data->agg.ssn = (int )tid_data->seq_number >> 4;
  tid_data->agg.txq_id = (u16 )txq_id;
  *ssn = tid_data->agg.ssn;
  if ((int )*ssn == (int )tid_data->next_reclaimed) {
    __iwl_dbg(priv->dev, 2147483648U, 0, "iwlagn_tx_agg_start", "Can proceed: ssn = next_recl = %d\n",
              (int )tid_data->agg.ssn);
    tid_data->agg.state = 1;
    ieee80211_start_tx_ba_cb_irqsafe(vif, (u8 const   *)(& sta->addr), (int )tid);
  } else {
    __iwl_dbg(priv->dev, 2147483648U, 0, "iwlagn_tx_agg_start", "Can\'t proceed: ssn %d, next_reclaimed = %d\n",
              (int )tid_data->agg.ssn, (int )tid_data->next_reclaimed);
    tid_data->agg.state = 3;
  }
  spin_unlock_bh(& priv->sta_lock);
  return (ret);
}
}
int iwlagn_tx_agg_flush(struct iwl_priv *priv , struct ieee80211_vif *vif , struct ieee80211_sta *sta ,
                        u16 tid ) 
{ 
  struct iwl_tid_data *tid_data ;
  enum iwl_agg_state agg_state ;
  int sta_id ;
  int txq_id ;
  int tmp ;
  int tmp___0 ;

  {
  sta_id = iwl_sta_id(sta);
  spin_lock_bh(& priv->sta_lock);
  tid_data = (struct iwl_tid_data *)(& priv->tid_data) + ((unsigned long )sta_id + (unsigned long )tid);
  txq_id = (int )tid_data->agg.txq_id;
  agg_state = tid_data->agg.state;
  __iwl_dbg(priv->dev, 2147483648U, 0, "iwlagn_tx_agg_flush", "Flush AGG: sta %d tid %d q %d state %d\n",
            sta_id, (int )tid, txq_id, (unsigned int )tid_data->agg.state);
  tid_data->agg.state = 0;
  spin_unlock_bh(& priv->sta_lock);
  tmp = iwlagn_txfifo_flush(priv, (u32 )(1UL << txq_id));
  if (tmp != 0) {
    __iwl_err(priv->dev, 0, 0, "Couldn\'t flush the AGG queue\n");
  } else {

  }
  tmp___0 = variable_test_bit((long )txq_id, (unsigned long const volatile   *)(& priv->agg_q_alloc));
  if (tmp___0 != 0) {
    if ((unsigned int )agg_state == 2U) {
      iwl_trans_txq_disable(priv->trans, txq_id, 1);
    } else {
      __iwl_dbg(priv->dev, 2147483648U, 0, "iwlagn_tx_agg_flush", "Don\'t disable tx agg: %d\n",
                (unsigned int )agg_state);
    }
    iwlagn_dealloc_agg_txq(priv, txq_id);
  } else {

  }
  return (0);
}
}
int iwlagn_tx_agg_oper(struct iwl_priv *priv , struct ieee80211_vif *vif , struct ieee80211_sta *sta ,
                       u16 tid , u8 buf_size ) 
{ 
  struct iwl_station_priv *sta_priv ;
  struct iwl_rxon_context *ctx ;
  struct iwl_rxon_context *tmp ;
  int q ;
  int fifo ;
    klee_make_symbolic(&fifo, sizeof(int), "fifo");
  u16 ssn ;
  int __min1 ;
    klee_make_symbolic(&__min1, sizeof(int), "__min1");
  int __min2 ;
    klee_make_symbolic(&__min2, sizeof(int), "__min2");
  u8 _min1 ;
  u8 _min2 ;
  int tmp___0 ;

  {
  sta_priv = (struct iwl_station_priv *)(& sta->drv_priv);
  tmp = iwl_rxon_ctx_from_vif(vif);
  ctx = tmp;
  __min1 = (int )buf_size;
  __min2 = 63;
  buf_size = (u8 )(__min1 < __min2 ? __min1 : __min2);
  spin_lock_bh(& priv->sta_lock);
  ssn = priv->tid_data[(int )sta_priv->sta_id][(int )tid].agg.ssn;
  q = (int )priv->tid_data[(int )sta_priv->sta_id][(int )tid].agg.txq_id;
  priv->tid_data[(int )sta_priv->sta_id][(int )tid].agg.state = 2;
  spin_unlock_bh(& priv->sta_lock);
  fifo = (int )ctx->ac_to_fifo[(int )tid_to_ac[(int )tid]];
  iwl_trans_txq_enable(priv->trans, q, fifo, (int )sta_priv->sta_id, (int )tid, (int )buf_size,
                       (int )ssn, 0U);
  if ((unsigned int )sta_priv->max_agg_bufsize == 0U) {
    sta_priv->max_agg_bufsize = 63U;
  } else {

  }
  _min1 = sta_priv->max_agg_bufsize;
  _min2 = buf_size;
  sta_priv->max_agg_bufsize = (u8 )((int )_min1 < (int )_min2 ? _min1 : _min2);
  if ((int )priv->hw_params.use_rts_for_aggregation) {
    sta_priv->lq_sta.lq.general_params.flags = (u8 )((unsigned int )sta_priv->lq_sta.lq.general_params.flags | 1U);
  } else {

  }
  priv->agg_tids_count = (u8 )((int )priv->agg_tids_count + 1);
  __iwl_dbg(priv->dev, 67108864U, 0, "iwlagn_tx_agg_oper", "priv->agg_tids_count = %u\n",
            (int )priv->agg_tids_count);
  sta_priv->lq_sta.lq.agg_params.agg_frame_cnt_limit = sta_priv->max_agg_bufsize;
  __iwl_dbg(priv->dev, 67108864U, 0, "iwlagn_tx_agg_oper", "Tx aggregation enabled on ra = %pM tid = %d\n",
            (u8 *)(& sta->addr), (int )tid);
  tmp___0 = iwl_send_lq_cmd(priv, ctx, & sta_priv->lq_sta.lq, 1, 0);
  return (tmp___0);
}
}
static void iwlagn_check_ratid_empty(struct iwl_priv *priv , int sta_id , u8 tid ) 
{ 
  struct iwl_tid_data *tid_data ;
  enum iwl_rxon_context_id ctx ;
  struct ieee80211_vif *vif ;
  u8 *addr ;
  int __ret_warn_on ;
  int tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
  tid_data = (struct iwl_tid_data *)(& priv->tid_data) + ((unsigned long )sta_id + (unsigned long )tid);
  if (debug_locks != 0) {
    tmp = lock_is_held(& priv->sta_lock.__annonCompField18.__annonCompField17.dep_map);
    if (tmp == 0) {
      tmp___0 = 1;
    } else {
      tmp___0 = 0;
    }
  } else {
    tmp___0 = 0;
  }
  __ret_warn_on = tmp___0;
  tmp___1 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp___1 != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/08_1a/drivers/net/wireless/iwlwifi/dvm/tx.c",
                       770);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  addr = (u8 *)(& priv->stations[sta_id].sta.sta.addr);
  ctx = (enum iwl_rxon_context_id )priv->stations[sta_id].ctxid;
  vif = priv->contexts[(unsigned int )ctx].vif;
  switch ((unsigned int )priv->tid_data[sta_id][(int )tid].agg.state) {
  case 4U: ;
  if ((int )tid_data->agg.ssn == (int )tid_data->next_reclaimed) {
    __iwl_dbg(priv->dev, 2147483648U, 0, "iwlagn_check_ratid_empty", "Can continue DELBA flow ssn = next_recl = %d\n",
              (int )tid_data->next_reclaimed);
    iwl_trans_txq_disable(priv->trans, (int )tid_data->agg.txq_id, 1);
    iwlagn_dealloc_agg_txq(priv, (int )tid_data->agg.txq_id);
    tid_data->agg.state = 0;
    ieee80211_stop_tx_ba_cb_irqsafe(vif, (u8 const   *)addr, (int )tid);
  } else {

  }
  goto ldv_55173;
  case 3U: ;
  if ((int )tid_data->agg.ssn == (int )tid_data->next_reclaimed) {
    __iwl_dbg(priv->dev, 2147483648U, 0, "iwlagn_check_ratid_empty", "Can continue ADDBA flow ssn = next_recl = %d\n",
              (int )tid_data->next_reclaimed);
    tid_data->agg.state = 1;
    ieee80211_start_tx_ba_cb_irqsafe(vif, (u8 const   *)addr, (int )tid);
  } else {

  }
  goto ldv_55173;
  default: ;
  goto ldv_55173;
  }
  ldv_55173: ;
  return;
}
}
static void iwlagn_non_agg_tx_status(struct iwl_priv *priv , struct iwl_rxon_context *ctx ,
                                     u8 const   *addr1 ) 
{ 
  struct ieee80211_sta *sta ;
  struct iwl_station_priv *sta_priv ;
  int tmp ;

  {
  rcu_read_lock();
  sta = ieee80211_find_sta(ctx->vif, addr1);
  if ((unsigned long )sta != (unsigned long )((struct ieee80211_sta *)0)) {
    sta_priv = (struct iwl_station_priv *)(& sta->drv_priv);
    if ((int )sta_priv->client) {
      tmp = atomic_sub_return(1, & sta_priv->pending_frames);
      if (tmp == 0) {
        ieee80211_sta_block_awake(priv->hw, sta, 0);
      } else {

      }
    } else {

    }
  } else {

  }
  rcu_read_unlock();
  return;
}
}
static void iwlagn_hwrate_to_tx_control(struct iwl_priv *priv , u32 rate_n_flags ,
                                        struct ieee80211_tx_info *info ) 
{ 
  struct ieee80211_tx_rate *r ;
  int tmp ;

  {
  r = (struct ieee80211_tx_rate *)(& info->__annonCompField99.status.rates);
  info->__annonCompField99.status.antenna = (u8 )((rate_n_flags & 114688U) >> 14);
  if ((rate_n_flags & 256U) != 0U) {
    r->flags = (unsigned short )((unsigned int )r->flags | 8U);
  } else {

  }
  if ((rate_n_flags & 1024U) != 0U) {
    r->flags = (unsigned short )((unsigned int )r->flags | 16U);
  } else {

  }
  if ((rate_n_flags & 2048U) != 0U) {
    r->flags = (unsigned short )((unsigned int )r->flags | 32U);
  } else {

  }
  if ((rate_n_flags & 4096U) != 0U) {
    r->flags = (unsigned short )((unsigned int )r->flags | 64U);
  } else {

  }
  if ((rate_n_flags & 8192U) != 0U) {
    r->flags = (unsigned short )((unsigned int )r->flags | 128U);
  } else {

  }
  tmp = iwlagn_hwrate_to_mac80211_idx(rate_n_flags, (enum ieee80211_band )info->band);
  r->idx = (s8 )tmp;
  return;
}
}
char const   *iwl_get_tx_fail_reason(u32 status ) 
{ 


  {
  switch (status & 255U) {
  case 1U: ;
  return ("SUCCESS");
  case 64U: ;
  return ("DELAY");
  case 65U: ;
  return ("FEW_BYTES");
  case 66U: ;
  return ("BT_PRIO");
  case 67U: ;
  return ("QUIET_PERIOD");
  case 68U: ;
  return ("CALC_TTAK");
  case 129U: ;
  return ("INTERNAL_CROSSED_RETRY");
  case 130U: ;
  return ("SHORT_LIMIT");
  case 131U: ;
  return ("LONG_LIMIT");
  case 132U: ;
  return ("FIFO_UNDERRUN");
  case 133U: ;
  return ("DRAIN_FLOW");
  case 134U: ;
  return ("RFKILL_FLUSH");
  case 135U: ;
  return ("LIFE_EXPIRE");
  case 136U: ;
  return ("DEST_PS");
  case 137U: ;
  return ("HOST_ABORTED");
  case 138U: ;
  return ("BT_RETRY");
  case 139U: ;
  return ("STA_INVALID");
  case 140U: ;
  return ("FRAG_DROPPED");
  case 141U: ;
  return ("TID_DISABLE");
  case 142U: ;
  return ("FIFO_FLUSHED");
  case 143U: ;
  return ("INSUFFICIENT_CF_POLL");
  case 144U: ;
  return ("PASSIVE_NO_RX");
  case 145U: ;
  return ("NO_BEACON_ON_RADAR");
  }
  return ("UNKNOWN");
}
}
static void iwlagn_count_agg_tx_err_status(struct iwl_priv *priv , u16 status ) 
{ 


  {
  status = (unsigned int )status & 4095U;
  switch ((int )status) {
  case 1: 
  priv->reply_agg_tx_stats.underrun = priv->reply_agg_tx_stats.underrun + 1U;
  goto ldv_55220;
  case 2: 
  priv->reply_agg_tx_stats.bt_prio = priv->reply_agg_tx_stats.bt_prio + 1U;
  goto ldv_55220;
  case 4: 
  priv->reply_agg_tx_stats.few_bytes = priv->reply_agg_tx_stats.few_bytes + 1U;
  goto ldv_55220;
  case 8: 
  priv->reply_agg_tx_stats.abort = priv->reply_agg_tx_stats.abort + 1U;
  goto ldv_55220;
  case 16: 
  priv->reply_agg_tx_stats.last_sent_ttl = priv->reply_agg_tx_stats.last_sent_ttl + 1U;
  goto ldv_55220;
  case 32: 
  priv->reply_agg_tx_stats.last_sent_try = priv->reply_agg_tx_stats.last_sent_try + 1U;
  goto ldv_55220;
  case 64: 
  priv->reply_agg_tx_stats.last_sent_bt_kill = priv->reply_agg_tx_stats.last_sent_bt_kill + 1U;
  goto ldv_55220;
  case 128: 
  priv->reply_agg_tx_stats.scd_query = priv->reply_agg_tx_stats.scd_query + 1U;
  goto ldv_55220;
  case 256: 
  priv->reply_agg_tx_stats.bad_crc32 = priv->reply_agg_tx_stats.bad_crc32 + 1U;
  goto ldv_55220;
  case 511: 
  priv->reply_agg_tx_stats.response = priv->reply_agg_tx_stats.response + 1U;
  goto ldv_55220;
  case 512: 
  priv->reply_agg_tx_stats.dump_tx = priv->reply_agg_tx_stats.dump_tx + 1U;
  goto ldv_55220;
  case 1024: 
  priv->reply_agg_tx_stats.delay_tx = priv->reply_agg_tx_stats.delay_tx + 1U;
  goto ldv_55220;
  default: 
  priv->reply_agg_tx_stats.unknown = priv->reply_agg_tx_stats.unknown + 1U;
  goto ldv_55220;
  }
  ldv_55220: ;
  return;
}
}
__inline static u32 iwlagn_get_scd_ssn(struct iwlagn_tx_resp *tx_resp ) 
{ 
  __u32 tmp ;

  {
  tmp = __le32_to_cpup((__le32 const   *)(& tx_resp->status) + (unsigned long )tx_resp->frame_count);
  return (tmp & 4095U);
}
}
static void iwl_rx_reply_tx_agg(struct iwl_priv *priv , struct iwlagn_tx_resp *tx_resp ) 
{ 
  struct agg_tx_status *frame_status ;
  int tid ;
    klee_make_symbolic(&tid, sizeof(int), "tid");
  int sta_id ;
  struct iwl_ht_agg *agg ;
  u32 status ;
  int i ;
  int __ret_warn_on ;
  long tmp ;
  u32 tmp___0 ;
  u16 fstatus ;
  u8 retry_cnt ;
  char const   *tmp___1 ;

  {
  frame_status = & tx_resp->status;
  tid = (int )tx_resp->ra_tid & 15;
  sta_id = (int )tx_resp->ra_tid >> 4;
  agg = & priv->tid_data[sta_id][tid].agg;
  status = (u32 )tx_resp->status.status;
  __ret_warn_on = tid == 8;
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/08_1a/drivers/net/wireless/iwlwifi/dvm/tx.c",
                       952);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if ((int )agg->wait_for_ba) {
    __iwl_dbg(priv->dev, 1073741824U, 0, "iwl_rx_reply_tx_agg", "got tx response w/o block-ack\n");
  } else {

  }
  agg->rate_n_flags = tx_resp->rate_n_flags;
  agg->wait_for_ba = (unsigned int )tx_resp->frame_count > 1U;
  if ((((unsigned int )tx_resp->bt_kill_count != 0U && (unsigned int )tx_resp->frame_count == 1U) && (unsigned long )(priv->lib)->bt_params != (unsigned long )((struct iwl_dvm_bt_params  const  */* const  */)0)) && (int )((priv->lib)->bt_params)->advanced_bt_coexist) {
    __iwl_dbg(priv->dev, 32768U, 0, "iwl_rx_reply_tx_agg", "receive reply tx w/ bt_kill\n");
  } else {

  }
  if ((unsigned int )tx_resp->frame_count == 1U) {
    return;
  } else {

  }
  tmp___0 = iwlagn_get_scd_ssn(tx_resp);
  __iwl_dbg(priv->dev, 1073741824U, 0, "iwl_rx_reply_tx_agg", "TXQ %d initial_rate 0x%x ssn %d frm_cnt %d\n",
            (int )agg->txq_id, tx_resp->rate_n_flags, tmp___0, (int )tx_resp->frame_count);
  i = 0;
  goto ldv_55253;
  ldv_55252: 
  fstatus = (frame_status + (unsigned long )i)->status;
  retry_cnt = (u8 )((int )fstatus >> 12);
  if ((status & 4095U) != 0U) {
    iwlagn_count_agg_tx_err_status(priv, (int )fstatus);
  } else {

  }
  if ((status & 12U) != 0U) {
    goto ldv_55251;
  } else {

  }
  if ((status & 4095U) != 0U || (unsigned int )retry_cnt > 1U) {
    tmp___1 = iwl_get_agg_tx_fail_reason((int )fstatus);
    __iwl_dbg(priv->dev, 1073741824U, 0, "iwl_rx_reply_tx_agg", "%d: status %s (0x%04x), try-count (0x%01x)\n",
              i, tmp___1, (int )fstatus & 4095, (int )retry_cnt);
  } else {

  }
  ldv_55251: 
  i = i + 1;
  ldv_55253: ;
  if ((int )tx_resp->frame_count > i) {
    goto ldv_55252;
  } else {

  }

  return;
}
}
char const   *iwl_get_agg_tx_fail_reason(u16 status ) 
{ 


  {
  status = (unsigned int )status & 4095U;
  switch ((int )status) {
  case 0: ;
  return ("SUCCESS");
  case 1: ;
  return ("UNDERRUN_MSK");
  case 2: ;
  return ("BT_PRIO_MSK");
  case 4: ;
  return ("FEW_BYTES_MSK");
  case 8: ;
  return ("ABORT_MSK");
  case 16: ;
  return ("LAST_SENT_TTL_MSK");
  case 32: ;
  return ("LAST_SENT_TRY_CNT_MSK");
  case 64: ;
  return ("LAST_SENT_BT_KILL_MSK");
  case 128: ;
  return ("SCD_QUERY_MSK");
  case 256: ;
  return ("TEST_BAD_CRC32_MSK");
  case 511: ;
  return ("RESPONSE_MSK");
  case 512: ;
  return ("DUMP_TX_MSK");
  case 1024: ;
  return ("DELAY_TX_MSK");
  }
  return ("UNKNOWN");
}
}
static void iwlagn_count_tx_err_status(struct iwl_priv *priv , u16 status ) 
{ 


  {
  status = (unsigned int )status & 255U;
  switch ((int )status) {
  case 64: 
  priv->reply_tx_stats.pp_delay = priv->reply_tx_stats.pp_delay + 1U;
  goto ldv_55276;
  case 65: 
  priv->reply_tx_stats.pp_few_bytes = priv->reply_tx_stats.pp_few_bytes + 1U;
  goto ldv_55276;
  case 66: 
  priv->reply_tx_stats.pp_bt_prio = priv->reply_tx_stats.pp_bt_prio + 1U;
  goto ldv_55276;
  case 67: 
  priv->reply_tx_stats.pp_quiet_period = priv->reply_tx_stats.pp_quiet_period + 1U;
  goto ldv_55276;
  case 68: 
  priv->reply_tx_stats.pp_calc_ttak = priv->reply_tx_stats.pp_calc_ttak + 1U;
  goto ldv_55276;
  case 129: 
  priv->reply_tx_stats.int_crossed_retry = priv->reply_tx_stats.int_crossed_retry + 1U;
  goto ldv_55276;
  case 130: 
  priv->reply_tx_stats.short_limit = priv->reply_tx_stats.short_limit + 1U;
  goto ldv_55276;
  case 131: 
  priv->reply_tx_stats.long_limit = priv->reply_tx_stats.long_limit + 1U;
  goto ldv_55276;
  case 132: 
  priv->reply_tx_stats.fifo_underrun = priv->reply_tx_stats.fifo_underrun + 1U;
  goto ldv_55276;
  case 133: 
  priv->reply_tx_stats.drain_flow = priv->reply_tx_stats.drain_flow + 1U;
  goto ldv_55276;
  case 134: 
  priv->reply_tx_stats.rfkill_flush = priv->reply_tx_stats.rfkill_flush + 1U;
  goto ldv_55276;
  case 135: 
  priv->reply_tx_stats.life_expire = priv->reply_tx_stats.life_expire + 1U;
  goto ldv_55276;
  case 136: 
  priv->reply_tx_stats.dest_ps = priv->reply_tx_stats.dest_ps + 1U;
  goto ldv_55276;
  case 137: 
  priv->reply_tx_stats.host_abort = priv->reply_tx_stats.host_abort + 1U;
  goto ldv_55276;
  case 138: 
  priv->reply_tx_stats.bt_retry = priv->reply_tx_stats.bt_retry + 1U;
  goto ldv_55276;
  case 139: 
  priv->reply_tx_stats.sta_invalid = priv->reply_tx_stats.sta_invalid + 1U;
  goto ldv_55276;
  case 140: 
  priv->reply_tx_stats.frag_drop = priv->reply_tx_stats.frag_drop + 1U;
  goto ldv_55276;
  case 141: 
  priv->reply_tx_stats.tid_disable = priv->reply_tx_stats.tid_disable + 1U;
  goto ldv_55276;
  case 142: 
  priv->reply_tx_stats.fifo_flush = priv->reply_tx_stats.fifo_flush + 1U;
  goto ldv_55276;
  case 143: 
  priv->reply_tx_stats.insuff_cf_poll = priv->reply_tx_stats.insuff_cf_poll + 1U;
  goto ldv_55276;
  case 144: 
  priv->reply_tx_stats.fail_hw_drop = priv->reply_tx_stats.fail_hw_drop + 1U;
  goto ldv_55276;
  case 145: 
  priv->reply_tx_stats.sta_color_mismatch = priv->reply_tx_stats.sta_color_mismatch + 1U;
  goto ldv_55276;
  default: 
  priv->reply_tx_stats.unknown = priv->reply_tx_stats.unknown + 1U;
  goto ldv_55276;
  }
  ldv_55276: ;
  return;
}
}
static void iwlagn_set_tx_status(struct iwl_priv *priv , struct ieee80211_tx_info *info ,
                                 struct iwlagn_tx_resp *tx_resp ) 
{ 
  u16 status ;
  u32 tmp ;
  bool tmp___0 ;
  int tmp___1 ;

  {
  status = tx_resp->status.status;
  info->flags = info->flags & 4294967231U;
  info->__annonCompField99.status.rates[0].count = (unsigned char )((unsigned int )tx_resp->failure_frame + 1U);
  tmp = iwl_tx_status_to_mac80211((u32 )status);
  info->flags = info->flags | tmp;
  iwlagn_hwrate_to_tx_control(priv, tx_resp->rate_n_flags, info);
  tmp___0 = iwl_is_tx_success((u32 )status);
  if (tmp___0) {
    tmp___1 = 0;
  } else {
    tmp___1 = 1;
  }
  if (tmp___1) {
    iwlagn_count_tx_err_status(priv, (int )status);
  } else {

  }
  return;
}
}
static void iwl_check_abort_status(struct iwl_priv *priv , u8 frame_count , u32 status ) 
{ 
  int tmp ;

  {
  if ((unsigned int )frame_count == 1U && status == 134U) {
    __iwl_err(priv->dev, 0, 0, "Tx flush command to flush out all frames\n");
    tmp = constant_test_bit(5L, (unsigned long const volatile   *)(& priv->status));
    if (tmp == 0) {
      queue_work___2(priv->workqueue, & priv->tx_flush);
    } else {

    }
  } else {

  }
  return;
}
}
int iwlagn_rx_reply_tx(struct iwl_priv *priv , struct iwl_rx_cmd_buffer *rxb , struct iwl_device_cmd *cmd ) 
{ 
  struct iwl_rx_packet *pkt ;
  void *tmp ;
  u16 sequence ;
  int txq_id ;
  int cmd_index ;
    klee_make_symbolic(&cmd_index, sizeof(int), "cmd_index");
  struct iwlagn_tx_resp *tx_resp ;
  struct ieee80211_hdr *hdr ;
  u32 status ;
  u16 ssn ;
  u32 tmp___0 ;
  int tid ;
  int sta_id ;
  int freed ;
    klee_make_symbolic(&freed, sizeof(int), "freed");
  struct ieee80211_tx_info *info ;
  struct sk_buff_head skbs ;
  struct sk_buff *skb ;
  struct iwl_rxon_context *ctx ;
  bool is_agg ;
  bool __warned ;
  int __ret_warn_once ;
  int __ret_warn_on ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  u16 next_reclaimed ;
  int tmp___4 ;
  char const   *tmp___5 ;
  bool tmp___6 ;
  int tmp___7 ;
  struct ieee80211_tx_info *tmp___8 ;
  char const   *tmp___9 ;
  int tmp___10 ;

  {
  tmp = rxb_addr(rxb);
  pkt = (struct iwl_rx_packet *)tmp;
  sequence = pkt->hdr.sequence;
  txq_id = ((int )sequence >> 8) & 31;
  cmd_index = (int )sequence & 255;
  tx_resp = (struct iwlagn_tx_resp *)(& pkt->data);
  status = (u32 )tx_resp->status.status;
  tmp___0 = iwlagn_get_scd_ssn(tx_resp);
  ssn = (u16 )tmp___0;
  is_agg = txq_id > 10;
  tid = (int )tx_resp->ra_tid & 15;
  sta_id = (int )tx_resp->ra_tid >> 4;
  spin_lock_bh(& priv->sta_lock);
  if ((int )is_agg) {
    __ret_warn_once = sta_id > 15 || tid > 7;
    tmp___3 = ldv__builtin_expect(__ret_warn_once != 0, 0L);
    if (tmp___3 != 0L) {
      __ret_warn_on = ! __warned;
      tmp___1 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
      if (tmp___1 != 0L) {
        warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/08_1a/drivers/net/wireless/iwlwifi/dvm/tx.c",
                           1160);
      } else {

      }
      tmp___2 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
      if (tmp___2 != 0L) {
        __warned = 1;
      } else {

      }
    } else {

    }
    ldv__builtin_expect(__ret_warn_once != 0, 0L);
    if ((int )priv->tid_data[sta_id][tid].agg.txq_id != txq_id) {
      __iwl_err(priv->dev, 0, 0, "txq_id mismatch: %d %d\n", txq_id, (int )priv->tid_data[sta_id][tid].agg.txq_id);
    } else {

    }
    iwl_rx_reply_tx_agg(priv, tx_resp);
  } else {

  }
  __skb_queue_head_init(& skbs);
  if ((unsigned int )tx_resp->frame_count == 1U) {
    next_reclaimed = tx_resp->seq_ctl;
    next_reclaimed = (u16 )((((int )next_reclaimed + 16) & 65520) >> 4);
    if ((int )is_agg) {
      next_reclaimed = ssn;
    } else {

    }
    if (tid != 8) {
      priv->tid_data[sta_id][tid].next_reclaimed = next_reclaimed;
      __iwl_dbg(priv->dev, 1073741824U, 0, "iwlagn_rx_reply_tx", "Next reclaimed packet:%d\n",
                (int )next_reclaimed);
    } else {

    }
    iwl_trans_reclaim(priv->trans, txq_id, (int )ssn, & skbs);
    iwlagn_check_ratid_empty(priv, sta_id, (int )((u8 )tid));
    freed = 0;
    skb = skbs.next;
    goto ldv_55339;
    ldv_55338: 
    hdr = (struct ieee80211_hdr *)skb->data;
    tmp___4 = ieee80211_is_data_qos((int )hdr->frame_control);
    if (tmp___4 == 0) {
      priv->last_seq_ctl = tx_resp->seq_ctl;
    } else {

    }
    info = IEEE80211_SKB_CB(skb);
    ctx = (struct iwl_rxon_context *)info->__annonCompField99.driver_data[0];
    iwl_trans_free_tx_cmd(priv->trans, (struct iwl_device_cmd *)info->__annonCompField99.driver_data[1]);
    memset((void *)(& info->__annonCompField99.status), 0, 40UL);
    if ((status == 144U && (unsigned long )ctx->vif != (unsigned long )((struct ieee80211_vif *)0)) && (unsigned int )(ctx->vif)->type == 2U) {
      priv->passive_no_rx = 1;
      __iwl_dbg(priv->dev, 2147483648U, 0, "iwlagn_rx_reply_tx", "stop all queues: passive channel\n");
      ieee80211_stop_queues(priv->hw);
      tmp___5 = iwl_get_tx_fail_reason(status);
      __iwl_dbg(priv->dev, 1073741824U, 0, "iwlagn_rx_reply_tx", "TXQ %d status %s (0x%08x) rate_n_flags 0x%x retries %d\n",
                txq_id, tmp___5, status, tx_resp->rate_n_flags, (int )tx_resp->failure_frame);
      __iwl_dbg(priv->dev, 1073741824U, 0, "iwlagn_rx_reply_tx", "FrameCnt = %d, idx=%d\n",
                (int )tx_resp->frame_count, cmd_index);
    } else {

    }
    if ((int )is_agg) {
      tmp___6 = iwl_is_tx_success(status);
      if (tmp___6) {
        tmp___7 = 0;
      } else {
        tmp___7 = 1;
      }
      if (tmp___7) {
        info->flags = info->flags | 2048U;
      } else {

      }
    } else {

    }
    tmp___8 = IEEE80211_SKB_CB(skb);
    iwlagn_set_tx_status(priv, tmp___8, tx_resp);
    if (! is_agg) {
      iwlagn_non_agg_tx_status(priv, ctx, (u8 const   *)(& hdr->addr1));
    } else {

    }
    freed = freed + 1;
    skb = skb->__annonCompField68.__annonCompField67.next;
    ldv_55339: ;
    if ((unsigned long )((struct sk_buff *)(& skbs)) != (unsigned long )skb) {
      goto ldv_55338;
    } else {

    }

    if (tid != 8) {
      priv->tid_data[sta_id][tid].next_reclaimed = next_reclaimed;
      __iwl_dbg(priv->dev, 1073741824U, 0, "iwlagn_rx_reply_tx", "Next reclaimed packet:%d\n",
                (int )next_reclaimed);
    } else {

    }
    if (! is_agg && freed != 1) {
      __iwl_err(priv->dev, 0, 0, "Q: %d, freed %d\n", txq_id, freed);
    } else {

    }
    tmp___9 = iwl_get_tx_fail_reason(status);
    __iwl_dbg(priv->dev, 1073741824U, 0, "iwlagn_rx_reply_tx", "TXQ %d status %s (0x%08x)\n",
              txq_id, tmp___9, status);
    __iwl_dbg(priv->dev, 1073741824U, 0, "iwlagn_rx_reply_tx", "\t\t\t\tinitial_rate 0x%x retries %d, idx=%d ssn=%d seq_ctl=0x%x\n",
              tx_resp->rate_n_flags, (int )tx_resp->failure_frame, (int )sequence & 255,
              (int )ssn, (int )tx_resp->seq_ctl);
  } else {

  }
  iwl_check_abort_status(priv, (int )tx_resp->frame_count, status);
  spin_unlock_bh(& priv->sta_lock);
  goto ldv_55342;
  ldv_55341: 
  skb = __skb_dequeue(& skbs);
  ieee80211_tx_status(priv->hw, skb);
  ldv_55342: 
  tmp___10 = skb_queue_empty((struct sk_buff_head  const  *)(& skbs));
  if (tmp___10 == 0) {
    goto ldv_55341;
  } else {

  }

  return (0);
}
}
int iwlagn_rx_reply_compressed_ba(struct iwl_priv *priv , struct iwl_rx_cmd_buffer *rxb ,
                                  struct iwl_device_cmd *cmd ) 
{ 
  struct iwl_rx_packet *pkt ;
  void *tmp ;
  struct iwl_compressed_ba_resp *ba_resp ;
  struct iwl_ht_agg *agg ;
  struct sk_buff_head reclaimed_skbs ;
  struct sk_buff *skb ;
  int sta_id ;
  int tid ;
  int freed ;
  u16 scd_flow ;
  u16 ba_resp_scd_ssn ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  struct ieee80211_hdr *hdr ;
  struct ieee80211_tx_info *info ;
  struct ieee80211_tx_info *tmp___3 ;
  bool __warned ;
  int __ret_warn_once ;
  int __ret_warn_on ;
  long tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
  tmp = rxb_addr(rxb);
  pkt = (struct iwl_rx_packet *)tmp;
  ba_resp = (struct iwl_compressed_ba_resp *)(& pkt->data);
  scd_flow = ba_resp->scd_flow;
  ba_resp_scd_ssn = ba_resp->scd_ssn;
  if ((int )scd_flow >= (int )((priv->cfg)->base_params)->num_of_queues) {
    __iwl_err(priv->dev, 0, 0, "BUG_ON scd_flow is bigger than number of queues\n");
    return (0);
  } else {

  }
  sta_id = (int )ba_resp->sta_id;
  tid = (int )ba_resp->tid;
  agg = & priv->tid_data[sta_id][tid].agg;
  spin_lock_bh(& priv->sta_lock);
  tmp___1 = ldv__builtin_expect((long )(! agg->wait_for_ba), 0L);
  if (tmp___1 != 0L) {
    tmp___0 = ldv__builtin_expect(ba_resp->bitmap != 0ULL, 0L);
    if (tmp___0 != 0L) {
      __iwl_err(priv->dev, 0, 0, "Received BA when not expected\n");
    } else {

    }
    spin_unlock_bh(& priv->sta_lock);
    return (0);
  } else {

  }
  tmp___2 = ldv__builtin_expect((int )agg->txq_id != (int )scd_flow, 0L);
  if (tmp___2 != 0L) {
    __iwl_dbg(priv->dev, 2147483648U, 0, "iwlagn_rx_reply_compressed_ba", "Bad queue mapping txq_id=%d, agg_txq[sta:%d,tid:%d]=%d\n",
              (int )scd_flow, sta_id, tid, (int )agg->txq_id);
    spin_unlock_bh(& priv->sta_lock);
    return (0);
  } else {

  }
  __skb_queue_head_init(& reclaimed_skbs);
  iwl_trans_reclaim(priv->trans, (int )scd_flow, (int )ba_resp_scd_ssn, & reclaimed_skbs);
  __iwl_dbg(priv->dev, 1073741824U, 0, "iwlagn_rx_reply_compressed_ba", "REPLY_COMPRESSED_BA [%d] Received from %pM, sta_id = %d\n",
            (int )agg->wait_for_ba, (u8 *)(& ba_resp->sta_addr_lo32), (int )ba_resp->sta_id);
  __iwl_dbg(priv->dev, 1073741824U, 0, "iwlagn_rx_reply_compressed_ba", "TID = %d, SeqCtl = %d, bitmap = 0x%llx, scd_flow = %d, scd_ssn = %d sent:%d, acked:%d\n",
            (int )ba_resp->tid, (int )ba_resp->seq_ctl, ba_resp->bitmap, (int )scd_flow,
            (int )ba_resp_scd_ssn, (int )ba_resp->txed, (int )ba_resp->txed_2_done);
  agg->wait_for_ba = 0;
  if ((int )ba_resp->txed_2_done > (int )ba_resp->txed) {
    __iwl_dbg(priv->dev, 1073741824U, 0, "iwlagn_rx_reply_compressed_ba", "bogus sent(%d) and ack(%d) count\n",
              (int )ba_resp->txed, (int )ba_resp->txed_2_done);
    ba_resp->txed = ba_resp->txed_2_done;
  } else {

  }
  priv->tid_data[sta_id][tid].next_reclaimed = ba_resp_scd_ssn;
  iwlagn_check_ratid_empty(priv, sta_id, (int )((u8 )tid));
  freed = 0;
  skb = reclaimed_skbs.next;
  goto ldv_55368;
  ldv_55367: 
  hdr = (struct ieee80211_hdr *)skb->data;
  tmp___3 = IEEE80211_SKB_CB(skb);
  info = tmp___3;
  tmp___7 = ieee80211_is_data_qos((int )hdr->frame_control);
  if (tmp___7 != 0) {
    freed = freed + 1;
  } else {
    __ret_warn_once = 1;
    tmp___6 = ldv__builtin_expect(__ret_warn_once != 0, 0L);
    if (tmp___6 != 0L) {
      __ret_warn_on = ! __warned;
      tmp___4 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
      if (tmp___4 != 0L) {
        warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/08_1a/drivers/net/wireless/iwlwifi/dvm/tx.c",
                           1386);
      } else {

      }
      tmp___5 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
      if (tmp___5 != 0L) {
        __warned = 1;
      } else {

      }
    } else {

    }
    ldv__builtin_expect(__ret_warn_once != 0, 0L);
  }
  iwl_trans_free_tx_cmd(priv->trans, (struct iwl_device_cmd *)info->__annonCompField99.driver_data[1]);
  memset((void *)(& info->__annonCompField99.status), 0, 40UL);
  info->flags = info->flags | 512U;
  if (freed == 1) {
    info = IEEE80211_SKB_CB(skb);
    memset((void *)(& info->__annonCompField99.status), 0, 40UL);
    info->flags = info->flags | 1024U;
    info->__annonCompField99.status.ampdu_ack_len = ba_resp->txed_2_done;
    info->__annonCompField99.status.ampdu_len = ba_resp->txed;
    iwlagn_hwrate_to_tx_control(priv, agg->rate_n_flags, info);
  } else {

  }
  skb = skb->__annonCompField68.__annonCompField67.next;
  ldv_55368: ;
  if ((unsigned long )((struct sk_buff *)(& reclaimed_skbs)) != (unsigned long )skb) {
    goto ldv_55367;
  } else {

  }
  spin_unlock_bh(& priv->sta_lock);
  goto ldv_55371;
  ldv_55370: 
  skb = __skb_dequeue(& reclaimed_skbs);
  ieee80211_tx_status(priv->hw, skb);
  ldv_55371: 
  tmp___8 = skb_queue_empty((struct sk_buff_head  const  *)(& reclaimed_skbs));
  if (tmp___8 == 0) {
    goto ldv_55370;
  } else {

  }

  return (0);
}
}
bool ldv_queue_work_on_91(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_7(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_delayed_work_on_92(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_7(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_work_on_93(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_7(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
void ldv_flush_workqueue_94(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
  flush_workqueue(ldv_func_arg1);
  call_and_disable_all_7(2);
  return;
}
}
bool ldv_queue_delayed_work_on_95(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_7(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
__inline static long ldv__builtin_expect(long exp , long c ) ;
bool ldv_queue_work_on_105(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_work_on_107(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_delayed_work_on_106(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
bool ldv_queue_delayed_work_on_109(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
void ldv_flush_workqueue_108(struct workqueue_struct *ldv_func_arg1 ) ;
bool ldv_cancel_work_sync_110(struct work_struct *ldv_func_arg1 ) ;
__inline static bool queue_work___3(struct workqueue_struct *wq , struct work_struct *work ) 
{ 
  bool tmp ;

  {
  tmp = ldv_queue_work_on_105(8192, wq, work);
  return (tmp);
}
}
void call_and_disable_work_7(struct work_struct *work ) ;
void invoke_work_7(void) ;
extern void ieee80211_get_tkip_p1k_iv(struct ieee80211_key_conf * , u32  , u16 * ) ;
extern void ieee80211_get_tkip_rx_p1k(struct ieee80211_key_conf * , u8 const   * ,
                                      u32  , u16 * ) ;
extern void ieee80211_get_key_tx_seq(struct ieee80211_key_conf * , struct ieee80211_key_seq * ) ;
extern void ieee80211_get_key_rx_seq(struct ieee80211_key_conf * , int  , struct ieee80211_key_seq * ) ;
extern void ieee80211_iter_keys(struct ieee80211_hw * , struct ieee80211_vif * , void (*)(struct ieee80211_hw * ,
                                                                                          struct ieee80211_vif * ,
                                                                                          struct ieee80211_sta * ,
                                                                                          struct ieee80211_key_conf * ,
                                                                                          void * ) ,
                                void * ) ;
extern void ieee80211_request_smps(struct ieee80211_vif * , enum ieee80211_smps_mode  ) ;
extern void ieee80211_enable_rssi_reports(struct ieee80211_vif * , int  , int  ) ;
extern void ieee80211_disable_rssi_reports(struct ieee80211_vif * ) ;
extern int ieee80211_ave_rssi(struct ieee80211_vif * ) ;
__inline static int iwl_trans_send_cmd(struct iwl_trans *trans , struct iwl_host_cmd *cmd ) 
{ 
  int ret ;
  int tmp ;
  int tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;

  {
  if ((cmd->flags & 4U) == 0U) {
    tmp = constant_test_bit(4L, (unsigned long const volatile   *)(& trans->status));
    if (tmp != 0) {
      tmp___0 = 1;
    } else {
      tmp___0 = 0;
    }
  } else {
    tmp___0 = 0;
  }
  tmp___1 = ldv__builtin_expect((long )tmp___0, 0L);
  if (tmp___1 != 0L) {
    return (-132);
  } else {

  }
  tmp___2 = constant_test_bit(5L, (unsigned long const volatile   *)(& trans->status));
  tmp___3 = ldv__builtin_expect(tmp___2 != 0, 0L);
  if (tmp___3 != 0L) {
    return (-5);
  } else {

  }
  tmp___4 = ldv__builtin_expect((unsigned int )trans->state != 1U, 0L);
  if (tmp___4 != 0L) {
    __iwl_err(trans->dev, 0, 0, "%s bad state = %d\n", "iwl_trans_send_cmd", (unsigned int )trans->state);
    return (-5);
  } else {

  }
  if ((cmd->flags & 1U) == 0U) {
    lock_acquire(& trans->sync_cmd_lockdep_map, 0U, 0, 2, 1, (struct lockdep_map *)0,
                 0UL);
  } else {

  }
  ret = (*((trans->ops)->send_cmd))(trans, cmd);
  if ((cmd->flags & 1U) == 0U) {
    lock_release(& trans->sync_cmd_lockdep_map, 1, 0UL);
  } else {

  }
  return (ret);
}
}
void iwl_tt_handler(struct iwl_priv *priv ) ;
__inline static int iwl_is_associated(struct iwl_priv *priv , enum iwl_rxon_context_id ctxid ) 
{ 
  int tmp ;

  {
  tmp = iwl_is_associated_ctx((struct iwl_rxon_context *)(& priv->contexts) + (unsigned long )ctxid);
  return (tmp);
}
}
int iwlagn_send_tx_power(struct iwl_priv *priv ) ;
void iwlagn_temperature(struct iwl_priv *priv ) ;
int iwlagn_send_patterns(struct iwl_priv *priv , struct cfg80211_wowlan *wowlan ) ;
int iwlagn_bt_coex_profile_notif(struct iwl_priv *priv , struct iwl_rx_cmd_buffer *rxb ,
                                 struct iwl_device_cmd *cmd ) ;
void iwlagn_bt_rx_handler_setup(struct iwl_priv *priv ) ;
void iwlagn_bt_coex_rssi_monitor(struct iwl_priv *priv ) ;
void iwlagn_bt_adjust_rssi_monitor(struct iwl_priv *priv , bool rssi_ena ) ;
int iwlagn_manage_ibss_station(struct iwl_priv *priv , struct ieee80211_vif *vif ,
                               bool add ) ;
int iwlagn_add_bssid_station(struct iwl_priv *priv , struct iwl_rxon_context *ctx ,
                             u8 const   *addr , u8 *sta_id_r ) ;
__inline static int iwl_is_ctkill(struct iwl_priv *priv ) 
{ 
  int tmp ;

  {
  tmp = constant_test_bit(1L, (unsigned long const volatile   *)(& priv->status));
  return (tmp);
}
}
__inline static char const   *iwl_dvm_get_cmd_string(u8 cmd ) 
{ 
  char const   *s ;

  {
  s = iwl_dvm_cmd_strings[(int )cmd];
  if ((unsigned long )s != (unsigned long )((char const   *)0)) {
    return (s);
  } else {

  }
  return ("UNKNOWN");
}
}
int iwlagn_hw_valid_rtc_data_addr(u32 addr ) 
{ 


  {
  return (addr > 8388607U && addr <= 8437759U);
}
}
int iwlagn_send_tx_power(struct iwl_priv *priv ) 
{ 
  struct iwlagn_tx_power_dbm_cmd tx_power_cmd ;
  u8 tx_ant_cfg_cmd ;
  bool __warned ;
  int __ret_warn_once ;
  int tmp ;
  int __ret_warn_on ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  int tmp___4 ;

  {
  tmp = constant_test_bit(9L, (unsigned long const volatile   *)(& priv->status));
  __ret_warn_once = tmp != 0;
  tmp___2 = ldv__builtin_expect(__ret_warn_once != 0, 0L);
  if (tmp___2 != 0L) {
    __ret_warn_on = ! __warned;
    tmp___0 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
    if (tmp___0 != 0L) {
      warn_slowpath_fmt("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/08_1a/drivers/net/wireless/iwlwifi/dvm/lib.c",
                        55, "TX Power requested while scanning!\n");
    } else {

    }
    tmp___1 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
    if (tmp___1 != 0L) {
      __warned = 1;
    } else {

    }
  } else {

  }
  tmp___3 = ldv__builtin_expect(__ret_warn_once != 0, 0L);
  if (tmp___3 != 0L) {
    return (-11);
  } else {

  }
  tx_power_cmd.global_lmt = (signed char )((unsigned int )((unsigned char )priv->tx_power_user_lmt) * 2U);
  if ((int )tx_power_cmd.global_lmt > (int )(priv->nvm_data)->max_tx_pwr_half_dbm) {
    tx_power_cmd.global_lmt = (priv->nvm_data)->max_tx_pwr_half_dbm;
  } else {

  }
  tx_power_cmd.flags = 64U;
  tx_power_cmd.srv_chan_lmt = 127;
  if (((unsigned int )(priv->fw)->ucode_ver & 65280U) >> 8 == 1U) {
    tx_ant_cfg_cmd = 152U;
  } else {
    tx_ant_cfg_cmd = 149U;
  }
  tmp___4 = iwl_dvm_send_cmd_pdu(priv, (int )tx_ant_cfg_cmd, 0U, 4, (void const   *)(& tx_power_cmd));
  return (tmp___4);
}
}
void iwlagn_temperature(struct iwl_priv *priv ) 
{ 
  int __ret_warn_on ;
  int tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
  if (debug_locks != 0) {
    tmp = lock_is_held(& priv->statistics.lock.__annonCompField18.__annonCompField17.dep_map);
    if (tmp == 0) {
      tmp___0 = 1;
    } else {
      tmp___0 = 0;
    }
  } else {
    tmp___0 = 0;
  }
  __ret_warn_on = tmp___0;
  tmp___1 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp___1 != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/08_1a/drivers/net/wireless/iwlwifi/dvm/lib.c",
                       90);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  priv->temperature = (s32 )priv->statistics.common.temperature;
  iwl_tt_handler(priv);
  return;
}
}
int iwlagn_hwrate_to_mac80211_idx(u32 rate_n_flags , enum ieee80211_band band ) 
{ 
  int idx ;
  int band_offset ;
    klee_make_symbolic(&band_offset, sizeof(int), "band_offset");

  {
  idx = 0;
  band_offset = 0;
  if ((rate_n_flags & 256U) != 0U) {
    idx = (int )rate_n_flags & 255;
    return (idx);
  } else {
    if ((unsigned int )band == 1U) {
      band_offset = 4;
    } else {

    }
    idx = band_offset;
    goto ldv_55172;
    ldv_55171: ;
    if ((u32 )iwl_rates[idx].plcp == (rate_n_flags & 255U)) {
      return (idx - band_offset);
    } else {

    }
    idx = idx + 1;
    ldv_55172: ;
    if (idx <= 11) {
      goto ldv_55171;
    } else {

    }

  }
  return (-1);
}
}
int iwlagn_manage_ibss_station(struct iwl_priv *priv , struct ieee80211_vif *vif ,
                               bool add ) 
{ 
  struct iwl_vif_priv *vif_priv ;
  int tmp ;
  int tmp___0 ;

  {
  vif_priv = (struct iwl_vif_priv *)(& vif->drv_priv);
  if ((int )add) {
    tmp = iwlagn_add_bssid_station(priv, vif_priv->ctx, vif->bss_conf.bssid, & vif_priv->ibss_bssid_sta_id);
    return (tmp);
  } else {

  }
  tmp___0 = iwl_remove_station(priv, (int )vif_priv->ibss_bssid_sta_id, vif->bss_conf.bssid);
  return (tmp___0);
}
}
int iwlagn_txfifo_flush(struct iwl_priv *priv , u32 scd_q_msk ) 
{ 
  struct iwl_txfifo_flush_cmd_v3 flush_cmd_v3 ;
  struct iwl_txfifo_flush_cmd_v2 flush_cmd_v2 ;
  u32 queue_control ;
  int tmp ;
  int tmp___0 ;

  {
  flush_cmd_v3.queue_control = 0U;
  flush_cmd_v3.flush_control = 2U;
  flush_cmd_v3.reserved = (unsigned short)0;
  flush_cmd_v2.queue_control = (unsigned short)0;
  flush_cmd_v2.flush_control = 2U;
  queue_control = 15U;
  if ((unsigned int )priv->valid_contexts != 1U) {
    queue_control = queue_control | 496U;
  } else {

  }
  if ((int )(priv->nvm_data)->sku_cap_11n_enable) {
    queue_control = queue_control | 1047552U;
  } else {

  }
  if (scd_q_msk != 0U) {
    queue_control = scd_q_msk;
  } else {

  }
  __iwl_dbg(priv->dev, 1U, 0, "iwlagn_txfifo_flush", "queue control: 0x%x\n", queue_control);
  flush_cmd_v3.queue_control = queue_control;
  flush_cmd_v2.queue_control = (unsigned short )queue_control;
  if (((unsigned int )(priv->fw)->ucode_ver & 65280U) >> 8 > 2U) {
    tmp = iwl_dvm_send_cmd_pdu(priv, 30, 0U, 8, (void const   *)(& flush_cmd_v3));
    return (tmp);
  } else {

  }
  tmp___0 = iwl_dvm_send_cmd_pdu(priv, 30, 0U, 4, (void const   *)(& flush_cmd_v2));
  return (tmp___0);
}
}
void iwlagn_dev_txfifo_flush(struct iwl_priv *priv ) 
{ 
  int tmp ;

  {
  mutex_lock_nested(& priv->mutex, 0U);
  ieee80211_stop_queues(priv->hw);
  tmp = iwlagn_txfifo_flush(priv, 0U);
  if (tmp != 0) {
    __iwl_err(priv->dev, 0, 0, "flush request fail\n");
    goto done;
  } else {

  }
  __iwl_dbg(priv->dev, 1U, 0, "iwlagn_dev_txfifo_flush", "wait transmit/flush all frames\n");
  iwl_trans_wait_tx_queue_empty(priv->trans, 4294967295U);
  done: 
  ieee80211_wake_queues(priv->hw);
  mutex_unlock(& priv->mutex);
  return;
}
}
static __le32 const   iwlagn_def_3w_lookup[12U]  = 
  {      2863311530U,      2863311530U,      2930420394U,      2863311530U, 
        3422617384U,      43690U,      3422595754U,      43690U, 
        3221241856U,      16384U,      4026552320U,      4026552320U};
static __le32 const   iwlagn_concurrent_lookup[12U]  = 
  {      2863311530U,      2863311530U,      2863311530U,      2863311530U, 
        2863311530U,      2863311530U,      2863311530U,      2863311530U, 
        0U,      0U,      0U,      0U};
void iwlagn_send_advance_bt_config(struct iwl_priv *priv ) 
{ 
  struct iwl_basic_bt_cmd basic ;
  struct iwl_bt_cmd_v1 bt_cmd_v1 ;
  struct iwl_bt_cmd_v2 bt_cmd_v2 ;
  int ret ;
  int __ret_warn_on ;
  long tmp ;

  {
  basic.flags = (unsigned char)0;
  basic.ledtime = (unsigned char)0;
  basic.max_kill = 5U;
  basic.bt3_timer_t7_value = 1U;
  basic.kill_ack_mask = 0U;
  basic.kill_cts_mask = 0U;
  basic.bt3_prio_sample_time = 2U;
  basic.bt3_timer_t2_value = 12U;
  basic.bt4_reaction_time = (unsigned short)0;
  basic.bt3_lookup_table[0] = 0U;
  basic.bt3_lookup_table[1] = 0U;
  basic.bt3_lookup_table[2] = 0U;
  basic.bt3_lookup_table[3] = 0U;
  basic.bt3_lookup_table[4] = 0U;
  basic.bt3_lookup_table[5] = 0U;
  basic.bt3_lookup_table[6] = 0U;
  basic.bt3_lookup_table[7] = 0U;
  basic.bt3_lookup_table[8] = 0U;
  basic.bt3_lookup_table[9] = 0U;
  basic.bt3_lookup_table[10] = 0U;
  basic.bt3_lookup_table[11] = 0U;
  basic.reduce_txpower = (unsigned char)0;
  basic.reserved = (unsigned char)0;
  basic.valid = (unsigned short)0;
  if ((unsigned long )(priv->lib)->bt_params != (unsigned long )((struct iwl_dvm_bt_params  const  */* const  */)0)) {
    if ((int )((priv->lib)->bt_params)->bt_session_2) {
      bt_cmd_v2.prio_boost = ((priv->lib)->bt_params)->bt_prio_boost;
      bt_cmd_v2.tx_prio_boost = 0U;
      bt_cmd_v2.rx_prio_boost = 0U;
    } else {
      __ret_warn_on = ((unsigned int )((priv->lib)->bt_params)->bt_prio_boost & 4294967040U) != 0U;
      tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
      if (tmp != 0L) {
        warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/08_1a/drivers/net/wireless/iwlwifi/dvm/lib.c",
                           270);
      } else {

      }
      ldv__builtin_expect(__ret_warn_on != 0, 0L);
      bt_cmd_v1.prio_boost = (u8 )((priv->lib)->bt_params)->bt_prio_boost;
      bt_cmd_v1.tx_prio_boost = 0U;
      bt_cmd_v1.rx_prio_boost = 0U;
    }
  } else {
    __iwl_err(priv->dev, 0, 0, "failed to construct BT Coex Config\n");
    return;
  }
  basic.kill_ack_mask = priv->kill_ack_mask;
  basic.kill_cts_mask = priv->kill_cts_mask;
  if ((int )priv->reduced_txpower) {
    basic.reduce_txpower = 1U;
  } else {

  }
  basic.valid = priv->bt_valid;
  if (! iwlwifi_mod_params.bt_coex_active || (unsigned int )priv->iw_mode == 1U) {
    basic.flags = 0U;
  } else {
    basic.flags = 16U;
    if (! priv->bt_enable_pspoll) {
      basic.flags = (u8 )((unsigned int )basic.flags | 128U);
    } else {
      basic.flags = (unsigned int )basic.flags & 127U;
    }
    if ((int )priv->bt_ch_announce) {
      basic.flags = (u8 )((unsigned int )basic.flags | 1U);
    } else {

    }
    __iwl_dbg(priv->dev, 32768U, 0, "iwlagn_send_advance_bt_config", "BT coex flag: 0X%x\n",
              (int )basic.flags);
  }
  priv->bt_enable_flag = basic.flags;
  if ((int )priv->bt_full_concurrent) {
    memcpy((void *)(& basic.bt3_lookup_table), (void const   *)(& iwlagn_concurrent_lookup),
             48UL);
  } else {
    memcpy((void *)(& basic.bt3_lookup_table), (void const   *)(& iwlagn_def_3w_lookup),
             48UL);
  }
  __iwl_dbg(priv->dev, 32768U, 0, "iwlagn_send_advance_bt_config", "BT coex %s in %s mode\n",
            (unsigned int )basic.flags != 0U ? (char *)"active" : (char *)"disabled",
            (int )priv->bt_full_concurrent ? (char *)"full concurrency" : (char *)"3-wire");
  if ((int )((priv->lib)->bt_params)->bt_session_2) {
    memcpy((void *)(& bt_cmd_v2.basic), (void const   *)(& basic), 68UL);
    ret = iwl_dvm_send_cmd_pdu(priv, 155, 0U, 76, (void const   *)(& bt_cmd_v2));
  } else {
    memcpy((void *)(& bt_cmd_v1.basic), (void const   *)(& basic), 68UL);
    ret = iwl_dvm_send_cmd_pdu(priv, 155, 0U, 72, (void const   *)(& bt_cmd_v1));
  }
  if (ret != 0) {
    __iwl_err(priv->dev, 0, 0, "failed to send BT Coex Config\n");
  } else {

  }
  return;
}
}
void iwlagn_bt_adjust_rssi_monitor(struct iwl_priv *priv , bool rssi_ena ) 
{ 
  struct iwl_rxon_context *ctx ;
  struct iwl_rxon_context *found_ctx ;
  bool found_ap ;
  int __ret_warn_on ;
  int tmp ;
  int tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  found_ctx = (struct iwl_rxon_context *)0;
  found_ap = 0;
  if (debug_locks != 0) {
    tmp = lock_is_held(& priv->mutex.dep_map);
    if (tmp == 0) {
      tmp___0 = 1;
    } else {
      tmp___0 = 0;
    }
  } else {
    tmp___0 = 0;
  }
  __ret_warn_on = tmp___0;
  tmp___1 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp___1 != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/08_1a/drivers/net/wireless/iwlwifi/dvm/lib.c",
                       353);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if ((int )rssi_ena) {
    ctx = (struct iwl_rxon_context *)(& priv->contexts);
    goto ldv_55217;
    ldv_55216: ;
    if ((int )((unsigned long )priv->valid_contexts >> (int )ctx->ctxid) & 1) {
      if ((unsigned long )ctx->vif != (unsigned long )((struct ieee80211_vif *)0) && (unsigned int )(ctx->vif)->type == 3U) {
        tmp___2 = iwl_is_associated_ctx(ctx);
        if (tmp___2 != 0) {
          found_ap = 1;
          goto ldv_55215;
        } else {

        }
      } else {

      }
    } else {

    }
    ctx = ctx + 1;
    ldv_55217: ;
    if ((unsigned long )((struct iwl_rxon_context *)(& priv->contexts) + 2UL) > (unsigned long )ctx) {
      goto ldv_55216;
    } else {

    }
    ldv_55215: ;
  } else {

  }
  if (! rssi_ena || (int )found_ap) {
    if ((unsigned long )priv->cur_rssi_ctx != (unsigned long )((struct iwl_rxon_context *)0)) {
      ctx = priv->cur_rssi_ctx;
      ieee80211_disable_rssi_reports(ctx->vif);
      priv->cur_rssi_ctx = (struct iwl_rxon_context *)0;
    } else {

    }
    return;
  } else {

  }
  ctx = (struct iwl_rxon_context *)(& priv->contexts);
  goto ldv_55220;
  ldv_55219: ;
  if ((int )((unsigned long )priv->valid_contexts >> (int )ctx->ctxid) & 1) {
    if ((unsigned long )ctx->vif != (unsigned long )((struct ieee80211_vif *)0) && (unsigned int )(ctx->vif)->type == 2U) {
      tmp___3 = iwl_is_associated_ctx(ctx);
      if (tmp___3 != 0) {
        found_ctx = ctx;
        goto ldv_55218;
      } else {

      }
    } else {

    }
  } else {

  }
  ctx = ctx + 1;
  ldv_55220: ;
  if ((unsigned long )((struct iwl_rxon_context *)(& priv->contexts) + 2UL) > (unsigned long )ctx) {
    goto ldv_55219;
  } else {

  }
  ldv_55218: ;
  if ((unsigned long )priv->cur_rssi_ctx == (unsigned long )found_ctx) {
    return;
  } else {

  }
  if ((unsigned long )priv->cur_rssi_ctx != (unsigned long )((struct iwl_rxon_context *)0)) {
    ctx = priv->cur_rssi_ctx;
    if ((unsigned long )ctx->vif != (unsigned long )((struct ieee80211_vif *)0)) {
      ieee80211_disable_rssi_reports(ctx->vif);
    } else {

    }
  } else {

  }
  priv->cur_rssi_ctx = found_ctx;
  if ((unsigned long )found_ctx == (unsigned long )((struct iwl_rxon_context *)0)) {
    return;
  } else {

  }
  ieee80211_enable_rssi_reports(found_ctx->vif, -75, -65);
  return;
}
}
static bool iwlagn_bt_traffic_is_sco(struct iwl_bt_uart_msg *uart_msg ) 
{ 


  {
  return (((int )uart_msg->frame3 & 1) != 0);
}
}
static void iwlagn_bt_traffic_change_work(struct work_struct *work ) 
{ 
  struct iwl_priv *priv ;
  struct work_struct  const  *__mptr ;
  struct iwl_rxon_context *ctx ;
  int smps_request ;
    klee_make_symbolic(&smps_request, sizeof(int), "smps_request");
  int tmp ;

  {
  __mptr = (struct work_struct  const  *)work;
  priv = (struct iwl_priv *)__mptr + 0xffffffffffffd198UL;
  smps_request = -1;
  if ((unsigned int )priv->bt_enable_flag == 0U) {
    return;
  } else {

  }
  __iwl_dbg(priv->dev, 32768U, 0, "iwlagn_bt_traffic_change_work", "BT traffic load changes: %d\n",
            (int )priv->bt_traffic_load);
  switch ((int )priv->bt_traffic_load) {
  case 0: ;
  if ((unsigned int )priv->bt_status != 0U) {
    smps_request = 3;
  } else {
    smps_request = 0;
  }
  goto ldv_55234;
  case 1: 
  smps_request = 3;
  goto ldv_55234;
  case 2: ;
  case 3: 
  smps_request = 2;
  goto ldv_55234;
  default: 
  __iwl_err(priv->dev, 0, 0, "Invalid BT traffic load: %d\n", (int )priv->bt_traffic_load);
  goto ldv_55234;
  }
  ldv_55234: 
  mutex_lock_nested(& priv->mutex, 0U);
  tmp = constant_test_bit(9L, (unsigned long const volatile   *)(& priv->status));
  if (tmp != 0) {
    goto out;
  } else {

  }
  iwl_update_chain_flags(priv);
  if (smps_request != -1) {
    priv->current_ht_config.smps = (enum ieee80211_smps_mode )smps_request;
    ctx = (struct iwl_rxon_context *)(& priv->contexts);
    goto ldv_55241;
    ldv_55240: ;
    if ((int )((unsigned long )priv->valid_contexts >> (int )ctx->ctxid) & 1) {
      if ((unsigned long )ctx->vif != (unsigned long )((struct ieee80211_vif *)0) && (unsigned int )(ctx->vif)->type == 2U) {
        ieee80211_request_smps(ctx->vif, (enum ieee80211_smps_mode )smps_request);
      } else {

      }
    } else {

    }
    ctx = ctx + 1;
    ldv_55241: ;
    if ((unsigned long )((struct iwl_rxon_context *)(& priv->contexts) + 2UL) > (unsigned long )ctx) {
      goto ldv_55240;
    } else {

    }

  } else {

  }
  iwlagn_bt_coex_rssi_monitor(priv);
  out: 
  mutex_unlock(& priv->mutex);
  return;
}
}
void iwlagn_bt_coex_rssi_monitor(struct iwl_priv *priv ) 
{ 


  {
  if ((int )priv->bt_is_sco && (unsigned int )priv->bt_traffic_load == 3U) {
    iwlagn_bt_adjust_rssi_monitor(priv, 1);
  } else {
    iwlagn_bt_adjust_rssi_monitor(priv, 0);
  }
  return;
}
}
static void iwlagn_print_uartmsg(struct iwl_priv *priv , struct iwl_bt_uart_msg *uart_msg ) 
{ 


  {
  __iwl_dbg(priv->dev, 32768U, 0, "iwlagn_print_uartmsg", "Message Type = 0x%X, SSN = 0x%X, Update Req = 0x%X\n",
            (int )uart_msg->frame1 & 7, (int )(((unsigned int )uart_msg->frame1 & 24U) >> 3),
            (int )(((unsigned int )uart_msg->frame1 & 32U) >> 5));
  __iwl_dbg(priv->dev, 32768U, 0, "iwlagn_print_uartmsg", "Open connections = 0x%X, Traffic load = 0x%X, Chl_SeqN = 0x%X, In band = 0x%X\n",
            (int )uart_msg->frame2 & 3, (int )(((unsigned int )uart_msg->frame2 & 12U) >> 2),
            (int )(((unsigned int )uart_msg->frame2 & 16U) >> 4), (int )(((unsigned int )uart_msg->frame2 & 32U) >> 5));
  __iwl_dbg(priv->dev, 32768U, 0, "iwlagn_print_uartmsg", "SCO/eSCO = 0x%X, Sniff = 0x%X, A2DP = 0x%X, ACL = 0x%X, Master = 0x%X, OBEX = 0x%X\n",
            (int )uart_msg->frame3 & 1, (int )(((unsigned int )uart_msg->frame3 & 2U) >> 1),
            (int )(((unsigned int )uart_msg->frame3 & 4U) >> 2), (int )(((unsigned int )uart_msg->frame3 & 8U) >> 3),
            (int )(((unsigned int )uart_msg->frame3 & 16U) >> 4), (int )(((unsigned int )uart_msg->frame3 & 32U) >> 5));
  __iwl_dbg(priv->dev, 32768U, 0, "iwlagn_print_uartmsg", "Idle duration = 0x%X\n",
            (int )uart_msg->frame4 & 63);
  __iwl_dbg(priv->dev, 32768U, 0, "iwlagn_print_uartmsg", "Tx Activity = 0x%X, Rx Activity = 0x%X, eSCO Retransmissions = 0x%X\n",
            (int )uart_msg->frame5 & 3, (int )(((unsigned int )uart_msg->frame5 & 12U) >> 2),
            (int )(((unsigned int )uart_msg->frame5 & 48U) >> 4));
  __iwl_dbg(priv->dev, 32768U, 0, "iwlagn_print_uartmsg", "Sniff Interval = 0x%X, Discoverable = 0x%X\n",
            (int )uart_msg->frame6 & 31, (int )(((unsigned int )uart_msg->frame6 & 32U) >> 5));
  __iwl_dbg(priv->dev, 32768U, 0, "iwlagn_print_uartmsg", "Sniff Activity = 0x%X, Page = 0x%X, Inquiry = 0x%X, Connectable = 0x%X\n",
            (int )uart_msg->frame7 & 7, (int )(((unsigned int )uart_msg->frame7 & 8U) >> 3),
            (int )(((unsigned int )uart_msg->frame7 & 16U) >> 4), (int )(((unsigned int )uart_msg->frame7 & 32U) >> 5));
  return;
}
}
static bool iwlagn_set_kill_msk(struct iwl_priv *priv , struct iwl_bt_uart_msg *uart_msg ) 
{ 
  bool need_update ;
  u8 kill_msk ;
  __le32 bt_kill_ack_msg[3U] ;
  __le32 bt_kill_cts_msg[3U] ;

  {
  need_update = 0;
  kill_msk = 2U;
  bt_kill_ack_msg[0] = 4294901760U;
  bt_kill_ack_msg[1] = 4294967295U;
  bt_kill_ack_msg[2] = 0U;
  bt_kill_cts_msg[0] = 4294901760U;
  bt_kill_cts_msg[1] = 4294967295U;
  bt_kill_cts_msg[2] = 0U;
  if (! priv->reduced_txpower) {
    kill_msk = (unsigned int )uart_msg->frame3 & 1U;
  } else {

  }
  if (priv->kill_ack_mask != bt_kill_ack_msg[(int )kill_msk] || priv->kill_cts_mask != bt_kill_cts_msg[(int )kill_msk]) {
    priv->bt_valid = (__le16 )((unsigned int )priv->bt_valid | 16U);
    priv->kill_ack_mask = bt_kill_ack_msg[(int )kill_msk];
    priv->bt_valid = (__le16 )((unsigned int )priv->bt_valid | 32U);
    priv->kill_cts_mask = bt_kill_cts_msg[(int )kill_msk];
    need_update = 1;
  } else {

  }
  return (need_update);
}
}
static bool iwlagn_fill_txpower_mode(struct iwl_priv *priv , struct iwl_bt_uart_msg *uart_msg ) 
{ 
  bool need_update ;
  struct iwl_rxon_context *ctx ;
  int ave_rssi ;
    klee_make_symbolic(&ave_rssi, sizeof(int), "ave_rssi");
  int tmp ;
  int tmp___0 ;

  {
  need_update = 0;
  ctx = (struct iwl_rxon_context *)(& priv->contexts);
  if ((unsigned long )ctx->vif == (unsigned long )((struct ieee80211_vif *)0) || (unsigned int )(ctx->vif)->type != 2U) {
    __iwl_dbg(priv->dev, 1U, 0, "iwlagn_fill_txpower_mode", "BSS ctx not active or not in sta mode\n");
    return (0);
  } else {

  }
  ave_rssi = ieee80211_ave_rssi(ctx->vif);
  if (ave_rssi == 0) {
    __iwl_dbg(priv->dev, 32768U, 0, "iwlagn_fill_txpower_mode", "no rssi data available\n");
    return (need_update);
  } else {

  }
  if (! priv->reduced_txpower) {
    tmp___0 = iwl_is_associated(priv, 1);
    if (tmp___0 == 0) {
      if (ave_rssi >= -61) {
        if (((int )uart_msg->frame3 & 40) != 0) {
          if (((int )uart_msg->frame3 & 7) == 0) {
            priv->reduced_txpower = 1;
            priv->bt_valid = (__le16 )((unsigned int )priv->bt_valid | 64U);
            need_update = 1;
          } else {
            goto _L___2;
          }
        } else {
          goto _L___2;
        }
      } else {
        goto _L___2;
      }
    } else {
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */ 
  if ((int )priv->reduced_txpower) {
    tmp = iwl_is_associated(priv, 1);
    if (((tmp != 0 || ave_rssi < -65) || ((int )uart_msg->frame3 & 7) != 0) || ((int )uart_msg->frame3 & 40) == 0) {
      priv->reduced_txpower = 0;
      priv->bt_valid = (__le16 )((unsigned int )priv->bt_valid | 64U);
      need_update = 1;
    } else {

    }
  } else {

  }
  return (need_update);
}
}
int iwlagn_bt_coex_profile_notif(struct iwl_priv *priv , struct iwl_rx_cmd_buffer *rxb ,
                                 struct iwl_device_cmd *cmd ) 
{ 
  struct iwl_rx_packet *pkt ;
  void *tmp ;
  struct iwl_bt_coex_profile_notif *coex ;
  struct iwl_bt_uart_msg *uart_msg ;
  bool tmp___0 ;
  bool tmp___1 ;

  {
  tmp = rxb_addr(rxb);
  pkt = (struct iwl_rx_packet *)tmp;
  coex = (struct iwl_bt_coex_profile_notif *)(& pkt->data);
  uart_msg = & coex->last_bt_uart_msg;
  if ((unsigned int )priv->bt_enable_flag == 0U) {
    return (0);
  } else {

  }
  __iwl_dbg(priv->dev, 32768U, 0, "iwlagn_bt_coex_profile_notif", "BT Coex notification:\n");
  __iwl_dbg(priv->dev, 32768U, 0, "iwlagn_bt_coex_profile_notif", "    status: %d\n",
            (int )coex->bt_status);
  __iwl_dbg(priv->dev, 32768U, 0, "iwlagn_bt_coex_profile_notif", "    traffic load: %d\n",
            (int )coex->bt_traffic_load);
  __iwl_dbg(priv->dev, 32768U, 0, "iwlagn_bt_coex_profile_notif", "    CI compliance: %d\n",
            (int )coex->bt_ci_compliance);
  iwlagn_print_uartmsg(priv, uart_msg);
  priv->last_bt_traffic_load = priv->bt_traffic_load;
  priv->bt_is_sco = iwlagn_bt_traffic_is_sco(uart_msg);
  if ((unsigned int )priv->iw_mode != 1U) {
    if ((int )priv->bt_status != (int )coex->bt_status || (int )priv->last_bt_traffic_load != (int )coex->bt_traffic_load) {
      if ((unsigned int )coex->bt_status != 0U) {
        if (! priv->bt_ch_announce) {
          priv->bt_traffic_load = 2U;
        } else {
          priv->bt_traffic_load = coex->bt_traffic_load;
        }
      } else {
        priv->bt_traffic_load = 0U;
      }
      priv->bt_status = coex->bt_status;
      queue_work___3(priv->workqueue, & priv->bt_traffic_change_work);
    } else {

    }
  } else {

  }
  tmp___0 = iwlagn_fill_txpower_mode(priv, uart_msg);
  if ((int )tmp___0) {
    queue_work___3(priv->workqueue, & priv->bt_runtime_config);
  } else {
    tmp___1 = iwlagn_set_kill_msk(priv, uart_msg);
    if ((int )tmp___1) {
      queue_work___3(priv->workqueue, & priv->bt_runtime_config);
    } else {

    }
  }
  priv->bt_ci_compliance = coex->bt_ci_compliance;
  return (0);
}
}
void iwlagn_bt_rx_handler_setup(struct iwl_priv *priv ) 
{ 


  {
  priv->rx_handlers[206] = & iwlagn_bt_coex_profile_notif;
  return;
}
}
void iwlagn_bt_setup_deferred_work(struct iwl_priv *priv ) 
{ 
  struct lock_class_key __key ;
  atomic_long_t __constr_expr_0 ;

  {
  __init_work(& priv->bt_traffic_change_work, 0);
  __constr_expr_0.counter = 137438953408L;
  priv->bt_traffic_change_work.data = __constr_expr_0;
  lockdep_init_map(& priv->bt_traffic_change_work.lockdep_map, "(&priv->bt_traffic_change_work)",
                   & __key, 0);
  INIT_LIST_HEAD(& priv->bt_traffic_change_work.entry);
  priv->bt_traffic_change_work.func = & iwlagn_bt_traffic_change_work;
  return;
}
}
void iwlagn_bt_cancel_deferred_work(struct iwl_priv *priv ) 
{ 


  {
  ldv_cancel_work_sync_110(& priv->bt_traffic_change_work);
  return;
}
}
static bool is_single_rx_stream(struct iwl_priv *priv ) 
{ 


  {
  return ((bool )((unsigned int )priv->current_ht_config.smps == 2U || (int )priv->current_ht_config.single_chain_sufficient));
}
}
static int iwl_get_active_rx_chain_count(struct iwl_priv *priv ) 
{ 
  bool tmp ;

  {
  if (((unsigned long )(priv->lib)->bt_params != (unsigned long )((struct iwl_dvm_bt_params  const  */* const  */)0) && (int )((priv->lib)->bt_params)->advanced_bt_coexist) && ((int )priv->bt_full_concurrent || (unsigned int )priv->bt_traffic_load > 1U)) {
    return (2);
  } else {

  }
  tmp = is_single_rx_stream(priv);
  if ((int )tmp) {
    return (2);
  } else {
    return (3);
  }
}
}
static int iwl_get_idle_rx_chain_count(struct iwl_priv *priv , int active_cnt ) 
{ 
  int __ret_warn_on ;
  long tmp ;

  {
  switch ((unsigned int )priv->current_ht_config.smps) {
  case 2U: ;
  case 3U: ;
  return (1);
  case 0U: ;
  case 1U: ;
  return (active_cnt);
  default: 
  __ret_warn_on = 1;
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp != 0L) {
    warn_slowpath_fmt("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/08_1a/drivers/net/wireless/iwlwifi/dvm/lib.c",
                      793, "invalid SMPS mode %d", (unsigned int )priv->current_ht_config.smps);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  return (active_cnt);
  }
}
}
static u8 iwl_count_chain_bitmap(u32 chain_bitmap ) 
{ 
  u8 res ;

  {
  res = (unsigned int )((u8 )chain_bitmap) & 1U;
  res = (int )((u8 )(((unsigned long )chain_bitmap & 2UL) >> 1)) + (int )res;
  res = (int )((u8 )(((unsigned long )chain_bitmap & 4UL) >> 2)) + (int )res;
  res = (int )((u8 )(((unsigned long )chain_bitmap & 8UL) >> 3)) + (int )res;
  return (res);
}
}
void iwlagn_set_rxon_chain(struct iwl_priv *priv , struct iwl_rxon_context *ctx ) 
{ 
  bool is_single ;
  bool tmp ;
  bool is_cam ;
  int tmp___0 ;
  u8 idle_rx_cnt ;
  u8 active_rx_cnt ;
  u8 valid_rx_cnt ;
  u32 active_chains ;
  u16 rx_chain ;
  u8 tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int __ret_warn_on ;
  long tmp___4 ;

  {
  tmp = is_single_rx_stream(priv);
  is_single = tmp;
  tmp___0 = constant_test_bit(13L, (unsigned long const volatile   *)(& priv->status));
  is_cam = tmp___0 == 0;
  if (priv->chain_noise_data.active_chains != 0U) {
    active_chains = priv->chain_noise_data.active_chains;
  } else {
    active_chains = (u32 )(priv->nvm_data)->valid_rx_ant;
  }
  if (((unsigned long )(priv->lib)->bt_params != (unsigned long )((struct iwl_dvm_bt_params  const  */* const  */)0) && (int )((priv->lib)->bt_params)->advanced_bt_coexist) && ((int )priv->bt_full_concurrent || (unsigned int )priv->bt_traffic_load > 1U)) {
    tmp___1 = first_antenna((int )((u8 )active_chains));
    active_chains = (u32 )tmp___1;
  } else {

  }
  rx_chain = (int )((u16 )active_chains) << 1U;
  tmp___2 = iwl_get_active_rx_chain_count(priv);
  active_rx_cnt = (u8 )tmp___2;
  tmp___3 = iwl_get_idle_rx_chain_count(priv, (int )active_rx_cnt);
  idle_rx_cnt = (u8 )tmp___3;
  valid_rx_cnt = iwl_count_chain_bitmap(active_chains);
  if ((int )valid_rx_cnt < (int )active_rx_cnt) {
    active_rx_cnt = valid_rx_cnt;
  } else {

  }
  if ((int )valid_rx_cnt < (int )idle_rx_cnt) {
    idle_rx_cnt = valid_rx_cnt;
  } else {

  }
  rx_chain = (u16 )((int )((short )((int )active_rx_cnt << 12)) | (int )((short )rx_chain));
  rx_chain = (u16 )((int )((short )((int )idle_rx_cnt << 10)) | (int )((short )rx_chain));
  ctx->staging.rx_chain = rx_chain;
  if ((! is_single && (unsigned int )active_rx_cnt > 1U) && (int )is_cam) {
    ctx->staging.rx_chain = (__le16 )((unsigned int )ctx->staging.rx_chain | 16384U);
  } else {
    ctx->staging.rx_chain = (unsigned int )ctx->staging.rx_chain & 49151U;
  }
  __iwl_dbg(priv->dev, 4097U, 0, "iwlagn_set_rxon_chain", "rx_chain=0x%X active=%d idle=%d\n",
            (int )ctx->staging.rx_chain, (int )active_rx_cnt, (int )idle_rx_cnt);
  __ret_warn_on = ((unsigned int )active_rx_cnt == 0U || (unsigned int )idle_rx_cnt == 0U) || (int )active_rx_cnt < (int )idle_rx_cnt;
  tmp___4 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp___4 != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/08_1a/drivers/net/wireless/iwlwifi/dvm/lib.c",
                       875);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  return;
}
}
u8 iwl_toggle_tx_ant(struct iwl_priv *priv , u8 ant , u8 valid ) 
{ 
  int i ;
  u8 ind ;

  {
  ind = ant;
  if ((unsigned int )priv->band == 0U && (unsigned int )priv->bt_traffic_load > 1U) {
    return (0U);
  } else {

  }
  i = 0;
  goto ldv_55330;
  ldv_55329: 
  ind = (int )ind + 1 <= 2 ? (unsigned int )ind + 1U : 0U;
  if ((int )((unsigned long )valid >> (int )ind) & 1) {
    return (ind);
  } else {

  }
  i = i + 1;
  ldv_55330: ;
  if (i <= 1) {
    goto ldv_55329;
  } else {

  }

  return (ant);
}
}
static void iwlagn_convert_p1k(u16 *p1k , __le16 *out ) 
{ 
  int i ;

  {
  i = 0;
  goto ldv_55338;
  ldv_55337: 
  *(out + (unsigned long )i) = *(p1k + (unsigned long )i);
  i = i + 1;
  ldv_55338: ;
  if (i <= 4) {
    goto ldv_55337;
  } else {

  }

  return;
}
}
static void iwlagn_wowlan_program_keys(struct ieee80211_hw *hw , struct ieee80211_vif *vif ,
                                       struct ieee80211_sta *sta , struct ieee80211_key_conf *key ,
                                       void *_data___0 ) 
{ 
  struct iwl_priv *priv ;
  struct wowlan_key_data *data ;
  struct iwl_rxon_context *ctx ;
  struct aes_sc *aes_sc ;
  struct aes_sc *aes_tx_sc ;
  struct tkip_sc *tkip_sc ;
  struct tkip_sc *tkip_tx_sc ;
  struct iwlagn_p1k_cache *rx_p1ks ;
  u8 *rx_mic_key ;
  struct ieee80211_key_seq seq ;
  u32 cur_rx_iv32 ;
  u16 p1k[5U] ;
  int ret ;
  int i ;
  u8 *pn ;
  u8 *pn___0 ;

  {
  priv = (struct iwl_priv *)(& ((struct iwl_op_mode *)hw->priv)->op_mode_specific);
  data = (struct wowlan_key_data *)_data___0;
  ctx = data->ctx;
  aes_tx_sc = (struct aes_sc *)0;
  tkip_tx_sc = (struct tkip_sc *)0;
  cur_rx_iv32 = 0U;
  mutex_lock_nested(& priv->mutex, 0U);
  if (((key->cipher == 1027073U || key->cipher == 1027077U) && (unsigned long )sta == (unsigned long )((struct ieee80211_sta *)0)) && (unsigned int )ctx->key_mapping_keys == 0U) {
    ret = iwl_set_default_wep_key(priv, ctx, key);
  } else {
    ret = iwl_set_dynamic_key(priv, ctx, key, sta);
  }
  if (ret != 0) {
    __iwl_err(priv->dev, 0, 0, "Error setting key during suspend!\n");
    data->error = 1;
  } else {

  }
  switch (key->cipher) {
  case 1027074U: ;
  if ((unsigned long )sta != (unsigned long )((struct ieee80211_sta *)0)) {
    tkip_sc = (struct tkip_sc *)(& (data->rsc_tsc)->all_tsc_rsc.tkip.unicast_rsc);
    tkip_tx_sc = & (data->rsc_tsc)->all_tsc_rsc.tkip.tsc;
    rx_p1ks = (struct iwlagn_p1k_cache *)(& (data->tkip)->rx_uni);
    ieee80211_get_key_tx_seq(key, & seq);
    tkip_tx_sc->iv16 = seq.__annonCompField100.tkip.iv16;
    tkip_tx_sc->iv32 = seq.__annonCompField100.tkip.iv32;
    ieee80211_get_tkip_p1k_iv(key, seq.__annonCompField100.tkip.iv32, (u16 *)(& p1k));
    iwlagn_convert_p1k((u16 *)(& p1k), (__le16 *)(& (data->tkip)->tx.p1k));
    memcpy((void *)(& (data->tkip)->mic_keys.tx), (void const   *)(& key->key) + 16U,
             8UL);
    rx_mic_key = (u8 *)(& (data->tkip)->mic_keys.rx_unicast);
  } else {
    tkip_sc = (struct tkip_sc *)(& (data->rsc_tsc)->all_tsc_rsc.tkip.multicast_rsc);
    rx_p1ks = (struct iwlagn_p1k_cache *)(& (data->tkip)->rx_multi);
    rx_mic_key = (u8 *)(& (data->tkip)->mic_keys.rx_mcast);
  }
  i = 0;
  goto ldv_55371;
  ldv_55370: 
  ieee80211_get_key_rx_seq(key, i, & seq);
  (tkip_sc + (unsigned long )i)->iv16 = seq.__annonCompField100.tkip.iv16;
  (tkip_sc + (unsigned long )i)->iv32 = seq.__annonCompField100.tkip.iv32;
  if (seq.__annonCompField100.tkip.iv32 > cur_rx_iv32) {
    cur_rx_iv32 = seq.__annonCompField100.tkip.iv32;
  } else {

  }
  i = i + 1;
  ldv_55371: ;
  if (i <= 15) {
    goto ldv_55370;
  } else {

  }
  ieee80211_get_tkip_rx_p1k(key, data->bssid, cur_rx_iv32, (u16 *)(& p1k));
  iwlagn_convert_p1k((u16 *)(& p1k), (__le16 *)(& rx_p1ks->p1k));
  ieee80211_get_tkip_rx_p1k(key, data->bssid, cur_rx_iv32 + 1U, (u16 *)(& p1k));
  iwlagn_convert_p1k((u16 *)(& p1k), (__le16 *)(& (rx_p1ks + 1UL)->p1k));
  memcpy((void *)rx_mic_key, (void const   *)(& key->key) + 24U, 8UL);
  data->use_tkip = 1;
  data->use_rsc_tsc = 1;
  goto ldv_55373;
  case 1027076U: ;
  if ((unsigned long )sta != (unsigned long )((struct ieee80211_sta *)0)) {
    pn = (u8 *)(& seq.__annonCompField100.ccmp.pn);
    aes_sc = (struct aes_sc *)(& (data->rsc_tsc)->all_tsc_rsc.aes.unicast_rsc);
    aes_tx_sc = & (data->rsc_tsc)->all_tsc_rsc.aes.tsc;
    ieee80211_get_key_tx_seq(key, & seq);
    aes_tx_sc->pn = (((((unsigned long long )*(pn + 5UL) | ((unsigned long long )*(pn + 4UL) << 8)) | ((unsigned long long )*(pn + 3UL) << 16)) | ((unsigned long long )*(pn + 2UL) << 24)) | ((unsigned long long )*(pn + 1UL) << 32)) | ((unsigned long long )*pn << 40);
  } else {
    aes_sc = (struct aes_sc *)(& (data->rsc_tsc)->all_tsc_rsc.aes.multicast_rsc);
  }
  i = 0;
  goto ldv_55378;
  ldv_55377: 
  pn___0 = (u8 *)(& seq.__annonCompField100.ccmp.pn);
  ieee80211_get_key_rx_seq(key, i, & seq);
  aes_sc->pn = (((((unsigned long long )*(pn___0 + 5UL) | ((unsigned long long )*(pn___0 + 4UL) << 8)) | ((unsigned long long )*(pn___0 + 3UL) << 16)) | ((unsigned long long )*(pn___0 + 2UL) << 24)) | ((unsigned long long )*(pn___0 + 1UL) << 32)) | ((unsigned long long )*pn___0 << 40);
  i = i + 1;
  ldv_55378: ;
  if (i <= 15) {
    goto ldv_55377;
  } else {

  }
  data->use_rsc_tsc = 1;
  goto ldv_55373;
  }
  ldv_55373: 
  mutex_unlock(& priv->mutex);
  return;
}
}
int iwlagn_send_patterns(struct iwl_priv *priv , struct cfg80211_wowlan *wowlan ) 
{ 
  struct iwlagn_wowlan_patterns_cmd *pattern_cmd ;
  struct iwl_host_cmd cmd ;
  unsigned int tmp ;
  int i ;
  int err ;
  void *tmp___0 ;
  int mask_len ;
    klee_make_symbolic(&mask_len, sizeof(int), "mask_len");

  {
  cmd.data[0] = 0;
  cmd.data[1] = 0;
  cmd.resp_pkt = 0;
  cmd._rx_page_addr = 0UL;
  cmd._rx_page_order = 0U;
  cmd.handler_status = 0;
  cmd.flags = 0U;
  cmd.len[0] = (unsigned short)0;
  cmd.len[1] = (unsigned short)0;
  cmd.dataflags[0] = 1U;
  tmp = 1U;
  while (1) {
    if (tmp >= 2U) {
      break;
    } else {

    }
    cmd.dataflags[tmp] = (unsigned char)0;
    tmp = tmp + 1U;
  }
  cmd.id = 224U;
  if (wowlan->n_patterns == 0) {
    return (0);
  } else {

  }
  cmd.len[0] = (unsigned int )((u16 )((unsigned long )wowlan->n_patterns)) * 148U + 4U;
  tmp___0 = kmalloc((size_t )cmd.len[0], 208U);
  pattern_cmd = (struct iwlagn_wowlan_patterns_cmd *)tmp___0;
  if ((unsigned long )pattern_cmd == (unsigned long )((struct iwlagn_wowlan_patterns_cmd *)0)) {
    return (-12);
  } else {

  }
  pattern_cmd->n_patterns = (unsigned int )wowlan->n_patterns;
  i = 0;
  goto ldv_55390;
  ldv_55389: 
  mask_len = ((wowlan->patterns + (unsigned long )i)->pattern_len + 7) / 8;
  memcpy((void *)(& pattern_cmd->patterns[i].mask), (void const   *)(wowlan->patterns + (unsigned long )i)->mask,
           (size_t )mask_len);
  memcpy((void *)(& pattern_cmd->patterns[i].pattern), (void const   *)(wowlan->patterns + (unsigned long )i)->pattern,
           (size_t )(wowlan->patterns + (unsigned long )i)->pattern_len);
  pattern_cmd->patterns[i].mask_size = (u8 )mask_len;
  pattern_cmd->patterns[i].pattern_size = (u8 )(wowlan->patterns + (unsigned long )i)->pattern_len;
  i = i + 1;
  ldv_55390: ;
  if (wowlan->n_patterns > i) {
    goto ldv_55389;
  } else {

  }
  cmd.data[0] = (void const   *)pattern_cmd;
  err = iwl_dvm_send_cmd(priv, & cmd);
  kfree((void const   *)pattern_cmd);
  return (err);
}
}
int iwlagn_suspend(struct iwl_priv *priv , struct cfg80211_wowlan *wowlan ) 
{ 
  struct iwlagn_wowlan_wakeup_filter_cmd wakeup_filter_cmd ;
  struct iwl_rxon_cmd rxon ;
  struct iwl_rxon_context *ctx ;
  struct iwlagn_wowlan_kek_kck_material_cmd kek_kck_cmd ;
  struct iwlagn_wowlan_tkip_params_cmd tkip_cmd ;
  struct iwlagn_d3_config_cmd d3_cfg_cmd ;
  struct wowlan_key_data key_data ;
  int ret ;
  int i ;
  u16 seq ;
  void *tmp ;
  struct iwl_host_cmd rsc_tsc_cmd ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;

  {
  ctx = (struct iwl_rxon_context *)(& priv->contexts);
  tkip_cmd.mic_keys.tx[0] = (unsigned char)0;
  tkip_cmd.mic_keys.tx[1] = (unsigned char)0;
  tkip_cmd.mic_keys.tx[2] = (unsigned char)0;
  tkip_cmd.mic_keys.tx[3] = (unsigned char)0;
  tkip_cmd.mic_keys.tx[4] = (unsigned char)0;
  tkip_cmd.mic_keys.tx[5] = (unsigned char)0;
  tkip_cmd.mic_keys.tx[6] = (unsigned char)0;
  tkip_cmd.mic_keys.tx[7] = (unsigned char)0;
  tkip_cmd.mic_keys.rx_unicast[0] = (unsigned char)0;
  tkip_cmd.mic_keys.rx_unicast[1] = (unsigned char)0;
  tkip_cmd.mic_keys.rx_unicast[2] = (unsigned char)0;
  tkip_cmd.mic_keys.rx_unicast[3] = (unsigned char)0;
  tkip_cmd.mic_keys.rx_unicast[4] = (unsigned char)0;
  tkip_cmd.mic_keys.rx_unicast[5] = (unsigned char)0;
  tkip_cmd.mic_keys.rx_unicast[6] = (unsigned char)0;
  tkip_cmd.mic_keys.rx_unicast[7] = (unsigned char)0;
  tkip_cmd.mic_keys.rx_mcast[0] = (unsigned char)0;
  tkip_cmd.mic_keys.rx_mcast[1] = (unsigned char)0;
  tkip_cmd.mic_keys.rx_mcast[2] = (unsigned char)0;
  tkip_cmd.mic_keys.rx_mcast[3] = (unsigned char)0;
  tkip_cmd.mic_keys.rx_mcast[4] = (unsigned char)0;
  tkip_cmd.mic_keys.rx_mcast[5] = (unsigned char)0;
  tkip_cmd.mic_keys.rx_mcast[6] = (unsigned char)0;
  tkip_cmd.mic_keys.rx_mcast[7] = (unsigned char)0;
  tkip_cmd.tx.p1k[0] = (unsigned short)0;
  tkip_cmd.tx.p1k[1] = (unsigned short)0;
  tkip_cmd.tx.p1k[2] = (unsigned short)0;
  tkip_cmd.tx.p1k[3] = (unsigned short)0;
  tkip_cmd.tx.p1k[4] = (unsigned short)0;
  tkip_cmd.rx_uni[0].p1k[0] = (unsigned short)0;
  tkip_cmd.rx_uni[0].p1k[1] = (unsigned short)0;
  tkip_cmd.rx_uni[0].p1k[2] = (unsigned short)0;
  tkip_cmd.rx_uni[0].p1k[3] = (unsigned short)0;
  tkip_cmd.rx_uni[0].p1k[4] = (unsigned short)0;
  tkip_cmd.rx_uni[1].p1k[0] = (unsigned short)0;
  tkip_cmd.rx_uni[1].p1k[1] = (unsigned short)0;
  tkip_cmd.rx_uni[1].p1k[2] = (unsigned short)0;
  tkip_cmd.rx_uni[1].p1k[3] = (unsigned short)0;
  tkip_cmd.rx_uni[1].p1k[4] = (unsigned short)0;
  tkip_cmd.rx_multi[0].p1k[0] = (unsigned short)0;
  tkip_cmd.rx_multi[0].p1k[1] = (unsigned short)0;
  tkip_cmd.rx_multi[0].p1k[2] = (unsigned short)0;
  tkip_cmd.rx_multi[0].p1k[3] = (unsigned short)0;
  tkip_cmd.rx_multi[0].p1k[4] = (unsigned short)0;
  tkip_cmd.rx_multi[1].p1k[0] = (unsigned short)0;
  tkip_cmd.rx_multi[1].p1k[1] = (unsigned short)0;
  tkip_cmd.rx_multi[1].p1k[2] = (unsigned short)0;
  tkip_cmd.rx_multi[1].p1k[3] = (unsigned short)0;
  tkip_cmd.rx_multi[1].p1k[4] = (unsigned short)0;
  d3_cfg_cmd.min_sleep_time = 10000000U;
  d3_cfg_cmd.wakeup_flags = 0U;
  key_data.ctx = ctx;
  key_data.rsc_tsc = 0;
  key_data.tkip = & tkip_cmd;
  key_data.bssid = (u8 const   *)(& ctx->active.bssid_addr);
  key_data.error = (_Bool)0;
  key_data.use_rsc_tsc = 0;
  key_data.use_tkip = 0;
  tmp = kzalloc(264UL, 208U);
  key_data.rsc_tsc = (struct iwlagn_wowlan_rsc_tsc_params_cmd *)tmp;
  if ((unsigned long )key_data.rsc_tsc == (unsigned long )((struct iwlagn_wowlan_rsc_tsc_params_cmd *)0)) {
    return (-12);
  } else {

  }
  memset((void *)(& wakeup_filter_cmd), 0, 24UL);
  seq = (unsigned int )priv->last_seq_ctl & 65520U;
  wakeup_filter_cmd.non_qos_seq = seq;
  i = 0;
  goto ldv_55407;
  ldv_55406: 
  seq = priv->tid_data[0][i].seq_number;
  seq = (unsigned int )seq + 65520U;
  wakeup_filter_cmd.qos_seq[i] = seq;
  i = i + 1;
  ldv_55407: ;
  if (i <= 7) {
    goto ldv_55406;
  } else {

  }

  if ((int )wowlan->disconnect) {
    wakeup_filter_cmd.enabled = wakeup_filter_cmd.enabled | 12U;
  } else {

  }
  if ((int )wowlan->magic_pkt) {
    wakeup_filter_cmd.enabled = wakeup_filter_cmd.enabled | 1U;
  } else {

  }
  if ((int )wowlan->gtk_rekey_failure) {
    wakeup_filter_cmd.enabled = wakeup_filter_cmd.enabled | 16U;
  } else {

  }
  if ((int )wowlan->eap_identity_req) {
    wakeup_filter_cmd.enabled = wakeup_filter_cmd.enabled | 32U;
  } else {

  }
  if ((int )wowlan->four_way_handshake) {
    wakeup_filter_cmd.enabled = wakeup_filter_cmd.enabled | 64U;
  } else {

  }
  if (wowlan->n_patterns != 0) {
    wakeup_filter_cmd.enabled = wakeup_filter_cmd.enabled | 2U;
  } else {

  }
  if ((int )wowlan->rfkill_release) {
    d3_cfg_cmd.wakeup_flags = d3_cfg_cmd.wakeup_flags | 1U;
  } else {

  }
  iwl_scan_cancel_timeout(priv, 200UL);
  memcpy((void *)(& rxon), (void const   *)(& ctx->active), 50UL);
  priv->ucode_loaded = 0;
  iwl_trans_stop_device(priv->trans);
  priv->wowlan = 1;
  ret = iwl_load_ucode_wait_alive(priv, 2);
  if (ret != 0) {
    goto out;
  } else {

  }
  ret = iwl_alive_start(priv);
  if (ret != 0) {
    goto out;
  } else {

  }
  memcpy((void *)(& ctx->staging), (void const   *)(& rxon), 50UL);
  ret = iwlagn_commit_rxon(priv, ctx);
  if (ret != 0) {
    goto out;
  } else {

  }
  ret = iwl_power_update_mode(priv, 1);
  if (ret != 0) {
    goto out;
  } else {

  }
  if (iwlwifi_mod_params.sw_crypto == 0) {
    priv->ucode_key_table = 0UL;
    ctx->key_mapping_keys = 0U;
    mutex_unlock(& priv->mutex);
    ieee80211_iter_keys(priv->hw, ctx->vif, & iwlagn_wowlan_program_keys, (void *)(& key_data));
    mutex_lock_nested(& priv->mutex, 0U);
    if ((int )key_data.error) {
      ret = -5;
      goto out;
    } else {

    }
    if ((int )key_data.use_rsc_tsc) {
      rsc_tsc_cmd.data[0] = (void const   *)key_data.rsc_tsc;
      tmp___0 = 1U;
      while (1) {
        if (tmp___0 >= 2U) {
          break;
        } else {

        }
        rsc_tsc_cmd.data[tmp___0] = 0;
        tmp___0 = tmp___0 + 1U;
      }
      rsc_tsc_cmd.resp_pkt = 0;
      rsc_tsc_cmd._rx_page_addr = 0UL;
      rsc_tsc_cmd._rx_page_order = 0U;
      rsc_tsc_cmd.handler_status = 0;
      rsc_tsc_cmd.flags = 0U;
      rsc_tsc_cmd.len[0] = 264U;
      tmp___1 = 1U;
      while (1) {
        if (tmp___1 >= 2U) {
          break;
        } else {

        }
        rsc_tsc_cmd.len[tmp___1] = (unsigned short)0;
        tmp___1 = tmp___1 + 1U;
      }
      rsc_tsc_cmd.dataflags[0] = 1U;
      tmp___2 = 1U;
      while (1) {
        if (tmp___2 >= 2U) {
          break;
        } else {

        }
        rsc_tsc_cmd.dataflags[tmp___2] = (unsigned char)0;
        tmp___2 = tmp___2 + 1U;
      }
      rsc_tsc_cmd.id = 226U;
      ret = iwl_dvm_send_cmd(priv, & rsc_tsc_cmd);
      if (ret != 0) {
        goto out;
      } else {

      }
    } else {

    }
    if ((int )key_data.use_tkip) {
      ret = iwl_dvm_send_cmd_pdu(priv, 227, 0U, 74, (void const   *)(& tkip_cmd));
      if (ret != 0) {
        goto out;
      } else {

      }
    } else {

    }
    if ((int )priv->have_rekey_data) {
      memset((void *)(& kek_kck_cmd), 0, 76UL);
      memcpy((void *)(& kek_kck_cmd.kck), (void const   *)(& priv->kck), 16UL);
      kek_kck_cmd.kck_len = 16U;
      memcpy((void *)(& kek_kck_cmd.kek), (void const   *)(& priv->kek), 16UL);
      kek_kck_cmd.kek_len = 16U;
      kek_kck_cmd.replay_ctr = priv->replay_ctr;
      ret = iwl_dvm_send_cmd_pdu(priv, 228, 0U, 76, (void const   *)(& kek_kck_cmd));
      if (ret != 0) {
        goto out;
      } else {

      }
    } else {

    }
  } else {

  }
  ret = iwl_dvm_send_cmd_pdu(priv, 211, 0U, 8, (void const   *)(& d3_cfg_cmd));
  if (ret != 0) {
    goto out;
  } else {

  }
  ret = iwl_dvm_send_cmd_pdu(priv, 225, 0U, 24, (void const   *)(& wakeup_filter_cmd));
  if (ret != 0) {
    goto out;
  } else {

  }
  ret = iwlagn_send_patterns(priv, wowlan);
  out: 
  kfree((void const   *)key_data.rsc_tsc);
  return (ret);
}
}
int iwl_dvm_send_cmd(struct iwl_priv *priv , struct iwl_host_cmd *cmd ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;
  int __ret_warn_on ;
  int tmp___4 ;
  int tmp___5 ;
  long tmp___6 ;
  int tmp___7 ;

  {
  tmp___0 = iwl_is_rfkill(priv);
  if (tmp___0 != 0) {
    tmp = iwl_is_rfkill(priv);
    __iwl_warn(priv->dev, "Not sending command - %s KILL\n", tmp != 0 ? (char *)"RF" : (char *)"CT");
    return (-5);
  } else {
    tmp___1 = iwl_is_ctkill(priv);
    if (tmp___1 != 0) {
      tmp = iwl_is_rfkill(priv);
      __iwl_warn(priv->dev, "Not sending command - %s KILL\n", tmp != 0 ? (char *)"RF" : (char *)"CT");
      return (-5);
    } else {

    }
  }
  tmp___3 = constant_test_bit(10L, (unsigned long const volatile   *)(& priv->status));
  if (tmp___3 != 0) {
    tmp___2 = iwl_dvm_get_cmd_string((int )cmd->id);
    __iwl_err(priv->dev, 0, 0, "Command %s failed: FW Error\n", tmp___2);
    return (-5);
  } else {

  }
  if (! priv->ucode_loaded) {
    __iwl_err(priv->dev, 0, 0, "Fw not loaded - dropping CMD: %x\n", (int )cmd->id);
    return (-5);
  } else {

  }
  if ((cmd->flags & 1U) == 0U) {
    if (debug_locks != 0) {
      tmp___4 = lock_is_held(& priv->mutex.dep_map);
      if (tmp___4 == 0) {
        tmp___5 = 1;
      } else {
        tmp___5 = 0;
      }
    } else {
      tmp___5 = 0;
    }
    __ret_warn_on = tmp___5;
    tmp___6 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
    if (tmp___6 != 0L) {
      warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/08_1a/drivers/net/wireless/iwlwifi/dvm/lib.c",
                         1286);
    } else {

    }
    ldv__builtin_expect(__ret_warn_on != 0, 0L);
  } else {

  }
  tmp___7 = iwl_trans_send_cmd(priv->trans, cmd);
  return (tmp___7);
}
}
int iwl_dvm_send_cmd_pdu(struct iwl_priv *priv , u8 id , u32 flags , u16 len , void const   *data ) 
{ 
  struct iwl_host_cmd cmd ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  int tmp___1 ;

  {
  cmd.data[0] = data;
  tmp = 1U;
  while (1) {
    if (tmp >= 2U) {
      break;
    } else {

    }
    cmd.data[tmp] = 0;
    tmp = tmp + 1U;
  }
  cmd.resp_pkt = 0;
  cmd._rx_page_addr = 0UL;
  cmd._rx_page_order = 0U;
  cmd.handler_status = 0;
  cmd.flags = flags;
  cmd.len[0] = len;
  tmp___0 = 1U;
  while (1) {
    if (tmp___0 >= 2U) {
      break;
    } else {

    }
    cmd.len[tmp___0] = (unsigned short)0;
    tmp___0 = tmp___0 + 1U;
  }
  cmd.dataflags[0] = (unsigned char)0;
  cmd.dataflags[1] = (unsigned char)0;
  cmd.id = id;
  tmp___1 = iwl_dvm_send_cmd(priv, & cmd);
  return (tmp___1);
}
}
void disable_work_7(struct work_struct *work ) 
{ 


  {
  if ((ldv_work_7_0 == 3 || ldv_work_7_0 == 2) && (unsigned long )ldv_work_struct_7_0 == (unsigned long )work) {
    ldv_work_7_0 = 1;
  } else {

  }
  if ((ldv_work_7_1 == 3 || ldv_work_7_1 == 2) && (unsigned long )ldv_work_struct_7_1 == (unsigned long )work) {
    ldv_work_7_1 = 1;
  } else {

  }
  if ((ldv_work_7_2 == 3 || ldv_work_7_2 == 2) && (unsigned long )ldv_work_struct_7_2 == (unsigned long )work) {
    ldv_work_7_2 = 1;
  } else {

  }
  if ((ldv_work_7_3 == 3 || ldv_work_7_3 == 2) && (unsigned long )ldv_work_struct_7_3 == (unsigned long )work) {
    ldv_work_7_3 = 1;
  } else {

  }
  return;
}
}
void call_and_disable_work_7(struct work_struct *work ) 
{ 


  {
  if ((ldv_work_7_0 == 2 || ldv_work_7_0 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_7_0) {
    iwlagn_bt_traffic_change_work(work);
    ldv_work_7_0 = 1;
    return;
  } else {

  }
  if ((ldv_work_7_1 == 2 || ldv_work_7_1 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_7_1) {
    iwlagn_bt_traffic_change_work(work);
    ldv_work_7_1 = 1;
    return;
  } else {

  }
  if ((ldv_work_7_2 == 2 || ldv_work_7_2 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_7_2) {
    iwlagn_bt_traffic_change_work(work);
    ldv_work_7_2 = 1;
    return;
  } else {

  }
  if ((ldv_work_7_3 == 2 || ldv_work_7_3 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_7_3) {
    iwlagn_bt_traffic_change_work(work);
    ldv_work_7_3 = 1;
    return;
  } else {

  }
  return;
}
}
void call_and_disable_all_7(int state ) 
{ 


  {
  if (ldv_work_7_0 == state) {
    call_and_disable_work_7(ldv_work_struct_7_0);
  } else {

  }
  if (ldv_work_7_1 == state) {
    call_and_disable_work_7(ldv_work_struct_7_1);
  } else {

  }
  if (ldv_work_7_2 == state) {
    call_and_disable_work_7(ldv_work_struct_7_2);
  } else {

  }
  if (ldv_work_7_3 == state) {
    call_and_disable_work_7(ldv_work_struct_7_3);
  } else {

  }
  return;
}
}
void work_init_7(void) 
{ 


  {
  ldv_work_7_0 = 0;
  ldv_work_7_1 = 0;
  ldv_work_7_2 = 0;
  ldv_work_7_3 = 0;
  return;
}
}
void invoke_work_7(void) 
{ 
  int tmp ;

  {
  tmp = __VERIFIER_nondet_int();
  switch (tmp) {
  case 0: ;
  if (ldv_work_7_0 == 2 || ldv_work_7_0 == 3) {
    ldv_work_7_0 = 4;
    iwlagn_bt_traffic_change_work(ldv_work_struct_7_0);
    ldv_work_7_0 = 1;
  } else {

  }
  goto ldv_55445;
  case 1: ;
  if (ldv_work_7_1 == 2 || ldv_work_7_1 == 3) {
    ldv_work_7_1 = 4;
    iwlagn_bt_traffic_change_work(ldv_work_struct_7_0);
    ldv_work_7_1 = 1;
  } else {

  }
  goto ldv_55445;
  case 2: ;
  if (ldv_work_7_2 == 2 || ldv_work_7_2 == 3) {
    ldv_work_7_2 = 4;
    iwlagn_bt_traffic_change_work(ldv_work_struct_7_0);
    ldv_work_7_2 = 1;
  } else {

  }
  goto ldv_55445;
  case 3: ;
  if (ldv_work_7_3 == 2 || ldv_work_7_3 == 3) {
    ldv_work_7_3 = 4;
    iwlagn_bt_traffic_change_work(ldv_work_struct_7_0);
    ldv_work_7_3 = 1;
  } else {

  }
  goto ldv_55445;
  default: 
  ldv_stop();
  }
  ldv_55445: ;
  return;
}
}
void activate_work_7(struct work_struct *work , int state ) 
{ 


  {
  if (ldv_work_7_0 == 0) {
    ldv_work_struct_7_0 = work;
    ldv_work_7_0 = state;
    return;
  } else {

  }
  if (ldv_work_7_1 == 0) {
    ldv_work_struct_7_1 = work;
    ldv_work_7_1 = state;
    return;
  } else {

  }
  if (ldv_work_7_2 == 0) {
    ldv_work_struct_7_2 = work;
    ldv_work_7_2 = state;
    return;
  } else {

  }
  if (ldv_work_7_3 == 0) {
    ldv_work_struct_7_3 = work;
    ldv_work_7_3 = state;
    return;
  } else {

  }
  return;
}
}
bool ldv_queue_work_on_105(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_7(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_delayed_work_on_106(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_7(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_work_on_107(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_7(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
void ldv_flush_workqueue_108(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
  flush_workqueue(ldv_func_arg1);
  call_and_disable_all_7(2);
  return;
}
}
bool ldv_queue_delayed_work_on_109(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_7(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
bool ldv_cancel_work_sync_110(struct work_struct *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___12 ldv_func_res ;
  bool tmp ;

  {
  tmp = cancel_work_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_work_7(ldv_func_arg1);
  return (ldv_func_res);
}
}
extern void __list_add(struct list_head * , struct list_head * , struct list_head * ) ;
__inline static void list_add_tail(struct list_head *new , struct list_head *head ) 
{ 


  {
  __list_add(new, head->prev, head);
  return;
}
}
extern void list_del(struct list_head * ) ;
__inline static void list_replace(struct list_head *old , struct list_head *new ) 
{ 


  {
  new->next = old->next;
  (new->next)->prev = new;
  new->prev = old->prev;
  (new->prev)->next = new;
  return;
}
}
extern int memcmp(void const   * , void const   * , size_t  ) ;
bool ldv_queue_work_on_121(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_work_on_123(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_delayed_work_on_122(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
bool ldv_queue_delayed_work_on_125(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
void ldv_flush_workqueue_124(struct workqueue_struct *ldv_func_arg1 ) ;
__inline static int iwl_is_any_associated(struct iwl_priv *priv ) 
{ 
  struct iwl_rxon_context *ctx ;
  int tmp ;

  {
  ctx = (struct iwl_rxon_context *)(& priv->contexts);
  goto ldv_53074;
  ldv_53073: ;
  if ((int )((unsigned long )priv->valid_contexts >> (int )ctx->ctxid) & 1) {
    tmp = iwl_is_associated_ctx(ctx);
    if (tmp != 0) {
      return (1);
    } else {

    }
  } else {

  }
  ctx = ctx + 1;
  ldv_53074: ;
  if ((unsigned long )((struct iwl_rxon_context *)(& priv->contexts) + 2UL) > (unsigned long )ctx) {
    goto ldv_53073;
  } else {

  }

  return (0);
}
}
void iwl_init_sensitivity(struct iwl_priv *priv ) ;
int iwl_send_calib_results(struct iwl_priv *priv ) 
{ 
  struct iwl_host_cmd hcmd ;
  struct iwl_calib_result *res ;
  struct list_head  const  *__mptr ;
  int ret ;
  struct list_head  const  *__mptr___0 ;

  {
  hcmd.data[0] = 0;
  hcmd.data[1] = 0;
  hcmd.resp_pkt = 0;
  hcmd._rx_page_addr = 0UL;
  hcmd._rx_page_order = 0U;
  hcmd.handler_status = 0;
  hcmd.flags = 0U;
  hcmd.len[0] = (unsigned short)0;
  hcmd.len[1] = (unsigned short)0;
  hcmd.dataflags[0] = (unsigned char)0;
  hcmd.dataflags[1] = (unsigned char)0;
  hcmd.id = 176U;
  __mptr = (struct list_head  const  *)priv->calib_results.next;
  res = (struct iwl_calib_result *)__mptr;
  goto ldv_53507;
  ldv_53506: 
  hcmd.len[0] = (u16 )res->cmd_len;
  hcmd.data[0] = (void const   *)(& res->hdr);
  hcmd.dataflags[0] = 1U;
  ret = iwl_dvm_send_cmd(priv, & hcmd);
  if (ret != 0) {
    __iwl_err(priv->dev, 0, 0, "Error %d on calib cmd %d\n", ret, (int )res->hdr.op_code);
    return (ret);
  } else {

  }
  __mptr___0 = (struct list_head  const  *)res->list.next;
  res = (struct iwl_calib_result *)__mptr___0;
  ldv_53507: ;
  if ((unsigned long )(& res->list) != (unsigned long )(& priv->calib_results)) {
    goto ldv_53506;
  } else {

  }

  return (0);
}
}
int iwl_calib_set(struct iwl_priv *priv , struct iwl_calib_hdr  const  *cmd , int len ) 
{ 
  struct iwl_calib_result *res ;
  struct iwl_calib_result *tmp ;
  void *tmp___0 ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;

  {
  tmp___0 = kmalloc((unsigned long )len + 28UL, 32U);
  res = (struct iwl_calib_result *)tmp___0;
  if ((unsigned long )res == (unsigned long )((struct iwl_calib_result *)0)) {
    return (-12);
  } else {

  }
  memcpy((void *)(& res->hdr), (void const   *)cmd, (size_t )len);
  res->cmd_len = (size_t )len;
  __mptr = (struct list_head  const  *)priv->calib_results.next;
  tmp = (struct iwl_calib_result *)__mptr;
  goto ldv_53521;
  ldv_53520: ;
  if ((int )tmp->hdr.op_code == (int )res->hdr.op_code) {
    list_replace(& tmp->list, & res->list);
    kfree((void const   *)tmp);
    return (0);
  } else {

  }
  __mptr___0 = (struct list_head  const  *)tmp->list.next;
  tmp = (struct iwl_calib_result *)__mptr___0;
  ldv_53521: ;
  if ((unsigned long )(& tmp->list) != (unsigned long )(& priv->calib_results)) {
    goto ldv_53520;
  } else {

  }
  list_add_tail(& res->list, & priv->calib_results);
  return (0);
}
}
void iwl_calib_free_results(struct iwl_priv *priv ) 
{ 
  struct iwl_calib_result *res ;
  struct iwl_calib_result *tmp ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;

  {
  __mptr = (struct list_head  const  *)priv->calib_results.next;
  res = (struct iwl_calib_result *)__mptr;
  __mptr___0 = (struct list_head  const  *)res->list.next;
  tmp = (struct iwl_calib_result *)__mptr___0;
  goto ldv_53535;
  ldv_53534: 
  list_del(& res->list);
  kfree((void const   *)res);
  res = tmp;
  __mptr___1 = (struct list_head  const  *)tmp->list.next;
  tmp = (struct iwl_calib_result *)__mptr___1;
  ldv_53535: ;
  if ((unsigned long )(& res->list) != (unsigned long )(& priv->calib_results)) {
    goto ldv_53534;
  } else {

  }

  return;
}
}
static int iwl_sens_energy_cck(struct iwl_priv *priv , u32 norm_fa , u32 rx_enable_time ,
                               struct statistics_general_data *rx_info ) 
{ 
  u32 max_nrg_cck ;
  int i ;
  u8 max_silence_rssi ;
  u32 silence_ref ;
  u8 silence_rssi_a ;
  u8 silence_rssi_b ;
  u8 silence_rssi_c ;
  u32 val ;
  u32 false_alarms ;
  u32 max_false_alarms ;
  u32 min_false_alarms ;
  struct iwl_sensitivity_data *data ;
  struct iwl_sensitivity_ranges  const  *ranges ;
  u8 _max1 ;
  u8 _max2 ;
  u8 _max1___0 ;
  unsigned char _max2___0 ;
    klee_make_symbolic(&_max2___0, sizeof(char), "_max2___0");
  u32 _max1___1 ;
  u32 _max2___1 ;
  u32 _min1 ;
  u32 _min2 ;
  u32 _min1___0 ;
  u32 _min2___0 ;
  u32 _max1___2 ;
  u32 _max2___2 ;
  unsigned int _min1___1 ;
    klee_make_symbolic(&_min1___1, sizeof(int), "_min1___1");
  u32 _min2___1 ;
  u32 _max1___3 ;
  u32 _max2___3 ;
  unsigned int _min1___2 ;
    klee_make_symbolic(&_min1___2, sizeof(int), "_min1___2");
  u32 _min2___2 ;
  unsigned int _min1___3 ;
    klee_make_symbolic(&_min1___3, sizeof(int), "_min1___3");
  u32 _min2___3 ;
  unsigned int _max1___4 ;
    klee_make_symbolic(&_max1___4, sizeof(int), "_max1___4");
  u32 _max2___4 ;
  unsigned int _max1___5 ;
    klee_make_symbolic(&_max1___5, sizeof(int), "_max1___5");
  u32 _max2___5 ;

  {
  max_nrg_cck = 0U;
  i = 0;
  max_silence_rssi = 0U;
  silence_ref = 0U;
  silence_rssi_a = 0U;
  silence_rssi_b = 0U;
  silence_rssi_c = 0U;
  false_alarms = norm_fa * 204800U;
  max_false_alarms = rx_enable_time * 50U;
  min_false_alarms = rx_enable_time * 5U;
  data = (struct iwl_sensitivity_data *)0;
  ranges = priv->hw_params.sens;
  data = & priv->sensitivity_data;
  data->nrg_auto_corr_silence_diff = 0;
  silence_rssi_a = (unsigned char )((rx_info->beacon_silence_rssi_a & 65280U) >> 8);
  silence_rssi_b = (unsigned char )((rx_info->beacon_silence_rssi_b & 65280U) >> 8);
  silence_rssi_c = (unsigned char )((rx_info->beacon_silence_rssi_c & 65280U) >> 8);
  _max1 = silence_rssi_b;
  _max2 = silence_rssi_c;
  val = (u32 )((int )_max1 > (int )_max2 ? _max1 : _max2);
  _max1___0 = silence_rssi_a;
  _max2___0 = (unsigned char )val;
  max_silence_rssi = (u8 )((int )_max1___0 > (int )_max2___0 ? (int )_max1___0 : (int )_max2___0);
  data->nrg_silence_rssi[data->nrg_silence_idx] = max_silence_rssi;
  data->nrg_silence_idx = data->nrg_silence_idx + 1U;
  if (data->nrg_silence_idx > 19U) {
    data->nrg_silence_idx = 0U;
  } else {

  }
  i = 0;
  goto ldv_53566;
  ldv_53565: 
  val = (u32 )data->nrg_silence_rssi[i];
  _max1___1 = silence_ref;
  _max2___1 = val;
  silence_ref = _max1___1 > _max2___1 ? _max1___1 : _max2___1;
  i = i + 1;
  ldv_53566: ;
  if (i <= 19) {
    goto ldv_53565;
  } else {

  }
  __iwl_dbg(priv->dev, 2097152U, 0, "iwl_sens_energy_cck", "silence a %u, b %u, c %u, 20-bcn max %u\n",
            (int )silence_rssi_a, (int )silence_rssi_b, (int )silence_rssi_c, silence_ref);
  i = (int )data->nrg_energy_idx;
  _min1 = rx_info->beacon_energy_b;
  _min2 = rx_info->beacon_energy_c;
  val = _min1 < _min2 ? _min1 : _min2;
  _min1___0 = rx_info->beacon_energy_a;
  _min2___0 = val;
  data->nrg_value[i] = _min1___0 < _min2___0 ? _min1___0 : _min2___0;
  data->nrg_energy_idx = data->nrg_energy_idx + 1U;
  if (data->nrg_energy_idx > 9U) {
    data->nrg_energy_idx = 0U;
  } else {

  }
  max_nrg_cck = data->nrg_value[0];
  i = 1;
  goto ldv_53579;
  ldv_53578: 
  _max1___2 = max_nrg_cck;
  _max2___2 = data->nrg_value[i];
  max_nrg_cck = _max1___2 > _max2___2 ? _max1___2 : _max2___2;
  i = i + 1;
  ldv_53579: ;
  if (i <= 9) {
    goto ldv_53578;
  } else {

  }
  max_nrg_cck = max_nrg_cck + 6U;
  __iwl_dbg(priv->dev, 2097152U, 0, "iwl_sens_energy_cck", "rx energy a %u, b %u, c %u, 10-bcn max/min %u\n",
            rx_info->beacon_energy_a, rx_info->beacon_energy_b, rx_info->beacon_energy_c,
            max_nrg_cck - 6U);
  if (false_alarms < min_false_alarms) {
    data->num_in_cck_no_fa = data->num_in_cck_no_fa + 1U;
  } else {
    data->num_in_cck_no_fa = 0U;
  }
  __iwl_dbg(priv->dev, 2097152U, 0, "iwl_sens_energy_cck", "consecutive bcns with few false alarms = %u\n",
            data->num_in_cck_no_fa);
  if (false_alarms > max_false_alarms && data->auto_corr_cck > 160U) {
    __iwl_dbg(priv->dev, 2097152U, 0, "iwl_sens_energy_cck", "norm FA %u > max FA %u\n",
              false_alarms, max_false_alarms);
    __iwl_dbg(priv->dev, 2097152U, 0, "iwl_sens_energy_cck", "... reducing sensitivity\n");
    data->nrg_curr_state = 0U;
    data->nrg_silence_ref = silence_ref;
    data->nrg_th_cck = data->nrg_th_cck - 2U;
  } else
  if (false_alarms < min_false_alarms) {
    data->nrg_curr_state = 1U;
    data->nrg_auto_corr_silence_diff = (int )data->nrg_silence_ref - (int )silence_ref;
    __iwl_dbg(priv->dev, 2097152U, 0, "iwl_sens_energy_cck", "norm FA %u < min FA %u, silence diff %d\n",
              false_alarms, min_false_alarms, data->nrg_auto_corr_silence_diff);
    if (data->nrg_prev_state != 0U && (data->nrg_auto_corr_silence_diff > 2 || data->num_in_cck_no_fa > 100U)) {
      __iwl_dbg(priv->dev, 2097152U, 0, "iwl_sens_energy_cck", "... increasing sensitivity\n");
      val = data->nrg_th_cck + 2U;
      _min1___1 = (unsigned int )ranges->min_nrg_cck;
      _min2___1 = val;
      data->nrg_th_cck = _min1___1 < _min2___1 ? _min1___1 : _min2___1;
    } else {
      __iwl_dbg(priv->dev, 2097152U, 0, "iwl_sens_energy_cck", "... but not changing sensitivity\n");
    }
  } else {
    __iwl_dbg(priv->dev, 2097152U, 0, "iwl_sens_energy_cck", " FA in safe zone\n");
    data->nrg_curr_state = 2U;
    data->nrg_silence_ref = silence_ref;
    if (data->nrg_prev_state == 0U) {
      __iwl_dbg(priv->dev, 2097152U, 0, "iwl_sens_energy_cck", "... increasing margin\n");
      if (data->nrg_th_cck > max_nrg_cck + 8U) {
        data->nrg_th_cck = data->nrg_th_cck - 8U;
      } else {
        data->nrg_th_cck = max_nrg_cck;
      }
    } else {

    }
  }
  _max1___3 = max_nrg_cck;
  _max2___3 = data->nrg_th_cck;
  data->nrg_th_cck = _max1___3 > _max2___3 ? _max1___3 : _max2___3;
  __iwl_dbg(priv->dev, 2097152U, 0, "iwl_sens_energy_cck", "new nrg_th_cck %u\n",
            data->nrg_th_cck);
  data->nrg_prev_state = data->nrg_curr_state;
  if (false_alarms > min_false_alarms) {
    if (data->auto_corr_cck <= 159U) {
      data->auto_corr_cck = 161U;
    } else {
      val = data->auto_corr_cck + 3U;
      _min1___2 = (unsigned int )ranges->auto_corr_max_cck;
      _min2___2 = val;
      data->auto_corr_cck = _min1___2 < _min2___2 ? _min1___2 : _min2___2;
    }
    val = data->auto_corr_cck_mrc + 3U;
    _min1___3 = (unsigned int )ranges->auto_corr_max_cck_mrc;
    _min2___3 = val;
    data->auto_corr_cck_mrc = _min1___3 < _min2___3 ? _min1___3 : _min2___3;
  } else
  if (false_alarms < min_false_alarms && (data->nrg_auto_corr_silence_diff > 2 || data->num_in_cck_no_fa > 100U)) {
    val = data->auto_corr_cck - 3U;
    _max1___4 = (unsigned int )ranges->auto_corr_min_cck;
    _max2___4 = val;
    data->auto_corr_cck = _max1___4 > _max2___4 ? _max1___4 : _max2___4;
    val = data->auto_corr_cck_mrc - 3U;
    _max1___5 = (unsigned int )ranges->auto_corr_min_cck_mrc;
    _max2___5 = val;
    data->auto_corr_cck_mrc = _max1___5 > _max2___5 ? _max1___5 : _max2___5;
  } else {

  }
  return (0);
}
}
static int iwl_sens_auto_corr_ofdm(struct iwl_priv *priv , u32 norm_fa , u32 rx_enable_time ) 
{ 
  u32 val ;
  u32 false_alarms ;
  u32 max_false_alarms ;
  u32 min_false_alarms ;
  struct iwl_sensitivity_data *data ;
  struct iwl_sensitivity_ranges  const  *ranges ;
  unsigned int _min1 ;
  u32 _min2 ;
  unsigned int _min1___0 ;
    klee_make_symbolic(&_min1___0, sizeof(int), "_min1___0");
  u32 _min2___0 ;
  unsigned int _min1___1 ;
  u32 _min2___1 ;
  unsigned int _min1___2 ;
  u32 _min2___2 ;
  unsigned int _max1 ;
    klee_make_symbolic(&_max1, sizeof(int), "_max1");
  u32 _max2 ;
  unsigned int _max1___0 ;
    klee_make_symbolic(&_max1___0, sizeof(int), "_max1___0");
  u32 _max2___0 ;
  unsigned int _max1___1 ;
    klee_make_symbolic(&_max1___1, sizeof(int), "_max1___1");
  u32 _max2___1 ;
  unsigned int _max1___2 ;
    klee_make_symbolic(&_max1___2, sizeof(int), "_max1___2");
  u32 _max2___2 ;

  {
  false_alarms = norm_fa * 204800U;
  max_false_alarms = rx_enable_time * 50U;
  min_false_alarms = rx_enable_time * 5U;
  data = (struct iwl_sensitivity_data *)0;
  ranges = priv->hw_params.sens;
  data = & priv->sensitivity_data;
  if (false_alarms > max_false_alarms) {
    __iwl_dbg(priv->dev, 2097152U, 0, "iwl_sens_auto_corr_ofdm", "norm FA %u > max FA %u)\n",
              false_alarms, max_false_alarms);
    val = data->auto_corr_ofdm + 1U;
    _min1 = (unsigned int )ranges->auto_corr_max_ofdm;
    _min2 = val;
    data->auto_corr_ofdm = _min1 < _min2 ? _min1 : _min2;
    val = data->auto_corr_ofdm_mrc + 1U;
    _min1___0 = (unsigned int )ranges->auto_corr_max_ofdm_mrc;
    _min2___0 = val;
    data->auto_corr_ofdm_mrc = _min1___0 < _min2___0 ? _min1___0 : _min2___0;
    val = data->auto_corr_ofdm_x1 + 1U;
    _min1___1 = (unsigned int )ranges->auto_corr_max_ofdm_x1;
    _min2___1 = val;
    data->auto_corr_ofdm_x1 = _min1___1 < _min2___1 ? _min1___1 : _min2___1;
    val = data->auto_corr_ofdm_mrc_x1 + 1U;
    _min1___2 = (unsigned int )ranges->auto_corr_max_ofdm_mrc_x1;
    _min2___2 = val;
    data->auto_corr_ofdm_mrc_x1 = _min1___2 < _min2___2 ? _min1___2 : _min2___2;
  } else
  if (false_alarms < min_false_alarms) {
    __iwl_dbg(priv->dev, 2097152U, 0, "iwl_sens_auto_corr_ofdm", "norm FA %u < min FA %u\n",
              false_alarms, min_false_alarms);
    val = data->auto_corr_ofdm - 1U;
    _max1 = (unsigned int )ranges->auto_corr_min_ofdm;
    _max2 = val;
    data->auto_corr_ofdm = _max1 > _max2 ? _max1 : _max2;
    val = data->auto_corr_ofdm_mrc - 1U;
    _max1___0 = (unsigned int )ranges->auto_corr_min_ofdm_mrc;
    _max2___0 = val;
    data->auto_corr_ofdm_mrc = _max1___0 > _max2___0 ? _max1___0 : _max2___0;
    val = data->auto_corr_ofdm_x1 - 1U;
    _max1___1 = (unsigned int )ranges->auto_corr_min_ofdm_x1;
    _max2___1 = val;
    data->auto_corr_ofdm_x1 = _max1___1 > _max2___1 ? _max1___1 : _max2___1;
    val = data->auto_corr_ofdm_mrc_x1 - 1U;
    _max1___2 = (unsigned int )ranges->auto_corr_min_ofdm_mrc_x1;
    _max2___2 = val;
    data->auto_corr_ofdm_mrc_x1 = _max1___2 > _max2___2 ? _max1___2 : _max2___2;
  } else {
    __iwl_dbg(priv->dev, 2097152U, 0, "iwl_sens_auto_corr_ofdm", "min FA %u < norm FA %u < max FA %u OK\n",
              min_false_alarms, false_alarms, max_false_alarms);
  }
  return (0);
}
}
static void iwl_prepare_legacy_sensitivity_tbl(struct iwl_priv *priv , struct iwl_sensitivity_data *data ,
                                               __le16 *tbl ) 
{ 


  {
  *(tbl + 5UL) = (unsigned short )data->auto_corr_ofdm;
  *(tbl + 6UL) = (unsigned short )data->auto_corr_ofdm_mrc;
  *(tbl + 2UL) = (unsigned short )data->auto_corr_ofdm_x1;
  *(tbl + 3UL) = (unsigned short )data->auto_corr_ofdm_mrc_x1;
  *(tbl + 9UL) = (unsigned short )data->auto_corr_cck;
  *(tbl + 4UL) = (unsigned short )data->auto_corr_cck_mrc;
  *tbl = (unsigned short )data->nrg_th_cck;
  *(tbl + 1UL) = (unsigned short )data->nrg_th_ofdm;
  *(tbl + 7UL) = data->barker_corr_th_min;
  *(tbl + 8UL) = data->barker_corr_th_min_mrc;
  *(tbl + 10UL) = data->nrg_th_cca;
  __iwl_dbg(priv->dev, 2097152U, 0, "iwl_prepare_legacy_sensitivity_tbl", "ofdm: ac %u mrc %u x1 %u mrc_x1 %u thresh %u\n",
            data->auto_corr_ofdm, data->auto_corr_ofdm_mrc, data->auto_corr_ofdm_x1,
            data->auto_corr_ofdm_mrc_x1, data->nrg_th_ofdm);
  __iwl_dbg(priv->dev, 2097152U, 0, "iwl_prepare_legacy_sensitivity_tbl", "cck: ac %u mrc %u thresh %u\n",
            data->auto_corr_cck, data->auto_corr_cck_mrc, data->nrg_th_cck);
  return;
}
}
static int iwl_sensitivity_write(struct iwl_priv *priv ) 
{ 
  struct iwl_sensitivity_cmd cmd ;
  struct iwl_sensitivity_data *data ;
  struct iwl_host_cmd cmd_out ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  data = (struct iwl_sensitivity_data *)0;
  cmd_out.data[0] = (void const   *)(& cmd);
  tmp = 1U;
  while (1) {
    if (tmp >= 2U) {
      break;
    } else {

    }
    cmd_out.data[tmp] = 0;
    tmp = tmp + 1U;
  }
  cmd_out.resp_pkt = 0;
  cmd_out._rx_page_addr = 0UL;
  cmd_out._rx_page_order = 0U;
  cmd_out.handler_status = 0;
  cmd_out.flags = 1U;
  cmd_out.len[0] = 24U;
  tmp___0 = 1U;
  while (1) {
    if (tmp___0 >= 2U) {
      break;
    } else {

    }
    cmd_out.len[tmp___0] = (unsigned short)0;
    tmp___0 = tmp___0 + 1U;
  }
  cmd_out.dataflags[0] = (unsigned char)0;
  cmd_out.dataflags[1] = (unsigned char)0;
  cmd_out.id = 168U;
  data = & priv->sensitivity_data;
  memset((void *)(& cmd), 0, 24UL);
  iwl_prepare_legacy_sensitivity_tbl(priv, data, (__le16 *)(& cmd.table));
  cmd.control = 1U;
  tmp___1 = memcmp((void const   *)(& cmd.table), (void const   *)(& priv->sensitivity_tbl),
                   22UL);
  if (tmp___1 == 0) {
    __iwl_dbg(priv->dev, 2097152U, 0, "iwl_sensitivity_write", "No change in SENSITIVITY_CMD\n");
    return (0);
  } else {

  }
  memcpy((void *)(& priv->sensitivity_tbl), (void const   *)(& cmd.table), 22UL);
  tmp___2 = iwl_dvm_send_cmd(priv, & cmd_out);
  return (tmp___2);
}
}
static int iwl_enhance_sensitivity_write(struct iwl_priv *priv ) 
{ 
  struct iwl_enhance_sensitivity_cmd cmd ;
  struct iwl_sensitivity_data *data ;
  struct iwl_host_cmd cmd_out ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  data = (struct iwl_sensitivity_data *)0;
  cmd_out.data[0] = (void const   *)(& cmd);
  tmp = 1U;
  while (1) {
    if (tmp >= 2U) {
      break;
    } else {

    }
    cmd_out.data[tmp] = 0;
    tmp = tmp + 1U;
  }
  cmd_out.resp_pkt = 0;
  cmd_out._rx_page_addr = 0UL;
  cmd_out._rx_page_order = 0U;
  cmd_out.handler_status = 0;
  cmd_out.flags = 1U;
  cmd_out.len[0] = 48U;
  tmp___0 = 1U;
  while (1) {
    if (tmp___0 >= 2U) {
      break;
    } else {

    }
    cmd_out.len[tmp___0] = (unsigned short)0;
    tmp___0 = tmp___0 + 1U;
  }
  cmd_out.dataflags[0] = (unsigned char)0;
  cmd_out.dataflags[1] = (unsigned char)0;
  cmd_out.id = 168U;
  data = & priv->sensitivity_data;
  memset((void *)(& cmd), 0, 48UL);
  iwl_prepare_legacy_sensitivity_tbl(priv, data, (__le16 *)(& cmd.enhance_table));
  if ((int )(priv->lib)->hd_v2) {
    cmd.enhance_table[11] = 1U;
    cmd.enhance_table[12] = 1U;
    cmd.enhance_table[13] = 1U;
    cmd.enhance_table[14] = 600U;
    cmd.enhance_table[15] = 40U;
    cmd.enhance_table[16] = 486U;
    cmd.enhance_table[17] = 45U;
    cmd.enhance_table[18] = 853U;
    cmd.enhance_table[19] = 60U;
    cmd.enhance_table[20] = 476U;
    cmd.enhance_table[21] = 99U;
  } else {
    cmd.enhance_table[11] = 0U;
    cmd.enhance_table[12] = 0U;
    cmd.enhance_table[13] = 0U;
    cmd.enhance_table[14] = 668U;
    cmd.enhance_table[15] = 4U;
    cmd.enhance_table[16] = 486U;
    cmd.enhance_table[17] = 37U;
    cmd.enhance_table[18] = 853U;
    cmd.enhance_table[19] = 4U;
    cmd.enhance_table[20] = 476U;
    cmd.enhance_table[21] = 99U;
  }
  cmd.control = 1U;
  tmp___1 = memcmp((void const   *)(& cmd.enhance_table), (void const   *)(& priv->sensitivity_tbl),
                   22UL);
  if (tmp___1 == 0) {
    tmp___2 = memcmp((void const   *)(& cmd.enhance_table) + 11U, (void const   *)(& priv->enhance_sensitivity_tbl),
                     24UL);
    if (tmp___2 == 0) {
      __iwl_dbg(priv->dev, 2097152U, 0, "iwl_enhance_sensitivity_write", "No change in SENSITIVITY_CMD\n");
      return (0);
    } else {

    }
  } else {

  }
  memcpy((void *)(& priv->sensitivity_tbl), (void const   *)(& cmd.enhance_table),
           22UL);
  memcpy((void *)(& priv->enhance_sensitivity_tbl), (void const   *)(& cmd.enhance_table) + 11U,
           24UL);
  tmp___3 = iwl_dvm_send_cmd(priv, & cmd_out);
  return (tmp___3);
}
}
void iwl_init_sensitivity(struct iwl_priv *priv ) 
{ 
  int ret ;
  int i ;
  struct iwl_sensitivity_data *data ;
  struct iwl_sensitivity_ranges  const  *ranges ;
  int tmp ;
  int tmp___0 ;

  {
  ret = 0;
  data = (struct iwl_sensitivity_data *)0;
  ranges = priv->hw_params.sens;
  if ((int )priv->calib_disabled & 1) {
    return;
  } else {

  }
  __iwl_dbg(priv->dev, 2097152U, 0, "iwl_init_sensitivity", "Start iwl_init_sensitivity\n");
  data = & priv->sensitivity_data;
  if ((unsigned long )ranges == (unsigned long )((struct iwl_sensitivity_ranges  const  *)0)) {
    return;
  } else {

  }
  memset((void *)data, 0, 144UL);
  data->num_in_cck_no_fa = 0U;
  data->nrg_curr_state = 0U;
  data->nrg_prev_state = 0U;
  data->nrg_silence_ref = 0U;
  data->nrg_silence_idx = 0U;
  data->nrg_energy_idx = 0U;
  i = 0;
  goto ldv_53664;
  ldv_53663: 
  data->nrg_value[i] = 0U;
  i = i + 1;
  ldv_53664: ;
  if (i <= 9) {
    goto ldv_53663;
  } else {

  }
  i = 0;
  goto ldv_53667;
  ldv_53666: 
  data->nrg_silence_rssi[i] = 0U;
  i = i + 1;
  ldv_53667: ;
  if (i <= 19) {
    goto ldv_53666;
  } else {

  }
  data->auto_corr_ofdm = (u32 )ranges->auto_corr_min_ofdm;
  data->auto_corr_ofdm_mrc = (u32 )ranges->auto_corr_min_ofdm_mrc;
  data->auto_corr_ofdm_x1 = (u32 )ranges->auto_corr_min_ofdm_x1;
  data->auto_corr_ofdm_mrc_x1 = (u32 )ranges->auto_corr_min_ofdm_mrc_x1;
  data->auto_corr_cck = 125U;
  data->auto_corr_cck_mrc = (u32 )ranges->auto_corr_min_cck_mrc;
  data->nrg_th_cck = (u32 )ranges->nrg_th_cck;
  data->nrg_th_ofdm = (u32 )ranges->nrg_th_ofdm;
  data->barker_corr_th_min = ranges->barker_corr_th_min;
  data->barker_corr_th_min_mrc = ranges->barker_corr_th_min_mrc;
  data->nrg_th_cca = ranges->nrg_th_cca;
  data->last_bad_plcp_cnt_ofdm = 0U;
  data->last_fa_cnt_ofdm = 0U;
  data->last_bad_plcp_cnt_cck = 0U;
  data->last_fa_cnt_cck = 0U;
  if ((int )(priv->fw)->enhance_sensitivity_table) {
    tmp = iwl_enhance_sensitivity_write(priv);
    ret = tmp | ret;
  } else {
    tmp___0 = iwl_sensitivity_write(priv);
    ret = tmp___0 | ret;
  }
  __iwl_dbg(priv->dev, 2097152U, 0, "iwl_init_sensitivity", "<<return 0x%X\n", ret);
  return;
}
}
void iwl_sensitivity_calibration(struct iwl_priv *priv ) 
{ 
  u32 rx_enable_time ;
  u32 fa_cck ;
  u32 fa_ofdm ;
  u32 bad_plcp_cck ;
  u32 bad_plcp_ofdm ;
  u32 norm_fa_ofdm ;
  u32 norm_fa_cck ;
  struct iwl_sensitivity_data *data ;
  struct statistics_rx_non_phy *rx_info ;
  struct statistics_rx_phy *ofdm ;
  struct statistics_rx_phy *cck ;
  struct statistics_general_data statis ;
  int tmp ;

  {
  data = (struct iwl_sensitivity_data *)0;
  if ((int )priv->calib_disabled & 1) {
    return;
  } else {

  }
  data = & priv->sensitivity_data;
  tmp = iwl_is_any_associated(priv);
  if (tmp == 0) {
    __iwl_dbg(priv->dev, 2097152U, 0, "iwl_sensitivity_calibration", "<< - not associated\n");
    return;
  } else {

  }
  spin_lock_bh(& priv->statistics.lock);
  rx_info = & priv->statistics.rx_non_phy;
  ofdm = & priv->statistics.rx_ofdm;
  cck = & priv->statistics.rx_cck;
  if (rx_info->interference_data_flag != 1U) {
    __iwl_dbg(priv->dev, 2097152U, 0, "iwl_sensitivity_calibration", "<< invalid data.\n");
    spin_unlock_bh(& priv->statistics.lock);
    return;
  } else {

  }
  rx_enable_time = rx_info->channel_load;
  fa_cck = cck->false_alarm_cnt;
  fa_ofdm = ofdm->false_alarm_cnt;
  bad_plcp_cck = cck->plcp_err;
  bad_plcp_ofdm = ofdm->plcp_err;
  statis.beacon_silence_rssi_a = rx_info->beacon_silence_rssi_a;
  statis.beacon_silence_rssi_b = rx_info->beacon_silence_rssi_b;
  statis.beacon_silence_rssi_c = rx_info->beacon_silence_rssi_c;
  statis.beacon_energy_a = rx_info->beacon_energy_a;
  statis.beacon_energy_b = rx_info->beacon_energy_b;
  statis.beacon_energy_c = rx_info->beacon_energy_c;
  spin_unlock_bh(& priv->statistics.lock);
  __iwl_dbg(priv->dev, 2097152U, 0, "iwl_sensitivity_calibration", "rx_enable_time = %u usecs\n",
            rx_enable_time);
  if (rx_enable_time == 0U) {
    __iwl_dbg(priv->dev, 2097152U, 0, "iwl_sensitivity_calibration", "<< RX Enable Time == 0!\n");
    return;
  } else {

  }
  if (data->last_bad_plcp_cnt_cck > bad_plcp_cck) {
    data->last_bad_plcp_cnt_cck = bad_plcp_cck;
  } else {
    bad_plcp_cck = bad_plcp_cck - data->last_bad_plcp_cnt_cck;
    data->last_bad_plcp_cnt_cck = data->last_bad_plcp_cnt_cck + bad_plcp_cck;
  }
  if (data->last_bad_plcp_cnt_ofdm > bad_plcp_ofdm) {
    data->last_bad_plcp_cnt_ofdm = bad_plcp_ofdm;
  } else {
    bad_plcp_ofdm = bad_plcp_ofdm - data->last_bad_plcp_cnt_ofdm;
    data->last_bad_plcp_cnt_ofdm = data->last_bad_plcp_cnt_ofdm + bad_plcp_ofdm;
  }
  if (data->last_fa_cnt_ofdm > fa_ofdm) {
    data->last_fa_cnt_ofdm = fa_ofdm;
  } else {
    fa_ofdm = fa_ofdm - data->last_fa_cnt_ofdm;
    data->last_fa_cnt_ofdm = data->last_fa_cnt_ofdm + fa_ofdm;
  }
  if (data->last_fa_cnt_cck > fa_cck) {
    data->last_fa_cnt_cck = fa_cck;
  } else {
    fa_cck = fa_cck - data->last_fa_cnt_cck;
    data->last_fa_cnt_cck = data->last_fa_cnt_cck + fa_cck;
  }
  norm_fa_ofdm = fa_ofdm + bad_plcp_ofdm;
  norm_fa_cck = fa_cck + bad_plcp_cck;
  __iwl_dbg(priv->dev, 2097152U, 0, "iwl_sensitivity_calibration", "cck: fa %u badp %u  ofdm: fa %u badp %u\n",
            fa_cck, bad_plcp_cck, fa_ofdm, bad_plcp_ofdm);
  iwl_sens_auto_corr_ofdm(priv, norm_fa_ofdm, rx_enable_time);
  iwl_sens_energy_cck(priv, norm_fa_cck, rx_enable_time, & statis);
  if ((int )(priv->fw)->enhance_sensitivity_table) {
    iwl_enhance_sensitivity_write(priv);
  } else {
    iwl_sensitivity_write(priv);
  }
  return;
}
}
__inline static u8 find_first_chain(u8 mask ) 
{ 


  {
  if ((int )mask & 1) {
    return (0U);
  } else {

  }
  if (((unsigned long )mask & 2UL) != 0UL) {
    return (1U);
  } else {

  }
  return (2U);
}
}
static void iwl_find_disconn_antenna(struct iwl_priv *priv , u32 *average_sig , struct iwl_chain_noise_data *data ) 
{ 
  u32 active_chains ;
  u32 max_average_sig ;
  u16 max_average_sig_antenna_i ;
  u8 num_tx_chains ;
  u8 first_chain ;
  u16 i ;
  s32 rssi_delta ;
  u8 ant_msk ;

  {
  active_chains = 0U;
  i = 0U;
  *average_sig = data->chain_signal_a / 16U;
  *(average_sig + 1UL) = data->chain_signal_b / 16U;
  *(average_sig + 2UL) = data->chain_signal_c / 16U;
  if (*average_sig >= *(average_sig + 1UL)) {
    max_average_sig = *average_sig;
    max_average_sig_antenna_i = 0U;
    active_chains = (u32 )(1 << (int )max_average_sig_antenna_i);
  } else {
    max_average_sig = *(average_sig + 1UL);
    max_average_sig_antenna_i = 1U;
    active_chains = (u32 )(1 << (int )max_average_sig_antenna_i);
  }
  if (*(average_sig + 2UL) >= max_average_sig) {
    max_average_sig = *(average_sig + 2UL);
    max_average_sig_antenna_i = 2U;
    active_chains = (u32 )(1 << (int )max_average_sig_antenna_i);
  } else {

  }
  __iwl_dbg(priv->dev, 2097152U, 0, "iwl_find_disconn_antenna", "average_sig: a %d b %d c %d\n",
            *average_sig, *(average_sig + 1UL), *(average_sig + 2UL));
  __iwl_dbg(priv->dev, 2097152U, 0, "iwl_find_disconn_antenna", "max_average_sig = %d, antenna %d\n",
            max_average_sig, (int )max_average_sig_antenna_i);
  i = 0U;
  goto ldv_53702;
  ldv_53701: ;
  if ((int )i != (int )max_average_sig_antenna_i) {
    rssi_delta = (s32 )(max_average_sig - *(average_sig + (unsigned long )i));
    if (rssi_delta > 15) {
      data->disconn_array[(int )i] = 1U;
    } else {
      active_chains = (u32 )(1 << (int )i) | active_chains;
    }
    __iwl_dbg(priv->dev, 2097152U, 0, "iwl_find_disconn_antenna", "i = %d  rssiDelta = %d  disconn_array[i] = %d\n",
              (int )i, rssi_delta, (int )data->disconn_array[(int )i]);
  } else {

  }
  i = (u16 )((int )i + 1);
  ldv_53702: ;
  if ((unsigned int )i <= 2U) {
    goto ldv_53701;
  } else {

  }
  active_chains = (u32 )(priv->nvm_data)->valid_rx_ant & active_chains;
  num_tx_chains = 0U;
  i = 0U;
  goto ldv_53708;
  ldv_53707: 
  ant_msk = (u8 )(1 << (int )i);
  if ((unsigned int )((int )(priv->nvm_data)->valid_tx_ant & (int )ant_msk) == 0U) {
    goto ldv_53705;
  } else {

  }
  num_tx_chains = (u8 )((int )num_tx_chains + 1);
  if ((unsigned int )data->disconn_array[(int )i] == 0U) {
    goto ldv_53706;
  } else {

  }
  if ((int )priv->hw_params.tx_chains_num == (int )num_tx_chains && (unsigned int )data->disconn_array[(int )i] != 0U) {
    first_chain = find_first_chain((int )(priv->nvm_data)->valid_tx_ant);
    data->disconn_array[(int )first_chain] = 0U;
    active_chains = (u32 )(1UL << (int )first_chain) | active_chains;
    __iwl_dbg(priv->dev, 2097152U, 0, "iwl_find_disconn_antenna", "All Tx chains are disconnected W/A - declare %d as connected\n",
              (int )first_chain);
    goto ldv_53706;
  } else {

  }
  ldv_53705: 
  i = (u16 )((int )i + 1);
  ldv_53708: ;
  if ((unsigned int )i <= 2U) {
    goto ldv_53707;
  } else {

  }
  ldv_53706: ;
  if ((u32 )(priv->nvm_data)->valid_rx_ant != active_chains && priv->chain_noise_data.active_chains != active_chains) {
    __iwl_dbg(priv->dev, 2097152U, 0, "iwl_find_disconn_antenna", "Detected that not all antennas are connected! Connected: %#x, valid: %#x.\n",
              active_chains, (int )(priv->nvm_data)->valid_rx_ant);
  } else {

  }
  data->active_chains = active_chains;
  __iwl_dbg(priv->dev, 2097152U, 0, "iwl_find_disconn_antenna", "active_chains (bitwise) = 0x%x\n",
            active_chains);
  return;
}
}
static void iwlagn_gain_computation(struct iwl_priv *priv , u32 *average_noise , u8 default_chain ) 
{ 
  int i ;
  s32 delta_g ;
  struct iwl_chain_noise_data *data ;
  long _min1 ;
  long ret ;
  int __x___0 ;
    klee_make_symbolic(&__x___0, sizeof(int), "__x___0");
  long _min2 ;
  struct iwl_calib_chain_noise_gain_cmd cmd ;

  {
  data = & priv->chain_noise_data;
  i = (int )default_chain + 1;
  goto ldv_53730;
  ldv_53729: ;
  if ((unsigned int )data->disconn_array[i] != 0U) {
    data->delta_gain_code[i] = 0U;
    goto ldv_53717;
  } else {

  }
  delta_g = ((int )(priv->lib)->chain_noise_scale * ((int )*(average_noise + (unsigned long )default_chain) - (int )*(average_noise + (unsigned long )i))) / 1500;
  __x___0 = delta_g;
  ret = (long )(__x___0 < 0 ? - __x___0 : __x___0);
  _min1 = ret;
  _min2 = 3L;
  data->delta_gain_code[i] = (u8 )(_min1 < _min2 ? _min1 : _min2);
  if (delta_g < 0) {
    data->delta_gain_code[i] = (u8 )((unsigned int )data->delta_gain_code[i] | 4U);
  } else {

  }
  ldv_53717: 
  i = i + 1;
  ldv_53730: ;
  if (i <= 2) {
    goto ldv_53729;
  } else {

  }
  __iwl_dbg(priv->dev, 2097152U, 0, "iwlagn_gain_computation", "Delta gains: ANT_B = %d  ANT_C = %d\n",
            (int )data->delta_gain_code[1], (int )data->delta_gain_code[2]);
  if ((unsigned int )data->radio_write == 0U) {
    memset((void *)(& cmd), 0, 8UL);
    iwl_set_calib_hdr(& cmd.hdr, (int )priv->phy_calib_chain_noise_gain_cmd);
    cmd.delta_gain_1 = data->delta_gain_code[1];
    cmd.delta_gain_2 = data->delta_gain_code[2];
    iwl_dvm_send_cmd_pdu(priv, 176, 1U, 8, (void const   *)(& cmd));
    data->radio_write = 1U;
    data->state = 2U;
  } else {

  }
  return;
}
}
void iwl_chain_noise_calibration(struct iwl_priv *priv ) 
{ 
  struct iwl_chain_noise_data *data ;
  u32 chain_noise_a ;
  u32 chain_noise_b ;
  u32 chain_noise_c ;
  u32 chain_sig_a ;
  u32 chain_sig_b ;
  u32 chain_sig_c ;
  u32 average_sig[3U] ;
  unsigned int tmp ;
  u32 average_noise[3U] ;
  unsigned int tmp___0 ;
  u32 min_average_noise ;
  u16 min_average_noise_antenna_i ;
  u16 i ;
  u16 rxon_chnum ;
  u16 stat_chnum ;
  u8 rxon_band24 ;
  u8 stat_band24 ;
  struct statistics_rx_non_phy *rx_info ;
  struct iwl_rxon_context *ctx ;
  u8 tmp___1 ;

  {
  data = (struct iwl_chain_noise_data *)0;
  average_sig[0] = 65535U;
  tmp = 1U;
  while (1) {
    if (tmp >= 3U) {
      break;
    } else {

    }
    average_sig[tmp] = 0U;
    tmp = tmp + 1U;
  }
  average_noise[0] = 65535U;
  tmp___0 = 1U;
  while (1) {
    if (tmp___0 >= 3U) {
      break;
    } else {

    }
    average_noise[tmp___0] = 0U;
    tmp___0 = tmp___0 + 1U;
  }
  min_average_noise = 4294967295U;
  min_average_noise_antenna_i = 65535U;
  i = 0U;
  rxon_chnum = 65535U;
  stat_chnum = 65535U;
  ctx = (struct iwl_rxon_context *)(& priv->contexts);
  if ((priv->calib_disabled & 2U) != 0U) {
    return;
  } else {

  }
  data = & priv->chain_noise_data;
  if ((unsigned int )data->state != 1U) {
    if ((unsigned int )data->state == 0U) {
      __iwl_dbg(priv->dev, 2097152U, 0, "iwl_chain_noise_calibration", "Wait for noise calib reset\n");
    } else {

    }
    return;
  } else {

  }
  spin_lock_bh(& priv->statistics.lock);
  rx_info = & priv->statistics.rx_non_phy;
  if (rx_info->interference_data_flag != 1U) {
    __iwl_dbg(priv->dev, 2097152U, 0, "iwl_chain_noise_calibration", " << Interference data unavailable\n");
    spin_unlock_bh(& priv->statistics.lock);
    return;
  } else {

  }
  rxon_band24 = (unsigned int )((u8 )ctx->staging.flags) & 1U;
  rxon_chnum = ctx->staging.channel;
  stat_band24 = (priv->statistics.flag & 2U) != 0U;
  stat_chnum = (u16 )(priv->statistics.flag >> 16);
  if ((int )rxon_chnum != (int )stat_chnum || (int )rxon_band24 != (int )stat_band24) {
    __iwl_dbg(priv->dev, 2097152U, 0, "iwl_chain_noise_calibration", "Stats not from chan=%d, band24=%d\n",
              (int )rxon_chnum, (int )rxon_band24);
    spin_unlock_bh(& priv->statistics.lock);
    return;
  } else {

  }
  chain_noise_a = rx_info->beacon_silence_rssi_a & 255U;
  chain_noise_b = rx_info->beacon_silence_rssi_b & 255U;
  chain_noise_c = rx_info->beacon_silence_rssi_c & 255U;
  chain_sig_a = rx_info->beacon_rssi_a & 255U;
  chain_sig_b = rx_info->beacon_rssi_b & 255U;
  chain_sig_c = rx_info->beacon_rssi_c & 255U;
  spin_unlock_bh(& priv->statistics.lock);
  data->beacon_count = (u16 )((int )data->beacon_count + 1);
  data->chain_noise_a = data->chain_noise_a + chain_noise_a;
  data->chain_noise_b = data->chain_noise_b + chain_noise_b;
  data->chain_noise_c = data->chain_noise_c + chain_noise_c;
  data->chain_signal_a = data->chain_signal_a + chain_sig_a;
  data->chain_signal_b = data->chain_signal_b + chain_sig_b;
  data->chain_signal_c = data->chain_signal_c + chain_sig_c;
  __iwl_dbg(priv->dev, 2097152U, 0, "iwl_chain_noise_calibration", "chan=%d, band24=%d, beacon=%d\n",
            (int )rxon_chnum, (int )rxon_band24, (int )data->beacon_count);
  __iwl_dbg(priv->dev, 2097152U, 0, "iwl_chain_noise_calibration", "chain_sig: a %d b %d c %d\n",
            chain_sig_a, chain_sig_b, chain_sig_c);
  __iwl_dbg(priv->dev, 2097152U, 0, "iwl_chain_noise_calibration", "chain_noise: a %d b %d c %d\n",
            chain_noise_a, chain_noise_b, chain_noise_c);
  if ((unsigned int )data->beacon_count != 16U) {
    return;
  } else {

  }
  if ((unsigned long )(priv->lib)->bt_params != (unsigned long )((struct iwl_dvm_bt_params  const  */* const  */)0) && (int )((priv->lib)->bt_params)->advanced_bt_coexist) {
    data->active_chains = (u32 )(priv->nvm_data)->valid_rx_ant;
    i = 0U;
    goto ldv_53757;
    ldv_53756: ;
    if ((data->active_chains & (u32 )(1 << (int )i)) == 0U) {
      data->disconn_array[(int )i] = 1U;
    } else {

    }
    i = (u16 )((int )i + 1);
    ldv_53757: ;
    if ((unsigned int )i <= 2U) {
      goto ldv_53756;
    } else {

    }

  } else {
    iwl_find_disconn_antenna(priv, (u32 *)(& average_sig), data);
  }
  average_noise[0] = data->chain_noise_a / 16U;
  average_noise[1] = data->chain_noise_b / 16U;
  average_noise[2] = data->chain_noise_c / 16U;
  i = 0U;
  goto ldv_53760;
  ldv_53759: ;
  if ((unsigned int )data->disconn_array[(int )i] == 0U && average_noise[(int )i] <= min_average_noise) {
    min_average_noise = average_noise[(int )i];
    min_average_noise_antenna_i = i;
  } else {

  }
  i = (u16 )((int )i + 1);
  ldv_53760: ;
  if ((unsigned int )i <= 2U) {
    goto ldv_53759;
  } else {

  }
  __iwl_dbg(priv->dev, 2097152U, 0, "iwl_chain_noise_calibration", "average_noise: a %d b %d c %d\n",
            average_noise[0], average_noise[1], average_noise[2]);
  __iwl_dbg(priv->dev, 2097152U, 0, "iwl_chain_noise_calibration", "min_average_noise = %d, antenna %d\n",
            min_average_noise, (int )min_average_noise_antenna_i);
  tmp___1 = find_first_chain((int )(priv->nvm_data)->valid_rx_ant);
  iwlagn_gain_computation(priv, (u32 *)(& average_noise), (int )tmp___1);
  iwl_update_chain_flags(priv);
  data->state = 3U;
  iwl_power_update_mode(priv, 0);
  return;
}
}
void iwl_reset_run_time_calib(struct iwl_priv *priv ) 
{ 
  int i ;

  {
  memset((void *)(& priv->sensitivity_data), 0, 144UL);
  memset((void *)(& priv->chain_noise_data), 0, 40UL);
  i = 0;
  goto ldv_53767;
  ldv_53766: 
  priv->chain_noise_data.delta_gain_code[i] = 4U;
  i = i + 1;
  ldv_53767: ;
  if (i <= 2) {
    goto ldv_53766;
  } else {

  }
  iwl_send_statistics_request(priv, 1, 1);
  return;
}
}
bool ldv_queue_work_on_121(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_7(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_delayed_work_on_122(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_7(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_work_on_123(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_7(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
void ldv_flush_workqueue_124(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
  flush_workqueue(ldv_func_arg1);
  call_and_disable_all_7(2);
  return;
}
}
bool ldv_queue_delayed_work_on_125(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_7(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
__inline static long ldv__builtin_expect(long exp , long c ) ;
__inline static unsigned long arch_local_save_flags___1(void) 
{ 
  unsigned long __ret ;
  unsigned long __edi ;
  unsigned long __esi ;
  unsigned long __edx ;
  unsigned long __ecx ;
  unsigned long __eax ;
  long tmp ;

  {
  __edi = __edi;
  __esi = __esi;
  __edx = __edx;
  __ecx = __ecx;
  __eax = __eax;
  tmp = ldv__builtin_expect((unsigned long )pv_irq_ops.save_fl.func == (unsigned long )((void *)0),
                         0L);
  if (tmp != 0L) {
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"./arch/x86/include/asm/paravirt.h"),
                         "i" (831), "i" (12UL));
    ldv_4860: ;
    goto ldv_4860;
  } else {

  }
  __asm__  volatile   ("771:\n\tcall *%c2;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c1\n  .byte 772b-771b\n  .short %c3\n.popsection\n": "=a" (__eax): [paravirt_typenum] "i" (43UL),
                       [paravirt_opptr] "i" (& pv_irq_ops.save_fl.func), [paravirt_clobber] "i" (1): "memory",
                       "cc");
  __ret = __eax;
  return (__ret);
}
}
__inline static bool static_key_false___1(struct static_key *key ) 
{ 
  int tmp ;
  long tmp___0 ;

  {
  tmp = static_key_count(key);
  tmp___0 = ldv__builtin_expect(tmp > 0, 0L);
  if (tmp___0 != 0L) {
    return (1);
  } else {

  }
  return (0);
}
}
__inline static int rcu_read_lock_sched_held___1(void) 
{ 
  int lockdep_opinion ;
  int tmp ;
  bool tmp___0 ;
  int tmp___1 ;
  bool tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  unsigned long _flags ;
  int tmp___5 ;
  int tmp___6 ;

  {
  lockdep_opinion = 0;
  tmp = debug_lockdep_rcu_enabled();
  if (tmp == 0) {
    return (1);
  } else {

  }
  tmp___0 = rcu_is_watching();
  if (tmp___0) {
    tmp___1 = 0;
  } else {
    tmp___1 = 1;
  }
  if (tmp___1) {
    return (0);
  } else {

  }
  tmp___2 = rcu_lockdep_current_cpu_online();
  if (tmp___2) {
    tmp___3 = 0;
  } else {
    tmp___3 = 1;
  }
  if (tmp___3) {
    return (0);
  } else {

  }
  if (debug_locks != 0) {
    lockdep_opinion = lock_is_held(& rcu_sched_lock_map);
  } else {

  }
  if (lockdep_opinion != 0) {
    tmp___6 = 1;
  } else {
    tmp___4 = preempt_count();
    if (tmp___4 != 0) {
      tmp___6 = 1;
    } else {
      _flags = arch_local_save_flags___1();
      tmp___5 = arch_irqs_disabled_flags(_flags);
      if (tmp___5 != 0) {
        tmp___6 = 1;
      } else {
        tmp___6 = 0;
      }
    }
  }
  return (tmp___6);
}
}
int ldv_mod_timer_140(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
int ldv_mod_timer_141(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
int ldv_mod_timer_142(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
int ldv_del_timer_sync_143(struct timer_list *ldv_func_arg1 ) ;
int ldv_del_timer_sync_144(struct timer_list *ldv_func_arg1 ) ;
int ldv_del_timer_sync_145(struct timer_list *ldv_func_arg1 ) ;
int ldv_del_timer_sync_146(struct timer_list *ldv_func_arg1 ) ;
int ldv_del_timer_sync_147(struct timer_list *ldv_func_arg1 ) ;
bool ldv_queue_work_on_135(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_work_on_137(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_delayed_work_on_136(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
bool ldv_queue_delayed_work_on_139(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
void ldv_flush_workqueue_138(struct workqueue_struct *ldv_func_arg1 ) ;
bool ldv_cancel_work_sync_148(struct work_struct *ldv_func_arg1 ) ;
bool ldv_cancel_work_sync_149(struct work_struct *ldv_func_arg1 ) ;
bool ldv_cancel_work_sync_150(struct work_struct *ldv_func_arg1 ) ;
__inline static bool queue_work___4(struct workqueue_struct *wq , struct work_struct *work ) 
{ 
  bool tmp ;

  {
  tmp = ldv_queue_work_on_135(8192, wq, work);
  return (tmp);
}
}
__inline static void *kmalloc_array(size_t n , size_t size , gfp_t flags ) 
{ 
  void *tmp ;

  {
  if (size != 0UL && 0xffffffffffffffffUL / size < n) {
    return ((void *)0);
  } else {

  }
  tmp = __kmalloc(n * size, flags);
  return (tmp);
}
}
void *ldv_calloc(size_t nmemb , size_t size ) ;
__inline static void *kcalloc(size_t n , size_t size , gfp_t flags ) 
{ 
  void *tmp ;

  {
  tmp = kmalloc_array(n, size, flags | 32768U);
  return (tmp);
}
}
void activate_suitable_timer_18(struct timer_list *timer , unsigned long data ) ;
void call_and_disable_work_10(struct work_struct *work ) ;
void invoke_work_8(void) ;
void disable_suitable_timer_17(struct timer_list *timer ) ;
void invoke_work_10(void) ;
void ldv_timer_17(int state , struct timer_list *timer ) ;
void choose_timer_18(void) ;
void call_and_disable_all_9(int state ) ;
void call_and_disable_work_8(struct work_struct *work ) ;
void invoke_work_9(void) ;
void disable_work_8(struct work_struct *work ) ;
void activate_work_9(struct work_struct *work , int state ) ;
void ldv_timer_18(int state , struct timer_list *timer ) ;
void choose_timer_17(void) ;
void call_and_disable_all_8(int state ) ;
void call_and_disable_work_9(struct work_struct *work ) ;
void activate_work_8(struct work_struct *work , int state ) ;
void activate_suitable_timer_17(struct timer_list *timer , unsigned long data ) ;
void disable_work_9(struct work_struct *work ) ;
void disable_work_10(struct work_struct *work ) ;
int reg_timer_17(struct timer_list *timer , void (*function)(unsigned long  ) , unsigned long data ) ;
void activate_work_10(struct work_struct *work , int state ) ;
void activate_pending_timer_17(struct timer_list *timer , unsigned long data , int pending_flag ) ;
void call_and_disable_all_10(int state ) ;
__inline static void trace_iwlwifi_dev_ioread32___0(struct device  const  *dev , u32 offs ,
                                                    u32 val ) 
{ 
  struct tracepoint_func *it_func_ptr ;
  void *it_func ;
  void *__data ;
  struct tracepoint_func *________p1 ;
  struct tracepoint_func *_________p1 ;
  union __anonunion___u_386 __u ;
  bool __warned ;
  int tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  struct tracepoint_func *________p1___0 ;
  struct tracepoint_func *_________p1___0 ;
  union __anonunion___u_388 __u___0 ;
  bool __warned___0 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  tmp___1 = static_key_false___1(& __tracepoint_iwlwifi_dev_ioread32.key);
  if ((int )tmp___1) {
    rcu_read_lock_sched_notrace();
    __read_once_size((void const volatile   *)(& __tracepoint_iwlwifi_dev_ioread32.funcs),
                     (void *)(& __u.__c), 8);
    _________p1 = __u.__val;
    ________p1 = _________p1;
    tmp = debug_lockdep_rcu_enabled();
    if (tmp != 0 && ! __warned) {
      tmp___0 = rcu_read_lock_sched_held___1();
      if (tmp___0 == 0) {
        __warned = 1;
        lockdep_rcu_suspicious("drivers/net/wireless/iwlwifi/dvm/../iwl-devtrace-io.h",
                               50, "suspicious rcu_dereference_check() usage");
      } else {

      }
    } else {

    }
    it_func_ptr = ________p1;
    if ((unsigned long )it_func_ptr != (unsigned long )((struct tracepoint_func *)0)) {
      ldv_51132: 
      it_func = it_func_ptr->func;
      __data = it_func_ptr->data;
      (*((void (*)(void * , struct device  const  * , u32  , u32  ))it_func))(__data,
                                                                              dev,
                                                                              offs,
                                                                              val);
      it_func_ptr = it_func_ptr + 1;
      if ((unsigned long )it_func_ptr->func != (unsigned long )((void *)0)) {
        goto ldv_51132;
      } else {

      }

    } else {

    }
    rcu_read_unlock_sched_notrace();
  } else {

  }
  rcu_read_lock_sched_notrace();
  __read_once_size((void const volatile   *)(& __tracepoint_iwlwifi_dev_ioread32.funcs),
                   (void *)(& __u___0.__c), 8);
  _________p1___0 = __u___0.__val;
  ________p1___0 = _________p1___0;
  tmp___2 = debug_lockdep_rcu_enabled();
  if (tmp___2 != 0 && ! __warned___0) {
    tmp___3 = rcu_read_lock_sched_held___1();
    if (tmp___3 == 0) {
      __warned___0 = 1;
      lockdep_rcu_suspicious("drivers/net/wireless/iwlwifi/dvm/../iwl-devtrace-io.h",
                             50, "suspicious rcu_dereference_check() usage");
    } else {

    }
  } else {

  }
  rcu_read_unlock_sched_notrace();
  return;
}
}
__inline static void trace_iwlwifi_dev_iowrite32___1(struct device  const  *dev ,
                                                     u32 offs , u32 val ) 
{ 
  struct tracepoint_func *it_func_ptr ;
  void *it_func ;
  void *__data ;
  struct tracepoint_func *________p1 ;
  struct tracepoint_func *_________p1 ;
  union __anonunion___u_394 __u ;
  bool __warned ;
  int tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  struct tracepoint_func *________p1___0 ;
  struct tracepoint_func *_________p1___0 ;
  union __anonunion___u_396 __u___0 ;
  bool __warned___0 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  tmp___1 = static_key_false___1(& __tracepoint_iwlwifi_dev_iowrite32.key);
  if ((int )tmp___1) {
    rcu_read_lock_sched_notrace();
    __read_once_size((void const volatile   *)(& __tracepoint_iwlwifi_dev_iowrite32.funcs),
                     (void *)(& __u.__c), 8);
    _________p1 = __u.__val;
    ________p1 = _________p1;
    tmp = debug_lockdep_rcu_enabled();
    if (tmp != 0 && ! __warned) {
      tmp___0 = rcu_read_lock_sched_held___1();
      if (tmp___0 == 0) {
        __warned = 1;
        lockdep_rcu_suspicious("drivers/net/wireless/iwlwifi/dvm/../iwl-devtrace-io.h",
                               84, "suspicious rcu_dereference_check() usage");
      } else {

      }
    } else {

    }
    it_func_ptr = ________p1;
    if ((unsigned long )it_func_ptr != (unsigned long )((struct tracepoint_func *)0)) {
      ldv_51254: 
      it_func = it_func_ptr->func;
      __data = it_func_ptr->data;
      (*((void (*)(void * , struct device  const  * , u32  , u32  ))it_func))(__data,
                                                                              dev,
                                                                              offs,
                                                                              val);
      it_func_ptr = it_func_ptr + 1;
      if ((unsigned long )it_func_ptr->func != (unsigned long )((void *)0)) {
        goto ldv_51254;
      } else {

      }

    } else {

    }
    rcu_read_unlock_sched_notrace();
  } else {

  }
  rcu_read_lock_sched_notrace();
  __read_once_size((void const volatile   *)(& __tracepoint_iwlwifi_dev_iowrite32.funcs),
                   (void *)(& __u___0.__c), 8);
  _________p1___0 = __u___0.__val;
  ________p1___0 = _________p1___0;
  tmp___2 = debug_lockdep_rcu_enabled();
  if (tmp___2 != 0 && ! __warned___0) {
    tmp___3 = rcu_read_lock_sched_held___1();
    if (tmp___3 == 0) {
      __warned___0 = 1;
      lockdep_rcu_suspicious("drivers/net/wireless/iwlwifi/dvm/../iwl-devtrace-io.h",
                             84, "suspicious rcu_dereference_check() usage");
    } else {

    }
  } else {

  }
  rcu_read_unlock_sched_notrace();
  return;
}
}
__inline static void iwl_write32___1(struct iwl_trans *trans , u32 ofs , u32 val ) 
{ 


  {
  trace_iwlwifi_dev_iowrite32___1((struct device  const  *)trans->dev, ofs, val);
  iwl_trans_write32(trans, ofs, val);
  return;
}
}
__inline static u32 iwl_read32___0(struct iwl_trans *trans , u32 ofs ) 
{ 
  u32 val ;
  u32 tmp ;

  {
  tmp = iwl_trans_read32(trans, ofs);
  val = tmp;
  trace_iwlwifi_dev_ioread32___0((struct device  const  *)trans->dev, ofs, val);
  return (val);
}
}
u8 iwl_tt_current_power_mode(struct iwl_priv *priv ) ;
bool iwl_tt_is_low_power_state(struct iwl_priv *priv ) ;
enum iwl_antenna_ok iwl_rx_ant_restriction(struct iwl_priv *priv ) ;
void iwl_tt_enter_ct_kill(struct iwl_priv *priv ) ;
void iwl_tt_exit_ct_kill(struct iwl_priv *priv ) ;
static struct iwl_tt_trans  const  tt_range_0[3U]  = {      {0, 0U, 104U}, 
        {1, 105U, 113U}, 
        {3, 114U, 4294967295U}};
static struct iwl_tt_trans  const  tt_range_1[3U]  = {      {0, 0U, 95U}, 
        {2, 110U, 113U}, 
        {3, 114U, 4294967295U}};
static struct iwl_tt_trans  const  tt_range_2[3U]  = {      {1, 0U, 100U}, 
        {3, 114U, 4294967295U}, 
        {3, 114U, 4294967295U}};
static struct iwl_tt_trans  const  tt_range_3[3U]  = {      {0, 0U, 95U}, 
        {3, 96U, 4294967295U}, 
        {3, 96U, 4294967295U}};
static struct iwl_tt_restriction  const  restriction_range[4U]  = {      {2, 2, 1}, 
        {1, 2, 1}, 
        {1, 1, 0}, 
        {0, 0, 0}};
bool iwl_tt_is_low_power_state(struct iwl_priv *priv ) 
{ 
  struct iwl_tt_mgmt *tt ;

  {
  tt = & priv->thermal_throttle;
  if ((unsigned int )tt->state != 0U) {
    return (1);
  } else {

  }
  return (0);
}
}
u8 iwl_tt_current_power_mode(struct iwl_priv *priv ) 
{ 
  struct iwl_tt_mgmt *tt ;

  {
  tt = & priv->thermal_throttle;
  return (tt->tt_power_mode);
}
}
bool iwl_ht_enabled(struct iwl_priv *priv ) 
{ 
  struct iwl_tt_mgmt *tt ;
  struct iwl_tt_restriction *restriction ;

  {
  tt = & priv->thermal_throttle;
  if (! priv->thermal_throttle.advanced_tt) {
    return (1);
  } else {

  }
  restriction = tt->restriction + (unsigned long )tt->state;
  return (restriction->is_ht);
}
}
static bool iwl_within_ct_kill_margin(struct iwl_priv *priv ) 
{ 
  s32 temp ;
  bool within_margin ;

  {
  temp = priv->temperature;
  within_margin = 0;
  if (! priv->thermal_throttle.advanced_tt) {
    within_margin = temp + 3 > 109;
  } else {
    within_margin = temp + 3 > 113;
  }
  return (within_margin);
}
}
bool iwl_check_for_ct_kill(struct iwl_priv *priv ) 
{ 
  bool is_ct_kill ;
  bool tmp ;

  {
  is_ct_kill = 0;
  tmp = iwl_within_ct_kill_margin(priv);
  if ((int )tmp) {
    iwl_tt_enter_ct_kill(priv);
    is_ct_kill = 1;
  } else {

  }
  return (is_ct_kill);
}
}
enum iwl_antenna_ok iwl_tx_ant_restriction(struct iwl_priv *priv ) 
{ 
  struct iwl_tt_mgmt *tt ;
  struct iwl_tt_restriction *restriction ;

  {
  tt = & priv->thermal_throttle;
  if (! priv->thermal_throttle.advanced_tt) {
    return (2);
  } else {

  }
  restriction = tt->restriction + (unsigned long )tt->state;
  return (restriction->tx_stream);
}
}
enum iwl_antenna_ok iwl_rx_ant_restriction(struct iwl_priv *priv ) 
{ 
  struct iwl_tt_mgmt *tt ;
  struct iwl_tt_restriction *restriction ;

  {
  tt = & priv->thermal_throttle;
  if (! priv->thermal_throttle.advanced_tt) {
    return (2);
  } else {

  }
  restriction = tt->restriction + (unsigned long )tt->state;
  return (restriction->rx_stream);
}
}
static void iwl_tt_check_exit_ct_kill(unsigned long data ) 
{ 
  struct iwl_priv *priv ;
  struct iwl_tt_mgmt *tt ;
  unsigned long flags ;
  int tmp ;
  bool tmp___0 ;
  long tmp___1 ;

  {
  priv = (struct iwl_priv *)data;
  tt = & priv->thermal_throttle;
  tmp = constant_test_bit(5L, (unsigned long const volatile   *)(& priv->status));
  if (tmp != 0) {
    return;
  } else {

  }
  if ((unsigned int )tt->state == 3U) {
    if ((int )priv->thermal_throttle.ct_kill_toggle) {
      iwl_write32___1(priv->trans, 92U, 8U);
      priv->thermal_throttle.ct_kill_toggle = 0;
    } else {
      iwl_write32___1(priv->trans, 88U, 8U);
      priv->thermal_throttle.ct_kill_toggle = 1;
    }
    iwl_read32___0(priv->trans, 84U);
    tmp___0 = (*(((priv->trans)->ops)->grab_nic_access))(priv->trans, 0, & flags);
    tmp___1 = ldv__builtin_expect((long )tmp___0, 1L);
    if (tmp___1 != 0L) {
      iwl_trans_release_nic_access(priv->trans, & flags);
    } else {

    }
    __iwl_dbg(priv->dev, 512U, 0, "iwl_tt_check_exit_ct_kill", "schedule ct_kill exit timer\n");
    ldv_mod_timer_140(& priv->thermal_throttle.ct_kill_exit_tm, (unsigned long )jiffies + 1250UL);
  } else {

  }
  return;
}
}
static void iwl_perform_ct_kill_task(struct iwl_priv *priv , bool stop ) 
{ 


  {
  if ((int )stop) {
    __iwl_dbg(priv->dev, 512U, 0, "iwl_perform_ct_kill_task", "Stop all queues\n");
    if ((unsigned int )priv->mac80211_registered != 0U) {
      ieee80211_stop_queues(priv->hw);
    } else {

    }
    __iwl_dbg(priv->dev, 512U, 0, "iwl_perform_ct_kill_task", "Schedule 5 seconds CT_KILL Timer\n");
    ldv_mod_timer_141(& priv->thermal_throttle.ct_kill_exit_tm, (unsigned long )jiffies + 1250UL);
  } else {
    __iwl_dbg(priv->dev, 512U, 0, "iwl_perform_ct_kill_task", "Wake all queues\n");
    if ((unsigned int )priv->mac80211_registered != 0U) {
      ieee80211_wake_queues(priv->hw);
    } else {

    }
  }
  return;
}
}
static void iwl_tt_ready_for_ct_kill(unsigned long data ) 
{ 
  struct iwl_priv *priv ;
  struct iwl_tt_mgmt *tt ;
  int tmp ;

  {
  priv = (struct iwl_priv *)data;
  tt = & priv->thermal_throttle;
  tmp = constant_test_bit(5L, (unsigned long const volatile   *)(& priv->status));
  if (tmp != 0) {
    return;
  } else {

  }
  if ((unsigned int )tt->state != 3U) {
    __iwl_dbg(priv->dev, 512U, 0, "iwl_tt_ready_for_ct_kill", "entering CT_KILL state when temperature timer expired\n");
    tt->state = 3;
    set_bit(1L, (unsigned long volatile   *)(& priv->status));
    iwl_perform_ct_kill_task(priv, 1);
  } else {

  }
  return;
}
}
static void iwl_prepare_ct_kill_task(struct iwl_priv *priv ) 
{ 
  unsigned long tmp ;

  {
  __iwl_dbg(priv->dev, 512U, 0, "iwl_prepare_ct_kill_task", "Prepare to enter IWL_TI_CT_KILL\n");
  iwl_send_statistics_request(priv, 0, 0);
  tmp = msecs_to_jiffies(300U);
  ldv_mod_timer_142(& priv->thermal_throttle.ct_kill_waiting_tm, tmp + (unsigned long )jiffies);
  return;
}
}
static void iwl_legacy_tt_handler(struct iwl_priv *priv , s32 temp , bool force ) 
{ 
  struct iwl_tt_mgmt *tt ;
  enum iwl_tt_state old_state ;
  int tmp ;

  {
  tt = & priv->thermal_throttle;
  if ((tt->tt_previous_temp != 0 && tt->tt_previous_temp < temp) && temp - tt->tt_previous_temp > 5) {
    __iwl_dbg(priv->dev, 512U, 0, "iwl_legacy_tt_handler", "Temperature increase %d degree Celsius\n",
              temp - tt->tt_previous_temp);
  } else {

  }
  old_state = tt->state;
  if (temp > 109) {
    tt->state = 3;
  } else
  if (temp > 99) {
    tt->state = 2;
  } else
  if (temp > 89) {
    tt->state = 1;
  } else {
    tt->state = 0;
  }
  tt->tt_previous_temp = temp;
  ldv_del_timer_sync_143(& priv->thermal_throttle.ct_kill_waiting_tm);
  if ((unsigned int )tt->state != (unsigned int )old_state) {
    switch ((unsigned int )tt->state) {
    case 0U: ;
    goto ldv_55101;
    case 1U: 
    tt->tt_power_mode = 2U;
    goto ldv_55101;
    case 2U: 
    tt->tt_power_mode = 3U;
    goto ldv_55101;
    default: 
    tt->tt_power_mode = 4U;
    goto ldv_55101;
    }
    ldv_55101: 
    mutex_lock_nested(& priv->mutex, 0U);
    if ((unsigned int )old_state == 3U) {
      clear_bit(1L, (unsigned long volatile   *)(& priv->status));
    } else {

    }
    if ((unsigned int )tt->state != 3U) {
      tmp = iwl_power_update_mode(priv, 1);
      if (tmp != 0) {
        if ((unsigned int )old_state == 3U) {
          set_bit(1L, (unsigned long volatile   *)(& priv->status));
        } else {

        }
        tt->state = old_state;
        __iwl_err(priv->dev, 0, 0, "Cannot update power mode, TT state not updated\n");
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      if ((unsigned int )tt->state == 3U) {
        if ((int )force) {
          set_bit(1L, (unsigned long volatile   *)(& priv->status));
          iwl_perform_ct_kill_task(priv, 1);
        } else {
          iwl_prepare_ct_kill_task(priv);
          tt->state = old_state;
        }
      } else
      if ((unsigned int )old_state == 3U && (unsigned int )tt->state != 3U) {
        iwl_perform_ct_kill_task(priv, 0);
      } else {

      }
      __iwl_dbg(priv->dev, 512U, 0, "iwl_legacy_tt_handler", "Temperature state changed %u\n",
                (unsigned int )tt->state);
      __iwl_dbg(priv->dev, 512U, 0, "iwl_legacy_tt_handler", "Power Index change to %u\n",
                (int )tt->tt_power_mode);
    }
    mutex_unlock(& priv->mutex);
  } else {

  }
  return;
}
}
static void iwl_advance_tt_handler(struct iwl_priv *priv , s32 temp , bool force ) 
{ 
  struct iwl_tt_mgmt *tt ;
  int i ;
  bool changed ;
  enum iwl_tt_state old_state ;
  struct iwl_tt_trans *transaction ;
  struct iwl_rxon_context *ctx ;
  struct iwl_rxon_cmd *rxon ;
  bool tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  tt = & priv->thermal_throttle;
  changed = 0;
  old_state = tt->state;
  i = 0;
  goto ldv_55118;
  ldv_55117: 
  transaction = tt->transaction + (unsigned long )((unsigned int )old_state * 3U + (unsigned int )i);
  if ((u32 )temp >= transaction->tt_low && (u32 )temp <= transaction->tt_high) {
    if ((tt->tt_previous_temp != 0 && tt->tt_previous_temp < temp) && temp - tt->tt_previous_temp > 5) {
      __iwl_dbg(priv->dev, 512U, 0, "iwl_advance_tt_handler", "Temperature increase %d degree Celsius\n",
                temp - tt->tt_previous_temp);
    } else {

    }
    tt->tt_previous_temp = temp;
    if ((unsigned int )transaction->next_state != (unsigned int )old_state) {
      changed = 1;
      tt->state = transaction->next_state;
    } else {

    }
    goto ldv_55116;
  } else {

  }
  i = i + 1;
  ldv_55118: ;
  if (i <= 2) {
    goto ldv_55117;
  } else {

  }
  ldv_55116: 
  ldv_del_timer_sync_144(& priv->thermal_throttle.ct_kill_waiting_tm);
  if ((int )changed) {
    if ((unsigned int )tt->state != 0U) {
      tt->tt_power_mode = 4U;
      tmp = iwl_ht_enabled(priv);
      if (tmp) {
        tmp___0 = 0;
      } else {
        tmp___0 = 1;
      }
      if (tmp___0) {
        ctx = (struct iwl_rxon_context *)(& priv->contexts);
        goto ldv_55122;
        ldv_55121: ;
        if ((int )((unsigned long )priv->valid_contexts >> (int )ctx->ctxid) & 1) {
          rxon = & ctx->staging;
          rxon->flags = rxon->flags & 4164943871U;
        } else {

        }
        ctx = ctx + 1;
        ldv_55122: ;
        if ((unsigned long )((struct iwl_rxon_context *)(& priv->contexts) + 2UL) > (unsigned long )ctx) {
          goto ldv_55121;
        } else {

        }

      } else {
        iwl_set_rxon_ht(priv, & priv->current_ht_config);
      }
    } else {
      iwl_set_rxon_ht(priv, & priv->current_ht_config);
    }
    mutex_lock_nested(& priv->mutex, 0U);
    if ((unsigned int )old_state == 3U) {
      clear_bit(1L, (unsigned long volatile   *)(& priv->status));
    } else {

    }
    if ((unsigned int )tt->state != 3U) {
      tmp___1 = iwl_power_update_mode(priv, 1);
      if (tmp___1 != 0) {
        __iwl_err(priv->dev, 0, 0, "Cannot update power mode, TT state not updated\n");
        if ((unsigned int )old_state == 3U) {
          set_bit(1L, (unsigned long volatile   *)(& priv->status));
        } else {

        }
        tt->state = old_state;
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      __iwl_dbg(priv->dev, 512U, 0, "iwl_advance_tt_handler", "Thermal Throttling to new state: %u\n",
                (unsigned int )tt->state);
      if ((unsigned int )old_state != 3U && (unsigned int )tt->state == 3U) {
        if ((int )force) {
          __iwl_dbg(priv->dev, 512U, 0, "iwl_advance_tt_handler", "Enter IWL_TI_CT_KILL\n");
          set_bit(1L, (unsigned long volatile   *)(& priv->status));
          iwl_perform_ct_kill_task(priv, 1);
        } else {
          tt->state = old_state;
          iwl_prepare_ct_kill_task(priv);
        }
      } else
      if ((unsigned int )old_state == 3U && (unsigned int )tt->state != 3U) {
        __iwl_dbg(priv->dev, 512U, 0, "iwl_advance_tt_handler", "Exit IWL_TI_CT_KILL\n");
        iwl_perform_ct_kill_task(priv, 0);
      } else {

      }
    }
    mutex_unlock(& priv->mutex);
  } else {

  }
  return;
}
}
static void iwl_bg_ct_enter(struct work_struct *work ) 
{ 
  struct iwl_priv *priv ;
  struct work_struct  const  *__mptr ;
  struct iwl_tt_mgmt *tt ;
  int tmp ;
  int tmp___0 ;

  {
  __mptr = (struct work_struct  const  *)work;
  priv = (struct iwl_priv *)__mptr + 0xffffffffffffcf88UL;
  tt = & priv->thermal_throttle;
  tmp = constant_test_bit(5L, (unsigned long const volatile   *)(& priv->status));
  if (tmp != 0) {
    return;
  } else {

  }
  tmp___0 = iwl_is_ready(priv);
  if (tmp___0 == 0) {
    return;
  } else {

  }
  if ((unsigned int )tt->state != 3U) {
    __iwl_err(priv->dev, 0, 0, "Device reached critical temperature - ucode going to sleep!\n");
    if (! priv->thermal_throttle.advanced_tt) {
      iwl_legacy_tt_handler(priv, 110, 1);
    } else {
      iwl_advance_tt_handler(priv, 115, 1);
    }
  } else {

  }
  return;
}
}
static void iwl_bg_ct_exit(struct work_struct *work ) 
{ 
  struct iwl_priv *priv ;
  struct work_struct  const  *__mptr ;
  struct iwl_tt_mgmt *tt ;
  int tmp ;
  int tmp___0 ;

  {
  __mptr = (struct work_struct  const  *)work;
  priv = (struct iwl_priv *)__mptr + 0xffffffffffffcf38UL;
  tt = & priv->thermal_throttle;
  tmp = constant_test_bit(5L, (unsigned long const volatile   *)(& priv->status));
  if (tmp != 0) {
    return;
  } else {

  }
  tmp___0 = iwl_is_ready(priv);
  if (tmp___0 == 0) {
    return;
  } else {

  }
  ldv_del_timer_sync_145(& priv->thermal_throttle.ct_kill_exit_tm);
  if ((unsigned int )tt->state == 3U) {
    __iwl_err(priv->dev, 0, 0, "Device temperature below critical- ucode awake!\n");
    priv->temperature = 0;
    if (! priv->thermal_throttle.advanced_tt) {
      iwl_legacy_tt_handler(priv, 100, 1);
    } else {
      iwl_advance_tt_handler(priv, 95, 1);
    }
  } else {

  }
  return;
}
}
void iwl_tt_enter_ct_kill(struct iwl_priv *priv ) 
{ 
  int tmp ;

  {
  tmp = constant_test_bit(5L, (unsigned long const volatile   *)(& priv->status));
  if (tmp != 0) {
    return;
  } else {

  }
  __iwl_dbg(priv->dev, 512U, 0, "iwl_tt_enter_ct_kill", "Queueing critical temperature enter.\n");
  queue_work___4(priv->workqueue, & priv->ct_enter);
  return;
}
}
void iwl_tt_exit_ct_kill(struct iwl_priv *priv ) 
{ 
  int tmp ;

  {
  tmp = constant_test_bit(5L, (unsigned long const volatile   *)(& priv->status));
  if (tmp != 0) {
    return;
  } else {

  }
  __iwl_dbg(priv->dev, 512U, 0, "iwl_tt_exit_ct_kill", "Queueing critical temperature exit.\n");
  queue_work___4(priv->workqueue, & priv->ct_exit);
  return;
}
}
static void iwl_bg_tt_work(struct work_struct *work ) 
{ 
  struct iwl_priv *priv ;
  struct work_struct  const  *__mptr ;
  s32 temp ;
  int tmp ;

  {
  __mptr = (struct work_struct  const  *)work;
  priv = (struct iwl_priv *)__mptr + 0xffffffffffffcfd8UL;
  temp = priv->temperature;
  tmp = constant_test_bit(5L, (unsigned long const volatile   *)(& priv->status));
  if (tmp != 0) {
    return;
  } else {

  }
  if (! priv->thermal_throttle.advanced_tt) {
    iwl_legacy_tt_handler(priv, temp, 0);
  } else {
    iwl_advance_tt_handler(priv, temp, 0);
  }
  return;
}
}
void iwl_tt_handler(struct iwl_priv *priv ) 
{ 
  int tmp ;

  {
  tmp = constant_test_bit(5L, (unsigned long const volatile   *)(& priv->status));
  if (tmp != 0) {
    return;
  } else {

  }
  __iwl_dbg(priv->dev, 512U, 0, "iwl_tt_handler", "Queueing thermal throttling work.\n");
  queue_work___4(priv->workqueue, & priv->tt_work);
  return;
}
}
void iwl_tt_initialize(struct iwl_priv *priv ) 
{ 
  struct iwl_tt_mgmt *tt ;
  int size ;
  struct iwl_tt_trans *transaction ;
  struct lock_class_key __key ;
  atomic_long_t __constr_expr_0 ;
  struct lock_class_key __key___0 ;
  atomic_long_t __constr_expr_1 ;
  struct lock_class_key __key___1 ;
  atomic_long_t __constr_expr_2 ;
  void *tmp ;
  void *tmp___0 ;

  {
  tt = & priv->thermal_throttle;
  size = 36;
  __iwl_dbg(priv->dev, 512U, 0, "iwl_tt_initialize", "Initialize Thermal Throttling\n");
  memset((void *)tt, 0, 288UL);
  tt->state = 0;
  reg_timer_18(& priv->thermal_throttle.ct_kill_exit_tm, & iwl_tt_check_exit_ct_kill,
               (unsigned long )priv);
  reg_timer_18(& priv->thermal_throttle.ct_kill_waiting_tm, & iwl_tt_ready_for_ct_kill,
               (unsigned long )priv);
  __init_work(& priv->tt_work, 0);
  __constr_expr_0.counter = 137438953408L;
  priv->tt_work.data = __constr_expr_0;
  lockdep_init_map(& priv->tt_work.lockdep_map, "(&priv->tt_work)", & __key, 0);
  INIT_LIST_HEAD(& priv->tt_work.entry);
  priv->tt_work.func = & iwl_bg_tt_work;
  __init_work(& priv->ct_enter, 0);
  __constr_expr_1.counter = 137438953408L;
  priv->ct_enter.data = __constr_expr_1;
  lockdep_init_map(& priv->ct_enter.lockdep_map, "(&priv->ct_enter)", & __key___0,
                   0);
  INIT_LIST_HEAD(& priv->ct_enter.entry);
  priv->ct_enter.func = & iwl_bg_ct_enter;
  __init_work(& priv->ct_exit, 0);
  __constr_expr_2.counter = 137438953408L;
  priv->ct_exit.data = __constr_expr_2;
  lockdep_init_map(& priv->ct_exit.lockdep_map, "(&priv->ct_exit)", & __key___1, 0);
  INIT_LIST_HEAD(& priv->ct_exit.entry);
  priv->ct_exit.func = & iwl_bg_ct_exit;
  if ((int )(priv->lib)->adv_thermal_throttle) {
    __iwl_dbg(priv->dev, 512U, 0, "iwl_tt_initialize", "Advanced Thermal Throttling\n");
    tmp = kcalloc(4UL, 12UL, 208U);
    tt->restriction = (struct iwl_tt_restriction *)tmp;
    tmp___0 = kcalloc(12UL, 12UL, 208U);
    tt->transaction = (struct iwl_tt_trans *)tmp___0;
    if ((unsigned long )tt->restriction == (unsigned long )((struct iwl_tt_restriction *)0) || (unsigned long )tt->transaction == (unsigned long )((struct iwl_tt_trans *)0)) {
      __iwl_err(priv->dev, 0, 0, "Fallback to Legacy Throttling\n");
      priv->thermal_throttle.advanced_tt = 0;
      kfree((void const   *)tt->restriction);
      tt->restriction = (struct iwl_tt_restriction *)0;
      kfree((void const   *)tt->transaction);
      tt->transaction = (struct iwl_tt_trans *)0;
    } else {
      transaction = tt->transaction;
      memcpy((void *)transaction, (void const   *)(& tt_range_0), (size_t )size);
      transaction = tt->transaction + 3UL;
      memcpy((void *)transaction, (void const   *)(& tt_range_1), (size_t )size);
      transaction = tt->transaction + 6UL;
      memcpy((void *)transaction, (void const   *)(& tt_range_2), (size_t )size);
      transaction = tt->transaction + 9UL;
      memcpy((void *)transaction, (void const   *)(& tt_range_3), (size_t )size);
      size = 48;
      memcpy((void *)tt->restriction, (void const   *)(& restriction_range), (size_t )size);
      priv->thermal_throttle.advanced_tt = 1;
    }
  } else {
    __iwl_dbg(priv->dev, 512U, 0, "iwl_tt_initialize", "Legacy Thermal Throttling\n");
    priv->thermal_throttle.advanced_tt = 0;
  }
  return;
}
}
void iwl_tt_exit(struct iwl_priv *priv ) 
{ 
  struct iwl_tt_mgmt *tt ;

  {
  tt = & priv->thermal_throttle;
  ldv_del_timer_sync_146(& priv->thermal_throttle.ct_kill_exit_tm);
  ldv_del_timer_sync_147(& priv->thermal_throttle.ct_kill_waiting_tm);
  ldv_cancel_work_sync_148(& priv->tt_work);
  ldv_cancel_work_sync_149(& priv->ct_enter);
  ldv_cancel_work_sync_150(& priv->ct_exit);
  if ((int )priv->thermal_throttle.advanced_tt) {
    kfree((void const   *)tt->restriction);
    tt->restriction = (struct iwl_tt_restriction *)0;
    kfree((void const   *)tt->transaction);
    tt->transaction = (struct iwl_tt_trans *)0;
  } else {

  }
  return;
}
}
void activate_suitable_timer_18(struct timer_list *timer , unsigned long data ) 
{ 


  {
  if (ldv_timer_18_0 == 0 || ldv_timer_18_0 == 2) {
    ldv_timer_list_18_0 = timer;
    ldv_timer_list_18_0->data = data;
    ldv_timer_18_0 = 1;
    return;
  } else {

  }
  if (ldv_timer_18_1 == 0 || ldv_timer_18_1 == 2) {
    ldv_timer_list_18_1 = timer;
    ldv_timer_list_18_1->data = data;
    ldv_timer_18_1 = 1;
    return;
  } else {

  }
  if (ldv_timer_18_2 == 0 || ldv_timer_18_2 == 2) {
    ldv_timer_list_18_2 = timer;
    ldv_timer_list_18_2->data = data;
    ldv_timer_18_2 = 1;
    return;
  } else {

  }
  if (ldv_timer_18_3 == 0 || ldv_timer_18_3 == 2) {
    ldv_timer_list_18_3 = timer;
    ldv_timer_list_18_3->data = data;
    ldv_timer_18_3 = 1;
    return;
  } else {

  }
  return;
}
}
void timer_init_17(void) 
{ 


  {
  ldv_timer_17_0 = 0;
  ldv_timer_17_1 = 0;
  ldv_timer_17_2 = 0;
  ldv_timer_17_3 = 0;
  return;
}
}
void call_and_disable_work_10(struct work_struct *work ) 
{ 


  {
  if ((ldv_work_10_0 == 2 || ldv_work_10_0 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_10_0) {
    iwl_bg_ct_exit(work);
    ldv_work_10_0 = 1;
    return;
  } else {

  }
  if ((ldv_work_10_1 == 2 || ldv_work_10_1 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_10_1) {
    iwl_bg_ct_exit(work);
    ldv_work_10_1 = 1;
    return;
  } else {

  }
  if ((ldv_work_10_2 == 2 || ldv_work_10_2 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_10_2) {
    iwl_bg_ct_exit(work);
    ldv_work_10_2 = 1;
    return;
  } else {

  }
  if ((ldv_work_10_3 == 2 || ldv_work_10_3 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_10_3) {
    iwl_bg_ct_exit(work);
    ldv_work_10_3 = 1;
    return;
  } else {

  }
  return;
}
}
void work_init_9(void) 
{ 


  {
  ldv_work_9_0 = 0;
  ldv_work_9_1 = 0;
  ldv_work_9_2 = 0;
  ldv_work_9_3 = 0;
  return;
}
}
void invoke_work_8(void) 
{ 
  int tmp ;

  {
  tmp = __VERIFIER_nondet_int();
  switch (tmp) {
  case 0: ;
  if (ldv_work_8_0 == 2 || ldv_work_8_0 == 3) {
    ldv_work_8_0 = 4;
    iwl_bg_tt_work(ldv_work_struct_8_0);
    ldv_work_8_0 = 1;
  } else {

  }
  goto ldv_55195;
  case 1: ;
  if (ldv_work_8_1 == 2 || ldv_work_8_1 == 3) {
    ldv_work_8_1 = 4;
    iwl_bg_tt_work(ldv_work_struct_8_0);
    ldv_work_8_1 = 1;
  } else {

  }
  goto ldv_55195;
  case 2: ;
  if (ldv_work_8_2 == 2 || ldv_work_8_2 == 3) {
    ldv_work_8_2 = 4;
    iwl_bg_tt_work(ldv_work_struct_8_0);
    ldv_work_8_2 = 1;
  } else {

  }
  goto ldv_55195;
  case 3: ;
  if (ldv_work_8_3 == 2 || ldv_work_8_3 == 3) {
    ldv_work_8_3 = 4;
    iwl_bg_tt_work(ldv_work_struct_8_0);
    ldv_work_8_3 = 1;
  } else {

  }
  goto ldv_55195;
  default: 
  ldv_stop();
  }
  ldv_55195: ;
  return;
}
}
void disable_suitable_timer_17(struct timer_list *timer ) 
{ 


  {
  if (ldv_timer_17_0 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_17_0) {
    ldv_timer_17_0 = 0;
    return;
  } else {

  }
  if (ldv_timer_17_1 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_17_1) {
    ldv_timer_17_1 = 0;
    return;
  } else {

  }
  if (ldv_timer_17_2 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_17_2) {
    ldv_timer_17_2 = 0;
    return;
  } else {

  }
  if (ldv_timer_17_3 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_17_3) {
    ldv_timer_17_3 = 0;
    return;
  } else {

  }
  return;
}
}
int reg_timer_18(struct timer_list *timer , void (*function)(unsigned long  ) , unsigned long data ) 
{ 


  {
  if ((unsigned long )function == (unsigned long )(& iwl_tt_ready_for_ct_kill)) {
    activate_suitable_timer_18(timer, data);
  } else {

  }
  return (0);
}
}
void activate_pending_timer_18(struct timer_list *timer , unsigned long data , int pending_flag ) 
{ 


  {
  if ((unsigned long )ldv_timer_list_18_0 == (unsigned long )timer) {
    if (ldv_timer_18_0 == 2 || pending_flag != 0) {
      ldv_timer_list_18_0 = timer;
      ldv_timer_list_18_0->data = data;
      ldv_timer_18_0 = 1;
    } else {

    }
    return;
  } else {

  }
  if ((unsigned long )ldv_timer_list_18_1 == (unsigned long )timer) {
    if (ldv_timer_18_1 == 2 || pending_flag != 0) {
      ldv_timer_list_18_1 = timer;
      ldv_timer_list_18_1->data = data;
      ldv_timer_18_1 = 1;
    } else {

    }
    return;
  } else {

  }
  if ((unsigned long )ldv_timer_list_18_2 == (unsigned long )timer) {
    if (ldv_timer_18_2 == 2 || pending_flag != 0) {
      ldv_timer_list_18_2 = timer;
      ldv_timer_list_18_2->data = data;
      ldv_timer_18_2 = 1;
    } else {

    }
    return;
  } else {

  }
  if ((unsigned long )ldv_timer_list_18_3 == (unsigned long )timer) {
    if (ldv_timer_18_3 == 2 || pending_flag != 0) {
      ldv_timer_list_18_3 = timer;
      ldv_timer_list_18_3->data = data;
      ldv_timer_18_3 = 1;
    } else {

    }
    return;
  } else {

  }
  activate_suitable_timer_18(timer, data);
  return;
}
}
void invoke_work_10(void) 
{ 
  int tmp ;

  {
  tmp = __VERIFIER_nondet_int();
  switch (tmp) {
  case 0: ;
  if (ldv_work_10_0 == 2 || ldv_work_10_0 == 3) {
    ldv_work_10_0 = 4;
    iwl_bg_ct_exit(ldv_work_struct_10_0);
    ldv_work_10_0 = 1;
  } else {

  }
  goto ldv_55220;
  case 1: ;
  if (ldv_work_10_1 == 2 || ldv_work_10_1 == 3) {
    ldv_work_10_1 = 4;
    iwl_bg_ct_exit(ldv_work_struct_10_0);
    ldv_work_10_1 = 1;
  } else {

  }
  goto ldv_55220;
  case 2: ;
  if (ldv_work_10_2 == 2 || ldv_work_10_2 == 3) {
    ldv_work_10_2 = 4;
    iwl_bg_ct_exit(ldv_work_struct_10_0);
    ldv_work_10_2 = 1;
  } else {

  }
  goto ldv_55220;
  case 3: ;
  if (ldv_work_10_3 == 2 || ldv_work_10_3 == 3) {
    ldv_work_10_3 = 4;
    iwl_bg_ct_exit(ldv_work_struct_10_0);
    ldv_work_10_3 = 1;
  } else {

  }
  goto ldv_55220;
  default: 
  ldv_stop();
  }
  ldv_55220: ;
  return;
}
}
void ldv_timer_17(int state , struct timer_list *timer ) 
{ 


  {
  LDV_IN_INTERRUPT = 2;
  iwl_tt_check_exit_ct_kill(timer->data);
  LDV_IN_INTERRUPT = 1;
  return;
}
}
void choose_timer_18(void) 
{ 
  int tmp ;

  {
  tmp = __VERIFIER_nondet_int();
  switch (tmp) {
  case 0: ;
  if (ldv_timer_18_0 == 1) {
    ldv_timer_18_0 = 2;
    ldv_timer_18(ldv_timer_18_0, ldv_timer_list_18_0);
  } else {

  }
  goto ldv_55233;
  case 1: ;
  if (ldv_timer_18_1 == 1) {
    ldv_timer_18_1 = 2;
    ldv_timer_18(ldv_timer_18_1, ldv_timer_list_18_1);
  } else {

  }
  goto ldv_55233;
  case 2: ;
  if (ldv_timer_18_2 == 1) {
    ldv_timer_18_2 = 2;
    ldv_timer_18(ldv_timer_18_2, ldv_timer_list_18_2);
  } else {

  }
  goto ldv_55233;
  case 3: ;
  if (ldv_timer_18_3 == 1) {
    ldv_timer_18_3 = 2;
    ldv_timer_18(ldv_timer_18_3, ldv_timer_list_18_3);
  } else {

  }
  goto ldv_55233;
  default: 
  ldv_stop();
  }
  ldv_55233: ;
  return;
}
}
void disable_suitable_timer_18(struct timer_list *timer ) 
{ 


  {
  if (ldv_timer_18_0 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_18_0) {
    ldv_timer_18_0 = 0;
    return;
  } else {

  }
  if (ldv_timer_18_1 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_18_1) {
    ldv_timer_18_1 = 0;
    return;
  } else {

  }
  if (ldv_timer_18_2 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_18_2) {
    ldv_timer_18_2 = 0;
    return;
  } else {

  }
  if (ldv_timer_18_3 != 0 && (unsigned long )timer == (unsigned long )ldv_timer_list_18_3) {
    ldv_timer_18_3 = 0;
    return;
  } else {

  }
  return;
}
}
void work_init_8(void) 
{ 


  {
  ldv_work_8_0 = 0;
  ldv_work_8_1 = 0;
  ldv_work_8_2 = 0;
  ldv_work_8_3 = 0;
  return;
}
}
void call_and_disable_all_9(int state ) 
{ 


  {
  if (ldv_work_9_0 == state) {
    call_and_disable_work_9(ldv_work_struct_9_0);
  } else {

  }
  if (ldv_work_9_1 == state) {
    call_and_disable_work_9(ldv_work_struct_9_1);
  } else {

  }
  if (ldv_work_9_2 == state) {
    call_and_disable_work_9(ldv_work_struct_9_2);
  } else {

  }
  if (ldv_work_9_3 == state) {
    call_and_disable_work_9(ldv_work_struct_9_3);
  } else {

  }
  return;
}
}
void work_init_10(void) 
{ 


  {
  ldv_work_10_0 = 0;
  ldv_work_10_1 = 0;
  ldv_work_10_2 = 0;
  ldv_work_10_3 = 0;
  return;
}
}
void timer_init_18(void) 
{ 


  {
  ldv_timer_18_0 = 0;
  ldv_timer_18_1 = 0;
  ldv_timer_18_2 = 0;
  ldv_timer_18_3 = 0;
  return;
}
}
void call_and_disable_work_8(struct work_struct *work ) 
{ 


  {
  if ((ldv_work_8_0 == 2 || ldv_work_8_0 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_8_0) {
    iwl_bg_tt_work(work);
    ldv_work_8_0 = 1;
    return;
  } else {

  }
  if ((ldv_work_8_1 == 2 || ldv_work_8_1 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_8_1) {
    iwl_bg_tt_work(work);
    ldv_work_8_1 = 1;
    return;
  } else {

  }
  if ((ldv_work_8_2 == 2 || ldv_work_8_2 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_8_2) {
    iwl_bg_tt_work(work);
    ldv_work_8_2 = 1;
    return;
  } else {

  }
  if ((ldv_work_8_3 == 2 || ldv_work_8_3 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_8_3) {
    iwl_bg_tt_work(work);
    ldv_work_8_3 = 1;
    return;
  } else {

  }
  return;
}
}
void invoke_work_9(void) 
{ 
  int tmp ;

  {
  tmp = __VERIFIER_nondet_int();
  switch (tmp) {
  case 0: ;
  if (ldv_work_9_0 == 2 || ldv_work_9_0 == 3) {
    ldv_work_9_0 = 4;
    iwl_bg_ct_enter(ldv_work_struct_9_0);
    ldv_work_9_0 = 1;
  } else {

  }
  goto ldv_55264;
  case 1: ;
  if (ldv_work_9_1 == 2 || ldv_work_9_1 == 3) {
    ldv_work_9_1 = 4;
    iwl_bg_ct_enter(ldv_work_struct_9_0);
    ldv_work_9_1 = 1;
  } else {

  }
  goto ldv_55264;
  case 2: ;
  if (ldv_work_9_2 == 2 || ldv_work_9_2 == 3) {
    ldv_work_9_2 = 4;
    iwl_bg_ct_enter(ldv_work_struct_9_0);
    ldv_work_9_2 = 1;
  } else {

  }
  goto ldv_55264;
  case 3: ;
  if (ldv_work_9_3 == 2 || ldv_work_9_3 == 3) {
    ldv_work_9_3 = 4;
    iwl_bg_ct_enter(ldv_work_struct_9_0);
    ldv_work_9_3 = 1;
  } else {

  }
  goto ldv_55264;
  default: 
  ldv_stop();
  }
  ldv_55264: ;
  return;
}
}
void disable_work_8(struct work_struct *work ) 
{ 


  {
  if ((ldv_work_8_0 == 3 || ldv_work_8_0 == 2) && (unsigned long )ldv_work_struct_8_0 == (unsigned long )work) {
    ldv_work_8_0 = 1;
  } else {

  }
  if ((ldv_work_8_1 == 3 || ldv_work_8_1 == 2) && (unsigned long )ldv_work_struct_8_1 == (unsigned long )work) {
    ldv_work_8_1 = 1;
  } else {

  }
  if ((ldv_work_8_2 == 3 || ldv_work_8_2 == 2) && (unsigned long )ldv_work_struct_8_2 == (unsigned long )work) {
    ldv_work_8_2 = 1;
  } else {

  }
  if ((ldv_work_8_3 == 3 || ldv_work_8_3 == 2) && (unsigned long )ldv_work_struct_8_3 == (unsigned long )work) {
    ldv_work_8_3 = 1;
  } else {

  }
  return;
}
}
void activate_work_9(struct work_struct *work , int state ) 
{ 


  {
  if (ldv_work_9_0 == 0) {
    ldv_work_struct_9_0 = work;
    ldv_work_9_0 = state;
    return;
  } else {

  }
  if (ldv_work_9_1 == 0) {
    ldv_work_struct_9_1 = work;
    ldv_work_9_1 = state;
    return;
  } else {

  }
  if (ldv_work_9_2 == 0) {
    ldv_work_struct_9_2 = work;
    ldv_work_9_2 = state;
    return;
  } else {

  }
  if (ldv_work_9_3 == 0) {
    ldv_work_struct_9_3 = work;
    ldv_work_9_3 = state;
    return;
  } else {

  }
  return;
}
}
void ldv_timer_18(int state , struct timer_list *timer ) 
{ 


  {
  LDV_IN_INTERRUPT = 2;
  iwl_tt_ready_for_ct_kill(timer->data);
  LDV_IN_INTERRUPT = 1;
  return;
}
}
void choose_timer_17(void) 
{ 
  int tmp ;

  {
  tmp = __VERIFIER_nondet_int();
  switch (tmp) {
  case 0: ;
  if (ldv_timer_17_0 == 1) {
    ldv_timer_17_0 = 2;
    ldv_timer_17(ldv_timer_17_0, ldv_timer_list_17_0);
  } else {

  }
  goto ldv_55284;
  case 1: ;
  if (ldv_timer_17_1 == 1) {
    ldv_timer_17_1 = 2;
    ldv_timer_17(ldv_timer_17_1, ldv_timer_list_17_1);
  } else {

  }
  goto ldv_55284;
  case 2: ;
  if (ldv_timer_17_2 == 1) {
    ldv_timer_17_2 = 2;
    ldv_timer_17(ldv_timer_17_2, ldv_timer_list_17_2);
  } else {

  }
  goto ldv_55284;
  case 3: ;
  if (ldv_timer_17_3 == 1) {
    ldv_timer_17_3 = 2;
    ldv_timer_17(ldv_timer_17_3, ldv_timer_list_17_3);
  } else {

  }
  goto ldv_55284;
  default: 
  ldv_stop();
  }
  ldv_55284: ;
  return;
}
}
void call_and_disable_all_8(int state ) 
{ 


  {
  if (ldv_work_8_0 == state) {
    call_and_disable_work_8(ldv_work_struct_8_0);
  } else {

  }
  if (ldv_work_8_1 == state) {
    call_and_disable_work_8(ldv_work_struct_8_1);
  } else {

  }
  if (ldv_work_8_2 == state) {
    call_and_disable_work_8(ldv_work_struct_8_2);
  } else {

  }
  if (ldv_work_8_3 == state) {
    call_and_disable_work_8(ldv_work_struct_8_3);
  } else {

  }
  return;
}
}
void call_and_disable_work_9(struct work_struct *work ) 
{ 


  {
  if ((ldv_work_9_0 == 2 || ldv_work_9_0 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_9_0) {
    iwl_bg_ct_enter(work);
    ldv_work_9_0 = 1;
    return;
  } else {

  }
  if ((ldv_work_9_1 == 2 || ldv_work_9_1 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_9_1) {
    iwl_bg_ct_enter(work);
    ldv_work_9_1 = 1;
    return;
  } else {

  }
  if ((ldv_work_9_2 == 2 || ldv_work_9_2 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_9_2) {
    iwl_bg_ct_enter(work);
    ldv_work_9_2 = 1;
    return;
  } else {

  }
  if ((ldv_work_9_3 == 2 || ldv_work_9_3 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_9_3) {
    iwl_bg_ct_enter(work);
    ldv_work_9_3 = 1;
    return;
  } else {

  }
  return;
}
}
void activate_work_8(struct work_struct *work , int state ) 
{ 


  {
  if (ldv_work_8_0 == 0) {
    ldv_work_struct_8_0 = work;
    ldv_work_8_0 = state;
    return;
  } else {

  }
  if (ldv_work_8_1 == 0) {
    ldv_work_struct_8_1 = work;
    ldv_work_8_1 = state;
    return;
  } else {

  }
  if (ldv_work_8_2 == 0) {
    ldv_work_struct_8_2 = work;
    ldv_work_8_2 = state;
    return;
  } else {

  }
  if (ldv_work_8_3 == 0) {
    ldv_work_struct_8_3 = work;
    ldv_work_8_3 = state;
    return;
  } else {

  }
  return;
}
}
void activate_suitable_timer_17(struct timer_list *timer , unsigned long data ) 
{ 


  {
  if (ldv_timer_17_0 == 0 || ldv_timer_17_0 == 2) {
    ldv_timer_list_17_0 = timer;
    ldv_timer_list_17_0->data = data;
    ldv_timer_17_0 = 1;
    return;
  } else {

  }
  if (ldv_timer_17_1 == 0 || ldv_timer_17_1 == 2) {
    ldv_timer_list_17_1 = timer;
    ldv_timer_list_17_1->data = data;
    ldv_timer_17_1 = 1;
    return;
  } else {

  }
  if (ldv_timer_17_2 == 0 || ldv_timer_17_2 == 2) {
    ldv_timer_list_17_2 = timer;
    ldv_timer_list_17_2->data = data;
    ldv_timer_17_2 = 1;
    return;
  } else {

  }
  if (ldv_timer_17_3 == 0 || ldv_timer_17_3 == 2) {
    ldv_timer_list_17_3 = timer;
    ldv_timer_list_17_3->data = data;
    ldv_timer_17_3 = 1;
    return;
  } else {

  }
  return;
}
}
void disable_work_9(struct work_struct *work ) 
{ 


  {
  if ((ldv_work_9_0 == 3 || ldv_work_9_0 == 2) && (unsigned long )ldv_work_struct_9_0 == (unsigned long )work) {
    ldv_work_9_0 = 1;
  } else {

  }
  if ((ldv_work_9_1 == 3 || ldv_work_9_1 == 2) && (unsigned long )ldv_work_struct_9_1 == (unsigned long )work) {
    ldv_work_9_1 = 1;
  } else {

  }
  if ((ldv_work_9_2 == 3 || ldv_work_9_2 == 2) && (unsigned long )ldv_work_struct_9_2 == (unsigned long )work) {
    ldv_work_9_2 = 1;
  } else {

  }
  if ((ldv_work_9_3 == 3 || ldv_work_9_3 == 2) && (unsigned long )ldv_work_struct_9_3 == (unsigned long )work) {
    ldv_work_9_3 = 1;
  } else {

  }
  return;
}
}
void disable_work_10(struct work_struct *work ) 
{ 


  {
  if ((ldv_work_10_0 == 3 || ldv_work_10_0 == 2) && (unsigned long )ldv_work_struct_10_0 == (unsigned long )work) {
    ldv_work_10_0 = 1;
  } else {

  }
  if ((ldv_work_10_1 == 3 || ldv_work_10_1 == 2) && (unsigned long )ldv_work_struct_10_1 == (unsigned long )work) {
    ldv_work_10_1 = 1;
  } else {

  }
  if ((ldv_work_10_2 == 3 || ldv_work_10_2 == 2) && (unsigned long )ldv_work_struct_10_2 == (unsigned long )work) {
    ldv_work_10_2 = 1;
  } else {

  }
  if ((ldv_work_10_3 == 3 || ldv_work_10_3 == 2) && (unsigned long )ldv_work_struct_10_3 == (unsigned long )work) {
    ldv_work_10_3 = 1;
  } else {

  }
  return;
}
}
int reg_timer_17(struct timer_list *timer , void (*function)(unsigned long  ) , unsigned long data ) 
{ 


  {
  if ((unsigned long )function == (unsigned long )(& iwl_tt_check_exit_ct_kill)) {
    activate_suitable_timer_17(timer, data);
  } else {

  }
  return (0);
}
}
void activate_work_10(struct work_struct *work , int state ) 
{ 


  {
  if (ldv_work_10_0 == 0) {
    ldv_work_struct_10_0 = work;
    ldv_work_10_0 = state;
    return;
  } else {

  }
  if (ldv_work_10_1 == 0) {
    ldv_work_struct_10_1 = work;
    ldv_work_10_1 = state;
    return;
  } else {

  }
  if (ldv_work_10_2 == 0) {
    ldv_work_struct_10_2 = work;
    ldv_work_10_2 = state;
    return;
  } else {

  }
  if (ldv_work_10_3 == 0) {
    ldv_work_struct_10_3 = work;
    ldv_work_10_3 = state;
    return;
  } else {

  }
  return;
}
}
void activate_pending_timer_17(struct timer_list *timer , unsigned long data , int pending_flag ) 
{ 


  {
  if ((unsigned long )ldv_timer_list_17_0 == (unsigned long )timer) {
    if (ldv_timer_17_0 == 2 || pending_flag != 0) {
      ldv_timer_list_17_0 = timer;
      ldv_timer_list_17_0->data = data;
      ldv_timer_17_0 = 1;
    } else {

    }
    return;
  } else {

  }
  if ((unsigned long )ldv_timer_list_17_1 == (unsigned long )timer) {
    if (ldv_timer_17_1 == 2 || pending_flag != 0) {
      ldv_timer_list_17_1 = timer;
      ldv_timer_list_17_1->data = data;
      ldv_timer_17_1 = 1;
    } else {

    }
    return;
  } else {

  }
  if ((unsigned long )ldv_timer_list_17_2 == (unsigned long )timer) {
    if (ldv_timer_17_2 == 2 || pending_flag != 0) {
      ldv_timer_list_17_2 = timer;
      ldv_timer_list_17_2->data = data;
      ldv_timer_17_2 = 1;
    } else {

    }
    return;
  } else {

  }
  if ((unsigned long )ldv_timer_list_17_3 == (unsigned long )timer) {
    if (ldv_timer_17_3 == 2 || pending_flag != 0) {
      ldv_timer_list_17_3 = timer;
      ldv_timer_list_17_3->data = data;
      ldv_timer_17_3 = 1;
    } else {

    }
    return;
  } else {

  }
  activate_suitable_timer_17(timer, data);
  return;
}
}
void call_and_disable_all_10(int state ) 
{ 


  {
  if (ldv_work_10_0 == state) {
    call_and_disable_work_10(ldv_work_struct_10_0);
  } else {

  }
  if (ldv_work_10_1 == state) {
    call_and_disable_work_10(ldv_work_struct_10_1);
  } else {

  }
  if (ldv_work_10_2 == state) {
    call_and_disable_work_10(ldv_work_struct_10_2);
  } else {

  }
  if (ldv_work_10_3 == state) {
    call_and_disable_work_10(ldv_work_struct_10_3);
  } else {

  }
  return;
}
}
bool ldv_queue_work_on_135(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_7(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_delayed_work_on_136(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_7(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_work_on_137(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_7(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
void ldv_flush_workqueue_138(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
  flush_workqueue(ldv_func_arg1);
  call_and_disable_all_7(2);
  return;
}
}
bool ldv_queue_delayed_work_on_139(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_7(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
int ldv_mod_timer_140(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;

  {
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
  ldv_func_res = tmp;
  activate_pending_timer_18(ldv_func_arg1, ldv_func_arg2, 1);
  return (ldv_func_res);
}
}
int ldv_mod_timer_141(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___4 ldv_func_res ;
  int tmp ;

  {
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
  ldv_func_res = tmp;
  activate_pending_timer_18(ldv_func_arg1, ldv_func_arg2, 1);
  return (ldv_func_res);
}
}
int ldv_mod_timer_142(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___13 ldv_func_res ;
  int tmp ;

  {
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
  ldv_func_res = tmp;
  activate_pending_timer_18(ldv_func_arg1, ldv_func_arg2, 1);
  return (ldv_func_res);
}
}
int ldv_del_timer_sync_143(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___14 ldv_func_res ;
  int tmp ;

  {
  tmp = del_timer_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_suitable_timer_18(ldv_func_arg1);
  return (ldv_func_res);
}
}
int ldv_del_timer_sync_144(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___15 ldv_func_res ;
  int tmp ;

  {
  tmp = del_timer_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_suitable_timer_18(ldv_func_arg1);
  return (ldv_func_res);
}
}
int ldv_del_timer_sync_145(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___16 ldv_func_res ;
  int tmp ;

  {
  tmp = del_timer_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_suitable_timer_18(ldv_func_arg1);
  return (ldv_func_res);
}
}
int ldv_del_timer_sync_146(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___9 ldv_func_res ;
  int tmp ;

  {
  tmp = del_timer_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_suitable_timer_18(ldv_func_arg1);
  return (ldv_func_res);
}
}
int ldv_del_timer_sync_147(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___10 ldv_func_res ;
  int tmp ;

  {
  tmp = del_timer_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_suitable_timer_18(ldv_func_arg1);
  return (ldv_func_res);
}
}
bool ldv_cancel_work_sync_148(struct work_struct *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___17 ldv_func_res ;
  bool tmp ;

  {
  tmp = cancel_work_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_work_7(ldv_func_arg1);
  return (ldv_func_res);
}
}
bool ldv_cancel_work_sync_149(struct work_struct *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___18 ldv_func_res ;
  bool tmp ;

  {
  tmp = cancel_work_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_work_7(ldv_func_arg1);
  return (ldv_func_res);
}
}
bool ldv_cancel_work_sync_150(struct work_struct *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___19 ldv_func_res ;
  bool tmp ;

  {
  tmp = cancel_work_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_work_7(ldv_func_arg1);
  return (ldv_func_res);
}
}
__inline static long ldv__builtin_expect(long exp , long c ) ;
bool ldv_queue_work_on_171(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_work_on_173(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_delayed_work_on_172(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
bool ldv_queue_delayed_work_on_175(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
void ldv_flush_workqueue_174(struct workqueue_struct *ldv_func_arg1 ) ;
extern void free_pages(unsigned long  , unsigned int  ) ;
__inline static bool is_broadcast_ether_addr(u8 const   *addr ) 
{ 


  {
  return ((unsigned int )(((int )((unsigned short )*((u16 const   *)addr)) & (int )((unsigned short )*((u16 const   *)addr + 2U))) & (int )((unsigned short )*((u16 const   *)addr + 4U))) == 65535U);
}
}
__inline static bool ether_addr_equal(u8 const   *addr1 , u8 const   *addr2 ) 
{ 
  u32 fold ;

  {
  fold = ((unsigned int )*((u32 const   *)addr1) ^ (unsigned int )*((u32 const   *)addr2)) | (unsigned int )((int )((unsigned short )*((u16 const   *)addr1 + 4U)) ^ (int )((unsigned short )*((u16 const   *)addr2 + 4U)));
  return (fold == 0U);
}
}
__inline static void iwl_free_resp(struct iwl_host_cmd *cmd ) 
{ 


  {
  free_pages(cmd->_rx_page_addr, cmd->_rx_page_order);
  return;
}
}
u8 const   iwl_bcast_addr[6U] ;
int iwl_scan_cancel(struct iwl_priv *priv ) ;
void iwl_restore_stations(struct iwl_priv *priv , struct iwl_rxon_context *ctx ) ;
int iwl_get_free_ucode_key_offset(struct iwl_priv *priv ) ;
u8 iwl_prep_station(struct iwl_priv *priv , struct iwl_rxon_context *ctx , u8 const   *addr ,
                    bool is_ap , struct ieee80211_sta *sta ) ;
int iwl_add_sta_callback(struct iwl_priv *priv , struct iwl_rx_cmd_buffer *rxb , struct iwl_device_cmd *cmd ) ;
int iwl_restore_default_wep_keys(struct iwl_priv *priv , struct iwl_rxon_context *ctx ) ;
int iwl_update_bcast_station(struct iwl_priv *priv , struct iwl_rxon_context *ctx ) ;
int iwl_update_bcast_stations(struct iwl_priv *priv ) ;
u8 const   iwl_bcast_addr[6U]  = {      255U,      255U,      255U,      255U, 
        255U,      255U};
static int iwl_sta_ucode_activate(struct iwl_priv *priv , u8 sta_id ) 
{ 
  int __ret_warn_on ;
  int tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
  if (debug_locks != 0) {
    tmp = lock_is_held(& priv->sta_lock.__annonCompField18.__annonCompField17.dep_map);
    if (tmp == 0) {
      tmp___0 = 1;
    } else {
      tmp___0 = 0;
    }
  } else {
    tmp___0 = 0;
  }
  __ret_warn_on = tmp___0;
  tmp___1 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp___1 != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/08_1a/drivers/net/wireless/iwlwifi/dvm/sta.c",
                       39);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if ((unsigned int )sta_id > 15U) {
    __iwl_err(priv->dev, 0, 0, "invalid sta_id %u\n", (int )sta_id);
    return (-22);
  } else {

  }
  if (((unsigned long )priv->stations[(int )sta_id].used & 1UL) == 0UL) {
    __iwl_err(priv->dev, 0, 0, "ACTIVATE a non DRIVER active station id %u addr %pM\n",
              (int )sta_id, (u8 *)(& priv->stations[(int )sta_id].sta.sta.addr));
  } else {

  }
  if (((unsigned long )priv->stations[(int )sta_id].used & 2UL) != 0UL) {
    __iwl_dbg(priv->dev, 4097U, 0, "iwl_sta_ucode_activate", "STA id %u addr %pM already present in uCode (according to driver)\n",
              (int )sta_id, (u8 *)(& priv->stations[(int )sta_id].sta.sta.addr));
  } else {
    priv->stations[(int )sta_id].used = (u8 )((unsigned int )priv->stations[(int )sta_id].used | 2U);
    __iwl_dbg(priv->dev, 4097U, 0, "iwl_sta_ucode_activate", "Added STA id %u addr %pM to uCode\n",
              (int )sta_id, (u8 *)(& priv->stations[(int )sta_id].sta.sta.addr));
  }
  return (0);
}
}
static int iwl_process_add_sta_resp(struct iwl_priv *priv , struct iwl_addsta_cmd *addsta ,
                                    struct iwl_rx_packet *pkt ) 
{ 
  struct iwl_add_sta_resp *add_sta_resp ;
  u8 sta_id ;
  int ret ;

  {
  add_sta_resp = (struct iwl_add_sta_resp *)(& pkt->data);
  sta_id = addsta->sta.sta_id;
  ret = -5;
  if (((int )pkt->hdr.flags & 64) != 0) {
    __iwl_err(priv->dev, 0, 0, "Bad return from REPLY_ADD_STA (0x%08X)\n", (int )pkt->hdr.flags);
    return (ret);
  } else {

  }
  __iwl_dbg(priv->dev, 1U, 0, "iwl_process_add_sta_resp", "Processing response for adding station %u\n",
            (int )sta_id);
  spin_lock_bh(& priv->sta_lock);
  switch ((int )add_sta_resp->status) {
  case 1: 
  __iwl_dbg(priv->dev, 1U, 0, "iwl_process_add_sta_resp", "REPLY_ADD_STA PASSED\n");
  ret = iwl_sta_ucode_activate(priv, (int )sta_id);
  goto ldv_53655;
  case 2: 
  __iwl_err(priv->dev, 0, 0, "Adding station %d failed, no room in table.\n", (int )sta_id);
  goto ldv_53655;
  case 4: 
  __iwl_err(priv->dev, 0, 0, "Adding station %d failed, no block ack resource.\n",
            (int )sta_id);
  goto ldv_53655;
  case 8: 
  __iwl_err(priv->dev, 0, 0, "Attempting to modify non-existing station %d\n", (int )sta_id);
  goto ldv_53655;
  default: 
  __iwl_dbg(priv->dev, 4097U, 0, "iwl_process_add_sta_resp", "Received REPLY_ADD_STA:(0x%08X)\n",
            (int )add_sta_resp->status);
  goto ldv_53655;
  }
  ldv_53655: 
  __iwl_dbg(priv->dev, 1U, 0, "iwl_process_add_sta_resp", "%s station id %u addr %pM\n",
            (unsigned int )priv->stations[(int )sta_id].sta.mode == 1U ? (char *)"Modified" : (char *)"Added",
            (int )sta_id, (u8 *)(& priv->stations[(int )sta_id].sta.sta.addr));
  __iwl_dbg(priv->dev, 1U, 0, "iwl_process_add_sta_resp", "%s station according to cmd buffer %pM\n",
            (unsigned int )priv->stations[(int )sta_id].sta.mode == 1U ? (char *)"Modified" : (char *)"Added",
            (u8 *)(& addsta->sta.addr));
  spin_unlock_bh(& priv->sta_lock);
  return (ret);
}
}
int iwl_add_sta_callback(struct iwl_priv *priv , struct iwl_rx_cmd_buffer *rxb , struct iwl_device_cmd *cmd ) 
{ 
  struct iwl_rx_packet *pkt ;
  void *tmp ;
  int tmp___0 ;

  {
  tmp = rxb_addr(rxb);
  pkt = (struct iwl_rx_packet *)tmp;
  if ((unsigned long )cmd == (unsigned long )((struct iwl_device_cmd *)0)) {
    return (0);
  } else {

  }
  tmp___0 = iwl_process_add_sta_resp(priv, (struct iwl_addsta_cmd *)(& cmd->payload),
                                     pkt);
  return (tmp___0);
}
}
int iwl_send_add_sta(struct iwl_priv *priv , struct iwl_addsta_cmd *sta , u8 flags ) 
{ 
  int ret ;
  struct iwl_host_cmd cmd ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  u8 sta_id ;

  {
  ret = 0;
  cmd.data[0] = (void const   *)sta;
  tmp = 1U;
  while (1) {
    if (tmp >= 2U) {
      break;
    } else {

    }
    cmd.data[tmp] = 0;
    tmp = tmp + 1U;
  }
  cmd.resp_pkt = 0;
  cmd._rx_page_addr = 0UL;
  cmd._rx_page_order = 0U;
  cmd.handler_status = 0;
  cmd.flags = (unsigned int )flags;
  cmd.len[0] = 92U;
  tmp___0 = 1U;
  while (1) {
    if (tmp___0 >= 2U) {
      break;
    } else {

    }
    cmd.len[tmp___0] = (unsigned short)0;
    tmp___0 = tmp___0 + 1U;
  }
  cmd.dataflags[0] = (unsigned char)0;
  cmd.dataflags[1] = (unsigned char)0;
  cmd.id = 24U;
  sta_id = sta->sta.sta_id;
  __iwl_dbg(priv->dev, 1U, 0, "iwl_send_add_sta", "Adding sta %u (%pM) %ssynchronously\n",
            (int )sta_id, (u8 *)(& sta->sta.addr), (int )flags & 1 ? (char *)"a" : (char *)"");
  if (((int )flags & 1) == 0) {
    cmd.flags = cmd.flags | 2U;
    __might_sleep("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/08_1a/drivers/net/wireless/iwlwifi/dvm/sta.c",
                  155, 0);
  } else {

  }
  ret = iwl_dvm_send_cmd(priv, & cmd);
  if (ret != 0 || (int )flags & 1) {
    return (ret);
  } else {

  }
  iwl_free_resp(& cmd);
  if (cmd.handler_status != 0) {
    __iwl_err(priv->dev, 0, 0, "%s - error in the CMD response %d\n", "iwl_send_add_sta",
              cmd.handler_status);
  } else {

  }
  return (cmd.handler_status);
}
}
bool iwl_is_ht40_tx_allowed(struct iwl_priv *priv , struct iwl_rxon_context *ctx ,
                            struct ieee80211_sta *sta ) 
{ 


  {
  if (! ctx->ht.enabled || ! ctx->ht.is_40mhz) {
    return (0);
  } else {

  }
  if ((int )priv->disable_ht40) {
    return (0);
  } else {

  }
  if ((unsigned long )sta == (unsigned long )((struct ieee80211_sta *)0)) {
    return (1);
  } else {

  }
  return ((unsigned int )sta->bandwidth != 0U);
}
}
static void iwl_sta_calc_ht_flags(struct iwl_priv *priv , struct ieee80211_sta *sta ,
                                  struct iwl_rxon_context *ctx , __le32 *flags , __le32 *mask ) 
{ 
  struct ieee80211_sta_ht_cap *sta_ht_inf ;
  bool tmp ;

  {
  sta_ht_inf = & sta->ht_cap;
  *mask = 66715648U;
  *flags = 0U;
  if ((unsigned long )sta == (unsigned long )((struct ieee80211_sta *)0) || ! sta_ht_inf->ht_supported) {
    return;
  } else {

  }
  __iwl_dbg(priv->dev, 1U, 0, "iwl_sta_calc_ht_flags", "STA %pM SM PS mode: %s\n",
            (u8 *)(& sta->addr), (unsigned int )sta->smps_mode != 2U ? ((unsigned int )sta->smps_mode == 3U ? (char *)"dynamic" : (char *)"disabled") : (char *)"static");
  switch ((unsigned int )sta->smps_mode) {
  case 2U: 
  *flags = *flags | 4194304U;
  goto ldv_53690;
  case 3U: 
  *flags = *flags | 131072U;
  goto ldv_53690;
  case 1U: ;
  goto ldv_53690;
  default: 
  __iwl_warn(priv->dev, "Invalid MIMO PS mode %d\n", (unsigned int )sta->smps_mode);
  goto ldv_53690;
  }
  ldv_53690: 
  *flags = *flags | ((unsigned int )sta_ht_inf->ampdu_factor << 19);
  *flags = *flags | ((unsigned int )sta_ht_inf->ampdu_density << 23);
  tmp = iwl_is_ht40_tx_allowed(priv, ctx, sta);
  if ((int )tmp) {
    *flags = *flags | 2097152U;
  } else {

  }
  return;
}
}
int iwl_sta_update_ht(struct iwl_priv *priv , struct iwl_rxon_context *ctx , struct ieee80211_sta *sta ) 
{ 
  u8 sta_id ;
  int tmp ;
  __le32 flags ;
  __le32 mask ;
  struct iwl_addsta_cmd cmd ;
  bool __warned ;
  int __ret_warn_once ;
  int __ret_warn_on ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  int tmp___4 ;

  {
  tmp = iwl_sta_id(sta);
  sta_id = (u8 )tmp;
  __ret_warn_once = (unsigned int )sta_id == 255U;
  tmp___2 = ldv__builtin_expect(__ret_warn_once != 0, 0L);
  if (tmp___2 != 0L) {
    __ret_warn_on = ! __warned;
    tmp___0 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
    if (tmp___0 != 0L) {
      warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/08_1a/drivers/net/wireless/iwlwifi/dvm/sta.c",
                         248);
    } else {

    }
    tmp___1 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
    if (tmp___1 != 0L) {
      __warned = 1;
    } else {

    }
  } else {

  }
  tmp___3 = ldv__builtin_expect(__ret_warn_once != 0, 0L);
  if (tmp___3 != 0L) {
    return (-22);
  } else {

  }
  iwl_sta_calc_ht_flags(priv, sta, ctx, & flags, & mask);
  spin_lock_bh(& priv->sta_lock);
  priv->stations[(int )sta_id].sta.station_flags = priv->stations[(int )sta_id].sta.station_flags & ~ mask;
  priv->stations[(int )sta_id].sta.station_flags = priv->stations[(int )sta_id].sta.station_flags | flags;
  spin_unlock_bh(& priv->sta_lock);
  memset((void *)(& cmd), 0, 92UL);
  cmd.mode = 1U;
  cmd.station_flags_msk = mask;
  cmd.station_flags = flags;
  cmd.sta.sta_id = sta_id;
  tmp___4 = iwl_send_add_sta(priv, & cmd, 0);
  return (tmp___4);
}
}
static void iwl_set_ht_add_station(struct iwl_priv *priv , u8 index , struct ieee80211_sta *sta ,
                                   struct iwl_rxon_context *ctx ) 
{ 
  __le32 flags ;
  __le32 mask ;
  int __ret_warn_on ;
  int tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
  iwl_sta_calc_ht_flags(priv, sta, ctx, & flags, & mask);
  if (debug_locks != 0) {
    tmp = lock_is_held(& priv->sta_lock.__annonCompField18.__annonCompField17.dep_map);
    if (tmp == 0) {
      tmp___0 = 1;
    } else {
      tmp___0 = 0;
    }
  } else {
    tmp___0 = 0;
  }
  __ret_warn_on = tmp___0;
  tmp___1 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp___1 != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/08_1a/drivers/net/wireless/iwlwifi/dvm/sta.c",
                       275);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  priv->stations[(int )index].sta.station_flags = priv->stations[(int )index].sta.station_flags & ~ mask;
  priv->stations[(int )index].sta.station_flags = priv->stations[(int )index].sta.station_flags | flags;
  return;
}
}
u8 iwl_prep_station(struct iwl_priv *priv , struct iwl_rxon_context *ctx , u8 const   *addr ,
                    bool is_ap , struct ieee80211_sta *sta ) 
{ 
  struct iwl_station_entry *station ;
  int i ;
  u8 sta_id ;
  bool tmp ;
  bool tmp___0 ;
  long tmp___1 ;
  bool tmp___2 ;
  struct iwl_station_priv *sta_priv ;

  {
  sta_id = 255U;
  if ((int )is_ap) {
    sta_id = ctx->ap_sta_id;
  } else {
    tmp___0 = is_broadcast_ether_addr(addr);
    if ((int )tmp___0) {
      sta_id = ctx->bcast_sta_id;
    } else {
      i = 2;
      goto ldv_53730;
      ldv_53729: 
      tmp = ether_addr_equal((u8 const   *)(& priv->stations[i].sta.sta.addr), addr);
      if ((int )tmp) {
        sta_id = (u8 )i;
        goto ldv_53728;
      } else {

      }
      if ((unsigned int )priv->stations[i].used == 0U && (unsigned int )sta_id == 255U) {
        sta_id = (u8 )i;
      } else {

      }
      i = i + 1;
      ldv_53730: ;
      if (i <= 15) {
        goto ldv_53729;
      } else {

      }
      ldv_53728: ;
    }
  }
  tmp___1 = ldv__builtin_expect((unsigned int )sta_id == 255U, 0L);
  if (tmp___1 != 0L) {
    return (sta_id);
  } else {

  }
  if (((unsigned long )priv->stations[(int )sta_id].used & 4UL) != 0UL) {
    __iwl_dbg(priv->dev, 1U, 0, "iwl_prep_station", "STA %d already in process of being added.\n",
              (int )sta_id);
    return (sta_id);
  } else {

  }
  if ((int )priv->stations[(int )sta_id].used & 1 && ((unsigned long )priv->stations[(int )sta_id].used & 2UL) != 0UL) {
    tmp___2 = ether_addr_equal((u8 const   *)(& priv->stations[(int )sta_id].sta.sta.addr),
                               addr);
    if ((int )tmp___2) {
      __iwl_dbg(priv->dev, 4097U, 0, "iwl_prep_station", "STA %d (%pM) already added, not adding again.\n",
                (int )sta_id, addr);
      return (sta_id);
    } else {

    }
  } else {

  }
  station = (struct iwl_station_entry *)(& priv->stations) + (unsigned long )sta_id;
  station->used = 1U;
  __iwl_dbg(priv->dev, 4097U, 0, "iwl_prep_station", "Add STA to driver ID %d: %pM\n",
            (int )sta_id, addr);
  priv->num_stations = priv->num_stations + 1;
  memset((void *)(& station->sta), 0, 92UL);
  memcpy((void *)(& station->sta.sta.addr), (void const   *)addr, 6UL);
  station->sta.mode = 0U;
  station->sta.sta.sta_id = sta_id;
  station->sta.station_flags = ctx->station_flags;
  station->ctxid = (u8 )ctx->ctxid;
  if ((unsigned long )sta != (unsigned long )((struct ieee80211_sta *)0)) {
    sta_priv = (struct iwl_station_priv *)(& sta->drv_priv);
    sta_priv->ctx = ctx;
  } else {

  }
  iwl_set_ht_add_station(priv, (int )sta_id, sta, ctx);
  return (sta_id);
}
}
int iwl_add_station_common(struct iwl_priv *priv , struct iwl_rxon_context *ctx ,
                           u8 const   *addr , bool is_ap , struct ieee80211_sta *sta ,
                           u8 *sta_id_r ) 
{ 
  int ret ;
  u8 sta_id ;
  struct iwl_addsta_cmd sta_cmd ;

  {
  ret = 0;
  *sta_id_r = 0U;
  spin_lock_bh(& priv->sta_lock);
  sta_id = iwl_prep_station(priv, ctx, addr, (int )is_ap, sta);
  if ((unsigned int )sta_id == 255U) {
    __iwl_err(priv->dev, 0, 0, "Unable to prepare station %pM for addition\n", addr);
    spin_unlock_bh(& priv->sta_lock);
    return (-22);
  } else {

  }
  if (((unsigned long )priv->stations[(int )sta_id].used & 4UL) != 0UL) {
    __iwl_dbg(priv->dev, 1U, 0, "iwl_add_station_common", "STA %d already in process of being added.\n",
              (int )sta_id);
    spin_unlock_bh(& priv->sta_lock);
    return (-17);
  } else {

  }
  if ((int )priv->stations[(int )sta_id].used & 1 && ((unsigned long )priv->stations[(int )sta_id].used & 2UL) != 0UL) {
    __iwl_dbg(priv->dev, 4097U, 0, "iwl_add_station_common", "STA %d (%pM) already added, not adding again.\n",
              (int )sta_id, addr);
    spin_unlock_bh(& priv->sta_lock);
    return (-17);
  } else {

  }
  priv->stations[(int )sta_id].used = (u8 )((unsigned int )priv->stations[(int )sta_id].used | 4U);
  memcpy((void *)(& sta_cmd), (void const   *)(& priv->stations[(int )sta_id].sta),
           92UL);
  spin_unlock_bh(& priv->sta_lock);
  ret = iwl_send_add_sta(priv, & sta_cmd, 0);
  if (ret != 0) {
    spin_lock_bh(& priv->sta_lock);
    __iwl_err(priv->dev, 0, 0, "Adding station %pM failed.\n", (u8 *)(& priv->stations[(int )sta_id].sta.sta.addr));
    priv->stations[(int )sta_id].used = (unsigned int )priv->stations[(int )sta_id].used & 254U;
    priv->stations[(int )sta_id].used = (unsigned int )priv->stations[(int )sta_id].used & 251U;
    spin_unlock_bh(& priv->sta_lock);
  } else {

  }
  *sta_id_r = sta_id;
  return (ret);
}
}
static void iwl_sta_ucode_deactivate(struct iwl_priv *priv , u8 sta_id ) 
{ 
  int __ret_warn_on ;
  int tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
  if (debug_locks != 0) {
    tmp = lock_is_held(& priv->sta_lock.__annonCompField18.__annonCompField17.dep_map);
    if (tmp == 0) {
      tmp___0 = 1;
    } else {
      tmp___0 = 0;
    }
  } else {
    tmp___0 = 0;
  }
  __ret_warn_on = tmp___0;
  tmp___1 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp___1 != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/08_1a/drivers/net/wireless/iwlwifi/dvm/sta.c",
                       434);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (((unsigned long )priv->stations[(int )sta_id].used & 3UL) != 2UL) {
    __iwl_err(priv->dev, 0, 0, "removed non active STA %u\n", (int )sta_id);
  } else {

  }
  priv->stations[(int )sta_id].used = (unsigned int )priv->stations[(int )sta_id].used & 253U;
  memset((void *)(& priv->stations) + (unsigned long )sta_id, 0, 104UL);
  __iwl_dbg(priv->dev, 4097U, 0, "iwl_sta_ucode_deactivate", "Removed STA %u\n", (int )sta_id);
  return;
}
}
static int iwl_send_remove_station(struct iwl_priv *priv , u8 const   *addr , int sta_id ,
                                   bool temporary ) 
{ 
  struct iwl_rx_packet *pkt ;
  int ret ;
  struct iwl_rem_sta_cmd rm_sta_cmd ;
  struct iwl_host_cmd cmd ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  struct iwl_rem_sta_resp *rem_sta_resp ;

  {
  cmd.data[0] = (void const   *)(& rm_sta_cmd);
  tmp = 1U;
  while (1) {
    if (tmp >= 2U) {
      break;
    } else {

    }
    cmd.data[tmp] = 0;
    tmp = tmp + 1U;
  }
  cmd.resp_pkt = 0;
  cmd._rx_page_addr = 0UL;
  cmd._rx_page_order = 0U;
  cmd.handler_status = 0;
  cmd.flags = 0U;
  cmd.len[0] = 12U;
  tmp___0 = 1U;
  while (1) {
    if (tmp___0 >= 2U) {
      break;
    } else {

    }
    cmd.len[tmp___0] = (unsigned short)0;
    tmp___0 = tmp___0 + 1U;
  }
  cmd.dataflags[0] = (unsigned char)0;
  cmd.dataflags[1] = (unsigned char)0;
  cmd.id = 25U;
  memset((void *)(& rm_sta_cmd), 0, 12UL);
  rm_sta_cmd.num_sta = 1U;
  memcpy((void *)(& rm_sta_cmd.addr), (void const   *)addr, 6UL);
  cmd.flags = cmd.flags | 2U;
  ret = iwl_dvm_send_cmd(priv, & cmd);
  if (ret != 0) {
    return (ret);
  } else {

  }
  pkt = cmd.resp_pkt;
  if (((int )pkt->hdr.flags & 64) != 0) {
    __iwl_err(priv->dev, 0, 0, "Bad return from REPLY_REMOVE_STA (0x%08X)\n", (int )pkt->hdr.flags);
    ret = -5;
  } else {

  }
  if (ret == 0) {
    rem_sta_resp = (struct iwl_rem_sta_resp *)(& pkt->data);
    switch ((int )rem_sta_resp->status) {
    case 1: ;
    if (! temporary) {
      spin_lock_bh(& priv->sta_lock);
      iwl_sta_ucode_deactivate(priv, (int )((u8 )sta_id));
      spin_unlock_bh(& priv->sta_lock);
    } else {

    }
    __iwl_dbg(priv->dev, 4097U, 0, "iwl_send_remove_station", "REPLY_REMOVE_STA PASSED\n");
    goto ldv_53765;
    default: 
    ret = -5;
    __iwl_err(priv->dev, 0, 0, "REPLY_REMOVE_STA failed\n");
    goto ldv_53765;
    }
    ldv_53765: ;
  } else {

  }
  iwl_free_resp(& cmd);
  return (ret);
}
}
int iwl_remove_station(struct iwl_priv *priv , u8 const   sta_id , u8 const   *addr ) 
{ 
  u8 tid ;
  int tmp ;
  int __ret_warn_on ;
  long tmp___0 ;
  long tmp___1 ;
  int __ret_warn_on___0 ;
  long tmp___2 ;
  long tmp___3 ;
  int tmp___4 ;

  {
  tmp = iwl_is_ready(priv);
  if (tmp == 0) {
    __iwl_dbg(priv->dev, 1U, 0, "iwl_remove_station", "Unable to remove station %pM, device not ready.\n",
              addr);
    return (0);
  } else {

  }
  __iwl_dbg(priv->dev, 4097U, 0, "iwl_remove_station", "Removing STA from driver:%d  %pM\n",
            (int )sta_id, addr);
  __ret_warn_on = (unsigned int )((unsigned char )sta_id) == 255U;
  tmp___0 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp___0 != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/08_1a/drivers/net/wireless/iwlwifi/dvm/sta.c",
                       525);
  } else {

  }
  tmp___1 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp___1 != 0L) {
    return (-22);
  } else {

  }
  spin_lock_bh(& priv->sta_lock);
  if (((unsigned long )priv->stations[(int )sta_id].used & 1UL) == 0UL) {
    __iwl_dbg(priv->dev, 1U, 0, "iwl_remove_station", "Removing %pM but non DRIVER active\n",
              addr);
    goto out_err;
  } else {

  }
  if (((unsigned long )priv->stations[(int )sta_id].used & 2UL) == 0UL) {
    __iwl_dbg(priv->dev, 1U, 0, "iwl_remove_station", "Removing %pM but non UCODE active\n",
              addr);
    goto out_err;
  } else {

  }
  if (((unsigned long )priv->stations[(int )sta_id].used & 8UL) != 0UL) {
    kfree((void const   *)priv->stations[(int )sta_id].lq);
    priv->stations[(int )sta_id].lq = (struct iwl_link_quality_cmd *)0;
  } else {

  }
  tid = 0U;
  goto ldv_53778;
  ldv_53777: 
  memset((void *)(& priv->tid_data) + ((unsigned long )sta_id + (unsigned long )tid),
           0, 20UL);
  tid = (u8 )((int )tid + 1);
  ldv_53778: ;
  if ((unsigned int )tid <= 7U) {
    goto ldv_53777;
  } else {

  }
  priv->stations[(int )sta_id].used = (unsigned int )priv->stations[(int )sta_id].used & 254U;
  priv->num_stations = priv->num_stations - 1;
  __ret_warn_on___0 = priv->num_stations < 0;
  tmp___2 = ldv__builtin_expect(__ret_warn_on___0 != 0, 0L);
  if (tmp___2 != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/08_1a/drivers/net/wireless/iwlwifi/dvm/sta.c",
                       555);
  } else {

  }
  tmp___3 = ldv__builtin_expect(__ret_warn_on___0 != 0, 0L);
  if (tmp___3 != 0L) {
    priv->num_stations = 0;
  } else {

  }
  spin_unlock_bh(& priv->sta_lock);
  tmp___4 = iwl_send_remove_station(priv, addr, (int )sta_id, 0);
  return (tmp___4);
  out_err: 
  spin_unlock_bh(& priv->sta_lock);
  return (-22);
}
}
void iwl_deactivate_station(struct iwl_priv *priv , u8 const   sta_id , u8 const   *addr ) 
{ 
  u8 tid ;
  int tmp ;
  bool __warned ;
  int __ret_warn_once ;
  int __ret_warn_on ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  bool __warned___0 ;
  int __ret_warn_once___0 ;
  int __ret_warn_on___0 ;
  long tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;
  bool __warned___1 ;
  int __ret_warn_once___1 ;
  int __ret_warn_on___1 ;
  long tmp___7 ;
  long tmp___8 ;
  long tmp___9 ;
  long tmp___10 ;

  {
  tmp = iwl_is_ready(priv);
  if (tmp == 0) {
    __iwl_dbg(priv->dev, 1U, 0, "iwl_deactivate_station", "Unable to remove station %pM, device not ready.\n",
              addr);
    return;
  } else {

  }
  __iwl_dbg(priv->dev, 4097U, 0, "iwl_deactivate_station", "Deactivating STA: %pM (%d)\n",
            addr, (int )sta_id);
  __ret_warn_once = (unsigned int )((unsigned char )sta_id) == 255U;
  tmp___2 = ldv__builtin_expect(__ret_warn_once != 0, 0L);
  if (tmp___2 != 0L) {
    __ret_warn_on = ! __warned;
    tmp___0 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
    if (tmp___0 != 0L) {
      warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/08_1a/drivers/net/wireless/iwlwifi/dvm/sta.c",
                         580);
    } else {

    }
    tmp___1 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
    if (tmp___1 != 0L) {
      __warned = 1;
    } else {

    }
  } else {

  }
  tmp___3 = ldv__builtin_expect(__ret_warn_once != 0, 0L);
  if (tmp___3 != 0L) {
    return;
  } else {

  }
  spin_lock_bh(& priv->sta_lock);
  __ret_warn_once___0 = ((unsigned long )priv->stations[(int )sta_id].used & 1UL) == 0UL;
  tmp___6 = ldv__builtin_expect(__ret_warn_once___0 != 0, 0L);
  if (tmp___6 != 0L) {
    __ret_warn_on___0 = ! __warned___0;
    tmp___4 = ldv__builtin_expect(__ret_warn_on___0 != 0, 0L);
    if (tmp___4 != 0L) {
      warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/08_1a/drivers/net/wireless/iwlwifi/dvm/sta.c",
                         585);
    } else {

    }
    tmp___5 = ldv__builtin_expect(__ret_warn_on___0 != 0, 0L);
    if (tmp___5 != 0L) {
      __warned___0 = 1;
    } else {

    }
  } else {

  }
  ldv__builtin_expect(__ret_warn_once___0 != 0, 0L);
  tid = 0U;
  goto ldv_53800;
  ldv_53799: 
  memset((void *)(& priv->tid_data) + ((unsigned long )sta_id + (unsigned long )tid),
           0, 20UL);
  tid = (u8 )((int )tid + 1);
  ldv_53800: ;
  if ((unsigned int )tid <= 7U) {
    goto ldv_53799;
  } else {

  }
  priv->stations[(int )sta_id].used = (unsigned int )priv->stations[(int )sta_id].used & 254U;
  priv->stations[(int )sta_id].used = (unsigned int )priv->stations[(int )sta_id].used & 251U;
  priv->num_stations = priv->num_stations - 1;
  __ret_warn_once___1 = priv->num_stations < 0;
  tmp___9 = ldv__builtin_expect(__ret_warn_once___1 != 0, 0L);
  if (tmp___9 != 0L) {
    __ret_warn_on___1 = ! __warned___1;
    tmp___7 = ldv__builtin_expect(__ret_warn_on___1 != 0, 0L);
    if (tmp___7 != 0L) {
      warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/08_1a/drivers/net/wireless/iwlwifi/dvm/sta.c",
                         596);
    } else {

    }
    tmp___8 = ldv__builtin_expect(__ret_warn_on___1 != 0, 0L);
    if (tmp___8 != 0L) {
      __warned___1 = 1;
    } else {

    }
  } else {

  }
  tmp___10 = ldv__builtin_expect(__ret_warn_once___1 != 0, 0L);
  if (tmp___10 != 0L) {
    priv->num_stations = 0;
  } else {

  }
  spin_unlock_bh(& priv->sta_lock);
  return;
}
}
static void iwl_sta_fill_lq(struct iwl_priv *priv , struct iwl_rxon_context *ctx ,
                            u8 sta_id , struct iwl_link_quality_cmd *link_cmd ) 
{ 
  int i ;
  int r ;
    klee_make_symbolic(&r, sizeof(int), "r");
  u32 rate_flags ;
  __le32 rate_n_flags ;
  int __ret_warn_on ;
  int tmp ;
  int tmp___0 ;
  long tmp___1 ;
  u8 tmp___2 ;
  u8 tmp___3 ;
  u8 tmp___4 ;

  {
  rate_flags = 0U;
  if (debug_locks != 0) {
    tmp = lock_is_held(& priv->mutex.dep_map);
    if (tmp == 0) {
      tmp___0 = 1;
    } else {
      tmp___0 = 0;
    }
  } else {
    tmp___0 = 0;
  }
  __ret_warn_on = tmp___0;
  tmp___1 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp___1 != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/08_1a/drivers/net/wireless/iwlwifi/dvm/sta.c",
                       609);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  memset((void *)link_cmd, 0, 88UL);
  if ((unsigned int )priv->band == 1U) {
    r = 4;
  } else
  if (((unsigned long )ctx != (unsigned long )((struct iwl_rxon_context *)0) && (unsigned long )ctx->vif != (unsigned long )((struct ieee80211_vif *)0)) && (int )(ctx->vif)->p2p) {
    r = 4;
  } else {
    r = 0;
  }
  if (r >= 0 && r <= 3) {
    rate_flags = rate_flags | 512U;
  } else {

  }
  tmp___2 = first_antenna((int )(priv->nvm_data)->valid_tx_ant);
  rate_flags = (u32 )((int )tmp___2 << 14) | rate_flags;
  rate_n_flags = iwl_hw_set_rate_n_flags((int )iwl_rates[r].plcp, rate_flags);
  i = 0;
  goto ldv_53820;
  ldv_53819: 
  link_cmd->rs_table[i].rate_n_flags = rate_n_flags;
  i = i + 1;
  ldv_53820: ;
  if (i <= 15) {
    goto ldv_53819;
  } else {

  }
  link_cmd->general_params.single_stream_ant_msk = first_antenna((int )(priv->nvm_data)->valid_tx_ant);
  tmp___3 = first_antenna((int )(priv->nvm_data)->valid_tx_ant);
  link_cmd->general_params.dual_stream_ant_msk = (u8 )((int )((signed char )(priv->nvm_data)->valid_tx_ant) & ~ ((int )((signed char )tmp___3)));
  if ((unsigned int )link_cmd->general_params.dual_stream_ant_msk == 0U) {
    link_cmd->general_params.dual_stream_ant_msk = 3U;
  } else {
    tmp___4 = num_of_ant((int )(priv->nvm_data)->valid_tx_ant);
    if ((unsigned int )tmp___4 == 2U) {
      link_cmd->general_params.dual_stream_ant_msk = (priv->nvm_data)->valid_tx_ant;
    } else {

    }
  }
  link_cmd->agg_params.agg_dis_start_th = 3U;
  link_cmd->agg_params.agg_time_limit = 4000U;
  link_cmd->sta_id = sta_id;
  return;
}
}
void iwl_clear_ucode_stations(struct iwl_priv *priv , struct iwl_rxon_context *ctx ) 
{ 
  int i ;
  bool cleared ;

  {
  cleared = 0;
  __iwl_dbg(priv->dev, 1U, 0, "iwl_clear_ucode_stations", "Clearing ucode stations in driver\n");
  spin_lock_bh(& priv->sta_lock);
  i = 0;
  goto ldv_53831;
  ldv_53830: ;
  if ((unsigned long )ctx != (unsigned long )((struct iwl_rxon_context *)0) && (unsigned int )ctx->ctxid != (unsigned int )priv->stations[i].ctxid) {
    goto ldv_53829;
  } else {

  }
  if (((unsigned long )priv->stations[i].used & 2UL) != 0UL) {
    __iwl_dbg(priv->dev, 1U, 0, "iwl_clear_ucode_stations", "Clearing ucode active for station %d\n",
              i);
    priv->stations[i].used = (unsigned int )priv->stations[i].used & 253U;
    cleared = 1;
  } else {

  }
  ldv_53829: 
  i = i + 1;
  ldv_53831: ;
  if (i <= 15) {
    goto ldv_53830;
  } else {

  }
  spin_unlock_bh(& priv->sta_lock);
  if (! cleared) {
    __iwl_dbg(priv->dev, 1U, 0, "iwl_clear_ucode_stations", "No active stations found to be cleared\n");
  } else {

  }
  return;
}
}
void iwl_restore_stations(struct iwl_priv *priv , struct iwl_rxon_context *ctx ) 
{ 
  struct iwl_addsta_cmd sta_cmd ;
  struct iwl_link_quality_cmd zero_lq ;
  struct iwl_link_quality_cmd lq ;
  int i ;
  bool found ;
  int ret ;
  bool send_lq ;
  int tmp ;
  int tmp___0 ;

  {
  zero_lq.sta_id = (unsigned char)0;
  zero_lq.reserved1 = (unsigned char)0;
  zero_lq.control = (unsigned short)0;
  zero_lq.general_params.flags = (unsigned char)0;
  zero_lq.general_params.mimo_delimiter = (unsigned char)0;
  zero_lq.general_params.single_stream_ant_msk = (unsigned char)0;
  zero_lq.general_params.dual_stream_ant_msk = (unsigned char)0;
  zero_lq.general_params.start_rate_index[0] = (unsigned char)0;
  zero_lq.general_params.start_rate_index[1] = (unsigned char)0;
  zero_lq.general_params.start_rate_index[2] = (unsigned char)0;
  zero_lq.general_params.start_rate_index[3] = (unsigned char)0;
  zero_lq.agg_params.agg_time_limit = (unsigned short)0;
  zero_lq.agg_params.agg_dis_start_th = (unsigned char)0;
  zero_lq.agg_params.agg_frame_cnt_limit = (unsigned char)0;
  zero_lq.agg_params.reserved = 0U;
  zero_lq.rs_table[0].rate_n_flags = 0U;
  zero_lq.rs_table[1].rate_n_flags = 0U;
  zero_lq.rs_table[2].rate_n_flags = 0U;
  zero_lq.rs_table[3].rate_n_flags = 0U;
  zero_lq.rs_table[4].rate_n_flags = 0U;
  zero_lq.rs_table[5].rate_n_flags = 0U;
  zero_lq.rs_table[6].rate_n_flags = 0U;
  zero_lq.rs_table[7].rate_n_flags = 0U;
  zero_lq.rs_table[8].rate_n_flags = 0U;
  zero_lq.rs_table[9].rate_n_flags = 0U;
  zero_lq.rs_table[10].rate_n_flags = 0U;
  zero_lq.rs_table[11].rate_n_flags = 0U;
  zero_lq.rs_table[12].rate_n_flags = 0U;
  zero_lq.rs_table[13].rate_n_flags = 0U;
  zero_lq.rs_table[14].rate_n_flags = 0U;
  zero_lq.rs_table[15].rate_n_flags = 0U;
  zero_lq.reserved2 = 0U;
  found = 0;
  tmp = iwl_is_ready(priv);
  if (tmp == 0) {
    __iwl_dbg(priv->dev, 1U, 0, "iwl_restore_stations", "Not ready yet, not restoring any stations.\n");
    return;
  } else {

  }
  __iwl_dbg(priv->dev, 4097U, 0, "iwl_restore_stations", "Restoring all known stations ... start.\n");
  spin_lock_bh(& priv->sta_lock);
  i = 0;
  goto ldv_53847;
  ldv_53846: ;
  if ((unsigned int )ctx->ctxid != (unsigned int )priv->stations[i].ctxid) {
    goto ldv_53845;
  } else {

  }
  if ((int )priv->stations[i].used & 1 && ((unsigned long )priv->stations[i].used & 2UL) == 0UL) {
    __iwl_dbg(priv->dev, 4097U, 0, "iwl_restore_stations", "Restoring sta %pM\n",
              (u8 *)(& priv->stations[i].sta.sta.addr));
    priv->stations[i].sta.mode = 0U;
    priv->stations[i].used = (u8 )((unsigned int )priv->stations[i].used | 4U);
    found = 1;
  } else {

  }
  ldv_53845: 
  i = i + 1;
  ldv_53847: ;
  if (i <= 15) {
    goto ldv_53846;
  } else {

  }
  i = 0;
  goto ldv_53851;
  ldv_53850: ;
  if (((unsigned long )priv->stations[i].used & 4UL) != 0UL) {
    memcpy((void *)(& sta_cmd), (void const   *)(& priv->stations[i].sta), 92UL);
    send_lq = 0;
    if ((unsigned long )priv->stations[i].lq != (unsigned long )((struct iwl_link_quality_cmd *)0)) {
      if ((int )priv->wowlan) {
        iwl_sta_fill_lq(priv, ctx, (int )((u8 )i), & lq);
      } else {
        memcpy((void *)(& lq), (void const   *)priv->stations[i].lq, 88UL);
      }
      tmp___0 = memcmp((void const   *)(& lq), (void const   *)(& zero_lq), 88UL);
      if (tmp___0 != 0) {
        send_lq = 1;
      } else {

      }
    } else {

    }
    spin_unlock_bh(& priv->sta_lock);
    ret = iwl_send_add_sta(priv, & sta_cmd, 0);
    if (ret != 0) {
      spin_lock_bh(& priv->sta_lock);
      __iwl_err(priv->dev, 0, 0, "Adding station %pM failed.\n", (u8 *)(& priv->stations[i].sta.sta.addr));
      priv->stations[i].used = (unsigned int )priv->stations[i].used & 254U;
      priv->stations[i].used = (unsigned int )priv->stations[i].used & 251U;
      goto ldv_53849;
    } else {

    }
    if ((int )send_lq) {
      iwl_send_lq_cmd(priv, ctx, & lq, 0, 1);
    } else {

    }
    spin_lock_bh(& priv->sta_lock);
    priv->stations[i].used = (unsigned int )priv->stations[i].used & 251U;
  } else {

  }
  ldv_53849: 
  i = i + 1;
  ldv_53851: ;
  if (i <= 15) {
    goto ldv_53850;
  } else {

  }
  spin_unlock_bh(& priv->sta_lock);
  if (! found) {
    __iwl_dbg(priv->dev, 1U, 0, "iwl_restore_stations", "Restoring all known stations .... no stations to be restored.\n");
  } else {
    __iwl_dbg(priv->dev, 1U, 0, "iwl_restore_stations", "Restoring all known stations .... complete.\n");
  }
  return;
}
}
int iwl_get_free_ucode_key_offset(struct iwl_priv *priv ) 
{ 
  int i ;
  int tmp ;

  {
  i = 0;
  goto ldv_53858;
  ldv_53857: 
  tmp = test_and_set_bit((long )i, (unsigned long volatile   *)(& priv->ucode_key_table));
  if (tmp == 0) {
    return (i);
  } else {

  }
  i = i + 1;
  ldv_53858: ;
  if ((int )priv->sta_key_max_num > i) {
    goto ldv_53857;
  } else {

  }

  return (255);
}
}
void iwl_dealloc_bcast_stations(struct iwl_priv *priv ) 
{ 
  int i ;
  int __ret_warn_on ;
  long tmp ;
  long tmp___0 ;

  {
  spin_lock_bh(& priv->sta_lock);
  i = 0;
  goto ldv_53868;
  ldv_53867: ;
  if (((unsigned long )priv->stations[i].used & 16UL) == 0UL) {
    goto ldv_53864;
  } else {

  }
  priv->stations[i].used = (unsigned int )priv->stations[i].used & 253U;
  priv->num_stations = priv->num_stations - 1;
  __ret_warn_on = priv->num_stations < 0;
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/08_1a/drivers/net/wireless/iwlwifi/dvm/sta.c",
                       795);
  } else {

  }
  tmp___0 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp___0 != 0L) {
    priv->num_stations = 0;
  } else {

  }
  kfree((void const   *)priv->stations[i].lq);
  priv->stations[i].lq = (struct iwl_link_quality_cmd *)0;
  ldv_53864: 
  i = i + 1;
  ldv_53868: ;
  if (i <= 15) {
    goto ldv_53867;
  } else {

  }
  spin_unlock_bh(& priv->sta_lock);
  return;
}
}
static void iwl_dump_lq_cmd(struct iwl_priv *priv , struct iwl_link_quality_cmd *lq ) 
{ 
  int i ;

  {
  __iwl_dbg(priv->dev, 1048576U, 0, "iwl_dump_lq_cmd", "lq station id 0x%x\n", (int )lq->sta_id);
  __iwl_dbg(priv->dev, 1048576U, 0, "iwl_dump_lq_cmd", "lq ant 0x%X 0x%X\n", (int )lq->general_params.single_stream_ant_msk,
            (int )lq->general_params.dual_stream_ant_msk);
  i = 0;
  goto ldv_53877;
  ldv_53876: 
  __iwl_dbg(priv->dev, 1048576U, 0, "iwl_dump_lq_cmd", "lq index %d 0x%X\n", i, lq->rs_table[i].rate_n_flags);
  i = i + 1;
  ldv_53877: ;
  if (i <= 15) {
    goto ldv_53876;
  } else {

  }

  return;
}
}
static bool is_lq_table_valid(struct iwl_priv *priv , struct iwl_rxon_context *ctx ,
                              struct iwl_link_quality_cmd *lq ) 
{ 
  int i ;

  {
  if ((int )ctx->ht.enabled) {
    return (1);
  } else {

  }
  __iwl_dbg(priv->dev, 1U, 0, "is_lq_table_valid", "Channel %u is not an HT channel\n",
            (int )ctx->active.channel);
  i = 0;
  goto ldv_53887;
  ldv_53886: ;
  if ((lq->rs_table[i].rate_n_flags & 256U) != 0U) {
    __iwl_dbg(priv->dev, 1U, 0, "is_lq_table_valid", "index %d of LQ expects HT channel\n",
              i);
    return (0);
  } else {

  }
  i = i + 1;
  ldv_53887: ;
  if (i <= 15) {
    goto ldv_53886;
  } else {

  }

  return (1);
}
}
int iwl_send_lq_cmd(struct iwl_priv *priv , struct iwl_rxon_context *ctx , struct iwl_link_quality_cmd *lq ,
                    u8 flags , bool init ) 
{ 
  int ret ;
  struct iwl_host_cmd cmd ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  int __ret_warn_on ;
  long tmp___1 ;
  long tmp___2 ;
  int __ret_warn_on___0 ;
  long tmp___3 ;
  long tmp___4 ;
  bool tmp___5 ;

  {
  ret = 0;
  cmd.data[0] = (void const   *)lq;
  tmp = 1U;
  while (1) {
    if (tmp >= 2U) {
      break;
    } else {

    }
    cmd.data[tmp] = 0;
    tmp = tmp + 1U;
  }
  cmd.resp_pkt = 0;
  cmd._rx_page_addr = 0UL;
  cmd._rx_page_order = 0U;
  cmd.handler_status = 0;
  cmd.flags = (unsigned int )flags;
  cmd.len[0] = 88U;
  tmp___0 = 1U;
  while (1) {
    if (tmp___0 >= 2U) {
      break;
    } else {

    }
    cmd.len[tmp___0] = (unsigned short)0;
    tmp___0 = tmp___0 + 1U;
  }
  cmd.dataflags[0] = (unsigned char)0;
  cmd.dataflags[1] = (unsigned char)0;
  cmd.id = 78U;
  __ret_warn_on = (unsigned int )lq->sta_id == 255U;
  tmp___1 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp___1 != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/08_1a/drivers/net/wireless/iwlwifi/dvm/sta.c",
                       879);
  } else {

  }
  tmp___2 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp___2 != 0L) {
    return (-22);
  } else {

  }
  spin_lock_bh(& priv->sta_lock);
  if (((unsigned long )priv->stations[(int )lq->sta_id].used & 1UL) == 0UL) {
    spin_unlock_bh(& priv->sta_lock);
    return (-22);
  } else {

  }
  spin_unlock_bh(& priv->sta_lock);
  iwl_dump_lq_cmd(priv, lq);
  __ret_warn_on___0 = (int )init && (int )cmd.flags & 1;
  tmp___3 = ldv__builtin_expect(__ret_warn_on___0 != 0, 0L);
  if (tmp___3 != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/08_1a/drivers/net/wireless/iwlwifi/dvm/sta.c",
                       891);
  } else {

  }
  tmp___4 = ldv__builtin_expect(__ret_warn_on___0 != 0, 0L);
  if (tmp___4 != 0L) {
    return (-22);
  } else {

  }
  tmp___5 = is_lq_table_valid(priv, ctx, lq);
  if ((int )tmp___5) {
    ret = iwl_dvm_send_cmd(priv, & cmd);
  } else {
    ret = -22;
  }
  if ((int )cmd.flags & 1) {
    return (ret);
  } else {

  }
  if ((int )init) {
    __iwl_dbg(priv->dev, 1U, 0, "iwl_send_lq_cmd", "init LQ command complete, clearing sta addition status for sta %d\n",
              (int )lq->sta_id);
    spin_lock_bh(& priv->sta_lock);
    priv->stations[(int )lq->sta_id].used = (unsigned int )priv->stations[(int )lq->sta_id].used & 251U;
    spin_unlock_bh(& priv->sta_lock);
  } else {

  }
  return (ret);
}
}
static struct iwl_link_quality_cmd *iwl_sta_alloc_lq(struct iwl_priv *priv , struct iwl_rxon_context *ctx ,
                                                     u8 sta_id ) 
{ 
  struct iwl_link_quality_cmd *link_cmd ;
  void *tmp ;

  {
  tmp = kzalloc(88UL, 208U);
  link_cmd = (struct iwl_link_quality_cmd *)tmp;
  if ((unsigned long )link_cmd == (unsigned long )((struct iwl_link_quality_cmd *)0)) {
    __iwl_err(priv->dev, 0, 0, "Unable to allocate memory for LQ cmd.\n");
    return ((struct iwl_link_quality_cmd *)0);
  } else {

  }
  iwl_sta_fill_lq(priv, ctx, (int )sta_id, link_cmd);
  return (link_cmd);
}
}
int iwlagn_add_bssid_station(struct iwl_priv *priv , struct iwl_rxon_context *ctx ,
                             u8 const   *addr , u8 *sta_id_r ) 
{ 
  int ret ;
  u8 sta_id ;
  struct iwl_link_quality_cmd *link_cmd ;

  {
  if ((unsigned long )sta_id_r != (unsigned long )((u8 *)0U)) {
    *sta_id_r = 255U;
  } else {

  }
  ret = iwl_add_station_common(priv, ctx, addr, 0, (struct ieee80211_sta *)0, & sta_id);
  if (ret != 0) {
    __iwl_err(priv->dev, 0, 0, "Unable to add station %pM\n", addr);
    return (ret);
  } else {

  }
  if ((unsigned long )sta_id_r != (unsigned long )((u8 *)0U)) {
    *sta_id_r = sta_id;
  } else {

  }
  spin_lock_bh(& priv->sta_lock);
  priv->stations[(int )sta_id].used = (u8 )((unsigned int )priv->stations[(int )sta_id].used | 8U);
  spin_unlock_bh(& priv->sta_lock);
  link_cmd = iwl_sta_alloc_lq(priv, ctx, (int )sta_id);
  if ((unsigned long )link_cmd == (unsigned long )((struct iwl_link_quality_cmd *)0)) {
    __iwl_err(priv->dev, 0, 0, "Unable to initialize rate scaling for station %pM.\n",
              addr);
    return (-12);
  } else {

  }
  ret = iwl_send_lq_cmd(priv, ctx, link_cmd, 0, 1);
  if (ret != 0) {
    __iwl_err(priv->dev, 0, 0, "Link quality command failed (%d)\n", ret);
  } else {

  }
  spin_lock_bh(& priv->sta_lock);
  priv->stations[(int )sta_id].lq = link_cmd;
  spin_unlock_bh(& priv->sta_lock);
  return (0);
}
}
static int iwl_send_static_wepkey_cmd(struct iwl_priv *priv , struct iwl_rxon_context *ctx ,
                                      bool send_if_empty ) 
{ 
  int i ;
  int not_empty ;
    klee_make_symbolic(&not_empty, sizeof(int), "not_empty");
  u8 buff[100U] ;
  struct iwl_wep_cmd *wep_cmd ;
  size_t cmd_size ;
  struct iwl_host_cmd cmd ;
  unsigned int tmp ;
  int tmp___0 ;

  {
  not_empty = 0;
  wep_cmd = (struct iwl_wep_cmd *)(& buff);
  cmd_size = 4UL;
  cmd.data[0] = (void const   *)wep_cmd;
  tmp = 1U;
  while (1) {
    if (tmp >= 2U) {
      break;
    } else {

    }
    cmd.data[tmp] = 0;
    tmp = tmp + 1U;
  }
  cmd.resp_pkt = 0;
  cmd._rx_page_addr = 0UL;
  cmd._rx_page_order = 0U;
  cmd.handler_status = 0;
  cmd.flags = 0U;
  cmd.len[0] = (unsigned short)0;
  cmd.len[1] = (unsigned short)0;
  cmd.dataflags[0] = (unsigned char)0;
  cmd.dataflags[1] = (unsigned char)0;
  cmd.id = ctx->wep_key_cmd;
  __might_sleep("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/08_1a/drivers/net/wireless/iwlwifi/dvm/sta.c",
                1002, 0);
  memset((void *)wep_cmd, 0, cmd_size + 96UL);
  i = 0;
  goto ldv_53930;
  ldv_53929: 
  wep_cmd->key[i].key_index = (u8 )i;
  if ((unsigned int )ctx->wep_keys[i].key_size != 0U) {
    wep_cmd->key[i].key_offset = (u8 )i;
    not_empty = 1;
  } else {
    wep_cmd->key[i].key_offset = 255U;
  }
  wep_cmd->key[i].key_size = ctx->wep_keys[i].key_size;
  memcpy((void *)(& wep_cmd->key[i].key) + 3U, (void const   *)(& ctx->wep_keys[i].key),
           (size_t )ctx->wep_keys[i].key_size);
  i = i + 1;
  ldv_53930: ;
  if (i <= 3) {
    goto ldv_53929;
  } else {

  }
  wep_cmd->global_key_type = 1U;
  wep_cmd->num_keys = 4U;
  cmd_size = cmd_size + 96UL;
  cmd.len[0] = (u16 )cmd_size;
  if (not_empty != 0 || (int )send_if_empty) {
    tmp___0 = iwl_dvm_send_cmd(priv, & cmd);
    return (tmp___0);
  } else {
    return (0);
  }
}
}
int iwl_restore_default_wep_keys(struct iwl_priv *priv , struct iwl_rxon_context *ctx ) 
{ 
  int __ret_warn_on ;
  int tmp ;
  int tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;

  {
  if (debug_locks != 0) {
    tmp = lock_is_held(& priv->mutex.dep_map);
    if (tmp == 0) {
      tmp___0 = 1;
    } else {
      tmp___0 = 0;
    }
  } else {
    tmp___0 = 0;
  }
  __ret_warn_on = tmp___0;
  tmp___1 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp___1 != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/08_1a/drivers/net/wireless/iwlwifi/dvm/sta.c",
                       1037);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  tmp___2 = iwl_send_static_wepkey_cmd(priv, ctx, 0);
  return (tmp___2);
}
}
int iwl_remove_default_wep_key(struct iwl_priv *priv , struct iwl_rxon_context *ctx ,
                               struct ieee80211_key_conf *keyconf ) 
{ 
  int ret ;
  int __ret_warn_on ;
  int tmp ;
  int tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;

  {
  if (debug_locks != 0) {
    tmp = lock_is_held(& priv->mutex.dep_map);
    if (tmp == 0) {
      tmp___0 = 1;
    } else {
      tmp___0 = 0;
    }
  } else {
    tmp___0 = 0;
  }
  __ret_warn_on = tmp___0;
  tmp___1 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp___1 != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/08_1a/drivers/net/wireless/iwlwifi/dvm/sta.c",
                       1048);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  __iwl_dbg(priv->dev, 4194304U, 0, "iwl_remove_default_wep_key", "Removing default WEP key: idx=%d\n",
            (int )keyconf->keyidx);
  memset((void *)(& ctx->wep_keys) + (unsigned long )keyconf->keyidx, 0, 24UL);
  tmp___2 = iwl_is_rfkill(priv);
  if (tmp___2 != 0) {
    __iwl_dbg(priv->dev, 4194304U, 0, "iwl_remove_default_wep_key", "Not sending REPLY_WEPKEY command due to RFKILL.\n");
    return (0);
  } else {

  }
  ret = iwl_send_static_wepkey_cmd(priv, ctx, 1);
  __iwl_dbg(priv->dev, 4194304U, 0, "iwl_remove_default_wep_key", "Remove default WEP key: idx=%d ret=%d\n",
            (int )keyconf->keyidx, ret);
  return (ret);
}
}
int iwl_set_default_wep_key(struct iwl_priv *priv , struct iwl_rxon_context *ctx ,
                            struct ieee80211_key_conf *keyconf ) 
{ 
  int ret ;
  int __ret_warn_on ;
  int tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
  if (debug_locks != 0) {
    tmp = lock_is_held(& priv->mutex.dep_map);
    if (tmp == 0) {
      tmp___0 = 1;
    } else {
      tmp___0 = 0;
    }
  } else {
    tmp___0 = 0;
  }
  __ret_warn_on = tmp___0;
  tmp___1 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp___1 != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/08_1a/drivers/net/wireless/iwlwifi/dvm/sta.c",
                       1073);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if ((unsigned int )keyconf->keylen != 13U && (unsigned int )keyconf->keylen != 5U) {
    __iwl_dbg(priv->dev, 4194304U, 0, "iwl_set_default_wep_key", "Bad WEP key length %d\n",
              (int )keyconf->keylen);
    return (-22);
  } else {

  }
  keyconf->hw_key_idx = 254U;
  ctx->wep_keys[(int )keyconf->keyidx].key_size = keyconf->keylen;
  memcpy((void *)(& ctx->wep_keys[(int )keyconf->keyidx].key), (void const   *)(& keyconf->key),
           (size_t )keyconf->keylen);
  ret = iwl_send_static_wepkey_cmd(priv, ctx, 0);
  __iwl_dbg(priv->dev, 4194304U, 0, "iwl_set_default_wep_key", "Set default WEP key: len=%d idx=%d ret=%d\n",
            (int )keyconf->keylen, (int )keyconf->keyidx, ret);
  return (ret);
}
}
static u8 iwlagn_key_sta_id(struct iwl_priv *priv , struct ieee80211_vif *vif , struct ieee80211_sta *sta ) 
{ 
  struct iwl_vif_priv *vif_priv ;
  int tmp ;

  {
  vif_priv = (struct iwl_vif_priv *)(& vif->drv_priv);
  if ((unsigned long )sta != (unsigned long )((struct ieee80211_sta *)0)) {
    tmp = iwl_sta_id(sta);
    return ((u8 )tmp);
  } else {

  }
  if ((unsigned int )vif->type == 2U && (unsigned long )vif_priv->ctx != (unsigned long )((struct iwl_rxon_context *)0)) {
    return ((vif_priv->ctx)->ap_sta_id);
  } else {

  }
  return (255U);
}
}
static int iwlagn_send_sta_key(struct iwl_priv *priv , struct ieee80211_key_conf *keyconf ,
                               u8 sta_id , u32 tkip_iv32 , u16 *tkip_p1k , u32 cmd_flags ) 
{ 
  __le16 key_flags ;
  struct iwl_addsta_cmd sta_cmd ;
  int i ;
  int __ret_warn_on ;
  long tmp ;
  int tmp___0 ;

  {
  spin_lock_bh(& priv->sta_lock);
  memcpy((void *)(& sta_cmd), (void const   *)(& priv->stations[(int )sta_id].sta),
           92UL);
  spin_unlock_bh(& priv->sta_lock);
  key_flags = (int )((unsigned short )keyconf->keyidx) << 8U;
  key_flags = (__le16 )((unsigned int )key_flags | 8U);
  switch (keyconf->cipher) {
  case 1027076U: 
  key_flags = (__le16 )((unsigned int )key_flags | 2U);
  memcpy((void *)(& sta_cmd.key.key), (void const   *)(& keyconf->key), (size_t )keyconf->keylen);
  goto ldv_53974;
  case 1027074U: 
  key_flags = (__le16 )((unsigned int )key_flags | 3U);
  sta_cmd.key.tkip_rx_tsc_byte2 = (u8 )tkip_iv32;
  i = 0;
  goto ldv_53977;
  ldv_53976: 
  sta_cmd.key.tkip_rx_ttak[i] = *(tkip_p1k + (unsigned long )i);
  i = i + 1;
  ldv_53977: ;
  if (i <= 4) {
    goto ldv_53976;
  } else {

  }
  memcpy((void *)(& sta_cmd.key.key), (void const   *)(& keyconf->key), (size_t )keyconf->keylen);
  goto ldv_53974;
  case 1027077U: 
  key_flags = (__le16 )((unsigned int )key_flags | 4096U);
  case 1027073U: 
  key_flags = (__le16 )((unsigned int )key_flags | 1U);
  memcpy((void *)(& sta_cmd.key.key) + 3U, (void const   *)(& keyconf->key), (size_t )keyconf->keylen);
  goto ldv_53974;
  default: 
  __ret_warn_on = 1;
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/08_1a/drivers/net/wireless/iwlwifi/dvm/sta.c",
                       1166);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  return (-22);
  }
  ldv_53974: ;
  if (((int )keyconf->flags & 8) == 0) {
    key_flags = (__le16 )((unsigned int )key_flags | 16384U);
  } else {

  }
  sta_cmd.key.key_offset = keyconf->hw_key_idx;
  sta_cmd.key.key_flags = key_flags;
  sta_cmd.mode = 1U;
  sta_cmd.sta.modify_mask = 1U;
  tmp___0 = iwl_send_add_sta(priv, & sta_cmd, (int )((u8 )cmd_flags));
  return (tmp___0);
}
}
void iwl_update_tkip_key(struct iwl_priv *priv , struct ieee80211_vif *vif , struct ieee80211_key_conf *keyconf ,
                         struct ieee80211_sta *sta , u32 iv32 , u16 *phase1key ) 
{ 
  u8 sta_id ;
  u8 tmp ;
  int tmp___0 ;

  {
  tmp = iwlagn_key_sta_id(priv, vif, sta);
  sta_id = tmp;
  if ((unsigned int )sta_id == 255U) {
    return;
  } else {

  }
  tmp___0 = iwl_scan_cancel(priv);
  if (tmp___0 != 0) {
    return;
  } else {

  }
  iwlagn_send_sta_key(priv, keyconf, (int )sta_id, iv32, phase1key, 1U);
  return;
}
}
int iwl_remove_dynamic_key(struct iwl_priv *priv , struct iwl_rxon_context *ctx ,
                           struct ieee80211_key_conf *keyconf , struct ieee80211_sta *sta ) 
{ 
  struct iwl_addsta_cmd sta_cmd ;
  u8 sta_id ;
  u8 tmp ;
  __le16 key_flags ;
  int __ret_warn_on ;
  int tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  tmp = iwlagn_key_sta_id(priv, ctx->vif, sta);
  sta_id = tmp;
  if ((unsigned int )sta_id == 255U) {
    return (-2);
  } else {

  }
  spin_lock_bh(& priv->sta_lock);
  memcpy((void *)(& sta_cmd), (void const   *)(& priv->stations[(int )sta_id].sta),
           92UL);
  if (((unsigned long )priv->stations[(int )sta_id].used & 2UL) == 0UL) {
    sta_id = 255U;
  } else {

  }
  spin_unlock_bh(& priv->sta_lock);
  if ((unsigned int )sta_id == 255U) {
    return (0);
  } else {

  }
  if (debug_locks != 0) {
    tmp___0 = lock_is_held(& priv->mutex.dep_map);
    if (tmp___0 == 0) {
      tmp___1 = 1;
    } else {
      tmp___1 = 0;
    }
  } else {
    tmp___1 = 0;
  }
  __ret_warn_on = tmp___1;
  tmp___2 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp___2 != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/08_1a/drivers/net/wireless/iwlwifi/dvm/sta.c",
                       1225);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  ctx->key_mapping_keys = (u8 )((int )ctx->key_mapping_keys - 1);
  __iwl_dbg(priv->dev, 4194304U, 0, "iwl_remove_dynamic_key", "Remove dynamic key: idx=%d sta=%d\n",
            (int )keyconf->keyidx, (int )sta_id);
  tmp___3 = test_and_clear_bit((long )keyconf->hw_key_idx, (unsigned long volatile   *)(& priv->ucode_key_table));
  if (tmp___3 == 0) {
    __iwl_err(priv->dev, 0, 0, "offset %d not used in uCode key table.\n", (int )keyconf->hw_key_idx);
  } else {

  }
  key_flags = (int )((unsigned short )keyconf->keyidx) << 8U;
  key_flags = (__le16 )((unsigned int )key_flags | 2056U);
  if (((int )keyconf->flags & 8) == 0) {
    key_flags = (__le16 )((unsigned int )key_flags | 16384U);
  } else {

  }
  sta_cmd.key.key_flags = key_flags;
  sta_cmd.key.key_offset = keyconf->hw_key_idx;
  sta_cmd.sta.modify_mask = 1U;
  sta_cmd.mode = 1U;
  tmp___4 = iwl_send_add_sta(priv, & sta_cmd, 0);
  return (tmp___4);
}
}
int iwl_set_dynamic_key(struct iwl_priv *priv , struct iwl_rxon_context *ctx , struct ieee80211_key_conf *keyconf ,
                        struct ieee80211_sta *sta ) 
{ 
  struct ieee80211_key_seq seq ;
  u16 p1k[5U] ;
  int ret ;
  u8 sta_id ;
  u8 tmp ;
  u8 const   *addr ;
  int __ret_warn_on ;
  int tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;
  int tmp___3 ;

  {
  tmp = iwlagn_key_sta_id(priv, ctx->vif, sta);
  sta_id = tmp;
  if ((unsigned int )sta_id == 255U) {
    return (-22);
  } else {

  }
  if (debug_locks != 0) {
    tmp___0 = lock_is_held(& priv->mutex.dep_map);
    if (tmp___0 == 0) {
      tmp___1 = 1;
    } else {
      tmp___1 = 0;
    }
  } else {
    tmp___1 = 0;
  }
  __ret_warn_on = tmp___1;
  tmp___2 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp___2 != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/08_1a/drivers/net/wireless/iwlwifi/dvm/sta.c",
                       1265);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  tmp___3 = iwl_get_free_ucode_key_offset(priv);
  keyconf->hw_key_idx = (u8 )tmp___3;
  if ((unsigned int )keyconf->hw_key_idx == 255U) {
    return (-28);
  } else {

  }
  ctx->key_mapping_keys = (u8 )((int )ctx->key_mapping_keys + 1);
  switch (keyconf->cipher) {
  case 1027074U: ;
  if ((unsigned long )sta != (unsigned long )((struct ieee80211_sta *)0)) {
    addr = (u8 const   *)(& sta->addr);
  } else {
    addr = (u8 const   *)(& ctx->active.bssid_addr);
  }
  ieee80211_get_key_rx_seq(keyconf, 0, & seq);
  ieee80211_get_tkip_rx_p1k(keyconf, addr, seq.__annonCompField100.tkip.iv32, (u16 *)(& p1k));
  ret = iwlagn_send_sta_key(priv, keyconf, (int )sta_id, seq.__annonCompField100.tkip.iv32,
                            (u16 *)(& p1k), 0U);
  goto ldv_54019;
  case 1027076U: ;
  case 1027073U: ;
  case 1027077U: 
  ret = iwlagn_send_sta_key(priv, keyconf, (int )sta_id, 0U, (u16 *)0U, 0U);
  goto ldv_54019;
  default: 
  __iwl_err(priv->dev, 0, 0, "Unknown cipher %x\n", keyconf->cipher);
  ret = -22;
  }
  ldv_54019: ;
  if (ret != 0) {
    ctx->key_mapping_keys = (u8 )((int )ctx->key_mapping_keys - 1);
    clear_bit((long )keyconf->hw_key_idx, (unsigned long volatile   *)(& priv->ucode_key_table));
  } else {

  }
  __iwl_dbg(priv->dev, 4194304U, 0, "iwl_set_dynamic_key", "Set dynamic key: cipher=%x len=%d idx=%d sta=%pM ret=%d\n",
            keyconf->cipher, (int )keyconf->keylen, (int )keyconf->keyidx, (unsigned long )sta != (unsigned long )((struct ieee80211_sta *)0) ? (u8 *)(& sta->addr) : (u8 *)0U,
            ret);
  return (ret);
}
}
int iwlagn_alloc_bcast_station(struct iwl_priv *priv , struct iwl_rxon_context *ctx ) 
{ 
  struct iwl_link_quality_cmd *link_cmd ;
  u8 sta_id ;

  {
  spin_lock_bh(& priv->sta_lock);
  sta_id = iwl_prep_station(priv, ctx, (u8 const   *)(& iwl_bcast_addr), 0, (struct ieee80211_sta *)0);
  if ((unsigned int )sta_id == 255U) {
    __iwl_err(priv->dev, 0, 0, "Unable to prepare broadcast station\n");
    spin_unlock_bh(& priv->sta_lock);
    return (-22);
  } else {

  }
  priv->stations[(int )sta_id].used = (u8 )((unsigned int )priv->stations[(int )sta_id].used | 1U);
  priv->stations[(int )sta_id].used = (u8 )((unsigned int )priv->stations[(int )sta_id].used | 16U);
  spin_unlock_bh(& priv->sta_lock);
  link_cmd = iwl_sta_alloc_lq(priv, ctx, (int )sta_id);
  if ((unsigned long )link_cmd == (unsigned long )((struct iwl_link_quality_cmd *)0)) {
    __iwl_err(priv->dev, 0, 0, "Unable to initialize rate scaling for bcast station.\n");
    return (-12);
  } else {

  }
  spin_lock_bh(& priv->sta_lock);
  priv->stations[(int )sta_id].lq = link_cmd;
  spin_unlock_bh(& priv->sta_lock);
  return (0);
}
}
int iwl_update_bcast_station(struct iwl_priv *priv , struct iwl_rxon_context *ctx ) 
{ 
  struct iwl_link_quality_cmd *link_cmd ;
  u8 sta_id ;

  {
  sta_id = ctx->bcast_sta_id;
  link_cmd = iwl_sta_alloc_lq(priv, ctx, (int )sta_id);
  if ((unsigned long )link_cmd == (unsigned long )((struct iwl_link_quality_cmd *)0)) {
    __iwl_err(priv->dev, 0, 0, "Unable to initialize rate scaling for bcast station.\n");
    return (-12);
  } else {

  }
  spin_lock_bh(& priv->sta_lock);
  if ((unsigned long )priv->stations[(int )sta_id].lq != (unsigned long )((struct iwl_link_quality_cmd *)0)) {
    kfree((void const   *)priv->stations[(int )sta_id].lq);
  } else {
    __iwl_dbg(priv->dev, 1U, 0, "iwl_update_bcast_station", "Bcast station rate scaling has not been initialized yet.\n");
  }
  priv->stations[(int )sta_id].lq = link_cmd;
  spin_unlock_bh(& priv->sta_lock);
  return (0);
}
}
int iwl_update_bcast_stations(struct iwl_priv *priv ) 
{ 
  struct iwl_rxon_context *ctx ;
  int ret ;

  {
  ret = 0;
  ctx = (struct iwl_rxon_context *)(& priv->contexts);
  goto ldv_54045;
  ldv_54044: ;
  if ((int )((unsigned long )priv->valid_contexts >> (int )ctx->ctxid) & 1) {
    ret = iwl_update_bcast_station(priv, ctx);
    if (ret != 0) {
      goto ldv_54043;
    } else {

    }
  } else {

  }
  ctx = ctx + 1;
  ldv_54045: ;
  if ((unsigned long )((struct iwl_rxon_context *)(& priv->contexts) + 2UL) > (unsigned long )ctx) {
    goto ldv_54044;
  } else {

  }
  ldv_54043: ;
  return (ret);
}
}
int iwl_sta_tx_modify_enable_tid(struct iwl_priv *priv , int sta_id , int tid ) 
{ 
  struct iwl_addsta_cmd sta_cmd ;
  int __ret_warn_on ;
  int tmp ;
  int tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;

  {
  if (debug_locks != 0) {
    tmp = lock_is_held(& priv->mutex.dep_map);
    if (tmp == 0) {
      tmp___0 = 1;
    } else {
      tmp___0 = 0;
    }
  } else {
    tmp___0 = 0;
  }
  __ret_warn_on = tmp___0;
  tmp___1 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp___1 != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/08_1a/drivers/net/wireless/iwlwifi/dvm/sta.c",
                       1399);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  spin_lock_bh(& priv->sta_lock);
  priv->stations[sta_id].sta.sta.modify_mask = 2U;
  priv->stations[sta_id].sta.tid_disable_tx = (__le16 )((int )priv->stations[sta_id].sta.tid_disable_tx & ~ ((int )((unsigned short )(1 << tid))));
  priv->stations[sta_id].sta.mode = 1U;
  memcpy((void *)(& sta_cmd), (void const   *)(& priv->stations[sta_id].sta), 92UL);
  spin_unlock_bh(& priv->sta_lock);
  tmp___2 = iwl_send_add_sta(priv, & sta_cmd, 0);
  return (tmp___2);
}
}
int iwl_sta_rx_agg_start(struct iwl_priv *priv , struct ieee80211_sta *sta , int tid ,
                         u16 ssn ) 
{ 
  int sta_id ;
  struct iwl_addsta_cmd sta_cmd ;
  int __ret_warn_on ;
  int tmp ;
  int tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;

  {
  if (debug_locks != 0) {
    tmp = lock_is_held(& priv->mutex.dep_map);
    if (tmp == 0) {
      tmp___0 = 1;
    } else {
      tmp___0 = 0;
    }
  } else {
    tmp___0 = 0;
  }
  __ret_warn_on = tmp___0;
  tmp___1 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp___1 != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/08_1a/drivers/net/wireless/iwlwifi/dvm/sta.c",
                       1418);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  sta_id = iwl_sta_id(sta);
  if (sta_id == 255) {
    return (-6);
  } else {

  }
  spin_lock_bh(& priv->sta_lock);
  priv->stations[sta_id].sta.station_flags_msk = 0U;
  priv->stations[sta_id].sta.sta.modify_mask = 8U;
  priv->stations[sta_id].sta.add_immediate_ba_tid = (unsigned char )tid;
  priv->stations[sta_id].sta.add_immediate_ba_ssn = ssn;
  priv->stations[sta_id].sta.mode = 1U;
  memcpy((void *)(& sta_cmd), (void const   *)(& priv->stations[sta_id].sta), 92UL);
  spin_unlock_bh(& priv->sta_lock);
  tmp___2 = iwl_send_add_sta(priv, & sta_cmd, 0);
  return (tmp___2);
}
}
int iwl_sta_rx_agg_stop(struct iwl_priv *priv , struct ieee80211_sta *sta , int tid ) 
{ 
  int sta_id ;
  struct iwl_addsta_cmd sta_cmd ;
  int __ret_warn_on ;
  int tmp ;
  int tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;

  {
  if (debug_locks != 0) {
    tmp = lock_is_held(& priv->mutex.dep_map);
    if (tmp == 0) {
      tmp___0 = 1;
    } else {
      tmp___0 = 0;
    }
  } else {
    tmp___0 = 0;
  }
  __ret_warn_on = tmp___0;
  tmp___1 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp___1 != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/08_1a/drivers/net/wireless/iwlwifi/dvm/sta.c",
                       1442);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  sta_id = iwl_sta_id(sta);
  if (sta_id == 255) {
    __iwl_err(priv->dev, 0, 0, "Invalid station for AGG tid %d\n", tid);
    return (-6);
  } else {

  }
  spin_lock_bh(& priv->sta_lock);
  priv->stations[sta_id].sta.station_flags_msk = 0U;
  priv->stations[sta_id].sta.sta.modify_mask = 16U;
  priv->stations[sta_id].sta.remove_immediate_ba_tid = (unsigned char )tid;
  priv->stations[sta_id].sta.mode = 1U;
  memcpy((void *)(& sta_cmd), (void const   *)(& priv->stations[sta_id].sta), 92UL);
  spin_unlock_bh(& priv->sta_lock);
  tmp___2 = iwl_send_add_sta(priv, & sta_cmd, 0);
  return (tmp___2);
}
}
void iwl_sta_modify_sleep_tx_count(struct iwl_priv *priv , int sta_id , int cnt ) 
{ 
  struct iwl_addsta_cmd cmd ;

  {
  cmd.mode = 1U;
  cmd.reserved[0] = (unsigned char)0;
  cmd.reserved[1] = (unsigned char)0;
  cmd.reserved[2] = (unsigned char)0;
  cmd.sta.addr[0] = (unsigned char)0;
  cmd.sta.addr[1] = (unsigned char)0;
  cmd.sta.addr[2] = (unsigned char)0;
  cmd.sta.addr[3] = (unsigned char)0;
  cmd.sta.addr[4] = (unsigned char)0;
  cmd.sta.addr[5] = (unsigned char)0;
  cmd.sta.reserved1 = (unsigned short)0;
  cmd.sta.sta_id = (unsigned char )sta_id;
  cmd.sta.modify_mask = 32U;
  cmd.sta.reserved2 = (unsigned short)0;
  cmd.key.key_flags = (unsigned short)0;
  cmd.key.tkip_rx_tsc_byte2 = (unsigned char)0;
  cmd.key.reserved1 = (unsigned char)0;
  cmd.key.tkip_rx_ttak[0] = (unsigned short)0;
  cmd.key.tkip_rx_ttak[1] = (unsigned short)0;
  cmd.key.tkip_rx_ttak[2] = (unsigned short)0;
  cmd.key.tkip_rx_ttak[3] = (unsigned short)0;
  cmd.key.tkip_rx_ttak[4] = (unsigned short)0;
  cmd.key.key_offset = (unsigned char)0;
  cmd.key.reserved2 = (unsigned char)0;
  cmd.key.key[0] = (unsigned char)0;
  cmd.key.key[1] = (unsigned char)0;
  cmd.key.key[2] = (unsigned char)0;
  cmd.key.key[3] = (unsigned char)0;
  cmd.key.key[4] = (unsigned char)0;
  cmd.key.key[5] = (unsigned char)0;
  cmd.key.key[6] = (unsigned char)0;
  cmd.key.key[7] = (unsigned char)0;
  cmd.key.key[8] = (unsigned char)0;
  cmd.key.key[9] = (unsigned char)0;
  cmd.key.key[10] = (unsigned char)0;
  cmd.key.key[11] = (unsigned char)0;
  cmd.key.key[12] = (unsigned char)0;
  cmd.key.key[13] = (unsigned char)0;
  cmd.key.key[14] = (unsigned char)0;
  cmd.key.key[15] = (unsigned char)0;
  cmd.key.tx_secur_seq_cnt = 0ULL;
  cmd.key.hw_tkip_mic_rx_key = 0ULL;
  cmd.key.hw_tkip_mic_tx_key = 0ULL;
  cmd.station_flags = 256U;
  cmd.station_flags_msk = 256U;
  cmd.tid_disable_tx = (unsigned short)0;
  cmd.legacy_reserved = (unsigned short)0;
  cmd.add_immediate_ba_tid = (unsigned char)0;
  cmd.remove_immediate_ba_tid = (unsigned char)0;
  cmd.add_immediate_ba_ssn = (unsigned short)0;
  cmd.sleep_tx_count = (unsigned short )cnt;
  cmd.reserved2 = (unsigned short)0;
  iwl_send_add_sta(priv, & cmd, 1);
  return;
}
}
bool ldv_queue_work_on_171(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_7(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_delayed_work_on_172(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_7(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_work_on_173(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_7(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
void ldv_flush_workqueue_174(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
  flush_workqueue(ldv_func_arg1);
  call_and_disable_all_7(2);
  return;
}
}
bool ldv_queue_delayed_work_on_175(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_7(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
__inline static long ldv__builtin_expect(long exp , long c ) ;
__inline static void le32_add_cpu(__le32 *var , u32 val ) 
{ 


  {
  *var = *var + val;
  return;
}
}
extern void print_hex_dump(char const   * , char const   * , int  , int  , int  ,
                           void const   * , size_t  , bool  ) ;
__inline static unsigned long arch_local_save_flags___2(void) 
{ 
  unsigned long __ret ;
  unsigned long __edi ;
  unsigned long __esi ;
  unsigned long __edx ;
  unsigned long __ecx ;
  unsigned long __eax ;
  long tmp ;

  {
  __edi = __edi;
  __esi = __esi;
  __edx = __edx;
  __ecx = __ecx;
  __eax = __eax;
  tmp = ldv__builtin_expect((unsigned long )pv_irq_ops.save_fl.func == (unsigned long )((void *)0),
                         0L);
  if (tmp != 0L) {
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"./arch/x86/include/asm/paravirt.h"),
                         "i" (831), "i" (12UL));
    ldv_4860: ;
    goto ldv_4860;
  } else {

  }
  __asm__  volatile   ("771:\n\tcall *%c2;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c1\n  .byte 772b-771b\n  .short %c3\n.popsection\n": "=a" (__eax): [paravirt_typenum] "i" (43UL),
                       [paravirt_opptr] "i" (& pv_irq_ops.save_fl.func), [paravirt_clobber] "i" (1): "memory",
                       "cc");
  __ret = __eax;
  return (__ret);
}
}
__inline static bool static_key_false___2(struct static_key *key ) 
{ 
  int tmp ;
  long tmp___0 ;

  {
  tmp = static_key_count(key);
  tmp___0 = ldv__builtin_expect(tmp > 0, 0L);
  if (tmp___0 != 0L) {
    return (1);
  } else {

  }
  return (0);
}
}
extern void dump_page(struct page * , char const   * ) ;
extern void kfree_call_rcu(struct callback_head * , void (*)(struct callback_head * ) ) ;
__inline static int rcu_read_lock_sched_held___2(void) 
{ 
  int lockdep_opinion ;
  int tmp ;
  bool tmp___0 ;
  int tmp___1 ;
  bool tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  unsigned long _flags ;
  int tmp___5 ;
  int tmp___6 ;

  {
  lockdep_opinion = 0;
  tmp = debug_lockdep_rcu_enabled();
  if (tmp == 0) {
    return (1);
  } else {

  }
  tmp___0 = rcu_is_watching();
  if (tmp___0) {
    tmp___1 = 0;
  } else {
    tmp___1 = 1;
  }
  if (tmp___1) {
    return (0);
  } else {

  }
  tmp___2 = rcu_lockdep_current_cpu_online();
  if (tmp___2) {
    tmp___3 = 0;
  } else {
    tmp___3 = 1;
  }
  if (tmp___3) {
    return (0);
  } else {

  }
  if (debug_locks != 0) {
    lockdep_opinion = lock_is_held(& rcu_sched_lock_map);
  } else {

  }
  if (lockdep_opinion != 0) {
    tmp___6 = 1;
  } else {
    tmp___4 = preempt_count();
    if (tmp___4 != 0) {
      tmp___6 = 1;
    } else {
      _flags = arch_local_save_flags___2();
      tmp___5 = arch_irqs_disabled_flags(_flags);
      if (tmp___5 != 0) {
        tmp___6 = 1;
      } else {
        tmp___6 = 0;
      }
    }
  }
  return (tmp___6);
}
}
int ldv_mod_timer_190(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
bool ldv_queue_work_on_185(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_work_on_187(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_delayed_work_on_186(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
bool ldv_queue_delayed_work_on_189(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
void ldv_flush_workqueue_188(struct workqueue_struct *ldv_func_arg1 ) ;
__inline static bool queue_work___5(struct workqueue_struct *wq , struct work_struct *work ) 
{ 
  bool tmp ;

  {
  tmp = ldv_queue_work_on_185(8192, wq, work);
  return (tmp);
}
}
__inline static int PageTail(struct page  const  *page ) 
{ 
  int tmp ;

  {
  tmp = constant_test_bit(15L, (unsigned long const volatile   *)(& page->flags));
  return (tmp);
}
}
extern bool __get_page_tail(struct page * ) ;
__inline static void get_page(struct page *page ) 
{ 
  bool tmp ;
  long tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;

  {
  tmp___1 = PageTail((struct page  const  *)page);
  tmp___2 = ldv__builtin_expect(tmp___1 != 0, 0L);
  if (tmp___2 != 0L) {
    tmp = __get_page_tail(page);
    tmp___0 = ldv__builtin_expect((long )tmp, 1L);
    if (tmp___0 != 0L) {
      return;
    } else {

    }
  } else {

  }
  tmp___3 = atomic_read((atomic_t const   *)(& page->__annonCompField42.__annonCompField41.__annonCompField40._count));
  tmp___4 = ldv__builtin_expect(tmp___3 <= 0, 0L);
  if (tmp___4 != 0L) {
    dump_page(page, "VM_BUG_ON_PAGE(atomic_read(&page->_count) <= 0)");
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"include/linux/mm.h"),
                         "i" (543), "i" (12UL));
    ldv_24332: ;
    goto ldv_24332;
  } else {

  }
  atomic_inc(& page->__annonCompField42.__annonCompField41.__annonCompField40._count);
  return;
}
}
extern struct sk_buff *__alloc_skb(unsigned int  , gfp_t  , int  , int  ) ;
__inline static struct sk_buff *alloc_skb(unsigned int size , gfp_t priority ) 
{ 
  struct sk_buff *tmp ;

  {
  tmp = __alloc_skb(size, priority, 0, -1);
  return (tmp);
}
}
__inline static bool skb_is_nonlinear(struct sk_buff  const  *skb ) 
{ 


  {
  return ((unsigned int )skb->data_len != 0U);
}
}
extern void skb_add_rx_frag(struct sk_buff * , int  , struct page * , int  , int  ,
                            unsigned int  ) ;
__inline static int skb_tailroom(struct sk_buff  const  *skb ) 
{ 
  bool tmp ;

  {
  tmp = skb_is_nonlinear(skb);
  return ((int )tmp ? 0 : (int )((unsigned int )skb->end - (unsigned int )skb->tail));
}
}
__inline static int ieee80211_is_beacon(__le16 fc ) 
{ 


  {
  return (((int )fc & 252) == 128);
}
}
extern int ieee80211_channel_to_frequency(int  , enum ieee80211_band  ) ;
__inline static struct ieee80211_rx_status *IEEE80211_SKB_RXCB(struct sk_buff *skb ) 
{ 


  {
  return ((struct ieee80211_rx_status *)(& skb->cb));
}
}
extern void ieee80211_rx(struct ieee80211_hw * , struct sk_buff * ) ;
__inline static int rxb_offset(struct iwl_rx_cmd_buffer *r ) 
{ 


  {
  return (r->_offset);
}
}
__inline static struct page *rxb_steal_page(struct iwl_rx_cmd_buffer *r ) 
{ 


  {
  r->_page_stolen = 1;
  get_page(r->_page);
  return (r->_page);
}
}
__inline static void trace_iwlwifi_dev_iowrite32___2(struct device  const  *dev ,
                                                     u32 offs , u32 val ) 
{ 
  struct tracepoint_func *it_func_ptr ;
  void *it_func ;
  void *__data ;
  struct tracepoint_func *________p1 ;
  struct tracepoint_func *_________p1 ;
  union __anonunion___u_398___1 __u ;
  bool __warned ;
  int tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  struct tracepoint_func *________p1___0 ;
  struct tracepoint_func *_________p1___0 ;
  union __anonunion___u_400___1 __u___0 ;
  bool __warned___0 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  tmp___1 = static_key_false___2(& __tracepoint_iwlwifi_dev_iowrite32.key);
  if ((int )tmp___1) {
    rcu_read_lock_sched_notrace();
    __read_once_size((void const volatile   *)(& __tracepoint_iwlwifi_dev_iowrite32.funcs),
                     (void *)(& __u.__c), 8);
    _________p1 = __u.__val;
    ________p1 = _________p1;
    tmp = debug_lockdep_rcu_enabled();
    if (tmp != 0 && ! __warned) {
      tmp___0 = rcu_read_lock_sched_held___2();
      if (tmp___0 == 0) {
        __warned = 1;
        lockdep_rcu_suspicious("drivers/net/wireless/iwlwifi/dvm/../iwl-devtrace-io.h",
                               84, "suspicious rcu_dereference_check() usage");
      } else {

      }
    } else {

    }
    it_func_ptr = ________p1;
    if ((unsigned long )it_func_ptr != (unsigned long )((struct tracepoint_func *)0)) {
      ldv_51370: 
      it_func = it_func_ptr->func;
      __data = it_func_ptr->data;
      (*((void (*)(void * , struct device  const  * , u32  , u32  ))it_func))(__data,
                                                                              dev,
                                                                              offs,
                                                                              val);
      it_func_ptr = it_func_ptr + 1;
      if ((unsigned long )it_func_ptr->func != (unsigned long )((void *)0)) {
        goto ldv_51370;
      } else {

      }

    } else {

    }
    rcu_read_unlock_sched_notrace();
  } else {

  }
  rcu_read_lock_sched_notrace();
  __read_once_size((void const volatile   *)(& __tracepoint_iwlwifi_dev_iowrite32.funcs),
                   (void *)(& __u___0.__c), 8);
  _________p1___0 = __u___0.__val;
  ________p1___0 = _________p1___0;
  tmp___2 = debug_lockdep_rcu_enabled();
  if (tmp___2 != 0 && ! __warned___0) {
    tmp___3 = rcu_read_lock_sched_held___2();
    if (tmp___3 == 0) {
      __warned___0 = 1;
      lockdep_rcu_suspicious("drivers/net/wireless/iwlwifi/dvm/../iwl-devtrace-io.h",
                             84, "suspicious rcu_dereference_check() usage");
    } else {

    }
  } else {

  }
  rcu_read_unlock_sched_notrace();
  return;
}
}
__inline static void iwl_write32___2(struct iwl_trans *trans , u32 ofs , u32 val ) 
{ 


  {
  trace_iwlwifi_dev_iowrite32___2((struct device  const  *)trans->dev, ofs, val);
  iwl_trans_write32(trans, ofs, val);
  return;
}
}
extern void iwl_write_direct32(struct iwl_trans * , u32  , u32  ) ;
extern void iwl_notification_wait_init(struct iwl_notif_wait_data * ) ;
extern void iwl_notification_wait_notify(struct iwl_notif_wait_data * , struct iwl_rx_packet * ) ;
__inline static int iwl_is_any_associated___0(struct iwl_priv *priv ) 
{ 
  struct iwl_rxon_context *ctx ;
  int tmp ;

  {
  ctx = (struct iwl_rxon_context *)(& priv->contexts);
  goto ldv_54746;
  ldv_54745: ;
  if ((int )((unsigned long )priv->valid_contexts >> (int )ctx->ctxid) & 1) {
    tmp = iwl_is_associated_ctx(ctx);
    if (tmp != 0) {
      return (1);
    } else {

    }
  } else {

  }
  ctx = ctx + 1;
  ldv_54746: ;
  if ((unsigned long )((struct iwl_rxon_context *)(& priv->contexts) + 2UL) > (unsigned long )ctx) {
    goto ldv_54745;
  } else {

  }

  return (0);
}
}
int iwl_force_rf_reset(struct iwl_priv *priv , bool external ) ;
void iwl_internal_short_hw_scan(struct iwl_priv *priv ) ;
void iwl_setup_rx_scan_handlers(struct iwl_priv *priv ) ;
__inline static u8 iwl_hw_get_rate(__le32 rate_n_flags ) 
{ 


  {
  return ((u8 )rate_n_flags);
}
}
char const   * const  iwl_dvm_cmd_strings[255U]  = 
  {      0,      "REPLY_ALIVE",      "REPLY_ERROR",      "REPLY_ECHO", 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        "REPLY_RXON",      "REPLY_RXON_ASSOC",      0,      "REPLY_QOS_PARAM", 
        "REPLY_RXON_TIMING",      0,      0,      0, 
        "REPLY_ADD_STA",      "REPLY_REMOVE_STA",      "REPLY_REMOVE_ALL_STA",      0, 
        "REPLY_TX",      0,      "REPLY_TXFIFO_FLUSH",      0, 
        "REPLY_WEPKEY",      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        "REPLY_LEDS_CMD",      0,      0,      0, 
        0,      0,      "REPLY_TX_LINK_QUALITY_CMD",      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      "COEX_PRIORITY_TABLE_CMD",      "COEX_MEDIUM_NOTIFICATION", 
        "COEX_EVENT_CMD",      0,      0,      0, 
        0,      0,      "TEMPERATURE_NOTIFICATION",      0, 
        0,      "CALIBRATION_CFG_CMD",      "CALIBRATION_RES_NOTIFICATION",      "CALIBRATION_COMPLETE_NOTIFICATION", 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      "REPLY_QUIET_CMD",      "REPLY_CHANNEL_SWITCH",      "CHANNEL_SWITCH_NOTIFICATION", 
        "REPLY_SPECTRUM_MEASUREMENT_CMD",      "SPECTRUM_MEASURE_NOTIFICATION",      0,      "POWER_TABLE_CMD", 
        0,      0,      "PM_SLEEP_NOTIFICATION",      "PM_DEBUG_STATISTIC_NOTIFIC", 
        0,      0,      0,      0, 
        "REPLY_SCAN_CMD",      "REPLY_SCAN_ABORT_CMD",      "SCAN_START_NOTIFICATION",      "SCAN_RESULTS_NOTIFICATION", 
        "SCAN_COMPLETE_NOTIFICATION",      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        "BEACON_NOTIFICATION",      "REPLY_TX_BEACON",      0,      0, 
        "WHO_IS_AWAKE_NOTIFICATION",      "REPLY_TX_POWER_DBM_CMD",      "QUIET_NOTIFICATION",      "REPLY_TX_PWR_TABLE_CMD", 
        "TX_ANT_CONFIGURATION_CMD",      "MEASURE_ABORT_NOTIFICATION",      0,      "REPLY_BT_CONFIG", 
        "REPLY_STATISTICS_CMD",      "STATISTICS_NOTIFICATION",      0,      0, 
        "REPLY_CARD_STATE_CMD",      "CARD_STATE_NOTIFICATION",      "MISSED_BEACONS_NOTIFICATION",      0, 
        "REPLY_CT_KILL_CONFIG_CMD",      0,      0,      0, 
        "SENSITIVITY_CMD",      0,      0,      0, 
        0,      0,      0,      0, 
        "REPLY_PHY_CALIBRATION_CMD",      0,      "REPLY_WIPAN_PARAMS",      "REPLY_WIPAN_RXON", 
        "REPLY_WIPAN_RXON_TIMING",      0,      "REPLY_WIPAN_RXON_ASSOC",      "REPLY_WIPAN_QOS_PARAM", 
        "REPLY_WIPAN_WEPKEY",      "REPLY_WIPAN_P2P_CHANNEL_SWITCH",      0,      0, 
        "REPLY_WIPAN_NOA_NOTIFICATION",      "REPLY_WIPAN_DEACTIVATION_COMPLETE",      0,      0, 
        "REPLY_RX_PHY_CMD",      "REPLY_RX_MPDU_CMD",      0,      0, 
        0,      "REPLY_COMPRESSED_BA",      0,      0, 
        0,      0,      0,      0, 
        "REPLY_BT_COEX_PRIO_TABLE",      "REPLY_BT_COEX_PROT_ENV",      "REPLY_BT_COEX_PROFILE_NOTIF",      0, 
        0,      0,      0,      "REPLY_D3_CONFIG", 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        "REPLY_WOWLAN_PATTERNS",      "REPLY_WOWLAN_WAKEUP_FILTER",      "REPLY_WOWLAN_TSC_RSC_PARAMS",      "REPLY_WOWLAN_TKIP_PARAMS", 
        "REPLY_WOWLAN_KEK_KCK_MATERIAL",      "REPLY_WOWLAN_GET_STATUS"};
static int iwlagn_rx_reply_error(struct iwl_priv *priv , struct iwl_rx_cmd_buffer *rxb ,
                                 struct iwl_device_cmd *cmd ) 
{ 
  struct iwl_rx_packet *pkt ;
  void *tmp ;
  struct iwl_error_resp *err_resp ;

  {
  tmp = rxb_addr(rxb);
  pkt = (struct iwl_rx_packet *)tmp;
  err_resp = (struct iwl_error_resp *)(& pkt->data);
  __iwl_err(priv->dev, 0, 0, "Error Reply type 0x%08X cmd REPLY_ERROR (0x%02X) seq 0x%04X ser 0x%08X\n",
            err_resp->error_type, (int )err_resp->cmd_id, (int )err_resp->bad_cmd_seq_num,
            err_resp->error_info);
  return (0);
}
}
static int iwlagn_rx_csa(struct iwl_priv *priv , struct iwl_rx_cmd_buffer *rxb , struct iwl_device_cmd *cmd ) 
{ 
  struct iwl_rx_packet *pkt ;
  void *tmp ;
  struct iwl_csa_notification *csa ;
  struct iwl_rxon_context *ctx ;
  struct iwl_rxon_cmd *rxon ;
  int tmp___0 ;

  {
  tmp = rxb_addr(rxb);
  pkt = (struct iwl_rx_packet *)tmp;
  csa = (struct iwl_csa_notification *)(& pkt->data);
  ctx = (struct iwl_rxon_context *)(& priv->contexts);
  rxon = (struct iwl_rxon_cmd *)(& ctx->active);
  tmp___0 = constant_test_bit(11L, (unsigned long const volatile   *)(& priv->status));
  if (tmp___0 == 0) {
    return (0);
  } else {

  }
  if (csa->status == 0U && (int )csa->channel == (int )priv->switch_channel) {
    rxon->channel = csa->channel;
    ctx->staging.channel = csa->channel;
    __iwl_dbg(priv->dev, 268435456U, 0, "iwlagn_rx_csa", "CSA notif: channel %d\n",
              (int )csa->channel);
    iwl_chswitch_done(priv, 1);
  } else {
    __iwl_err(priv->dev, 0, 0, "CSA notif (fail) : channel %d\n", (int )csa->channel);
    iwl_chswitch_done(priv, 0);
  }
  return (0);
}
}
static int iwlagn_rx_spectrum_measure_notif(struct iwl_priv *priv , struct iwl_rx_cmd_buffer *rxb ,
                                            struct iwl_device_cmd *cmd ) 
{ 
  struct iwl_rx_packet *pkt ;
  void *tmp ;
  struct iwl_spectrum_notification *report ;

  {
  tmp = rxb_addr(rxb);
  pkt = (struct iwl_rx_packet *)tmp;
  report = (struct iwl_spectrum_notification *)(& pkt->data);
  if ((unsigned int )report->state == 0U) {
    __iwl_dbg(priv->dev, 268435456U, 0, "iwlagn_rx_spectrum_measure_notif", "Spectrum Measure Notification: Start\n");
    return (0);
  } else {

  }
  memcpy((void *)(& priv->measure_report), (void const   *)report, 100UL);
  priv->measurement_status = (u8 )((unsigned int )priv->measurement_status | 1U);
  return (0);
}
}
static int iwlagn_rx_pm_sleep_notif(struct iwl_priv *priv , struct iwl_rx_cmd_buffer *rxb ,
                                    struct iwl_device_cmd *cmd ) 
{ 
  struct iwl_rx_packet *pkt ;
  void *tmp ;
  struct iwl_sleep_notification *sleep ;

  {
  tmp = rxb_addr(rxb);
  pkt = (struct iwl_rx_packet *)tmp;
  sleep = (struct iwl_sleep_notification *)(& pkt->data);
  __iwl_dbg(priv->dev, 16777216U, 0, "iwlagn_rx_pm_sleep_notif", "sleep mode: %d, src: %d\n",
            (int )sleep->pm_sleep_mode, (int )sleep->pm_wakeup_src);
  return (0);
}
}
static int iwlagn_rx_pm_debug_statistics_notif(struct iwl_priv *priv , struct iwl_rx_cmd_buffer *rxb ,
                                               struct iwl_device_cmd *cmd ) 
{ 
  struct iwl_rx_packet *pkt ;
  void *tmp ;
  u32 len ;
  u32 tmp___0 ;
  bool tmp___1 ;

  {
  tmp = rxb_addr(rxb);
  pkt = (struct iwl_rx_packet *)tmp;
  tmp___0 = iwl_rx_packet_len((struct iwl_rx_packet  const  *)pkt);
  len = tmp___0;
  __iwl_dbg(priv->dev, 128U, 0, "iwlagn_rx_pm_debug_statistics_notif", "Dumping %d bytes of unhandled notification for PM_DEBUG_STATISTIC_NOTIFIC:\n",
            len);
  tmp___1 = iwl_have_debug_level(128U);
  if ((int )tmp___1) {
    print_hex_dump("\017", "iwl data: ", 2, 16, 1, (void const   *)(& pkt->data),
                   (size_t )len, 1);
  } else {

  }
  return (0);
}
}
static int iwlagn_rx_beacon_notif(struct iwl_priv *priv , struct iwl_rx_cmd_buffer *rxb ,
                                  struct iwl_device_cmd *cmd ) 
{ 
  struct iwl_rx_packet *pkt ;
  void *tmp ;
  struct iwlagn_beacon_notif *beacon ;
  u16 status ;
  u8 rate ;
  u8 tmp___0 ;

  {
  tmp = rxb_addr(rxb);
  pkt = (struct iwl_rx_packet *)tmp;
  beacon = (struct iwlagn_beacon_notif *)(& pkt->data);
  status = beacon->beacon_notify_hdr.status.status;
  tmp___0 = iwl_hw_get_rate(beacon->beacon_notify_hdr.rate_n_flags);
  rate = tmp___0;
  __iwl_dbg(priv->dev, 16777216U, 0, "iwlagn_rx_beacon_notif", "beacon status %#x, retries:%d ibssmgr:%d tsf:0x%.8x%.8x rate:%d\n",
            (int )status & 255, (int )beacon->beacon_notify_hdr.failure_frame, beacon->ibss_mgr_status,
            beacon->high_tsf, beacon->low_tsf, (int )rate);
  priv->ibss_manager = beacon->ibss_mgr_status;
  return (0);
}
}
static bool iwlagn_good_plcp_health(struct iwl_priv *priv , struct statistics_rx_phy *cur_ofdm ,
                                    struct statistics_rx_ht_phy *cur_ofdm_ht , unsigned int msecs ) 
{ 
  int delta ;
    klee_make_symbolic(&delta, sizeof(int), "delta");
  int threshold ;
    klee_make_symbolic(&threshold, sizeof(int), "threshold");

  {
  threshold = (int )priv->plcp_delta_threshold;
  if (threshold == 0) {
    __iwl_dbg(priv->dev, 128U, 0, "iwlagn_good_plcp_health", "plcp_err check disabled\n");
    return (1);
  } else {

  }
  delta = (int )(((cur_ofdm->plcp_err - priv->statistics.rx_ofdm.plcp_err) + cur_ofdm_ht->plcp_err) - priv->statistics.rx_ofdm_ht.plcp_err);
  if (delta <= 0) {
    return (1);
  } else {

  }
  if ((unsigned int )(delta * 100) / msecs > (unsigned int )threshold) {
    __iwl_dbg(priv->dev, 128U, 0, "iwlagn_good_plcp_health", "plcp health threshold %u delta %d msecs %u\n",
              threshold, delta, msecs);
    return (0);
  } else {

  }
  return (1);
}
}
int iwl_force_rf_reset(struct iwl_priv *priv , bool external ) 
{ 
  struct iwl_rf_reset *rf_reset ;
  int tmp ;
  int tmp___0 ;

  {
  tmp = constant_test_bit(5L, (unsigned long const volatile   *)(& priv->status));
  if (tmp != 0) {
    return (-11);
  } else {

  }
  tmp___0 = iwl_is_any_associated___0(priv);
  if (tmp___0 == 0) {
    __iwl_dbg(priv->dev, 2048U, 0, "iwl_force_rf_reset", "force reset rejected: not associated\n");
    return (-67);
  } else {

  }
  rf_reset = & priv->rf_reset;
  rf_reset->reset_request_count = rf_reset->reset_request_count + 1;
  if ((! external && rf_reset->last_reset_jiffies != 0UL) && (long )(((unsigned long )jiffies - rf_reset->last_reset_jiffies) - 750UL) < 0L) {
    __iwl_dbg(priv->dev, 1U, 0, "iwl_force_rf_reset", "RF reset rejected\n");
    rf_reset->reset_reject_count = rf_reset->reset_reject_count + 1;
    return (-11);
  } else {

  }
  rf_reset->reset_success_count = rf_reset->reset_success_count + 1;
  rf_reset->last_reset_jiffies = jiffies;
  __iwl_dbg(priv->dev, 1U, 0, "iwl_force_rf_reset", "perform radio reset.\n");
  iwl_internal_short_hw_scan(priv);
  return (0);
}
}
static void iwlagn_recover_from_statistics(struct iwl_priv *priv , struct statistics_rx_phy *cur_ofdm ,
                                           struct statistics_rx_ht_phy *cur_ofdm_ht ,
                                           struct statistics_tx *tx , unsigned long stamp ) 
{ 
  unsigned int msecs ;
    klee_make_symbolic(&msecs, sizeof(int), "msecs");
  int tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;

  {
  tmp = constant_test_bit(5L, (unsigned long const volatile   *)(& priv->status));
  if (tmp != 0) {
    return;
  } else {

  }
  msecs = jiffies_to_msecs(stamp - priv->rx_statistics_jiffies);
  tmp___0 = iwl_is_any_associated___0(priv);
  if (tmp___0 == 0) {
    return;
  } else {

  }
  if (msecs <= 98U) {
    return;
  } else {

  }
  tmp___1 = iwlagn_good_plcp_health(priv, cur_ofdm, cur_ofdm_ht, msecs);
  if (tmp___1) {
    tmp___2 = 0;
  } else {
    tmp___2 = 1;
  }
  if (tmp___2) {
    iwl_force_rf_reset(priv, 0);
  } else {

  }
  return;
}
}
static void iwlagn_rx_calc_noise(struct iwl_priv *priv ) 
{ 
  struct statistics_rx_non_phy *rx_info ;
  int num_active_rx ;
    klee_make_symbolic(&num_active_rx, sizeof(int), "num_active_rx");
  int total_silence ;
    klee_make_symbolic(&total_silence, sizeof(int), "total_silence");
  int bcn_silence_a ;
    klee_make_symbolic(&bcn_silence_a, sizeof(int), "bcn_silence_a");
  int bcn_silence_b ;
    klee_make_symbolic(&bcn_silence_b, sizeof(int), "bcn_silence_b");
  int bcn_silence_c ;
    klee_make_symbolic(&bcn_silence_c, sizeof(int), "bcn_silence_c");
  int last_rx_noise ;
    klee_make_symbolic(&last_rx_noise, sizeof(int), "last_rx_noise");

  {
  num_active_rx = 0;
  total_silence = 0;
  rx_info = & priv->statistics.rx_non_phy;
  bcn_silence_a = (int )rx_info->beacon_silence_rssi_a & 255;
  bcn_silence_b = (int )rx_info->beacon_silence_rssi_b & 255;
  bcn_silence_c = (int )rx_info->beacon_silence_rssi_c & 255;
  if (bcn_silence_a != 0) {
    total_silence = total_silence + bcn_silence_a;
    num_active_rx = num_active_rx + 1;
  } else {

  }
  if (bcn_silence_b != 0) {
    total_silence = total_silence + bcn_silence_b;
    num_active_rx = num_active_rx + 1;
  } else {

  }
  if (bcn_silence_c != 0) {
    total_silence = total_silence + bcn_silence_c;
    num_active_rx = num_active_rx + 1;
  } else {

  }
  if (num_active_rx != 0) {
    last_rx_noise = total_silence / num_active_rx + -107;
  } else {
    last_rx_noise = -127;
  }
  __iwl_dbg(priv->dev, 2097152U, 0, "iwlagn_rx_calc_noise", "inband silence a %u, b %u, c %u, dBm %d\n",
            bcn_silence_a, bcn_silence_b, bcn_silence_c, last_rx_noise);
  return;
}
}
static void accum_stats(__le32 *prev , __le32 *cur , __le32 *delta , __le32 *max_delta ,
                        __le32 *accum , int size ) 
{ 
  int i ;

  {
  i = 0;
  goto ldv_55259;
  ldv_55258: ;
  if (*cur > *prev) {
    *delta = *cur - *prev;
    le32_add_cpu(accum, *delta);
    if (*delta > *max_delta) {
      *max_delta = *delta;
    } else {

    }
  } else {

  }
  i = i + 1;
  prev = prev + 1;
  cur = cur + 1;
  delta = delta + 1;
  max_delta = max_delta + 1;
  accum = accum + 1;
  ldv_55259: ;
  if ((unsigned long )i < (unsigned long )size / 4UL) {
    goto ldv_55258;
  } else {

  }

  return;
}
}
static void iwlagn_accumulative_statistics(struct iwl_priv *priv , struct statistics_general_common *common ,
                                           struct statistics_rx_non_phy *rx_non_phy ,
                                           struct statistics_rx_phy *rx_ofdm , struct statistics_rx_ht_phy *rx_ofdm_ht ,
                                           struct statistics_rx_phy *rx_cck , struct statistics_tx *tx ,
                                           struct statistics_bt_activity *bt_activity ) 
{ 


  {
  accum_stats((__le32 *)(& priv->statistics.common), (__le32 *)common, (__le32 *)(& priv->delta_stats.common),
              (__le32 *)(& priv->max_delta_stats.common), (__le32 *)(& priv->accum_stats.common),
              80);
  accum_stats((__le32 *)(& priv->statistics.rx_non_phy), (__le32 *)rx_non_phy, (__le32 *)(& priv->delta_stats.rx_non_phy),
              (__le32 *)(& priv->max_delta_stats.rx_non_phy), (__le32 *)(& priv->accum_stats.rx_non_phy),
              84);
  accum_stats((__le32 *)(& priv->statistics.rx_ofdm), (__le32 *)rx_ofdm, (__le32 *)(& priv->delta_stats.rx_ofdm),
              (__le32 *)(& priv->max_delta_stats.rx_ofdm), (__le32 *)(& priv->accum_stats.rx_ofdm),
              80);
  accum_stats((__le32 *)(& priv->statistics.rx_ofdm_ht), (__le32 *)rx_ofdm_ht, (__le32 *)(& priv->delta_stats.rx_ofdm_ht),
              (__le32 *)(& priv->max_delta_stats.rx_ofdm_ht), (__le32 *)(& priv->accum_stats.rx_ofdm_ht),
              40);
  accum_stats((__le32 *)(& priv->statistics.rx_cck), (__le32 *)rx_cck, (__le32 *)(& priv->delta_stats.rx_cck),
              (__le32 *)(& priv->max_delta_stats.rx_cck), (__le32 *)(& priv->accum_stats.rx_cck),
              80);
  accum_stats((__le32 *)(& priv->statistics.tx), (__le32 *)tx, (__le32 *)(& priv->delta_stats.tx),
              (__le32 *)(& priv->max_delta_stats.tx), (__le32 *)(& priv->accum_stats.tx),
              104);
  if ((unsigned long )bt_activity != (unsigned long )((struct statistics_bt_activity *)0)) {
    accum_stats((__le32 *)(& priv->statistics.bt_activity), (__le32 *)bt_activity,
                (__le32 *)(& priv->delta_stats.bt_activity), (__le32 *)(& priv->max_delta_stats.bt_activity),
                (__le32 *)(& priv->accum_stats.bt_activity), 32);
  } else {

  }
  return;
}
}
static int iwlagn_rx_statistics(struct iwl_priv *priv , struct iwl_rx_cmd_buffer *rxb ,
                                struct iwl_device_cmd *cmd ) 
{ 
  unsigned long stamp ;
  int reg_recalib_period ;
    klee_make_symbolic(&reg_recalib_period, sizeof(int), "reg_recalib_period");
  int change ;
    klee_make_symbolic(&change, sizeof(int), "change");
  struct iwl_rx_packet *pkt ;
  void *tmp ;
  u32 len ;
  u32 tmp___0 ;
  __le32 *flag ;
  struct statistics_general_common *common ;
  struct statistics_rx_non_phy *rx_non_phy ;
  struct statistics_rx_phy *rx_ofdm ;
  struct statistics_rx_ht_phy *rx_ofdm_ht ;
  struct statistics_rx_phy *rx_cck ;
  struct statistics_tx *tx ;
  struct statistics_bt_activity *bt_activity ;
  struct iwl_bt_notif_statistics *stats ;
  struct iwl_notif_statistics *stats___0 ;
  bool __warned ;
  int __ret_warn_once ;
  int __ret_warn_on ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  unsigned long tmp___4 ;
  int tmp___5 ;
  long tmp___6 ;

  {
  stamp = jiffies;
  reg_recalib_period = 60;
  tmp = rxb_addr(rxb);
  pkt = (struct iwl_rx_packet *)tmp;
  tmp___0 = iwl_rx_packet_payload_len((struct iwl_rx_packet  const  *)pkt);
  len = tmp___0;
  __iwl_dbg(priv->dev, 16777216U, 0, "iwlagn_rx_statistics", "Statistics notification received (%d bytes).\n",
            len);
  spin_lock(& priv->statistics.lock);
  if (len == 524U) {
    stats = (struct iwl_bt_notif_statistics *)(& pkt->data);
    flag = & stats->flag;
    common = & stats->general.common;
    rx_non_phy = & stats->rx.general.common;
    rx_ofdm = & stats->rx.ofdm;
    rx_ofdm_ht = & stats->rx.ofdm_ht;
    rx_cck = & stats->rx.cck;
    tx = & stats->tx;
    bt_activity = & stats->general.activity;
    priv->statistics.num_bt_kills = stats->rx.general.num_bt_kills;
    le32_add_cpu(& priv->statistics.accum_num_bt_kills, stats->rx.general.num_bt_kills);
  } else
  if (len == 480U) {
    stats___0 = (struct iwl_notif_statistics *)(& pkt->data);
    flag = & stats___0->flag;
    common = & stats___0->general.common;
    rx_non_phy = & stats___0->rx.general;
    rx_ofdm = & stats___0->rx.ofdm;
    rx_ofdm_ht = & stats___0->rx.ofdm_ht;
    rx_cck = & stats___0->rx.cck;
    tx = & stats___0->tx;
    bt_activity = (struct statistics_bt_activity *)0;
  } else {
    __ret_warn_once = 1;
    tmp___3 = ldv__builtin_expect(__ret_warn_once != 0, 0L);
    if (tmp___3 != 0L) {
      __ret_warn_on = ! __warned;
      tmp___1 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
      if (tmp___1 != 0L) {
        warn_slowpath_fmt("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/08_1a/drivers/net/wireless/iwlwifi/dvm/rx.c",
                          506, "len %d doesn\'t match BT (%zu) or normal (%zu)\n",
                          len, 524UL, 480UL);
      } else {

      }
      tmp___2 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
      if (tmp___2 != 0L) {
        __warned = 1;
      } else {

      }
    } else {

    }
    ldv__builtin_expect(__ret_warn_once != 0, 0L);
    spin_unlock(& priv->statistics.lock);
    return (0);
  }
  change = common->temperature != priv->statistics.common.temperature || ((*flag ^ priv->statistics.flag) & 8U) != 0U;
  iwlagn_accumulative_statistics(priv, common, rx_non_phy, rx_ofdm, rx_ofdm_ht, rx_cck,
                                 tx, bt_activity);
  iwlagn_recover_from_statistics(priv, rx_ofdm, rx_ofdm_ht, tx, stamp);
  priv->statistics.flag = *flag;
  memcpy((void *)(& priv->statistics.common), (void const   *)common, 80UL);
  memcpy((void *)(& priv->statistics.rx_non_phy), (void const   *)rx_non_phy, 84UL);
  memcpy((void *)(& priv->statistics.rx_ofdm), (void const   *)rx_ofdm, 80UL);
  memcpy((void *)(& priv->statistics.rx_ofdm_ht), (void const   *)rx_ofdm_ht, 40UL);
  memcpy((void *)(& priv->statistics.rx_cck), (void const   *)rx_cck, 80UL);
  memcpy((void *)(& priv->statistics.tx), (void const   *)tx, 104UL);
  if ((unsigned long )bt_activity != (unsigned long )((struct statistics_bt_activity *)0)) {
    memcpy((void *)(& priv->statistics.bt_activity), (void const   *)bt_activity,
             32UL);
  } else {

  }
  priv->rx_statistics_jiffies = stamp;
  set_bit(6L, (unsigned long volatile   *)(& priv->status));
  tmp___4 = msecs_to_jiffies((unsigned int const   )(reg_recalib_period * 1000));
  ldv_mod_timer_190(& priv->statistics_periodic, tmp___4 + (unsigned long )jiffies);
  tmp___5 = constant_test_bit(7L, (unsigned long const volatile   *)(& priv->status));
  tmp___6 = ldv__builtin_expect(tmp___5 == 0, 0L);
  if (tmp___6 != 0L && (unsigned int )pkt->hdr.cmd == 157U) {
    iwlagn_rx_calc_noise(priv);
    queue_work___5(priv->workqueue, & priv->run_time_calib_work);
  } else {

  }
  if ((unsigned long )(priv->lib)->temperature != (unsigned long )((void (*/* const  */)(struct iwl_priv * ))0) && change != 0) {
    (*((priv->lib)->temperature))(priv);
  } else {

  }
  spin_unlock(& priv->statistics.lock);
  return (0);
}
}
static int iwlagn_rx_reply_statistics(struct iwl_priv *priv , struct iwl_rx_cmd_buffer *rxb ,
                                      struct iwl_device_cmd *cmd ) 
{ 
  struct iwl_rx_packet *pkt ;
  void *tmp ;
  struct iwl_notif_statistics *stats ;

  {
  tmp = rxb_addr(rxb);
  pkt = (struct iwl_rx_packet *)tmp;
  stats = (struct iwl_notif_statistics *)(& pkt->data);
  if ((int )stats->flag & 1) {
    memset((void *)(& priv->accum_stats), 0, 500UL);
    memset((void *)(& priv->delta_stats), 0, 500UL);
    memset((void *)(& priv->max_delta_stats), 0, 500UL);
    __iwl_dbg(priv->dev, 16777216U, 0, "iwlagn_rx_reply_statistics", "Statistics have been cleared\n");
  } else {

  }
  iwlagn_rx_statistics(priv, rxb, cmd);
  return (0);
}
}
static int iwlagn_rx_card_state_notif(struct iwl_priv *priv , struct iwl_rx_cmd_buffer *rxb ,
                                      struct iwl_device_cmd *cmd ) 
{ 
  struct iwl_rx_packet *pkt ;
  void *tmp ;
  struct iwl_card_state_notif *card_state_notif ;
  u32 flags ;
  unsigned long status ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  tmp = rxb_addr(rxb);
  pkt = (struct iwl_rx_packet *)tmp;
  card_state_notif = (struct iwl_card_state_notif *)(& pkt->data);
  flags = card_state_notif->flags;
  status = priv->status;
  __iwl_dbg(priv->dev, 131072U, 0, "iwlagn_rx_card_state_notif", "Card state received: HW:%s SW:%s CT:%s\n",
            (int )flags & 1 ? (char *)"Kill" : (char *)"On", (flags & 2U) != 0U ? (char *)"Kill" : (char *)"On",
            (flags & 4U) != 0U ? (char *)"Reached" : (char *)"Not reached");
  if ((flags & 7U) != 0U) {
    iwl_write32___2(priv->trans, 88U, 4U);
    iwl_write_direct32(priv->trans, 1072U, 4U);
    if ((flags & 16U) == 0U) {
      iwl_write32___2(priv->trans, 92U, 4U);
      iwl_write_direct32(priv->trans, 1072U, 4U);
    } else {

    }
    if ((flags & 4U) != 0U) {
      iwl_tt_enter_ct_kill(priv);
    } else {

    }
  } else {

  }
  if ((flags & 4U) == 0U) {
    iwl_tt_exit_ct_kill(priv);
  } else {

  }
  if ((int )flags & 1) {
    set_bit(0L, (unsigned long volatile   *)(& priv->status));
  } else {
    clear_bit(0L, (unsigned long volatile   *)(& priv->status));
  }
  if ((flags & 16U) == 0U) {
    iwl_scan_cancel(priv);
  } else {

  }
  tmp___1 = constant_test_bit(0L, (unsigned long const volatile   *)(& status));
  tmp___2 = constant_test_bit(0L, (unsigned long const volatile   *)(& priv->status));
  if (tmp___1 != tmp___2) {
    tmp___0 = constant_test_bit(0L, (unsigned long const volatile   *)(& priv->status));
    wiphy_rfkill_set_hw_state((priv->hw)->wiphy, tmp___0 != 0);
  } else {

  }
  return (0);
}
}
static int iwlagn_rx_missed_beacon_notif(struct iwl_priv *priv , struct iwl_rx_cmd_buffer *rxb ,
                                         struct iwl_device_cmd *cmd ) 
{ 
  struct iwl_rx_packet *pkt ;
  void *tmp ;
  struct iwl_missed_beacon_notif *missed_beacon ;
  int tmp___0 ;

  {
  tmp = rxb_addr(rxb);
  pkt = (struct iwl_rx_packet *)tmp;
  missed_beacon = (struct iwl_missed_beacon_notif *)(& pkt->data);
  if (missed_beacon->consecutive_missed_beacons > (__le32 )priv->missed_beacon_threshold) {
    __iwl_dbg(priv->dev, 2097152U, 0, "iwlagn_rx_missed_beacon_notif", "missed bcn cnsq %d totl %d rcd %d expctd %d\n",
              missed_beacon->consecutive_missed_beacons, missed_beacon->total_missed_becons,
              missed_beacon->num_recvd_beacons, missed_beacon->num_expected_beacons);
    tmp___0 = constant_test_bit(7L, (unsigned long const volatile   *)(& priv->status));
    if (tmp___0 == 0) {
      iwl_init_sensitivity(priv);
    } else {

    }
  } else {

  }
  return (0);
}
}
static int iwlagn_rx_reply_rx_phy(struct iwl_priv *priv , struct iwl_rx_cmd_buffer *rxb ,
                                  struct iwl_device_cmd *cmd ) 
{ 
  struct iwl_rx_packet *pkt ;
  void *tmp ;

  {
  tmp = rxb_addr(rxb);
  pkt = (struct iwl_rx_packet *)tmp;
  priv->last_phy_res_valid = 1;
  priv->ampdu_ref = priv->ampdu_ref + 1U;
  memcpy((void *)(& priv->last_phy_res), (void const   *)(& pkt->data), 60UL);
  return (0);
}
}
static int iwlagn_set_decrypted_flag(struct iwl_priv *priv , struct ieee80211_hdr *hdr ,
                                     u32 decrypt_res , struct ieee80211_rx_status *stats ) 
{ 
  u16 fc ;

  {
  fc = hdr->frame_control;
  if (((unsigned int )priv->contexts[0].active.filter_flags & 8U) != 0U) {
    return (0);
  } else {

  }
  if (((int )fc & 16384) == 0) {
    return (0);
  } else {

  }
  __iwl_dbg(priv->dev, 16777216U, 0, "iwlagn_set_decrypted_flag", "decrypt_res:0x%x\n",
            decrypt_res);
  switch (decrypt_res & 1792U) {
  case 768U: ;
  if ((decrypt_res & 6144U) == 4096U) {
    goto ldv_55338;
  } else {

  }
  case 256U: ;
  if ((decrypt_res & 6144U) == 2048U) {
    __iwl_dbg(priv->dev, 16777216U, 0, "iwlagn_set_decrypted_flag", "Packet destroyed\n");
    return (-1);
  } else {

  }
  case 512U: ;
  if ((decrypt_res & 6144U) == 6144U) {
    __iwl_dbg(priv->dev, 16777216U, 0, "iwlagn_set_decrypted_flag", "hw decrypt successfully!!!\n");
    stats->flag = stats->flag | 2U;
  } else {

  }
  goto ldv_55338;
  default: ;
  goto ldv_55338;
  }
  ldv_55338: ;
  return (0);
}
}
static void iwlagn_pass_packet_to_mac80211(struct iwl_priv *priv , struct ieee80211_hdr *hdr ,
                                           u16 len , u32 ampdu_status , struct iwl_rx_cmd_buffer *rxb ,
                                           struct ieee80211_rx_status *stats ) 
{ 
  struct sk_buff *skb ;
  __le16 fc ;
  struct iwl_rxon_context *ctx ;
  unsigned int hdrlen ;
    klee_make_symbolic(&hdrlen, sizeof(int), "hdrlen");
  unsigned int fraglen ;
    klee_make_symbolic(&fraglen, sizeof(int), "fraglen");
  long tmp ;
  int tmp___0 ;
  int tmp___1 ;
  unsigned char *tmp___2 ;
  int offset ;
  void *tmp___3 ;
  int tmp___4 ;
  struct page *tmp___5 ;
  bool tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  long tmp___9 ;
  struct ieee80211_rx_status *tmp___10 ;

  {
  fc = hdr->frame_control;
  tmp = ldv__builtin_expect((unsigned int )priv->is_open == 0U, 0L);
  if (tmp != 0L) {
    __iwl_dbg(priv->dev, 8192U, 1, "iwlagn_pass_packet_to_mac80211", "Dropping packet while interface is not open.\n");
    return;
  } else {

  }
  if (iwlwifi_mod_params.sw_crypto == 0) {
    tmp___0 = iwlagn_set_decrypted_flag(priv, hdr, ampdu_status, stats);
    if (tmp___0 != 0) {
      return;
    } else {

    }
  } else {

  }
  skb = alloc_skb(128U, 32U);
  if ((unsigned long )skb == (unsigned long )((struct sk_buff *)0)) {
    __iwl_err(priv->dev, 0, 0, "alloc_skb failed\n");
    return;
  } else {

  }
  tmp___1 = skb_tailroom((struct sk_buff  const  *)skb);
  hdrlen = (int )len <= tmp___1 ? (unsigned int )len : 30U;
  tmp___2 = skb_put(skb, hdrlen);
  memcpy((void *)tmp___2, (void const   *)hdr, (size_t )hdrlen);
  fraglen = (unsigned int )len - hdrlen;
  if (fraglen != 0U) {
    tmp___3 = rxb_addr(rxb);
    tmp___4 = rxb_offset(rxb);
    offset = (int )(((unsigned int )((long )((void *)hdr + (unsigned long )hdrlen)) - (unsigned int )((long )tmp___3)) + (unsigned int )tmp___4);
    tmp___5 = rxb_steal_page(rxb);
    skb_add_rx_frag(skb, 0, tmp___5, offset, (int )fraglen, rxb->truesize);
  } else {

  }
  tmp___8 = ieee80211_is_beacon((int )fc);
  tmp___9 = ldv__builtin_expect((long )(tmp___8 != 0 && (int )priv->passive_no_rx), 0L);
  if (tmp___9 != 0L) {
    ctx = (struct iwl_rxon_context *)(& priv->contexts);
    goto ldv_55359;
    ldv_55358: ;
    if ((int )((unsigned long )priv->valid_contexts >> (int )ctx->ctxid) & 1) {
      tmp___6 = ether_addr_equal((u8 const   *)(& hdr->addr3), (u8 const   *)(& ctx->active.bssid_addr));
      if (tmp___6) {
        tmp___7 = 0;
      } else {
        tmp___7 = 1;
      }
      if (tmp___7) {
        goto ldv_55357;
      } else {

      }
      iwlagn_lift_passive_no_rx(priv);
    } else {

    }
    ldv_55357: 
    ctx = ctx + 1;
    ldv_55359: ;
    if ((unsigned long )((struct iwl_rxon_context *)(& priv->contexts) + 2UL) > (unsigned long )ctx) {
      goto ldv_55358;
    } else {

    }

  } else {

  }
  tmp___10 = IEEE80211_SKB_RXCB(skb);
  memcpy((void *)tmp___10, (void const   *)stats, 40UL);
  ieee80211_rx(priv->hw, skb);
  return;
}
}
static u32 iwlagn_translate_rx_status(struct iwl_priv *priv , u32 decrypt_in ) 
{ 
  u32 decrypt_out ;

  {
  decrypt_out = 0U;
  if ((decrypt_in & 64U) != 0U) {
    decrypt_out = decrypt_out | 192U;
  } else {

  }
  decrypt_out = (decrypt_in & 1792U) | decrypt_out;
  if ((decrypt_in & 1792U) == 0U) {
    return (decrypt_out);
  } else {

  }
  if ((decrypt_in & 1792U) == 1792U) {
    return (decrypt_out);
  } else {

  }
  if ((decrypt_in & 2048U) == 0U) {
    return (decrypt_out);
  } else {

  }
  switch (decrypt_in & 1792U) {
  case 512U: ;
  if ((decrypt_in & 64U) == 0U) {
    decrypt_out = decrypt_out | 2048U;
  } else {
    decrypt_out = decrypt_out | 6144U;
  }
  goto ldv_55367;
  case 768U: ;
  if ((decrypt_in & 128U) == 0U) {
    decrypt_out = decrypt_out | 4096U;
    goto ldv_55367;
  } else {

  }
  default: ;
  if ((decrypt_in & 32U) == 0U) {
    decrypt_out = decrypt_out | 2048U;
  } else {
    decrypt_out = decrypt_out | 6144U;
  }
  goto ldv_55367;
  }
  ldv_55367: 
  __iwl_dbg(priv->dev, 16777216U, 0, "iwlagn_translate_rx_status", "decrypt_in:0x%x  decrypt_out = 0x%x\n",
            decrypt_in, decrypt_out);
  return (decrypt_out);
}
}
static int iwlagn_calc_rssi(struct iwl_priv *priv , struct iwl_rx_phy_res *rx_resp ) 
{ 
  struct iwlagn_non_cfg_phy *ncphy ;
  u32 val ;
  u32 rssi_a ;
  u32 rssi_b ;
  u32 rssi_c ;
  u32 max_rssi ;
  u8 agc ;
  u32 __max1 ;
  u32 __max2 ;
  u32 __max1___0 ;
  u32 __max2___0 ;

  {
  ncphy = (struct iwlagn_non_cfg_phy *)(& rx_resp->non_cfg_phy_buf);
  val = ncphy->non_cfg_phy[1];
  agc = (u8 )((val & 65024U) >> 9);
  val = ncphy->non_cfg_phy[2];
  rssi_a = val & 255U;
  rssi_b = (val & 16711680U) >> 16;
  val = ncphy->non_cfg_phy[3];
  rssi_c = val & 255U;
  __max1 = rssi_a;
  __max2 = rssi_b;
  max_rssi = __max1 > __max2 ? __max1 : __max2;
  __max1___0 = max_rssi;
  __max2___0 = rssi_c;
  max_rssi = __max1___0 > __max2___0 ? __max1___0 : __max2___0;
  __iwl_dbg(priv->dev, 536870912U, 0, "iwlagn_calc_rssi", "Rssi In A %d B %d C %d Max %d AGC dB %d\n",
            rssi_a, rssi_b, rssi_c, max_rssi, (int )agc);
  return ((int )((max_rssi - (u32 )agc) - 44U));
}
}
static int iwlagn_rx_reply_rx(struct iwl_priv *priv , struct iwl_rx_cmd_buffer *rxb ,
                              struct iwl_device_cmd *cmd ) 
{ 
  struct ieee80211_hdr *header ;
  struct ieee80211_rx_status rx_status ;
  struct iwl_rx_packet *pkt ;
  void *tmp ;
  struct iwl_rx_phy_res *phy_res ;
  __le32 rx_pkt_status ;
  struct iwl_rx_mpdu_res_start *amsdu ;
  u32 len ;
  u32 ampdu_status ;
  u32 rate_n_flags ;
  long tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  rx_status.mactime = 0ULL;
  rx_status.device_timestamp = 0U;
  rx_status.ampdu_reference = 0U;
  rx_status.flag = 0U;
  rx_status.freq = (unsigned short)0;
  rx_status.vht_flag = (unsigned char)0;
  rx_status.rate_idx = (unsigned char)0;
  rx_status.vht_nss = (unsigned char)0;
  rx_status.rx_flags = (unsigned char)0;
  rx_status.band = (unsigned char)0;
  rx_status.antenna = (unsigned char)0;
  rx_status.signal = (signed char)0;
  rx_status.chains = (unsigned char)0;
  rx_status.chain_signal[0] = (signed char)0;
  rx_status.chain_signal[1] = (signed char)0;
  rx_status.chain_signal[2] = (signed char)0;
  rx_status.chain_signal[3] = (signed char)0;
  rx_status.ampdu_delimiter_crc = (unsigned char)0;
  tmp = rxb_addr(rxb);
  pkt = (struct iwl_rx_packet *)tmp;
  if (! priv->last_phy_res_valid) {
    __iwl_err(priv->dev, 0, 0, "MPDU frame without cached PHY data\n");
    return (0);
  } else {

  }
  phy_res = & priv->last_phy_res;
  amsdu = (struct iwl_rx_mpdu_res_start *)(& pkt->data);
  header = (struct ieee80211_hdr *)(& pkt->data) + 4U;
  len = (u32 )amsdu->byte_count;
  rx_pkt_status = *((__le32 *)(& pkt->data) + ((unsigned long )len + 4UL));
  ampdu_status = iwlagn_translate_rx_status(priv, rx_pkt_status);
  tmp___0 = ldv__builtin_expect((unsigned int )phy_res->cfg_phy_cnt > 20U, 0L);
  if (tmp___0 != 0L) {
    __iwl_dbg(priv->dev, 8192U, 0, "iwlagn_rx_reply_rx", "dsp size out of range [0,20]: %d\n",
              (int )phy_res->cfg_phy_cnt);
    return (0);
  } else {

  }
  if ((rx_pkt_status & 1U) == 0U || (rx_pkt_status & 2U) == 0U) {
    __iwl_dbg(priv->dev, 16777216U, 0, "iwlagn_rx_reply_rx", "Bad CRC or FIFO: 0x%08X.\n",
              rx_pkt_status);
    return (0);
  } else {

  }
  rate_n_flags = phy_res->rate_n_flags;
  rx_status.mactime = phy_res->timestamp;
  rx_status.band = (int )phy_res->phy_flags & 1 ? 0U : 1U;
  tmp___1 = ieee80211_channel_to_frequency((int )phy_res->channel, (enum ieee80211_band )rx_status.band);
  rx_status.freq = (u16 )tmp___1;
  tmp___2 = iwlagn_hwrate_to_mac80211_idx(rate_n_flags, (enum ieee80211_band )rx_status.band);
  rx_status.rate_idx = (u8 )tmp___2;
  rx_status.flag = 0U;
  priv->ucode_beacon_time = phy_res->beacon_time_stamp;
  tmp___3 = iwlagn_calc_rssi(priv, phy_res);
  rx_status.signal = (s8 )tmp___3;
  __iwl_dbg(priv->dev, 536870912U, 1, "iwlagn_rx_reply_rx", "Rssi %d, TSF %llu\n",
            (int )rx_status.signal, rx_status.mactime);
  rx_status.antenna = (u8 )(((int )phy_res->phy_flags & 112) >> 4);
  if (((int )phy_res->phy_flags & 4) != 0) {
    rx_status.flag = rx_status.flag | 256U;
  } else {

  }
  if (((int )phy_res->phy_flags & 128) != 0) {
    rx_status.flag = rx_status.flag | 16384U;
    rx_status.ampdu_reference = priv->ampdu_ref;
  } else {

  }
  if ((rate_n_flags & 256U) != 0U) {
    rx_status.flag = rx_status.flag | 512U;
  } else {

  }
  if ((rate_n_flags & 2048U) != 0U) {
    rx_status.flag = rx_status.flag | 1024U;
  } else {

  }
  if ((rate_n_flags & 8192U) != 0U) {
    rx_status.flag = rx_status.flag | 2048U;
  } else {

  }
  if ((rate_n_flags & 1024U) != 0U) {
    rx_status.flag = rx_status.flag | 8192U;
  } else {

  }
  iwlagn_pass_packet_to_mac80211(priv, header, (int )((u16 )len), ampdu_status, rxb,
                                 & rx_status);
  return (0);
}
}
extern void __compiletime_assert_1040(void) ;
static int iwlagn_rx_noa_notification(struct iwl_priv *priv , struct iwl_rx_cmd_buffer *rxb ,
                                      struct iwl_device_cmd *cmd ) 
{ 
  struct iwl_wipan_noa_data *new_data ;
  struct iwl_wipan_noa_data *old_data ;
  struct iwl_rx_packet *pkt ;
  void *tmp ;
  struct iwl_wipan_noa_notification *noa_notif ;
  int tmp___0 ;
  u32 len ;
  u32 copylen ;
  void *tmp___1 ;
  bool __cond ;
  struct iwl_wipan_noa_data *__var ;

  {
  tmp = rxb_addr(rxb);
  pkt = (struct iwl_rx_packet *)tmp;
  noa_notif = (struct iwl_wipan_noa_notification *)(& pkt->data);
  tmp___0 = debug_lockdep_rcu_enabled();
  old_data = priv->noa_data;
  if (noa_notif->noa_active != 0U) {
    len = (u32 )noa_notif->noa_attribute.length;
    copylen = len;
    len = len + 6U;
    len = len + 3U;
    copylen = copylen + 3U;
    tmp___1 = kmalloc((unsigned long )len + 24UL, 32U);
    new_data = (struct iwl_wipan_noa_data *)tmp___1;
    if ((unsigned long )new_data != (unsigned long )((struct iwl_wipan_noa_data *)0)) {
      new_data->length = len;
      new_data->data[0] = 221U;
      new_data->data[1] = (unsigned int )((u8 )len) - 2U;
      new_data->data[2] = 80U;
      new_data->data[3] = 111U;
      new_data->data[4] = 154U;
      new_data->data[5] = 9U;
      memcpy((void *)(& new_data->data) + 6U, (void const   *)(& noa_notif->noa_attribute),
               (size_t )copylen);
    } else {

    }
  } else {
    new_data = (struct iwl_wipan_noa_data *)0;
  }
  __cond = 0;
  if ((int )__cond) {
    __compiletime_assert_1040();
  } else {

  }
  __asm__  volatile   ("": : : "memory");
  __var = (struct iwl_wipan_noa_data *)0;
  *((struct iwl_wipan_noa_data * volatile  *)(& priv->noa_data)) = new_data;
  if ((unsigned long )old_data != (unsigned long )((struct iwl_wipan_noa_data *)0)) {
    kfree_call_rcu(& old_data->callback_head, (void (*)(struct callback_head * ))0);
  } else {

  }
  return (0);
}
}
void iwl_setup_rx_handlers(struct iwl_priv *priv ) 
{ 
  int (**handlers)(struct iwl_priv * , struct iwl_rx_cmd_buffer * , struct iwl_device_cmd * ) ;

  {
  handlers = (int (**)(struct iwl_priv * , struct iwl_rx_cmd_buffer * , struct iwl_device_cmd * ))(& priv->rx_handlers);
  *(handlers + 2UL) = & iwlagn_rx_reply_error;
  *(handlers + 115UL) = & iwlagn_rx_csa;
  *(handlers + 117UL) = & iwlagn_rx_spectrum_measure_notif;
  *(handlers + 122UL) = & iwlagn_rx_pm_sleep_notif;
  *(handlers + 123UL) = & iwlagn_rx_pm_debug_statistics_notif;
  *(handlers + 144UL) = & iwlagn_rx_beacon_notif;
  *(handlers + 24UL) = & iwl_add_sta_callback;
  *(handlers + 188UL) = & iwlagn_rx_noa_notification;
  *(handlers + 156UL) = & iwlagn_rx_reply_statistics;
  *(handlers + 157UL) = & iwlagn_rx_statistics;
  iwl_setup_rx_scan_handlers(priv);
  *(handlers + 161UL) = & iwlagn_rx_card_state_notif;
  *(handlers + 162UL) = & iwlagn_rx_missed_beacon_notif;
  *(handlers + 192UL) = & iwlagn_rx_reply_rx_phy;
  *(handlers + 193UL) = & iwlagn_rx_reply_rx;
  *(handlers + 197UL) = & iwlagn_rx_reply_compressed_ba;
  priv->rx_handlers[28] = & iwlagn_rx_reply_tx;
  iwl_notification_wait_init(& priv->notif_wait);
  if ((unsigned long )(priv->lib)->bt_params != (unsigned long )((struct iwl_dvm_bt_params  const  */* const  */)0)) {
    iwlagn_bt_rx_handler_setup(priv);
  } else {

  }
  return;
}
}
int iwl_rx_dispatch(struct iwl_op_mode *op_mode , struct iwl_rx_cmd_buffer *rxb ,
                    struct iwl_device_cmd *cmd ) 
{ 
  struct iwl_rx_packet *pkt ;
  void *tmp ;
  struct iwl_priv *priv ;
  int err ;
  char const   *tmp___0 ;

  {
  tmp = rxb_addr(rxb);
  pkt = (struct iwl_rx_packet *)tmp;
  priv = (struct iwl_priv *)(& op_mode->op_mode_specific);
  err = 0;
  iwl_notification_wait_notify(& priv->notif_wait, pkt);
  if ((unsigned long )priv->rx_handlers[(int )pkt->hdr.cmd] != (unsigned long )((int (*)(struct iwl_priv * ,
                                                                                         struct iwl_rx_cmd_buffer * ,
                                                                                         struct iwl_device_cmd * ))0)) {
    priv->rx_handlers_stats[(int )pkt->hdr.cmd] = priv->rx_handlers_stats[(int )pkt->hdr.cmd] + 1U;
    err = (*(priv->rx_handlers[(int )pkt->hdr.cmd]))(priv, rxb, cmd);
  } else {
    tmp___0 = iwl_dvm_get_cmd_string((int )pkt->hdr.cmd);
    __iwl_dbg(priv->dev, 16777216U, 0, "iwl_rx_dispatch", "No handler needed for %s, 0x%02x\n",
              tmp___0, (int )pkt->hdr.cmd);
  }
  return (err);
}
}
bool ldv_queue_work_on_185(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_7(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_delayed_work_on_186(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_7(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_work_on_187(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_7(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
void ldv_flush_workqueue_188(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
  flush_workqueue(ldv_func_arg1);
  call_and_disable_all_7(2);
  return;
}
}
bool ldv_queue_delayed_work_on_189(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_7(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
int ldv_mod_timer_190(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;

  {
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
  ldv_func_res = tmp;
  activate_pending_timer_18(ldv_func_arg1, ldv_func_arg2, 1);
  return (ldv_func_res);
}
}
__inline static long ldv__builtin_expect(long exp , long c ) ;
bool ldv_queue_work_on_201(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_work_on_203(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_delayed_work_on_202(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
bool ldv_queue_delayed_work_on_205(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
void ldv_flush_workqueue_204(struct workqueue_struct *ldv_func_arg1 ) ;
__inline static void iwl_trans_set_pmi(struct iwl_trans *trans , bool state ) 
{ 


  {
  if ((unsigned long )(trans->ops)->set_pmi != (unsigned long )((void (*/* const  */)(struct iwl_trans * ,
                                                                                      bool  ))0)) {
    (*((trans->ops)->set_pmi))(trans, (int )state);
  } else {

  }
  return;
}
}
int iwl_power_set_mode(struct iwl_priv *priv , struct iwl_powertable_cmd *cmd , bool force ) ;
__inline static bool iwl_advanced_bt_coexist(struct iwl_priv *priv ) 
{ 


  {
  return ((bool )((unsigned long )(priv->lib)->bt_params != (unsigned long )((struct iwl_dvm_bt_params  const  */* const  */)0) && (int )((priv->lib)->bt_params)->advanced_bt_coexist));
}
}
__inline static void iwl_dvm_set_pmi(struct iwl_priv *priv , bool state ) 
{ 


  {
  if ((int )state) {
    set_bit(13L, (unsigned long volatile   *)(& priv->status));
  } else {
    clear_bit(13L, (unsigned long volatile   *)(& priv->status));
  }
  iwl_trans_set_pmi(priv->trans, (int )state);
  return;
}
}
static bool force_cam  =    1;
static struct iwl_power_vec_entry  const  range_0[5U]  = {      {{1U, 0U, 0U, 204800U, 512000U, {1U, 1U, 2U, 2U, 255U}, 0U}, 0U}, 
        {{1U, 0U, 0U, 204800U, 307200U, {1U, 2U, 2U, 2U, 255U}, 0U}, 0U}, 
        {{1U, 0U, 0U, 51200U, 102400U, {2U, 2U, 2U, 2U, 255U}, 0U}, 0U}, 
        {{1U, 0U, 0U, 51200U, 25600U, {2U, 2U, 4U, 4U, 255U}, 0U}, 1U}, 
        {{1U, 0U, 0U, 25600U, 25600U, {2U, 2U, 4U, 6U, 255U}, 0U}, 2U}};
static struct iwl_power_vec_entry  const  range_1[5U]  = {      {{1U, 0U, 0U, 204800U, 512000U, {1U, 2U, 3U, 4U, 4U}, 0U}, 0U}, 
        {{1U, 0U, 0U, 204800U, 307200U, {1U, 2U, 3U, 4U, 7U}, 0U}, 0U}, 
        {{1U, 0U, 0U, 51200U, 102400U, {2U, 4U, 6U, 7U, 9U}, 0U}, 0U}, 
        {{1U, 0U, 0U, 51200U, 25600U, {2U, 4U, 6U, 9U, 10U}, 0U}, 1U}, 
        {{1U, 0U, 0U, 25600U, 25600U, {2U, 4U, 6U, 10U, 10U}, 0U}, 2U}};
static struct iwl_power_vec_entry  const  range_2[5U]  = {      {{1U, 0U, 0U, 204800U, 512000U, {1U, 2U, 3U, 4U, 255U}, 0U}, 0U}, 
        {{1U, 0U, 0U, 204800U, 307200U, {2U, 4U, 6U, 7U, 255U}, 0U}, 0U}, 
        {{1U, 0U, 0U, 51200U, 102400U, {2U, 7U, 9U, 9U, 255U}, 0U}, 0U}, 
        {{1U, 0U, 0U, 51200U, 25600U, {2U, 7U, 9U, 9U, 255U}, 0U}, 0U}, 
        {{1U, 0U, 0U, 25600U, 25600U, {4U, 7U, 10U, 10U, 255U}, 0U}, 0U}};
static struct iwl_power_vec_entry  const  apm_range_0[5U]  = {      {{515U, 0U, 0U, 50U, 50U, {1U, 2U, 4U, 6U, 255U}, 0U}, 0U}, 
        {{515U, 0U, 0U, 50U, 50U, {1U, 2U, 4U, 6U, 255U}, 0U}, 0U}, 
        {{515U, 0U, 0U, 50U, 50U, {1U, 2U, 4U, 6U, 255U}, 0U}, 0U}, 
        {{515U, 0U, 0U, 50U, 50U, {1U, 2U, 4U, 6U, 255U}, 0U}, 0U}, 
        {{515U, 0U, 0U, 50U, 50U, {1U, 2U, 6U, 8U, 255U}, 2U}, 2U}};
static struct iwl_power_vec_entry  const  apm_range_1[5U]  = {      {{515U, 0U, 0U, 50U, 50U, {1U, 2U, 4U, 6U, 255U}, 0U}, 0U}, 
        {{515U, 0U, 0U, 50U, 50U, {1U, 2U, 4U, 6U, 255U}, 0U}, 0U}, 
        {{515U, 0U, 0U, 50U, 50U, {1U, 2U, 4U, 6U, 255U}, 0U}, 0U}, 
        {{515U, 0U, 0U, 50U, 50U, {1U, 2U, 4U, 6U, 255U}, 0U}, 0U}, 
        {{515U, 0U, 0U, 50U, 50U, {1U, 2U, 6U, 8U, 255U}, 0U}, 2U}};
static struct iwl_power_vec_entry  const  apm_range_2[5U]  = {      {{515U, 0U, 0U, 50U, 50U, {1U, 2U, 4U, 6U, 255U}, 0U}, 0U}, 
        {{515U, 0U, 0U, 50U, 50U, {1U, 2U, 4U, 6U, 255U}, 0U}, 0U}, 
        {{515U, 0U, 0U, 50U, 50U, {1U, 2U, 4U, 6U, 255U}, 0U}, 0U}, 
        {{515U, 0U, 0U, 50U, 50U, {1U, 2U, 4U, 6U, 255U}, 0U}, 0U}, 
        {{515U, 0U, 0U, 50U, 50U, {1U, 2U, 6U, 8U, 255U}, 2U}, 2U}};
static void iwl_static_sleep_cmd(struct iwl_priv *priv , struct iwl_powertable_cmd *cmd ,
                                 enum iwl_power_level lvl , int period ) 
{ 
  struct iwl_power_vec_entry  const  *table ;
  int max_sleep[5U] ;
  unsigned int tmp ;
  int i ;
  u8 skip ;
  u32 slp_itrvl ;
  int __ret_warn_on ;
  long tmp___0 ;
  long tmp___1 ;
  bool tmp___2 ;

  {
  max_sleep[0] = 0;
  tmp = 1U;
  while (1) {
    if (tmp >= 5U) {
      break;
    } else {

    }
    max_sleep[tmp] = 0;
    tmp = tmp + 1U;
  }
  if ((int )(priv->lib)->adv_pm) {
    table = (struct iwl_power_vec_entry  const  *)(& apm_range_2);
    if (period <= 10) {
      table = (struct iwl_power_vec_entry  const  *)(& apm_range_1);
    } else {

    }
    if (period <= 2) {
      table = (struct iwl_power_vec_entry  const  *)(& apm_range_0);
    } else {

    }
  } else {
    table = (struct iwl_power_vec_entry  const  *)(& range_2);
    if (period <= 10) {
      table = (struct iwl_power_vec_entry  const  *)(& range_1);
    } else {

    }
    if (period <= 2) {
      table = (struct iwl_power_vec_entry  const  *)(& range_0);
    } else {

    }
  }
  __ret_warn_on = (unsigned int )lvl > 4U;
  tmp___0 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp___0 != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/08_1a/drivers/net/wireless/iwlwifi/dvm/power.c",
                       183);
  } else {

  }
  tmp___1 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp___1 != 0L) {
    memset((void *)cmd, 0, 36UL);
  } else {
    *cmd = (table + (unsigned long )lvl)->cmd;
  }
  if (period == 0) {
    skip = 0U;
    period = 1;
    i = 0;
    goto ldv_55026;
    ldv_55025: 
    max_sleep[i] = 1;
    i = i + 1;
    ldv_55026: ;
    if (i <= 4) {
      goto ldv_55025;
    } else {

    }

  } else {
    skip = (table + (unsigned long )lvl)->no_dtim;
    i = 0;
    goto ldv_55029;
    ldv_55028: 
    max_sleep[i] = (int )cmd->sleep_interval[i];
    i = i + 1;
    ldv_55029: ;
    if (i <= 4) {
      goto ldv_55028;
    } else {

    }
    max_sleep[4] = (int )skip + 1;
  }
  slp_itrvl = cmd->sleep_interval[4];
  if (slp_itrvl == 255U) {
    cmd->sleep_interval[4] = (unsigned int )(((int )skip + 1) * period);
  } else {

  }
  slp_itrvl = cmd->sleep_interval[4];
  if ((u32 )period < slp_itrvl) {
    cmd->sleep_interval[4] = (slp_itrvl / (u32 )period) * (u32 )period;
  } else {

  }
  if ((unsigned int )skip != 0U) {
    cmd->flags = (__le16 )((unsigned int )cmd->flags | 4U);
  } else {
    cmd->flags = (unsigned int )cmd->flags & 65531U;
  }
  if ((int )((priv->cfg)->base_params)->shadow_reg_enable) {
    cmd->flags = (__le16 )((unsigned int )cmd->flags | 64U);
  } else {
    cmd->flags = (unsigned int )cmd->flags & 65471U;
  }
  tmp___2 = iwl_advanced_bt_coexist(priv);
  if ((int )tmp___2) {
    if (! ((_Bool )((priv->lib)->bt_params)->bt_sco_disable)) {
      cmd->flags = (__le16 )((unsigned int )cmd->flags | 256U);
    } else {
      cmd->flags = (unsigned int )cmd->flags & 65279U;
    }
  } else {

  }
  slp_itrvl = cmd->sleep_interval[4];
  if (slp_itrvl > 10U) {
    cmd->sleep_interval[4] = 10U;
  } else {

  }
  i = 4;
  goto ldv_55032;
  ldv_55031: ;
  if (cmd->sleep_interval[i] > (__le32 )(max_sleep[i] * period)) {
    cmd->sleep_interval[i] = (unsigned int )(max_sleep[i] * period);
  } else {

  }
  if (i != 4) {
    if (cmd->sleep_interval[i] > cmd->sleep_interval[i + 1]) {
      cmd->sleep_interval[i] = cmd->sleep_interval[i + 1];
    } else {

    }
  } else {

  }
  i = i - 1;
  ldv_55032: ;
  if (i >= 0) {
    goto ldv_55031;
  } else {

  }

  if ((int )priv->power_data.bus_pm) {
    cmd->flags = (__le16 )((unsigned int )cmd->flags | 8U);
  } else {
    cmd->flags = (unsigned int )cmd->flags & 65527U;
  }
  __iwl_dbg(priv->dev, 256U, 0, "iwl_static_sleep_cmd", "numSkipDtim = %u, dtimPeriod = %d\n",
            (int )skip, period);
  __iwl_dbg(priv->dev, 256U, 0, "iwl_static_sleep_cmd", "Sleep command for index %d\n",
            (unsigned int )lvl + 1U);
  return;
}
}
static void iwl_power_sleep_cam_cmd(struct iwl_priv *priv , struct iwl_powertable_cmd *cmd ) 
{ 


  {
  memset((void *)cmd, 0, 36UL);
  if ((int )priv->power_data.bus_pm) {
    cmd->flags = (__le16 )((unsigned int )cmd->flags | 8U);
  } else {

  }
  __iwl_dbg(priv->dev, 256U, 0, "iwl_power_sleep_cam_cmd", "Sleep command for CAM\n");
  return;
}
}
static int iwl_set_power(struct iwl_priv *priv , struct iwl_powertable_cmd *cmd ) 
{ 
  int tmp ;

  {
  __iwl_dbg(priv->dev, 256U, 0, "iwl_set_power", "Sending power/sleep command\n");
  __iwl_dbg(priv->dev, 256U, 0, "iwl_set_power", "Flags value = 0x%08X\n", (int )cmd->flags);
  __iwl_dbg(priv->dev, 256U, 0, "iwl_set_power", "Tx timeout = %u\n", cmd->tx_data_timeout);
  __iwl_dbg(priv->dev, 256U, 0, "iwl_set_power", "Rx timeout = %u\n", cmd->rx_data_timeout);
  __iwl_dbg(priv->dev, 256U, 0, "iwl_set_power", "Sleep interval vector = { %d , %d , %d , %d , %d }\n",
            cmd->sleep_interval[0], cmd->sleep_interval[1], cmd->sleep_interval[2],
            cmd->sleep_interval[3], cmd->sleep_interval[4]);
  tmp = iwl_dvm_send_cmd_pdu(priv, 119, 0U, 36, (void const   *)cmd);
  return (tmp);
}
}
static void iwl_power_build_cmd(struct iwl_priv *priv , struct iwl_powertable_cmd *cmd ) 
{ 
  bool enabled ;
  int dtimper ;
    klee_make_symbolic(&dtimper, sizeof(int), "dtimper");
  u8 tmp ;
  bool tmp___0 ;

  {
  enabled = ((priv->hw)->conf.flags & 2U) != 0U;
  if ((int )force_cam) {
    iwl_power_sleep_cam_cmd(priv, cmd);
    return;
  } else {

  }
  dtimper = (int )(priv->hw)->conf.ps_dtim_period != 0 ? (int )(priv->hw)->conf.ps_dtim_period != 0 : 1;
  if ((int )priv->wowlan) {
    iwl_static_sleep_cmd(priv, cmd, 4, dtimper);
  } else
  if (! ((_Bool )(priv->lib)->no_idle_support) && ((priv->hw)->conf.flags & 4U) != 0U) {
    iwl_static_sleep_cmd(priv, cmd, 4, 20);
  } else {
    tmp___0 = iwl_tt_is_low_power_state(priv);
    if ((int )tmp___0) {
      tmp = iwl_tt_current_power_mode(priv);
      iwl_static_sleep_cmd(priv, cmd, (enum iwl_power_level )tmp, dtimper);
    } else
    if (! enabled) {
      iwl_power_sleep_cam_cmd(priv, cmd);
    } else
    if (priv->power_data.debug_sleep_level_override >= 0) {
      iwl_static_sleep_cmd(priv, cmd, (enum iwl_power_level )priv->power_data.debug_sleep_level_override,
                           dtimper);
    } else
    if (iwlwifi_mod_params.power_level > 0 && iwlwifi_mod_params.power_level <= 5) {
      iwl_static_sleep_cmd(priv, cmd, (enum iwl_power_level )(iwlwifi_mod_params.power_level + -1),
                           dtimper);
    } else {
      iwl_static_sleep_cmd(priv, cmd, 0, dtimper);
    }
  }
  return;
}
}
int iwl_power_set_mode(struct iwl_priv *priv , struct iwl_powertable_cmd *cmd , bool force ) 
{ 
  int ret ;
  bool update_chains ;
  int __ret_warn_on ;
  int tmp ;
  int tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  if (debug_locks != 0) {
    tmp = lock_is_held(& priv->mutex.dep_map);
    if (tmp == 0) {
      tmp___0 = 1;
    } else {
      tmp___0 = 0;
    }
  } else {
    tmp___0 = 0;
  }
  __ret_warn_on = tmp___0;
  tmp___1 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp___1 != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/08_1a/drivers/net/wireless/iwlwifi/dvm/power.c",
                       336);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  update_chains = (bool )((unsigned int )priv->chain_noise_data.state == 3U || (unsigned int )priv->chain_noise_data.state == 0U);
  tmp___2 = memcmp((void const   *)(& priv->power_data.sleep_cmd), (void const   *)cmd,
                   36UL);
  if (tmp___2 == 0 && ! force) {
    return (0);
  } else {

  }
  tmp___3 = iwl_is_ready_rf(priv);
  if (tmp___3 == 0) {
    return (-5);
  } else {

  }
  memcpy((void *)(& priv->power_data.sleep_cmd_next), (void const   *)cmd, 36UL);
  tmp___4 = constant_test_bit(7L, (unsigned long const volatile   *)(& priv->status));
  if (tmp___4 != 0 && ! force) {
    __iwl_dbg(priv->dev, 1U, 0, "iwl_power_set_mode", "Defer power set mode while scanning\n");
    return (0);
  } else {

  }
  if ((int )cmd->flags & 1) {
    iwl_dvm_set_pmi(priv, 1);
  } else {

  }
  ret = iwl_set_power(priv, cmd);
  if (ret == 0) {
    if (((int )cmd->flags & 1) == 0) {
      iwl_dvm_set_pmi(priv, 0);
    } else {

    }
    if ((int )update_chains) {
      iwl_update_chain_flags(priv);
    } else {
      __iwl_dbg(priv->dev, 256U, 0, "iwl_power_set_mode", "Cannot update the power, chain noise calibration running: %d\n",
                (int )priv->chain_noise_data.state);
    }
    memcpy((void *)(& priv->power_data.sleep_cmd), (void const   *)cmd, 36UL);
  } else {
    __iwl_err(priv->dev, 0, 0, "set power fail, ret = %d\n", ret);
  }
  return (ret);
}
}
int iwl_power_update_mode(struct iwl_priv *priv , bool force ) 
{ 
  struct iwl_powertable_cmd cmd ;
  int tmp ;

  {
  iwl_power_build_cmd(priv, & cmd);
  tmp = iwl_power_set_mode(priv, & cmd, (int )force);
  return (tmp);
}
}
void iwl_power_initialize(struct iwl_priv *priv ) 
{ 


  {
  priv->power_data.bus_pm = (priv->trans)->pm_support;
  priv->power_data.debug_sleep_level_override = -1;
  memset((void *)(& priv->power_data.sleep_cmd), 0, 36UL);
  return;
}
}
bool ldv_queue_work_on_201(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_7(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_delayed_work_on_202(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_7(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_work_on_203(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_7(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
void ldv_flush_workqueue_204(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
  flush_workqueue(ldv_func_arg1);
  call_and_disable_all_7(2);
  return;
}
}
bool ldv_queue_delayed_work_on_205(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_7(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
__inline static long ldv__builtin_expect(long exp , long c ) ;
__inline static int fls(int x ) 
{ 
  int r ;

  {
  __asm__  ("bsrl %1,%0": "=r" (r): "rm" (x), "0" (-1));
  return (r + 1);
}
}
extern void init_timer_key(struct timer_list * , unsigned int  , char const   * ,
                           struct lock_class_key * ) ;
extern void delayed_work_timer_fn(unsigned long  ) ;
bool ldv_queue_work_on_215(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_work_on_217(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_delayed_work_on_216(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
bool ldv_queue_delayed_work_on_219(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
void ldv_flush_workqueue_218(struct workqueue_struct *ldv_func_arg1 ) ;
bool ldv_cancel_work_sync_222(struct work_struct *ldv_func_arg1 ) ;
bool ldv_cancel_work_sync_223(struct work_struct *ldv_func_arg1 ) ;
bool ldv_cancel_work_sync_224(struct work_struct *ldv_func_arg1 ) ;
extern bool cancel_delayed_work(struct delayed_work * ) ;
bool ldv_cancel_delayed_work_220(struct delayed_work *ldv_func_arg1 ) ;
bool ldv_cancel_delayed_work_221(struct delayed_work *ldv_func_arg1 ) ;
extern bool cancel_delayed_work_sync(struct delayed_work * ) ;
bool ldv_cancel_delayed_work_sync_225(struct delayed_work *ldv_func_arg1 ) ;
__inline static bool queue_work___6(struct workqueue_struct *wq , struct work_struct *work ) 
{ 
  bool tmp ;

  {
  tmp = ldv_queue_work_on_215(8192, wq, work);
  return (tmp);
}
}
__inline static bool queue_delayed_work(struct workqueue_struct *wq , struct delayed_work *dwork ,
                                        unsigned long delay ) 
{ 
  bool tmp ;

  {
  tmp = ldv_queue_delayed_work_on_216(8192, wq, dwork, delay);
  return (tmp);
}
}
void call_and_disable_all_14(int state ) ;
void call_and_disable_work_13(struct work_struct *work ) ;
void activate_work_13(struct work_struct *work , int state ) ;
void disable_work_14(struct work_struct *work ) ;
void call_and_disable_all_11(int state ) ;
void call_and_disable_all_12(int state ) ;
void invoke_work_14(void) ;
void invoke_work_11(void) ;
void call_and_disable_work_14(struct work_struct *work ) ;
void disable_work_13(struct work_struct *work ) ;
void invoke_work_12(void) ;
void call_and_disable_work_12(struct work_struct *work ) ;
void activate_work_11(struct work_struct *work , int state ) ;
void disable_work_11(struct work_struct *work ) ;
void disable_work_12(struct work_struct *work ) ;
void activate_work_12(struct work_struct *work , int state ) ;
void invoke_work_13(void) ;
void call_and_disable_work_11(struct work_struct *work ) ;
void activate_work_14(struct work_struct *work , int state ) ;
void call_and_disable_all_13(int state ) ;
__inline static void eth_broadcast_addr(u8 *addr ) 
{ 


  {
  memset((void *)addr, 255, 6UL);
  return;
}
}
extern void ieee80211_scan_completed(struct ieee80211_hw * , bool  ) ;
__inline static int iwl_is_any_associated___1(struct iwl_priv *priv ) 
{ 
  struct iwl_rxon_context *ctx ;
  int tmp ;

  {
  ctx = (struct iwl_rxon_context *)(& priv->contexts);
  goto ldv_53258;
  ldv_53257: ;
  if ((int )((unsigned long )priv->valid_contexts >> (int )ctx->ctxid) & 1) {
    tmp = iwl_is_associated_ctx(ctx);
    if (tmp != 0) {
      return (1);
    } else {

    }
  } else {

  }
  ctx = ctx + 1;
  ldv_53258: ;
  if ((unsigned long )((struct iwl_rxon_context *)(& priv->contexts) + 2UL) > (unsigned long )ctx) {
    goto ldv_53257;
  } else {

  }

  return (0);
}
}
int iwlagn_set_pan_params(struct iwl_priv *priv ) ;
__inline static struct ieee80211_supported_band  const  *iwl_get_hw_mode(struct iwl_priv *priv ,
                                                                         enum ieee80211_band band ) 
{ 


  {
  return ((struct ieee80211_supported_band  const  *)((priv->hw)->wiphy)->bands[(unsigned int )band]);
}
}
void iwlagn_post_scan(struct iwl_priv *priv ) ;
static int iwl_send_scan_abort(struct iwl_priv *priv ) 
{ 
  int ret ;
  struct iwl_host_cmd cmd ;
  __le32 *status ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  cmd.data[0] = 0;
  cmd.data[1] = 0;
  cmd.resp_pkt = 0;
  cmd._rx_page_addr = 0UL;
  cmd._rx_page_order = 0U;
  cmd.handler_status = 0;
  cmd.flags = 2U;
  cmd.len[0] = (unsigned short)0;
  cmd.len[1] = (unsigned short)0;
  cmd.dataflags[0] = (unsigned char)0;
  cmd.dataflags[1] = (unsigned char)0;
  cmd.id = 129U;
  tmp = constant_test_bit(3L, (unsigned long const volatile   *)(& priv->status));
  if (tmp == 0) {
    return (-5);
  } else {
    tmp___0 = constant_test_bit(9L, (unsigned long const volatile   *)(& priv->status));
    if (tmp___0 == 0) {
      return (-5);
    } else {
      tmp___1 = constant_test_bit(10L, (unsigned long const volatile   *)(& priv->status));
      if (tmp___1 != 0) {
        return (-5);
      } else {

      }
    }
  }
  ret = iwl_dvm_send_cmd(priv, & cmd);
  if (ret != 0) {
    return (ret);
  } else {

  }
  status = (__le32 *)(& (cmd.resp_pkt)->data);
  if (*status != 1U) {
    __iwl_dbg(priv->dev, 2048U, 0, "iwl_send_scan_abort", "SCAN_ABORT ret %d.\n",
              *status);
    ret = -5;
  } else {

  }
  iwl_free_resp(& cmd);
  return (ret);
}
}
static void iwl_complete_scan(struct iwl_priv *priv , bool aborted ) 
{ 


  {
  if ((unsigned long )priv->scan_request != (unsigned long )((struct cfg80211_scan_request *)0)) {
    __iwl_dbg(priv->dev, 2048U, 0, "iwl_complete_scan", "Complete scan in mac80211\n");
    ieee80211_scan_completed(priv->hw, (int )aborted);
  } else {

  }
  priv->scan_type = 0;
  priv->scan_vif = (struct ieee80211_vif *)0;
  priv->scan_request = (struct cfg80211_scan_request *)0;
  return;
}
}
static void iwl_process_scan_complete(struct iwl_priv *priv ) 
{ 
  bool aborted ;
  int __ret_warn_on ;
  int tmp ;
  int tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int err ;
  int tmp___5 ;

  {
  if (debug_locks != 0) {
    tmp = lock_is_held(& priv->mutex.dep_map);
    if (tmp == 0) {
      tmp___0 = 1;
    } else {
      tmp___0 = 0;
    }
  } else {
    tmp___0 = 0;
  }
  __ret_warn_on = tmp___0;
  tmp___1 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp___1 != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/08_1a/drivers/net/wireless/iwlwifi/dvm/scan.c",
                       112);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  tmp___2 = test_and_clear_bit(12L, (unsigned long volatile   *)(& priv->status));
  if (tmp___2 == 0) {
    return;
  } else {

  }
  __iwl_dbg(priv->dev, 2048U, 0, "iwl_process_scan_complete", "Completed scan.\n");
  ldv_cancel_delayed_work_220(& priv->scan_check);
  tmp___3 = test_and_clear_bit(8L, (unsigned long volatile   *)(& priv->status));
  aborted = tmp___3 != 0;
  if ((int )aborted) {
    __iwl_dbg(priv->dev, 2048U, 0, "iwl_process_scan_complete", "Aborted scan completed.\n");
  } else {

  }
  tmp___4 = test_and_clear_bit(7L, (unsigned long volatile   *)(& priv->status));
  if (tmp___4 == 0) {
    __iwl_dbg(priv->dev, 2048U, 0, "iwl_process_scan_complete", "Scan already completed.\n");
    goto out_settings;
  } else {

  }
  if ((unsigned int )priv->scan_type != 0U && ! aborted) {
    if ((unsigned long )priv->scan_request == (unsigned long )((struct cfg80211_scan_request *)0)) {
      goto out_complete;
    } else {

    }
    err = iwl_scan_initiate(priv, priv->scan_vif, 0, ((priv->scan_request)->channels[0])->band);
    if (err != 0) {
      __iwl_dbg(priv->dev, 2048U, 0, "iwl_process_scan_complete", "failed to initiate pending scan: %d\n",
                err);
      aborted = 1;
      goto out_complete;
    } else {

    }
    return;
  } else {

  }
  out_complete: 
  iwl_complete_scan(priv, (int )aborted);
  out_settings: 
  tmp___5 = iwl_is_ready_rf(priv);
  if (tmp___5 == 0) {
    return;
  } else {

  }
  iwlagn_post_scan(priv);
  return;
}
}
void iwl_force_scan_end(struct iwl_priv *priv ) 
{ 
  int __ret_warn_on ;
  int tmp ;
  int tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;

  {
  if (debug_locks != 0) {
    tmp = lock_is_held(& priv->mutex.dep_map);
    if (tmp == 0) {
      tmp___0 = 1;
    } else {
      tmp___0 = 0;
    }
  } else {
    tmp___0 = 0;
  }
  __ret_warn_on = tmp___0;
  tmp___1 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp___1 != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/08_1a/drivers/net/wireless/iwlwifi/dvm/scan.c",
                       163);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  tmp___2 = constant_test_bit(7L, (unsigned long const volatile   *)(& priv->status));
  if (tmp___2 == 0) {
    __iwl_dbg(priv->dev, 2048U, 0, "iwl_force_scan_end", "Forcing scan end while not scanning\n");
    return;
  } else {

  }
  __iwl_dbg(priv->dev, 2048U, 0, "iwl_force_scan_end", "Forcing scan end\n");
  clear_bit(7L, (unsigned long volatile   *)(& priv->status));
  clear_bit(9L, (unsigned long volatile   *)(& priv->status));
  clear_bit(8L, (unsigned long volatile   *)(& priv->status));
  clear_bit(12L, (unsigned long volatile   *)(& priv->status));
  iwl_complete_scan(priv, 1);
  return;
}
}
static void iwl_do_scan_abort(struct iwl_priv *priv ) 
{ 
  int ret ;
  int __ret_warn_on ;
  int tmp ;
  int tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  if (debug_locks != 0) {
    tmp = lock_is_held(& priv->mutex.dep_map);
    if (tmp == 0) {
      tmp___0 = 1;
    } else {
      tmp___0 = 0;
    }
  } else {
    tmp___0 = 0;
  }
  __ret_warn_on = tmp___0;
  tmp___1 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp___1 != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/08_1a/drivers/net/wireless/iwlwifi/dvm/scan.c",
                       182);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  tmp___2 = constant_test_bit(7L, (unsigned long const volatile   *)(& priv->status));
  if (tmp___2 == 0) {
    __iwl_dbg(priv->dev, 2048U, 0, "iwl_do_scan_abort", "Not performing scan to abort\n");
    return;
  } else {

  }
  tmp___3 = test_and_set_bit(8L, (unsigned long volatile   *)(& priv->status));
  if (tmp___3 != 0) {
    __iwl_dbg(priv->dev, 2048U, 0, "iwl_do_scan_abort", "Scan abort in progress\n");
    return;
  } else {

  }
  ret = iwl_send_scan_abort(priv);
  if (ret != 0) {
    __iwl_dbg(priv->dev, 2048U, 0, "iwl_do_scan_abort", "Send scan abort failed %d\n",
              ret);
    iwl_force_scan_end(priv);
  } else {
    __iwl_dbg(priv->dev, 2048U, 0, "iwl_do_scan_abort", "Successfully send scan abort\n");
  }
  return;
}
}
int iwl_scan_cancel(struct iwl_priv *priv ) 
{ 


  {
  __iwl_dbg(priv->dev, 2048U, 0, "iwl_scan_cancel", "Queuing abort scan\n");
  queue_work___6(priv->workqueue, & priv->abort_scan);
  return (0);
}
}
void iwl_scan_cancel_timeout(struct iwl_priv *priv , unsigned long ms ) 
{ 
  unsigned long timeout ;
  unsigned long tmp ;
  int __ret_warn_on ;
  int tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;
  int tmp___3 ;

  {
  tmp = msecs_to_jiffies((unsigned int const   )ms);
  timeout = tmp + (unsigned long )jiffies;
  if (debug_locks != 0) {
    tmp___0 = lock_is_held(& priv->mutex.dep_map);
    if (tmp___0 == 0) {
      tmp___1 = 1;
    } else {
      tmp___1 = 0;
    }
  } else {
    tmp___1 = 0;
  }
  __ret_warn_on = tmp___1;
  tmp___2 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp___2 != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/08_1a/drivers/net/wireless/iwlwifi/dvm/scan.c",
                       221);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  __iwl_dbg(priv->dev, 2048U, 0, "iwl_scan_cancel_timeout", "Scan cancel timeout\n");
  iwl_do_scan_abort(priv);
  goto ldv_53716;
  ldv_53715: 
  tmp___3 = constant_test_bit(9L, (unsigned long const volatile   *)(& priv->status));
  if (tmp___3 == 0) {
    goto finished;
  } else {

  }
  msleep(20U);
  ldv_53716: ;
  if ((long )(timeout - (unsigned long )jiffies) >= 0L) {
    goto ldv_53715;
  } else {

  }

  return;
  finished: 
  iwl_process_scan_complete(priv);
  return;
}
}
static int iwl_rx_reply_scan(struct iwl_priv *priv , struct iwl_rx_cmd_buffer *rxb ,
                             struct iwl_device_cmd *cmd ) 
{ 
  struct iwl_rx_packet *pkt ;
  void *tmp ;
  struct iwl_scanreq_notification *notif ;

  {
  tmp = rxb_addr(rxb);
  pkt = (struct iwl_rx_packet *)tmp;
  notif = (struct iwl_scanreq_notification *)(& pkt->data);
  __iwl_dbg(priv->dev, 2048U, 0, "iwl_rx_reply_scan", "Scan request status = 0x%x\n",
            notif->status);
  return (0);
}
}
static int iwl_rx_scan_start_notif(struct iwl_priv *priv , struct iwl_rx_cmd_buffer *rxb ,
                                   struct iwl_device_cmd *cmd ) 
{ 
  struct iwl_rx_packet *pkt ;
  void *tmp ;
  struct iwl_scanstart_notification *notif ;

  {
  tmp = rxb_addr(rxb);
  pkt = (struct iwl_rx_packet *)tmp;
  notif = (struct iwl_scanstart_notification *)(& pkt->data);
  priv->scan_start_tsf = (unsigned long )notif->tsf_low;
  __iwl_dbg(priv->dev, 2048U, 0, "iwl_rx_scan_start_notif", "Scan start: %d [802.11%s] (TSF: 0x%08X:%08X) - %d (beacon timer %u)\n",
            (int )notif->channel, (unsigned int )notif->band != 0U ? (char *)"bg" : (char *)"a",
            notif->tsf_high, notif->tsf_low, notif->status, notif->beacon_timer);
  return (0);
}
}
static int iwl_rx_scan_results_notif(struct iwl_priv *priv , struct iwl_rx_cmd_buffer *rxb ,
                                     struct iwl_device_cmd *cmd ) 
{ 
  struct iwl_rx_packet *pkt ;
  void *tmp ;
  struct iwl_scanresults_notification *notif ;

  {
  tmp = rxb_addr(rxb);
  pkt = (struct iwl_rx_packet *)tmp;
  notif = (struct iwl_scanresults_notification *)(& pkt->data);
  __iwl_dbg(priv->dev, 2048U, 0, "iwl_rx_scan_results_notif", "Scan ch.res: %d [802.11%s] probe status: %u:%u (TSF: 0x%08X:%08X) - %d elapsed=%lu usec\n",
            (int )notif->channel, (unsigned int )notif->band != 0U ? (char *)"bg" : (char *)"a",
            (int )notif->probe_status, (int )notif->num_probe_not_sent, notif->tsf_high,
            notif->tsf_low, notif->statistics[0], (unsigned long )notif->tsf_low - priv->scan_start_tsf);
  return (0);
}
}
static int iwl_rx_scan_complete_notif(struct iwl_priv *priv , struct iwl_rx_cmd_buffer *rxb ,
                                      struct iwl_device_cmd *cmd ) 
{ 
  struct iwl_rx_packet *pkt ;
  void *tmp ;
  struct iwl_scancomplete_notification *scan_notif ;
  unsigned int tmp___0 ;
  bool tmp___1 ;

  {
  tmp = rxb_addr(rxb);
  pkt = (struct iwl_rx_packet *)tmp;
  scan_notif = (struct iwl_scancomplete_notification *)(& pkt->data);
  __iwl_dbg(priv->dev, 2048U, 0, "iwl_rx_scan_complete_notif", "Scan complete: %d channels (TSF 0x%08X:%08X) - %d\n",
            (int )scan_notif->scanned_channels, scan_notif->tsf_low, scan_notif->tsf_high,
            (int )scan_notif->status);
  tmp___0 = jiffies_to_msecs((unsigned long )jiffies - priv->scan_start);
  __iwl_dbg(priv->dev, 2048U, 0, "iwl_rx_scan_complete_notif", "Scan on %sGHz took %dms\n",
            (unsigned int )priv->scan_band == 0U ? (char *)"2.4" : (char *)"5.2",
            tmp___0);
  set_bit(12L, (unsigned long volatile   *)(& priv->status));
  clear_bit(9L, (unsigned long volatile   *)(& priv->status));
  queue_work___6(priv->workqueue, & priv->scan_completed);
  if ((unsigned int )priv->iw_mode != 1U) {
    tmp___1 = iwl_advanced_bt_coexist(priv);
    if ((int )tmp___1) {
      if ((int )priv->bt_status != (int )scan_notif->bt_status) {
        if ((unsigned int )scan_notif->bt_status != 0U) {
          if (! priv->bt_ch_announce) {
            priv->bt_traffic_load = 2U;
          } else {

          }
        } else {
          priv->bt_traffic_load = 0U;
        }
        priv->bt_status = scan_notif->bt_status;
        queue_work___6(priv->workqueue, & priv->bt_traffic_change_work);
      } else {

      }
    } else {

    }
  } else {

  }
  return (0);
}
}
void iwl_setup_rx_scan_handlers(struct iwl_priv *priv ) 
{ 


  {
  priv->rx_handlers[128] = & iwl_rx_reply_scan;
  priv->rx_handlers[130] = & iwl_rx_scan_start_notif;
  priv->rx_handlers[131] = & iwl_rx_scan_results_notif;
  priv->rx_handlers[132] = & iwl_rx_scan_complete_notif;
  return;
}
}
static u16 iwl_get_active_dwell_time(struct iwl_priv *priv , enum ieee80211_band band ,
                                     u8 n_probes ) 
{ 


  {
  if ((unsigned int )band == 1U) {
    return ((unsigned int )((u16 )((int )n_probes + 11)) * 2U);
  } else {
    return ((unsigned int )((u16 )((int )n_probes + 1)) * 3U + 30U);
  }
}
}
static u16 iwl_limit_dwell(struct iwl_priv *priv , u16 dwell_time ) 
{ 
  struct iwl_rxon_context *ctx ;
  int limits[2U] ;
  int n_active ;
    klee_make_symbolic(&n_active, sizeof(int), "n_active");
  u16 limit ;
  int tmp ;
  int tmp___0 ;
  u16 _min1 ;
  u16 _min2 ;
  u16 _min1___0 ;
  u16 _min2___0 ;
  bool __warned ;
  int __ret_warn_once ;
  int __ret_warn_on ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;

  {
  limits[0] = 0;
  limits[1] = 0;
  n_active = 0;
  ctx = (struct iwl_rxon_context *)(& priv->contexts);
  goto ldv_53774;
  ldv_53773: ;
  if ((int )((unsigned long )priv->valid_contexts >> (int )ctx->ctxid) & 1) {
    switch ((int )ctx->staging.dev_type) {
    case 9: ;
    goto ldv_53767;
    case 3: ;
    default: 
    tmp = iwl_is_associated_ctx(ctx);
    if (tmp == 0) {
      goto ldv_53767;
    } else {

    }
    goto ldv_53770;
    case 7: ;
    case 8: ;
    goto ldv_53770;
    }
    ldv_53770: 
    tmp___0 = n_active;
    n_active = n_active + 1;
    limits[tmp___0] = ctx->beacon_int != 0 ? ctx->beacon_int != 0 : 100;
  } else {

  }
  ldv_53767: 
  ctx = ctx + 1;
  ldv_53774: ;
  if ((unsigned long )((struct iwl_rxon_context *)(& priv->contexts) + 2UL) > (unsigned long )ctx) {
    goto ldv_53773;
  } else {

  }

  switch (n_active) {
  case 0: ;
  return (dwell_time);
  case 2: 
  limit = (unsigned int )((u16 )((limits[1] * 98) / 100)) + 65526U;
  limit = (u16 )((unsigned int )limit / 2U);
  _min1 = limit;
  _min2 = dwell_time;
  dwell_time = (u16 )((int )_min1 < (int )_min2 ? _min1 : _min2);
  case 1: 
  limit = (unsigned int )((u16 )((limits[0] * 98) / 100)) + 65526U;
  limit = (u16 )((int )limit / n_active);
  _min1___0 = limit;
  _min2___0 = dwell_time;
  return ((u16 )((int )_min1___0 < (int )_min2___0 ? _min1___0 : _min2___0));
  default: 
  __ret_warn_once = 1;
  tmp___3 = ldv__builtin_expect(__ret_warn_once != 0, 0L);
  if (tmp___3 != 0L) {
    __ret_warn_on = ! __warned;
    tmp___1 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
    if (tmp___1 != 0L) {
      warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/08_1a/drivers/net/wireless/iwlwifi/dvm/scan.c",
                         437);
    } else {

    }
    tmp___2 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
    if (tmp___2 != 0L) {
      __warned = 1;
    } else {

    }
  } else {

  }
  ldv__builtin_expect(__ret_warn_once != 0, 0L);
  return (dwell_time);
  }
}
}
static u16 iwl_get_passive_dwell_time(struct iwl_priv *priv , enum ieee80211_band band ) 
{ 
  u16 passive ;
  u16 tmp ;

  {
  passive = (unsigned int )band == 0U ? 120U : 110U;
  tmp = iwl_limit_dwell(priv, (int )passive);
  return (tmp);
}
}
static u8 iwl_get_single_channel_number(struct iwl_priv *priv , enum ieee80211_band band ) 
{ 
  struct ieee80211_supported_band *sband ;
  struct iwl_rxon_context *ctx ;
  int i ;
  bool busy ;

  {
  sband = ((priv->hw)->wiphy)->bands[(unsigned int )band];
  i = 0;
  goto ldv_53809;
  ldv_53808: 
  busy = 0;
  ctx = (struct iwl_rxon_context *)(& priv->contexts);
  goto ldv_53806;
  ldv_53805: ;
  if ((int )((unsigned long )priv->valid_contexts >> (int )ctx->ctxid) & 1) {
    busy = (int )(sband->channels + (unsigned long )i)->hw_value == (int )ctx->staging.channel;
    if ((int )busy) {
      goto ldv_53804;
    } else {

    }
  } else {

  }
  ctx = ctx + 1;
  ldv_53806: ;
  if ((unsigned long )((struct iwl_rxon_context *)(& priv->contexts) + 2UL) > (unsigned long )ctx) {
    goto ldv_53805;
  } else {

  }
  ldv_53804: ;
  if ((int )busy) {
    goto ldv_53807;
  } else {

  }
  if (((sband->channels + (unsigned long )i)->flags & 1U) == 0U) {
    return ((u8 )(sband->channels + (unsigned long )i)->hw_value);
  } else {

  }
  ldv_53807: 
  i = i + 1;
  ldv_53809: ;
  if (sband->n_channels > i) {
    goto ldv_53808;
  } else {

  }

  return (0U);
}
}
static int iwl_get_channel_for_reset_scan(struct iwl_priv *priv , struct ieee80211_vif *vif ,
                                          enum ieee80211_band band , struct iwl_scan_channel *scan_ch ) 
{ 
  struct ieee80211_supported_band  const  *sband ;
  u16 channel ;
  u8 tmp ;

  {
  sband = iwl_get_hw_mode(priv, band);
  if ((unsigned long )sband == (unsigned long )((struct ieee80211_supported_band  const  *)0)) {
    __iwl_err(priv->dev, 0, 0, "invalid band\n");
    return (0);
  } else {

  }
  tmp = iwl_get_single_channel_number(priv, band);
  channel = (u16 )tmp;
  if ((unsigned int )channel != 0U) {
    scan_ch->channel = channel;
    scan_ch->type = 0U;
    scan_ch->active_dwell = 5U;
    scan_ch->passive_dwell = 5U;
    scan_ch->dsp_atten = 110U;
    if ((unsigned int )band == 1U) {
      scan_ch->tx_gain = 59U;
    } else {
      scan_ch->tx_gain = 40U;
    }
    return (1);
  } else {

  }
  __iwl_err(priv->dev, 0, 0, "no valid channel found\n");
  return (0);
}
}
static int iwl_get_channels_for_scan(struct iwl_priv *priv , struct ieee80211_vif *vif ,
                                     enum ieee80211_band band , u8 is_active , u8 n_probes ,
                                     struct iwl_scan_channel *scan_ch ) 
{ 
  struct ieee80211_channel *chan ;
  struct ieee80211_supported_band  const  *sband ;
  u16 passive_dwell ;
  u16 active_dwell ;
  int added ;
    klee_make_symbolic(&added, sizeof(int), "added");
  int i ;
  u16 channel ;

  {
  passive_dwell = 0U;
  active_dwell = 0U;
  sband = iwl_get_hw_mode(priv, band);
  if ((unsigned long )sband == (unsigned long )((struct ieee80211_supported_band  const  *)0)) {
    return (0);
  } else {

  }
  active_dwell = iwl_get_active_dwell_time(priv, band, (int )n_probes);
  passive_dwell = iwl_get_passive_dwell_time(priv, band);
  if ((int )passive_dwell <= (int )active_dwell) {
    passive_dwell = (unsigned int )active_dwell + 1U;
  } else {

  }
  i = 0;
  added = 0;
  goto ldv_53837;
  ldv_53836: 
  chan = (priv->scan_request)->channels[i];
  if ((unsigned int )chan->band != (unsigned int )band) {
    goto ldv_53834;
  } else {

  }
  channel = chan->hw_value;
  scan_ch->channel = channel;
  if ((unsigned int )is_active == 0U || (chan->flags & 2U) != 0U) {
    scan_ch->type = 0U;
  } else {
    scan_ch->type = 1U;
  }
  if ((unsigned int )n_probes != 0U) {
    scan_ch->type = scan_ch->type | ((unsigned int )(1UL << (int )n_probes) | ((unsigned int )(1UL << (int )n_probes) - 2U));
  } else {

  }
  scan_ch->active_dwell = active_dwell;
  scan_ch->passive_dwell = passive_dwell;
  scan_ch->dsp_atten = 110U;
  if ((unsigned int )band == 1U) {
    scan_ch->tx_gain = 59U;
  } else {
    scan_ch->tx_gain = 40U;
  }
  __iwl_dbg(priv->dev, 2048U, 0, "iwl_get_channels_for_scan", "Scanning ch=%d prob=0x%X [%s %d]\n",
            (int )channel, scan_ch->type, (int )scan_ch->type & 1 ? (char *)"ACTIVE" : (char *)"PASSIVE",
            (int )scan_ch->type & 1 ? (int )active_dwell : (int )passive_dwell);
  scan_ch = scan_ch + 1;
  added = added + 1;
  ldv_53834: 
  i = i + 1;
  ldv_53837: ;
  if ((u32 )i < (priv->scan_request)->n_channels) {
    goto ldv_53836;
  } else {

  }
  __iwl_dbg(priv->dev, 2048U, 0, "iwl_get_channels_for_scan", "total channels to scan %d\n",
            added);
  return (added);
}
}
static u16 iwl_fill_probe_req(struct ieee80211_mgmt *frame , u8 const   *ta , u8 const   *ies ,
                              int ie_len , u8 const   *ssid , u8 ssid_len , int left ) 
{ 
  int len ;
  u8 *pos ;
  u8 *tmp ;
  u8 *tmp___0 ;
  int __ret_warn_on ;
  long tmp___1 ;
  long tmp___2 ;

  {
  len = 0;
  pos = (u8 *)0U;
  left = left + -24;
  if (left < 0) {
    return (0U);
  } else {

  }
  frame->frame_control = 64U;
  eth_broadcast_addr((u8 *)(& frame->da));
  memcpy((void *)(& frame->sa), (void const   *)ta, 6UL);
  eth_broadcast_addr((u8 *)(& frame->bssid));
  frame->seq_ctrl = 0U;
  len = len + 24;
  pos = (u8 *)(& frame->u.probe_req.variable);
  left = (-2 - (int )ssid_len) + left;
  if (left < 0) {
    return (0U);
  } else {

  }
  tmp = pos;
  pos = pos + 1;
  *tmp = 0U;
  tmp___0 = pos;
  pos = pos + 1;
  *tmp___0 = ssid_len;
  if ((unsigned long )ssid != (unsigned long )((u8 const   *)0U) && (unsigned int )ssid_len != 0U) {
    memcpy((void *)pos, (void const   *)ssid, (size_t )ssid_len);
    pos = pos + (unsigned long )ssid_len;
  } else {

  }
  len = ((int )ssid_len + 2) + len;
  __ret_warn_on = left < ie_len;
  tmp___1 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp___1 != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/08_1a/drivers/net/wireless/iwlwifi/dvm/scan.c",
                       626);
  } else {

  }
  tmp___2 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp___2 != 0L) {
    return ((u16 )len);
  } else {

  }
  if ((unsigned long )ies != (unsigned long )((u8 const   *)0U) && ie_len != 0) {
    memcpy((void *)pos, (void const   *)ies, (size_t )ie_len);
    len = len + ie_len;
  } else {

  }
  return ((u16 )len);
}
}
static int iwlagn_request_scan(struct iwl_priv *priv , struct ieee80211_vif *vif ) 
{ 
  struct iwl_host_cmd cmd ;
  unsigned int tmp ;
  struct iwl_scan_cmd *scan ;
  struct iwl_rxon_context *ctx ;
  u32 rate_flags ;
  u16 cmd_len ;
  u16 rx_chain ;
  enum ieee80211_band band ;
  u8 n_probes ;
  u8 rx_ant ;
  u8 rate ;
  bool is_active ;
  int chan_mod ;
    klee_make_symbolic(&chan_mod, sizeof(int), "chan_mod");
  u8 active_chains ;
  u8 scan_tx_antennas ;
  int ret ;
  int scan_cmd_size ;
    klee_make_symbolic(&scan_cmd_size, sizeof(int), "scan_cmd_size");
  u8 const   *ssid ;
  u8 ssid_len ;
  int __ret_warn_on ;
  long tmp___0 ;
  long tmp___1 ;
  int __ret_warn_on___0 ;
  int tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;
  u16 interval ;
  u32 extra ;
  u32 suspend_time ;
  u32 scan_suspend_time ;
  int tmp___5 ;
  int i ;
  int p ;
    klee_make_symbolic(&p, sizeof(int), "p");
  u32 tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
  cmd.data[0] = 0;
  cmd.data[1] = 0;
  cmd.resp_pkt = 0;
  cmd._rx_page_addr = 0UL;
  cmd._rx_page_order = 0U;
  cmd.handler_status = 0;
  cmd.flags = 0U;
  cmd.len[0] = 764U;
  tmp = 1U;
  while (1) {
    if (tmp >= 2U) {
      break;
    } else {

    }
    cmd.len[tmp] = (unsigned short)0;
    tmp = tmp + 1U;
  }
  cmd.dataflags[0] = (unsigned char)0;
  cmd.dataflags[1] = (unsigned char)0;
  cmd.id = 128U;
  ctx = (struct iwl_rxon_context *)(& priv->contexts);
  rate_flags = 0U;
  cmd_len = 0U;
  rx_chain = 0U;
  n_probes = 0U;
  rx_ant = (priv->nvm_data)->valid_rx_ant;
  is_active = 0;
  scan_tx_antennas = (priv->nvm_data)->valid_tx_ant;
  scan_cmd_size = (int )((unsigned int )(priv->fw)->ucode_capa.max_probe_length + 1364U);
  ssid = (u8 const   *)0U;
  ssid_len = 0U;
  __ret_warn_on = (unsigned int )priv->scan_type == 0U && ((unsigned long )priv->scan_request == (unsigned long )((struct cfg80211_scan_request *)0) || (priv->scan_request)->n_channels > 50U);
  tmp___0 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp___0 != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/08_1a/drivers/net/wireless/iwlwifi/dvm/scan.c",
                       665);
  } else {

  }
  tmp___1 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp___1 != 0L) {
    return (-22);
  } else {

  }
  if (debug_locks != 0) {
    tmp___2 = lock_is_held(& priv->mutex.dep_map);
    if (tmp___2 == 0) {
      tmp___3 = 1;
    } else {
      tmp___3 = 0;
    }
  } else {
    tmp___3 = 0;
  }
  __ret_warn_on___0 = tmp___3;
  tmp___4 = ldv__builtin_expect(__ret_warn_on___0 != 0, 0L);
  if (tmp___4 != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/08_1a/drivers/net/wireless/iwlwifi/dvm/scan.c",
                       668);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on___0 != 0, 0L);
  if ((unsigned long )vif != (unsigned long )((struct ieee80211_vif *)0)) {
    ctx = iwl_rxon_ctx_from_vif(vif);
  } else {

  }
  if ((unsigned long )priv->scan_cmd == (unsigned long )((void *)0)) {
    priv->scan_cmd = kmalloc((size_t )scan_cmd_size, 208U);
    if ((unsigned long )priv->scan_cmd == (unsigned long )((void *)0)) {
      __iwl_dbg(priv->dev, 2048U, 0, "iwlagn_request_scan", "fail to allocate memory for scan\n");
      return (-12);
    } else {

    }
  } else {

  }
  scan = (struct iwl_scan_cmd *)priv->scan_cmd;
  memset((void *)scan, 0, (size_t )scan_cmd_size);
  scan->quiet_plcp_th = 1U;
  scan->quiet_time = 10U;
  tmp___5 = iwl_is_any_associated___1(priv);
  if (tmp___5 != 0) {
    interval = 0U;
    suspend_time = 100U;
    scan_suspend_time = 100U;
    __iwl_dbg(priv->dev, 1U, 0, "iwlagn_request_scan", "Scanning while associated...\n");
    switch ((unsigned int )priv->scan_type) {
    case 1U: 
    interval = 0U;
    goto ldv_53884;
    case 0U: 
    interval = vif->bss_conf.beacon_int;
    goto ldv_53884;
    }
    ldv_53884: 
    scan->suspend_time = 0U;
    scan->max_out_time = 204800U;
    if ((unsigned int )interval == 0U) {
      interval = (u16 )suspend_time;
    } else {

    }
    extra = suspend_time / (u32 )interval << 22;
    scan_suspend_time = (suspend_time % (u32 )interval) * 1024U | extra;
    scan->suspend_time = scan_suspend_time;
    __iwl_dbg(priv->dev, 2048U, 0, "iwlagn_request_scan", "suspend_time 0x%X beacon interval %d\n",
              scan_suspend_time, (int )interval);
  } else {

  }
  switch ((unsigned int )priv->scan_type) {
  case 1U: 
  __iwl_dbg(priv->dev, 2048U, 0, "iwlagn_request_scan", "Start internal passive scan.\n");
  scan->quiet_time = 5U;
  goto ldv_53887;
  case 0U: ;
  if ((priv->scan_request)->n_ssids != 0) {
    p = 0;
    __iwl_dbg(priv->dev, 2048U, 0, "iwlagn_request_scan", "Kicking off active scan\n");
    ssid_len = ((priv->scan_request)->ssids)->ssid_len;
    ssid = (u8 const   *)(& ((priv->scan_request)->ssids)->ssid);
    i = (priv->scan_request)->n_ssids + -1;
    goto ldv_53892;
    ldv_53891: 
    scan->direct_scan[p].id = 0U;
    scan->direct_scan[p].len = ((priv->scan_request)->ssids + (unsigned long )i)->ssid_len;
    memcpy((void *)(& scan->direct_scan[p].ssid), (void const   *)(& ((priv->scan_request)->ssids + (unsigned long )i)->ssid),
             (size_t )((priv->scan_request)->ssids + (unsigned long )i)->ssid_len);
    n_probes = (u8 )((int )n_probes + 1);
    p = p + 1;
    i = i - 1;
    ldv_53892: ;
    if (i > 0) {
      goto ldv_53891;
    } else {

    }
    is_active = 1;
  } else {
    __iwl_dbg(priv->dev, 2048U, 0, "iwlagn_request_scan", "Start passive scan.\n");
  }
  goto ldv_53887;
  }
  ldv_53887: 
  scan->tx_cmd.tx_flags = 8192U;
  scan->tx_cmd.sta_id = ctx->bcast_sta_id;
  scan->tx_cmd.stop_time.life_time = 4294967295U;
  switch ((unsigned int )priv->scan_band) {
  case 0U: 
  scan->flags = 5U;
  chan_mod = (int )(((unsigned int )priv->contexts[0].active.flags & 100663296U) >> 25);
  if (((unsigned long )priv->scan_request != (unsigned long )((struct cfg80211_scan_request *)0) && (int )(priv->scan_request)->no_cck) || chan_mod == 1) {
    rate = 13U;
  } else {
    rate = 10U;
    rate_flags = 512U;
  }
  if ((unsigned long )(priv->lib)->bt_params != (unsigned long )((struct iwl_dvm_bt_params  const  */* const  */)0) && (int )((priv->lib)->bt_params)->advanced_bt_coexist) {
    scan->tx_cmd.tx_flags = scan->tx_cmd.tx_flags | 4096U;
  } else {

  }
  goto ldv_53895;
  case 1U: 
  rate = 13U;
  goto ldv_53895;
  default: 
  __iwl_warn(priv->dev, "Invalid scan band\n");
  return (-5);
  }
  ldv_53895: ;
  if ((int )priv->new_scan_threshold_behaviour) {
    scan->good_CRC_th = (__le16 )is_active;
  } else {
    scan->good_CRC_th = (int )is_active ? 1U : 65535U;
  }
  band = priv->scan_band;
  if (((unsigned int )band == 0U && (unsigned long )(priv->lib)->bt_params != (unsigned long )((struct iwl_dvm_bt_params  const  */* const  */)0)) && (int )((priv->lib)->bt_params)->advanced_bt_coexist) {
    scan_tx_antennas = first_antenna((int )scan_tx_antennas);
  } else {

  }
  priv->scan_tx_ant[(unsigned int )band] = iwl_toggle_tx_ant(priv, (int )priv->scan_tx_ant[(unsigned int )band],
                                                             (int )scan_tx_antennas);
  tmp___6 = iwl_ant_idx_to_flags((int )priv->scan_tx_ant[(unsigned int )band]);
  rate_flags = tmp___6 | rate_flags;
  scan->tx_cmd.rate_n_flags = iwl_hw_set_rate_n_flags((int )rate, rate_flags);
  tmp___7 = constant_test_bit(13L, (unsigned long const volatile   *)(& priv->status));
  if (tmp___7 != 0 && ((priv->hw)->conf.flags & 4U) == 0U) {
    active_chains = (u8 )((int )((unsigned char )priv->chain_noise_data.active_chains) & (int )rx_ant);
    if ((unsigned int )active_chains == 0U) {
      active_chains = rx_ant;
    } else {

    }
    __iwl_dbg(priv->dev, 2048U, 0, "iwlagn_request_scan", "chain_noise_data.active_chains: %u\n",
              priv->chain_noise_data.active_chains);
    rx_ant = first_antenna((int )active_chains);
  } else {

  }
  if (((unsigned long )(priv->lib)->bt_params != (unsigned long )((struct iwl_dvm_bt_params  const  */* const  */)0) && (int )((priv->lib)->bt_params)->advanced_bt_coexist) && (int )priv->bt_full_concurrent) {
    rx_ant = first_antenna((int )rx_ant);
  } else {

  }
  rx_chain = (u16 )((int )((short )((int )(priv->nvm_data)->valid_rx_ant << 1)) | (int )((short )rx_chain));
  rx_chain = (u16 )((int )((short )((int )rx_ant << 7)) | (int )((short )rx_chain));
  rx_chain = (u16 )((int )((short )((int )rx_ant << 4)) | (int )((short )rx_chain));
  rx_chain = (u16 )((unsigned int )rx_chain | 1U);
  scan->rx_chain = rx_chain;
  switch ((unsigned int )priv->scan_type) {
  case 0U: 
  cmd_len = iwl_fill_probe_req((struct ieee80211_mgmt *)(& scan->data), (u8 const   *)(& vif->addr),
                               (priv->scan_request)->ie, (int )(priv->scan_request)->ie_len,
                               ssid, (int )ssid_len, (int )((unsigned int )scan_cmd_size - 764U));
  goto ldv_53899;
  case 1U: 
  cmd_len = iwl_fill_probe_req((struct ieee80211_mgmt *)(& scan->data), (u8 const   *)(& iwl_bcast_addr),
                               (u8 const   *)0U, 0, (u8 const   *)0U, 0, (int )((unsigned int )scan_cmd_size - 764U));
  goto ldv_53899;
  default: 
  __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/08_1a/drivers/net/wireless/iwlwifi/dvm/scan.c"),
                       "i" (884), "i" (12UL));
  ldv_53902: ;
  goto ldv_53902;
  }
  ldv_53899: 
  scan->tx_cmd.len = cmd_len;
  scan->filter_flags = scan->filter_flags | 68U;
  switch ((unsigned int )priv->scan_type) {
  case 1U: 
  tmp___8 = iwl_get_channel_for_reset_scan(priv, vif, band, (struct iwl_scan_channel *)(& scan->data) + (unsigned long )cmd_len);
  scan->channel_count = (u8 )tmp___8;
  goto ldv_53904;
  case 0U: 
  tmp___9 = iwl_get_channels_for_scan(priv, vif, band, (int )is_active, (int )n_probes,
                                      (struct iwl_scan_channel *)(& scan->data) + (unsigned long )cmd_len);
  scan->channel_count = (u8 )tmp___9;
  goto ldv_53904;
  }
  ldv_53904: ;
  if ((unsigned int )scan->channel_count == 0U) {
    __iwl_dbg(priv->dev, 2048U, 0, "iwlagn_request_scan", "channel count %d\n", (int )scan->channel_count);
    return (-5);
  } else {

  }
  cmd.len[0] = (unsigned int )cmd.len[0] + ((unsigned int )scan->tx_cmd.len + (unsigned int )((u16 )scan->channel_count) * 12U);
  cmd.data[0] = (void const   *)scan;
  cmd.dataflags[0] = 1U;
  scan->len = cmd.len[0];
  set_bit(9L, (unsigned long volatile   *)(& priv->status));
  ret = iwlagn_set_pan_params(priv);
  if (ret != 0) {
    clear_bit(9L, (unsigned long volatile   *)(& priv->status));
    return (ret);
  } else {

  }
  ret = iwl_dvm_send_cmd(priv, & cmd);
  if (ret != 0) {
    clear_bit(9L, (unsigned long volatile   *)(& priv->status));
    iwlagn_set_pan_params(priv);
  } else {

  }
  return (ret);
}
}
void iwl_init_scan_params(struct iwl_priv *priv ) 
{ 
  u8 ant_idx ;
  int tmp ;

  {
  tmp = fls((int )(priv->nvm_data)->valid_tx_ant);
  ant_idx = (unsigned int )((u8 )tmp) + 255U;
  if ((unsigned int )priv->scan_tx_ant[1] == 0U) {
    priv->scan_tx_ant[1] = ant_idx;
  } else {

  }
  if ((unsigned int )priv->scan_tx_ant[0] == 0U) {
    priv->scan_tx_ant[0] = ant_idx;
  } else {

  }
  return;
}
}
int iwl_scan_initiate(struct iwl_priv *priv , struct ieee80211_vif *vif , enum iwl_scan_type scan_type ,
                      enum ieee80211_band band ) 
{ 
  int ret ;
  int __ret_warn_on ;
  int tmp ;
  int tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  if (debug_locks != 0) {
    tmp = lock_is_held(& priv->mutex.dep_map);
    if (tmp == 0) {
      tmp___0 = 1;
    } else {
      tmp___0 = 0;
    }
  } else {
    tmp___0 = 0;
  }
  __ret_warn_on = tmp___0;
  tmp___1 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp___1 != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/08_1a/drivers/net/wireless/iwlwifi/dvm/scan.c",
                       950);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  ldv_cancel_delayed_work_221(& priv->scan_check);
  tmp___2 = iwl_is_ready_rf(priv);
  if (tmp___2 == 0) {
    __iwl_warn(priv->dev, "Request scan called when driver not ready.\n");
    return (-5);
  } else {

  }
  tmp___3 = constant_test_bit(9L, (unsigned long const volatile   *)(& priv->status));
  if (tmp___3 != 0) {
    __iwl_dbg(priv->dev, 2048U, 0, "iwl_scan_initiate", "Multiple concurrent scan requests in parallel.\n");
    return (-16);
  } else {

  }
  tmp___4 = constant_test_bit(8L, (unsigned long const volatile   *)(& priv->status));
  if (tmp___4 != 0) {
    __iwl_dbg(priv->dev, 2048U, 0, "iwl_scan_initiate", "Scan request while abort pending.\n");
    return (-16);
  } else {

  }
  __iwl_dbg(priv->dev, 2048U, 0, "iwl_scan_initiate", "Starting %sscan...\n", (unsigned int )scan_type == 0U ? (char *)"" : (char *)"internal short ");
  set_bit(7L, (unsigned long volatile   *)(& priv->status));
  priv->scan_type = scan_type;
  priv->scan_start = jiffies;
  priv->scan_band = band;
  ret = iwlagn_request_scan(priv, vif);
  if (ret != 0) {
    clear_bit(7L, (unsigned long volatile   *)(& priv->status));
    priv->scan_type = 0;
    return (ret);
  } else {

  }
  queue_delayed_work(priv->workqueue, & priv->scan_check, 3750UL);
  return (0);
}
}
void iwl_internal_short_hw_scan(struct iwl_priv *priv ) 
{ 


  {
  queue_work___6(priv->workqueue, & priv->start_internal_scan);
  return;
}
}
static void iwl_bg_start_internal_scan(struct work_struct *work ) 
{ 
  struct iwl_priv *priv ;
  struct work_struct  const  *__mptr ;
  int tmp ;
  int tmp___0 ;

  {
  __mptr = (struct work_struct  const  *)work;
  priv = (struct iwl_priv *)__mptr + 0xffffffffffffcee8UL;
  __iwl_dbg(priv->dev, 2048U, 0, "iwl_bg_start_internal_scan", "Start internal scan\n");
  mutex_lock_nested(& priv->mutex, 0U);
  if ((unsigned int )priv->scan_type == 1U) {
    __iwl_dbg(priv->dev, 2048U, 0, "iwl_bg_start_internal_scan", "Internal scan already in progress\n");
    goto unlock;
  } else {

  }
  tmp = constant_test_bit(7L, (unsigned long const volatile   *)(& priv->status));
  if (tmp != 0) {
    __iwl_dbg(priv->dev, 2048U, 0, "iwl_bg_start_internal_scan", "Scan already in progress.\n");
    goto unlock;
  } else {

  }
  tmp___0 = iwl_scan_initiate(priv, (struct ieee80211_vif *)0, 1, priv->band);
  if (tmp___0 != 0) {
    __iwl_dbg(priv->dev, 2048U, 0, "iwl_bg_start_internal_scan", "failed to start internal short scan\n");
  } else {

  }
  unlock: 
  mutex_unlock(& priv->mutex);
  return;
}
}
static void iwl_bg_scan_check(struct work_struct *data ) 
{ 
  struct iwl_priv *priv ;
  struct work_struct  const  *__mptr ;

  {
  __mptr = (struct work_struct  const  *)data;
  priv = (struct iwl_priv *)__mptr + 0xffffffffffffcda8UL;
  __iwl_dbg(priv->dev, 2048U, 0, "iwl_bg_scan_check", "Scan check work\n");
  mutex_lock_nested(& priv->mutex, 0U);
  iwl_force_scan_end(priv);
  mutex_unlock(& priv->mutex);
  return;
}
}
static void iwl_bg_abort_scan(struct work_struct *work ) 
{ 
  struct iwl_priv *priv ;
  struct work_struct  const  *__mptr ;

  {
  __mptr = (struct work_struct  const  *)work;
  priv = (struct iwl_priv *)__mptr + 0xffffffffffffd090UL;
  __iwl_dbg(priv->dev, 2048U, 0, "iwl_bg_abort_scan", "Abort scan work\n");
  mutex_lock_nested(& priv->mutex, 0U);
  iwl_scan_cancel_timeout(priv, 200UL);
  mutex_unlock(& priv->mutex);
  return;
}
}
static void iwl_bg_scan_completed(struct work_struct *work ) 
{ 
  struct iwl_priv *priv ;
  struct work_struct  const  *__mptr ;

  {
  __mptr = (struct work_struct  const  *)work;
  priv = (struct iwl_priv *)__mptr + 0xffffffffffffd0e0UL;
  mutex_lock_nested(& priv->mutex, 0U);
  iwl_process_scan_complete(priv);
  mutex_unlock(& priv->mutex);
  return;
}
}
void iwl_setup_scan_deferred_work(struct iwl_priv *priv ) 
{ 
  struct lock_class_key __key ;
  atomic_long_t __constr_expr_0 ;
  struct lock_class_key __key___0 ;
  atomic_long_t __constr_expr_1 ;
  struct lock_class_key __key___1 ;
  atomic_long_t __constr_expr_2 ;
  struct lock_class_key __key___2 ;
  atomic_long_t __constr_expr_3 ;
  struct lock_class_key __key___3 ;

  {
  __init_work(& priv->scan_completed, 0);
  __constr_expr_0.counter = 137438953408L;
  priv->scan_completed.data = __constr_expr_0;
  lockdep_init_map(& priv->scan_completed.lockdep_map, "(&priv->scan_completed)",
                   & __key, 0);
  INIT_LIST_HEAD(& priv->scan_completed.entry);
  priv->scan_completed.func = & iwl_bg_scan_completed;
  __init_work(& priv->abort_scan, 0);
  __constr_expr_1.counter = 137438953408L;
  priv->abort_scan.data = __constr_expr_1;
  lockdep_init_map(& priv->abort_scan.lockdep_map, "(&priv->abort_scan)", & __key___0,
                   0);
  INIT_LIST_HEAD(& priv->abort_scan.entry);
  priv->abort_scan.func = & iwl_bg_abort_scan;
  __init_work(& priv->start_internal_scan, 0);
  __constr_expr_2.counter = 137438953408L;
  priv->start_internal_scan.data = __constr_expr_2;
  lockdep_init_map(& priv->start_internal_scan.lockdep_map, "(&priv->start_internal_scan)",
                   & __key___1, 0);
  INIT_LIST_HEAD(& priv->start_internal_scan.entry);
  priv->start_internal_scan.func = & iwl_bg_start_internal_scan;
  __init_work(& priv->scan_check.work, 0);
  __constr_expr_3.counter = 137438953408L;
  priv->scan_check.work.data = __constr_expr_3;
  lockdep_init_map(& priv->scan_check.work.lockdep_map, "(&(&priv->scan_check)->work)",
                   & __key___2, 0);
  INIT_LIST_HEAD(& priv->scan_check.work.entry);
  priv->scan_check.work.func = & iwl_bg_scan_check;
  init_timer_key(& priv->scan_check.timer, 2097152U, "(&(&priv->scan_check)->timer)",
                 & __key___3);
  priv->scan_check.timer.function = & delayed_work_timer_fn;
  priv->scan_check.timer.data = (unsigned long )(& priv->scan_check);
  return;
}
}
void iwl_cancel_scan_deferred_work(struct iwl_priv *priv ) 
{ 
  bool tmp ;

  {
  ldv_cancel_work_sync_222(& priv->start_internal_scan);
  ldv_cancel_work_sync_223(& priv->abort_scan);
  ldv_cancel_work_sync_224(& priv->scan_completed);
  tmp = ldv_cancel_delayed_work_sync_225(& priv->scan_check);
  if ((int )tmp) {
    mutex_lock_nested(& priv->mutex, 0U);
    iwl_force_scan_end(priv);
    mutex_unlock(& priv->mutex);
  } else {

  }
  return;
}
}
void call_and_disable_all_14(int state ) 
{ 


  {
  if (ldv_work_14_0 == state) {
    call_and_disable_work_14(ldv_work_struct_14_0);
  } else {

  }
  if (ldv_work_14_1 == state) {
    call_and_disable_work_14(ldv_work_struct_14_1);
  } else {

  }
  if (ldv_work_14_2 == state) {
    call_and_disable_work_14(ldv_work_struct_14_2);
  } else {

  }
  if (ldv_work_14_3 == state) {
    call_and_disable_work_14(ldv_work_struct_14_3);
  } else {

  }
  return;
}
}
void call_and_disable_work_13(struct work_struct *work ) 
{ 


  {
  if ((ldv_work_13_0 == 2 || ldv_work_13_0 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_13_0) {
    iwl_bg_start_internal_scan(work);
    ldv_work_13_0 = 1;
    return;
  } else {

  }
  if ((ldv_work_13_1 == 2 || ldv_work_13_1 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_13_1) {
    iwl_bg_start_internal_scan(work);
    ldv_work_13_1 = 1;
    return;
  } else {

  }
  if ((ldv_work_13_2 == 2 || ldv_work_13_2 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_13_2) {
    iwl_bg_start_internal_scan(work);
    ldv_work_13_2 = 1;
    return;
  } else {

  }
  if ((ldv_work_13_3 == 2 || ldv_work_13_3 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_13_3) {
    iwl_bg_start_internal_scan(work);
    ldv_work_13_3 = 1;
    return;
  } else {

  }
  return;
}
}
void activate_work_13(struct work_struct *work , int state ) 
{ 


  {
  if (ldv_work_13_0 == 0) {
    ldv_work_struct_13_0 = work;
    ldv_work_13_0 = state;
    return;
  } else {

  }
  if (ldv_work_13_1 == 0) {
    ldv_work_struct_13_1 = work;
    ldv_work_13_1 = state;
    return;
  } else {

  }
  if (ldv_work_13_2 == 0) {
    ldv_work_struct_13_2 = work;
    ldv_work_13_2 = state;
    return;
  } else {

  }
  if (ldv_work_13_3 == 0) {
    ldv_work_struct_13_3 = work;
    ldv_work_13_3 = state;
    return;
  } else {

  }
  return;
}
}
void disable_work_14(struct work_struct *work ) 
{ 


  {
  if ((ldv_work_14_0 == 3 || ldv_work_14_0 == 2) && (unsigned long )ldv_work_struct_14_0 == (unsigned long )work) {
    ldv_work_14_0 = 1;
  } else {

  }
  if ((ldv_work_14_1 == 3 || ldv_work_14_1 == 2) && (unsigned long )ldv_work_struct_14_1 == (unsigned long )work) {
    ldv_work_14_1 = 1;
  } else {

  }
  if ((ldv_work_14_2 == 3 || ldv_work_14_2 == 2) && (unsigned long )ldv_work_struct_14_2 == (unsigned long )work) {
    ldv_work_14_2 = 1;
  } else {

  }
  if ((ldv_work_14_3 == 3 || ldv_work_14_3 == 2) && (unsigned long )ldv_work_struct_14_3 == (unsigned long )work) {
    ldv_work_14_3 = 1;
  } else {

  }
  return;
}
}
void call_and_disable_all_11(int state ) 
{ 


  {
  if (ldv_work_11_0 == state) {
    call_and_disable_work_11(ldv_work_struct_11_0);
  } else {

  }
  if (ldv_work_11_1 == state) {
    call_and_disable_work_11(ldv_work_struct_11_1);
  } else {

  }
  if (ldv_work_11_2 == state) {
    call_and_disable_work_11(ldv_work_struct_11_2);
  } else {

  }
  if (ldv_work_11_3 == state) {
    call_and_disable_work_11(ldv_work_struct_11_3);
  } else {

  }
  return;
}
}
void work_init_14(void) 
{ 


  {
  ldv_work_14_0 = 0;
  ldv_work_14_1 = 0;
  ldv_work_14_2 = 0;
  ldv_work_14_3 = 0;
  return;
}
}
void call_and_disable_all_12(int state ) 
{ 


  {
  if (ldv_work_12_0 == state) {
    call_and_disable_work_12(ldv_work_struct_12_0);
  } else {

  }
  if (ldv_work_12_1 == state) {
    call_and_disable_work_12(ldv_work_struct_12_1);
  } else {

  }
  if (ldv_work_12_2 == state) {
    call_and_disable_work_12(ldv_work_struct_12_2);
  } else {

  }
  if (ldv_work_12_3 == state) {
    call_and_disable_work_12(ldv_work_struct_12_3);
  } else {

  }
  return;
}
}
void invoke_work_14(void) 
{ 
  int tmp ;

  {
  tmp = __VERIFIER_nondet_int();
  switch (tmp) {
  case 0: ;
  if (ldv_work_14_0 == 2 || ldv_work_14_0 == 3) {
    ldv_work_14_0 = 4;
    iwl_bg_scan_check(ldv_work_struct_14_0);
    ldv_work_14_0 = 1;
  } else {

  }
  goto ldv_53996;
  case 1: ;
  if (ldv_work_14_1 == 2 || ldv_work_14_1 == 3) {
    ldv_work_14_1 = 4;
    iwl_bg_scan_check(ldv_work_struct_14_0);
    ldv_work_14_1 = 1;
  } else {

  }
  goto ldv_53996;
  case 2: ;
  if (ldv_work_14_2 == 2 || ldv_work_14_2 == 3) {
    ldv_work_14_2 = 4;
    iwl_bg_scan_check(ldv_work_struct_14_0);
    ldv_work_14_2 = 1;
  } else {

  }
  goto ldv_53996;
  case 3: ;
  if (ldv_work_14_3 == 2 || ldv_work_14_3 == 3) {
    ldv_work_14_3 = 4;
    iwl_bg_scan_check(ldv_work_struct_14_0);
    ldv_work_14_3 = 1;
  } else {

  }
  goto ldv_53996;
  default: 
  ldv_stop();
  }
  ldv_53996: ;
  return;
}
}
void invoke_work_11(void) 
{ 
  int tmp ;

  {
  tmp = __VERIFIER_nondet_int();
  switch (tmp) {
  case 0: ;
  if (ldv_work_11_0 == 2 || ldv_work_11_0 == 3) {
    ldv_work_11_0 = 4;
    iwl_bg_scan_completed(ldv_work_struct_11_0);
    ldv_work_11_0 = 1;
  } else {

  }
  goto ldv_54007;
  case 1: ;
  if (ldv_work_11_1 == 2 || ldv_work_11_1 == 3) {
    ldv_work_11_1 = 4;
    iwl_bg_scan_completed(ldv_work_struct_11_0);
    ldv_work_11_1 = 1;
  } else {

  }
  goto ldv_54007;
  case 2: ;
  if (ldv_work_11_2 == 2 || ldv_work_11_2 == 3) {
    ldv_work_11_2 = 4;
    iwl_bg_scan_completed(ldv_work_struct_11_0);
    ldv_work_11_2 = 1;
  } else {

  }
  goto ldv_54007;
  case 3: ;
  if (ldv_work_11_3 == 2 || ldv_work_11_3 == 3) {
    ldv_work_11_3 = 4;
    iwl_bg_scan_completed(ldv_work_struct_11_0);
    ldv_work_11_3 = 1;
  } else {

  }
  goto ldv_54007;
  default: 
  ldv_stop();
  }
  ldv_54007: ;
  return;
}
}
void work_init_13(void) 
{ 


  {
  ldv_work_13_0 = 0;
  ldv_work_13_1 = 0;
  ldv_work_13_2 = 0;
  ldv_work_13_3 = 0;
  return;
}
}
void call_and_disable_work_14(struct work_struct *work ) 
{ 


  {
  if ((ldv_work_14_0 == 2 || ldv_work_14_0 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_14_0) {
    iwl_bg_scan_check(work);
    ldv_work_14_0 = 1;
    return;
  } else {

  }
  if ((ldv_work_14_1 == 2 || ldv_work_14_1 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_14_1) {
    iwl_bg_scan_check(work);
    ldv_work_14_1 = 1;
    return;
  } else {

  }
  if ((ldv_work_14_2 == 2 || ldv_work_14_2 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_14_2) {
    iwl_bg_scan_check(work);
    ldv_work_14_2 = 1;
    return;
  } else {

  }
  if ((ldv_work_14_3 == 2 || ldv_work_14_3 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_14_3) {
    iwl_bg_scan_check(work);
    ldv_work_14_3 = 1;
    return;
  } else {

  }
  return;
}
}
void disable_work_13(struct work_struct *work ) 
{ 


  {
  if ((ldv_work_13_0 == 3 || ldv_work_13_0 == 2) && (unsigned long )ldv_work_struct_13_0 == (unsigned long )work) {
    ldv_work_13_0 = 1;
  } else {

  }
  if ((ldv_work_13_1 == 3 || ldv_work_13_1 == 2) && (unsigned long )ldv_work_struct_13_1 == (unsigned long )work) {
    ldv_work_13_1 = 1;
  } else {

  }
  if ((ldv_work_13_2 == 3 || ldv_work_13_2 == 2) && (unsigned long )ldv_work_struct_13_2 == (unsigned long )work) {
    ldv_work_13_2 = 1;
  } else {

  }
  if ((ldv_work_13_3 == 3 || ldv_work_13_3 == 2) && (unsigned long )ldv_work_struct_13_3 == (unsigned long )work) {
    ldv_work_13_3 = 1;
  } else {

  }
  return;
}
}
void invoke_work_12(void) 
{ 
  int tmp ;

  {
  tmp = __VERIFIER_nondet_int();
  switch (tmp) {
  case 0: ;
  if (ldv_work_12_0 == 2 || ldv_work_12_0 == 3) {
    ldv_work_12_0 = 4;
    iwl_bg_abort_scan(ldv_work_struct_12_0);
    ldv_work_12_0 = 1;
  } else {

  }
  goto ldv_54029;
  case 1: ;
  if (ldv_work_12_1 == 2 || ldv_work_12_1 == 3) {
    ldv_work_12_1 = 4;
    iwl_bg_abort_scan(ldv_work_struct_12_0);
    ldv_work_12_1 = 1;
  } else {

  }
  goto ldv_54029;
  case 2: ;
  if (ldv_work_12_2 == 2 || ldv_work_12_2 == 3) {
    ldv_work_12_2 = 4;
    iwl_bg_abort_scan(ldv_work_struct_12_0);
    ldv_work_12_2 = 1;
  } else {

  }
  goto ldv_54029;
  case 3: ;
  if (ldv_work_12_3 == 2 || ldv_work_12_3 == 3) {
    ldv_work_12_3 = 4;
    iwl_bg_abort_scan(ldv_work_struct_12_0);
    ldv_work_12_3 = 1;
  } else {

  }
  goto ldv_54029;
  default: 
  ldv_stop();
  }
  ldv_54029: ;
  return;
}
}
void call_and_disable_work_12(struct work_struct *work ) 
{ 


  {
  if ((ldv_work_12_0 == 2 || ldv_work_12_0 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_12_0) {
    iwl_bg_abort_scan(work);
    ldv_work_12_0 = 1;
    return;
  } else {

  }
  if ((ldv_work_12_1 == 2 || ldv_work_12_1 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_12_1) {
    iwl_bg_abort_scan(work);
    ldv_work_12_1 = 1;
    return;
  } else {

  }
  if ((ldv_work_12_2 == 2 || ldv_work_12_2 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_12_2) {
    iwl_bg_abort_scan(work);
    ldv_work_12_2 = 1;
    return;
  } else {

  }
  if ((ldv_work_12_3 == 2 || ldv_work_12_3 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_12_3) {
    iwl_bg_abort_scan(work);
    ldv_work_12_3 = 1;
    return;
  } else {

  }
  return;
}
}
void work_init_11(void) 
{ 


  {
  ldv_work_11_0 = 0;
  ldv_work_11_1 = 0;
  ldv_work_11_2 = 0;
  ldv_work_11_3 = 0;
  return;
}
}
void activate_work_11(struct work_struct *work , int state ) 
{ 


  {
  if (ldv_work_11_0 == 0) {
    ldv_work_struct_11_0 = work;
    ldv_work_11_0 = state;
    return;
  } else {

  }
  if (ldv_work_11_1 == 0) {
    ldv_work_struct_11_1 = work;
    ldv_work_11_1 = state;
    return;
  } else {

  }
  if (ldv_work_11_2 == 0) {
    ldv_work_struct_11_2 = work;
    ldv_work_11_2 = state;
    return;
  } else {

  }
  if (ldv_work_11_3 == 0) {
    ldv_work_struct_11_3 = work;
    ldv_work_11_3 = state;
    return;
  } else {

  }
  return;
}
}
void disable_work_11(struct work_struct *work ) 
{ 


  {
  if ((ldv_work_11_0 == 3 || ldv_work_11_0 == 2) && (unsigned long )ldv_work_struct_11_0 == (unsigned long )work) {
    ldv_work_11_0 = 1;
  } else {

  }
  if ((ldv_work_11_1 == 3 || ldv_work_11_1 == 2) && (unsigned long )ldv_work_struct_11_1 == (unsigned long )work) {
    ldv_work_11_1 = 1;
  } else {

  }
  if ((ldv_work_11_2 == 3 || ldv_work_11_2 == 2) && (unsigned long )ldv_work_struct_11_2 == (unsigned long )work) {
    ldv_work_11_2 = 1;
  } else {

  }
  if ((ldv_work_11_3 == 3 || ldv_work_11_3 == 2) && (unsigned long )ldv_work_struct_11_3 == (unsigned long )work) {
    ldv_work_11_3 = 1;
  } else {

  }
  return;
}
}
void disable_work_12(struct work_struct *work ) 
{ 


  {
  if ((ldv_work_12_0 == 3 || ldv_work_12_0 == 2) && (unsigned long )ldv_work_struct_12_0 == (unsigned long )work) {
    ldv_work_12_0 = 1;
  } else {

  }
  if ((ldv_work_12_1 == 3 || ldv_work_12_1 == 2) && (unsigned long )ldv_work_struct_12_1 == (unsigned long )work) {
    ldv_work_12_1 = 1;
  } else {

  }
  if ((ldv_work_12_2 == 3 || ldv_work_12_2 == 2) && (unsigned long )ldv_work_struct_12_2 == (unsigned long )work) {
    ldv_work_12_2 = 1;
  } else {

  }
  if ((ldv_work_12_3 == 3 || ldv_work_12_3 == 2) && (unsigned long )ldv_work_struct_12_3 == (unsigned long )work) {
    ldv_work_12_3 = 1;
  } else {

  }
  return;
}
}
void activate_work_12(struct work_struct *work , int state ) 
{ 


  {
  if (ldv_work_12_0 == 0) {
    ldv_work_struct_12_0 = work;
    ldv_work_12_0 = state;
    return;
  } else {

  }
  if (ldv_work_12_1 == 0) {
    ldv_work_struct_12_1 = work;
    ldv_work_12_1 = state;
    return;
  } else {

  }
  if (ldv_work_12_2 == 0) {
    ldv_work_struct_12_2 = work;
    ldv_work_12_2 = state;
    return;
  } else {

  }
  if (ldv_work_12_3 == 0) {
    ldv_work_struct_12_3 = work;
    ldv_work_12_3 = state;
    return;
  } else {

  }
  return;
}
}
void invoke_work_13(void) 
{ 
  int tmp ;

  {
  tmp = __VERIFIER_nondet_int();
  switch (tmp) {
  case 0: ;
  if (ldv_work_13_0 == 2 || ldv_work_13_0 == 3) {
    ldv_work_13_0 = 4;
    iwl_bg_start_internal_scan(ldv_work_struct_13_0);
    ldv_work_13_0 = 1;
  } else {

  }
  goto ldv_54062;
  case 1: ;
  if (ldv_work_13_1 == 2 || ldv_work_13_1 == 3) {
    ldv_work_13_1 = 4;
    iwl_bg_start_internal_scan(ldv_work_struct_13_0);
    ldv_work_13_1 = 1;
  } else {

  }
  goto ldv_54062;
  case 2: ;
  if (ldv_work_13_2 == 2 || ldv_work_13_2 == 3) {
    ldv_work_13_2 = 4;
    iwl_bg_start_internal_scan(ldv_work_struct_13_0);
    ldv_work_13_2 = 1;
  } else {

  }
  goto ldv_54062;
  case 3: ;
  if (ldv_work_13_3 == 2 || ldv_work_13_3 == 3) {
    ldv_work_13_3 = 4;
    iwl_bg_start_internal_scan(ldv_work_struct_13_0);
    ldv_work_13_3 = 1;
  } else {

  }
  goto ldv_54062;
  default: 
  ldv_stop();
  }
  ldv_54062: ;
  return;
}
}
void work_init_12(void) 
{ 


  {
  ldv_work_12_0 = 0;
  ldv_work_12_1 = 0;
  ldv_work_12_2 = 0;
  ldv_work_12_3 = 0;
  return;
}
}
void call_and_disable_work_11(struct work_struct *work ) 
{ 


  {
  if ((ldv_work_11_0 == 2 || ldv_work_11_0 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_11_0) {
    iwl_bg_scan_completed(work);
    ldv_work_11_0 = 1;
    return;
  } else {

  }
  if ((ldv_work_11_1 == 2 || ldv_work_11_1 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_11_1) {
    iwl_bg_scan_completed(work);
    ldv_work_11_1 = 1;
    return;
  } else {

  }
  if ((ldv_work_11_2 == 2 || ldv_work_11_2 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_11_2) {
    iwl_bg_scan_completed(work);
    ldv_work_11_2 = 1;
    return;
  } else {

  }
  if ((ldv_work_11_3 == 2 || ldv_work_11_3 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_11_3) {
    iwl_bg_scan_completed(work);
    ldv_work_11_3 = 1;
    return;
  } else {

  }
  return;
}
}
void activate_work_14(struct work_struct *work , int state ) 
{ 


  {
  if (ldv_work_14_0 == 0) {
    ldv_work_struct_14_0 = work;
    ldv_work_14_0 = state;
    return;
  } else {

  }
  if (ldv_work_14_1 == 0) {
    ldv_work_struct_14_1 = work;
    ldv_work_14_1 = state;
    return;
  } else {

  }
  if (ldv_work_14_2 == 0) {
    ldv_work_struct_14_2 = work;
    ldv_work_14_2 = state;
    return;
  } else {

  }
  if (ldv_work_14_3 == 0) {
    ldv_work_struct_14_3 = work;
    ldv_work_14_3 = state;
    return;
  } else {

  }
  return;
}
}
void call_and_disable_all_13(int state ) 
{ 


  {
  if (ldv_work_13_0 == state) {
    call_and_disable_work_13(ldv_work_struct_13_0);
  } else {

  }
  if (ldv_work_13_1 == state) {
    call_and_disable_work_13(ldv_work_struct_13_1);
  } else {

  }
  if (ldv_work_13_2 == state) {
    call_and_disable_work_13(ldv_work_struct_13_2);
  } else {

  }
  if (ldv_work_13_3 == state) {
    call_and_disable_work_13(ldv_work_struct_13_3);
  } else {

  }
  return;
}
}
bool ldv_queue_work_on_215(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_7(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_delayed_work_on_216(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_7(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_work_on_217(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_7(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
void ldv_flush_workqueue_218(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
  flush_workqueue(ldv_func_arg1);
  call_and_disable_all_7(2);
  return;
}
}
bool ldv_queue_delayed_work_on_219(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_7(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
bool ldv_cancel_delayed_work_220(struct delayed_work *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___12 ldv_func_res ;
  bool tmp ;

  {
  tmp = cancel_delayed_work(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_work_7(& ldv_func_arg1->work);
  return (ldv_func_res);
}
}
bool ldv_cancel_delayed_work_221(struct delayed_work *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___20 ldv_func_res ;
  bool tmp ;

  {
  tmp = cancel_delayed_work(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_work_7(& ldv_func_arg1->work);
  return (ldv_func_res);
}
}
bool ldv_cancel_work_sync_222(struct work_struct *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___5 ldv_func_res ;
  bool tmp ;

  {
  tmp = cancel_work_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_work_7(ldv_func_arg1);
  return (ldv_func_res);
}
}
bool ldv_cancel_work_sync_223(struct work_struct *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___6 ldv_func_res ;
  bool tmp ;

  {
  tmp = cancel_work_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_work_7(ldv_func_arg1);
  return (ldv_func_res);
}
}
bool ldv_cancel_work_sync_224(struct work_struct *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___7 ldv_func_res ;
  bool tmp ;

  {
  tmp = cancel_work_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_work_7(ldv_func_arg1);
  return (ldv_func_res);
}
}
bool ldv_cancel_delayed_work_sync_225(struct delayed_work *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___8 ldv_func_res ;
  bool tmp ;

  {
  tmp = cancel_delayed_work_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_work_7(& ldv_func_arg1->work);
  return (ldv_func_res);
}
}
__inline static long ldv__builtin_expect(long exp , long c ) ;
bool ldv_queue_work_on_241(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_work_on_243(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_delayed_work_on_242(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
bool ldv_queue_delayed_work_on_245(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
void ldv_flush_workqueue_244(struct workqueue_struct *ldv_func_arg1 ) ;
__inline static bool conf_is_ht40_minus(struct ieee80211_conf *conf ) 
{ 


  {
  return ((bool )((unsigned int )conf->chandef.width == 2U && conf->chandef.center_freq1 < (u32 )(conf->chandef.chan)->center_freq));
}
}
__inline static bool conf_is_ht40_plus(struct ieee80211_conf *conf ) 
{ 


  {
  return ((bool )((unsigned int )conf->chandef.width == 2U && conf->chandef.center_freq1 > (u32 )(conf->chandef.chan)->center_freq));
}
}
__inline static int iwl_is_any_associated___2(struct iwl_priv *priv ) 
{ 
  struct iwl_rxon_context *ctx ;
  int tmp ;

  {
  ctx = (struct iwl_rxon_context *)(& priv->contexts);
  goto ldv_53234;
  ldv_53233: ;
  if ((int )((unsigned long )priv->valid_contexts >> (int )ctx->ctxid) & 1) {
    tmp = iwl_is_associated_ctx(ctx);
    if (tmp != 0) {
      return (1);
    } else {

    }
  } else {

  }
  ctx = ctx + 1;
  ldv_53234: ;
  if ((unsigned long )((struct iwl_rxon_context *)(& priv->contexts) + 2UL) > (unsigned long )ctx) {
    goto ldv_53233;
  } else {

  }

  return (0);
}
}
void iwlagn_config_ht40(struct ieee80211_conf *conf , struct iwl_rxon_context *ctx ) ;
__inline static int iwl_is_alive(struct iwl_priv *priv ) 
{ 
  int tmp ;

  {
  tmp = constant_test_bit(2L, (unsigned long const volatile   *)(& priv->status));
  return (tmp);
}
}
void iwl_connection_init_rx_config(struct iwl_priv *priv , struct iwl_rxon_context *ctx ) 
{ 


  {
  memset((void *)(& ctx->staging), 0, 50UL);
  if ((unsigned long )ctx->vif == (unsigned long )((struct ieee80211_vif *)0)) {
    ctx->staging.dev_type = ctx->unused_devtype;
  } else {
    switch ((unsigned int )(ctx->vif)->type) {
    case 3U: 
    ctx->staging.dev_type = ctx->ap_devtype;
    goto ldv_53650;
    case 2U: 
    ctx->staging.dev_type = ctx->station_devtype;
    ctx->staging.filter_flags = 4U;
    goto ldv_53650;
    case 1U: 
    ctx->staging.dev_type = ctx->ibss_devtype;
    ctx->staging.flags = 32U;
    ctx->staging.filter_flags = 68U;
    goto ldv_53650;
    case 6U: 
    ctx->staging.dev_type = 6U;
    goto ldv_53650;
    default: 
    __iwl_err(priv->dev, 0, 0, "Unsupported interface type %d\n", (unsigned int )(ctx->vif)->type);
    goto ldv_53650;
    }
    ldv_53650: ;
  }
  ctx->staging.channel = ((priv->hw)->conf.chandef.chan)->hw_value;
  priv->band = ((priv->hw)->conf.chandef.chan)->band;
  iwl_set_flags_for_band(priv, ctx, priv->band, ctx->vif);
  ctx->staging.flags = ctx->staging.flags & 4194303999U;
  if ((unsigned long )ctx->vif != (unsigned long )((struct ieee80211_vif *)0)) {
    memcpy((void *)(& ctx->staging.node_addr), (void const   *)(& (ctx->vif)->addr),
             6UL);
  } else {

  }
  ctx->staging.ofdm_ht_single_stream_basic_rates = 255U;
  ctx->staging.ofdm_ht_dual_stream_basic_rates = 255U;
  ctx->staging.ofdm_ht_triple_stream_basic_rates = 255U;
  return;
}
}
static int iwlagn_disable_bss(struct iwl_priv *priv , struct iwl_rxon_context *ctx ,
                              struct iwl_rxon_cmd *send ) 
{ 
  __le32 old_filter ;
  int ret ;
  bool tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  old_filter = send->filter_flags;
  send->filter_flags = send->filter_flags & 4294967263U;
  ret = iwl_dvm_send_cmd_pdu(priv, (int )ctx->rxon_cmd, 0U, 50, (void const   *)send);
  send->filter_flags = old_filter;
  if (ret != 0) {
    tmp___1 = iwl_is_rfkill(priv);
    if (tmp___1 == 0) {
      __iwl_err(priv->dev, 0, 0, "Error clearing ASSOC_MSK on BSS (%d)\n", ret);
    } else {
      tmp = iwl_have_debug_level(128U);
      if ((int )tmp != 0) {
        tmp___0 = 0;
      } else {
        tmp___0 = 1;
      }
      __iwl_err(priv->dev, 1, (int )((bool )tmp___0), "Error clearing ASSOC_MSK on BSS (%d)\n",
                ret);
    }
  } else {

  }
  return (ret);
}
}
static int iwlagn_disable_pan(struct iwl_priv *priv , struct iwl_rxon_context *ctx ,
                              struct iwl_rxon_cmd *send ) 
{ 
  struct iwl_notification_wait disable_wait ;
  __le32 old_filter ;
  u8 old_dev_type ;
  int ret ;
  u8 deactivate_cmd[1U] ;

  {
  old_filter = send->filter_flags;
  old_dev_type = send->dev_type;
  deactivate_cmd[0] = 189U;
  iwl_init_notification_wait(& priv->notif_wait, & disable_wait, (u8 const   *)(& deactivate_cmd),
                             1, (bool (*)(struct iwl_notif_wait_data * , struct iwl_rx_packet * ,
                                          void * ))0, (void *)0);
  send->filter_flags = send->filter_flags & 4294967263U;
  send->dev_type = 9U;
  ret = iwl_dvm_send_cmd_pdu(priv, (int )ctx->rxon_cmd, 0U, 50, (void const   *)send);
  send->filter_flags = old_filter;
  send->dev_type = old_dev_type;
  if (ret != 0) {
    __iwl_err(priv->dev, 0, 0, "Error disabling PAN (%d)\n", ret);
    iwl_remove_notification(& priv->notif_wait, & disable_wait);
  } else {
    ret = iwl_wait_notification(& priv->notif_wait, & disable_wait, 250UL);
    if (ret != 0) {
      __iwl_err(priv->dev, 0, 0, "Timed out waiting for PAN disable\n");
    } else {

    }
  }
  return (ret);
}
}
static int iwlagn_disconn_pan(struct iwl_priv *priv , struct iwl_rxon_context *ctx ,
                              struct iwl_rxon_cmd *send ) 
{ 
  __le32 old_filter ;
  int ret ;

  {
  old_filter = send->filter_flags;
  send->filter_flags = send->filter_flags & 4294967263U;
  ret = iwl_dvm_send_cmd_pdu(priv, (int )ctx->rxon_cmd, 0U, 50, (void const   *)send);
  send->filter_flags = old_filter;
  return (ret);
}
}
static void iwlagn_update_qos(struct iwl_priv *priv , struct iwl_rxon_context *ctx ) 
{ 
  int ret ;
  bool tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  if (! ctx->is_active) {
    return;
  } else {

  }
  ctx->qos_data.def_qos_parm.qos_flags = 0U;
  if (ctx->qos_data.qos_active != 0) {
    ctx->qos_data.def_qos_parm.qos_flags = ctx->qos_data.def_qos_parm.qos_flags | 1U;
  } else {

  }
  if ((int )ctx->ht.enabled) {
    ctx->qos_data.def_qos_parm.qos_flags = ctx->qos_data.def_qos_parm.qos_flags | 2U;
  } else {

  }
  __iwl_dbg(priv->dev, 1U, 0, "iwlagn_update_qos", "send QoS cmd with Qos active=%d FLAGS=0x%X\n",
            ctx->qos_data.qos_active, ctx->qos_data.def_qos_parm.qos_flags);
  ret = iwl_dvm_send_cmd_pdu(priv, (int )ctx->qos_cmd, 0U, 36, (void const   *)(& ctx->qos_data.def_qos_parm));
  if (ret != 0) {
    tmp___1 = iwl_is_rfkill(priv);
    if (tmp___1 == 0) {
      __iwl_err(priv->dev, 0, 0, "Failed to update QoS\n");
    } else {
      tmp = iwl_have_debug_level(128U);
      if ((int )tmp != 0) {
        tmp___0 = 0;
      } else {
        tmp___0 = 1;
      }
      __iwl_err(priv->dev, 1, (int )((bool )tmp___0), "Failed to update QoS\n");
    }
  } else {

  }
  return;
}
}
static int iwlagn_update_beacon(struct iwl_priv *priv , struct ieee80211_vif *vif ) 
{ 
  int __ret_warn_on ;
  int tmp ;
  int tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;

  {
  if (debug_locks != 0) {
    tmp = lock_is_held(& priv->mutex.dep_map);
    if (tmp == 0) {
      tmp___0 = 1;
    } else {
      tmp___0 = 0;
    }
  } else {
    tmp___0 = 0;
  }
  __ret_warn_on = tmp___0;
  tmp___1 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp___1 != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/08_1a/drivers/net/wireless/iwlwifi/dvm/rxon.c",
                       202);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  consume_skb(priv->beacon_skb);
  priv->beacon_skb = ieee80211_beacon_get(priv->hw, vif);
  if ((unsigned long )priv->beacon_skb == (unsigned long )((struct sk_buff *)0)) {
    return (-12);
  } else {

  }
  tmp___2 = iwlagn_send_beacon_cmd(priv);
  return (tmp___2);
}
}
static int iwlagn_send_rxon_assoc(struct iwl_priv *priv , struct iwl_rxon_context *ctx ) 
{ 
  int ret ;
  struct iwl_rxon_assoc_cmd rxon_assoc ;
  struct iwl_rxon_cmd  const  *rxon1 ;
  struct iwl_rxon_cmd  const  *rxon2 ;

  {
  ret = 0;
  rxon1 = (struct iwl_rxon_cmd  const  *)(& ctx->staging);
  rxon2 = & ctx->active;
  if (((((((((unsigned int )rxon1->flags == (unsigned int )rxon2->flags && (unsigned int )rxon1->filter_flags == (unsigned int )rxon2->filter_flags) && (int )((unsigned char )rxon1->cck_basic_rates) == (int )((unsigned char )rxon2->cck_basic_rates)) && (int )((unsigned char )rxon1->ofdm_ht_single_stream_basic_rates) == (int )((unsigned char )rxon2->ofdm_ht_single_stream_basic_rates)) && (int )((unsigned char )rxon1->ofdm_ht_dual_stream_basic_rates) == (int )((unsigned char )rxon2->ofdm_ht_dual_stream_basic_rates)) && (int )((unsigned char )rxon1->ofdm_ht_triple_stream_basic_rates) == (int )((unsigned char )rxon2->ofdm_ht_triple_stream_basic_rates)) && (int )((unsigned short )rxon1->acquisition_data) == (int )((unsigned short )rxon2->acquisition_data)) && (int )((unsigned short )rxon1->rx_chain) == (int )((unsigned short )rxon2->rx_chain)) && (int )((unsigned char )rxon1->ofdm_basic_rates) == (int )((unsigned char )rxon2->ofdm_basic_rates)) {
    __iwl_dbg(priv->dev, 1U, 0, "iwlagn_send_rxon_assoc", "Using current RXON_ASSOC.  Not resending.\n");
    return (0);
  } else {

  }
  rxon_assoc.flags = ctx->staging.flags;
  rxon_assoc.filter_flags = ctx->staging.filter_flags;
  rxon_assoc.ofdm_basic_rates = ctx->staging.ofdm_basic_rates;
  rxon_assoc.cck_basic_rates = ctx->staging.cck_basic_rates;
  rxon_assoc.reserved1 = 0U;
  rxon_assoc.reserved2 = 0U;
  rxon_assoc.reserved3 = 0U;
  rxon_assoc.ofdm_ht_single_stream_basic_rates = ctx->staging.ofdm_ht_single_stream_basic_rates;
  rxon_assoc.ofdm_ht_dual_stream_basic_rates = ctx->staging.ofdm_ht_dual_stream_basic_rates;
  rxon_assoc.rx_chain_select_flags = ctx->staging.rx_chain;
  rxon_assoc.ofdm_ht_triple_stream_basic_rates = ctx->staging.ofdm_ht_triple_stream_basic_rates;
  rxon_assoc.acquisition_data = ctx->staging.acquisition_data;
  ret = iwl_dvm_send_cmd_pdu(priv, (int )ctx->rxon_assoc_cmd, 1U, 24, (void const   *)(& rxon_assoc));
  return (ret);
}
}
static u16 iwl_adjust_beacon_interval(u16 beacon_val , u16 max_beacon_val ) 
{ 
  u16 new_val ;
  u16 beacon_factor ;

  {
  if ((unsigned int )beacon_val == 0U) {
    return (200U);
  } else {

  }
  beacon_factor = (u16 )(((int )beacon_val + (int )max_beacon_val) / (int )max_beacon_val);
  new_val = (u16 )((int )beacon_val / (int )beacon_factor);
  if ((unsigned int )new_val == 0U) {
    new_val = max_beacon_val;
  } else {

  }
  return (new_val);
}
}
static int iwl_send_rxon_timing(struct iwl_priv *priv , struct iwl_rxon_context *ctx ) 
{ 
  u64 tsf ;
  s32 interval_tm ;
  s32 rem ;
  struct ieee80211_conf *conf ;
  u16 beacon_int ;
  struct ieee80211_vif *vif ;
  int __ret_warn_on ;
  int tmp ;
  int tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  uint32_t __base ;
  uint32_t __rem ;
  int tmp___5 ;

  {
  conf = (struct ieee80211_conf *)0;
  vif = ctx->vif;
  conf = & (priv->hw)->conf;
  if (debug_locks != 0) {
    tmp = lock_is_held(& priv->mutex.dep_map);
    if (tmp == 0) {
      tmp___0 = 1;
    } else {
      tmp___0 = 0;
    }
  } else {
    tmp___0 = 0;
  }
  __ret_warn_on = tmp___0;
  tmp___1 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp___1 != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/08_1a/drivers/net/wireless/iwlwifi/dvm/rxon.c",
                       302);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  memset((void *)(& ctx->timing), 0, 20UL);
  ctx->timing.timestamp = priv->timestamp;
  ctx->timing.listen_interval = conf->listen_interval;
  beacon_int = (unsigned long )vif != (unsigned long )((struct ieee80211_vif *)0) ? vif->bss_conf.beacon_int : 0U;
  ctx->timing.atim_window = 0U;
  if ((unsigned int )ctx->ctxid == 1U && ((unsigned long )ctx->vif == (unsigned long )((struct ieee80211_vif *)0) || (unsigned int )(ctx->vif)->type != 2U)) {
    tmp___4 = iwl_is_associated(priv, 0);
    if (tmp___4 != 0) {
      if ((unsigned long )priv->contexts[0].vif != (unsigned long )((struct ieee80211_vif *)0)) {
        if ((unsigned int )(priv->contexts[0].vif)->bss_conf.beacon_int != 0U) {
          ctx->timing.beacon_interval = priv->contexts[0].timing.beacon_interval;
          beacon_int = ctx->timing.beacon_interval;
        } else {
          goto _L___1;
        }
      } else {
        goto _L___1;
      }
    } else {
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
  if ((unsigned int )ctx->ctxid == 0U) {
    tmp___2 = iwl_is_associated(priv, 1);
    if (tmp___2 != 0) {
      if ((unsigned long )priv->contexts[1].vif != (unsigned long )((struct ieee80211_vif *)0)) {
        if ((unsigned int )(priv->contexts[1].vif)->bss_conf.beacon_int != 0U) {
          tmp___3 = iwl_is_associated_ctx(ctx);
          if ((tmp___3 == 0 || (unsigned long )ctx->vif == (unsigned long )((struct ieee80211_vif *)0)) || (unsigned int )(ctx->vif)->bss_conf.beacon_int == 0U) {
            ctx->timing.beacon_interval = priv->contexts[1].timing.beacon_interval;
            beacon_int = ctx->timing.beacon_interval;
          } else {
            beacon_int = iwl_adjust_beacon_interval((int )beacon_int, 4096);
            ctx->timing.beacon_interval = beacon_int;
          }
        } else {
          beacon_int = iwl_adjust_beacon_interval((int )beacon_int, 4096);
          ctx->timing.beacon_interval = beacon_int;
        }
      } else {
        beacon_int = iwl_adjust_beacon_interval((int )beacon_int, 4096);
        ctx->timing.beacon_interval = beacon_int;
      }
    } else {
      beacon_int = iwl_adjust_beacon_interval((int )beacon_int, 4096);
      ctx->timing.beacon_interval = beacon_int;
    }
  } else {
    beacon_int = iwl_adjust_beacon_interval((int )beacon_int, 4096);
    ctx->timing.beacon_interval = beacon_int;
  }
  ctx->beacon_int = (int )beacon_int;
  tsf = priv->timestamp;
  interval_tm = (int )beacon_int * 1024;
  __base = (uint32_t )interval_tm;
  __rem = (uint32_t )(tsf % (u64 )__base);
  tsf = tsf / (u64 )__base;
  rem = (s32 )__rem;
  ctx->timing.beacon_init_val = (unsigned int )(interval_tm - rem);
  ctx->timing.dtim_period = (unsigned long )vif != (unsigned long )((struct ieee80211_vif *)0) ? ((int )vif->bss_conf.dtim_period != 0 ? (u8 )((int )vif->bss_conf.dtim_period) : 1U) : 1U;
  __iwl_dbg(priv->dev, 4097U, 0, "iwl_send_rxon_timing", "beacon interval %d beacon timer %d beacon tim %d\n",
            (int )ctx->timing.beacon_interval, ctx->timing.beacon_init_val, (int )ctx->timing.atim_window);
  tmp___5 = iwl_dvm_send_cmd_pdu(priv, (int )ctx->rxon_timing_cmd, 0U, 20, (void const   *)(& ctx->timing));
  return (tmp___5);
}
}
static int iwlagn_rxon_disconn(struct iwl_priv *priv , struct iwl_rxon_context *ctx ) 
{ 
  int ret ;
  struct iwl_rxon_cmd *active ;

  {
  active = (struct iwl_rxon_cmd *)(& ctx->active);
  if ((unsigned int )ctx->ctxid == 0U) {
    ret = iwlagn_disable_bss(priv, ctx, & ctx->staging);
  } else {
    ret = iwlagn_disable_pan(priv, ctx, & ctx->staging);
    if (ret != 0) {
      return (ret);
    } else {

    }
    if ((unsigned long )ctx->vif != (unsigned long )((struct ieee80211_vif *)0)) {
      ret = iwl_send_rxon_timing(priv, ctx);
      if (ret != 0) {
        __iwl_err(priv->dev, 0, 0, "Failed to send timing (%d)!\n", ret);
        return (ret);
      } else {

      }
      ret = iwlagn_disconn_pan(priv, ctx, & ctx->staging);
    } else {

    }
  }
  if (ret != 0) {
    return (ret);
  } else {

  }
  iwl_clear_ucode_stations(priv, ctx);
  iwl_update_bcast_station(priv, ctx);
  iwl_restore_stations(priv, ctx);
  ret = iwl_restore_default_wep_keys(priv, ctx);
  if (ret != 0) {
    __iwl_err(priv->dev, 0, 0, "Failed to restore WEP keys (%d)\n", ret);
    return (ret);
  } else {

  }
  memcpy((void *)active, (void const   *)(& ctx->staging), 50UL);
  return (0);
}
}
static int iwl_set_tx_power(struct iwl_priv *priv , s8 tx_power , bool force ) 
{ 
  int ret ;
  s8 prev_tx_power ;
  bool defer ;
  struct iwl_rxon_context *ctx ;
  int __ret_warn_on ;
  int tmp ;
  int tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  ctx = (struct iwl_rxon_context *)(& priv->contexts);
  if ((priv->calib_disabled & 4U) != 0U) {
    return (0);
  } else {

  }
  if (debug_locks != 0) {
    tmp = lock_is_held(& priv->mutex.dep_map);
    if (tmp == 0) {
      tmp___0 = 1;
    } else {
      tmp___0 = 0;
    }
  } else {
    tmp___0 = 0;
  }
  __ret_warn_on = tmp___0;
  tmp___1 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp___1 != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/08_1a/drivers/net/wireless/iwlwifi/dvm/rxon.c",
                       411);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if ((int )priv->tx_power_user_lmt == (int )tx_power && ! force) {
    return (0);
  } else {

  }
  if ((int )tx_power < 0) {
    __iwl_warn(priv->dev, "Requested user TXPOWER %d below lower limit %d.\n", (int )tx_power,
               0);
    return (-22);
  } else {

  }
  if ((int )tx_power > ((int )(priv->nvm_data)->max_tx_pwr_half_dbm + 1) / 2) {
    __iwl_warn(priv->dev, "Requested user TXPOWER %d above upper limit %d.\n", (int )tx_power,
               (int )(priv->nvm_data)->max_tx_pwr_half_dbm);
    return (-22);
  } else {

  }
  tmp___2 = iwl_is_ready_rf(priv);
  if (tmp___2 == 0) {
    return (-5);
  } else {

  }
  priv->tx_power_next = tx_power;
  tmp___3 = constant_test_bit(7L, (unsigned long const volatile   *)(& priv->status));
  if (tmp___3 != 0) {
    tmp___5 = 1;
  } else {
    tmp___4 = memcmp((void const   *)(& ctx->active), (void const   *)(& ctx->staging),
                     50UL);
    if (tmp___4 != 0) {
      tmp___5 = 1;
    } else {
      tmp___5 = 0;
    }
  }
  defer = (bool )tmp___5;
  if ((int )defer && ! force) {
    __iwl_dbg(priv->dev, 1U, 0, "iwl_set_tx_power", "Deferring tx power set\n");
    return (0);
  } else {

  }
  prev_tx_power = priv->tx_power_user_lmt;
  priv->tx_power_user_lmt = tx_power;
  ret = iwlagn_send_tx_power(priv);
  if (ret != 0) {
    priv->tx_power_user_lmt = prev_tx_power;
    priv->tx_power_next = prev_tx_power;
  } else {

  }
  return (ret);
}
}
static int iwlagn_rxon_connect(struct iwl_priv *priv , struct iwl_rxon_context *ctx ) 
{ 
  int ret ;
  struct iwl_rxon_cmd *active ;
  int tmp ;

  {
  active = (struct iwl_rxon_cmd *)(& ctx->active);
  if ((unsigned int )ctx->ctxid == 0U) {
    ret = iwl_send_rxon_timing(priv, ctx);
    if (ret != 0) {
      __iwl_err(priv->dev, 0, 0, "Failed to send timing (%d)!\n", ret);
      return (ret);
    } else {

    }
  } else {

  }
  iwlagn_update_qos(priv, ctx);
  if ((unsigned long )ctx->vif != (unsigned long )((struct ieee80211_vif *)0) && (unsigned int )(ctx->vif)->type == 3U) {
    ret = iwlagn_update_beacon(priv, ctx->vif);
    if (ret != 0) {
      __iwl_err(priv->dev, 0, 0, "Error sending required beacon (%d)!\n", ret);
      return (ret);
    } else {

    }
  } else {

  }
  priv->start_calib = 0U;
  ret = iwl_dvm_send_cmd_pdu(priv, (int )ctx->rxon_cmd, 0U, 50, (void const   *)(& ctx->staging));
  if (ret != 0) {
    __iwl_err(priv->dev, 0, 0, "Error setting new RXON (%d)\n", ret);
    return (ret);
  } else {

  }
  memcpy((void *)active, (void const   *)(& ctx->staging), 50UL);
  if ((unsigned long )ctx->vif != (unsigned long )((struct ieee80211_vif *)0) && (unsigned int )(ctx->vif)->type == 1U) {
    tmp = iwlagn_update_beacon(priv, ctx->vif);
    if (tmp != 0) {
      __iwl_err(priv->dev, 0, 0, "Error sending IBSS beacon\n");
    } else {

    }
  } else {

  }
  iwl_init_sensitivity(priv);
  ret = iwl_set_tx_power(priv, (int )priv->tx_power_next, 1);
  if (ret != 0) {
    __iwl_err(priv->dev, 0, 0, "Error sending TX power (%d)\n", ret);
    return (ret);
  } else {

  }
  if ((((unsigned long )ctx->vif != (unsigned long )((struct ieee80211_vif *)0) && (unsigned int )(ctx->vif)->type == 2U) && (unsigned long )(priv->cfg)->ht_params != (unsigned long )((struct iwl_ht_params  const  */* const  */)0)) && (unsigned int )((priv->cfg)->ht_params)->smps_mode != 0U) {
    ieee80211_request_smps(ctx->vif, ((priv->cfg)->ht_params)->smps_mode);
  } else {

  }
  return (0);
}
}
int iwlagn_set_pan_params(struct iwl_priv *priv ) 
{ 
  struct iwl_wipan_params_cmd cmd ;
  struct iwl_rxon_context *ctx_bss ;
  struct iwl_rxon_context *ctx_pan ;
  int slot0 ;
    klee_make_symbolic(&slot0, sizeof(int), "slot0");
  int slot1 ;
    klee_make_symbolic(&slot1, sizeof(int), "slot1");
  int ret ;
  int __ret_warn_on ;
  int tmp ;
  int tmp___0 ;
  long tmp___1 ;
  int bcnint ;
    klee_make_symbolic(&bcnint, sizeof(int), "bcnint");
  int dtim ;
    klee_make_symbolic(&dtim, sizeof(int), "dtim");
  int __max1 ;
    klee_make_symbolic(&__max1, sizeof(int), "__max1");
  int __max2 ;
    klee_make_symbolic(&__max2, sizeof(int), "__max2");
  int tmp___2 ;
  int __max1___0 ;
    klee_make_symbolic(&__max1___0, sizeof(int), "__max1___0");
  int __max2___0 ;
    klee_make_symbolic(&__max2___0, sizeof(int), "__max2___0");
  int __max1___1 ;
    klee_make_symbolic(&__max1___1, sizeof(int), "__max1___1");
  int __max2___1 ;
    klee_make_symbolic(&__max2___1, sizeof(int), "__max2___1");
  int tmp___3 ;

  {
  slot0 = 300;
  slot1 = 0;
  if ((unsigned int )priv->valid_contexts == 1U) {
    return (0);
  } else {

  }
  if (debug_locks != 0) {
    tmp = lock_is_held(& priv->mutex.dep_map);
    if (tmp == 0) {
      tmp___0 = 1;
    } else {
      tmp___0 = 0;
    }
  } else {
    tmp___0 = 0;
  }
  __ret_warn_on = tmp___0;
  tmp___1 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp___1 != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/08_1a/drivers/net/wireless/iwlwifi/dvm/rxon.c",
                       545);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  ctx_bss = (struct iwl_rxon_context *)(& priv->contexts);
  ctx_pan = (struct iwl_rxon_context *)(& priv->contexts) + 1UL;
  if (! ctx_pan->is_active) {
    return (0);
  } else {

  }
  memset((void *)(& cmd), 0, 44UL);
  cmd.num_slots = 2U;
  cmd.slots[0].type = 0U;
  cmd.slots[1].type = 1U;
  if ((unsigned long )ctx_bss->vif != (unsigned long )((struct ieee80211_vif *)0) && (unsigned long )ctx_pan->vif != (unsigned long )((struct ieee80211_vif *)0)) {
    bcnint = ctx_pan->beacon_int;
    dtim = (int )(ctx_pan->vif)->bss_conf.dtim_period != 0 ? (int )(ctx_pan->vif)->bss_conf.dtim_period != 0 : 1;
    cmd.flags = (__le16 )((unsigned int )cmd.flags | 8U);
    if (((unsigned int )(ctx_pan->vif)->type == 3U && bcnint != 0) && ctx_bss->beacon_int != bcnint) {
      __iwl_err(priv->dev, 0, 0, "beacon intervals don\'t match (%d, %d)\n", ctx_bss->beacon_int,
                ctx_pan->beacon_int);
    } else {
      __max1 = bcnint;
      __max2 = ctx_bss->beacon_int;
      bcnint = __max1 > __max2 ? __max1 : __max2;
    }
    if (bcnint == 0) {
      bcnint = 200;
    } else {

    }
    slot0 = bcnint / 2;
    slot1 = bcnint - slot0;
    tmp___2 = constant_test_bit(9L, (unsigned long const volatile   *)(& priv->status));
    if (tmp___2 != 0 || (! (ctx_bss->vif)->bss_conf.idle && ! (ctx_bss->vif)->bss_conf.assoc)) {
      slot0 = (dtim * bcnint) * 3 + -20;
      slot1 = 20;
    } else
    if (! (ctx_pan->vif)->bss_conf.idle && ! (ctx_pan->vif)->bss_conf.assoc) {
      slot1 = (dtim * bcnint) * 3 + -20;
      slot0 = 20;
    } else {

    }
  } else
  if ((unsigned long )ctx_pan->vif != (unsigned long )((struct ieee80211_vif *)0)) {
    slot0 = 0;
    __max1___0 = 1;
    __max2___0 = (int )(ctx_pan->vif)->bss_conf.dtim_period;
    slot1 = (__max1___0 > __max2___0 ? __max1___0 : __max2___0) * ctx_pan->beacon_int;
    __max1___1 = 200;
    __max2___1 = slot1;
    slot1 = __max1___1 > __max2___1 ? __max1___1 : __max2___1;
    tmp___3 = constant_test_bit(9L, (unsigned long const volatile   *)(& priv->status));
    if (tmp___3 != 0) {
      slot0 = slot1 * 3 + -20;
      slot1 = 20;
    } else {

    }
  } else {

  }
  cmd.slots[0].width = (unsigned short )slot0;
  cmd.slots[1].width = (unsigned short )slot1;
  ret = iwl_dvm_send_cmd_pdu(priv, 178, 0U, 44, (void const   *)(& cmd));
  if (ret != 0) {
    __iwl_err(priv->dev, 0, 0, "Error setting PAN parameters (%d)\n", ret);
  } else {

  }
  return (ret);
}
}
static void _iwl_set_rxon_ht(struct iwl_priv *priv , struct iwl_ht_config *ht_conf ,
                             struct iwl_rxon_context *ctx ) 
{ 
  struct iwl_rxon_cmd *rxon ;
  bool tmp ;

  {
  rxon = & ctx->staging;
  if (! ctx->ht.enabled) {
    rxon->flags = rxon->flags & 4164943871U;
    return;
  } else {

  }
  rxon->flags = rxon->flags | (__le32 )((int )ctx->ht.protection << 23);
  rxon->flags = rxon->flags & 4190109695U;
  tmp = iwl_is_ht40_tx_allowed(priv, ctx, (struct ieee80211_sta *)0);
  if ((int )tmp) {
    if ((unsigned int )ctx->ht.protection == 2U) {
      rxon->flags = rxon->flags | 33554432U;
      switch ((int )ctx->ht.extension_chan_offset) {
      case 1: 
      rxon->flags = rxon->flags & 4290772991U;
      goto ldv_53777;
      case 3: 
      rxon->flags = rxon->flags | 4194304U;
      goto ldv_53777;
      }
      ldv_53777: ;
    } else {
      switch ((int )ctx->ht.extension_chan_offset) {
      case 1: 
      rxon->flags = rxon->flags & 4290772991U;
      rxon->flags = rxon->flags | 67108864U;
      goto ldv_53780;
      case 3: 
      rxon->flags = rxon->flags | 4194304U;
      rxon->flags = rxon->flags | 67108864U;
      goto ldv_53780;
      case 0: ;
      default: 
      __iwl_err(priv->dev, 0, 0, "invalid extension channel offset\n");
      goto ldv_53780;
      }
      ldv_53780: ;
    }
  } else {
    rxon->flags = rxon->flags;
  }
  iwlagn_set_rxon_chain(priv, ctx);
  __iwl_dbg(priv->dev, 4097U, 0, "_iwl_set_rxon_ht", "rxon flags 0x%X operation mode :0x%X extension channel offset 0x%x\n",
            rxon->flags, (int )ctx->ht.protection, (int )ctx->ht.extension_chan_offset);
  return;
}
}
void iwl_set_rxon_ht(struct iwl_priv *priv , struct iwl_ht_config *ht_conf ) 
{ 
  struct iwl_rxon_context *ctx ;

  {
  ctx = (struct iwl_rxon_context *)(& priv->contexts);
  goto ldv_53791;
  ldv_53790: ;
  if ((int )((unsigned long )priv->valid_contexts >> (int )ctx->ctxid) & 1) {
    _iwl_set_rxon_ht(priv, ht_conf, ctx);
  } else {

  }
  ctx = ctx + 1;
  ldv_53791: ;
  if ((unsigned long )((struct iwl_rxon_context *)(& priv->contexts) + 2UL) > (unsigned long )ctx) {
    goto ldv_53790;
  } else {

  }

  return;
}
}
void iwl_set_rxon_channel(struct iwl_priv *priv , struct ieee80211_channel *ch , struct iwl_rxon_context *ctx ) 
{ 
  enum ieee80211_band band ;
  u16 channel ;

  {
  band = ch->band;
  channel = ch->hw_value;
  if ((int )ctx->staging.channel == (int )channel && (unsigned int )priv->band == (unsigned int )band) {
    return;
  } else {

  }
  ctx->staging.channel = channel;
  if ((unsigned int )band == 1U) {
    ctx->staging.flags = ctx->staging.flags & 4294967294U;
  } else {
    ctx->staging.flags = ctx->staging.flags | 1U;
  }
  priv->band = band;
  __iwl_dbg(priv->dev, 1U, 0, "iwl_set_rxon_channel", "Staging channel set to %d [%d]\n",
            (int )channel, (unsigned int )band);
  return;
}
}
void iwl_set_flags_for_band(struct iwl_priv *priv , struct iwl_rxon_context *ctx ,
                            enum ieee80211_band band , struct ieee80211_vif *vif ) 
{ 


  {
  if ((unsigned int )band == 1U) {
    ctx->staging.flags = ctx->staging.flags & 4294967288U;
    ctx->staging.flags = ctx->staging.flags | 16U;
  } else {
    if ((unsigned long )vif != (unsigned long )((struct ieee80211_vif *)0) && (int )vif->bss_conf.use_short_slot) {
      ctx->staging.flags = ctx->staging.flags | 16U;
    } else {
      ctx->staging.flags = ctx->staging.flags & 4294967279U;
    }
    ctx->staging.flags = ctx->staging.flags | 1U;
    ctx->staging.flags = ctx->staging.flags | 4U;
    ctx->staging.flags = ctx->staging.flags & 4294967293U;
  }
  return;
}
}
static void iwl_set_rxon_hwcrypto(struct iwl_priv *priv , struct iwl_rxon_context *ctx ,
                                  int hw_decrypt ) 
{ 
  struct iwl_rxon_cmd *rxon ;

  {
  rxon = & ctx->staging;
  if (hw_decrypt != 0) {
    rxon->filter_flags = rxon->filter_flags & 4294967287U;
  } else {
    rxon->filter_flags = rxon->filter_flags | 8U;
  }
  return;
}
}
static int iwl_check_rxon_cmd(struct iwl_priv *priv , struct iwl_rxon_context *ctx ) 
{ 
  struct iwl_rxon_cmd *rxon ;
  u32 errors ;
  int __ret_warn_on ;
  long tmp ;

  {
  rxon = & ctx->staging;
  errors = 0U;
  if ((int )rxon->flags & 1) {
    if ((rxon->flags & 8192U) != 0U) {
      __iwl_warn(priv->dev, "check 2.4G: wrong narrow\n");
      errors = errors | 1U;
    } else {

    }
    if ((rxon->flags & 4096U) != 0U) {
      __iwl_warn(priv->dev, "check 2.4G: wrong radar\n");
      errors = errors | 2U;
    } else {

    }
  } else {
    if ((rxon->flags & 16U) == 0U) {
      __iwl_warn(priv->dev, "check 5.2G: not short slot!\n");
      errors = errors | 4U;
    } else {

    }
    if ((rxon->flags & 2U) != 0U) {
      __iwl_warn(priv->dev, "check 5.2G: CCK!\n");
      errors = errors | 8U;
    } else {

    }
  }
  if (((int )rxon->node_addr[0] | (int )rxon->bssid_addr[0]) & 1) {
    __iwl_warn(priv->dev, "mac/bssid mcast!\n");
    errors = errors | 16U;
  } else {

  }
  if (((int )rxon->ofdm_basic_rates & 16) == 0 && ((int )rxon->cck_basic_rates & 1) == 0) {
    __iwl_warn(priv->dev, "neither 1 nor 6 are basic\n");
    errors = errors | 32U;
  } else {

  }
  if ((unsigned int )rxon->assoc_id > 2007U) {
    __iwl_warn(priv->dev, "aid > 2007\n");
    errors = errors | 64U;
  } else {

  }
  if ((rxon->flags & 18U) == 18U) {
    __iwl_warn(priv->dev, "CCK and short slot\n");
    errors = errors | 128U;
  } else {

  }
  if ((rxon->flags & 6U) == 6U) {
    __iwl_warn(priv->dev, "CCK and auto detect\n");
    errors = errors | 256U;
  } else {

  }
  if ((rxon->flags & 12U) == 8U) {
    __iwl_warn(priv->dev, "TGg but no auto-detect\n");
    errors = errors | 512U;
  } else {

  }
  if ((unsigned int )rxon->channel == 0U) {
    __iwl_warn(priv->dev, "zero channel is invalid\n");
    errors = errors | 1024U;
  } else {

  }
  __ret_warn_on = errors != 0U;
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp != 0L) {
    warn_slowpath_fmt("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/08_1a/drivers/net/wireless/iwlwifi/dvm/rxon.c",
                      843, "Invalid RXON (%#x), channel %d", errors, (int )rxon->channel);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  return (errors != 0U ? -22 : 0);
}
}
static int iwl_full_rxon_required(struct iwl_priv *priv , struct iwl_rxon_context *ctx ) 
{ 
  struct iwl_rxon_cmd  const  *staging ;
  struct iwl_rxon_cmd  const  *active ;
  int tmp ;
  bool tmp___0 ;
  int tmp___1 ;
  bool tmp___2 ;
  int tmp___3 ;
  bool tmp___4 ;
  int tmp___5 ;

  {
  staging = (struct iwl_rxon_cmd  const  *)(& ctx->staging);
  active = & ctx->active;
  tmp = iwl_is_associated_ctx(ctx);
  if (tmp == 0) {
    __iwl_dbg(priv->dev, 1U, 0, "iwl_full_rxon_required", "need full RXON - !iwl_is_associated_ctx(ctx)\n");
    return (1);
  } else {

  }
  tmp___0 = ether_addr_equal((u8 const   *)(& staging->bssid_addr), (u8 const   *)(& active->bssid_addr));
  if (tmp___0) {
    tmp___1 = 0;
  } else {
    tmp___1 = 1;
  }
  if (tmp___1) {
    __iwl_dbg(priv->dev, 1U, 0, "iwl_full_rxon_required", "need full RXON - !ether_addr_equal(staging->bssid_addr, active->bssid_addr)\n");
    return (1);
  } else {

  }
  tmp___2 = ether_addr_equal((u8 const   *)(& staging->node_addr), (u8 const   *)(& active->node_addr));
  if (tmp___2) {
    tmp___3 = 0;
  } else {
    tmp___3 = 1;
  }
  if (tmp___3) {
    __iwl_dbg(priv->dev, 1U, 0, "iwl_full_rxon_required", "need full RXON - !ether_addr_equal(staging->node_addr, active->node_addr)\n");
    return (1);
  } else {

  }
  tmp___4 = ether_addr_equal((u8 const   *)(& staging->wlap_bssid_addr), (u8 const   *)(& active->wlap_bssid_addr));
  if (tmp___4) {
    tmp___5 = 0;
  } else {
    tmp___5 = 1;
  }
  if (tmp___5) {
    __iwl_dbg(priv->dev, 1U, 0, "iwl_full_rxon_required", "need full RXON - !ether_addr_equal(staging->wlap_bssid_addr, active->wlap_bssid_addr)\n");
    return (1);
  } else {

  }
  if ((int )((unsigned char )staging->dev_type) != (int )((unsigned char )active->dev_type)) {
    __iwl_dbg(priv->dev, 1U, 0, "iwl_full_rxon_required", "need full RXON - staging->dev_type != active->dev_type - %d != %d\n",
              (int )staging->dev_type, (int )active->dev_type);
    return (1);
  } else {

  }
  if ((int )((unsigned short )staging->channel) != (int )((unsigned short )active->channel)) {
    __iwl_dbg(priv->dev, 1U, 0, "iwl_full_rxon_required", "need full RXON - staging->channel != active->channel - %d != %d\n",
              (int )staging->channel, (int )active->channel);
    return (1);
  } else {

  }
  if ((int )((unsigned char )staging->air_propagation) != (int )((unsigned char )active->air_propagation)) {
    __iwl_dbg(priv->dev, 1U, 0, "iwl_full_rxon_required", "need full RXON - staging->air_propagation != active->air_propagation - %d != %d\n",
              (int )staging->air_propagation, (int )active->air_propagation);
    return (1);
  } else {

  }
  if ((int )((unsigned char )staging->ofdm_ht_single_stream_basic_rates) != (int )((unsigned char )active->ofdm_ht_single_stream_basic_rates)) {
    __iwl_dbg(priv->dev, 1U, 0, "iwl_full_rxon_required", "need full RXON - staging->ofdm_ht_single_stream_basic_rates != active->ofdm_ht_single_stream_basic_rates - %d != %d\n",
              (int )staging->ofdm_ht_single_stream_basic_rates, (int )active->ofdm_ht_single_stream_basic_rates);
    return (1);
  } else {

  }
  if ((int )((unsigned char )staging->ofdm_ht_dual_stream_basic_rates) != (int )((unsigned char )active->ofdm_ht_dual_stream_basic_rates)) {
    __iwl_dbg(priv->dev, 1U, 0, "iwl_full_rxon_required", "need full RXON - staging->ofdm_ht_dual_stream_basic_rates != active->ofdm_ht_dual_stream_basic_rates - %d != %d\n",
              (int )staging->ofdm_ht_dual_stream_basic_rates, (int )active->ofdm_ht_dual_stream_basic_rates);
    return (1);
  } else {

  }
  if ((int )((unsigned char )staging->ofdm_ht_triple_stream_basic_rates) != (int )((unsigned char )active->ofdm_ht_triple_stream_basic_rates)) {
    __iwl_dbg(priv->dev, 1U, 0, "iwl_full_rxon_required", "need full RXON - staging->ofdm_ht_triple_stream_basic_rates != active->ofdm_ht_triple_stream_basic_rates - %d != %d\n",
              (int )staging->ofdm_ht_triple_stream_basic_rates, (int )active->ofdm_ht_triple_stream_basic_rates);
    return (1);
  } else {

  }
  if ((int )((unsigned short )staging->assoc_id) != (int )((unsigned short )active->assoc_id)) {
    __iwl_dbg(priv->dev, 1U, 0, "iwl_full_rxon_required", "need full RXON - staging->assoc_id != active->assoc_id - %d != %d\n",
              (int )staging->assoc_id, (int )active->assoc_id);
    return (1);
  } else {

  }
  if ((int )((unsigned int )staging->flags ^ (unsigned int )active->flags) & 1) {
    __iwl_dbg(priv->dev, 1U, 0, "iwl_full_rxon_required", "need full RXON - staging->flags & RXON_FLG_BAND_24G_MSK != active->flags & RXON_FLG_BAND_24G_MSK - %d != %d\n",
              (unsigned int )staging->flags & 1U, (unsigned int )active->flags & 1U);
    return (1);
  } else {

  }
  if ((((unsigned int )staging->filter_flags ^ (unsigned int )active->filter_flags) & 32U) != 0U) {
    __iwl_dbg(priv->dev, 1U, 0, "iwl_full_rxon_required", "need full RXON - staging->filter_flags & RXON_FILTER_ASSOC_MSK != active->filter_flags & RXON_FILTER_ASSOC_MSK - %d != %d\n",
              (unsigned int )staging->filter_flags & 32U, (unsigned int )active->filter_flags & 32U);
    return (1);
  } else {

  }
  return (0);
}
}
void iwl_print_rx_config_cmd(struct iwl_priv *priv , enum iwl_rxon_context_id ctxid ) 
{ 
  struct iwl_rxon_context *ctx ;
  struct iwl_rxon_cmd *rxon ;
  bool tmp ;

  {
  ctx = (struct iwl_rxon_context *)(& priv->contexts) + (unsigned long )ctxid;
  rxon = & ctx->staging;
  __iwl_dbg(priv->dev, 128U, 0, "iwl_print_rx_config_cmd", "RX CONFIG:\n");
  tmp = iwl_have_debug_level(128U);
  if ((int )tmp) {
    print_hex_dump("\017", "iwl data: ", 2, 16, 1, (void const   *)rxon, 50UL, 1);
  } else {

  }
  __iwl_dbg(priv->dev, 128U, 0, "iwl_print_rx_config_cmd", "u16 channel: 0x%x\n",
            (int )rxon->channel);
  __iwl_dbg(priv->dev, 128U, 0, "iwl_print_rx_config_cmd", "u32 flags: 0x%08X\n",
            rxon->flags);
  __iwl_dbg(priv->dev, 128U, 0, "iwl_print_rx_config_cmd", "u32 filter_flags: 0x%08x\n",
            rxon->filter_flags);
  __iwl_dbg(priv->dev, 128U, 0, "iwl_print_rx_config_cmd", "u8 dev_type: 0x%x\n",
            (int )rxon->dev_type);
  __iwl_dbg(priv->dev, 128U, 0, "iwl_print_rx_config_cmd", "u8 ofdm_basic_rates: 0x%02x\n",
            (int )rxon->ofdm_basic_rates);
  __iwl_dbg(priv->dev, 128U, 0, "iwl_print_rx_config_cmd", "u8 cck_basic_rates: 0x%02x\n",
            (int )rxon->cck_basic_rates);
  __iwl_dbg(priv->dev, 128U, 0, "iwl_print_rx_config_cmd", "u8[6] node_addr: %pM\n",
            (u8 *)(& rxon->node_addr));
  __iwl_dbg(priv->dev, 128U, 0, "iwl_print_rx_config_cmd", "u8[6] bssid_addr: %pM\n",
            (u8 *)(& rxon->bssid_addr));
  __iwl_dbg(priv->dev, 128U, 0, "iwl_print_rx_config_cmd", "u16 assoc_id: 0x%x\n",
            (int )rxon->assoc_id);
  return;
}
}
static void iwl_calc_basic_rates(struct iwl_priv *priv , struct iwl_rxon_context *ctx ) 
{ 
  int lowest_present_ofdm ;
    klee_make_symbolic(&lowest_present_ofdm, sizeof(int), "lowest_present_ofdm");
  int lowest_present_cck ;
    klee_make_symbolic(&lowest_present_cck, sizeof(int), "lowest_present_cck");
  u8 cck ;
  u8 ofdm ;
  struct ieee80211_supported_band *sband ;
  unsigned long basic ;
    klee_make_symbolic(&basic, sizeof(long), "basic");
  int i ;
  unsigned long tmp ;
  int hw ;
    klee_make_symbolic(&hw, sizeof(int), "hw");
  unsigned long tmp___0 ;

  {
  lowest_present_ofdm = 100;
  lowest_present_cck = 100;
  cck = 0U;
  ofdm = 0U;
  if ((unsigned long )ctx->vif != (unsigned long )((struct ieee80211_vif *)0)) {
    basic = (unsigned long )(ctx->vif)->bss_conf.basic_rates;
    sband = ((priv->hw)->wiphy)->bands[(unsigned int )((priv->hw)->conf.chandef.chan)->band];
    tmp = find_first_bit((unsigned long const   *)(& basic), 64UL);
    i = (int )tmp;
    goto ldv_53848;
    ldv_53847: 
    hw = (int )(sband->bitrates + (unsigned long )i)->hw_value;
    if (hw > 3) {
      ofdm = (int )((u8 )(1UL << (hw + -4))) | (int )ofdm;
      if (lowest_present_ofdm > hw) {
        lowest_present_ofdm = hw;
      } else {

      }
    } else {
      cck = (int )((u8 )(1UL << hw)) | (int )cck;
      if (lowest_present_cck > hw) {
        lowest_present_cck = hw;
      } else {

      }
    }
    tmp___0 = find_next_bit((unsigned long const   *)(& basic), 64UL, (unsigned long )(i + 1));
    i = (int )tmp___0;
    ldv_53848: ;
    if (i <= 63) {
      goto ldv_53847;
    } else {

    }

  } else {

  }
  if (lowest_present_ofdm > 8) {
    ofdm = (u8 )((unsigned int )ofdm | 16U);
  } else {

  }
  if (lowest_present_ofdm > 6) {
    ofdm = (u8 )((unsigned int )ofdm | 4U);
  } else {

  }
  ofdm = (u8 )((unsigned int )ofdm | 1U);
  if (lowest_present_cck > 3) {
    cck = (u8 )((unsigned int )cck | 8U);
  } else {

  }
  if (lowest_present_cck > 2) {
    cck = (u8 )((unsigned int )cck | 4U);
  } else {

  }
  if (lowest_present_cck > 1) {
    cck = (u8 )((unsigned int )cck | 2U);
  } else {

  }
  cck = (u8 )((unsigned int )cck | 1U);
  __iwl_dbg(priv->dev, 1048576U, 0, "iwl_calc_basic_rates", "Set basic rates cck:0x%.2x ofdm:0x%.2x\n",
            (int )cck, (int )ofdm);
  ctx->staging.cck_basic_rates = cck;
  ctx->staging.ofdm_basic_rates = ofdm;
  return;
}
}
int iwlagn_commit_rxon(struct iwl_priv *priv , struct iwl_rxon_context *ctx ) 
{ 
  struct iwl_rxon_cmd *active ;
  bool new_assoc ;
  int ret ;
  int __ret_warn_on ;
  int tmp ;
  int tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  active = (struct iwl_rxon_cmd *)(& ctx->active);
  new_assoc = (ctx->staging.filter_flags & 32U) != 0U;
  if (debug_locks != 0) {
    tmp = lock_is_held(& priv->mutex.dep_map);
    if (tmp == 0) {
      tmp___0 = 1;
    } else {
      tmp___0 = 0;
    }
  } else {
    tmp___0 = 0;
  }
  __ret_warn_on = tmp___0;
  tmp___1 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp___1 != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/08_1a/drivers/net/wireless/iwlwifi/dvm/rxon.c",
                       1054);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  tmp___2 = iwl_is_alive(priv);
  if (tmp___2 == 0) {
    return (-16);
  } else {

  }
  if (! ctx->is_active) {
    return (0);
  } else {

  }
  ctx->staging.flags = ctx->staging.flags | 32768U;
  iwl_calc_basic_rates(priv, ctx);
  if (! priv->hw_params.use_rts_for_aggregation) {
    ctx->staging.flags = ctx->staging.flags | 1073741824U;
  } else {

  }
  if (((unsigned long )ctx->vif != (unsigned long )((struct ieee80211_vif *)0) && (int )(ctx->vif)->bss_conf.use_short_slot) || (ctx->staging.flags & 1U) == 0U) {
    ctx->staging.flags = ctx->staging.flags | 16U;
  } else {
    ctx->staging.flags = ctx->staging.flags & 4294967279U;
  }
  iwl_print_rx_config_cmd(priv, ctx->ctxid);
  ret = iwl_check_rxon_cmd(priv, ctx);
  if (ret != 0) {
    __iwl_err(priv->dev, 0, 0, "Invalid RXON configuration. Not committing.\n");
    return (-22);
  } else {

  }
  tmp___3 = constant_test_bit(11L, (unsigned long const volatile   *)(& priv->status));
  if (tmp___3 != 0 && (int )priv->switch_channel != (int )ctx->staging.channel) {
    __iwl_dbg(priv->dev, 268435456U, 0, "iwlagn_commit_rxon", "abort channel switch on %d\n",
              (int )priv->switch_channel);
    iwl_chswitch_done(priv, 0);
  } else {

  }
  tmp___4 = iwl_full_rxon_required(priv, ctx);
  if (tmp___4 == 0) {
    ret = iwlagn_send_rxon_assoc(priv, ctx);
    if (ret != 0) {
      __iwl_err(priv->dev, 0, 0, "Error setting RXON_ASSOC (%d)\n", ret);
      return (ret);
    } else {

    }
    memcpy((void *)active, (void const   *)(& ctx->staging), 50UL);
    iwl_set_tx_power(priv, (int )priv->tx_power_next, 0);
    iwl_power_update_mode(priv, 1);
    return (0);
  } else {

  }
  iwl_set_rxon_hwcrypto(priv, ctx, iwlwifi_mod_params.sw_crypto == 0);
  __iwl_dbg(priv->dev, 1U, 0, "iwlagn_commit_rxon", "Going to commit RXON\n  * with%s RXON_FILTER_ASSOC_MSK\n  * channel = %d\n  * bssid = %pM\n",
            (int )new_assoc ? (char *)"" : (char *)"out", (int )ctx->staging.channel,
            (u8 *)(& ctx->staging.bssid_addr));
  ret = iwlagn_rxon_disconn(priv, ctx);
  if (ret != 0) {
    return (ret);
  } else {

  }
  ret = iwlagn_set_pan_params(priv);
  if (ret != 0) {
    return (ret);
  } else {

  }
  if ((int )new_assoc) {
    tmp___5 = iwlagn_rxon_connect(priv, ctx);
    return (tmp___5);
  } else {

  }
  return (0);
}
}
void iwlagn_config_ht40(struct ieee80211_conf *conf , struct iwl_rxon_context *ctx ) 
{ 
  bool tmp ;
  bool tmp___0 ;

  {
  tmp___0 = conf_is_ht40_minus(conf);
  if ((int )tmp___0) {
    ctx->ht.extension_chan_offset = 3U;
    ctx->ht.is_40mhz = 1;
  } else {
    tmp = conf_is_ht40_plus(conf);
    if ((int )tmp) {
      ctx->ht.extension_chan_offset = 1U;
      ctx->ht.is_40mhz = 1;
    } else {
      ctx->ht.extension_chan_offset = 0U;
      ctx->ht.is_40mhz = 0;
    }
  }
  return;
}
}
int iwlagn_mac_config(struct ieee80211_hw *hw , u32 changed ) 
{ 
  struct iwl_priv *priv ;
  struct iwl_rxon_context *ctx ;
  struct ieee80211_conf *conf ;
  struct ieee80211_channel *channel ;
  int ret ;
  int tmp ;
  long tmp___0 ;
  int tmp___1 ;
  bool tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  priv = (struct iwl_priv *)(& ((struct iwl_op_mode *)hw->priv)->op_mode_specific);
  conf = & hw->conf;
  channel = conf->chandef.chan;
  ret = 0;
  __iwl_dbg(priv->dev, 2U, 0, "iwlagn_mac_config", "enter: changed %#x\n", changed);
  mutex_lock_nested(& priv->mutex, 0U);
  tmp = constant_test_bit(7L, (unsigned long const volatile   *)(& priv->status));
  tmp___0 = ldv__builtin_expect(tmp != 0, 0L);
  if (tmp___0 != 0L) {
    __iwl_dbg(priv->dev, 2U, 0, "iwlagn_mac_config", "leave - scanning\n");
    goto out;
  } else {

  }
  tmp___1 = iwl_is_ready(priv);
  if (tmp___1 == 0) {
    __iwl_dbg(priv->dev, 2U, 0, "iwlagn_mac_config", "leave - not ready\n");
    goto out;
  } else {

  }
  if ((changed & 66U) != 0U) {
    priv->current_ht_config.smps = conf->smps_mode;
    ctx = (struct iwl_rxon_context *)(& priv->contexts);
    goto ldv_53877;
    ldv_53876: ;
    if ((int )((unsigned long )priv->valid_contexts >> (int )ctx->ctxid) & 1) {
      iwlagn_set_rxon_chain(priv, ctx);
    } else {

    }
    ctx = ctx + 1;
    ldv_53877: ;
    if ((unsigned long )((struct iwl_rxon_context *)(& priv->contexts) + 2UL) > (unsigned long )ctx) {
      goto ldv_53876;
    } else {

    }

  } else {

  }
  if ((changed & 64U) != 0U) {
    ctx = (struct iwl_rxon_context *)(& priv->contexts);
    goto ldv_53880;
    ldv_53879: ;
    if ((int )((unsigned long )priv->valid_contexts >> (int )ctx->ctxid) & 1) {
      tmp___2 = conf_is_ht(conf);
      if ((int )ctx->ht.enabled != (int )tmp___2) {
        ctx->ht.enabled = conf_is_ht(conf);
      } else {

      }
      if ((int )ctx->ht.enabled) {
        if (! ctx->ht.is_40mhz) {
          iwlagn_config_ht40(conf, ctx);
        } else {
          tmp___3 = iwl_is_associated_ctx(ctx);
          if (tmp___3 == 0) {
            iwlagn_config_ht40(conf, ctx);
          } else {

          }
        }
      } else {
        ctx->ht.is_40mhz = 0;
      }
      ctx->ht.protection = 0U;
      if ((int )ctx->staging.channel != (int )channel->hw_value) {
        ctx->staging.flags = 0U;
      } else {

      }
      iwl_set_rxon_channel(priv, channel, ctx);
      iwl_set_rxon_ht(priv, & priv->current_ht_config);
      iwl_set_flags_for_band(priv, ctx, channel->band, ctx->vif);
    } else {

    }
    ctx = ctx + 1;
    ldv_53880: ;
    if ((unsigned long )((struct iwl_rxon_context *)(& priv->contexts) + 2UL) > (unsigned long )ctx) {
      goto ldv_53879;
    } else {

    }
    iwl_update_bcast_stations(priv);
  } else {

  }
  if ((changed & 272U) != 0U) {
    ret = iwl_power_update_mode(priv, 0);
    if (ret != 0) {
      __iwl_dbg(priv->dev, 2U, 0, "iwlagn_mac_config", "Error setting sleep level\n");
    } else {

    }
  } else {

  }
  if ((changed & 32U) != 0U) {
    __iwl_dbg(priv->dev, 2U, 0, "iwlagn_mac_config", "TX Power old=%d new=%d\n", (int )priv->tx_power_user_lmt,
              conf->power_level);
    iwl_set_tx_power(priv, (int )((s8 )conf->power_level), 0);
  } else {

  }
  ctx = (struct iwl_rxon_context *)(& priv->contexts);
  goto ldv_53884;
  ldv_53883: ;
  if ((int )((unsigned long )priv->valid_contexts >> (int )ctx->ctxid) & 1) {
    tmp___4 = memcmp((void const   *)(& ctx->staging), (void const   *)(& ctx->active),
                     50UL);
    if (tmp___4 == 0) {
      goto ldv_53882;
    } else {

    }
    iwlagn_commit_rxon(priv, ctx);
  } else {

  }
  ldv_53882: 
  ctx = ctx + 1;
  ldv_53884: ;
  if ((unsigned long )((struct iwl_rxon_context *)(& priv->contexts) + 2UL) > (unsigned long )ctx) {
    goto ldv_53883;
  } else {

  }

  out: 
  mutex_unlock(& priv->mutex);
  __iwl_dbg(priv->dev, 2U, 0, "iwlagn_mac_config", "leave\n");
  return (ret);
}
}
static void iwlagn_check_needed_chains(struct iwl_priv *priv , struct iwl_rxon_context *ctx ,
                                       struct ieee80211_bss_conf *bss_conf ) 
{ 
  struct ieee80211_vif *vif ;
  struct iwl_rxon_context *tmp ;
  struct ieee80211_sta *sta ;
  struct iwl_ht_config *ht_conf ;
  struct ieee80211_sta_ht_cap *ht_cap ;
  bool need_multiple ;
  int __ret_warn_on ;
  int tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;
  int maxstreams ;
    klee_make_symbolic(&maxstreams, sizeof(int), "maxstreams");

  {
  vif = ctx->vif;
  ht_conf = & priv->current_ht_config;
  if (debug_locks != 0) {
    tmp___0 = lock_is_held(& priv->mutex.dep_map);
    if (tmp___0 == 0) {
      tmp___1 = 1;
    } else {
      tmp___1 = 0;
    }
  } else {
    tmp___1 = 0;
  }
  __ret_warn_on = tmp___1;
  tmp___2 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp___2 != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/08_1a/drivers/net/wireless/iwlwifi/dvm/rxon.c",
                       1289);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  switch ((unsigned int )vif->type) {
  case 2U: 
  rcu_read_lock();
  sta = ieee80211_find_sta(vif, bss_conf->bssid);
  if ((unsigned long )sta == (unsigned long )((struct ieee80211_sta *)0)) {
    need_multiple = 0;
    rcu_read_unlock();
    goto ldv_53900;
  } else {

  }
  ht_cap = & sta->ht_cap;
  need_multiple = 1;
  if ((unsigned int )ht_cap->mcs.rx_mask[1] == 0U && (unsigned int )ht_cap->mcs.rx_mask[2] == 0U) {
    need_multiple = 0;
  } else
  if (((int )ht_cap->mcs.tx_params & 1) == 0) {
    need_multiple = 0;
  } else
  if (((int )ht_cap->mcs.tx_params & 2) != 0) {
    maxstreams = (int )ht_cap->mcs.tx_params & 12;
    maxstreams = maxstreams >> 2;
    maxstreams = maxstreams + 1;
    if (maxstreams <= 1) {
      need_multiple = 0;
    } else {

    }
  } else {

  }
  rcu_read_unlock();
  goto ldv_53900;
  case 1U: 
  need_multiple = 0;
  goto ldv_53900;
  default: 
  need_multiple = 1;
  goto ldv_53900;
  }
  ldv_53900: 
  ctx->ht_need_multiple_chains = need_multiple;
  if (! need_multiple) {
    tmp = (struct iwl_rxon_context *)(& priv->contexts);
    goto ldv_53907;
    ldv_53906: ;
    if ((int )((unsigned long )priv->valid_contexts >> (int )tmp->ctxid) & 1) {
      if ((unsigned long )tmp->vif == (unsigned long )((struct ieee80211_vif *)0)) {
        goto ldv_53904;
      } else {

      }
      if ((int )tmp->ht_need_multiple_chains) {
        need_multiple = 1;
        goto ldv_53905;
      } else {

      }
    } else {

    }
    ldv_53904: 
    tmp = tmp + 1;
    ldv_53907: ;
    if ((unsigned long )((struct iwl_rxon_context *)(& priv->contexts) + 2UL) > (unsigned long )tmp) {
      goto ldv_53906;
    } else {

    }
    ldv_53905: ;
  } else {

  }
  ht_conf->single_chain_sufficient = (bool )(! ((int )need_multiple != 0));
  return;
}
}
static void iwlagn_chain_noise_reset(struct iwl_priv *priv ) 
{ 
  struct iwl_chain_noise_data *data ;
  int ret ;
  struct iwl_calib_chain_noise_reset_cmd cmd ;
  int tmp ;

  {
  data = & priv->chain_noise_data;
  if ((priv->calib_disabled & 2U) != 0U) {
    return;
  } else {

  }
  if ((unsigned int )data->state == 0U) {
    tmp = iwl_is_any_associated___2(priv);
    if (tmp != 0) {
      data->chain_noise_a = 0U;
      data->chain_noise_b = 0U;
      data->chain_noise_c = 0U;
      data->chain_signal_a = 0U;
      data->chain_signal_b = 0U;
      data->chain_signal_c = 0U;
      data->beacon_count = 0U;
      memset((void *)(& cmd), 0, 4UL);
      iwl_set_calib_hdr(& cmd.hdr, (int )priv->phy_calib_chain_noise_reset_cmd);
      ret = iwl_dvm_send_cmd_pdu(priv, 176, 0U, 4, (void const   *)(& cmd));
      if (ret != 0) {
        __iwl_err(priv->dev, 0, 0, "Could not send REPLY_PHY_CALIBRATION_CMD\n");
      } else {

      }
      data->state = 1U;
      __iwl_dbg(priv->dev, 2097152U, 0, "iwlagn_chain_noise_reset", "Run chain_noise_calibrate\n");
    } else {

    }
  } else {

  }
  return;
}
}
void iwlagn_bss_info_changed(struct ieee80211_hw *hw , struct ieee80211_vif *vif ,
                             struct ieee80211_bss_conf *bss_conf , u32 changes ) 
{ 
  struct iwl_priv *priv ;
  struct iwl_rxon_context *ctx ;
  struct iwl_rxon_context *tmp ;
  int ret ;
  bool force ;
  int tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  priv = (struct iwl_priv *)(& ((struct iwl_op_mode *)hw->priv)->op_mode_specific);
  tmp = iwl_rxon_ctx_from_vif(vif);
  ctx = tmp;
  force = 0;
  mutex_lock_nested(& priv->mutex, 0U);
  if ((changes & 16384U) != 0U && (int )bss_conf->idle) {
    iwlagn_lift_passive_no_rx(priv);
  } else {

  }
  tmp___0 = iwl_is_ready(priv);
  tmp___1 = ldv__builtin_expect(tmp___0 == 0, 0L);
  if (tmp___1 != 0L) {
    __iwl_dbg(priv->dev, 2U, 0, "iwlagn_bss_info_changed", "leave - not ready\n");
    mutex_unlock(& priv->mutex);
    return;
  } else {

  }
  tmp___2 = ldv__builtin_expect((unsigned long )ctx->vif == (unsigned long )((struct ieee80211_vif *)0),
                             0L);
  if (tmp___2 != 0L) {
    __iwl_dbg(priv->dev, 2U, 0, "iwlagn_bss_info_changed", "leave - vif is NULL\n");
    mutex_unlock(& priv->mutex);
    return;
  } else {

  }
  if ((changes & 64U) != 0U) {
    force = 1;
  } else {

  }
  if ((changes & 8192U) != 0U) {
    ctx->qos_data.qos_active = (int )bss_conf->qos;
    iwlagn_update_qos(priv, ctx);
  } else {

  }
  ctx->staging.assoc_id = vif->bss_conf.aid;
  if ((int )vif->bss_conf.use_short_preamble) {
    ctx->staging.flags = ctx->staging.flags | 32U;
  } else {
    ctx->staging.flags = ctx->staging.flags & 4294967263U;
  }
  if ((int )changes & 1) {
    if ((int )bss_conf->assoc) {
      priv->timestamp = bss_conf->sync_tsf;
      ctx->staging.filter_flags = ctx->staging.filter_flags | 32U;
    } else {
      ctx->staging.filter_flags = ctx->staging.filter_flags & 4294967263U;
      if ((unsigned int )ctx->ctxid == 0U) {
        priv->have_rekey_data = 0;
      } else {

      }
    }
    iwlagn_bt_coex_rssi_monitor(priv);
  } else {

  }
  if ((int )ctx->ht.enabled) {
    ctx->ht.protection = (unsigned int )((u8 )bss_conf->ht_operation_mode) & 3U;
    ctx->ht.non_gf_sta_present = ((int )bss_conf->ht_operation_mode & 4) != 0;
    iwlagn_check_needed_chains(priv, ctx, bss_conf);
    iwl_set_rxon_ht(priv, & priv->current_ht_config);
  } else {

  }
  iwlagn_set_rxon_chain(priv, ctx);
  if ((int )bss_conf->use_cts_prot && (unsigned int )priv->band != 1U) {
    ctx->staging.flags = ctx->staging.flags | 8U;
  } else {
    ctx->staging.flags = ctx->staging.flags & 4294967287U;
  }
  if ((int )bss_conf->use_cts_prot) {
    ctx->staging.flags = ctx->staging.flags | 1073741824U;
  } else {
    ctx->staging.flags = ctx->staging.flags & 3221225471U;
  }
  memcpy((void *)(& ctx->staging.bssid_addr), (void const   *)bss_conf->bssid, 6UL);
  if ((unsigned int )vif->type == 3U || (unsigned int )vif->type == 1U) {
    if ((int )vif->bss_conf.enable_beacon) {
      ctx->staging.filter_flags = ctx->staging.filter_flags | 32U;
      priv->beacon_ctx = ctx;
    } else {
      ctx->staging.filter_flags = ctx->staging.filter_flags & 4294967263U;
      priv->beacon_ctx = (struct iwl_rxon_context *)0;
    }
  } else {

  }
  if ((unsigned int )vif->type == 2U) {
    if (! bss_conf->assoc) {
      ctx->staging.filter_flags = ctx->staging.filter_flags | 64U;
    } else {
      ctx->staging.filter_flags = ctx->staging.filter_flags & 4294967231U;
    }
  } else {

  }
  if ((int )force) {
    iwlagn_commit_rxon(priv, ctx);
  } else {
    tmp___3 = memcmp((void const   *)(& ctx->staging), (void const   *)(& ctx->active),
                     50UL);
    if (tmp___3 != 0) {
      iwlagn_commit_rxon(priv, ctx);
    } else {

    }
  }
  if ((int )changes & 1 && (int )bss_conf->assoc) {
    if ((unsigned int )priv->chain_noise_data.state == 3U) {
      iwl_power_update_mode(priv, 0);
    } else {

    }
    iwlagn_chain_noise_reset(priv);
    priv->start_calib = 1U;
  } else {

  }
  if ((changes & 2048U) != 0U) {
    ret = iwlagn_manage_ibss_station(priv, vif, (int )bss_conf->ibss_joined);
    if (ret != 0) {
      __iwl_err(priv->dev, 0, 0, "failed to %s IBSS station %pM\n", (int )bss_conf->ibss_joined ? (char *)"add" : (char *)"remove",
                bss_conf->bssid);
    } else {

    }
  } else {

  }
  if ((changes & 256U) != 0U && (unsigned long )priv->beacon_ctx == (unsigned long )ctx) {
    tmp___4 = iwlagn_update_beacon(priv, vif);
    if (tmp___4 != 0) {
      __iwl_err(priv->dev, 0, 0, "Error updating beacon\n");
    } else {

    }
  } else {

  }
  mutex_unlock(& priv->mutex);
  return;
}
}
void iwlagn_post_scan(struct iwl_priv *priv ) 
{ 
  struct iwl_rxon_context *ctx ;
  int tmp ;

  {
  iwl_power_set_mode(priv, & priv->power_data.sleep_cmd_next, 0);
  iwl_set_tx_power(priv, (int )priv->tx_power_next, 0);
  ctx = (struct iwl_rxon_context *)(& priv->contexts);
  goto ldv_53931;
  ldv_53930: ;
  if ((int )((unsigned long )priv->valid_contexts >> (int )ctx->ctxid) & 1) {
    tmp = memcmp((void const   *)(& ctx->staging), (void const   *)(& ctx->active),
                 50UL);
    if (tmp != 0) {
      iwlagn_commit_rxon(priv, ctx);
    } else {

    }
  } else {

  }
  ctx = ctx + 1;
  ldv_53931: ;
  if ((unsigned long )((struct iwl_rxon_context *)(& priv->contexts) + 2UL) > (unsigned long )ctx) {
    goto ldv_53930;
  } else {

  }
  iwlagn_set_pan_params(priv);
  return;
}
}
bool ldv_queue_work_on_241(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_7(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_delayed_work_on_242(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_7(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_work_on_243(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_7(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
void ldv_flush_workqueue_244(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
  flush_workqueue(ldv_func_arg1);
  call_and_disable_all_7(2);
  return;
}
}
bool ldv_queue_delayed_work_on_245(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_7(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
__inline static long ldv__builtin_expect(long exp , long c ) ;
__inline static unsigned long arch_local_save_flags___3(void) 
{ 
  unsigned long __ret ;
  unsigned long __edi ;
  unsigned long __esi ;
  unsigned long __edx ;
  unsigned long __ecx ;
  unsigned long __eax ;
  long tmp ;

  {
  __edi = __edi;
  __esi = __esi;
  __edx = __edx;
  __ecx = __ecx;
  __eax = __eax;
  tmp = ldv__builtin_expect((unsigned long )pv_irq_ops.save_fl.func == (unsigned long )((void *)0),
                         0L);
  if (tmp != 0L) {
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"./arch/x86/include/asm/paravirt.h"),
                         "i" (831), "i" (12UL));
    ldv_4860: ;
    goto ldv_4860;
  } else {

  }
  __asm__  volatile   ("771:\n\tcall *%c2;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c1\n  .byte 772b-771b\n  .short %c3\n.popsection\n": "=a" (__eax): [paravirt_typenum] "i" (43UL),
                       [paravirt_opptr] "i" (& pv_irq_ops.save_fl.func), [paravirt_clobber] "i" (1): "memory",
                       "cc");
  __ret = __eax;
  return (__ret);
}
}
__inline static bool static_key_false___3(struct static_key *key ) 
{ 
  int tmp ;
  long tmp___0 ;

  {
  tmp = static_key_count(key);
  tmp___0 = ldv__builtin_expect(tmp > 0, 0L);
  if (tmp___0 != 0L) {
    return (1);
  } else {

  }
  return (0);
}
}
__inline static int rcu_read_lock_sched_held___3(void) 
{ 
  int lockdep_opinion ;
  int tmp ;
  bool tmp___0 ;
  int tmp___1 ;
  bool tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  unsigned long _flags ;
  int tmp___5 ;
  int tmp___6 ;

  {
  lockdep_opinion = 0;
  tmp = debug_lockdep_rcu_enabled();
  if (tmp == 0) {
    return (1);
  } else {

  }
  tmp___0 = rcu_is_watching();
  if (tmp___0) {
    tmp___1 = 0;
  } else {
    tmp___1 = 1;
  }
  if (tmp___1) {
    return (0);
  } else {

  }
  tmp___2 = rcu_lockdep_current_cpu_online();
  if (tmp___2) {
    tmp___3 = 0;
  } else {
    tmp___3 = 1;
  }
  if (tmp___3) {
    return (0);
  } else {

  }
  if (debug_locks != 0) {
    lockdep_opinion = lock_is_held(& rcu_sched_lock_map);
  } else {

  }
  if (lockdep_opinion != 0) {
    tmp___6 = 1;
  } else {
    tmp___4 = preempt_count();
    if (tmp___4 != 0) {
      tmp___6 = 1;
    } else {
      _flags = arch_local_save_flags___3();
      tmp___5 = arch_irqs_disabled_flags(_flags);
      if (tmp___5 != 0) {
        tmp___6 = 1;
      } else {
        tmp___6 = 0;
      }
    }
  }
  return (tmp___6);
}
}
bool ldv_queue_work_on_255(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_work_on_257(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_delayed_work_on_256(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
bool ldv_queue_delayed_work_on_259(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
void ldv_flush_workqueue_258(struct workqueue_struct *ldv_func_arg1 ) ;
__inline static void trace_iwlwifi_dev_iowrite32___3(struct device  const  *dev ,
                                                     u32 offs , u32 val ) 
{ 
  struct tracepoint_func *it_func_ptr ;
  void *it_func ;
  void *__data ;
  struct tracepoint_func *________p1 ;
  struct tracepoint_func *_________p1 ;
  union __anonunion___u_394___0 __u ;
  bool __warned ;
  int tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  struct tracepoint_func *________p1___0 ;
  struct tracepoint_func *_________p1___0 ;
  union __anonunion___u_396___0 __u___0 ;
  bool __warned___0 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  tmp___1 = static_key_false___3(& __tracepoint_iwlwifi_dev_iowrite32.key);
  if ((int )tmp___1) {
    rcu_read_lock_sched_notrace();
    __read_once_size((void const volatile   *)(& __tracepoint_iwlwifi_dev_iowrite32.funcs),
                     (void *)(& __u.__c), 8);
    _________p1 = __u.__val;
    ________p1 = _________p1;
    tmp = debug_lockdep_rcu_enabled();
    if (tmp != 0 && ! __warned) {
      tmp___0 = rcu_read_lock_sched_held___3();
      if (tmp___0 == 0) {
        __warned = 1;
        lockdep_rcu_suspicious("drivers/net/wireless/iwlwifi/dvm/../iwl-devtrace-io.h",
                               84, "suspicious rcu_dereference_check() usage");
      } else {

      }
    } else {

    }
    it_func_ptr = ________p1;
    if ((unsigned long )it_func_ptr != (unsigned long )((struct tracepoint_func *)0)) {
      ldv_51204: 
      it_func = it_func_ptr->func;
      __data = it_func_ptr->data;
      (*((void (*)(void * , struct device  const  * , u32  , u32  ))it_func))(__data,
                                                                              dev,
                                                                              offs,
                                                                              val);
      it_func_ptr = it_func_ptr + 1;
      if ((unsigned long )it_func_ptr->func != (unsigned long )((void *)0)) {
        goto ldv_51204;
      } else {

      }

    } else {

    }
    rcu_read_unlock_sched_notrace();
  } else {

  }
  rcu_read_lock_sched_notrace();
  __read_once_size((void const volatile   *)(& __tracepoint_iwlwifi_dev_iowrite32.funcs),
                   (void *)(& __u___0.__c), 8);
  _________p1___0 = __u___0.__val;
  ________p1___0 = _________p1___0;
  tmp___2 = debug_lockdep_rcu_enabled();
  if (tmp___2 != 0 && ! __warned___0) {
    tmp___3 = rcu_read_lock_sched_held___3();
    if (tmp___3 == 0) {
      __warned___0 = 1;
      lockdep_rcu_suspicious("drivers/net/wireless/iwlwifi/dvm/../iwl-devtrace-io.h",
                             84, "suspicious rcu_dereference_check() usage");
    } else {

    }
  } else {

  }
  rcu_read_unlock_sched_notrace();
  return;
}
}
__inline static void iwl_write32___3(struct iwl_trans *trans , u32 ofs , u32 val ) 
{ 


  {
  trace_iwlwifi_dev_iowrite32___3((struct device  const  *)trans->dev, ofs, val);
  iwl_trans_write32(trans, ofs, val);
  return;
}
}
static void iwl1000_set_ct_threshold(struct iwl_priv *priv ) 
{ 


  {
  priv->hw_params.ct_kill_threshold = 110U;
  priv->hw_params.ct_kill_exit_threshold = 95U;
  return;
}
}
static void iwl1000_nic_config(struct iwl_priv *priv ) 
{ 


  {
  iwl_set_bits_mask_prph(priv->trans, 12376U, 96U, 4294966815U);
  return;
}
}
__inline static u32 iwl_beacon_time_mask_low(struct iwl_priv *priv , u16 tsf_bits ) 
{ 


  {
  return ((u32 )((1 << (int )tsf_bits) + -1));
}
}
__inline static u32 iwl_beacon_time_mask_high(struct iwl_priv *priv , u16 tsf_bits ) 
{ 


  {
  return ((u32 )(((1 << (32 - (int )tsf_bits)) + -1) << (int )tsf_bits));
}
}
static u32 iwl_usecs_to_beacons(struct iwl_priv *priv , u32 usec , u32 beacon_interval ) 
{ 
  u32 quot ;
  u32 rem ;
  u32 interval ;
  u32 tmp ;
  u32 tmp___0 ;

  {
  interval = beacon_interval * 1024U;
  if (interval == 0U || usec == 0U) {
    return (0U);
  } else {

  }
  tmp = iwl_beacon_time_mask_high(priv, 22);
  quot = usec / interval & (tmp >> 22);
  tmp___0 = iwl_beacon_time_mask_low(priv, 22);
  rem = usec % interval & tmp___0;
  return ((quot << 22) + rem);
}
}
static __le32 iwl_add_beacon_time(struct iwl_priv *priv , u32 base , u32 addon , u32 beacon_interval ) 
{ 
  u32 base_low ;
  u32 tmp ;
  u32 addon_low ;
  u32 tmp___0 ;
  u32 interval ;
  u32 res ;
  u32 tmp___1 ;
  u32 tmp___2 ;

  {
  tmp = iwl_beacon_time_mask_low(priv, 22);
  base_low = tmp & base;
  tmp___0 = iwl_beacon_time_mask_low(priv, 22);
  addon_low = tmp___0 & addon;
  interval = beacon_interval * 1024U;
  tmp___1 = iwl_beacon_time_mask_high(priv, 22);
  tmp___2 = iwl_beacon_time_mask_high(priv, 22);
  res = (tmp___1 & base) + (tmp___2 & addon);
  if (base_low > addon_low) {
    res = (base_low - addon_low) + res;
  } else
  if (base_low < addon_low) {
    res = ((interval + base_low) - addon_low) + res;
    res = res + 4194304U;
  } else {
    res = res + 4194304U;
  }
  return (res);
}
}
static struct iwl_sensitivity_ranges  const  iwl1000_sensitivity  = 
     {95U, 95U, 95U, 90U, 170U, 120U, 240U, 120U, 210U, 155U, 290U, 200U, 400U, 125U,
    170U, 190U, 390U, 62U};
static void iwl1000_hw_set_hw_params(struct iwl_priv *priv ) 
{ 


  {
  iwl1000_set_ct_threshold(priv);
  priv->hw_params.sens = & iwl1000_sensitivity;
  return;
}
}
struct iwl_dvm_cfg  const  iwl_dvm_1000_cfg  = 
     {& iwl1000_hw_set_hw_params, 0, & iwl1000_nic_config, & iwlagn_temperature, 0,
    1000, 200U, (_Bool)0, 1, (_Bool)0, (_Bool)0, (_Bool)0, (_Bool)0, (_Bool)0, (_Bool)0};
static void iwl2000_set_ct_threshold(struct iwl_priv *priv ) 
{ 


  {
  priv->hw_params.ct_kill_threshold = 114U;
  priv->hw_params.ct_kill_exit_threshold = 95U;
  return;
}
}
static void iwl2000_nic_config(struct iwl_priv *priv ) 
{ 


  {
  iwl_set_bit(priv->trans, 80U, 128U);
  return;
}
}
static struct iwl_sensitivity_ranges  const  iwl2000_sensitivity  = 
     {97U, 97U, 100U, 80U, 128U, 105U, 192U, 145U, 232U, 110U, 232U, 175U, 310U, 125U,
    160U, 190U, 390U, 62U};
static void iwl2000_hw_set_hw_params(struct iwl_priv *priv ) 
{ 


  {
  iwl2000_set_ct_threshold(priv);
  priv->hw_params.sens = & iwl2000_sensitivity;
  return;
}
}
struct iwl_dvm_cfg  const  iwl_dvm_2000_cfg  = 
     {& iwl2000_hw_set_hw_params, 0, & iwl2000_nic_config, & iwlagn_temperature, 0,
    1000, 50U, 1, 1, 1, (_Bool)0, 1, (_Bool)0, 1, (_Bool)0};
struct iwl_dvm_cfg  const  iwl_dvm_105_cfg  = 
     {& iwl2000_hw_set_hw_params, 0, & iwl2000_nic_config, & iwlagn_temperature, 0,
    1000, 50U, 1, 1, 1, (_Bool)0, 1, (_Bool)0, 1, 1};
static struct iwl_dvm_bt_params  const  iwl2030_bt_params  =    {1, 0U, 4042322160U, 1200U, 1, 1};
struct iwl_dvm_cfg  const  iwl_dvm_2030_cfg  = 
     {& iwl2000_hw_set_hw_params, 0, & iwl2000_nic_config, & iwlagn_temperature, & iwl2030_bt_params,
    1000, 50U, 1, 1, 1, (_Bool)0, 1, (_Bool)0, 1, 1};
static struct iwl_sensitivity_ranges  const  iwl5000_sensitivity  = 
     {100U, 100U, 100U, 90U, 170U, 105U, 220U, 120U, 210U, 120U, 240U, 200U, 400U, 125U,
    200U, 190U, 390U, 62U};
static struct iwl_sensitivity_ranges  const  iwl5150_sensitivity  = 
     {95U, 95U, 95U, 90U, 170U, 105U, 220U, 120U, 210U, 105U, 220U, 200U, 400U, 125U,
    170U, 190U, 390U, 62U};
static s32 iwl_temp_calib_to_offset(struct iwl_priv *priv ) 
{ 
  u16 temperature ;
  u16 voltage ;

  {
  temperature = (priv->nvm_data)->kelvin_temperature;
  voltage = (priv->nvm_data)->kelvin_voltage;
  return ((int )temperature - (int )voltage / -5);
}
}
static void iwl5150_set_ct_threshold(struct iwl_priv *priv ) 
{ 
  s32 volt2temp_coef ;
  s32 threshold ;
  s32 tmp ;

  {
  volt2temp_coef = -5;
  tmp = iwl_temp_calib_to_offset(priv);
  threshold = 383 - tmp;
  priv->hw_params.ct_kill_threshold = (u32 )(threshold * volt2temp_coef);
  return;
}
}
static void iwl5000_set_ct_threshold(struct iwl_priv *priv ) 
{ 


  {
  priv->hw_params.ct_kill_threshold = 110U;
  return;
}
}
static void iwl5000_hw_set_hw_params(struct iwl_priv *priv ) 
{ 


  {
  iwl5000_set_ct_threshold(priv);
  priv->hw_params.sens = & iwl5000_sensitivity;
  return;
}
}
static void iwl5150_hw_set_hw_params(struct iwl_priv *priv ) 
{ 


  {
  iwl5150_set_ct_threshold(priv);
  priv->hw_params.sens = & iwl5150_sensitivity;
  return;
}
}
static void iwl5150_temperature(struct iwl_priv *priv ) 
{ 
  u32 vt ;
  s32 offset ;
  s32 tmp ;

  {
  vt = 0U;
  tmp = iwl_temp_calib_to_offset(priv);
  offset = tmp;
  vt = priv->statistics.common.temperature;
  vt = vt / 4294967291U + (u32 )offset;
  priv->temperature = (s32 )(vt - 273U);
  iwl_tt_handler(priv);
  return;
}
}
static int iwl5000_hw_channel_switch(struct iwl_priv *priv , struct ieee80211_channel_switch *ch_switch ) 
{ 
  struct iwl_rxon_context *ctx ;
  struct iwl5000_channel_switch_cmd cmd ;
  u32 switch_time_in_usec ;
  u32 ucode_switch_time ;
  u16 ch ;
  u32 tsf_low ;
  u8 switch_count ;
  u16 beacon_interval ;
  struct ieee80211_vif *vif ;
  struct iwl_host_cmd hcmd ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  int tmp___1 ;

  {
  ctx = (struct iwl_rxon_context *)(& priv->contexts);
  beacon_interval = ctx->timing.beacon_interval;
  vif = ctx->vif;
  hcmd.data[0] = (void const   *)(& cmd);
  tmp = 1U;
  while (1) {
    if (tmp >= 2U) {
      break;
    } else {

    }
    hcmd.data[tmp] = 0;
    tmp = tmp + 1U;
  }
  hcmd.resp_pkt = 0;
  hcmd._rx_page_addr = 0UL;
  hcmd._rx_page_order = 0U;
  hcmd.handler_status = 0;
  hcmd.flags = 0U;
  hcmd.len[0] = 224U;
  tmp___0 = 1U;
  while (1) {
    if (tmp___0 >= 2U) {
      break;
    } else {

    }
    hcmd.len[tmp___0] = (unsigned short)0;
    tmp___0 = tmp___0 + 1U;
  }
  hcmd.dataflags[0] = (unsigned char)0;
  hcmd.dataflags[1] = (unsigned char)0;
  hcmd.id = 114U;
  cmd.band = (unsigned int )priv->band == 0U;
  ch = (ch_switch->chandef.chan)->hw_value;
  __iwl_dbg(priv->dev, 268435456U, 0, "iwl5000_hw_channel_switch", "channel switch from %d to %d\n",
            (int )ctx->active.channel, (int )ch);
  cmd.channel = ch;
  cmd.rxon_flags = ctx->staging.flags;
  cmd.rxon_filter_flags = ctx->staging.filter_flags;
  switch_count = ch_switch->count;
  tsf_low = (u32 )ch_switch->timestamp;
  if (priv->ucode_beacon_time > tsf_low && (unsigned int )beacon_interval != 0U) {
    if ((u32 )switch_count > (priv->ucode_beacon_time - tsf_low) / (u32 )beacon_interval) {
      switch_count = (int )switch_count - (int )((u8 )((priv->ucode_beacon_time - tsf_low) / (u32 )beacon_interval));
    } else {
      switch_count = 0U;
    }
  } else {

  }
  if ((unsigned int )switch_count <= 1U) {
    cmd.switch_time = priv->ucode_beacon_time;
  } else {
    switch_time_in_usec = (u32 )(((int )vif->bss_conf.beacon_int * (int )switch_count) * 1024);
    ucode_switch_time = iwl_usecs_to_beacons(priv, switch_time_in_usec, (u32 )beacon_interval);
    cmd.switch_time = iwl_add_beacon_time(priv, priv->ucode_beacon_time, ucode_switch_time,
                                          (u32 )beacon_interval);
  }
  __iwl_dbg(priv->dev, 268435456U, 0, "iwl5000_hw_channel_switch", "uCode time for the switch is 0x%x\n",
            cmd.switch_time);
  cmd.expect_beacon = (unsigned int )((u8 )(ch_switch->chandef.chan)->flags) & 8U;
  tmp___1 = iwl_dvm_send_cmd(priv, & hcmd);
  return (tmp___1);
}
}
struct iwl_dvm_cfg  const  iwl_dvm_5000_cfg  = 
     {& iwl5000_hw_set_hw_params, & iwl5000_hw_channel_switch, 0, & iwlagn_temperature,
    0, 1000, 100U, (_Bool)0, (_Bool)0, (_Bool)0, 1, (_Bool)0, (_Bool)0, (_Bool)0,
    (_Bool)0};
struct iwl_dvm_cfg  const  iwl_dvm_5150_cfg  = 
     {& iwl5150_hw_set_hw_params, & iwl5000_hw_channel_switch, 0, & iwl5150_temperature,
    0, 1000, 100U, (_Bool)0, (_Bool)0, (_Bool)0, 1, (_Bool)0, 1, (_Bool)0, (_Bool)0};
static void iwl6000_set_ct_threshold(struct iwl_priv *priv ) 
{ 


  {
  priv->hw_params.ct_kill_threshold = 114U;
  priv->hw_params.ct_kill_exit_threshold = 95U;
  return;
}
}
static void iwl6000_nic_config(struct iwl_priv *priv ) 
{ 
  int __ret_warn_on ;
  long tmp ;

  {
  switch ((unsigned int )(priv->cfg)->device_family) {
  case 11U: ;
  case 12U: ;
  case 9U: ;
  goto ldv_55101;
  case 10U: 
  iwl_write32___3(priv->trans, 80U, 2U);
  goto ldv_55101;
  case 13U: ;
  if ((unsigned int )(priv->nvm_data)->calib_version > 5U) {
    iwl_set_bit(priv->trans, 80U, 4U);
  } else {

  }
  goto ldv_55101;
  case 14U: ;
  if ((unsigned int )(priv->nvm_data)->calib_version > 5U) {
    iwl_set_bit(priv->trans, 80U, 4U);
  } else {

  }
  iwl_set_bit(priv->trans, 80U, 8U);
  goto ldv_55101;
  default: 
  __ret_warn_on = 1;
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/08_1a/drivers/net/wireless/iwlwifi/dvm/devices.c",
                       526);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  }
  ldv_55101: ;
  return;
}
}
static struct iwl_sensitivity_ranges  const  iwl6000_sensitivity  = 
     {110U, 110U, 110U, 80U, 128U, 105U, 192U, 145U, 232U, 110U, 232U, 175U, 310U, 125U,
    160U, 190U, 336U, 62U};
static void iwl6000_hw_set_hw_params(struct iwl_priv *priv ) 
{ 


  {
  iwl6000_set_ct_threshold(priv);
  priv->hw_params.sens = & iwl6000_sensitivity;
  return;
}
}
static int iwl6000_hw_channel_switch(struct iwl_priv *priv , struct ieee80211_channel_switch *ch_switch ) 
{ 
  struct iwl_rxon_context *ctx ;
  struct iwl6000_channel_switch_cmd *cmd ;
  u32 switch_time_in_usec ;
  u32 ucode_switch_time ;
  u16 ch ;
  u32 tsf_low ;
  u8 switch_count ;
  u16 beacon_interval ;
  struct ieee80211_vif *vif ;
  struct iwl_host_cmd hcmd ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  int err ;
  void *tmp___1 ;

  {
  ctx = (struct iwl_rxon_context *)(& priv->contexts);
  beacon_interval = ctx->timing.beacon_interval;
  vif = ctx->vif;
  hcmd.data[0] = 0;
  hcmd.data[1] = 0;
  hcmd.resp_pkt = 0;
  hcmd._rx_page_addr = 0UL;
  hcmd._rx_page_order = 0U;
  hcmd.handler_status = 0;
  hcmd.flags = 0U;
  hcmd.len[0] = 328U;
  tmp = 1U;
  while (1) {
    if (tmp >= 2U) {
      break;
    } else {

    }
    hcmd.len[tmp] = (unsigned short)0;
    tmp = tmp + 1U;
  }
  hcmd.dataflags[0] = 1U;
  tmp___0 = 1U;
  while (1) {
    if (tmp___0 >= 2U) {
      break;
    } else {

    }
    hcmd.dataflags[tmp___0] = (unsigned char)0;
    tmp___0 = tmp___0 + 1U;
  }
  hcmd.id = 114U;
  tmp___1 = kzalloc(328UL, 208U);
  cmd = (struct iwl6000_channel_switch_cmd *)tmp___1;
  if ((unsigned long )cmd == (unsigned long )((struct iwl6000_channel_switch_cmd *)0)) {
    return (-12);
  } else {

  }
  hcmd.data[0] = (void const   *)cmd;
  cmd->band = (unsigned int )priv->band == 0U;
  ch = (ch_switch->chandef.chan)->hw_value;
  __iwl_dbg(priv->dev, 268435456U, 0, "iwl6000_hw_channel_switch", "channel switch from %u to %u\n",
            (int )ctx->active.channel, (int )ch);
  cmd->channel = ch;
  cmd->rxon_flags = ctx->staging.flags;
  cmd->rxon_filter_flags = ctx->staging.filter_flags;
  switch_count = ch_switch->count;
  tsf_low = (u32 )ch_switch->timestamp;
  if (priv->ucode_beacon_time > tsf_low && (unsigned int )beacon_interval != 0U) {
    if ((u32 )switch_count > (priv->ucode_beacon_time - tsf_low) / (u32 )beacon_interval) {
      switch_count = (int )switch_count - (int )((u8 )((priv->ucode_beacon_time - tsf_low) / (u32 )beacon_interval));
    } else {
      switch_count = 0U;
    }
  } else {

  }
  if ((unsigned int )switch_count <= 1U) {
    cmd->switch_time = priv->ucode_beacon_time;
  } else {
    switch_time_in_usec = (u32 )(((int )vif->bss_conf.beacon_int * (int )switch_count) * 1024);
    ucode_switch_time = iwl_usecs_to_beacons(priv, switch_time_in_usec, (u32 )beacon_interval);
    cmd->switch_time = iwl_add_beacon_time(priv, priv->ucode_beacon_time, ucode_switch_time,
                                           (u32 )beacon_interval);
  }
  __iwl_dbg(priv->dev, 268435456U, 0, "iwl6000_hw_channel_switch", "uCode time for the switch is 0x%x\n",
            cmd->switch_time);
  cmd->expect_beacon = (unsigned int )((u8 )(ch_switch->chandef.chan)->flags) & 8U;
  err = iwl_dvm_send_cmd(priv, & hcmd);
  kfree((void const   *)cmd);
  return (err);
}
}
struct iwl_dvm_cfg  const  iwl_dvm_6000_cfg  = 
     {& iwl6000_hw_set_hw_params, & iwl6000_hw_channel_switch, & iwl6000_nic_config,
    & iwlagn_temperature, 0, 1000, 50U, 1, 1, (_Bool)0, (_Bool)0, (_Bool)0, (_Bool)0,
    (_Bool)0, (_Bool)0};
struct iwl_dvm_cfg  const  iwl_dvm_6005_cfg  = 
     {& iwl6000_hw_set_hw_params, & iwl6000_hw_channel_switch, & iwl6000_nic_config,
    & iwlagn_temperature, 0, 1000, 50U, 1, 1, (_Bool)0, (_Bool)0, 1, (_Bool)0, (_Bool)0,
    (_Bool)0};
struct iwl_dvm_cfg  const  iwl_dvm_6050_cfg  = 
     {& iwl6000_hw_set_hw_params, & iwl6000_hw_channel_switch, & iwl6000_nic_config,
    & iwlagn_temperature, 0, 1500, 50U, 1, 1, (_Bool)0, (_Bool)0, (_Bool)0, (_Bool)0,
    (_Bool)0, (_Bool)0};
static struct iwl_dvm_bt_params  const  iwl6000_bt_params  =    {1, 0U, 240U, 1200U, 1, (_Bool)0};
struct iwl_dvm_cfg  const  iwl_dvm_6030_cfg  = 
     {& iwl6000_hw_set_hw_params, & iwl6000_hw_channel_switch, & iwl6000_nic_config,
    & iwlagn_temperature, & iwl6000_bt_params, 1000, 50U, 1, 1, (_Bool)0, (_Bool)0,
    1, (_Bool)0, (_Bool)0, 1};
void ldv_initialize_iwl_dvm_cfg_62(void) 
{ 
  void *tmp ;

  {
  tmp = ldv_init_zalloc(14448UL);
  iwl_dvm_2000_cfg_group0 = (struct iwl_priv *)tmp;
  return;
}
}
void ldv_initialize_iwl_dvm_cfg_63(void) 
{ 
  void *tmp ;

  {
  tmp = ldv_init_zalloc(14448UL);
  iwl_dvm_1000_cfg_group0 = (struct iwl_priv *)tmp;
  return;
}
}
void ldv_initialize_iwl_dvm_cfg_56(void) 
{ 
  void *tmp ;

  {
  tmp = ldv_init_zalloc(14448UL);
  iwl_dvm_6005_cfg_group0 = (struct iwl_priv *)tmp;
  return;
}
}
void ldv_initialize_iwl_dvm_cfg_54(void) 
{ 
  void *tmp ;

  {
  tmp = ldv_init_zalloc(14448UL);
  iwl_dvm_6030_cfg_group0 = (struct iwl_priv *)tmp;
  return;
}
}
void ldv_initialize_iwl_dvm_cfg_59(void) 
{ 
  void *tmp ;

  {
  tmp = ldv_init_zalloc(14448UL);
  iwl_dvm_5000_cfg_group0 = (struct iwl_priv *)tmp;
  return;
}
}
void ldv_initialize_iwl_dvm_cfg_57(void) 
{ 
  void *tmp ;

  {
  tmp = ldv_init_zalloc(14448UL);
  iwl_dvm_6000_cfg_group0 = (struct iwl_priv *)tmp;
  return;
}
}
void ldv_initialize_iwl_dvm_cfg_61(void) 
{ 
  void *tmp ;

  {
  tmp = ldv_init_zalloc(14448UL);
  iwl_dvm_105_cfg_group0 = (struct iwl_priv *)tmp;
  return;
}
}
void ldv_initialize_iwl_dvm_cfg_55(void) 
{ 
  void *tmp ;

  {
  tmp = ldv_init_zalloc(14448UL);
  iwl_dvm_6050_cfg_group0 = (struct iwl_priv *)tmp;
  return;
}
}
void ldv_initialize_iwl_dvm_cfg_60(void) 
{ 
  void *tmp ;

  {
  tmp = ldv_init_zalloc(14448UL);
  iwl_dvm_2030_cfg_group0 = (struct iwl_priv *)tmp;
  return;
}
}
void ldv_initialize_iwl_dvm_cfg_58(void) 
{ 
  void *tmp ;

  {
  tmp = ldv_init_zalloc(14448UL);
  iwl_dvm_5150_cfg_group0 = (struct iwl_priv *)tmp;
  return;
}
}
void ldv_main_exported_63(void) 
{ 
  int tmp ;

  {
  tmp = __VERIFIER_nondet_int();
  switch (tmp) {
  case 0: ;
  if (ldv_state_variable_63 == 1) {
    iwl1000_nic_config(iwl_dvm_1000_cfg_group0);
    ldv_state_variable_63 = 1;
  } else {

  }
  goto ldv_55167;
  case 1: ;
  if (ldv_state_variable_63 == 1) {
    iwlagn_temperature(iwl_dvm_1000_cfg_group0);
    ldv_state_variable_63 = 1;
  } else {

  }
  goto ldv_55167;
  case 2: ;
  if (ldv_state_variable_63 == 1) {
    iwl1000_hw_set_hw_params(iwl_dvm_1000_cfg_group0);
    ldv_state_variable_63 = 1;
  } else {

  }
  goto ldv_55167;
  default: 
  ldv_stop();
  }
  ldv_55167: ;
  return;
}
}
void ldv_main_exported_57(void) 
{ 
  struct ieee80211_channel_switch *ldvarg40 ;
  void *tmp ;
  int tmp___0 ;

  {
  tmp = ldv_init_zalloc(48UL);
  ldvarg40 = (struct ieee80211_channel_switch *)tmp;
  tmp___0 = __VERIFIER_nondet_int();
  switch (tmp___0) {
  case 0: ;
  if (ldv_state_variable_57 == 1) {
    iwl6000_nic_config(iwl_dvm_6000_cfg_group0);
    ldv_state_variable_57 = 1;
  } else {

  }
  goto ldv_55176;
  case 1: ;
  if (ldv_state_variable_57 == 1) {
    iwlagn_temperature(iwl_dvm_6000_cfg_group0);
    ldv_state_variable_57 = 1;
  } else {

  }
  goto ldv_55176;
  case 2: ;
  if (ldv_state_variable_57 == 1) {
    iwl6000_hw_set_hw_params(iwl_dvm_6000_cfg_group0);
    ldv_state_variable_57 = 1;
  } else {

  }
  goto ldv_55176;
  case 3: ;
  if (ldv_state_variable_57 == 1) {
    iwl6000_hw_channel_switch(iwl_dvm_6000_cfg_group0, ldvarg40);
    ldv_state_variable_57 = 1;
  } else {

  }
  goto ldv_55176;
  default: 
  ldv_stop();
  }
  ldv_55176: ;
  return;
}
}
void ldv_main_exported_61(void) 
{ 
  int tmp ;

  {
  tmp = __VERIFIER_nondet_int();
  switch (tmp) {
  case 0: ;
  if (ldv_state_variable_61 == 1) {
    iwl2000_nic_config(iwl_dvm_105_cfg_group0);
    ldv_state_variable_61 = 1;
  } else {

  }
  goto ldv_55185;
  case 1: ;
  if (ldv_state_variable_61 == 1) {
    iwlagn_temperature(iwl_dvm_105_cfg_group0);
    ldv_state_variable_61 = 1;
  } else {

  }
  goto ldv_55185;
  case 2: ;
  if (ldv_state_variable_61 == 1) {
    iwl2000_hw_set_hw_params(iwl_dvm_105_cfg_group0);
    ldv_state_variable_61 = 1;
  } else {

  }
  goto ldv_55185;
  default: 
  ldv_stop();
  }
  ldv_55185: ;
  return;
}
}
void ldv_main_exported_58(void) 
{ 
  struct ieee80211_channel_switch *ldvarg155 ;
  void *tmp ;
  int tmp___0 ;

  {
  tmp = ldv_init_zalloc(48UL);
  ldvarg155 = (struct ieee80211_channel_switch *)tmp;
  tmp___0 = __VERIFIER_nondet_int();
  switch (tmp___0) {
  case 0: ;
  if (ldv_state_variable_58 == 1) {
    iwl5150_temperature(iwl_dvm_5150_cfg_group0);
    ldv_state_variable_58 = 1;
  } else {

  }
  goto ldv_55194;
  case 1: ;
  if (ldv_state_variable_58 == 1) {
    iwl5150_hw_set_hw_params(iwl_dvm_5150_cfg_group0);
    ldv_state_variable_58 = 1;
  } else {

  }
  goto ldv_55194;
  case 2: ;
  if (ldv_state_variable_58 == 1) {
    iwl5000_hw_channel_switch(iwl_dvm_5150_cfg_group0, ldvarg155);
    ldv_state_variable_58 = 1;
  } else {

  }
  goto ldv_55194;
  default: 
  ldv_stop();
  }
  ldv_55194: ;
  return;
}
}
void ldv_main_exported_59(void) 
{ 
  struct ieee80211_channel_switch *ldvarg236 ;
  void *tmp ;
  int tmp___0 ;

  {
  tmp = ldv_init_zalloc(48UL);
  ldvarg236 = (struct ieee80211_channel_switch *)tmp;
  tmp___0 = __VERIFIER_nondet_int();
  switch (tmp___0) {
  case 0: ;
  if (ldv_state_variable_59 == 1) {
    iwlagn_temperature(iwl_dvm_5000_cfg_group0);
    ldv_state_variable_59 = 1;
  } else {

  }
  goto ldv_55203;
  case 1: ;
  if (ldv_state_variable_59 == 1) {
    iwl5000_hw_set_hw_params(iwl_dvm_5000_cfg_group0);
    ldv_state_variable_59 = 1;
  } else {

  }
  goto ldv_55203;
  case 2: ;
  if (ldv_state_variable_59 == 1) {
    iwl5000_hw_channel_switch(iwl_dvm_5000_cfg_group0, ldvarg236);
    ldv_state_variable_59 = 1;
  } else {

  }
  goto ldv_55203;
  default: 
  ldv_stop();
  }
  ldv_55203: ;
  return;
}
}
void ldv_main_exported_60(void) 
{ 
  int tmp ;

  {
  tmp = __VERIFIER_nondet_int();
  switch (tmp) {
  case 0: ;
  if (ldv_state_variable_60 == 1) {
    iwl2000_nic_config(iwl_dvm_2030_cfg_group0);
    ldv_state_variable_60 = 1;
  } else {

  }
  goto ldv_55211;
  case 1: ;
  if (ldv_state_variable_60 == 1) {
    iwlagn_temperature(iwl_dvm_2030_cfg_group0);
    ldv_state_variable_60 = 1;
  } else {

  }
  goto ldv_55211;
  case 2: ;
  if (ldv_state_variable_60 == 1) {
    iwl2000_hw_set_hw_params(iwl_dvm_2030_cfg_group0);
    ldv_state_variable_60 = 1;
  } else {

  }
  goto ldv_55211;
  default: 
  ldv_stop();
  }
  ldv_55211: ;
  return;
}
}
void ldv_main_exported_56(void) 
{ 
  struct ieee80211_channel_switch *ldvarg166 ;
  void *tmp ;
  int tmp___0 ;

  {
  tmp = ldv_init_zalloc(48UL);
  ldvarg166 = (struct ieee80211_channel_switch *)tmp;
  tmp___0 = __VERIFIER_nondet_int();
  switch (tmp___0) {
  case 0: ;
  if (ldv_state_variable_56 == 1) {
    iwl6000_nic_config(iwl_dvm_6005_cfg_group0);
    ldv_state_variable_56 = 1;
  } else {

  }
  goto ldv_55220;
  case 1: ;
  if (ldv_state_variable_56 == 1) {
    iwlagn_temperature(iwl_dvm_6005_cfg_group0);
    ldv_state_variable_56 = 1;
  } else {

  }
  goto ldv_55220;
  case 2: ;
  if (ldv_state_variable_56 == 1) {
    iwl6000_hw_set_hw_params(iwl_dvm_6005_cfg_group0);
    ldv_state_variable_56 = 1;
  } else {

  }
  goto ldv_55220;
  case 3: ;
  if (ldv_state_variable_56 == 1) {
    iwl6000_hw_channel_switch(iwl_dvm_6005_cfg_group0, ldvarg166);
    ldv_state_variable_56 = 1;
  } else {

  }
  goto ldv_55220;
  default: 
  ldv_stop();
  }
  ldv_55220: ;
  return;
}
}
void ldv_main_exported_62(void) 
{ 
  int tmp ;

  {
  tmp = __VERIFIER_nondet_int();
  switch (tmp) {
  case 0: ;
  if (ldv_state_variable_62 == 1) {
    iwl2000_nic_config(iwl_dvm_2000_cfg_group0);
    ldv_state_variable_62 = 1;
  } else {

  }
  goto ldv_55229;
  case 1: ;
  if (ldv_state_variable_62 == 1) {
    iwlagn_temperature(iwl_dvm_2000_cfg_group0);
    ldv_state_variable_62 = 1;
  } else {

  }
  goto ldv_55229;
  case 2: ;
  if (ldv_state_variable_62 == 1) {
    iwl2000_hw_set_hw_params(iwl_dvm_2000_cfg_group0);
    ldv_state_variable_62 = 1;
  } else {

  }
  goto ldv_55229;
  default: 
  ldv_stop();
  }
  ldv_55229: ;
  return;
}
}
void ldv_main_exported_54(void) 
{ 
  struct ieee80211_channel_switch *ldvarg185 ;
  void *tmp ;
  int tmp___0 ;

  {
  tmp = ldv_init_zalloc(48UL);
  ldvarg185 = (struct ieee80211_channel_switch *)tmp;
  tmp___0 = __VERIFIER_nondet_int();
  switch (tmp___0) {
  case 0: ;
  if (ldv_state_variable_54 == 1) {
    iwl6000_nic_config(iwl_dvm_6030_cfg_group0);
    ldv_state_variable_54 = 1;
  } else {

  }
  goto ldv_55238;
  case 1: ;
  if (ldv_state_variable_54 == 1) {
    iwlagn_temperature(iwl_dvm_6030_cfg_group0);
    ldv_state_variable_54 = 1;
  } else {

  }
  goto ldv_55238;
  case 2: ;
  if (ldv_state_variable_54 == 1) {
    iwl6000_hw_set_hw_params(iwl_dvm_6030_cfg_group0);
    ldv_state_variable_54 = 1;
  } else {

  }
  goto ldv_55238;
  case 3: ;
  if (ldv_state_variable_54 == 1) {
    iwl6000_hw_channel_switch(iwl_dvm_6030_cfg_group0, ldvarg185);
    ldv_state_variable_54 = 1;
  } else {

  }
  goto ldv_55238;
  default: 
  ldv_stop();
  }
  ldv_55238: ;
  return;
}
}
void ldv_main_exported_55(void) 
{ 
  struct ieee80211_channel_switch *ldvarg34 ;
  void *tmp ;
  int tmp___0 ;

  {
  tmp = ldv_init_zalloc(48UL);
  ldvarg34 = (struct ieee80211_channel_switch *)tmp;
  tmp___0 = __VERIFIER_nondet_int();
  switch (tmp___0) {
  case 0: ;
  if (ldv_state_variable_55 == 1) {
    iwl6000_nic_config(iwl_dvm_6050_cfg_group0);
    ldv_state_variable_55 = 1;
  } else {

  }
  goto ldv_55248;
  case 1: ;
  if (ldv_state_variable_55 == 1) {
    iwlagn_temperature(iwl_dvm_6050_cfg_group0);
    ldv_state_variable_55 = 1;
  } else {

  }
  goto ldv_55248;
  case 2: ;
  if (ldv_state_variable_55 == 1) {
    iwl6000_hw_set_hw_params(iwl_dvm_6050_cfg_group0);
    ldv_state_variable_55 = 1;
  } else {

  }
  goto ldv_55248;
  case 3: ;
  if (ldv_state_variable_55 == 1) {
    iwl6000_hw_channel_switch(iwl_dvm_6050_cfg_group0, ldvarg34);
    ldv_state_variable_55 = 1;
  } else {

  }
  goto ldv_55248;
  default: 
  ldv_stop();
  }
  ldv_55248: ;
  return;
}
}
bool ldv_queue_work_on_255(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_7(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_delayed_work_on_256(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_7(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_work_on_257(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_7(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
void ldv_flush_workqueue_258(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
  flush_workqueue(ldv_func_arg1);
  call_and_disable_all_7(2);
  return;
}
}
bool ldv_queue_delayed_work_on_259(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_7(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
__inline static long ldv__builtin_expect(long exp , long c ) ;
extern char *kasprintf(gfp_t  , char const   *  , ...) ;
__inline static unsigned long arch_local_save_flags___4(void) 
{ 
  unsigned long __ret ;
  unsigned long __edi ;
  unsigned long __esi ;
  unsigned long __edx ;
  unsigned long __ecx ;
  unsigned long __eax ;
  long tmp ;

  {
  __edi = __edi;
  __esi = __esi;
  __edx = __edx;
  __ecx = __ecx;
  __eax = __eax;
  tmp = ldv__builtin_expect((unsigned long )pv_irq_ops.save_fl.func == (unsigned long )((void *)0),
                         0L);
  if (tmp != 0L) {
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"./arch/x86/include/asm/paravirt.h"),
                         "i" (831), "i" (12UL));
    ldv_4860: ;
    goto ldv_4860;
  } else {

  }
  __asm__  volatile   ("771:\n\tcall *%c2;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c1\n  .byte 772b-771b\n  .short %c3\n.popsection\n": "=a" (__eax): [paravirt_typenum] "i" (43UL),
                       [paravirt_opptr] "i" (& pv_irq_ops.save_fl.func), [paravirt_clobber] "i" (1): "memory",
                       "cc");
  __ret = __eax;
  return (__ret);
}
}
__inline static bool static_key_false___4(struct static_key *key ) 
{ 
  int tmp ;
  long tmp___0 ;

  {
  tmp = static_key_count(key);
  tmp___0 = ldv__builtin_expect(tmp > 0, 0L);
  if (tmp___0 != 0L) {
    return (1);
  } else {

  }
  return (0);
}
}
__inline static int rcu_read_lock_sched_held___4(void) 
{ 
  int lockdep_opinion ;
  int tmp ;
  bool tmp___0 ;
  int tmp___1 ;
  bool tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  unsigned long _flags ;
  int tmp___5 ;
  int tmp___6 ;

  {
  lockdep_opinion = 0;
  tmp = debug_lockdep_rcu_enabled();
  if (tmp == 0) {
    return (1);
  } else {

  }
  tmp___0 = rcu_is_watching();
  if (tmp___0) {
    tmp___1 = 0;
  } else {
    tmp___1 = 1;
  }
  if (tmp___1) {
    return (0);
  } else {

  }
  tmp___2 = rcu_lockdep_current_cpu_online();
  if (tmp___2) {
    tmp___3 = 0;
  } else {
    tmp___3 = 1;
  }
  if (tmp___3) {
    return (0);
  } else {

  }
  if (debug_locks != 0) {
    lockdep_opinion = lock_is_held(& rcu_sched_lock_map);
  } else {

  }
  if (lockdep_opinion != 0) {
    tmp___6 = 1;
  } else {
    tmp___4 = preempt_count();
    if (tmp___4 != 0) {
      tmp___6 = 1;
    } else {
      _flags = arch_local_save_flags___4();
      tmp___5 = arch_irqs_disabled_flags(_flags);
      if (tmp___5 != 0) {
        tmp___6 = 1;
      } else {
        tmp___6 = 0;
      }
    }
  }
  return (tmp___6);
}
}
bool ldv_queue_work_on_269(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_work_on_271(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_delayed_work_on_270(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
bool ldv_queue_delayed_work_on_273(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
void ldv_flush_workqueue_272(struct workqueue_struct *ldv_func_arg1 ) ;
__inline static char const   *kobject_name(struct kobject  const  *kobj ) 
{ 


  {
  return ((char const   *)kobj->name);
}
}
__inline static char const   *dev_name(struct device  const  *dev ) 
{ 
  char const   *tmp ;

  {
  if ((unsigned long )dev->init_name != (unsigned long )((char const   */* const  */)0)) {
    return ((char const   *)dev->init_name);
  } else {

  }
  tmp = kobject_name(& dev->kobj);
  return (tmp);
}
}
__inline static char const   *wiphy_name(struct wiphy  const  *wiphy ) 
{ 
  char const   *tmp ;

  {
  tmp = dev_name(& wiphy->dev);
  return (tmp);
}
}
extern char const   *__ieee80211_get_radio_led_name(struct ieee80211_hw * ) ;
extern char const   *__ieee80211_create_tpt_led_trigger(struct ieee80211_hw * , unsigned int  ,
                                                        struct ieee80211_tpt_blink  const  * ,
                                                        unsigned int  ) ;
__inline static char const   *ieee80211_get_radio_led_name(struct ieee80211_hw *hw ) 
{ 
  char const   *tmp ;

  {
  tmp = __ieee80211_get_radio_led_name(hw);
  return (tmp);
}
}
__inline static char const   *ieee80211_create_tpt_led_trigger(struct ieee80211_hw *hw ,
                                                               unsigned int flags ,
                                                               struct ieee80211_tpt_blink  const  *blink_table ,
                                                               unsigned int blink_table_len ) 
{ 
  char const   *tmp ;

  {
  tmp = __ieee80211_create_tpt_led_trigger(hw, flags, blink_table, blink_table_len);
  return (tmp);
}
}
__inline static void trace_iwlwifi_dev_ioread32___1(struct device  const  *dev , u32 offs ,
                                                    u32 val ) 
{ 
  struct tracepoint_func *it_func_ptr ;
  void *it_func ;
  void *__data ;
  struct tracepoint_func *________p1 ;
  struct tracepoint_func *_________p1 ;
  union __anonunion___u_390___0 __u ;
  bool __warned ;
  int tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  struct tracepoint_func *________p1___0 ;
  struct tracepoint_func *_________p1___0 ;
  union __anonunion___u_392___0 __u___0 ;
  bool __warned___0 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  tmp___1 = static_key_false___4(& __tracepoint_iwlwifi_dev_ioread32.key);
  if ((int )tmp___1) {
    rcu_read_lock_sched_notrace();
    __read_once_size((void const volatile   *)(& __tracepoint_iwlwifi_dev_ioread32.funcs),
                     (void *)(& __u.__c), 8);
    _________p1 = __u.__val;
    ________p1 = _________p1;
    tmp = debug_lockdep_rcu_enabled();
    if (tmp != 0 && ! __warned) {
      tmp___0 = rcu_read_lock_sched_held___4();
      if (tmp___0 == 0) {
        __warned = 1;
        lockdep_rcu_suspicious("drivers/net/wireless/iwlwifi/dvm/../iwl-devtrace-io.h",
                               50, "suspicious rcu_dereference_check() usage");
      } else {

      }
    } else {

    }
    it_func_ptr = ________p1;
    if ((unsigned long )it_func_ptr != (unsigned long )((struct tracepoint_func *)0)) {
      ldv_51242: 
      it_func = it_func_ptr->func;
      __data = it_func_ptr->data;
      (*((void (*)(void * , struct device  const  * , u32  , u32  ))it_func))(__data,
                                                                              dev,
                                                                              offs,
                                                                              val);
      it_func_ptr = it_func_ptr + 1;
      if ((unsigned long )it_func_ptr->func != (unsigned long )((void *)0)) {
        goto ldv_51242;
      } else {

      }

    } else {

    }
    rcu_read_unlock_sched_notrace();
  } else {

  }
  rcu_read_lock_sched_notrace();
  __read_once_size((void const volatile   *)(& __tracepoint_iwlwifi_dev_ioread32.funcs),
                   (void *)(& __u___0.__c), 8);
  _________p1___0 = __u___0.__val;
  ________p1___0 = _________p1___0;
  tmp___2 = debug_lockdep_rcu_enabled();
  if (tmp___2 != 0 && ! __warned___0) {
    tmp___3 = rcu_read_lock_sched_held___4();
    if (tmp___3 == 0) {
      __warned___0 = 1;
      lockdep_rcu_suspicious("drivers/net/wireless/iwlwifi/dvm/../iwl-devtrace-io.h",
                             50, "suspicious rcu_dereference_check() usage");
    } else {

    }
  } else {

  }
  rcu_read_unlock_sched_notrace();
  return;
}
}
__inline static void trace_iwlwifi_dev_iowrite32___4(struct device  const  *dev ,
                                                     u32 offs , u32 val ) 
{ 
  struct tracepoint_func *it_func_ptr ;
  void *it_func ;
  void *__data ;
  struct tracepoint_func *________p1 ;
  struct tracepoint_func *_________p1 ;
  union __anonunion___u_398___2 __u ;
  bool __warned ;
  int tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  struct tracepoint_func *________p1___0 ;
  struct tracepoint_func *_________p1___0 ;
  union __anonunion___u_400___2 __u___0 ;
  bool __warned___0 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  tmp___1 = static_key_false___4(& __tracepoint_iwlwifi_dev_iowrite32.key);
  if ((int )tmp___1) {
    rcu_read_lock_sched_notrace();
    __read_once_size((void const volatile   *)(& __tracepoint_iwlwifi_dev_iowrite32.funcs),
                     (void *)(& __u.__c), 8);
    _________p1 = __u.__val;
    ________p1 = _________p1;
    tmp = debug_lockdep_rcu_enabled();
    if (tmp != 0 && ! __warned) {
      tmp___0 = rcu_read_lock_sched_held___4();
      if (tmp___0 == 0) {
        __warned = 1;
        lockdep_rcu_suspicious("drivers/net/wireless/iwlwifi/dvm/../iwl-devtrace-io.h",
                               84, "suspicious rcu_dereference_check() usage");
      } else {

      }
    } else {

    }
    it_func_ptr = ________p1;
    if ((unsigned long )it_func_ptr != (unsigned long )((struct tracepoint_func *)0)) {
      ldv_51364: 
      it_func = it_func_ptr->func;
      __data = it_func_ptr->data;
      (*((void (*)(void * , struct device  const  * , u32  , u32  ))it_func))(__data,
                                                                              dev,
                                                                              offs,
                                                                              val);
      it_func_ptr = it_func_ptr + 1;
      if ((unsigned long )it_func_ptr->func != (unsigned long )((void *)0)) {
        goto ldv_51364;
      } else {

      }

    } else {

    }
    rcu_read_unlock_sched_notrace();
  } else {

  }
  rcu_read_lock_sched_notrace();
  __read_once_size((void const volatile   *)(& __tracepoint_iwlwifi_dev_iowrite32.funcs),
                   (void *)(& __u___0.__c), 8);
  _________p1___0 = __u___0.__val;
  ________p1___0 = _________p1___0;
  tmp___2 = debug_lockdep_rcu_enabled();
  if (tmp___2 != 0 && ! __warned___0) {
    tmp___3 = rcu_read_lock_sched_held___4();
    if (tmp___3 == 0) {
      __warned___0 = 1;
      lockdep_rcu_suspicious("drivers/net/wireless/iwlwifi/dvm/../iwl-devtrace-io.h",
                             84, "suspicious rcu_dereference_check() usage");
    } else {

    }
  } else {

  }
  rcu_read_unlock_sched_notrace();
  return;
}
}
__inline static void iwl_write32___4(struct iwl_trans *trans , u32 ofs , u32 val ) 
{ 


  {
  trace_iwlwifi_dev_iowrite32___4((struct device  const  *)trans->dev, ofs, val);
  iwl_trans_write32(trans, ofs, val);
  return;
}
}
__inline static u32 iwl_read32___1(struct iwl_trans *trans , u32 ofs ) 
{ 
  u32 val ;
  u32 tmp ;

  {
  tmp = iwl_trans_read32(trans, ofs);
  val = tmp;
  trace_iwlwifi_dev_ioread32___1((struct device  const  *)trans->dev, ofs, val);
  return (val);
}
}
extern int led_classdev_register(struct device * , struct led_classdev * ) ;
extern void led_classdev_unregister(struct led_classdev * ) ;
static struct ieee80211_tpt_blink  const  iwl_blink[10U]  = 
  {      {0, 334}, 
        {1023, 260}, 
        {5119, 220}, 
        {10239, 190}, 
        {20479, 170}, 
        {51199, 150}, 
        {71679, 130}, 
        {102399, 110}, 
        {204799, 80}, 
        {307199, 50}};
void iwlagn_led_enable(struct iwl_priv *priv ) 
{ 


  {
  iwl_write32___4(priv->trans, 148U, 96U);
  return;
}
}
__inline static u8 iwl_blink_compensation(struct iwl_priv *priv , u8 time , u16 compensation ) 
{ 


  {
  if ((unsigned int )compensation == 0U) {
    __iwl_err(priv->dev, 0, 0, "undefined blink compensation: use pre-defined blinking time\n");
    return (time);
  } else {

  }
  return ((u8 )((int )time * (int )compensation >> 6));
}
}
static int iwl_send_led_cmd(struct iwl_priv *priv , struct iwl_led_cmd *led_cmd ) 
{ 
  struct iwl_host_cmd cmd ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  u32 reg ;
  int tmp___1 ;

  {
  cmd.data[0] = (void const   *)led_cmd;
  tmp = 1U;
  while (1) {
    if (tmp >= 2U) {
      break;
    } else {

    }
    cmd.data[tmp] = 0;
    tmp = tmp + 1U;
  }
  cmd.resp_pkt = 0;
  cmd._rx_page_addr = 0UL;
  cmd._rx_page_order = 0U;
  cmd.handler_status = 0;
  cmd.flags = 1U;
  cmd.len[0] = 8U;
  tmp___0 = 1U;
  while (1) {
    if (tmp___0 >= 2U) {
      break;
    } else {

    }
    cmd.len[tmp___0] = (unsigned short)0;
    tmp___0 = tmp___0 + 1U;
  }
  cmd.dataflags[0] = (unsigned char)0;
  cmd.dataflags[1] = (unsigned char)0;
  cmd.id = 72U;
  reg = iwl_read32___1(priv->trans, 148U);
  if ((reg & 4294967263U) != reg) {
    iwl_write32___4(priv->trans, 148U, reg & 4294967263U);
  } else {

  }
  tmp___1 = iwl_dvm_send_cmd(priv, & cmd);
  return (tmp___1);
}
}
static int iwl_led_cmd(struct iwl_priv *priv , unsigned long on , unsigned long off ) 
{ 
  struct iwl_led_cmd led_cmd ;
  int ret ;
  int tmp ;

  {
  led_cmd.interval = 1000U;
  led_cmd.id = 2U;
  led_cmd.off = (unsigned char)0;
  led_cmd.on = (unsigned char)0;
  led_cmd.reserved = (unsigned char)0;
  tmp = constant_test_bit(3L, (unsigned long const volatile   *)(& priv->status));
  if (tmp == 0) {
    return (-16);
  } else {

  }
  if (priv->blink_on == on && priv->blink_off == off) {
    return (0);
  } else {

  }
  if (off == 0UL) {
    on = 11UL;
  } else {

  }
  __iwl_dbg(priv->dev, 524288U, 0, "iwl_led_cmd", "Led blink time compensation=%u\n",
            (int )((priv->cfg)->base_params)->led_compensation);
  led_cmd.on = iwl_blink_compensation(priv, (int )((u8 )on), (int )((priv->cfg)->base_params)->led_compensation);
  led_cmd.off = iwl_blink_compensation(priv, (int )((u8 )off), (int )((priv->cfg)->base_params)->led_compensation);
  ret = iwl_send_led_cmd(priv, & led_cmd);
  if (ret == 0) {
    priv->blink_on = on;
    priv->blink_off = off;
  } else {

  }
  return (ret);
}
}
static void iwl_led_brightness_set(struct led_classdev *led_cdev , enum led_brightness brightness ) 
{ 
  struct iwl_priv *priv ;
  struct led_classdev  const  *__mptr ;
  unsigned long on ;
    klee_make_symbolic(&on, sizeof(long), "on");

  {
  __mptr = (struct led_classdev  const  *)led_cdev;
  priv = (struct iwl_priv *)__mptr + 0xffffffffffffcac8UL;
  on = 0UL;
  if ((unsigned int )brightness != 0U) {
    on = 11UL;
  } else {

  }
  iwl_led_cmd(priv, on, 0UL);
  return;
}
}
static int iwl_led_blink_set(struct led_classdev *led_cdev , unsigned long *delay_on ,
                             unsigned long *delay_off ) 
{ 
  struct iwl_priv *priv ;
  struct led_classdev  const  *__mptr ;
  int tmp ;

  {
  __mptr = (struct led_classdev  const  *)led_cdev;
  priv = (struct iwl_priv *)__mptr + 0xffffffffffffcac8UL;
  tmp = iwl_led_cmd(priv, *delay_on, *delay_off);
  return (tmp);
}
}
void iwl_leds_init(struct iwl_priv *priv ) 
{ 
  int mode ;
  int ret ;
  char const   *tmp ;
  char *tmp___0 ;
  int __ret_warn_on ;
  long tmp___1 ;

  {
  mode = iwlwifi_mod_params.led_mode;
  if (mode == 3) {
    __iwl_info(priv->dev, "Led disabled\n");
    return;
  } else {

  }
  if (mode == 0) {
    mode = (int )(priv->cfg)->led_mode;
  } else {

  }
  tmp = wiphy_name((struct wiphy  const  *)(priv->hw)->wiphy);
  tmp___0 = kasprintf(208U, "%s-led", tmp);
  priv->led.name = (char const   *)tmp___0;
  priv->led.brightness_set = & iwl_led_brightness_set;
  priv->led.blink_set = & iwl_led_blink_set;
  priv->led.max_brightness = 1;
  switch (mode) {
  case 0: 
  __ret_warn_on = 1;
  tmp___1 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp___1 != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/08_1a/drivers/net/wireless/iwlwifi/dvm/led.c",
                       193);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  goto ldv_55190;
  case 2: 
  priv->led.default_trigger = ieee80211_create_tpt_led_trigger(priv->hw, 4U, (struct ieee80211_tpt_blink  const  *)(& iwl_blink),
                                                               10U);
  goto ldv_55190;
  case 1: 
  priv->led.default_trigger = ieee80211_get_radio_led_name(priv->hw);
  goto ldv_55190;
  }
  ldv_55190: 
  ret = led_classdev_register((priv->trans)->dev, & priv->led);
  if (ret != 0) {
    kfree((void const   *)priv->led.name);
    return;
  } else {

  }
  priv->led_registered = 1;
  return;
}
}
void iwl_leds_exit(struct iwl_priv *priv ) 
{ 


  {
  if (! priv->led_registered) {
    return;
  } else {

  }
  led_classdev_unregister(& priv->led);
  kfree((void const   *)priv->led.name);
  return;
}
}
bool ldv_queue_work_on_269(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_7(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_delayed_work_on_270(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_7(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_work_on_271(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_7(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
void ldv_flush_workqueue_272(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
  flush_workqueue(ldv_func_arg1);
  call_and_disable_all_7(2);
  return;
}
}
bool ldv_queue_delayed_work_on_273(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_7(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
__inline static long ldv__builtin_expect(long exp , long c ) ;
extern int hex_dump_to_buffer(void const   * , size_t  , int  , int  , char * , size_t  ,
                              bool  ) ;
extern size_t strlen(char const   * ) ;
__inline static unsigned long arch_local_save_flags___5(void) 
{ 
  unsigned long __ret ;
  unsigned long __edi ;
  unsigned long __esi ;
  unsigned long __edx ;
  unsigned long __ecx ;
  unsigned long __eax ;
  long tmp ;

  {
  __edi = __edi;
  __esi = __esi;
  __edx = __edx;
  __ecx = __ecx;
  __eax = __eax;
  tmp = ldv__builtin_expect((unsigned long )pv_irq_ops.save_fl.func == (unsigned long )((void *)0),
                         0L);
  if (tmp != 0L) {
    __asm__  volatile   ("1:\tud2\n.pushsection __bug_table,\"a\"\n2:\t.long 1b - 2b, %c0 - 2b\n\t.word %c1, 0\n\t.org 2b+%c2\n.popsection": : "i" ((char *)"./arch/x86/include/asm/paravirt.h"),
                         "i" (831), "i" (12UL));
    ldv_4860: ;
    goto ldv_4860;
  } else {

  }
  __asm__  volatile   ("771:\n\tcall *%c2;\n772:\n.pushsection .parainstructions,\"a\"\n .balign 8 \n .quad  771b\n  .byte %c1\n  .byte 772b-771b\n  .short %c3\n.popsection\n": "=a" (__eax): [paravirt_typenum] "i" (43UL),
                       [paravirt_opptr] "i" (& pv_irq_ops.save_fl.func), [paravirt_clobber] "i" (1): "memory",
                       "cc");
  __ret = __eax;
  return (__ret);
}
}
__inline static bool static_key_false___5(struct static_key *key ) 
{ 
  int tmp ;
  long tmp___0 ;

  {
  tmp = static_key_count(key);
  tmp___0 = ldv__builtin_expect(tmp > 0, 0L);
  if (tmp___0 != 0L) {
    return (1);
  } else {

  }
  return (0);
}
}
__inline static int rcu_read_lock_sched_held___5(void) 
{ 
  int lockdep_opinion ;
  int tmp ;
  bool tmp___0 ;
  int tmp___1 ;
  bool tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  unsigned long _flags ;
  int tmp___5 ;
  int tmp___6 ;

  {
  lockdep_opinion = 0;
  tmp = debug_lockdep_rcu_enabled();
  if (tmp == 0) {
    return (1);
  } else {

  }
  tmp___0 = rcu_is_watching();
  if (tmp___0) {
    tmp___1 = 0;
  } else {
    tmp___1 = 1;
  }
  if (tmp___1) {
    return (0);
  } else {

  }
  tmp___2 = rcu_lockdep_current_cpu_online();
  if (tmp___2) {
    tmp___3 = 0;
  } else {
    tmp___3 = 1;
  }
  if (tmp___3) {
    return (0);
  } else {

  }
  if (debug_locks != 0) {
    lockdep_opinion = lock_is_held(& rcu_sched_lock_map);
  } else {

  }
  if (lockdep_opinion != 0) {
    tmp___6 = 1;
  } else {
    tmp___4 = preempt_count();
    if (tmp___4 != 0) {
      tmp___6 = 1;
    } else {
      _flags = arch_local_save_flags___5();
      tmp___5 = arch_irqs_disabled_flags(_flags);
      if (tmp___5 != 0) {
        tmp___6 = 1;
      } else {
        tmp___6 = 0;
      }
    }
  }
  return (tmp___6);
}
}
int ldv_mod_timer_288(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
int ldv_del_timer_sync_289(struct timer_list *ldv_func_arg1 ) ;
bool ldv_queue_work_on_283(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_work_on_285(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_delayed_work_on_284(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
bool ldv_queue_delayed_work_on_287(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
void ldv_flush_workqueue_286(struct workqueue_struct *ldv_func_arg1 ) ;
extern loff_t generic_file_llseek(struct file * , loff_t  , int  ) ;
extern struct dentry *debugfs_create_dir(char const   * , struct dentry * ) ;
extern struct dentry *debugfs_create_symlink(char const   * , struct dentry * , char const   * ) ;
__inline static void trace_iwlwifi_dev_ioread32___2(struct device  const  *dev , u32 offs ,
                                                    u32 val ) 
{ 
  struct tracepoint_func *it_func_ptr ;
  void *it_func ;
  void *__data ;
  struct tracepoint_func *________p1 ;
  struct tracepoint_func *_________p1 ;
  union __anonunion___u_386___0 __u ;
  bool __warned ;
  int tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  struct tracepoint_func *________p1___0 ;
  struct tracepoint_func *_________p1___0 ;
  union __anonunion___u_388___0 __u___0 ;
  bool __warned___0 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  tmp___1 = static_key_false___5(& __tracepoint_iwlwifi_dev_ioread32.key);
  if ((int )tmp___1) {
    rcu_read_lock_sched_notrace();
    __read_once_size((void const volatile   *)(& __tracepoint_iwlwifi_dev_ioread32.funcs),
                     (void *)(& __u.__c), 8);
    _________p1 = __u.__val;
    ________p1 = _________p1;
    tmp = debug_lockdep_rcu_enabled();
    if (tmp != 0 && ! __warned) {
      tmp___0 = rcu_read_lock_sched_held___5();
      if (tmp___0 == 0) {
        __warned = 1;
        lockdep_rcu_suspicious("drivers/net/wireless/iwlwifi/dvm/../iwl-devtrace-io.h",
                               50, "suspicious rcu_dereference_check() usage");
      } else {

      }
    } else {

    }
    it_func_ptr = ________p1;
    if ((unsigned long )it_func_ptr != (unsigned long )((struct tracepoint_func *)0)) {
      ldv_51092: 
      it_func = it_func_ptr->func;
      __data = it_func_ptr->data;
      (*((void (*)(void * , struct device  const  * , u32  , u32  ))it_func))(__data,
                                                                              dev,
                                                                              offs,
                                                                              val);
      it_func_ptr = it_func_ptr + 1;
      if ((unsigned long )it_func_ptr->func != (unsigned long )((void *)0)) {
        goto ldv_51092;
      } else {

      }

    } else {

    }
    rcu_read_unlock_sched_notrace();
  } else {

  }
  rcu_read_lock_sched_notrace();
  __read_once_size((void const volatile   *)(& __tracepoint_iwlwifi_dev_ioread32.funcs),
                   (void *)(& __u___0.__c), 8);
  _________p1___0 = __u___0.__val;
  ________p1___0 = _________p1___0;
  tmp___2 = debug_lockdep_rcu_enabled();
  if (tmp___2 != 0 && ! __warned___0) {
    tmp___3 = rcu_read_lock_sched_held___5();
    if (tmp___3 == 0) {
      __warned___0 = 1;
      lockdep_rcu_suspicious("drivers/net/wireless/iwlwifi/dvm/../iwl-devtrace-io.h",
                             50, "suspicious rcu_dereference_check() usage");
    } else {

    }
  } else {

  }
  rcu_read_unlock_sched_notrace();
  return;
}
}
__inline static u32 iwl_read32___2(struct iwl_trans *trans , u32 ofs ) 
{ 
  u32 val ;
  u32 tmp ;

  {
  tmp = iwl_trans_read32(trans, ofs);
  val = tmp;
  trace_iwlwifi_dev_ioread32___2((struct device  const  *)trans->dev, ofs, val);
  return (val);
}
}
__inline static int iwl_is_any_associated___3(struct iwl_priv *priv ) 
{ 
  struct iwl_rxon_context *ctx ;
  int tmp ;

  {
  ctx = (struct iwl_rxon_context *)(& priv->contexts);
  goto ldv_54590;
  ldv_54589: ;
  if ((int )((unsigned long )priv->valid_contexts >> (int )ctx->ctxid) & 1) {
    tmp = iwl_is_associated_ctx(ctx);
    if (tmp != 0) {
      return (1);
    } else {

    }
  } else {

  }
  ctx = ctx + 1;
  ldv_54590: ;
  if ((unsigned long )((struct iwl_rxon_context *)(& priv->contexts) + 2UL) > (unsigned long )ctx) {
    goto ldv_54589;
  } else {

  }

  return (0);
}
}
static ssize_t iwl_dbgfs_sram_read(struct file *file , char *user_buf , size_t count ,
                                   loff_t *ppos ) 
{ 
  u32 val ;
  char *buf ;
  ssize_t ret ;
  int i ;
  bool device_format ;
  int offset ;
  int len ;
  int pos ;
  int sram ;
    klee_make_symbolic(&sram, sizeof(int), "sram");
  struct iwl_priv *priv ;
  struct fw_img  const  *img ;
  size_t bufsz ;
  int tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
  val = 0U;
  i = 0;
  device_format = 0;
  offset = 0;
  len = 0;
  pos = 0;
  priv = (struct iwl_priv *)file->private_data;
  tmp = iwl_is_ready_rf(priv);
  if (tmp == 0) {
    return (-11L);
  } else {

  }
  if (priv->dbgfs_sram_offset == 0U && priv->dbgfs_sram_len == 0U) {
    priv->dbgfs_sram_offset = 8388608U;
    if (! priv->ucode_loaded) {
      return (-22L);
    } else {

    }
    img = (struct fw_img  const  *)(& (priv->fw)->img) + (unsigned long )priv->cur_ucode;
    priv->dbgfs_sram_len = img->sec[0].len;
  } else {

  }
  len = (int )priv->dbgfs_sram_len;
  if (len == -4) {
    device_format = 1;
    len = 4;
  } else {

  }
  bufsz = (size_t )(len * 4 + 50);
  tmp___0 = kmalloc(bufsz, 208U);
  buf = (char *)tmp___0;
  if ((unsigned long )buf == (unsigned long )((char *)0)) {
    return (-12L);
  } else {

  }
  tmp___1 = scnprintf(buf + (unsigned long )pos, bufsz - (size_t )pos, "sram_len: 0x%x\n",
                      len);
  pos = tmp___1 + pos;
  tmp___2 = scnprintf(buf + (unsigned long )pos, bufsz - (size_t )pos, "sram_offset: 0x%x\n",
                      priv->dbgfs_sram_offset);
  pos = tmp___2 + pos;
  offset = (int )priv->dbgfs_sram_offset & 3;
  sram = (int )priv->dbgfs_sram_offset & -4;
  val = iwl_trans_read_mem32(priv->trans, (u32 )sram);
  goto ldv_55012;
  ldv_55011: ;
  if (i == 0) {
    tmp___3 = scnprintf(buf + (unsigned long )pos, bufsz - (size_t )pos, "%08X: ",
                        sram + offset);
    pos = tmp___3 + pos;
  } else {

  }
  if ((int )device_format) {
    tmp___4 = scnprintf(buf + (unsigned long )pos, bufsz - (size_t )pos, "%02x", (val >> (3 - offset) * 8) & 255U);
    pos = tmp___4 + pos;
  } else {
    tmp___5 = scnprintf(buf + (unsigned long )pos, bufsz - (size_t )pos, "%02x ",
                        (val >> offset * 8) & 255U);
    pos = tmp___5 + pos;
  }
  offset = offset + 1;
  if (offset == 4) {
    sram = sram + 4;
    offset = 0;
    val = iwl_trans_read_mem32(priv->trans, (u32 )sram);
  } else {

  }
  i = i + 1;
  if (i == 16) {
    i = 0;
    tmp___6 = scnprintf(buf + (unsigned long )pos, bufsz - (size_t )pos, "\n");
    pos = tmp___6 + pos;
  } else
  if ((i & 7) == 0) {
    tmp___7 = scnprintf(buf + (unsigned long )pos, bufsz - (size_t )pos, "   ");
    pos = tmp___7 + pos;
  } else
  if ((i & 3) == 0) {
    tmp___8 = scnprintf(buf + (unsigned long )pos, bufsz - (size_t )pos, " ");
    pos = tmp___8 + pos;
  } else {

  }
  len = len - 1;
  ldv_55012: ;
  if (len != 0) {
    goto ldv_55011;
  } else {

  }

  if (i != 0) {
    tmp___9 = scnprintf(buf + (unsigned long )pos, bufsz - (size_t )pos, "\n");
    pos = tmp___9 + pos;
  } else {

  }
  ret = simple_read_from_buffer((void *)user_buf, count, ppos, (void const   *)buf,
                                (size_t )pos);
  kfree((void const   *)buf);
  return (ret);
}
}
static ssize_t iwl_dbgfs_sram_write(struct file *file , char const   *user_buf , size_t count ,
                                    loff_t *ppos ) 
{ 
  struct iwl_priv *priv ;
  char buf[64U] ;
  int buf_size ;
    klee_make_symbolic(&buf_size, sizeof(int), "buf_size");
  u32 offset ;
  u32 len ;
  size_t _min1 ;
  unsigned long _min2 ;
  unsigned long tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  priv = (struct iwl_priv *)file->private_data;
  memset((void *)(& buf), 0, 64UL);
  _min1 = count;
  _min2 = 63UL;
  buf_size = (int )(_min1 < _min2 ? _min1 : _min2);
  tmp = copy_from_user((void *)(& buf), (void const   *)user_buf, (unsigned long )buf_size);
  if (tmp != 0UL) {
    return (-14L);
  } else {

  }
  tmp___1 = sscanf((char const   *)(& buf), "%x,%x", & offset, & len);
  if (tmp___1 == 2) {
    priv->dbgfs_sram_offset = offset;
    priv->dbgfs_sram_len = len;
  } else {
    tmp___0 = sscanf((char const   *)(& buf), "%x", & offset);
    if (tmp___0 == 1) {
      priv->dbgfs_sram_offset = offset;
      priv->dbgfs_sram_len = 4294967292U;
    } else {
      priv->dbgfs_sram_offset = 0U;
      priv->dbgfs_sram_len = 0U;
    }
  }
  return ((ssize_t )count);
}
}
static ssize_t iwl_dbgfs_wowlan_sram_read(struct file *file , char *user_buf , size_t count ,
                                          loff_t *ppos ) 
{ 
  struct iwl_priv *priv ;
  struct fw_img  const  *img ;
  ssize_t tmp ;

  {
  priv = (struct iwl_priv *)file->private_data;
  img = (struct fw_img  const  *)(& (priv->fw)->img) + 2UL;
  if ((unsigned long )priv->wowlan_sram == (unsigned long )((void *)0)) {
    return (-61L);
  } else {

  }
  tmp = simple_read_from_buffer((void *)user_buf, count, ppos, (void const   *)priv->wowlan_sram,
                                (size_t )img->sec[0].len);
  return (tmp);
}
}
static ssize_t iwl_dbgfs_stations_read(struct file *file , char *user_buf , size_t count ,
                                       loff_t *ppos ) 
{ 
  struct iwl_priv *priv ;
  struct iwl_station_entry *station ;
  struct iwl_tid_data *tid_data ;
  char *buf ;
  int i ;
  int j ;
  int pos ;
  ssize_t ret ;
  size_t bufsz ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  priv = (struct iwl_priv *)file->private_data;
  pos = 0;
  bufsz = (unsigned long )priv->num_stations * 500UL + 30UL;
  tmp = kmalloc(bufsz, 208U);
  buf = (char *)tmp;
  if ((unsigned long )buf == (unsigned long )((char *)0)) {
    return (-12L);
  } else {

  }
  tmp___0 = scnprintf(buf + (unsigned long )pos, bufsz - (unsigned long )pos, "num of stations: %d\n\n",
                      priv->num_stations);
  pos = tmp___0 + pos;
  i = 0;
  goto ldv_55056;
  ldv_55055: 
  station = (struct iwl_station_entry *)(& priv->stations) + (unsigned long )i;
  if ((unsigned int )station->used == 0U) {
    goto ldv_55051;
  } else {

  }
  tmp___1 = scnprintf(buf + (unsigned long )pos, bufsz - (unsigned long )pos, "station %d - addr: %pM, flags: %#x\n",
                      i, (u8 *)(& station->sta.sta.addr), station->sta.station_flags_msk);
  pos = tmp___1 + pos;
  tmp___2 = scnprintf(buf + (unsigned long )pos, bufsz - (unsigned long )pos, "TID seqno  next_rclmd rate_n_flags state txq\n");
  pos = tmp___2 + pos;
  j = 0;
  goto ldv_55053;
  ldv_55052: 
  tid_data = (struct iwl_tid_data *)(& priv->tid_data) + ((unsigned long )i + (unsigned long )j);
  tmp___3 = scnprintf(buf + (unsigned long )pos, bufsz - (unsigned long )pos, "%d:  0x%.4x 0x%.4x     0x%.8x   %d     %.2d",
                      j, (int )tid_data->seq_number, (int )tid_data->next_reclaimed,
                      tid_data->agg.rate_n_flags, (unsigned int )tid_data->agg.state,
                      (int )tid_data->agg.txq_id);
  pos = tmp___3 + pos;
  if ((int )tid_data->agg.wait_for_ba) {
    tmp___4 = scnprintf(buf + (unsigned long )pos, bufsz - (unsigned long )pos, " - waitforba");
    pos = tmp___4 + pos;
  } else {

  }
  tmp___5 = scnprintf(buf + (unsigned long )pos, bufsz - (unsigned long )pos, "\n");
  pos = tmp___5 + pos;
  j = j + 1;
  ldv_55053: ;
  if (j <= 7) {
    goto ldv_55052;
  } else {

  }
  tmp___6 = scnprintf(buf + (unsigned long )pos, bufsz - (unsigned long )pos, "\n");
  pos = tmp___6 + pos;
  ldv_55051: 
  i = i + 1;
  ldv_55056: ;
  if (i <= 15) {
    goto ldv_55055;
  } else {

  }
  ret = simple_read_from_buffer((void *)user_buf, count, ppos, (void const   *)buf,
                                (size_t )pos);
  kfree((void const   *)buf);
  return (ret);
}
}
static ssize_t iwl_dbgfs_nvm_read(struct file *file , char *user_buf , size_t count ,
                                  loff_t *ppos ) 
{ 
  ssize_t ret ;
  struct iwl_priv *priv ;
  int pos ;
  int ofs ;
    klee_make_symbolic(&ofs, sizeof(int), "ofs");
  int buf_size ;
  u8 const   *ptr ;
  char *buf ;
  u16 nvm_ver ;
  size_t eeprom_len ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;

  {
  priv = (struct iwl_priv *)file->private_data;
  pos = 0;
  ofs = 0;
  buf_size = 0;
  eeprom_len = priv->eeprom_blob_size;
  buf_size = (int )((unsigned int )(eeprom_len + 64UL) * 4U);
  if ((eeprom_len & 15UL) != 0UL) {
    return (-61L);
  } else {

  }
  ptr = (u8 const   *)priv->eeprom_blob;
  if ((unsigned long )ptr == (unsigned long )((u8 const   *)0U)) {
    return (-12L);
  } else {

  }
  tmp = kzalloc((size_t )buf_size, 208U);
  buf = (char *)tmp;
  if ((unsigned long )buf == (unsigned long )((char *)0)) {
    return (-12L);
  } else {

  }
  nvm_ver = (u16 )(priv->nvm_data)->nvm_version;
  tmp___0 = scnprintf(buf + (unsigned long )pos, (size_t )(buf_size - pos), "NVM version: 0x%x\n",
                      (int )nvm_ver);
  pos = tmp___0 + pos;
  ofs = 0;
  goto ldv_55074;
  ldv_55073: 
  tmp___1 = scnprintf(buf + (unsigned long )pos, (size_t )(buf_size - pos), "0x%.4x ",
                      ofs);
  pos = tmp___1 + pos;
  hex_dump_to_buffer((void const   *)ptr + (unsigned long )ofs, 16UL, 16, 2, buf + (unsigned long )pos,
                     (size_t )(buf_size - pos), 0);
  tmp___2 = strlen((char const   *)buf + (unsigned long )pos);
  pos = (int )((unsigned int )tmp___2 + (unsigned int )pos);
  if (buf_size - pos > 0) {
    tmp___3 = pos;
    pos = pos + 1;
    *(buf + (unsigned long )tmp___3) = 10;
  } else {

  }
  ofs = ofs + 16;
  ldv_55074: ;
  if ((size_t )ofs < eeprom_len) {
    goto ldv_55073;
  } else {

  }
  ret = simple_read_from_buffer((void *)user_buf, count, ppos, (void const   *)buf,
                                (size_t )pos);
  kfree((void const   *)buf);
  return (ret);
}
}
static ssize_t iwl_dbgfs_channels_read(struct file *file , char *user_buf , size_t count ,
                                       loff_t *ppos ) 
{ 
  struct iwl_priv *priv ;
  struct ieee80211_channel *channels ;
  struct ieee80211_supported_band  const  *supp_band ;
  int pos ;
  int i ;
  int bufsz ;
    klee_make_symbolic(&bufsz, sizeof(int), "bufsz");
  char *buf ;
  ssize_t ret ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  priv = (struct iwl_priv *)file->private_data;
  channels = (struct ieee80211_channel *)0;
  supp_band = (struct ieee80211_supported_band  const  *)0;
  pos = 0;
  bufsz = 4096;
  tmp = kzalloc((size_t )bufsz, 208U);
  buf = (char *)tmp;
  if ((unsigned long )buf == (unsigned long )((char *)0)) {
    return (-12L);
  } else {

  }
  supp_band = iwl_get_hw_mode(priv, 0);
  if ((unsigned long )supp_band != (unsigned long )((struct ieee80211_supported_band  const  *)0)) {
    channels = supp_band->channels;
    tmp___0 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "Displaying %d channels in 2.4GHz band 802.11bg):\n",
                        supp_band->n_channels);
    pos = tmp___0 + pos;
    i = 0;
    goto ldv_55091;
    ldv_55090: 
    tmp___1 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "%d: %ddBm: BSS%s%s, %s.\n",
                        (int )(channels + (unsigned long )i)->hw_value, (channels + (unsigned long )i)->max_power,
                        ((channels + (unsigned long )i)->flags & 8U) != 0U ? (char *)" (IEEE 802.11h required)" : (char *)"",
                        ((channels + (unsigned long )i)->flags & 2U) != 0U || ((channels + (unsigned long )i)->flags & 8U) != 0U ? (char *)"" : (char *)", IBSS",
                        ((channels + (unsigned long )i)->flags & 2U) != 0U ? (char *)"passive only" : (char *)"active/passive");
    pos = tmp___1 + pos;
    i = i + 1;
    ldv_55091: ;
    if ((int )supp_band->n_channels > i) {
      goto ldv_55090;
    } else {

    }

  } else {

  }
  supp_band = iwl_get_hw_mode(priv, 1);
  if ((unsigned long )supp_band != (unsigned long )((struct ieee80211_supported_band  const  *)0)) {
    channels = supp_band->channels;
    tmp___2 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "Displaying %d channels in 5.2GHz band (802.11a)\n",
                        supp_band->n_channels);
    pos = tmp___2 + pos;
    i = 0;
    goto ldv_55094;
    ldv_55093: 
    tmp___3 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "%d: %ddBm: BSS%s%s, %s.\n",
                        (int )(channels + (unsigned long )i)->hw_value, (channels + (unsigned long )i)->max_power,
                        ((channels + (unsigned long )i)->flags & 8U) != 0U ? (char *)" (IEEE 802.11h required)" : (char *)"",
                        ((channels + (unsigned long )i)->flags & 2U) != 0U || ((channels + (unsigned long )i)->flags & 8U) != 0U ? (char *)"" : (char *)", IBSS",
                        ((channels + (unsigned long )i)->flags & 2U) != 0U ? (char *)"passive only" : (char *)"active/passive");
    pos = tmp___3 + pos;
    i = i + 1;
    ldv_55094: ;
    if ((int )supp_band->n_channels > i) {
      goto ldv_55093;
    } else {

    }

  } else {

  }
  ret = simple_read_from_buffer((void *)user_buf, count, ppos, (void const   *)buf,
                                (size_t )pos);
  kfree((void const   *)buf);
  return (ret);
}
}
static ssize_t iwl_dbgfs_status_read(struct file *file , char *user_buf , size_t count ,
                                     loff_t *ppos ) 
{ 
  struct iwl_priv *priv ;
  char buf[512U] ;
  int pos ;
  size_t bufsz ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  ssize_t tmp___21 ;

  {
  priv = (struct iwl_priv *)file->private_data;
  pos = 0;
  bufsz = 512UL;
  tmp = constant_test_bit(0L, (unsigned long const volatile   *)(& priv->status));
  tmp___0 = scnprintf((char *)(& buf) + (unsigned long )pos, bufsz - (unsigned long )pos,
                      "STATUS_RF_KILL_HW:\t %d\n", tmp);
  pos = tmp___0 + pos;
  tmp___1 = constant_test_bit(1L, (unsigned long const volatile   *)(& priv->status));
  tmp___2 = scnprintf((char *)(& buf) + (unsigned long )pos, bufsz - (unsigned long )pos,
                      "STATUS_CT_KILL:\t\t %d\n", tmp___1);
  pos = tmp___2 + pos;
  tmp___3 = constant_test_bit(2L, (unsigned long const volatile   *)(& priv->status));
  tmp___4 = scnprintf((char *)(& buf) + (unsigned long )pos, bufsz - (unsigned long )pos,
                      "STATUS_ALIVE:\t\t %d\n", tmp___3);
  pos = tmp___4 + pos;
  tmp___5 = constant_test_bit(3L, (unsigned long const volatile   *)(& priv->status));
  tmp___6 = scnprintf((char *)(& buf) + (unsigned long )pos, bufsz - (unsigned long )pos,
                      "STATUS_READY:\t\t %d\n", tmp___5);
  pos = tmp___6 + pos;
  tmp___7 = constant_test_bit(5L, (unsigned long const volatile   *)(& priv->status));
  tmp___8 = scnprintf((char *)(& buf) + (unsigned long )pos, bufsz - (unsigned long )pos,
                      "STATUS_EXIT_PENDING:\t %d\n", tmp___7);
  pos = tmp___8 + pos;
  tmp___9 = constant_test_bit(6L, (unsigned long const volatile   *)(& priv->status));
  tmp___10 = scnprintf((char *)(& buf) + (unsigned long )pos, bufsz - (unsigned long )pos,
                       "STATUS_STATISTICS:\t %d\n", tmp___9);
  pos = tmp___10 + pos;
  tmp___11 = constant_test_bit(7L, (unsigned long const volatile   *)(& priv->status));
  tmp___12 = scnprintf((char *)(& buf) + (unsigned long )pos, bufsz - (unsigned long )pos,
                       "STATUS_SCANNING:\t %d\n", tmp___11);
  pos = tmp___12 + pos;
  tmp___13 = constant_test_bit(8L, (unsigned long const volatile   *)(& priv->status));
  tmp___14 = scnprintf((char *)(& buf) + (unsigned long )pos, bufsz - (unsigned long )pos,
                       "STATUS_SCAN_ABORTING:\t %d\n", tmp___13);
  pos = tmp___14 + pos;
  tmp___15 = constant_test_bit(9L, (unsigned long const volatile   *)(& priv->status));
  tmp___16 = scnprintf((char *)(& buf) + (unsigned long )pos, bufsz - (unsigned long )pos,
                       "STATUS_SCAN_HW:\t\t %d\n", tmp___15);
  pos = tmp___16 + pos;
  tmp___17 = constant_test_bit(13L, (unsigned long const volatile   *)(& priv->status));
  tmp___18 = scnprintf((char *)(& buf) + (unsigned long )pos, bufsz - (unsigned long )pos,
                       "STATUS_POWER_PMI:\t %d\n", tmp___17);
  pos = tmp___18 + pos;
  tmp___19 = constant_test_bit(10L, (unsigned long const volatile   *)(& priv->status));
  tmp___20 = scnprintf((char *)(& buf) + (unsigned long )pos, bufsz - (unsigned long )pos,
                       "STATUS_FW_ERROR:\t %d\n", tmp___19);
  pos = tmp___20 + pos;
  tmp___21 = simple_read_from_buffer((void *)user_buf, count, ppos, (void const   *)(& buf),
                                     (size_t )pos);
  return (tmp___21);
}
}
static ssize_t iwl_dbgfs_rx_handlers_read(struct file *file , char *user_buf , size_t count ,
                                          loff_t *ppos ) 
{ 
  struct iwl_priv *priv ;
  int pos ;
  int cnt ;
    klee_make_symbolic(&cnt, sizeof(int), "cnt");
  char *buf ;
  int bufsz ;
  ssize_t ret ;
  void *tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;

  {
  priv = (struct iwl_priv *)file->private_data;
  pos = 0;
  cnt = 0;
  bufsz = 1536;
  tmp = kzalloc((size_t )bufsz, 208U);
  buf = (char *)tmp;
  if ((unsigned long )buf == (unsigned long )((char *)0)) {
    return (-12L);
  } else {

  }
  cnt = 0;
  goto ldv_55119;
  ldv_55118: ;
  if (priv->rx_handlers_stats[cnt] != 0U) {
    tmp___0 = iwl_dvm_get_cmd_string((int )((u8 )cnt));
    tmp___1 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "\tRx handler[%36s]:\t\t %u\n",
                        tmp___0, priv->rx_handlers_stats[cnt]);
    pos = tmp___1 + pos;
  } else {

  }
  cnt = cnt + 1;
  ldv_55119: ;
  if (cnt <= 254) {
    goto ldv_55118;
  } else {

  }
  ret = simple_read_from_buffer((void *)user_buf, count, ppos, (void const   *)buf,
                                (size_t )pos);
  kfree((void const   *)buf);
  return (ret);
}
}
static ssize_t iwl_dbgfs_rx_handlers_write(struct file *file , char const   *user_buf ,
                                           size_t count , loff_t *ppos ) 
{ 
  struct iwl_priv *priv ;
  char buf[8U] ;
  int buf_size ;
  u32 reset_flag ;
  size_t _min1 ;
  unsigned long _min2 ;
  unsigned long tmp ;
  int tmp___0 ;

  {
  priv = (struct iwl_priv *)file->private_data;
  memset((void *)(& buf), 0, 8UL);
  _min1 = count;
  _min2 = 7UL;
  buf_size = (int )(_min1 < _min2 ? _min1 : _min2);
  tmp = copy_from_user((void *)(& buf), (void const   *)user_buf, (unsigned long )buf_size);
  if (tmp != 0UL) {
    return (-14L);
  } else {

  }
  tmp___0 = sscanf((char const   *)(& buf), "%x", & reset_flag);
  if (tmp___0 != 1) {
    return (-14L);
  } else {

  }
  if (reset_flag == 0U) {
    memset((void *)(& priv->rx_handlers_stats), 0, 1020UL);
  } else {

  }
  return ((ssize_t )count);
}
}
static ssize_t iwl_dbgfs_qos_read(struct file *file , char *user_buf , size_t count ,
                                  loff_t *ppos ) 
{ 
  struct iwl_priv *priv ;
  struct iwl_rxon_context *ctx ;
  int pos ;
  int i ;
  char buf[512U] ;
  size_t bufsz ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  ssize_t tmp___3 ;

  {
  priv = (struct iwl_priv *)file->private_data;
  pos = 0;
  bufsz = 512UL;
  ctx = (struct iwl_rxon_context *)(& priv->contexts);
  goto ldv_55150;
  ldv_55149: ;
  if ((int )((unsigned long )priv->valid_contexts >> (int )ctx->ctxid) & 1) {
    tmp = scnprintf((char *)(& buf) + (unsigned long )pos, bufsz - (unsigned long )pos,
                    "context %d:\n", (unsigned int )ctx->ctxid);
    pos = tmp + pos;
    i = 0;
    goto ldv_55147;
    ldv_55146: 
    tmp___0 = scnprintf((char *)(& buf) + (unsigned long )pos, bufsz - (unsigned long )pos,
                        "\tcw_min\tcw_max\taifsn\ttxop\n");
    pos = tmp___0 + pos;
    tmp___1 = scnprintf((char *)(& buf) + (unsigned long )pos, bufsz - (unsigned long )pos,
                        "AC[%d]\t%u\t%u\t%u\t%u\n", i, (int )ctx->qos_data.def_qos_parm.ac[i].cw_min,
                        (int )ctx->qos_data.def_qos_parm.ac[i].cw_max, (int )ctx->qos_data.def_qos_parm.ac[i].aifsn,
                        (int )ctx->qos_data.def_qos_parm.ac[i].edca_txop);
    pos = tmp___1 + pos;
    i = i + 1;
    ldv_55147: ;
    if (i <= 3) {
      goto ldv_55146;
    } else {

    }
    tmp___2 = scnprintf((char *)(& buf) + (unsigned long )pos, bufsz - (unsigned long )pos,
                        "\n");
    pos = tmp___2 + pos;
  } else {

  }
  ctx = ctx + 1;
  ldv_55150: ;
  if ((unsigned long )((struct iwl_rxon_context *)(& priv->contexts) + 2UL) > (unsigned long )ctx) {
    goto ldv_55149;
  } else {

  }
  tmp___3 = simple_read_from_buffer((void *)user_buf, count, ppos, (void const   *)(& buf),
                                    (size_t )pos);
  return (tmp___3);
}
}
static ssize_t iwl_dbgfs_thermal_throttling_read(struct file *file , char *user_buf ,
                                                 size_t count , loff_t *ppos ) 
{ 
  struct iwl_priv *priv ;
  struct iwl_tt_mgmt *tt ;
  struct iwl_tt_restriction *restriction ;
  char buf[100U] ;
  int pos ;
  size_t bufsz ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  ssize_t tmp___4 ;

  {
  priv = (struct iwl_priv *)file->private_data;
  tt = & priv->thermal_throttle;
  pos = 0;
  bufsz = 100UL;
  tmp = scnprintf((char *)(& buf) + (unsigned long )pos, bufsz - (unsigned long )pos,
                  "Thermal Throttling Mode: %s\n", (int )tt->advanced_tt ? (char *)"Advance" : (char *)"Legacy");
  pos = tmp + pos;
  tmp___0 = scnprintf((char *)(& buf) + (unsigned long )pos, bufsz - (unsigned long )pos,
                      "Thermal Throttling State: %d\n", (unsigned int )tt->state);
  pos = tmp___0 + pos;
  if ((int )tt->advanced_tt) {
    restriction = tt->restriction + (unsigned long )tt->state;
    tmp___1 = scnprintf((char *)(& buf) + (unsigned long )pos, bufsz - (unsigned long )pos,
                        "Tx mode: %d\n", (unsigned int )restriction->tx_stream);
    pos = tmp___1 + pos;
    tmp___2 = scnprintf((char *)(& buf) + (unsigned long )pos, bufsz - (unsigned long )pos,
                        "Rx mode: %d\n", (unsigned int )restriction->rx_stream);
    pos = tmp___2 + pos;
    tmp___3 = scnprintf((char *)(& buf) + (unsigned long )pos, bufsz - (unsigned long )pos,
                        "HT mode: %d\n", (int )restriction->is_ht);
    pos = tmp___3 + pos;
  } else {

  }
  tmp___4 = simple_read_from_buffer((void *)user_buf, count, ppos, (void const   *)(& buf),
                                    (size_t )pos);
  return (tmp___4);
}
}
static ssize_t iwl_dbgfs_disable_ht40_write(struct file *file , char const   *user_buf ,
                                            size_t count , loff_t *ppos ) 
{ 
  struct iwl_priv *priv ;
  char buf[8U] ;
  int buf_size ;
  int ht40 ;
    klee_make_symbolic(&ht40, sizeof(int), "ht40");
  size_t _min1 ;
  unsigned long _min2 ;
  unsigned long tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  priv = (struct iwl_priv *)file->private_data;
  memset((void *)(& buf), 0, 8UL);
  _min1 = count;
  _min2 = 7UL;
  buf_size = (int )(_min1 < _min2 ? _min1 : _min2);
  tmp = copy_from_user((void *)(& buf), (void const   *)user_buf, (unsigned long )buf_size);
  if (tmp != 0UL) {
    return (-14L);
  } else {

  }
  tmp___0 = sscanf((char const   *)(& buf), "%d", & ht40);
  if (tmp___0 != 1) {
    return (-14L);
  } else {

  }
  tmp___1 = iwl_is_any_associated___3(priv);
  if (tmp___1 == 0) {
    priv->disable_ht40 = ht40 != 0;
  } else {
    return (-22L);
  }
  return ((ssize_t )count);
}
}
static ssize_t iwl_dbgfs_disable_ht40_read(struct file *file , char *user_buf , size_t count ,
                                           loff_t *ppos ) 
{ 
  struct iwl_priv *priv ;
  char buf[100U] ;
  int pos ;
  size_t bufsz ;
  int tmp ;
  ssize_t tmp___0 ;

  {
  priv = (struct iwl_priv *)file->private_data;
  pos = 0;
  bufsz = 100UL;
  tmp = scnprintf((char *)(& buf) + (unsigned long )pos, bufsz - (unsigned long )pos,
                  "11n 40MHz Mode: %s\n", (int )priv->disable_ht40 ? (char *)"Disabled" : (char *)"Enabled");
  pos = tmp + pos;
  tmp___0 = simple_read_from_buffer((void *)user_buf, count, ppos, (void const   *)(& buf),
                                    (size_t )pos);
  return (tmp___0);
}
}
static ssize_t iwl_dbgfs_temperature_read(struct file *file , char *user_buf , size_t count ,
                                          loff_t *ppos ) 
{ 
  struct iwl_priv *priv ;
  char buf[8U] ;
  int pos ;
  size_t bufsz ;
  int tmp ;
  ssize_t tmp___0 ;

  {
  priv = (struct iwl_priv *)file->private_data;
  pos = 0;
  bufsz = 8UL;
  tmp = scnprintf((char *)(& buf) + (unsigned long )pos, bufsz - (unsigned long )pos,
                  "%d\n", priv->temperature);
  pos = tmp + pos;
  tmp___0 = simple_read_from_buffer((void *)user_buf, count, ppos, (void const   *)(& buf),
                                    (size_t )pos);
  return (tmp___0);
}
}
static ssize_t iwl_dbgfs_sleep_level_override_write(struct file *file , char const   *user_buf ,
                                                    size_t count , loff_t *ppos ) 
{ 
  struct iwl_priv *priv ;
  char buf[8U] ;
  int buf_size ;
  int value ;
  size_t _min1 ;
  unsigned long _min2 ;
  unsigned long tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  priv = (struct iwl_priv *)file->private_data;
  memset((void *)(& buf), 0, 8UL);
  _min1 = count;
  _min2 = 7UL;
  buf_size = (int )(_min1 < _min2 ? _min1 : _min2);
  tmp = copy_from_user((void *)(& buf), (void const   *)user_buf, (unsigned long )buf_size);
  if (tmp != 0UL) {
    return (-14L);
  } else {

  }
  tmp___0 = sscanf((char const   *)(& buf), "%d", & value);
  if (tmp___0 != 1) {
    return (-22L);
  } else {

  }
  if (value == 0) {
    return (-22L);
  } else
  if (value > 0) {
    value = value + -1;
  } else {

  }
  if (value != -1 && (value < 0 || value > 4)) {
    return (-22L);
  } else {

  }
  tmp___1 = iwl_is_ready_rf(priv);
  if (tmp___1 == 0) {
    return (-11L);
  } else {

  }
  priv->power_data.debug_sleep_level_override = value;
  mutex_lock_nested(& priv->mutex, 0U);
  iwl_power_update_mode(priv, 1);
  mutex_unlock(& priv->mutex);
  return ((ssize_t )count);
}
}
static ssize_t iwl_dbgfs_sleep_level_override_read(struct file *file , char *user_buf ,
                                                   size_t count , loff_t *ppos ) 
{ 
  struct iwl_priv *priv ;
  char buf[10U] ;
  int pos ;
  int value ;
  size_t bufsz ;
  ssize_t tmp ;

  {
  priv = (struct iwl_priv *)file->private_data;
  bufsz = 10UL;
  value = priv->power_data.debug_sleep_level_override;
  if (value >= 0) {
    value = value + 1;
  } else {

  }
  pos = scnprintf((char *)(& buf), bufsz, "%d\n", value);
  tmp = simple_read_from_buffer((void *)user_buf, count, ppos, (void const   *)(& buf),
                                (size_t )pos);
  return (tmp);
}
}
static ssize_t iwl_dbgfs_current_sleep_command_read(struct file *file , char *user_buf ,
                                                    size_t count , loff_t *ppos ) 
{ 
  struct iwl_priv *priv ;
  char buf[200U] ;
  int pos ;
  int i ;
  size_t bufsz ;
  struct iwl_powertable_cmd *cmd ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  ssize_t tmp___2 ;

  {
  priv = (struct iwl_priv *)file->private_data;
  pos = 0;
  bufsz = 200UL;
  cmd = & priv->power_data.sleep_cmd;
  tmp = scnprintf((char *)(& buf) + (unsigned long )pos, bufsz - (unsigned long )pos,
                  "flags: %#.2x\n", (int )cmd->flags);
  pos = tmp + pos;
  tmp___0 = scnprintf((char *)(& buf) + (unsigned long )pos, bufsz - (unsigned long )pos,
                      "RX/TX timeout: %d/%d usec\n", cmd->rx_data_timeout, cmd->tx_data_timeout);
  pos = tmp___0 + pos;
  i = 0;
  goto ldv_55234;
  ldv_55233: 
  tmp___1 = scnprintf((char *)(& buf) + (unsigned long )pos, bufsz - (unsigned long )pos,
                      "sleep_interval[%d]: %d\n", i, cmd->sleep_interval[i]);
  pos = tmp___1 + pos;
  i = i + 1;
  ldv_55234: ;
  if (i <= 4) {
    goto ldv_55233;
  } else {

  }
  tmp___2 = simple_read_from_buffer((void *)user_buf, count, ppos, (void const   *)(& buf),
                                    (size_t )pos);
  return (tmp___2);
}
}
static struct file_operations  const  iwl_dbgfs_sram_ops  = 
     {0, & generic_file_llseek, & iwl_dbgfs_sram_read, & iwl_dbgfs_sram_write, 0, 0,
    0, 0, 0, 0, 0, 0, & simple_open, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
static struct file_operations  const  iwl_dbgfs_wowlan_sram_ops  = 
     {0, & generic_file_llseek, & iwl_dbgfs_wowlan_sram_read, 0, 0, 0, 0, 0, 0, 0, 0,
    0, & simple_open, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
static struct file_operations  const  iwl_dbgfs_nvm_ops  = 
     {0, & generic_file_llseek, & iwl_dbgfs_nvm_read, 0, 0, 0, 0, 0, 0, 0, 0, 0, & simple_open,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
static struct file_operations  const  iwl_dbgfs_stations_ops  = 
     {0, & generic_file_llseek, & iwl_dbgfs_stations_read, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    & simple_open, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
static struct file_operations  const  iwl_dbgfs_channels_ops  = 
     {0, & generic_file_llseek, & iwl_dbgfs_channels_read, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    & simple_open, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
static struct file_operations  const  iwl_dbgfs_status_ops  = 
     {0, & generic_file_llseek, & iwl_dbgfs_status_read, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    & simple_open, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
static struct file_operations  const  iwl_dbgfs_rx_handlers_ops  = 
     {0, & generic_file_llseek, & iwl_dbgfs_rx_handlers_read, & iwl_dbgfs_rx_handlers_write,
    0, 0, 0, 0, 0, 0, 0, 0, & simple_open, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0};
static struct file_operations  const  iwl_dbgfs_qos_ops  = 
     {0, & generic_file_llseek, & iwl_dbgfs_qos_read, 0, 0, 0, 0, 0, 0, 0, 0, 0, & simple_open,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
static struct file_operations  const  iwl_dbgfs_thermal_throttling_ops  = 
     {0, & generic_file_llseek, & iwl_dbgfs_thermal_throttling_read, 0, 0, 0, 0, 0,
    0, 0, 0, 0, & simple_open, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
static struct file_operations  const  iwl_dbgfs_disable_ht40_ops  = 
     {0, & generic_file_llseek, & iwl_dbgfs_disable_ht40_read, & iwl_dbgfs_disable_ht40_write,
    0, 0, 0, 0, 0, 0, 0, 0, & simple_open, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0};
static struct file_operations  const  iwl_dbgfs_temperature_ops  = 
     {0, & generic_file_llseek, & iwl_dbgfs_temperature_read, 0, 0, 0, 0, 0, 0, 0, 0,
    0, & simple_open, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
static struct file_operations  const  iwl_dbgfs_sleep_level_override_ops  = 
     {0, & generic_file_llseek, & iwl_dbgfs_sleep_level_override_read, & iwl_dbgfs_sleep_level_override_write,
    0, 0, 0, 0, 0, 0, 0, 0, & simple_open, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0};
static struct file_operations  const  iwl_dbgfs_current_sleep_command_ops  = 
     {0, & generic_file_llseek, & iwl_dbgfs_current_sleep_command_read, 0, 0, 0, 0,
    0, 0, 0, 0, 0, & simple_open, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
static char const   *fmt_value  =    "  %-30s %10u\n";
static char const   *fmt_hex  =    "  %-30s       0x%02X\n";
static char const   *fmt_table  =    "  %-30s %10u  %10u  %10u  %10u\n";
static char const   *fmt_header  =    "%-32s    current  cumulative       delta         max\n";
static int iwl_statistics_flag(struct iwl_priv *priv , char *buf , int bufsz ) 
{ 
  int p ;
  u32 flag ;
  int __ret_warn_on ;
  int tmp ;
  int tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  p = 0;
  if (debug_locks != 0) {
    tmp = lock_is_held(& priv->statistics.lock.__annonCompField18.__annonCompField17.dep_map);
    if (tmp == 0) {
      tmp___0 = 1;
    } else {
      tmp___0 = 0;
    }
  } else {
    tmp___0 = 0;
  }
  __ret_warn_on = tmp___0;
  tmp___1 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp___1 != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--08_1a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/12002/dscv_tempdir/dscv/ri/08_1a/drivers/net/wireless/iwlwifi/dvm/debugfs.c",
                       697);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  flag = priv->statistics.flag;
  tmp___2 = scnprintf(buf + (unsigned long )p, (size_t )(bufsz - p), "Statistics Flag(0x%X):\n",
                      flag);
  p = tmp___2 + p;
  if ((int )flag & 1) {
    tmp___3 = scnprintf(buf + (unsigned long )p, (size_t )(bufsz - p), "\tStatistics have been cleared\n");
    p = tmp___3 + p;
  } else {

  }
  tmp___4 = scnprintf(buf + (unsigned long )p, (size_t )(bufsz - p), "\tOperational Frequency: %s\n",
                      (flag & 2U) != 0U ? (char *)"2.4 GHz" : (char *)"5.2 GHz");
  p = tmp___4 + p;
  tmp___5 = scnprintf(buf + (unsigned long )p, (size_t )(bufsz - p), "\tTGj Narrow Band: %s\n",
                      (flag & 4U) != 0U ? (char *)"enabled" : (char *)"disabled");
  p = tmp___5 + p;
  return (p);
}
}
static ssize_t iwl_dbgfs_ucode_rx_stats_read(struct file *file , char *user_buf ,
                                             size_t count , loff_t *ppos ) 
{ 
  struct iwl_priv *priv ;
  int pos ;
  char *buf ;
  int bufsz ;
  ssize_t ret ;
  struct statistics_rx_phy *ofdm ;
  struct statistics_rx_phy *accum_ofdm ;
  struct statistics_rx_phy *delta_ofdm ;
  struct statistics_rx_phy *max_ofdm ;
  struct statistics_rx_phy *cck ;
  struct statistics_rx_phy *accum_cck ;
  struct statistics_rx_phy *delta_cck ;
  struct statistics_rx_phy *max_cck ;
  struct statistics_rx_non_phy *general ;
  struct statistics_rx_non_phy *accum_general ;
  struct statistics_rx_non_phy *delta_general ;
  struct statistics_rx_non_phy *max_general ;
  struct statistics_rx_ht_phy *ht ;
  struct statistics_rx_ht_phy *accum_ht ;
  struct statistics_rx_ht_phy *delta_ht ;
  struct statistics_rx_ht_phy *max_ht ;
  int tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
    klee_make_symbolic(&tmp___29, sizeof(int), "tmp___29");
  int tmp___30 ;
    klee_make_symbolic(&tmp___30, sizeof(int), "tmp___30");
  int tmp___31 ;
    klee_make_symbolic(&tmp___31, sizeof(int), "tmp___31");
  int tmp___32 ;
    klee_make_symbolic(&tmp___32, sizeof(int), "tmp___32");
  int tmp___33 ;
    klee_make_symbolic(&tmp___33, sizeof(int), "tmp___33");
  int tmp___34 ;
  int tmp___35 ;
    klee_make_symbolic(&tmp___35, sizeof(int), "tmp___35");
  int tmp___36 ;
    klee_make_symbolic(&tmp___36, sizeof(int), "tmp___36");
  int tmp___37 ;
    klee_make_symbolic(&tmp___37, sizeof(int), "tmp___37");
  int tmp___38 ;
    klee_make_symbolic(&tmp___38, sizeof(int), "tmp___38");
  int tmp___39 ;
    klee_make_symbolic(&tmp___39, sizeof(int), "tmp___39");
  int tmp___40 ;
    klee_make_symbolic(&tmp___40, sizeof(int), "tmp___40");
  int tmp___41 ;
    klee_make_symbolic(&tmp___41, sizeof(int), "tmp___41");
  int tmp___42 ;
    klee_make_symbolic(&tmp___42, sizeof(int), "tmp___42");
  int tmp___43 ;
    klee_make_symbolic(&tmp___43, sizeof(int), "tmp___43");
  int tmp___44 ;
    klee_make_symbolic(&tmp___44, sizeof(int), "tmp___44");
  int tmp___45 ;
    klee_make_symbolic(&tmp___45, sizeof(int), "tmp___45");
  int tmp___46 ;
    klee_make_symbolic(&tmp___46, sizeof(int), "tmp___46");
  int tmp___47 ;
    klee_make_symbolic(&tmp___47, sizeof(int), "tmp___47");
  int tmp___48 ;
    klee_make_symbolic(&tmp___48, sizeof(int), "tmp___48");
  int tmp___49 ;
    klee_make_symbolic(&tmp___49, sizeof(int), "tmp___49");
  int tmp___50 ;
    klee_make_symbolic(&tmp___50, sizeof(int), "tmp___50");
  int tmp___51 ;
    klee_make_symbolic(&tmp___51, sizeof(int), "tmp___51");
  int tmp___52 ;
    klee_make_symbolic(&tmp___52, sizeof(int), "tmp___52");
  int tmp___53 ;
    klee_make_symbolic(&tmp___53, sizeof(int), "tmp___53");
  int tmp___54 ;
    klee_make_symbolic(&tmp___54, sizeof(int), "tmp___54");
  int tmp___55 ;
    klee_make_symbolic(&tmp___55, sizeof(int), "tmp___55");
  int tmp___56 ;
    klee_make_symbolic(&tmp___56, sizeof(int), "tmp___56");
  int tmp___57 ;
    klee_make_symbolic(&tmp___57, sizeof(int), "tmp___57");
  int tmp___58 ;
    klee_make_symbolic(&tmp___58, sizeof(int), "tmp___58");
  int tmp___59 ;
    klee_make_symbolic(&tmp___59, sizeof(int), "tmp___59");
  int tmp___60 ;
    klee_make_symbolic(&tmp___60, sizeof(int), "tmp___60");
  int tmp___61 ;
    klee_make_symbolic(&tmp___61, sizeof(int), "tmp___61");
  int tmp___62 ;
    klee_make_symbolic(&tmp___62, sizeof(int), "tmp___62");
  int tmp___63 ;
    klee_make_symbolic(&tmp___63, sizeof(int), "tmp___63");
  int tmp___64 ;
    klee_make_symbolic(&tmp___64, sizeof(int), "tmp___64");
  int tmp___65 ;
    klee_make_symbolic(&tmp___65, sizeof(int), "tmp___65");
  int tmp___66 ;
    klee_make_symbolic(&tmp___66, sizeof(int), "tmp___66");
  int tmp___67 ;
    klee_make_symbolic(&tmp___67, sizeof(int), "tmp___67");
  int tmp___68 ;
    klee_make_symbolic(&tmp___68, sizeof(int), "tmp___68");
  int tmp___69 ;
    klee_make_symbolic(&tmp___69, sizeof(int), "tmp___69");
  int tmp___70 ;
    klee_make_symbolic(&tmp___70, sizeof(int), "tmp___70");
  int tmp___71 ;
    klee_make_symbolic(&tmp___71, sizeof(int), "tmp___71");
  int tmp___72 ;
    klee_make_symbolic(&tmp___72, sizeof(int), "tmp___72");
  int tmp___73 ;
    klee_make_symbolic(&tmp___73, sizeof(int), "tmp___73");
  int tmp___74 ;
    klee_make_symbolic(&tmp___74, sizeof(int), "tmp___74");

  {
  priv = (struct iwl_priv *)file->private_data;
  pos = 0;
  bufsz = 8560;
  tmp = iwl_is_alive(priv);
  if (tmp == 0) {
    return (-11L);
  } else {

  }
  tmp___0 = kzalloc((size_t )bufsz, 208U);
  buf = (char *)tmp___0;
  if ((unsigned long )buf == (unsigned long )((char *)0)) {
    return (-12L);
  } else {

  }
  spin_lock_bh(& priv->statistics.lock);
  ofdm = & priv->statistics.rx_ofdm;
  cck = & priv->statistics.rx_cck;
  general = & priv->statistics.rx_non_phy;
  ht = & priv->statistics.rx_ofdm_ht;
  accum_ofdm = & priv->accum_stats.rx_ofdm;
  accum_cck = & priv->accum_stats.rx_cck;
  accum_general = & priv->accum_stats.rx_non_phy;
  accum_ht = & priv->accum_stats.rx_ofdm_ht;
  delta_ofdm = & priv->delta_stats.rx_ofdm;
  delta_cck = & priv->delta_stats.rx_cck;
  delta_general = & priv->delta_stats.rx_non_phy;
  delta_ht = & priv->delta_stats.rx_ofdm_ht;
  max_ofdm = & priv->max_delta_stats.rx_ofdm;
  max_cck = & priv->max_delta_stats.rx_cck;
  max_general = & priv->max_delta_stats.rx_non_phy;
  max_ht = & priv->max_delta_stats.rx_ofdm_ht;
  tmp___1 = iwl_statistics_flag(priv, buf, bufsz);
  pos = tmp___1 + pos;
  tmp___2 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_header,
                      (char *)"Statistics_Rx - OFDM:");
  pos = tmp___2 + pos;
  tmp___3 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                      (char *)"ina_cnt:", ofdm->ina_cnt, accum_ofdm->ina_cnt, delta_ofdm->ina_cnt,
                      max_ofdm->ina_cnt);
  pos = tmp___3 + pos;
  tmp___4 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                      (char *)"fina_cnt:", ofdm->fina_cnt, accum_ofdm->fina_cnt, delta_ofdm->fina_cnt,
                      max_ofdm->fina_cnt);
  pos = tmp___4 + pos;
  tmp___5 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                      (char *)"plcp_err:", ofdm->plcp_err, accum_ofdm->plcp_err, delta_ofdm->plcp_err,
                      max_ofdm->plcp_err);
  pos = tmp___5 + pos;
  tmp___6 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                      (char *)"crc32_err:", ofdm->crc32_err, accum_ofdm->crc32_err,
                      delta_ofdm->crc32_err, max_ofdm->crc32_err);
  pos = tmp___6 + pos;
  tmp___7 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                      (char *)"overrun_err:", ofdm->overrun_err, accum_ofdm->overrun_err,
                      delta_ofdm->overrun_err, max_ofdm->overrun_err);
  pos = tmp___7 + pos;
  tmp___8 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                      (char *)"early_overrun_err:", ofdm->early_overrun_err, accum_ofdm->early_overrun_err,
                      delta_ofdm->early_overrun_err, max_ofdm->early_overrun_err);
  pos = tmp___8 + pos;
  tmp___9 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                      (char *)"crc32_good:", ofdm->crc32_good, accum_ofdm->crc32_good,
                      delta_ofdm->crc32_good, max_ofdm->crc32_good);
  pos = tmp___9 + pos;
  tmp___10 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"false_alarm_cnt:", ofdm->false_alarm_cnt, accum_ofdm->false_alarm_cnt,
                       delta_ofdm->false_alarm_cnt, max_ofdm->false_alarm_cnt);
  pos = tmp___10 + pos;
  tmp___11 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"fina_sync_err_cnt:", ofdm->fina_sync_err_cnt, accum_ofdm->fina_sync_err_cnt,
                       delta_ofdm->fina_sync_err_cnt, max_ofdm->fina_sync_err_cnt);
  pos = tmp___11 + pos;
  tmp___12 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"sfd_timeout:", ofdm->sfd_timeout, accum_ofdm->sfd_timeout,
                       delta_ofdm->sfd_timeout, max_ofdm->sfd_timeout);
  pos = tmp___12 + pos;
  tmp___13 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"fina_timeout:", ofdm->fina_timeout, accum_ofdm->fina_timeout,
                       delta_ofdm->fina_timeout, max_ofdm->fina_timeout);
  pos = tmp___13 + pos;
  tmp___14 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"unresponded_rts:", ofdm->unresponded_rts, accum_ofdm->unresponded_rts,
                       delta_ofdm->unresponded_rts, max_ofdm->unresponded_rts);
  pos = tmp___14 + pos;
  tmp___15 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"rxe_frame_lmt_ovrun:", ofdm->rxe_frame_limit_overrun,
                       accum_ofdm->rxe_frame_limit_overrun, delta_ofdm->rxe_frame_limit_overrun,
                       max_ofdm->rxe_frame_limit_overrun);
  pos = tmp___15 + pos;
  tmp___16 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"sent_ack_cnt:", ofdm->sent_ack_cnt, accum_ofdm->sent_ack_cnt,
                       delta_ofdm->sent_ack_cnt, max_ofdm->sent_ack_cnt);
  pos = tmp___16 + pos;
  tmp___17 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"sent_cts_cnt:", ofdm->sent_cts_cnt, accum_ofdm->sent_cts_cnt,
                       delta_ofdm->sent_cts_cnt, max_ofdm->sent_cts_cnt);
  pos = tmp___17 + pos;
  tmp___18 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"sent_ba_rsp_cnt:", ofdm->sent_ba_rsp_cnt, accum_ofdm->sent_ba_rsp_cnt,
                       delta_ofdm->sent_ba_rsp_cnt, max_ofdm->sent_ba_rsp_cnt);
  pos = tmp___18 + pos;
  tmp___19 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"dsp_self_kill:", ofdm->dsp_self_kill, accum_ofdm->dsp_self_kill,
                       delta_ofdm->dsp_self_kill, max_ofdm->dsp_self_kill);
  pos = tmp___19 + pos;
  tmp___20 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"mh_format_err:", ofdm->mh_format_err, accum_ofdm->mh_format_err,
                       delta_ofdm->mh_format_err, max_ofdm->mh_format_err);
  pos = tmp___20 + pos;
  tmp___21 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"re_acq_main_rssi_sum:", ofdm->re_acq_main_rssi_sum,
                       accum_ofdm->re_acq_main_rssi_sum, delta_ofdm->re_acq_main_rssi_sum,
                       max_ofdm->re_acq_main_rssi_sum);
  pos = tmp___21 + pos;
  tmp___22 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_header,
                       (char *)"Statistics_Rx - CCK:");
  pos = tmp___22 + pos;
  tmp___23 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"ina_cnt:", cck->ina_cnt, accum_cck->ina_cnt, delta_cck->ina_cnt,
                       max_cck->ina_cnt);
  pos = tmp___23 + pos;
  tmp___24 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"fina_cnt:", cck->fina_cnt, accum_cck->fina_cnt, delta_cck->fina_cnt,
                       max_cck->fina_cnt);
  pos = tmp___24 + pos;
  tmp___25 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"plcp_err:", cck->plcp_err, accum_cck->plcp_err, delta_cck->plcp_err,
                       max_cck->plcp_err);
  pos = tmp___25 + pos;
  tmp___26 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"crc32_err:", cck->crc32_err, accum_cck->crc32_err,
                       delta_cck->crc32_err, max_cck->crc32_err);
  pos = tmp___26 + pos;
  tmp___27 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"overrun_err:", cck->overrun_err, accum_cck->overrun_err,
                       delta_cck->overrun_err, max_cck->overrun_err);
  pos = tmp___27 + pos;
  tmp___28 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"early_overrun_err:", cck->early_overrun_err, accum_cck->early_overrun_err,
                       delta_cck->early_overrun_err, max_cck->early_overrun_err);
  pos = tmp___28 + pos;
  tmp___29 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"crc32_good:", cck->crc32_good, accum_cck->crc32_good,
                       delta_cck->crc32_good, max_cck->crc32_good);
  pos = tmp___29 + pos;
  tmp___30 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"false_alarm_cnt:", cck->false_alarm_cnt, accum_cck->false_alarm_cnt,
                       delta_cck->false_alarm_cnt, max_cck->false_alarm_cnt);
  pos = tmp___30 + pos;
  tmp___31 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"fina_sync_err_cnt:", cck->fina_sync_err_cnt, accum_cck->fina_sync_err_cnt,
                       delta_cck->fina_sync_err_cnt, max_cck->fina_sync_err_cnt);
  pos = tmp___31 + pos;
  tmp___32 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"sfd_timeout:", cck->sfd_timeout, accum_cck->sfd_timeout,
                       delta_cck->sfd_timeout, max_cck->sfd_timeout);
  pos = tmp___32 + pos;
  tmp___33 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"fina_timeout:", cck->fina_timeout, accum_cck->fina_timeout,
                       delta_cck->fina_timeout, max_cck->fina_timeout);
  pos = tmp___33 + pos;
  tmp___34 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"unresponded_rts:", cck->unresponded_rts, accum_cck->unresponded_rts,
                       delta_cck->unresponded_rts, max_cck->unresponded_rts);
  pos = tmp___34 + pos;
  tmp___35 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"rxe_frame_lmt_ovrun:", cck->rxe_frame_limit_overrun,
                       accum_cck->rxe_frame_limit_overrun, delta_cck->rxe_frame_limit_overrun,
                       max_cck->rxe_frame_limit_overrun);
  pos = tmp___35 + pos;
  tmp___36 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"sent_ack_cnt:", cck->sent_ack_cnt, accum_cck->sent_ack_cnt,
                       delta_cck->sent_ack_cnt, max_cck->sent_ack_cnt);
  pos = tmp___36 + pos;
  tmp___37 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"sent_cts_cnt:", cck->sent_cts_cnt, accum_cck->sent_cts_cnt,
                       delta_cck->sent_cts_cnt, max_cck->sent_cts_cnt);
  pos = tmp___37 + pos;
  tmp___38 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"sent_ba_rsp_cnt:", cck->sent_ba_rsp_cnt, accum_cck->sent_ba_rsp_cnt,
                       delta_cck->sent_ba_rsp_cnt, max_cck->sent_ba_rsp_cnt);
  pos = tmp___38 + pos;
  tmp___39 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"dsp_self_kill:", cck->dsp_self_kill, accum_cck->dsp_self_kill,
                       delta_cck->dsp_self_kill, max_cck->dsp_self_kill);
  pos = tmp___39 + pos;
  tmp___40 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"mh_format_err:", cck->mh_format_err, accum_cck->mh_format_err,
                       delta_cck->mh_format_err, max_cck->mh_format_err);
  pos = tmp___40 + pos;
  tmp___41 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"re_acq_main_rssi_sum:", cck->re_acq_main_rssi_sum,
                       accum_cck->re_acq_main_rssi_sum, delta_cck->re_acq_main_rssi_sum,
                       max_cck->re_acq_main_rssi_sum);
  pos = tmp___41 + pos;
  tmp___42 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_header,
                       (char *)"Statistics_Rx - GENERAL:");
  pos = tmp___42 + pos;
  tmp___43 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"bogus_cts:", general->bogus_cts, accum_general->bogus_cts,
                       delta_general->bogus_cts, max_general->bogus_cts);
  pos = tmp___43 + pos;
  tmp___44 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"bogus_ack:", general->bogus_ack, accum_general->bogus_ack,
                       delta_general->bogus_ack, max_general->bogus_ack);
  pos = tmp___44 + pos;
  tmp___45 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"non_bssid_frames:", general->non_bssid_frames, accum_general->non_bssid_frames,
                       delta_general->non_bssid_frames, max_general->non_bssid_frames);
  pos = tmp___45 + pos;
  tmp___46 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"filtered_frames:", general->filtered_frames, accum_general->filtered_frames,
                       delta_general->filtered_frames, max_general->filtered_frames);
  pos = tmp___46 + pos;
  tmp___47 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"non_channel_beacons:", general->non_channel_beacons,
                       accum_general->non_channel_beacons, delta_general->non_channel_beacons,
                       max_general->non_channel_beacons);
  pos = tmp___47 + pos;
  tmp___48 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"channel_beacons:", general->channel_beacons, accum_general->channel_beacons,
                       delta_general->channel_beacons, max_general->channel_beacons);
  pos = tmp___48 + pos;
  tmp___49 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"num_missed_bcon:", general->num_missed_bcon, accum_general->num_missed_bcon,
                       delta_general->num_missed_bcon, max_general->num_missed_bcon);
  pos = tmp___49 + pos;
  tmp___50 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"adc_rx_saturation_time:", general->adc_rx_saturation_time,
                       accum_general->adc_rx_saturation_time, delta_general->adc_rx_saturation_time,
                       max_general->adc_rx_saturation_time);
  pos = tmp___50 + pos;
  tmp___51 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"ina_detect_search_tm:", general->ina_detection_search_time,
                       accum_general->ina_detection_search_time, delta_general->ina_detection_search_time,
                       max_general->ina_detection_search_time);
  pos = tmp___51 + pos;
  tmp___52 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"beacon_silence_rssi_a:", general->beacon_silence_rssi_a,
                       accum_general->beacon_silence_rssi_a, delta_general->beacon_silence_rssi_a,
                       max_general->beacon_silence_rssi_a);
  pos = tmp___52 + pos;
  tmp___53 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"beacon_silence_rssi_b:", general->beacon_silence_rssi_b,
                       accum_general->beacon_silence_rssi_b, delta_general->beacon_silence_rssi_b,
                       max_general->beacon_silence_rssi_b);
  pos = tmp___53 + pos;
  tmp___54 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"beacon_silence_rssi_c:", general->beacon_silence_rssi_c,
                       accum_general->beacon_silence_rssi_c, delta_general->beacon_silence_rssi_c,
                       max_general->beacon_silence_rssi_c);
  pos = tmp___54 + pos;
  tmp___55 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"interference_data_flag:", general->interference_data_flag,
                       accum_general->interference_data_flag, delta_general->interference_data_flag,
                       max_general->interference_data_flag);
  pos = tmp___55 + pos;
  tmp___56 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"channel_load:", general->channel_load, accum_general->channel_load,
                       delta_general->channel_load, max_general->channel_load);
  pos = tmp___56 + pos;
  tmp___57 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"dsp_false_alarms:", general->dsp_false_alarms, accum_general->dsp_false_alarms,
                       delta_general->dsp_false_alarms, max_general->dsp_false_alarms);
  pos = tmp___57 + pos;
  tmp___58 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"beacon_rssi_a:", general->beacon_rssi_a, accum_general->beacon_rssi_a,
                       delta_general->beacon_rssi_a, max_general->beacon_rssi_a);
  pos = tmp___58 + pos;
  tmp___59 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"beacon_rssi_b:", general->beacon_rssi_b, accum_general->beacon_rssi_b,
                       delta_general->beacon_rssi_b, max_general->beacon_rssi_b);
  pos = tmp___59 + pos;
  tmp___60 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"beacon_rssi_c:", general->beacon_rssi_c, accum_general->beacon_rssi_c,
                       delta_general->beacon_rssi_c, max_general->beacon_rssi_c);
  pos = tmp___60 + pos;
  tmp___61 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"beacon_energy_a:", general->beacon_energy_a, accum_general->beacon_energy_a,
                       delta_general->beacon_energy_a, max_general->beacon_energy_a);
  pos = tmp___61 + pos;
  tmp___62 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"beacon_energy_b:", general->beacon_energy_b, accum_general->beacon_energy_b,
                       delta_general->beacon_energy_b, max_general->beacon_energy_b);
  pos = tmp___62 + pos;
  tmp___63 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"beacon_energy_c:", general->beacon_energy_c, accum_general->beacon_energy_c,
                       delta_general->beacon_energy_c, max_general->beacon_energy_c);
  pos = tmp___63 + pos;
  tmp___64 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_header,
                       (char *)"Statistics_Rx - OFDM_HT:");
  pos = tmp___64 + pos;
  tmp___65 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"plcp_err:", ht->plcp_err, accum_ht->plcp_err, delta_ht->plcp_err,
                       max_ht->plcp_err);
  pos = tmp___65 + pos;
  tmp___66 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"overrun_err:", ht->overrun_err, accum_ht->overrun_err,
                       delta_ht->overrun_err, max_ht->overrun_err);
  pos = tmp___66 + pos;
  tmp___67 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"early_overrun_err:", ht->early_overrun_err, accum_ht->early_overrun_err,
                       delta_ht->early_overrun_err, max_ht->early_overrun_err);
  pos = tmp___67 + pos;
  tmp___68 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"crc32_good:", ht->crc32_good, accum_ht->crc32_good,
                       delta_ht->crc32_good, max_ht->crc32_good);
  pos = tmp___68 + pos;
  tmp___69 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"crc32_err:", ht->crc32_err, accum_ht->crc32_err, delta_ht->crc32_err,
                       max_ht->crc32_err);
  pos = tmp___69 + pos;
  tmp___70 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"mh_format_err:", ht->mh_format_err, accum_ht->mh_format_err,
                       delta_ht->mh_format_err, max_ht->mh_format_err);
  pos = tmp___70 + pos;
  tmp___71 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"agg_crc32_good:", ht->agg_crc32_good, accum_ht->agg_crc32_good,
                       delta_ht->agg_crc32_good, max_ht->agg_crc32_good);
  pos = tmp___71 + pos;
  tmp___72 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"agg_mpdu_cnt:", ht->agg_mpdu_cnt, accum_ht->agg_mpdu_cnt,
                       delta_ht->agg_mpdu_cnt, max_ht->agg_mpdu_cnt);
  pos = tmp___72 + pos;
  tmp___73 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"agg_cnt:", ht->agg_cnt, accum_ht->agg_cnt, delta_ht->agg_cnt,
                       max_ht->agg_cnt);
  pos = tmp___73 + pos;
  tmp___74 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"unsupport_mcs:", ht->unsupport_mcs, accum_ht->unsupport_mcs,
                       delta_ht->unsupport_mcs, max_ht->unsupport_mcs);
  pos = tmp___74 + pos;
  spin_unlock_bh(& priv->statistics.lock);
  ret = simple_read_from_buffer((void *)user_buf, count, ppos, (void const   *)buf,
                                (size_t )pos);
  kfree((void const   *)buf);
  return (ret);
}
}
static ssize_t iwl_dbgfs_ucode_tx_stats_read(struct file *file , char *user_buf ,
                                             size_t count , loff_t *ppos ) 
{ 
  struct iwl_priv *priv ;
  int pos ;
  char *buf ;
  int bufsz ;
  ssize_t ret ;
  struct statistics_tx *tx ;
  struct statistics_tx *accum_tx ;
  struct statistics_tx *delta_tx ;
  struct statistics_tx *max_tx ;
  int tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;

  {
  priv = (struct iwl_priv *)file->private_data;
  pos = 0;
  bufsz = 5242;
  tmp = iwl_is_alive(priv);
  if (tmp == 0) {
    return (-11L);
  } else {

  }
  tmp___0 = kzalloc((size_t )bufsz, 208U);
  buf = (char *)tmp___0;
  if ((unsigned long )buf == (unsigned long )((char *)0)) {
    return (-12L);
  } else {

  }
  spin_lock_bh(& priv->statistics.lock);
  tx = & priv->statistics.tx;
  accum_tx = & priv->accum_stats.tx;
  delta_tx = & priv->delta_stats.tx;
  max_tx = & priv->max_delta_stats.tx;
  tmp___1 = iwl_statistics_flag(priv, buf, bufsz);
  pos = tmp___1 + pos;
  tmp___2 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_header,
                      (char *)"Statistics_Tx:");
  pos = tmp___2 + pos;
  tmp___3 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                      (char *)"preamble:", tx->preamble_cnt, accum_tx->preamble_cnt,
                      delta_tx->preamble_cnt, max_tx->preamble_cnt);
  pos = tmp___3 + pos;
  tmp___4 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                      (char *)"rx_detected_cnt:", tx->rx_detected_cnt, accum_tx->rx_detected_cnt,
                      delta_tx->rx_detected_cnt, max_tx->rx_detected_cnt);
  pos = tmp___4 + pos;
  tmp___5 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                      (char *)"bt_prio_defer_cnt:", tx->bt_prio_defer_cnt, accum_tx->bt_prio_defer_cnt,
                      delta_tx->bt_prio_defer_cnt, max_tx->bt_prio_defer_cnt);
  pos = tmp___5 + pos;
  tmp___6 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                      (char *)"bt_prio_kill_cnt:", tx->bt_prio_kill_cnt, accum_tx->bt_prio_kill_cnt,
                      delta_tx->bt_prio_kill_cnt, max_tx->bt_prio_kill_cnt);
  pos = tmp___6 + pos;
  tmp___7 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                      (char *)"few_bytes_cnt:", tx->few_bytes_cnt, accum_tx->few_bytes_cnt,
                      delta_tx->few_bytes_cnt, max_tx->few_bytes_cnt);
  pos = tmp___7 + pos;
  tmp___8 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                      (char *)"cts_timeout:", tx->cts_timeout, accum_tx->cts_timeout,
                      delta_tx->cts_timeout, max_tx->cts_timeout);
  pos = tmp___8 + pos;
  tmp___9 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                      (char *)"ack_timeout:", tx->ack_timeout, accum_tx->ack_timeout,
                      delta_tx->ack_timeout, max_tx->ack_timeout);
  pos = tmp___9 + pos;
  tmp___10 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"expected_ack_cnt:", tx->expected_ack_cnt, accum_tx->expected_ack_cnt,
                       delta_tx->expected_ack_cnt, max_tx->expected_ack_cnt);
  pos = tmp___10 + pos;
  tmp___11 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"actual_ack_cnt:", tx->actual_ack_cnt, accum_tx->actual_ack_cnt,
                       delta_tx->actual_ack_cnt, max_tx->actual_ack_cnt);
  pos = tmp___11 + pos;
  tmp___12 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"dump_msdu_cnt:", tx->dump_msdu_cnt, accum_tx->dump_msdu_cnt,
                       delta_tx->dump_msdu_cnt, max_tx->dump_msdu_cnt);
  pos = tmp___12 + pos;
  tmp___13 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"abort_nxt_frame_mismatch:", tx->burst_abort_next_frame_mismatch_cnt,
                       accum_tx->burst_abort_next_frame_mismatch_cnt, delta_tx->burst_abort_next_frame_mismatch_cnt,
                       max_tx->burst_abort_next_frame_mismatch_cnt);
  pos = tmp___13 + pos;
  tmp___14 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"abort_missing_nxt_frame:", tx->burst_abort_missing_next_frame_cnt,
                       accum_tx->burst_abort_missing_next_frame_cnt, delta_tx->burst_abort_missing_next_frame_cnt,
                       max_tx->burst_abort_missing_next_frame_cnt);
  pos = tmp___14 + pos;
  tmp___15 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"cts_timeout_collision:", tx->cts_timeout_collision,
                       accum_tx->cts_timeout_collision, delta_tx->cts_timeout_collision,
                       max_tx->cts_timeout_collision);
  pos = tmp___15 + pos;
  tmp___16 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"ack_ba_timeout_collision:", tx->ack_or_ba_timeout_collision,
                       accum_tx->ack_or_ba_timeout_collision, delta_tx->ack_or_ba_timeout_collision,
                       max_tx->ack_or_ba_timeout_collision);
  pos = tmp___16 + pos;
  tmp___17 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"agg ba_timeout:", tx->agg.ba_timeout, accum_tx->agg.ba_timeout,
                       delta_tx->agg.ba_timeout, max_tx->agg.ba_timeout);
  pos = tmp___17 + pos;
  tmp___18 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"agg ba_resched_frames:", tx->agg.ba_reschedule_frames,
                       accum_tx->agg.ba_reschedule_frames, delta_tx->agg.ba_reschedule_frames,
                       max_tx->agg.ba_reschedule_frames);
  pos = tmp___18 + pos;
  tmp___19 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"agg scd_query_agg_frame:", tx->agg.scd_query_agg_frame_cnt,
                       accum_tx->agg.scd_query_agg_frame_cnt, delta_tx->agg.scd_query_agg_frame_cnt,
                       max_tx->agg.scd_query_agg_frame_cnt);
  pos = tmp___19 + pos;
  tmp___20 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"agg scd_query_no_agg:", tx->agg.scd_query_no_agg,
                       accum_tx->agg.scd_query_no_agg, delta_tx->agg.scd_query_no_agg,
                       max_tx->agg.scd_query_no_agg);
  pos = tmp___20 + pos;
  tmp___21 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"agg scd_query_agg:", tx->agg.scd_query_agg, accum_tx->agg.scd_query_agg,
                       delta_tx->agg.scd_query_agg, max_tx->agg.scd_query_agg);
  pos = tmp___21 + pos;
  tmp___22 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"agg scd_query_mismatch:", tx->agg.scd_query_mismatch,
                       accum_tx->agg.scd_query_mismatch, delta_tx->agg.scd_query_mismatch,
                       max_tx->agg.scd_query_mismatch);
  pos = tmp___22 + pos;
  tmp___23 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"agg frame_not_ready:", tx->agg.frame_not_ready, accum_tx->agg.frame_not_ready,
                       delta_tx->agg.frame_not_ready, max_tx->agg.frame_not_ready);
  pos = tmp___23 + pos;
  tmp___24 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"agg underrun:", tx->agg.underrun, accum_tx->agg.underrun,
                       delta_tx->agg.underrun, max_tx->agg.underrun);
  pos = tmp___24 + pos;
  tmp___25 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"agg bt_prio_kill:", tx->agg.bt_prio_kill, accum_tx->agg.bt_prio_kill,
                       delta_tx->agg.bt_prio_kill, max_tx->agg.bt_prio_kill);
  pos = tmp___25 + pos;
  tmp___26 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"agg rx_ba_rsp_cnt:", tx->agg.rx_ba_rsp_cnt, accum_tx->agg.rx_ba_rsp_cnt,
                       delta_tx->agg.rx_ba_rsp_cnt, max_tx->agg.rx_ba_rsp_cnt);
  pos = tmp___26 + pos;
  if (((unsigned int )tx->tx_power.ant_a != 0U || (unsigned int )tx->tx_power.ant_b != 0U) || (unsigned int )tx->tx_power.ant_c != 0U) {
    tmp___27 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "tx power: (1/2 dB step)\n");
    pos = tmp___27 + pos;
    if ((int )(priv->nvm_data)->valid_tx_ant & 1 && (unsigned int )tx->tx_power.ant_a != 0U) {
      tmp___28 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_hex,
                           (char *)"antenna A:", (int )tx->tx_power.ant_a);
      pos = tmp___28 + pos;
    } else {

    }
    if (((unsigned long )(priv->nvm_data)->valid_tx_ant & 2UL) != 0UL && (unsigned int )tx->tx_power.ant_b != 0U) {
      tmp___29 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_hex,
                           (char *)"antenna B:", (int )tx->tx_power.ant_b);
      pos = tmp___29 + pos;
    } else {

    }
    if (((unsigned long )(priv->nvm_data)->valid_tx_ant & 4UL) != 0UL && (unsigned int )tx->tx_power.ant_c != 0U) {
      tmp___30 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_hex,
                           (char *)"antenna C:", (int )tx->tx_power.ant_c);
      pos = tmp___30 + pos;
    } else {

    }
  } else {

  }
  spin_unlock_bh(& priv->statistics.lock);
  ret = simple_read_from_buffer((void *)user_buf, count, ppos, (void const   *)buf,
                                (size_t )pos);
  kfree((void const   *)buf);
  return (ret);
}
}
static ssize_t iwl_dbgfs_ucode_general_stats_read(struct file *file , char *user_buf ,
                                                  size_t count , loff_t *ppos ) 
{ 
  struct iwl_priv *priv ;
  int pos ;
  char *buf ;
  int bufsz ;
  ssize_t ret ;
  struct statistics_general_common *general ;
  struct statistics_general_common *accum_general ;
  struct statistics_general_common *delta_general ;
  struct statistics_general_common *max_general ;
  struct statistics_dbg *dbg ;
  struct statistics_dbg *accum_dbg ;
  struct statistics_dbg *delta_dbg ;
  struct statistics_dbg *max_dbg ;
  struct statistics_div *div ;
  struct statistics_div *accum_div ;
  struct statistics_div *delta_div ;
  struct statistics_div *max_div ;
  int tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;

  {
  priv = (struct iwl_priv *)file->private_data;
  pos = 0;
  bufsz = 1180;
  tmp = iwl_is_alive(priv);
  if (tmp == 0) {
    return (-11L);
  } else {

  }
  tmp___0 = kzalloc((size_t )bufsz, 208U);
  buf = (char *)tmp___0;
  if ((unsigned long )buf == (unsigned long )((char *)0)) {
    return (-12L);
  } else {

  }
  spin_lock_bh(& priv->statistics.lock);
  general = & priv->statistics.common;
  dbg = & priv->statistics.common.dbg;
  div = & priv->statistics.common.div;
  accum_general = & priv->accum_stats.common;
  accum_dbg = & priv->accum_stats.common.dbg;
  accum_div = & priv->accum_stats.common.div;
  delta_general = & priv->delta_stats.common;
  max_general = & priv->max_delta_stats.common;
  delta_dbg = & priv->delta_stats.common.dbg;
  max_dbg = & priv->max_delta_stats.common.dbg;
  delta_div = & priv->delta_stats.common.div;
  max_div = & priv->max_delta_stats.common.div;
  tmp___1 = iwl_statistics_flag(priv, buf, bufsz);
  pos = tmp___1 + pos;
  tmp___2 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_header,
                      (char *)"Statistics_General:");
  pos = tmp___2 + pos;
  tmp___3 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_value,
                      (char *)"temperature:", general->temperature);
  pos = tmp___3 + pos;
  tmp___4 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_value,
                      (char *)"temperature_m:", general->temperature_m);
  pos = tmp___4 + pos;
  tmp___5 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_value,
                      (char *)"ttl_timestamp:", general->ttl_timestamp);
  pos = tmp___5 + pos;
  tmp___6 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                      (char *)"burst_check:", dbg->burst_check, accum_dbg->burst_check,
                      delta_dbg->burst_check, max_dbg->burst_check);
  pos = tmp___6 + pos;
  tmp___7 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                      (char *)"burst_count:", dbg->burst_count, accum_dbg->burst_count,
                      delta_dbg->burst_count, max_dbg->burst_count);
  pos = tmp___7 + pos;
  tmp___8 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                      (char *)"wait_for_silence_timeout_count:", dbg->wait_for_silence_timeout_cnt,
                      accum_dbg->wait_for_silence_timeout_cnt, delta_dbg->wait_for_silence_timeout_cnt,
                      max_dbg->wait_for_silence_timeout_cnt);
  pos = tmp___8 + pos;
  tmp___9 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                      (char *)"sleep_time:", general->sleep_time, accum_general->sleep_time,
                      delta_general->sleep_time, max_general->sleep_time);
  pos = tmp___9 + pos;
  tmp___10 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"slots_out:", general->slots_out, accum_general->slots_out,
                       delta_general->slots_out, max_general->slots_out);
  pos = tmp___10 + pos;
  tmp___11 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"slots_idle:", general->slots_idle, accum_general->slots_idle,
                       delta_general->slots_idle, max_general->slots_idle);
  pos = tmp___11 + pos;
  tmp___12 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"tx_on_a:", div->tx_on_a, accum_div->tx_on_a, delta_div->tx_on_a,
                       max_div->tx_on_a);
  pos = tmp___12 + pos;
  tmp___13 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"tx_on_b:", div->tx_on_b, accum_div->tx_on_b, delta_div->tx_on_b,
                       max_div->tx_on_b);
  pos = tmp___13 + pos;
  tmp___14 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"exec_time:", div->exec_time, accum_div->exec_time,
                       delta_div->exec_time, max_div->exec_time);
  pos = tmp___14 + pos;
  tmp___15 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"probe_time:", div->probe_time, accum_div->probe_time,
                       delta_div->probe_time, max_div->probe_time);
  pos = tmp___15 + pos;
  tmp___16 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"rx_enable_counter:", general->rx_enable_counter, accum_general->rx_enable_counter,
                       delta_general->rx_enable_counter, max_general->rx_enable_counter);
  pos = tmp___16 + pos;
  tmp___17 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), fmt_table,
                       (char *)"num_of_sos_states:", general->num_of_sos_states, accum_general->num_of_sos_states,
                       delta_general->num_of_sos_states, max_general->num_of_sos_states);
  pos = tmp___17 + pos;
  spin_unlock_bh(& priv->statistics.lock);
  ret = simple_read_from_buffer((void *)user_buf, count, ppos, (void const   *)buf,
                                (size_t )pos);
  kfree((void const   *)buf);
  return (ret);
}
}
static ssize_t iwl_dbgfs_ucode_bt_stats_read(struct file *file , char *user_buf ,
                                             size_t count , loff_t *ppos ) 
{ 
  struct iwl_priv *priv ;
  int pos ;
  char *buf ;
  int bufsz ;
  ssize_t ret ;
  struct statistics_bt_activity *bt ;
  struct statistics_bt_activity *accum_bt ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;

  {
  priv = (struct iwl_priv *)file->private_data;
  pos = 0;
  bufsz = 968;
  tmp = iwl_is_alive(priv);
  if (tmp == 0) {
    return (-11L);
  } else {

  }
  if ((unsigned int )priv->bt_enable_flag == 0U) {
    return (-22L);
  } else {

  }
  mutex_lock_nested(& priv->mutex, 0U);
  tmp___0 = iwl_send_statistics_request(priv, 0, 0);
  ret = (ssize_t )tmp___0;
  mutex_unlock(& priv->mutex);
  if (ret != 0L) {
    return (-11L);
  } else {

  }
  tmp___1 = kzalloc((size_t )bufsz, 208U);
  buf = (char *)tmp___1;
  if ((unsigned long )buf == (unsigned long )((char *)0)) {
    return (-12L);
  } else {

  }
  spin_lock_bh(& priv->statistics.lock);
  bt = & priv->statistics.bt_activity;
  accum_bt = & priv->accum_stats.bt_activity;
  tmp___2 = iwl_statistics_flag(priv, buf, bufsz);
  pos = tmp___2 + pos;
  tmp___3 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "Statistics_BT:\n");
  pos = tmp___3 + pos;
  tmp___4 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "\t\t\tcurrent\t\t\taccumulative\n");
  pos = tmp___4 + pos;
  tmp___5 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "hi_priority_tx_req_cnt:\t\t%u\t\t\t%u\n",
                      bt->hi_priority_tx_req_cnt, accum_bt->hi_priority_tx_req_cnt);
  pos = tmp___5 + pos;
  tmp___6 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "hi_priority_tx_denied_cnt:\t%u\t\t\t%u\n",
                      bt->hi_priority_tx_denied_cnt, accum_bt->hi_priority_tx_denied_cnt);
  pos = tmp___6 + pos;
  tmp___7 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "lo_priority_tx_req_cnt:\t\t%u\t\t\t%u\n",
                      bt->lo_priority_tx_req_cnt, accum_bt->lo_priority_tx_req_cnt);
  pos = tmp___7 + pos;
  tmp___8 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "lo_priority_tx_denied_cnt:\t%u\t\t\t%u\n",
                      bt->lo_priority_tx_denied_cnt, accum_bt->lo_priority_tx_denied_cnt);
  pos = tmp___8 + pos;
  tmp___9 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "hi_priority_rx_req_cnt:\t\t%u\t\t\t%u\n",
                      bt->hi_priority_rx_req_cnt, accum_bt->hi_priority_rx_req_cnt);
  pos = tmp___9 + pos;
  tmp___10 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "hi_priority_rx_denied_cnt:\t%u\t\t\t%u\n",
                       bt->hi_priority_rx_denied_cnt, accum_bt->hi_priority_rx_denied_cnt);
  pos = tmp___10 + pos;
  tmp___11 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "lo_priority_rx_req_cnt:\t\t%u\t\t\t%u\n",
                       bt->lo_priority_rx_req_cnt, accum_bt->lo_priority_rx_req_cnt);
  pos = tmp___11 + pos;
  tmp___12 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "lo_priority_rx_denied_cnt:\t%u\t\t\t%u\n",
                       bt->lo_priority_rx_denied_cnt, accum_bt->lo_priority_rx_denied_cnt);
  pos = tmp___12 + pos;
  tmp___13 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "(rx)num_bt_kills:\t\t%u\t\t\t%u\n",
                       priv->statistics.num_bt_kills, priv->statistics.accum_num_bt_kills);
  pos = tmp___13 + pos;
  spin_unlock_bh(& priv->statistics.lock);
  ret = simple_read_from_buffer((void *)user_buf, count, ppos, (void const   *)buf,
                                (size_t )pos);
  kfree((void const   *)buf);
  return (ret);
}
}
static ssize_t iwl_dbgfs_reply_tx_error_read(struct file *file , char *user_buf ,
                                             size_t count , loff_t *ppos ) 
{ 
  struct iwl_priv *priv ;
  int pos ;
  char *buf ;
  int bufsz ;
  ssize_t ret ;
  int tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;
  char const   *tmp___4 ;
  int tmp___5 ;
  char const   *tmp___6 ;
  int tmp___7 ;
  char const   *tmp___8 ;
  int tmp___9 ;
  char const   *tmp___10 ;
  int tmp___11 ;
  char const   *tmp___12 ;
  int tmp___13 ;
  char const   *tmp___14 ;
  int tmp___15 ;
  char const   *tmp___16 ;
  int tmp___17 ;
  char const   *tmp___18 ;
  int tmp___19 ;
  char const   *tmp___20 ;
  int tmp___21 ;
  char const   *tmp___22 ;
  int tmp___23 ;
  char const   *tmp___24 ;
  int tmp___25 ;
  char const   *tmp___26 ;
  int tmp___27 ;
  char const   *tmp___28 ;
  int tmp___29 ;
  char const   *tmp___30 ;
  int tmp___31 ;
  char const   *tmp___32 ;
  int tmp___33 ;
  char const   *tmp___34 ;
  int tmp___35 ;
  char const   *tmp___36 ;
  int tmp___37 ;
  char const   *tmp___38 ;
  int tmp___39 ;
  char const   *tmp___40 ;
  int tmp___41 ;
  char const   *tmp___42 ;
  int tmp___43 ;
  char const   *tmp___44 ;
  int tmp___45 ;
  int tmp___46 ;
  int tmp___47 ;
  char const   *tmp___48 ;
  int tmp___49 ;
  char const   *tmp___50 ;
  int tmp___51 ;
  char const   *tmp___52 ;
  int tmp___53 ;
  char const   *tmp___54 ;
  int tmp___55 ;
  char const   *tmp___56 ;
  int tmp___57 ;
  char const   *tmp___58 ;
  int tmp___59 ;
  char const   *tmp___60 ;
  int tmp___61 ;
  char const   *tmp___62 ;
  int tmp___63 ;
  char const   *tmp___64 ;
  int tmp___65 ;
  char const   *tmp___66 ;
  int tmp___67 ;
  char const   *tmp___68 ;
  int tmp___69 ;
  char const   *tmp___70 ;
  int tmp___71 ;
  int tmp___72 ;

  {
  priv = (struct iwl_priv *)file->private_data;
  pos = 0;
  bufsz = 3656;
  tmp = iwl_is_alive(priv);
  if (tmp == 0) {
    return (-11L);
  } else {

  }
  tmp___0 = kzalloc((size_t )bufsz, 208U);
  buf = (char *)tmp___0;
  if ((unsigned long )buf == (unsigned long )((char *)0)) {
    return (-12L);
  } else {

  }
  tmp___1 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "Statistics_TX_Error:\n");
  pos = tmp___1 + pos;
  tmp___2 = iwl_get_tx_fail_reason(64U);
  tmp___3 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "%s:\t\t\t\t%u\n",
                      tmp___2, priv->reply_tx_stats.pp_delay);
  pos = tmp___3 + pos;
  tmp___4 = iwl_get_tx_fail_reason(65U);
  tmp___5 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "%s:\t\t\t%u\n",
                      tmp___4, priv->reply_tx_stats.pp_few_bytes);
  pos = tmp___5 + pos;
  tmp___6 = iwl_get_tx_fail_reason(66U);
  tmp___7 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "%s:\t\t\t%u\n",
                      tmp___6, priv->reply_tx_stats.pp_bt_prio);
  pos = tmp___7 + pos;
  tmp___8 = iwl_get_tx_fail_reason(67U);
  tmp___9 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "%s:\t\t\t%u\n",
                      tmp___8, priv->reply_tx_stats.pp_quiet_period);
  pos = tmp___9 + pos;
  tmp___10 = iwl_get_tx_fail_reason(68U);
  tmp___11 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "%s:\t\t\t%u\n",
                       tmp___10, priv->reply_tx_stats.pp_calc_ttak);
  pos = tmp___11 + pos;
  tmp___12 = iwl_get_tx_fail_reason(129U);
  tmp___13 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "%s:\t\t%u\n",
                       tmp___12, priv->reply_tx_stats.int_crossed_retry);
  pos = tmp___13 + pos;
  tmp___14 = iwl_get_tx_fail_reason(130U);
  tmp___15 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "%s:\t\t\t%u\n",
                       tmp___14, priv->reply_tx_stats.short_limit);
  pos = tmp___15 + pos;
  tmp___16 = iwl_get_tx_fail_reason(131U);
  tmp___17 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "%s:\t\t\t%u\n",
                       tmp___16, priv->reply_tx_stats.long_limit);
  pos = tmp___17 + pos;
  tmp___18 = iwl_get_tx_fail_reason(132U);
  tmp___19 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "%s:\t\t\t%u\n",
                       tmp___18, priv->reply_tx_stats.fifo_underrun);
  pos = tmp___19 + pos;
  tmp___20 = iwl_get_tx_fail_reason(133U);
  tmp___21 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "%s:\t\t\t%u\n",
                       tmp___20, priv->reply_tx_stats.drain_flow);
  pos = tmp___21 + pos;
  tmp___22 = iwl_get_tx_fail_reason(134U);
  tmp___23 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "%s:\t\t\t%u\n",
                       tmp___22, priv->reply_tx_stats.rfkill_flush);
  pos = tmp___23 + pos;
  tmp___24 = iwl_get_tx_fail_reason(135U);
  tmp___25 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "%s:\t\t\t%u\n",
                       tmp___24, priv->reply_tx_stats.life_expire);
  pos = tmp___25 + pos;
  tmp___26 = iwl_get_tx_fail_reason(136U);
  tmp___27 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "%s:\t\t\t%u\n",
                       tmp___26, priv->reply_tx_stats.dest_ps);
  pos = tmp___27 + pos;
  tmp___28 = iwl_get_tx_fail_reason(137U);
  tmp___29 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "%s:\t\t\t%u\n",
                       tmp___28, priv->reply_tx_stats.host_abort);
  pos = tmp___29 + pos;
  tmp___30 = iwl_get_tx_fail_reason(138U);
  tmp___31 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "%s:\t\t\t%u\n",
                       tmp___30, priv->reply_tx_stats.pp_delay);
  pos = tmp___31 + pos;
  tmp___32 = iwl_get_tx_fail_reason(139U);
  tmp___33 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "%s:\t\t\t%u\n",
                       tmp___32, priv->reply_tx_stats.sta_invalid);
  pos = tmp___33 + pos;
  tmp___34 = iwl_get_tx_fail_reason(140U);
  tmp___35 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "%s:\t\t\t%u\n",
                       tmp___34, priv->reply_tx_stats.frag_drop);
  pos = tmp___35 + pos;
  tmp___36 = iwl_get_tx_fail_reason(141U);
  tmp___37 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "%s:\t\t\t%u\n",
                       tmp___36, priv->reply_tx_stats.tid_disable);
  pos = tmp___37 + pos;
  tmp___38 = iwl_get_tx_fail_reason(142U);
  tmp___39 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "%s:\t\t\t%u\n",
                       tmp___38, priv->reply_tx_stats.fifo_flush);
  pos = tmp___39 + pos;
  tmp___40 = iwl_get_tx_fail_reason(143U);
  tmp___41 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "%s:\t\t%u\n",
                       tmp___40, priv->reply_tx_stats.insuff_cf_poll);
  pos = tmp___41 + pos;
  tmp___42 = iwl_get_tx_fail_reason(144U);
  tmp___43 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "%s:\t\t\t%u\n",
                       tmp___42, priv->reply_tx_stats.fail_hw_drop);
  pos = tmp___43 + pos;
  tmp___44 = iwl_get_tx_fail_reason(145U);
  tmp___45 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "%s:\t\t%u\n",
                       tmp___44, priv->reply_tx_stats.sta_color_mismatch);
  pos = tmp___45 + pos;
  tmp___46 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "UNKNOWN:\t\t\t%u\n",
                       priv->reply_tx_stats.unknown);
  pos = tmp___46 + pos;
  tmp___47 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "\nStatistics_Agg_TX_Error:\n");
  pos = tmp___47 + pos;
  tmp___48 = iwl_get_agg_tx_fail_reason(1);
  tmp___49 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "%s:\t\t\t%u\n",
                       tmp___48, priv->reply_agg_tx_stats.underrun);
  pos = tmp___49 + pos;
  tmp___50 = iwl_get_agg_tx_fail_reason(2);
  tmp___51 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "%s:\t\t\t%u\n",
                       tmp___50, priv->reply_agg_tx_stats.bt_prio);
  pos = tmp___51 + pos;
  tmp___52 = iwl_get_agg_tx_fail_reason(4);
  tmp___53 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "%s:\t\t\t%u\n",
                       tmp___52, priv->reply_agg_tx_stats.few_bytes);
  pos = tmp___53 + pos;
  tmp___54 = iwl_get_agg_tx_fail_reason(8);
  tmp___55 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "%s:\t\t\t%u\n",
                       tmp___54, priv->reply_agg_tx_stats.abort);
  pos = tmp___55 + pos;
  tmp___56 = iwl_get_agg_tx_fail_reason(16);
  tmp___57 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "%s:\t\t%u\n",
                       tmp___56, priv->reply_agg_tx_stats.last_sent_ttl);
  pos = tmp___57 + pos;
  tmp___58 = iwl_get_agg_tx_fail_reason(32);
  tmp___59 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "%s:\t\t%u\n",
                       tmp___58, priv->reply_agg_tx_stats.last_sent_try);
  pos = tmp___59 + pos;
  tmp___60 = iwl_get_agg_tx_fail_reason(64);
  tmp___61 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "%s:\t\t%u\n",
                       tmp___60, priv->reply_agg_tx_stats.last_sent_bt_kill);
  pos = tmp___61 + pos;
  tmp___62 = iwl_get_agg_tx_fail_reason(128);
  tmp___63 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "%s:\t\t\t%u\n",
                       tmp___62, priv->reply_agg_tx_stats.scd_query);
  pos = tmp___63 + pos;
  tmp___64 = iwl_get_agg_tx_fail_reason(256);
  tmp___65 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "%s:\t\t%u\n",
                       tmp___64, priv->reply_agg_tx_stats.bad_crc32);
  pos = tmp___65 + pos;
  tmp___66 = iwl_get_agg_tx_fail_reason(511);
  tmp___67 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "%s:\t\t\t%u\n",
                       tmp___66, priv->reply_agg_tx_stats.response);
  pos = tmp___67 + pos;
  tmp___68 = iwl_get_agg_tx_fail_reason(512);
  tmp___69 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "%s:\t\t\t%u\n",
                       tmp___68, priv->reply_agg_tx_stats.dump_tx);
  pos = tmp___69 + pos;
  tmp___70 = iwl_get_agg_tx_fail_reason(1024);
  tmp___71 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "%s:\t\t\t%u\n",
                       tmp___70, priv->reply_agg_tx_stats.delay_tx);
  pos = tmp___71 + pos;
  tmp___72 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "UNKNOWN:\t\t\t%u\n",
                       priv->reply_agg_tx_stats.unknown);
  pos = tmp___72 + pos;
  ret = simple_read_from_buffer((void *)user_buf, count, ppos, (void const   *)buf,
                                (size_t )pos);
  kfree((void const   *)buf);
  return (ret);
}
}
static ssize_t iwl_dbgfs_sensitivity_read(struct file *file , char *user_buf , size_t count ,
                                          loff_t *ppos ) 
{ 
  struct iwl_priv *priv ;
  int pos ;
  int cnt ;
  char *buf ;
  int bufsz ;
  ssize_t ret ;
  struct iwl_sensitivity_data *data ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;

  {
  priv = (struct iwl_priv *)file->private_data;
  pos = 0;
  cnt = 0;
  bufsz = 676;
  data = & priv->sensitivity_data;
  tmp = kzalloc((size_t )bufsz, 208U);
  buf = (char *)tmp;
  if ((unsigned long )buf == (unsigned long )((char *)0)) {
    return (-12L);
  } else {

  }
  tmp___0 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "auto_corr_ofdm:\t\t\t %u\n",
                      data->auto_corr_ofdm);
  pos = tmp___0 + pos;
  tmp___1 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "auto_corr_ofdm_mrc:\t\t %u\n",
                      data->auto_corr_ofdm_mrc);
  pos = tmp___1 + pos;
  tmp___2 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "auto_corr_ofdm_x1:\t\t %u\n",
                      data->auto_corr_ofdm_x1);
  pos = tmp___2 + pos;
  tmp___3 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "auto_corr_ofdm_mrc_x1:\t\t %u\n",
                      data->auto_corr_ofdm_mrc_x1);
  pos = tmp___3 + pos;
  tmp___4 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "auto_corr_cck:\t\t\t %u\n",
                      data->auto_corr_cck);
  pos = tmp___4 + pos;
  tmp___5 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "auto_corr_cck_mrc:\t\t %u\n",
                      data->auto_corr_cck_mrc);
  pos = tmp___5 + pos;
  tmp___6 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "last_bad_plcp_cnt_ofdm:\t\t %u\n",
                      data->last_bad_plcp_cnt_ofdm);
  pos = tmp___6 + pos;
  tmp___7 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "last_fa_cnt_ofdm:\t\t %u\n",
                      data->last_fa_cnt_ofdm);
  pos = tmp___7 + pos;
  tmp___8 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "last_bad_plcp_cnt_cck:\t\t %u\n",
                      data->last_bad_plcp_cnt_cck);
  pos = tmp___8 + pos;
  tmp___9 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "last_fa_cnt_cck:\t\t %u\n",
                      data->last_fa_cnt_cck);
  pos = tmp___9 + pos;
  tmp___10 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "nrg_curr_state:\t\t\t %u\n",
                       data->nrg_curr_state);
  pos = tmp___10 + pos;
  tmp___11 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "nrg_prev_state:\t\t\t %u\n",
                       data->nrg_prev_state);
  pos = tmp___11 + pos;
  tmp___12 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "nrg_value:\t\t\t");
  pos = tmp___12 + pos;
  cnt = 0;
  goto ldv_55365;
  ldv_55364: 
  tmp___13 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), " %u", data->nrg_value[cnt]);
  pos = tmp___13 + pos;
  cnt = cnt + 1;
  ldv_55365: ;
  if (cnt <= 9) {
    goto ldv_55364;
  } else {

  }
  tmp___14 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "\n");
  pos = tmp___14 + pos;
  tmp___15 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "nrg_silence_rssi:\t\t");
  pos = tmp___15 + pos;
  cnt = 0;
  goto ldv_55368;
  ldv_55367: 
  tmp___16 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), " %u", (int )data->nrg_silence_rssi[cnt]);
  pos = tmp___16 + pos;
  cnt = cnt + 1;
  ldv_55368: ;
  if (cnt <= 19) {
    goto ldv_55367;
  } else {

  }
  tmp___17 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "\n");
  pos = tmp___17 + pos;
  tmp___18 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "nrg_silence_ref:\t\t %u\n",
                       data->nrg_silence_ref);
  pos = tmp___18 + pos;
  tmp___19 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "nrg_energy_idx:\t\t\t %u\n",
                       data->nrg_energy_idx);
  pos = tmp___19 + pos;
  tmp___20 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "nrg_silence_idx:\t\t %u\n",
                       data->nrg_silence_idx);
  pos = tmp___20 + pos;
  tmp___21 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "nrg_th_cck:\t\t\t %u\n",
                       data->nrg_th_cck);
  pos = tmp___21 + pos;
  tmp___22 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "nrg_auto_corr_silence_diff:\t %u\n",
                       data->nrg_auto_corr_silence_diff);
  pos = tmp___22 + pos;
  tmp___23 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "num_in_cck_no_fa:\t\t %u\n",
                       data->num_in_cck_no_fa);
  pos = tmp___23 + pos;
  tmp___24 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "nrg_th_ofdm:\t\t\t %u\n",
                       data->nrg_th_ofdm);
  pos = tmp___24 + pos;
  ret = simple_read_from_buffer((void *)user_buf, count, ppos, (void const   *)buf,
                                (size_t )pos);
  kfree((void const   *)buf);
  return (ret);
}
}
static ssize_t iwl_dbgfs_chain_noise_read(struct file *file , char *user_buf , size_t count ,
                                          loff_t *ppos ) 
{ 
  struct iwl_priv *priv ;
  int pos ;
  int cnt ;
  char *buf ;
  int bufsz ;
  ssize_t ret ;
  struct iwl_chain_noise_data *data ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;

  {
  priv = (struct iwl_priv *)file->private_data;
  pos = 0;
  cnt = 0;
  bufsz = 260;
  data = & priv->chain_noise_data;
  tmp = kzalloc((size_t )bufsz, 208U);
  buf = (char *)tmp;
  if ((unsigned long )buf == (unsigned long )((char *)0)) {
    return (-12L);
  } else {

  }
  tmp___0 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "active_chains:\t\t\t %u\n",
                      data->active_chains);
  pos = tmp___0 + pos;
  tmp___1 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "chain_noise_a:\t\t\t %u\n",
                      data->chain_noise_a);
  pos = tmp___1 + pos;
  tmp___2 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "chain_noise_b:\t\t\t %u\n",
                      data->chain_noise_b);
  pos = tmp___2 + pos;
  tmp___3 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "chain_noise_c:\t\t\t %u\n",
                      data->chain_noise_c);
  pos = tmp___3 + pos;
  tmp___4 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "chain_signal_a:\t\t\t %u\n",
                      data->chain_signal_a);
  pos = tmp___4 + pos;
  tmp___5 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "chain_signal_b:\t\t\t %u\n",
                      data->chain_signal_b);
  pos = tmp___5 + pos;
  tmp___6 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "chain_signal_c:\t\t\t %u\n",
                      data->chain_signal_c);
  pos = tmp___6 + pos;
  tmp___7 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "beacon_count:\t\t\t %u\n",
                      (int )data->beacon_count);
  pos = tmp___7 + pos;
  tmp___8 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "disconn_array:\t\t\t");
  pos = tmp___8 + pos;
  cnt = 0;
  goto ldv_55384;
  ldv_55383: 
  tmp___9 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), " %u", (int )data->disconn_array[cnt]);
  pos = tmp___9 + pos;
  cnt = cnt + 1;
  ldv_55384: ;
  if (cnt <= 2) {
    goto ldv_55383;
  } else {

  }
  tmp___10 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "\n");
  pos = tmp___10 + pos;
  tmp___11 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "delta_gain_code:\t\t");
  pos = tmp___11 + pos;
  cnt = 0;
  goto ldv_55387;
  ldv_55386: 
  tmp___12 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), " %u", (int )data->delta_gain_code[cnt]);
  pos = tmp___12 + pos;
  cnt = cnt + 1;
  ldv_55387: ;
  if (cnt <= 2) {
    goto ldv_55386;
  } else {

  }
  tmp___13 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "\n");
  pos = tmp___13 + pos;
  tmp___14 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "radio_write:\t\t\t %u\n",
                       (int )data->radio_write);
  pos = tmp___14 + pos;
  tmp___15 = scnprintf(buf + (unsigned long )pos, (size_t )(bufsz - pos), "state:\t\t\t\t %u\n",
                       (int )data->state);
  pos = tmp___15 + pos;
  ret = simple_read_from_buffer((void *)user_buf, count, ppos, (void const   *)buf,
                                (size_t )pos);
  kfree((void const   *)buf);
  return (ret);
}
}
static ssize_t iwl_dbgfs_power_save_status_read(struct file *file , char *user_buf ,
                                                size_t count , loff_t *ppos ) 
{ 
  struct iwl_priv *priv ;
  char buf[60U] ;
  int pos ;
  size_t bufsz ;
  u32 pwrsave_status ;
  u32 tmp ;
  int tmp___0 ;
  int tmp___1 ;
  ssize_t tmp___2 ;

  {
  priv = (struct iwl_priv *)file->private_data;
  pos = 0;
  bufsz = 60UL;
  tmp = iwl_read32___2(priv->trans, 36U);
  pwrsave_status = tmp & 50331648U;
  tmp___0 = scnprintf((char *)(& buf) + (unsigned long )pos, bufsz - (unsigned long )pos,
                      "Power Save Status: ");
  pos = tmp___0 + pos;
  tmp___1 = scnprintf((char *)(& buf) + (unsigned long )pos, bufsz - (unsigned long )pos,
                      "%s\n", pwrsave_status != 0U ? (pwrsave_status != 16777216U ? (pwrsave_status == 33554432U ? (char *)"PHY" : (char *)"error") : (char *)"MAC") : (char *)"none");
  pos = tmp___1 + pos;
  tmp___2 = simple_read_from_buffer((void *)user_buf, count, ppos, (void const   *)(& buf),
                                    (size_t )pos);
  return (tmp___2);
}
}
static ssize_t iwl_dbgfs_clear_ucode_statistics_write(struct file *file , char const   *user_buf ,
                                                      size_t count , loff_t *ppos ) 
{ 
  struct iwl_priv *priv ;
  char buf[8U] ;
  int buf_size ;
  int clear ;
    klee_make_symbolic(&clear, sizeof(int), "clear");
  size_t _min1 ;
  unsigned long _min2 ;
  unsigned long tmp ;
  int tmp___0 ;

  {
  priv = (struct iwl_priv *)file->private_data;
  memset((void *)(& buf), 0, 8UL);
  _min1 = count;
  _min2 = 7UL;
  buf_size = (int )(_min1 < _min2 ? _min1 : _min2);
  tmp = copy_from_user((void *)(& buf), (void const   *)user_buf, (unsigned long )buf_size);
  if (tmp != 0UL) {
    return (-14L);
  } else {

  }
  tmp___0 = sscanf((char const   *)(& buf), "%d", & clear);
  if (tmp___0 != 1) {
    return (-14L);
  } else {

  }
  mutex_lock_nested(& priv->mutex, 0U);
  iwl_send_statistics_request(priv, 0, 1);
  mutex_unlock(& priv->mutex);
  return ((ssize_t )count);
}
}
static ssize_t iwl_dbgfs_ucode_tracing_read(struct file *file , char *user_buf , size_t count ,
                                            loff_t *ppos ) 
{ 
  struct iwl_priv *priv ;
  int pos ;
  char buf[128U] ;
  size_t bufsz ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  ssize_t tmp___3 ;

  {
  priv = (struct iwl_priv *)file->private_data;
  pos = 0;
  bufsz = 128UL;
  tmp = scnprintf((char *)(& buf) + (unsigned long )pos, bufsz - (unsigned long )pos,
                  "ucode trace timer is %s\n", (int )priv->event_log.ucode_trace ? (char *)"On" : (char *)"Off");
  pos = tmp + pos;
  tmp___0 = scnprintf((char *)(& buf) + (unsigned long )pos, bufsz - (unsigned long )pos,
                      "non_wraps_count:\t\t %u\n", priv->event_log.non_wraps_count);
  pos = tmp___0 + pos;
  tmp___1 = scnprintf((char *)(& buf) + (unsigned long )pos, bufsz - (unsigned long )pos,
                      "wraps_once_count:\t\t %u\n", priv->event_log.wraps_once_count);
  pos = tmp___1 + pos;
  tmp___2 = scnprintf((char *)(& buf) + (unsigned long )pos, bufsz - (unsigned long )pos,
                      "wraps_more_count:\t\t %u\n", priv->event_log.wraps_more_count);
  pos = tmp___2 + pos;
  tmp___3 = simple_read_from_buffer((void *)user_buf, count, ppos, (void const   *)(& buf),
                                    (size_t )pos);
  return (tmp___3);
}
}
static ssize_t iwl_dbgfs_ucode_tracing_write(struct file *file , char const   *user_buf ,
                                             size_t count , loff_t *ppos ) 
{ 
  struct iwl_priv *priv ;
  char buf[8U] ;
  int buf_size ;
  int trace ;
  size_t _min1 ;
  unsigned long _min2 ;
  unsigned long tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  priv = (struct iwl_priv *)file->private_data;
  memset((void *)(& buf), 0, 8UL);
  _min1 = count;
  _min2 = 7UL;
  buf_size = (int )(_min1 < _min2 ? _min1 : _min2);
  tmp = copy_from_user((void *)(& buf), (void const   *)user_buf, (unsigned long )buf_size);
  if (tmp != 0UL) {
    return (-14L);
  } else {

  }
  tmp___0 = sscanf((char const   *)(& buf), "%d", & trace);
  if (tmp___0 != 1) {
    return (-14L);
  } else {

  }
  if (trace != 0) {
    priv->event_log.ucode_trace = 1;
    tmp___1 = iwl_is_alive(priv);
    if (tmp___1 != 0) {
      ldv_mod_timer_288(& priv->ucode_trace, jiffies);
    } else {

    }
  } else {
    priv->event_log.ucode_trace = 0;
    ldv_del_timer_sync_289(& priv->ucode_trace);
  }
  return ((ssize_t )count);
}
}
static ssize_t iwl_dbgfs_rxon_flags_read(struct file *file , char *user_buf , size_t count ,
                                         loff_t *ppos ) 
{ 
  struct iwl_priv *priv ;
  int len ;
  char buf[20U] ;
  ssize_t tmp ;

  {
  priv = (struct iwl_priv *)file->private_data;
  len = 0;
  len = sprintf((char *)(& buf), "0x%04X\n", priv->contexts[0].active.flags);
  tmp = simple_read_from_buffer((void *)user_buf, count, ppos, (void const   *)(& buf),
                                (size_t )len);
  return (tmp);
}
}
static ssize_t iwl_dbgfs_rxon_filter_flags_read(struct file *file , char *user_buf ,
                                                size_t count , loff_t *ppos ) 
{ 
  struct iwl_priv *priv ;
  int len ;
  char buf[20U] ;
  ssize_t tmp ;

  {
  priv = (struct iwl_priv *)file->private_data;
  len = 0;
  len = sprintf((char *)(& buf), "0x%04X\n", priv->contexts[0].active.filter_flags);
  tmp = simple_read_from_buffer((void *)user_buf, count, ppos, (void const   *)(& buf),
                                (size_t )len);
  return (tmp);
}
}
static ssize_t iwl_dbgfs_missed_beacon_read(struct file *file , char *user_buf , size_t count ,
                                            loff_t *ppos ) 
{ 
  struct iwl_priv *priv ;
  int pos ;
  char buf[12U] ;
  size_t bufsz ;
  int tmp ;
  ssize_t tmp___0 ;

  {
  priv = (struct iwl_priv *)file->private_data;
  pos = 0;
  bufsz = 12UL;
  tmp = scnprintf((char *)(& buf) + (unsigned long )pos, bufsz - (unsigned long )pos,
                  "%d\n", priv->missed_beacon_threshold);
  pos = tmp + pos;
  tmp___0 = simple_read_from_buffer((void *)user_buf, count, ppos, (void const   *)(& buf),
                                    (size_t )pos);
  return (tmp___0);
}
}
static ssize_t iwl_dbgfs_missed_beacon_write(struct file *file , char const   *user_buf ,
                                             size_t count , loff_t *ppos ) 
{ 
  struct iwl_priv *priv ;
  char buf[8U] ;
  int buf_size ;
  int missed ;
    klee_make_symbolic(&missed, sizeof(int), "missed");
  size_t _min1 ;
  unsigned long _min2 ;
  unsigned long tmp ;
  int tmp___0 ;

  {
  priv = (struct iwl_priv *)file->private_data;
  memset((void *)(& buf), 0, 8UL);
  _min1 = count;
  _min2 = 7UL;
  buf_size = (int )(_min1 < _min2 ? _min1 : _min2);
  tmp = copy_from_user((void *)(& buf), (void const   *)user_buf, (unsigned long )buf_size);
  if (tmp != 0UL) {
    return (-14L);
  } else {

  }
  tmp___0 = sscanf((char const   *)(& buf), "%d", & missed);
  if (tmp___0 != 1) {
    return (-22L);
  } else {

  }
  if (missed <= 0 || missed > 5) {
    priv->missed_beacon_threshold = 5;
  } else {
    priv->missed_beacon_threshold = missed;
  }
  return ((ssize_t )count);
}
}
static ssize_t iwl_dbgfs_plcp_delta_read(struct file *file , char *user_buf , size_t count ,
                                         loff_t *ppos ) 
{ 
  struct iwl_priv *priv ;
  int pos ;
  char buf[12U] ;
  size_t bufsz ;
  int tmp ;
  ssize_t tmp___0 ;

  {
  priv = (struct iwl_priv *)file->private_data;
  pos = 0;
  bufsz = 12UL;
  tmp = scnprintf((char *)(& buf) + (unsigned long )pos, bufsz - (unsigned long )pos,
                  "%u\n", (int )priv->plcp_delta_threshold);
  pos = tmp + pos;
  tmp___0 = simple_read_from_buffer((void *)user_buf, count, ppos, (void const   *)(& buf),
                                    (size_t )pos);
  return (tmp___0);
}
}
static ssize_t iwl_dbgfs_plcp_delta_write(struct file *file , char const   *user_buf ,
                                          size_t count , loff_t *ppos ) 
{ 
  struct iwl_priv *priv ;
  char buf[8U] ;
  int buf_size ;
  int plcp ;
    klee_make_symbolic(&plcp, sizeof(int), "plcp");
  size_t _min1 ;
  unsigned long _min2 ;
  unsigned long tmp ;
  int tmp___0 ;

  {
  priv = (struct iwl_priv *)file->private_data;
  memset((void *)(& buf), 0, 8UL);
  _min1 = count;
  _min2 = 7UL;
  buf_size = (int )(_min1 < _min2 ? _min1 : _min2);
  tmp = copy_from_user((void *)(& buf), (void const   *)user_buf, (unsigned long )buf_size);
  if (tmp != 0UL) {
    return (-14L);
  } else {

  }
  tmp___0 = sscanf((char const   *)(& buf), "%d", & plcp);
  if (tmp___0 != 1) {
    return (-22L);
  } else {

  }
  if (plcp <= 0 || plcp > 255) {
    priv->plcp_delta_threshold = 0U;
  } else {
    priv->plcp_delta_threshold = (u8 )plcp;
  }
  return ((ssize_t )count);
}
}
static ssize_t iwl_dbgfs_rf_reset_read(struct file *file , char *user_buf , size_t count ,
                                       loff_t *ppos ) 
{ 
  struct iwl_priv *priv ;
  int pos ;
  char buf[300U] ;
  size_t bufsz ;
  struct iwl_rf_reset *rf_reset ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  ssize_t tmp___3 ;

  {
  priv = (struct iwl_priv *)file->private_data;
  pos = 0;
  bufsz = 300UL;
  rf_reset = & priv->rf_reset;
  tmp = scnprintf((char *)(& buf) + (unsigned long )pos, bufsz - (unsigned long )pos,
                  "RF reset statistics\n");
  pos = tmp + pos;
  tmp___0 = scnprintf((char *)(& buf) + (unsigned long )pos, bufsz - (unsigned long )pos,
                      "\tnumber of reset request: %d\n", rf_reset->reset_request_count);
  pos = tmp___0 + pos;
  tmp___1 = scnprintf((char *)(& buf) + (unsigned long )pos, bufsz - (unsigned long )pos,
                      "\tnumber of reset request success: %d\n", rf_reset->reset_success_count);
  pos = tmp___1 + pos;
  tmp___2 = scnprintf((char *)(& buf) + (unsigned long )pos, bufsz - (unsigned long )pos,
                      "\tnumber of reset request reject: %d\n", rf_reset->reset_reject_count);
  pos = tmp___2 + pos;
  tmp___3 = simple_read_from_buffer((void *)user_buf, count, ppos, (void const   *)(& buf),
                                    (size_t )pos);
  return (tmp___3);
}
}
static ssize_t iwl_dbgfs_rf_reset_write(struct file *file , char const   *user_buf ,
                                        size_t count , loff_t *ppos ) 
{ 
  struct iwl_priv *priv ;
  int ret ;

  {
  priv = (struct iwl_priv *)file->private_data;
  ret = iwl_force_rf_reset(priv, 1);
  return ((ssize_t )(ret != 0 ? (size_t )ret : count));
}
}
static ssize_t iwl_dbgfs_txfifo_flush_write(struct file *file , char const   *user_buf ,
                                            size_t count , loff_t *ppos ) 
{ 
  struct iwl_priv *priv ;
  char buf[8U] ;
  int buf_size ;
  int flush ;
    klee_make_symbolic(&flush, sizeof(int), "flush");
  size_t _min1 ;
  unsigned long _min2 ;
  unsigned long tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  priv = (struct iwl_priv *)file->private_data;
  memset((void *)(& buf), 0, 8UL);
  _min1 = count;
  _min2 = 7UL;
  buf_size = (int )(_min1 < _min2 ? _min1 : _min2);
  tmp = copy_from_user((void *)(& buf), (void const   *)user_buf, (unsigned long )buf_size);
  if (tmp != 0UL) {
    return (-14L);
  } else {

  }
  tmp___0 = sscanf((char const   *)(& buf), "%d", & flush);
  if (tmp___0 != 1) {
    return (-22L);
  } else {

  }
  tmp___1 = iwl_is_rfkill(priv);
  if (tmp___1 != 0) {
    return (-14L);
  } else {

  }
  iwlagn_dev_txfifo_flush(priv);
  return ((ssize_t )count);
}
}
static ssize_t iwl_dbgfs_bt_traffic_read(struct file *file , char *user_buf , size_t count ,
                                         loff_t *ppos ) 
{ 
  struct iwl_priv *priv ;
  int pos ;
  char buf[200U] ;
  size_t bufsz ;
  int tmp ;
  ssize_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  ssize_t tmp___10 ;

  {
  priv = (struct iwl_priv *)file->private_data;
  pos = 0;
  bufsz = 200UL;
  if ((unsigned int )priv->bt_enable_flag == 0U) {
    tmp = scnprintf((char *)(& buf) + (unsigned long )pos, bufsz - (unsigned long )pos,
                    "BT coex disabled\n");
    pos = tmp + pos;
    tmp___0 = simple_read_from_buffer((void *)user_buf, count, ppos, (void const   *)(& buf),
                                      (size_t )pos);
    return (tmp___0);
  } else {

  }
  tmp___1 = scnprintf((char *)(& buf) + (unsigned long )pos, bufsz - (unsigned long )pos,
                      "BT enable flag: 0x%x\n", (int )priv->bt_enable_flag);
  pos = tmp___1 + pos;
  tmp___2 = scnprintf((char *)(& buf) + (unsigned long )pos, bufsz - (unsigned long )pos,
                      "BT in %s mode\n", (int )priv->bt_full_concurrent ? (char *)"full concurrency" : (char *)"3-wire");
  pos = tmp___2 + pos;
  tmp___3 = scnprintf((char *)(& buf) + (unsigned long )pos, bufsz - (unsigned long )pos,
                      "BT status: %s, last traffic notif: %d\n", (unsigned int )priv->bt_status != 0U ? (char *)"On" : (char *)"Off",
                      (int )priv->last_bt_traffic_load);
  pos = tmp___3 + pos;
  tmp___4 = scnprintf((char *)(& buf) + (unsigned long )pos, bufsz - (unsigned long )pos,
                      "ch_announcement: %d, kill_ack_mask: %x, kill_cts_mask: %x\n",
                      (int )priv->bt_ch_announce, priv->kill_ack_mask, priv->kill_cts_mask);
  pos = tmp___4 + pos;
  tmp___5 = scnprintf((char *)(& buf) + (unsigned long )pos, bufsz - (unsigned long )pos,
                      "bluetooth traffic load: ");
  pos = tmp___5 + pos;
  switch ((int )priv->bt_traffic_load) {
  case 3: 
  tmp___6 = scnprintf((char *)(& buf) + (unsigned long )pos, bufsz - (unsigned long )pos,
                      "Continuous\n");
  pos = tmp___6 + pos;
  goto ldv_55543;
  case 2: 
  tmp___7 = scnprintf((char *)(& buf) + (unsigned long )pos, bufsz - (unsigned long )pos,
                      "High\n");
  pos = tmp___7 + pos;
  goto ldv_55543;
  case 1: 
  tmp___8 = scnprintf((char *)(& buf) + (unsigned long )pos, bufsz - (unsigned long )pos,
                      "Low\n");
  pos = tmp___8 + pos;
  goto ldv_55543;
  case 0: ;
  default: 
  tmp___9 = scnprintf((char *)(& buf) + (unsigned long )pos, bufsz - (unsigned long )pos,
                      "None\n");
  pos = tmp___9 + pos;
  goto ldv_55543;
  }
  ldv_55543: 
  tmp___10 = simple_read_from_buffer((void *)user_buf, count, ppos, (void const   *)(& buf),
                                     (size_t )pos);
  return (tmp___10);
}
}
static ssize_t iwl_dbgfs_protection_mode_read(struct file *file , char *user_buf ,
                                              size_t count , loff_t *ppos ) 
{ 
  struct iwl_priv *priv ;
  int pos ;
  char buf[40U] ;
  size_t bufsz ;
  int tmp ;
  int tmp___0 ;
  ssize_t tmp___1 ;

  {
  priv = (struct iwl_priv *)file->private_data;
  pos = 0;
  bufsz = 40UL;
  if ((unsigned long )(priv->cfg)->ht_params != (unsigned long )((struct iwl_ht_params  const  */* const  */)0)) {
    tmp = scnprintf((char *)(& buf) + (unsigned long )pos, bufsz - (unsigned long )pos,
                    "use %s for aggregation\n", (int )priv->hw_params.use_rts_for_aggregation ? (char *)"rts/cts" : (char *)"cts-to-self");
    pos = tmp + pos;
  } else {
    tmp___0 = scnprintf((char *)(& buf) + (unsigned long )pos, bufsz - (unsigned long )pos,
                        "N/A");
    pos = tmp___0 + pos;
  }
  tmp___1 = simple_read_from_buffer((void *)user_buf, count, ppos, (void const   *)(& buf),
                                    (size_t )pos);
  return (tmp___1);
}
}
static ssize_t iwl_dbgfs_protection_mode_write(struct file *file , char const   *user_buf ,
                                               size_t count , loff_t *ppos ) 
{ 
  struct iwl_priv *priv ;
  char buf[8U] ;
  int buf_size ;
  int rts ;
    klee_make_symbolic(&rts, sizeof(int), "rts");
  size_t _min1 ;
  unsigned long _min2 ;
  unsigned long tmp ;
  int tmp___0 ;

  {
  priv = (struct iwl_priv *)file->private_data;
  if ((unsigned long )(priv->cfg)->ht_params == (unsigned long )((struct iwl_ht_params  const  */* const  */)0)) {
    return (-22L);
  } else {

  }
  memset((void *)(& buf), 0, 8UL);
  _min1 = count;
  _min2 = 7UL;
  buf_size = (int )(_min1 < _min2 ? _min1 : _min2);
  tmp = copy_from_user((void *)(& buf), (void const   *)user_buf, (unsigned long )buf_size);
  if (tmp != 0UL) {
    return (-14L);
  } else {

  }
  tmp___0 = sscanf((char const   *)(& buf), "%d", & rts);
  if (tmp___0 != 1) {
    return (-22L);
  } else {

  }
  if (rts != 0) {
    priv->hw_params.use_rts_for_aggregation = 1;
  } else {
    priv->hw_params.use_rts_for_aggregation = 0;
  }
  return ((ssize_t )count);
}
}
static int iwl_cmd_echo_test(struct iwl_priv *priv ) 
{ 
  int ret ;
  struct iwl_host_cmd cmd ;
  unsigned int tmp ;

  {
  cmd.data[0] = 0;
  cmd.data[1] = 0;
  cmd.resp_pkt = 0;
  cmd._rx_page_addr = 0UL;
  cmd._rx_page_order = 0U;
  cmd.handler_status = 0;
  cmd.flags = 0U;
  cmd.len[0] = 0U;
  tmp = 1U;
  while (1) {
    if (tmp >= 2U) {
      break;
    } else {

    }
    cmd.len[tmp] = (unsigned short)0;
    tmp = tmp + 1U;
  }
  cmd.dataflags[0] = (unsigned char)0;
  cmd.dataflags[1] = (unsigned char)0;
  cmd.id = 3U;
  ret = iwl_dvm_send_cmd(priv, & cmd);
  if (ret != 0) {
    __iwl_err(priv->dev, 0, 0, "echo testing fail: 0X%x\n", ret);
  } else {
    __iwl_dbg(priv->dev, 1U, 0, "iwl_cmd_echo_test", "echo testing pass\n");
  }
  return (ret);
}
}
static ssize_t iwl_dbgfs_echo_test_write(struct file *file , char const   *user_buf ,
                                         size_t count , loff_t *ppos ) 
{ 
  struct iwl_priv *priv ;
  char buf[8U] ;
  int buf_size ;
  size_t _min1 ;
  unsigned long _min2 ;
  unsigned long tmp ;

  {
  priv = (struct iwl_priv *)file->private_data;
  memset((void *)(& buf), 0, 8UL);
  _min1 = count;
  _min2 = 7UL;
  buf_size = (int )(_min1 < _min2 ? _min1 : _min2);
  tmp = copy_from_user((void *)(& buf), (void const   *)user_buf, (unsigned long )buf_size);
  if (tmp != 0UL) {
    return (-14L);
  } else {

  }
  iwl_cmd_echo_test(priv);
  return ((ssize_t )count);
}
}
static ssize_t iwl_dbgfs_log_event_read(struct file *file , char *user_buf , size_t count ,
                                        loff_t *ppos ) 
{ 
  struct iwl_priv *priv ;
  char *buf ;
  ssize_t ret ;
  int tmp ;

  {
  priv = (struct iwl_priv *)file->private_data;
  buf = (char *)0;
  tmp = iwl_dump_nic_event_log(priv, 1, & buf);
  ret = (ssize_t )tmp;
  if (ret > 0L) {
    ret = simple_read_from_buffer((void *)user_buf, count, ppos, (void const   *)buf,
                                  (size_t )ret);
  } else {

  }
  kfree((void const   *)buf);
  return (ret);
}
}
static ssize_t iwl_dbgfs_log_event_write(struct file *file , char const   *user_buf ,
                                         size_t count , loff_t *ppos ) 
{ 
  struct iwl_priv *priv ;
  u32 event_log_flag ;
  char buf[8U] ;
  int buf_size ;
  int tmp ;
  size_t _min1 ;
  unsigned long _min2 ;
  unsigned long tmp___0 ;
  int tmp___1 ;

  {
  priv = (struct iwl_priv *)file->private_data;
  tmp = iwl_is_ready(priv);
  if (tmp == 0) {
    return (-11L);
  } else {

  }
  memset((void *)(& buf), 0, 8UL);
  _min1 = count;
  _min2 = 7UL;
  buf_size = (int )(_min1 < _min2 ? _min1 : _min2);
  tmp___0 = copy_from_user((void *)(& buf), (void const   *)user_buf, (unsigned long )buf_size);
  if (tmp___0 != 0UL) {
    return (-14L);
  } else {

  }
  tmp___1 = sscanf((char const   *)(& buf), "%d", & event_log_flag);
  if (tmp___1 != 1) {
    return (-14L);
  } else {

  }
  if (event_log_flag == 1U) {
    iwl_dump_nic_event_log(priv, 1, (char **)0);
  } else {

  }
  return ((ssize_t )count);
}
}
static ssize_t iwl_dbgfs_calib_disabled_read(struct file *file , char *user_buf ,
                                             size_t count , loff_t *ppos ) 
{ 
  struct iwl_priv *priv ;
  char buf[120U] ;
  int pos ;
  size_t bufsz ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  ssize_t tmp___2 ;

  {
  priv = (struct iwl_priv *)file->private_data;
  pos = 0;
  bufsz = 120UL;
  tmp = scnprintf((char *)(& buf) + (unsigned long )pos, bufsz - (unsigned long )pos,
                  "Sensitivity calibrations %s\n", (int )priv->calib_disabled & 1 ? (char *)"DISABLED" : (char *)"ENABLED");
  pos = tmp + pos;
  tmp___0 = scnprintf((char *)(& buf) + (unsigned long )pos, bufsz - (unsigned long )pos,
                      "Chain noise calibrations %s\n", (priv->calib_disabled & 2U) != 0U ? (char *)"DISABLED" : (char *)"ENABLED");
  pos = tmp___0 + pos;
  tmp___1 = scnprintf((char *)(& buf) + (unsigned long )pos, bufsz - (unsigned long )pos,
                      "Tx power calibrations %s\n", (priv->calib_disabled & 4U) != 0U ? (char *)"DISABLED" : (char *)"ENABLED");
  pos = tmp___1 + pos;
  tmp___2 = simple_read_from_buffer((void *)user_buf, count, ppos, (void const   *)(& buf),
                                    (size_t )pos);
  return (tmp___2);
}
}
static ssize_t iwl_dbgfs_calib_disabled_write(struct file *file , char const   *user_buf ,
                                              size_t count , loff_t *ppos ) 
{ 
  struct iwl_priv *priv ;
  char buf[8U] ;
  u32 calib_disabled ;
  int buf_size ;
  size_t _min1 ;
  unsigned long _min2 ;
  unsigned long tmp ;
  int tmp___0 ;

  {
  priv = (struct iwl_priv *)file->private_data;
  memset((void *)(& buf), 0, 8UL);
  _min1 = count;
  _min2 = 7UL;
  buf_size = (int )(_min1 < _min2 ? _min1 : _min2);
  tmp = copy_from_user((void *)(& buf), (void const   *)user_buf, (unsigned long )buf_size);
  if (tmp != 0UL) {
    return (-14L);
  } else {

  }
  tmp___0 = sscanf((char const   *)(& buf), "%x", & calib_disabled);
  if (tmp___0 != 1) {
    return (-14L);
  } else {

  }
  priv->calib_disabled = calib_disabled;
  return ((ssize_t )count);
}
}
static ssize_t iwl_dbgfs_fw_restart_write(struct file *file , char const   *user_buf ,
                                          size_t count , loff_t *ppos ) 
{ 
  struct iwl_priv *priv ;
  bool restart_fw ;
  int ret ;

  {
  priv = (struct iwl_priv *)file->private_data;
  restart_fw = iwlwifi_mod_params.restart_fw;
  iwlwifi_mod_params.restart_fw = 1;
  mutex_lock_nested(& priv->mutex, 0U);
  ret = iwl_dvm_send_cmd_pdu(priv, 2, 0U, 0, (void const   *)0);
  mutex_unlock(& priv->mutex);
  iwlwifi_mod_params.restart_fw = restart_fw;
  return ((ssize_t )count);
}
}
static struct file_operations  const  iwl_dbgfs_ucode_rx_stats_ops  = 
     {0, & generic_file_llseek, & iwl_dbgfs_ucode_rx_stats_read, 0, 0, 0, 0, 0, 0, 0,
    0, 0, & simple_open, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
static struct file_operations  const  iwl_dbgfs_ucode_tx_stats_ops  = 
     {0, & generic_file_llseek, & iwl_dbgfs_ucode_tx_stats_read, 0, 0, 0, 0, 0, 0, 0,
    0, 0, & simple_open, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
static struct file_operations  const  iwl_dbgfs_ucode_general_stats_ops  = 
     {0, & generic_file_llseek, & iwl_dbgfs_ucode_general_stats_read, 0, 0, 0, 0, 0,
    0, 0, 0, 0, & simple_open, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
static struct file_operations  const  iwl_dbgfs_sensitivity_ops  = 
     {0, & generic_file_llseek, & iwl_dbgfs_sensitivity_read, 0, 0, 0, 0, 0, 0, 0, 0,
    0, & simple_open, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
static struct file_operations  const  iwl_dbgfs_chain_noise_ops  = 
     {0, & generic_file_llseek, & iwl_dbgfs_chain_noise_read, 0, 0, 0, 0, 0, 0, 0, 0,
    0, & simple_open, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
static struct file_operations  const  iwl_dbgfs_power_save_status_ops  = 
     {0, & generic_file_llseek, & iwl_dbgfs_power_save_status_read, 0, 0, 0, 0, 0, 0,
    0, 0, 0, & simple_open, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
static struct file_operations  const  iwl_dbgfs_clear_ucode_statistics_ops  = 
     {0, & generic_file_llseek, 0, & iwl_dbgfs_clear_ucode_statistics_write, 0, 0, 0,
    0, 0, 0, 0, 0, & simple_open, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
static struct file_operations  const  iwl_dbgfs_ucode_tracing_ops  = 
     {0, & generic_file_llseek, & iwl_dbgfs_ucode_tracing_read, & iwl_dbgfs_ucode_tracing_write,
    0, 0, 0, 0, 0, 0, 0, 0, & simple_open, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0};
static struct file_operations  const  iwl_dbgfs_missed_beacon_ops  = 
     {0, & generic_file_llseek, & iwl_dbgfs_missed_beacon_read, & iwl_dbgfs_missed_beacon_write,
    0, 0, 0, 0, 0, 0, 0, 0, & simple_open, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0};
static struct file_operations  const  iwl_dbgfs_plcp_delta_ops  = 
     {0, & generic_file_llseek, & iwl_dbgfs_plcp_delta_read, & iwl_dbgfs_plcp_delta_write,
    0, 0, 0, 0, 0, 0, 0, 0, & simple_open, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0};
static struct file_operations  const  iwl_dbgfs_rf_reset_ops  = 
     {0, & generic_file_llseek, & iwl_dbgfs_rf_reset_read, & iwl_dbgfs_rf_reset_write,
    0, 0, 0, 0, 0, 0, 0, 0, & simple_open, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0};
static struct file_operations  const  iwl_dbgfs_rxon_flags_ops  = 
     {0, & generic_file_llseek, & iwl_dbgfs_rxon_flags_read, 0, 0, 0, 0, 0, 0, 0, 0,
    0, & simple_open, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
static struct file_operations  const  iwl_dbgfs_rxon_filter_flags_ops  = 
     {0, & generic_file_llseek, & iwl_dbgfs_rxon_filter_flags_read, 0, 0, 0, 0, 0, 0,
    0, 0, 0, & simple_open, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
static struct file_operations  const  iwl_dbgfs_txfifo_flush_ops  = 
     {0, & generic_file_llseek, 0, & iwl_dbgfs_txfifo_flush_write, 0, 0, 0, 0, 0, 0,
    0, 0, & simple_open, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
static struct file_operations  const  iwl_dbgfs_ucode_bt_stats_ops  = 
     {0, & generic_file_llseek, & iwl_dbgfs_ucode_bt_stats_read, 0, 0, 0, 0, 0, 0, 0,
    0, 0, & simple_open, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
static struct file_operations  const  iwl_dbgfs_bt_traffic_ops  = 
     {0, & generic_file_llseek, & iwl_dbgfs_bt_traffic_read, 0, 0, 0, 0, 0, 0, 0, 0,
    0, & simple_open, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
static struct file_operations  const  iwl_dbgfs_protection_mode_ops  = 
     {0, & generic_file_llseek, & iwl_dbgfs_protection_mode_read, & iwl_dbgfs_protection_mode_write,
    0, 0, 0, 0, 0, 0, 0, 0, & simple_open, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0};
static struct file_operations  const  iwl_dbgfs_reply_tx_error_ops  = 
     {0, & generic_file_llseek, & iwl_dbgfs_reply_tx_error_read, 0, 0, 0, 0, 0, 0, 0,
    0, 0, & simple_open, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
static struct file_operations  const  iwl_dbgfs_echo_test_ops  = 
     {0, & generic_file_llseek, 0, & iwl_dbgfs_echo_test_write, 0, 0, 0, 0, 0, 0, 0,
    0, & simple_open, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
static struct file_operations  const  iwl_dbgfs_fw_restart_ops  = 
     {0, & generic_file_llseek, 0, & iwl_dbgfs_fw_restart_write, 0, 0, 0, 0, 0, 0, 0,
    0, & simple_open, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
static struct file_operations  const  iwl_dbgfs_log_event_ops  = 
     {0, & generic_file_llseek, & iwl_dbgfs_log_event_read, & iwl_dbgfs_log_event_write,
    0, 0, 0, 0, 0, 0, 0, 0, & simple_open, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0};
static struct file_operations  const  iwl_dbgfs_calib_disabled_ops  = 
     {0, & generic_file_llseek, & iwl_dbgfs_calib_disabled_read, & iwl_dbgfs_calib_disabled_write,
    0, 0, 0, 0, 0, 0, 0, 0, & simple_open, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0};
int iwl_dbgfs_register(struct iwl_priv *priv , struct dentry *dbgfs_dir ) 
{ 
  struct dentry *dir_data ;
  struct dentry *dir_rf ;
  struct dentry *dir_debug ;
  struct dentry *tmp ;
  struct dentry *tmp___0 ;
  struct dentry *tmp___1 ;
  struct dentry *tmp___2 ;
  struct dentry *tmp___3 ;
  struct dentry *tmp___4 ;
  struct dentry *tmp___5 ;
  struct dentry *tmp___6 ;
  struct dentry *tmp___7 ;
  struct dentry *tmp___8 ;
  struct dentry *tmp___9 ;
  struct dentry *tmp___10 ;
  struct dentry *tmp___11 ;
  struct dentry *tmp___12 ;
  struct dentry *tmp___13 ;
  struct dentry *tmp___14 ;
  struct dentry *tmp___15 ;
  struct dentry *tmp___16 ;
  struct dentry *tmp___17 ;
  struct dentry *tmp___18 ;
  struct dentry *tmp___19 ;
  struct dentry *tmp___20 ;
  struct dentry *tmp___21 ;
  struct dentry *tmp___22 ;
  struct dentry *tmp___23 ;
  struct dentry *tmp___24 ;
  struct dentry *tmp___25 ;
  struct dentry *tmp___26 ;
  struct dentry *tmp___27 ;
  struct dentry *tmp___28 ;
  struct dentry *tmp___29 ;
  struct dentry *tmp___30 ;
  struct dentry *tmp___31 ;
  struct dentry *tmp___32 ;
  bool tmp___33 ;
  struct dentry *tmp___34 ;
  char buf[100U] ;
  struct dentry *mac80211_dir ;
  struct dentry *dev_dir ;
  struct dentry *root_dir ;
  struct dentry *tmp___35 ;

  {
  priv->debugfs_dir = dbgfs_dir;
  dir_data = debugfs_create_dir("data", dbgfs_dir);
  if ((unsigned long )dir_data == (unsigned long )((struct dentry *)0)) {
    goto err;
  } else {

  }
  dir_rf = debugfs_create_dir("rf", dbgfs_dir);
  if ((unsigned long )dir_rf == (unsigned long )((struct dentry *)0)) {
    goto err;
  } else {

  }
  dir_debug = debugfs_create_dir("debug", dbgfs_dir);
  if ((unsigned long )dir_debug == (unsigned long )((struct dentry *)0)) {
    goto err;
  } else {

  }
  tmp = debugfs_create_file("nvm", 256, dir_data, (void *)priv, & iwl_dbgfs_nvm_ops);
  if ((unsigned long )tmp == (unsigned long )((struct dentry *)0)) {
    goto err;
  } else {

  }
  tmp___0 = debugfs_create_file("sram", 384, dir_data, (void *)priv, & iwl_dbgfs_sram_ops);
  if ((unsigned long )tmp___0 == (unsigned long )((struct dentry *)0)) {
    goto err;
  } else {

  }
  tmp___1 = debugfs_create_file("wowlan_sram", 256, dir_data, (void *)priv, & iwl_dbgfs_wowlan_sram_ops);
  if ((unsigned long )tmp___1 == (unsigned long )((struct dentry *)0)) {
    goto err;
  } else {

  }
  tmp___2 = debugfs_create_file("stations", 256, dir_data, (void *)priv, & iwl_dbgfs_stations_ops);
  if ((unsigned long )tmp___2 == (unsigned long )((struct dentry *)0)) {
    goto err;
  } else {

  }
  tmp___3 = debugfs_create_file("channels", 256, dir_data, (void *)priv, & iwl_dbgfs_channels_ops);
  if ((unsigned long )tmp___3 == (unsigned long )((struct dentry *)0)) {
    goto err;
  } else {

  }
  tmp___4 = debugfs_create_file("status", 256, dir_data, (void *)priv, & iwl_dbgfs_status_ops);
  if ((unsigned long )tmp___4 == (unsigned long )((struct dentry *)0)) {
    goto err;
  } else {

  }
  tmp___5 = debugfs_create_file("rx_handlers", 384, dir_data, (void *)priv, & iwl_dbgfs_rx_handlers_ops);
  if ((unsigned long )tmp___5 == (unsigned long )((struct dentry *)0)) {
    goto err;
  } else {

  }
  tmp___6 = debugfs_create_file("qos", 256, dir_data, (void *)priv, & iwl_dbgfs_qos_ops);
  if ((unsigned long )tmp___6 == (unsigned long )((struct dentry *)0)) {
    goto err;
  } else {

  }
  tmp___7 = debugfs_create_file("sleep_level_override", 384, dir_data, (void *)priv,
                                & iwl_dbgfs_sleep_level_override_ops);
  if ((unsigned long )tmp___7 == (unsigned long )((struct dentry *)0)) {
    goto err;
  } else {

  }
  tmp___8 = debugfs_create_file("current_sleep_command", 256, dir_data, (void *)priv,
                                & iwl_dbgfs_current_sleep_command_ops);
  if ((unsigned long )tmp___8 == (unsigned long )((struct dentry *)0)) {
    goto err;
  } else {

  }
  tmp___9 = debugfs_create_file("thermal_throttling", 256, dir_data, (void *)priv,
                                & iwl_dbgfs_thermal_throttling_ops);
  if ((unsigned long )tmp___9 == (unsigned long )((struct dentry *)0)) {
    goto err;
  } else {

  }
  tmp___10 = debugfs_create_file("disable_ht40", 384, dir_data, (void *)priv, & iwl_dbgfs_disable_ht40_ops);
  if ((unsigned long )tmp___10 == (unsigned long )((struct dentry *)0)) {
    goto err;
  } else {

  }
  tmp___11 = debugfs_create_file("temperature", 256, dir_data, (void *)priv, & iwl_dbgfs_temperature_ops);
  if ((unsigned long )tmp___11 == (unsigned long )((struct dentry *)0)) {
    goto err;
  } else {

  }
  tmp___12 = debugfs_create_file("power_save_status", 256, dir_debug, (void *)priv,
                                 & iwl_dbgfs_power_save_status_ops);
  if ((unsigned long )tmp___12 == (unsigned long )((struct dentry *)0)) {
    goto err;
  } else {

  }
  tmp___13 = debugfs_create_file("clear_ucode_statistics", 128, dir_debug, (void *)priv,
                                 & iwl_dbgfs_clear_ucode_statistics_ops);
  if ((unsigned long )tmp___13 == (unsigned long )((struct dentry *)0)) {
    goto err;
  } else {

  }
  tmp___14 = debugfs_create_file("missed_beacon", 128, dir_debug, (void *)priv, & iwl_dbgfs_missed_beacon_ops);
  if ((unsigned long )tmp___14 == (unsigned long )((struct dentry *)0)) {
    goto err;
  } else {

  }
  tmp___15 = debugfs_create_file("plcp_delta", 384, dir_debug, (void *)priv, & iwl_dbgfs_plcp_delta_ops);
  if ((unsigned long )tmp___15 == (unsigned long )((struct dentry *)0)) {
    goto err;
  } else {

  }
  tmp___16 = debugfs_create_file("rf_reset", 384, dir_debug, (void *)priv, & iwl_dbgfs_rf_reset_ops);
  if ((unsigned long )tmp___16 == (unsigned long )((struct dentry *)0)) {
    goto err;
  } else {

  }
  tmp___17 = debugfs_create_file("ucode_rx_stats", 256, dir_debug, (void *)priv, & iwl_dbgfs_ucode_rx_stats_ops);
  if ((unsigned long )tmp___17 == (unsigned long )((struct dentry *)0)) {
    goto err;
  } else {

  }
  tmp___18 = debugfs_create_file("ucode_tx_stats", 256, dir_debug, (void *)priv, & iwl_dbgfs_ucode_tx_stats_ops);
  if ((unsigned long )tmp___18 == (unsigned long )((struct dentry *)0)) {
    goto err;
  } else {

  }
  tmp___19 = debugfs_create_file("ucode_general_stats", 256, dir_debug, (void *)priv,
                                 & iwl_dbgfs_ucode_general_stats_ops);
  if ((unsigned long )tmp___19 == (unsigned long )((struct dentry *)0)) {
    goto err;
  } else {

  }
  tmp___20 = debugfs_create_file("txfifo_flush", 128, dir_debug, (void *)priv, & iwl_dbgfs_txfifo_flush_ops);
  if ((unsigned long )tmp___20 == (unsigned long )((struct dentry *)0)) {
    goto err;
  } else {

  }
  tmp___21 = debugfs_create_file("protection_mode", 384, dir_debug, (void *)priv,
                                 & iwl_dbgfs_protection_mode_ops);
  if ((unsigned long )tmp___21 == (unsigned long )((struct dentry *)0)) {
    goto err;
  } else {

  }
  tmp___22 = debugfs_create_file("sensitivity", 256, dir_debug, (void *)priv, & iwl_dbgfs_sensitivity_ops);
  if ((unsigned long )tmp___22 == (unsigned long )((struct dentry *)0)) {
    goto err;
  } else {

  }
  tmp___23 = debugfs_create_file("chain_noise", 256, dir_debug, (void *)priv, & iwl_dbgfs_chain_noise_ops);
  if ((unsigned long )tmp___23 == (unsigned long )((struct dentry *)0)) {
    goto err;
  } else {

  }
  tmp___24 = debugfs_create_file("ucode_tracing", 384, dir_debug, (void *)priv, & iwl_dbgfs_ucode_tracing_ops);
  if ((unsigned long )tmp___24 == (unsigned long )((struct dentry *)0)) {
    goto err;
  } else {

  }
  tmp___25 = debugfs_create_file("ucode_bt_stats", 256, dir_debug, (void *)priv, & iwl_dbgfs_ucode_bt_stats_ops);
  if ((unsigned long )tmp___25 == (unsigned long )((struct dentry *)0)) {
    goto err;
  } else {

  }
  tmp___26 = debugfs_create_file("reply_tx_error", 256, dir_debug, (void *)priv, & iwl_dbgfs_reply_tx_error_ops);
  if ((unsigned long )tmp___26 == (unsigned long )((struct dentry *)0)) {
    goto err;
  } else {

  }
  tmp___27 = debugfs_create_file("rxon_flags", 128, dir_debug, (void *)priv, & iwl_dbgfs_rxon_flags_ops);
  if ((unsigned long )tmp___27 == (unsigned long )((struct dentry *)0)) {
    goto err;
  } else {

  }
  tmp___28 = debugfs_create_file("rxon_filter_flags", 128, dir_debug, (void *)priv,
                                 & iwl_dbgfs_rxon_filter_flags_ops);
  if ((unsigned long )tmp___28 == (unsigned long )((struct dentry *)0)) {
    goto err;
  } else {

  }
  tmp___29 = debugfs_create_file("echo_test", 128, dir_debug, (void *)priv, & iwl_dbgfs_echo_test_ops);
  if ((unsigned long )tmp___29 == (unsigned long )((struct dentry *)0)) {
    goto err;
  } else {

  }
  tmp___30 = debugfs_create_file("fw_restart", 128, dir_debug, (void *)priv, & iwl_dbgfs_fw_restart_ops);
  if ((unsigned long )tmp___30 == (unsigned long )((struct dentry *)0)) {
    goto err;
  } else {

  }
  tmp___31 = debugfs_create_file("log_event", 384, dir_debug, (void *)priv, & iwl_dbgfs_log_event_ops);
  if ((unsigned long )tmp___31 == (unsigned long )((struct dentry *)0)) {
    goto err;
  } else {

  }
  tmp___33 = iwl_advanced_bt_coexist(priv);
  if ((int )tmp___33) {
    tmp___32 = debugfs_create_file("bt_traffic", 256, dir_debug, (void *)priv, & iwl_dbgfs_bt_traffic_ops);
    if ((unsigned long )tmp___32 == (unsigned long )((struct dentry *)0)) {
      goto err;
    } else {

    }
  } else {

  }
  tmp___34 = debugfs_create_file("calib_disabled", 384, dir_rf, (void *)priv, & iwl_dbgfs_calib_disabled_ops);
  if ((unsigned long )tmp___34 == (unsigned long )((struct dentry *)0)) {
    goto err;
  } else {

  }
  if ((unsigned int )priv->mac80211_registered != 0U) {
    dev_dir = dbgfs_dir->d_parent;
    root_dir = dev_dir->d_parent;
    mac80211_dir = ((priv->hw)->wiphy)->debugfsdir;
    snprintf((char *)(& buf), 100UL, "../../%s/%s", root_dir->d_name.name, dev_dir->d_name.name);
    tmp___35 = debugfs_create_symlink("iwlwifi", mac80211_dir, (char const   *)(& buf));
    if ((unsigned long )tmp___35 == (unsigned long )((struct dentry *)0)) {
      goto err;
    } else {

    }
  } else {

  }
  return (0);
  err: 
  __iwl_err(priv->dev, 0, 0, "failed to create the dvm debugfs entries\n");
  return (-12);
}
}
extern int ldv_release_52(void) ;
extern int ldv_release_43(void) ;
int ldv_retval_33  ;
    klee_make_symbolic(&ldv_retval_33, sizeof(int), "ldv_retval_33");
int ldv_retval_2  ;
    klee_make_symbolic(&ldv_retval_2, sizeof(int), "ldv_retval_2");
extern int ldv_release_36(void) ;
extern int ldv_release_44(void) ;
int ldv_retval_26  ;
    klee_make_symbolic(&ldv_retval_26, sizeof(int), "ldv_retval_26");
int ldv_retval_0  ;
    klee_make_symbolic(&ldv_retval_0, sizeof(int), "ldv_retval_0");
int ldv_retval_11  ;
    klee_make_symbolic(&ldv_retval_11, sizeof(int), "ldv_retval_11");
int ldv_retval_1  ;
    klee_make_symbolic(&ldv_retval_1, sizeof(int), "ldv_retval_1");
extern int ldv_release_42(void) ;
int ldv_retval_28  ;
    klee_make_symbolic(&ldv_retval_28, sizeof(int), "ldv_retval_28");
int ldv_retval_25  ;
    klee_make_symbolic(&ldv_retval_25, sizeof(int), "ldv_retval_25");
extern int ldv_release_53(void) ;
extern int ldv_release_38(void) ;
int ldv_retval_15  ;
    klee_make_symbolic(&ldv_retval_15, sizeof(int), "ldv_retval_15");
extern int ldv_release_19(void) ;
extern int ldv_release_39(void) ;
extern int ldv_release_32(void) ;
int ldv_retval_24  ;
    klee_make_symbolic(&ldv_retval_24, sizeof(int), "ldv_retval_24");
extern int ldv_release_23(void) ;
int ldv_retval_32  ;
    klee_make_symbolic(&ldv_retval_32, sizeof(int), "ldv_retval_32");
int ldv_retval_8  ;
    klee_make_symbolic(&ldv_retval_8, sizeof(int), "ldv_retval_8");
extern int ldv_release_51(void) ;
int ldv_retval_31  ;
    klee_make_symbolic(&ldv_retval_31, sizeof(int), "ldv_retval_31");
int ldv_retval_7  ;
    klee_make_symbolic(&ldv_retval_7, sizeof(int), "ldv_retval_7");
int ldv_retval_14  ;
    klee_make_symbolic(&ldv_retval_14, sizeof(int), "ldv_retval_14");
int ldv_retval_17  ;
    klee_make_symbolic(&ldv_retval_17, sizeof(int), "ldv_retval_17");
extern int ldv_release_30(void) ;
int ldv_retval_34  ;
    klee_make_symbolic(&ldv_retval_34, sizeof(int), "ldv_retval_34");
extern int ldv_release_27(void) ;
extern int ldv_release_50(void) ;
extern int ldv_release_37(void) ;
extern int ldv_release_48(void) ;
extern int ldv_release_20(void) ;
int ldv_retval_18  ;
    klee_make_symbolic(&ldv_retval_18, sizeof(int), "ldv_retval_18");
int ldv_retval_35  ;
    klee_make_symbolic(&ldv_retval_35, sizeof(int), "ldv_retval_35");
int ldv_retval_5  ;
    klee_make_symbolic(&ldv_retval_5, sizeof(int), "ldv_retval_5");
int ldv_retval_23  ;
    klee_make_symbolic(&ldv_retval_23, sizeof(int), "ldv_retval_23");
int ldv_retval_22  ;
    klee_make_symbolic(&ldv_retval_22, sizeof(int), "ldv_retval_22");
int ldv_retval_36  ;
    klee_make_symbolic(&ldv_retval_36, sizeof(int), "ldv_retval_36");
int ldv_retval_27  ;
    klee_make_symbolic(&ldv_retval_27, sizeof(int), "ldv_retval_27");
extern int ldv_release_41(void) ;
extern int ldv_release_47(void) ;
int ldv_retval_37  ;
    klee_make_symbolic(&ldv_retval_37, sizeof(int), "ldv_retval_37");
extern int ldv_release_22(void) ;
extern int ldv_release_46(void) ;
int ldv_retval_29  ;
    klee_make_symbolic(&ldv_retval_29, sizeof(int), "ldv_retval_29");
extern int ldv_release_40(void) ;
extern int ldv_release_24(void) ;
extern int ldv_release_25(void) ;
extern int ldv_release_33(void) ;
int ldv_retval_38  ;
    klee_make_symbolic(&ldv_retval_38, sizeof(int), "ldv_retval_38");
extern int ldv_release_31(void) ;
extern int ldv_release_29(void) ;
extern int ldv_release_49(void) ;
extern int ldv_release_35(void) ;
int ldv_retval_12  ;
    klee_make_symbolic(&ldv_retval_12, sizeof(int), "ldv_retval_12");
int ldv_retval_6  ;
    klee_make_symbolic(&ldv_retval_6, sizeof(int), "ldv_retval_6");
int ldv_retval_39  ;
    klee_make_symbolic(&ldv_retval_39, sizeof(int), "ldv_retval_39");
extern int ldv_release_28(void) ;
int ldv_retval_21  ;
    klee_make_symbolic(&ldv_retval_21, sizeof(int), "ldv_retval_21");
extern int ldv_release_26(void) ;
extern int ldv_release_21(void) ;
int ldv_retval_9  ;
    klee_make_symbolic(&ldv_retval_9, sizeof(int), "ldv_retval_9");
int ldv_retval_10  ;
    klee_make_symbolic(&ldv_retval_10, sizeof(int), "ldv_retval_10");
extern int ldv_release_34(void) ;
extern int ldv_release_45(void) ;
int ldv_retval_4  ;
    klee_make_symbolic(&ldv_retval_4, sizeof(int), "ldv_retval_4");
int ldv_retval_3  ;
    klee_make_symbolic(&ldv_retval_3, sizeof(int), "ldv_retval_3");
void ldv_file_operations_20(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
  tmp = ldv_init_zalloc(1000UL);
  iwl_dbgfs_log_event_ops_group1 = (struct inode *)tmp;
  tmp___0 = ldv_init_zalloc(504UL);
  iwl_dbgfs_log_event_ops_group2 = (struct file *)tmp___0;
  return;
}
}
void ldv_file_operations_26(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
  tmp = ldv_init_zalloc(1000UL);
  iwl_dbgfs_ucode_bt_stats_ops_group1 = (struct inode *)tmp;
  tmp___0 = ldv_init_zalloc(504UL);
  iwl_dbgfs_ucode_bt_stats_ops_group2 = (struct file *)tmp___0;
  return;
}
}
void ldv_file_operations_41(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
  tmp = ldv_init_zalloc(1000UL);
  iwl_dbgfs_current_sleep_command_ops_group1 = (struct inode *)tmp;
  tmp___0 = ldv_init_zalloc(504UL);
  iwl_dbgfs_current_sleep_command_ops_group2 = (struct file *)tmp___0;
  return;
}
}
void ldv_file_operations_40(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
  tmp = ldv_init_zalloc(1000UL);
  iwl_dbgfs_ucode_rx_stats_ops_group1 = (struct inode *)tmp;
  tmp___0 = ldv_init_zalloc(504UL);
  iwl_dbgfs_ucode_rx_stats_ops_group2 = (struct file *)tmp___0;
  return;
}
}
void ldv_file_operations_24(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
  tmp = ldv_init_zalloc(1000UL);
  iwl_dbgfs_protection_mode_ops_group1 = (struct inode *)tmp;
  tmp___0 = ldv_init_zalloc(504UL);
  iwl_dbgfs_protection_mode_ops_group2 = (struct file *)tmp___0;
  return;
}
}
void ldv_file_operations_50(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
  tmp = ldv_init_zalloc(1000UL);
  iwl_dbgfs_stations_ops_group1 = (struct inode *)tmp;
  tmp___0 = ldv_init_zalloc(504UL);
  iwl_dbgfs_stations_ops_group2 = (struct file *)tmp___0;
  return;
}
}
void ldv_file_operations_51(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
  tmp = ldv_init_zalloc(1000UL);
  iwl_dbgfs_nvm_ops_group1 = (struct inode *)tmp;
  tmp___0 = ldv_init_zalloc(504UL);
  iwl_dbgfs_nvm_ops_group2 = (struct file *)tmp___0;
  return;
}
}
void ldv_file_operations_34(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
  tmp = ldv_init_zalloc(1000UL);
  iwl_dbgfs_clear_ucode_statistics_ops_group1 = (struct inode *)tmp;
  tmp___0 = ldv_init_zalloc(504UL);
  iwl_dbgfs_clear_ucode_statistics_ops_group2 = (struct file *)tmp___0;
  return;
}
}
void ldv_file_operations_39(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
  tmp = ldv_init_zalloc(1000UL);
  iwl_dbgfs_ucode_tx_stats_ops_group1 = (struct inode *)tmp;
  tmp___0 = ldv_init_zalloc(504UL);
  iwl_dbgfs_ucode_tx_stats_ops_group2 = (struct file *)tmp___0;
  return;
}
}
void ldv_file_operations_31(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
  tmp = ldv_init_zalloc(1000UL);
  iwl_dbgfs_plcp_delta_ops_group1 = (struct inode *)tmp;
  tmp___0 = ldv_init_zalloc(504UL);
  iwl_dbgfs_plcp_delta_ops_group2 = (struct file *)tmp___0;
  return;
}
}
void ldv_file_operations_29(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
  tmp = ldv_init_zalloc(1000UL);
  iwl_dbgfs_rxon_flags_ops_group1 = (struct inode *)tmp;
  tmp___0 = ldv_init_zalloc(504UL);
  iwl_dbgfs_rxon_flags_ops_group2 = (struct file *)tmp___0;
  return;
}
}
void ldv_file_operations_42(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
  tmp = ldv_init_zalloc(1000UL);
  iwl_dbgfs_sleep_level_override_ops_group1 = (struct inode *)tmp;
  tmp___0 = ldv_init_zalloc(504UL);
  iwl_dbgfs_sleep_level_override_ops_group2 = (struct file *)tmp___0;
  return;
}
}
void ldv_file_operations_33(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
  tmp = ldv_init_zalloc(1000UL);
  iwl_dbgfs_ucode_tracing_ops_group1 = (struct inode *)tmp;
  tmp___0 = ldv_init_zalloc(504UL);
  iwl_dbgfs_ucode_tracing_ops_group2 = (struct file *)tmp___0;
  return;
}
}
void ldv_file_operations_48(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
  tmp = ldv_init_zalloc(1000UL);
  iwl_dbgfs_status_ops_group1 = (struct inode *)tmp;
  tmp___0 = ldv_init_zalloc(504UL);
  iwl_dbgfs_status_ops_group2 = (struct file *)tmp___0;
  return;
}
}
void ldv_file_operations_30(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
  tmp = ldv_init_zalloc(1000UL);
  iwl_dbgfs_rf_reset_ops_group1 = (struct inode *)tmp;
  tmp___0 = ldv_init_zalloc(504UL);
  iwl_dbgfs_rf_reset_ops_group2 = (struct file *)tmp___0;
  return;
}
}
void ldv_file_operations_23(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
  tmp = ldv_init_zalloc(1000UL);
  iwl_dbgfs_reply_tx_error_ops_group1 = (struct inode *)tmp;
  tmp___0 = ldv_init_zalloc(504UL);
  iwl_dbgfs_reply_tx_error_ops_group2 = (struct file *)tmp___0;
  return;
}
}
void ldv_file_operations_19(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
  tmp = ldv_init_zalloc(1000UL);
  iwl_dbgfs_calib_disabled_ops_group1 = (struct inode *)tmp;
  tmp___0 = ldv_init_zalloc(504UL);
  iwl_dbgfs_calib_disabled_ops_group2 = (struct file *)tmp___0;
  return;
}
}
void ldv_file_operations_49(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
  tmp = ldv_init_zalloc(1000UL);
  iwl_dbgfs_channels_ops_group1 = (struct inode *)tmp;
  tmp___0 = ldv_init_zalloc(504UL);
  iwl_dbgfs_channels_ops_group2 = (struct file *)tmp___0;
  return;
}
}
void ldv_file_operations_32(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
  tmp = ldv_init_zalloc(1000UL);
  iwl_dbgfs_missed_beacon_ops_group1 = (struct inode *)tmp;
  tmp___0 = ldv_init_zalloc(504UL);
  iwl_dbgfs_missed_beacon_ops_group2 = (struct file *)tmp___0;
  return;
}
}
void ldv_file_operations_25(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
  tmp = ldv_init_zalloc(1000UL);
  iwl_dbgfs_bt_traffic_ops_group1 = (struct inode *)tmp;
  tmp___0 = ldv_init_zalloc(504UL);
  iwl_dbgfs_bt_traffic_ops_group2 = (struct file *)tmp___0;
  return;
}
}
void ldv_file_operations_45(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
  tmp = ldv_init_zalloc(1000UL);
  iwl_dbgfs_thermal_throttling_ops_group1 = (struct inode *)tmp;
  tmp___0 = ldv_init_zalloc(504UL);
  iwl_dbgfs_thermal_throttling_ops_group2 = (struct file *)tmp___0;
  return;
}
}
void ldv_file_operations_28(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
  tmp = ldv_init_zalloc(1000UL);
  iwl_dbgfs_rxon_filter_flags_ops_group1 = (struct inode *)tmp;
  tmp___0 = ldv_init_zalloc(504UL);
  iwl_dbgfs_rxon_filter_flags_ops_group2 = (struct file *)tmp___0;
  return;
}
}
void ldv_file_operations_43(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
  tmp = ldv_init_zalloc(1000UL);
  iwl_dbgfs_temperature_ops_group1 = (struct inode *)tmp;
  tmp___0 = ldv_init_zalloc(504UL);
  iwl_dbgfs_temperature_ops_group2 = (struct file *)tmp___0;
  return;
}
}
void ldv_file_operations_38(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
  tmp = ldv_init_zalloc(1000UL);
  iwl_dbgfs_ucode_general_stats_ops_group1 = (struct inode *)tmp;
  tmp___0 = ldv_init_zalloc(504UL);
  iwl_dbgfs_ucode_general_stats_ops_group2 = (struct file *)tmp___0;
  return;
}
}
void ldv_file_operations_22(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
  tmp = ldv_init_zalloc(1000UL);
  iwl_dbgfs_echo_test_ops_group1 = (struct inode *)tmp;
  tmp___0 = ldv_init_zalloc(504UL);
  iwl_dbgfs_echo_test_ops_group2 = (struct file *)tmp___0;
  return;
}
}
void ldv_file_operations_35(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
  tmp = ldv_init_zalloc(1000UL);
  iwl_dbgfs_power_save_status_ops_group1 = (struct inode *)tmp;
  tmp___0 = ldv_init_zalloc(504UL);
  iwl_dbgfs_power_save_status_ops_group2 = (struct file *)tmp___0;
  return;
}
}
void ldv_file_operations_46(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
  tmp = ldv_init_zalloc(1000UL);
  iwl_dbgfs_qos_ops_group1 = (struct inode *)tmp;
  tmp___0 = ldv_init_zalloc(504UL);
  iwl_dbgfs_qos_ops_group2 = (struct file *)tmp___0;
  return;
}
}
void ldv_file_operations_44(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
  tmp = ldv_init_zalloc(1000UL);
  iwl_dbgfs_disable_ht40_ops_group1 = (struct inode *)tmp;
  tmp___0 = ldv_init_zalloc(504UL);
  iwl_dbgfs_disable_ht40_ops_group2 = (struct file *)tmp___0;
  return;
}
}
void ldv_file_operations_37(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
  tmp = ldv_init_zalloc(1000UL);
  iwl_dbgfs_sensitivity_ops_group1 = (struct inode *)tmp;
  tmp___0 = ldv_init_zalloc(504UL);
  iwl_dbgfs_sensitivity_ops_group2 = (struct file *)tmp___0;
  return;
}
}
void ldv_file_operations_21(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
  tmp = ldv_init_zalloc(1000UL);
  iwl_dbgfs_fw_restart_ops_group1 = (struct inode *)tmp;
  tmp___0 = ldv_init_zalloc(504UL);
  iwl_dbgfs_fw_restart_ops_group2 = (struct file *)tmp___0;
  return;
}
}
void ldv_file_operations_36(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
  tmp = ldv_init_zalloc(1000UL);
  iwl_dbgfs_chain_noise_ops_group1 = (struct inode *)tmp;
  tmp___0 = ldv_init_zalloc(504UL);
  iwl_dbgfs_chain_noise_ops_group2 = (struct file *)tmp___0;
  return;
}
}
void ldv_file_operations_27(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
  tmp = ldv_init_zalloc(1000UL);
  iwl_dbgfs_txfifo_flush_ops_group1 = (struct inode *)tmp;
  tmp___0 = ldv_init_zalloc(504UL);
  iwl_dbgfs_txfifo_flush_ops_group2 = (struct file *)tmp___0;
  return;
}
}
void ldv_file_operations_52(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
  tmp = ldv_init_zalloc(1000UL);
  iwl_dbgfs_wowlan_sram_ops_group1 = (struct inode *)tmp;
  tmp___0 = ldv_init_zalloc(504UL);
  iwl_dbgfs_wowlan_sram_ops_group2 = (struct file *)tmp___0;
  return;
}
}
void ldv_file_operations_47(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
  tmp = ldv_init_zalloc(1000UL);
  iwl_dbgfs_rx_handlers_ops_group1 = (struct inode *)tmp;
  tmp___0 = ldv_init_zalloc(504UL);
  iwl_dbgfs_rx_handlers_ops_group2 = (struct file *)tmp___0;
  return;
}
}
void ldv_file_operations_53(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
  tmp = ldv_init_zalloc(1000UL);
  iwl_dbgfs_sram_ops_group1 = (struct inode *)tmp;
  tmp___0 = ldv_init_zalloc(504UL);
  iwl_dbgfs_sram_ops_group2 = (struct file *)tmp___0;
  return;
}
}
void ldv_main_exported_33(void) 
{ 
  loff_t *ldvarg2 ;
  void *tmp ;
  char *ldvarg4 ;
  void *tmp___0 ;
  loff_t ldvarg1 ;
  size_t ldvarg6 ;
  loff_t *ldvarg5 ;
  void *tmp___1 ;
  int ldvarg0 ;
    klee_make_symbolic(&ldvarg0, sizeof(int), "ldvarg0");
  size_t ldvarg3 ;
  char *ldvarg7 ;
  void *tmp___2 ;
  int tmp___3 ;

  {
  tmp = ldv_init_zalloc(8UL);
  ldvarg2 = (loff_t *)tmp;
  tmp___0 = ldv_init_zalloc(1UL);
  ldvarg4 = (char *)tmp___0;
  tmp___1 = ldv_init_zalloc(8UL);
  ldvarg5 = (loff_t *)tmp___1;
  tmp___2 = ldv_init_zalloc(1UL);
  ldvarg7 = (char *)tmp___2;
  ldv_memset((void *)(& ldvarg1), 0, 8UL);
  ldv_memset((void *)(& ldvarg6), 0, 8UL);
  ldv_memset((void *)(& ldvarg0), 0, 4UL);
  ldv_memset((void *)(& ldvarg3), 0, 8UL);
  tmp___3 = __VERIFIER_nondet_int();
  switch (tmp___3) {
  case 0: ;
  if (ldv_state_variable_33 == 1) {
    ldv_retval_0 = simple_open(iwl_dbgfs_ucode_tracing_ops_group1, iwl_dbgfs_ucode_tracing_ops_group2);
    if (ldv_retval_0 == 0) {
      ldv_state_variable_33 = 2;
      ref_cnt = ref_cnt + 1;
    } else {

    }
  } else {

  }
  goto ldv_55899;
  case 1: ;
  if (ldv_state_variable_33 == 1) {
    iwl_dbgfs_ucode_tracing_write(iwl_dbgfs_ucode_tracing_ops_group2, (char const   *)ldvarg7,
                                  ldvarg6, ldvarg5);
    ldv_state_variable_33 = 1;
  } else {

  }
  if (ldv_state_variable_33 == 2) {
    iwl_dbgfs_ucode_tracing_write(iwl_dbgfs_ucode_tracing_ops_group2, (char const   *)ldvarg7,
                                  ldvarg6, ldvarg5);
    ldv_state_variable_33 = 2;
  } else {

  }
  goto ldv_55899;
  case 2: ;
  if (ldv_state_variable_33 == 2) {
    iwl_dbgfs_ucode_tracing_read(iwl_dbgfs_ucode_tracing_ops_group2, ldvarg4, ldvarg3,
                                 ldvarg2);
    ldv_state_variable_33 = 2;
  } else {

  }
  goto ldv_55899;
  case 3: ;
  if (ldv_state_variable_33 == 2) {
    generic_file_llseek(iwl_dbgfs_ucode_tracing_ops_group2, ldvarg1, ldvarg0);
    ldv_state_variable_33 = 2;
  } else {

  }
  goto ldv_55899;
  case 4: ;
  if (ldv_state_variable_33 == 2) {
    ldv_release_33();
    ldv_state_variable_33 = 1;
    ref_cnt = ref_cnt - 1;
  } else {

  }
  goto ldv_55899;
  default: 
  ldv_stop();
  }
  ldv_55899: ;
  return;
}
}
void ldv_main_exported_32(void) 
{ 
  loff_t ldvarg9 ;
  loff_t *ldvarg10 ;
  void *tmp ;
  loff_t *ldvarg13 ;
  void *tmp___0 ;
  size_t ldvarg14 ;
  int ldvarg8 ;
    klee_make_symbolic(&ldvarg8, sizeof(int), "ldvarg8");
  char *ldvarg15 ;
  void *tmp___1 ;
  char *ldvarg12 ;
  void *tmp___2 ;
  size_t ldvarg11 ;
  int tmp___3 ;

  {
  tmp = ldv_init_zalloc(8UL);
  ldvarg10 = (loff_t *)tmp;
  tmp___0 = ldv_init_zalloc(8UL);
  ldvarg13 = (loff_t *)tmp___0;
  tmp___1 = ldv_init_zalloc(1UL);
  ldvarg15 = (char *)tmp___1;
  tmp___2 = ldv_init_zalloc(1UL);
  ldvarg12 = (char *)tmp___2;
  ldv_memset((void *)(& ldvarg9), 0, 8UL);
  ldv_memset((void *)(& ldvarg14), 0, 8UL);
  ldv_memset((void *)(& ldvarg8), 0, 4UL);
  ldv_memset((void *)(& ldvarg11), 0, 8UL);
  tmp___3 = __VERIFIER_nondet_int();
  switch (tmp___3) {
  case 0: ;
  if (ldv_state_variable_32 == 1) {
    ldv_retval_1 = simple_open(iwl_dbgfs_missed_beacon_ops_group1, iwl_dbgfs_missed_beacon_ops_group2);
    if (ldv_retval_1 == 0) {
      ldv_state_variable_32 = 2;
      ref_cnt = ref_cnt + 1;
    } else {

    }
  } else {

  }
  goto ldv_55917;
  case 1: ;
  if (ldv_state_variable_32 == 1) {
    iwl_dbgfs_missed_beacon_write(iwl_dbgfs_missed_beacon_ops_group2, (char const   *)ldvarg15,
                                  ldvarg14, ldvarg13);
    ldv_state_variable_32 = 1;
  } else {

  }
  if (ldv_state_variable_32 == 2) {
    iwl_dbgfs_missed_beacon_write(iwl_dbgfs_missed_beacon_ops_group2, (char const   *)ldvarg15,
                                  ldvarg14, ldvarg13);
    ldv_state_variable_32 = 2;
  } else {

  }
  goto ldv_55917;
  case 2: ;
  if (ldv_state_variable_32 == 2) {
    iwl_dbgfs_missed_beacon_read(iwl_dbgfs_missed_beacon_ops_group2, ldvarg12, ldvarg11,
                                 ldvarg10);
    ldv_state_variable_32 = 2;
  } else {

  }
  goto ldv_55917;
  case 3: ;
  if (ldv_state_variable_32 == 2) {
    generic_file_llseek(iwl_dbgfs_missed_beacon_ops_group2, ldvarg9, ldvarg8);
    ldv_state_variable_32 = 2;
  } else {

  }
  goto ldv_55917;
  case 4: ;
  if (ldv_state_variable_32 == 2) {
    ldv_release_32();
    ldv_state_variable_32 = 1;
    ref_cnt = ref_cnt - 1;
  } else {

  }
  goto ldv_55917;
  default: 
  ldv_stop();
  }
  ldv_55917: ;
  return;
}
}
void ldv_main_exported_21(void) 
{ 
  int ldvarg16 ;
    klee_make_symbolic(&ldvarg16, sizeof(int), "ldvarg16");
  size_t ldvarg19 ;
  loff_t ldvarg17 ;
  char *ldvarg20 ;
  void *tmp ;
  loff_t *ldvarg18 ;
  void *tmp___0 ;
  int tmp___1 ;

  {
  tmp = ldv_init_zalloc(1UL);
  ldvarg20 = (char *)tmp;
  tmp___0 = ldv_init_zalloc(8UL);
  ldvarg18 = (loff_t *)tmp___0;
  ldv_memset((void *)(& ldvarg16), 0, 4UL);
  ldv_memset((void *)(& ldvarg19), 0, 8UL);
  ldv_memset((void *)(& ldvarg17), 0, 8UL);
  tmp___1 = __VERIFIER_nondet_int();
  switch (tmp___1) {
  case 0: ;
  if (ldv_state_variable_21 == 1) {
    ldv_retval_2 = simple_open(iwl_dbgfs_fw_restart_ops_group1, iwl_dbgfs_fw_restart_ops_group2);
    if (ldv_retval_2 == 0) {
      ldv_state_variable_21 = 2;
      ref_cnt = ref_cnt + 1;
    } else {

    }
  } else {

  }
  goto ldv_55932;
  case 1: ;
  if (ldv_state_variable_21 == 1) {
    iwl_dbgfs_fw_restart_write(iwl_dbgfs_fw_restart_ops_group2, (char const   *)ldvarg20,
                               ldvarg19, ldvarg18);
    ldv_state_variable_21 = 1;
  } else {

  }
  if (ldv_state_variable_21 == 2) {
    iwl_dbgfs_fw_restart_write(iwl_dbgfs_fw_restart_ops_group2, (char const   *)ldvarg20,
                               ldvarg19, ldvarg18);
    ldv_state_variable_21 = 2;
  } else {

  }
  goto ldv_55932;
  case 2: ;
  if (ldv_state_variable_21 == 2) {
    generic_file_llseek(iwl_dbgfs_fw_restart_ops_group2, ldvarg17, ldvarg16);
    ldv_state_variable_21 = 2;
  } else {

  }
  goto ldv_55932;
  case 3: ;
  if (ldv_state_variable_21 == 2) {
    ldv_release_21();
    ldv_state_variable_21 = 1;
    ref_cnt = ref_cnt - 1;
  } else {

  }
  goto ldv_55932;
  default: 
  ldv_stop();
  }
  ldv_55932: ;
  return;
}
}
void ldv_main_exported_26(void) 
{ 
  loff_t ldvarg22 ;
  loff_t *ldvarg23 ;
  void *tmp ;
  char *ldvarg25 ;
  void *tmp___0 ;
  int ldvarg21 ;
    klee_make_symbolic(&ldvarg21, sizeof(int), "ldvarg21");
  size_t ldvarg24 ;
  int tmp___1 ;

  {
  tmp = ldv_init_zalloc(8UL);
  ldvarg23 = (loff_t *)tmp;
  tmp___0 = ldv_init_zalloc(1UL);
  ldvarg25 = (char *)tmp___0;
  ldv_memset((void *)(& ldvarg22), 0, 8UL);
  ldv_memset((void *)(& ldvarg21), 0, 4UL);
  ldv_memset((void *)(& ldvarg24), 0, 8UL);
  tmp___1 = __VERIFIER_nondet_int();
  switch (tmp___1) {
  case 0: ;
  if (ldv_state_variable_26 == 1) {
    ldv_retval_3 = simple_open(iwl_dbgfs_ucode_bt_stats_ops_group1, iwl_dbgfs_ucode_bt_stats_ops_group2);
    if (ldv_retval_3 == 0) {
      ldv_state_variable_26 = 2;
      ref_cnt = ref_cnt + 1;
    } else {

    }
  } else {

  }
  goto ldv_55946;
  case 1: ;
  if (ldv_state_variable_26 == 2) {
    iwl_dbgfs_ucode_bt_stats_read(iwl_dbgfs_ucode_bt_stats_ops_group2, ldvarg25, ldvarg24,
                                  ldvarg23);
    ldv_state_variable_26 = 2;
  } else {

  }
  goto ldv_55946;
  case 2: ;
  if (ldv_state_variable_26 == 2) {
    generic_file_llseek(iwl_dbgfs_ucode_bt_stats_ops_group2, ldvarg22, ldvarg21);
    ldv_state_variable_26 = 2;
  } else {

  }
  goto ldv_55946;
  case 3: ;
  if (ldv_state_variable_26 == 2) {
    ldv_release_26();
    ldv_state_variable_26 = 1;
    ref_cnt = ref_cnt - 1;
  } else {

  }
  goto ldv_55946;
  default: 
  ldv_stop();
  }
  ldv_55946: ;
  return;
}
}
void ldv_main_exported_30(void) 
{ 
  char *ldvarg206 ;
  void *tmp ;
  loff_t *ldvarg201 ;
  void *tmp___0 ;
  int ldvarg199 ;
    klee_make_symbolic(&ldvarg199, sizeof(int), "ldvarg199");
  size_t ldvarg205 ;
  size_t ldvarg202 ;
  loff_t ldvarg200 ;
  char *ldvarg203 ;
  void *tmp___1 ;
  loff_t *ldvarg204 ;
  void *tmp___2 ;
  int tmp___3 ;

  {
  tmp = ldv_init_zalloc(1UL);
  ldvarg206 = (char *)tmp;
  tmp___0 = ldv_init_zalloc(8UL);
  ldvarg201 = (loff_t *)tmp___0;
  tmp___1 = ldv_init_zalloc(1UL);
  ldvarg203 = (char *)tmp___1;
  tmp___2 = ldv_init_zalloc(8UL);
  ldvarg204 = (loff_t *)tmp___2;
  ldv_memset((void *)(& ldvarg199), 0, 4UL);
  ldv_memset((void *)(& ldvarg205), 0, 8UL);
  ldv_memset((void *)(& ldvarg202), 0, 8UL);
  ldv_memset((void *)(& ldvarg200), 0, 8UL);
  tmp___3 = __VERIFIER_nondet_int();
  switch (tmp___3) {
  case 0: ;
  if (ldv_state_variable_30 == 1) {
    ldv_retval_21 = simple_open(iwl_dbgfs_rf_reset_ops_group1, iwl_dbgfs_rf_reset_ops_group2);
    if (ldv_retval_21 == 0) {
      ldv_state_variable_30 = 2;
      ref_cnt = ref_cnt + 1;
    } else {

    }
  } else {

  }
  goto ldv_55963;
  case 1: ;
  if (ldv_state_variable_30 == 1) {
    iwl_dbgfs_rf_reset_write(iwl_dbgfs_rf_reset_ops_group2, (char const   *)ldvarg206,
                             ldvarg205, ldvarg204);
    ldv_state_variable_30 = 1;
  } else {

  }
  if (ldv_state_variable_30 == 2) {
    iwl_dbgfs_rf_reset_write(iwl_dbgfs_rf_reset_ops_group2, (char const   *)ldvarg206,
                             ldvarg205, ldvarg204);
    ldv_state_variable_30 = 2;
  } else {

  }
  goto ldv_55963;
  case 2: ;
  if (ldv_state_variable_30 == 2) {
    iwl_dbgfs_rf_reset_read(iwl_dbgfs_rf_reset_ops_group2, ldvarg203, ldvarg202, ldvarg201);
    ldv_state_variable_30 = 2;
  } else {

  }
  goto ldv_55963;
  case 3: ;
  if (ldv_state_variable_30 == 2) {
    generic_file_llseek(iwl_dbgfs_rf_reset_ops_group2, ldvarg200, ldvarg199);
    ldv_state_variable_30 = 2;
  } else {

  }
  goto ldv_55963;
  case 4: ;
  if (ldv_state_variable_30 == 2) {
    ldv_release_30();
    ldv_state_variable_30 = 1;
    ref_cnt = ref_cnt - 1;
  } else {

  }
  goto ldv_55963;
  default: 
  ldv_stop();
  }
  ldv_55963: ;
  return;
}
}
void ldv_main_exported_44(void) 
{ 
  loff_t *ldvarg28 ;
  void *tmp ;
  size_t ldvarg29 ;
  char *ldvarg30 ;
  void *tmp___0 ;
  char *ldvarg33 ;
  void *tmp___1 ;
  loff_t *ldvarg31 ;
  void *tmp___2 ;
  size_t ldvarg32 ;
  int ldvarg26 ;
    klee_make_symbolic(&ldvarg26, sizeof(int), "ldvarg26");
  loff_t ldvarg27 ;
  int tmp___3 ;

  {
  tmp = ldv_init_zalloc(8UL);
  ldvarg28 = (loff_t *)tmp;
  tmp___0 = ldv_init_zalloc(1UL);
  ldvarg30 = (char *)tmp___0;
  tmp___1 = ldv_init_zalloc(1UL);
  ldvarg33 = (char *)tmp___1;
  tmp___2 = ldv_init_zalloc(8UL);
  ldvarg31 = (loff_t *)tmp___2;
  ldv_memset((void *)(& ldvarg29), 0, 8UL);
  ldv_memset((void *)(& ldvarg32), 0, 8UL);
  ldv_memset((void *)(& ldvarg26), 0, 4UL);
  ldv_memset((void *)(& ldvarg27), 0, 8UL);
  tmp___3 = __VERIFIER_nondet_int();
  switch (tmp___3) {
  case 0: ;
  if (ldv_state_variable_44 == 1) {
    ldv_retval_4 = simple_open(iwl_dbgfs_disable_ht40_ops_group1, iwl_dbgfs_disable_ht40_ops_group2);
    if (ldv_retval_4 == 0) {
      ldv_state_variable_44 = 2;
      ref_cnt = ref_cnt + 1;
    } else {

    }
  } else {

  }
  goto ldv_55981;
  case 1: ;
  if (ldv_state_variable_44 == 1) {
    iwl_dbgfs_disable_ht40_write(iwl_dbgfs_disable_ht40_ops_group2, (char const   *)ldvarg33,
                                 ldvarg32, ldvarg31);
    ldv_state_variable_44 = 1;
  } else {

  }
  if (ldv_state_variable_44 == 2) {
    iwl_dbgfs_disable_ht40_write(iwl_dbgfs_disable_ht40_ops_group2, (char const   *)ldvarg33,
                                 ldvarg32, ldvarg31);
    ldv_state_variable_44 = 2;
  } else {

  }
  goto ldv_55981;
  case 2: ;
  if (ldv_state_variable_44 == 2) {
    iwl_dbgfs_disable_ht40_read(iwl_dbgfs_disable_ht40_ops_group2, ldvarg30, ldvarg29,
                                ldvarg28);
    ldv_state_variable_44 = 2;
  } else {

  }
  goto ldv_55981;
  case 3: ;
  if (ldv_state_variable_44 == 2) {
    generic_file_llseek(iwl_dbgfs_disable_ht40_ops_group2, ldvarg27, ldvarg26);
    ldv_state_variable_44 = 2;
  } else {

  }
  goto ldv_55981;
  case 4: ;
  if (ldv_state_variable_44 == 2) {
    ldv_release_44();
    ldv_state_variable_44 = 1;
    ref_cnt = ref_cnt - 1;
  } else {

  }
  goto ldv_55981;
  default: 
  ldv_stop();
  }
  ldv_55981: ;
  return;
}
}
void ldv_main_exported_25(void) 
{ 
  size_t ldvarg210 ;
  int ldvarg207 ;
    klee_make_symbolic(&ldvarg207, sizeof(int), "ldvarg207");
  loff_t ldvarg208 ;
  char *ldvarg211 ;
  void *tmp ;
  loff_t *ldvarg209 ;
  void *tmp___0 ;
  int tmp___1 ;

  {
  tmp = ldv_init_zalloc(1UL);
  ldvarg211 = (char *)tmp;
  tmp___0 = ldv_init_zalloc(8UL);
  ldvarg209 = (loff_t *)tmp___0;
  ldv_memset((void *)(& ldvarg210), 0, 8UL);
  ldv_memset((void *)(& ldvarg207), 0, 4UL);
  ldv_memset((void *)(& ldvarg208), 0, 8UL);
  tmp___1 = __VERIFIER_nondet_int();
  switch (tmp___1) {
  case 0: ;
  if (ldv_state_variable_25 == 1) {
    ldv_retval_22 = simple_open(iwl_dbgfs_bt_traffic_ops_group1, iwl_dbgfs_bt_traffic_ops_group2);
    if (ldv_retval_22 == 0) {
      ldv_state_variable_25 = 2;
      ref_cnt = ref_cnt + 1;
    } else {

    }
  } else {

  }
  goto ldv_55996;
  case 1: ;
  if (ldv_state_variable_25 == 2) {
    iwl_dbgfs_bt_traffic_read(iwl_dbgfs_bt_traffic_ops_group2, ldvarg211, ldvarg210,
                              ldvarg209);
    ldv_state_variable_25 = 2;
  } else {

  }
  goto ldv_55996;
  case 2: ;
  if (ldv_state_variable_25 == 2) {
    generic_file_llseek(iwl_dbgfs_bt_traffic_ops_group2, ldvarg208, ldvarg207);
    ldv_state_variable_25 = 2;
  } else {

  }
  goto ldv_55996;
  case 3: ;
  if (ldv_state_variable_25 == 2) {
    ldv_release_25();
    ldv_state_variable_25 = 1;
    ref_cnt = ref_cnt - 1;
  } else {

  }
  goto ldv_55996;
  default: 
  ldv_stop();
  }
  ldv_55996: ;
  return;
}
}
void ldv_main_exported_27(void) 
{ 
  size_t ldvarg38 ;
  loff_t ldvarg36 ;
  int ldvarg35 ;
    klee_make_symbolic(&ldvarg35, sizeof(int), "ldvarg35");
  loff_t *ldvarg37 ;
  void *tmp ;
  char *ldvarg39 ;
  void *tmp___0 ;
  int tmp___1 ;

  {
  tmp = ldv_init_zalloc(8UL);
  ldvarg37 = (loff_t *)tmp;
  tmp___0 = ldv_init_zalloc(1UL);
  ldvarg39 = (char *)tmp___0;
  ldv_memset((void *)(& ldvarg38), 0, 8UL);
  ldv_memset((void *)(& ldvarg36), 0, 8UL);
  ldv_memset((void *)(& ldvarg35), 0, 4UL);
  tmp___1 = __VERIFIER_nondet_int();
  switch (tmp___1) {
  case 0: ;
  if (ldv_state_variable_27 == 1) {
    ldv_retval_5 = simple_open(iwl_dbgfs_txfifo_flush_ops_group1, iwl_dbgfs_txfifo_flush_ops_group2);
    if (ldv_retval_5 == 0) {
      ldv_state_variable_27 = 2;
      ref_cnt = ref_cnt + 1;
    } else {

    }
  } else {

  }
  goto ldv_56010;
  case 1: ;
  if (ldv_state_variable_27 == 1) {
    iwl_dbgfs_txfifo_flush_write(iwl_dbgfs_txfifo_flush_ops_group2, (char const   *)ldvarg39,
                                 ldvarg38, ldvarg37);
    ldv_state_variable_27 = 1;
  } else {

  }
  if (ldv_state_variable_27 == 2) {
    iwl_dbgfs_txfifo_flush_write(iwl_dbgfs_txfifo_flush_ops_group2, (char const   *)ldvarg39,
                                 ldvarg38, ldvarg37);
    ldv_state_variable_27 = 2;
  } else {

  }
  goto ldv_56010;
  case 2: ;
  if (ldv_state_variable_27 == 2) {
    generic_file_llseek(iwl_dbgfs_txfifo_flush_ops_group2, ldvarg36, ldvarg35);
    ldv_state_variable_27 = 2;
  } else {

  }
  goto ldv_56010;
  case 3: ;
  if (ldv_state_variable_27 == 2) {
    ldv_release_27();
    ldv_state_variable_27 = 1;
    ref_cnt = ref_cnt - 1;
  } else {

  }
  goto ldv_56010;
  default: 
  ldv_stop();
  }
  ldv_56010: ;
  return;
}
}
void ldv_main_exported_28(void) 
{ 
  char *ldvarg216 ;
  void *tmp ;
  int ldvarg212 ;
    klee_make_symbolic(&ldvarg212, sizeof(int), "ldvarg212");
  loff_t *ldvarg214 ;
  void *tmp___0 ;
  size_t ldvarg215 ;
  loff_t ldvarg213 ;
  int tmp___1 ;

  {
  tmp = ldv_init_zalloc(1UL);
  ldvarg216 = (char *)tmp;
  tmp___0 = ldv_init_zalloc(8UL);
  ldvarg214 = (loff_t *)tmp___0;
  ldv_memset((void *)(& ldvarg212), 0, 4UL);
  ldv_memset((void *)(& ldvarg215), 0, 8UL);
  ldv_memset((void *)(& ldvarg213), 0, 8UL);
  tmp___1 = __VERIFIER_nondet_int();
  switch (tmp___1) {
  case 0: ;
  if (ldv_state_variable_28 == 1) {
    ldv_retval_23 = simple_open(iwl_dbgfs_rxon_filter_flags_ops_group1, iwl_dbgfs_rxon_filter_flags_ops_group2);
    if (ldv_retval_23 == 0) {
      ldv_state_variable_28 = 2;
      ref_cnt = ref_cnt + 1;
    } else {

    }
  } else {

  }
  goto ldv_56024;
  case 1: ;
  if (ldv_state_variable_28 == 2) {
    iwl_dbgfs_rxon_filter_flags_read(iwl_dbgfs_rxon_filter_flags_ops_group2, ldvarg216,
                                     ldvarg215, ldvarg214);
    ldv_state_variable_28 = 2;
  } else {

  }
  goto ldv_56024;
  case 2: ;
  if (ldv_state_variable_28 == 2) {
    generic_file_llseek(iwl_dbgfs_rxon_filter_flags_ops_group2, ldvarg213, ldvarg212);
    ldv_state_variable_28 = 2;
  } else {

  }
  goto ldv_56024;
  case 3: ;
  if (ldv_state_variable_28 == 2) {
    ldv_release_28();
    ldv_state_variable_28 = 1;
    ref_cnt = ref_cnt - 1;
  } else {

  }
  goto ldv_56024;
  default: 
  ldv_stop();
  }
  ldv_56024: ;
  return;
}
}
void ldv_main_exported_40(void) 
{ 
  loff_t *ldvarg219 ;
  void *tmp ;
  char *ldvarg221 ;
  void *tmp___0 ;
  int ldvarg217 ;
    klee_make_symbolic(&ldvarg217, sizeof(int), "ldvarg217");
  loff_t ldvarg218 ;
  size_t ldvarg220 ;
  int tmp___1 ;

  {
  tmp = ldv_init_zalloc(8UL);
  ldvarg219 = (loff_t *)tmp;
  tmp___0 = ldv_init_zalloc(1UL);
  ldvarg221 = (char *)tmp___0;
  ldv_memset((void *)(& ldvarg217), 0, 4UL);
  ldv_memset((void *)(& ldvarg218), 0, 8UL);
  ldv_memset((void *)(& ldvarg220), 0, 8UL);
  tmp___1 = __VERIFIER_nondet_int();
  switch (tmp___1) {
  case 0: ;
  if (ldv_state_variable_40 == 1) {
    ldv_retval_24 = simple_open(iwl_dbgfs_ucode_rx_stats_ops_group1, iwl_dbgfs_ucode_rx_stats_ops_group2);
    if (ldv_retval_24 == 0) {
      ldv_state_variable_40 = 2;
      ref_cnt = ref_cnt + 1;
    } else {

    }
  } else {

  }
  goto ldv_56038;
  case 1: ;
  if (ldv_state_variable_40 == 2) {
    iwl_dbgfs_ucode_rx_stats_read(iwl_dbgfs_ucode_rx_stats_ops_group2, ldvarg221,
                                  ldvarg220, ldvarg219);
    ldv_state_variable_40 = 2;
  } else {

  }
  goto ldv_56038;
  case 2: ;
  if (ldv_state_variable_40 == 2) {
    generic_file_llseek(iwl_dbgfs_ucode_rx_stats_ops_group2, ldvarg218, ldvarg217);
    ldv_state_variable_40 = 2;
  } else {

  }
  goto ldv_56038;
  case 3: ;
  if (ldv_state_variable_40 == 2) {
    ldv_release_40();
    ldv_state_variable_40 = 1;
    ref_cnt = ref_cnt - 1;
  } else {

  }
  goto ldv_56038;
  default: 
  ldv_stop();
  }
  ldv_56038: ;
  return;
}
}
void ldv_main_exported_20(void) 
{ 
  size_t ldvarg47 ;
  size_t ldvarg44 ;
  char *ldvarg48 ;
  void *tmp ;
  loff_t *ldvarg46 ;
  void *tmp___0 ;
  loff_t ldvarg42 ;
  loff_t *ldvarg43 ;
  void *tmp___1 ;
  int ldvarg41 ;
    klee_make_symbolic(&ldvarg41, sizeof(int), "ldvarg41");
  char *ldvarg45 ;
  void *tmp___2 ;
  int tmp___3 ;

  {
  tmp = ldv_init_zalloc(1UL);
  ldvarg48 = (char *)tmp;
  tmp___0 = ldv_init_zalloc(8UL);
  ldvarg46 = (loff_t *)tmp___0;
  tmp___1 = ldv_init_zalloc(8UL);
  ldvarg43 = (loff_t *)tmp___1;
  tmp___2 = ldv_init_zalloc(1UL);
  ldvarg45 = (char *)tmp___2;
  ldv_memset((void *)(& ldvarg47), 0, 8UL);
  ldv_memset((void *)(& ldvarg44), 0, 8UL);
  ldv_memset((void *)(& ldvarg42), 0, 8UL);
  ldv_memset((void *)(& ldvarg41), 0, 4UL);
  tmp___3 = __VERIFIER_nondet_int();
  switch (tmp___3) {
  case 0: ;
  if (ldv_state_variable_20 == 1) {
    ldv_retval_6 = simple_open(iwl_dbgfs_log_event_ops_group1, iwl_dbgfs_log_event_ops_group2);
    if (ldv_retval_6 == 0) {
      ldv_state_variable_20 = 2;
      ref_cnt = ref_cnt + 1;
    } else {

    }
  } else {

  }
  goto ldv_56055;
  case 1: ;
  if (ldv_state_variable_20 == 1) {
    iwl_dbgfs_log_event_write(iwl_dbgfs_log_event_ops_group2, (char const   *)ldvarg48,
                              ldvarg47, ldvarg46);
    ldv_state_variable_20 = 1;
  } else {

  }
  if (ldv_state_variable_20 == 2) {
    iwl_dbgfs_log_event_write(iwl_dbgfs_log_event_ops_group2, (char const   *)ldvarg48,
                              ldvarg47, ldvarg46);
    ldv_state_variable_20 = 2;
  } else {

  }
  goto ldv_56055;
  case 2: ;
  if (ldv_state_variable_20 == 2) {
    iwl_dbgfs_log_event_read(iwl_dbgfs_log_event_ops_group2, ldvarg45, ldvarg44, ldvarg43);
    ldv_state_variable_20 = 2;
  } else {

  }
  goto ldv_56055;
  case 3: ;
  if (ldv_state_variable_20 == 2) {
    generic_file_llseek(iwl_dbgfs_log_event_ops_group2, ldvarg42, ldvarg41);
    ldv_state_variable_20 = 2;
  } else {

  }
  goto ldv_56055;
  case 4: ;
  if (ldv_state_variable_20 == 2) {
    ldv_release_20();
    ldv_state_variable_20 = 1;
    ref_cnt = ref_cnt - 1;
  } else {

  }
  goto ldv_56055;
  default: 
  ldv_stop();
  }
  ldv_56055: ;
  return;
}
}
void ldv_main_exported_49(void) 
{ 
  loff_t *ldvarg239 ;
  void *tmp ;
  char *ldvarg241 ;
  void *tmp___0 ;
  size_t ldvarg240 ;
  int ldvarg237 ;
    klee_make_symbolic(&ldvarg237, sizeof(int), "ldvarg237");
  loff_t ldvarg238 ;
  int tmp___1 ;

  {
  tmp = ldv_init_zalloc(8UL);
  ldvarg239 = (loff_t *)tmp;
  tmp___0 = ldv_init_zalloc(1UL);
  ldvarg241 = (char *)tmp___0;
  ldv_memset((void *)(& ldvarg240), 0, 8UL);
  ldv_memset((void *)(& ldvarg237), 0, 4UL);
  ldv_memset((void *)(& ldvarg238), 0, 8UL);
  tmp___1 = __VERIFIER_nondet_int();
  switch (tmp___1) {
  case 0: ;
  if (ldv_state_variable_49 == 1) {
    ldv_retval_25 = simple_open(iwl_dbgfs_channels_ops_group1, iwl_dbgfs_channels_ops_group2);
    if (ldv_retval_25 == 0) {
      ldv_state_variable_49 = 2;
      ref_cnt = ref_cnt + 1;
    } else {

    }
  } else {

  }
  goto ldv_56070;
  case 1: ;
  if (ldv_state_variable_49 == 2) {
    iwl_dbgfs_channels_read(iwl_dbgfs_channels_ops_group2, ldvarg241, ldvarg240, ldvarg239);
    ldv_state_variable_49 = 2;
  } else {

  }
  goto ldv_56070;
  case 2: ;
  if (ldv_state_variable_49 == 2) {
    generic_file_llseek(iwl_dbgfs_channels_ops_group2, ldvarg238, ldvarg237);
    ldv_state_variable_49 = 2;
  } else {

  }
  goto ldv_56070;
  case 3: ;
  if (ldv_state_variable_49 == 2) {
    ldv_release_49();
    ldv_state_variable_49 = 1;
    ref_cnt = ref_cnt - 1;
  } else {

  }
  goto ldv_56070;
  default: 
  ldv_stop();
  }
  ldv_56070: ;
  return;
}
}
void ldv_main_exported_24(void) 
{ 
  size_t ldvarg245 ;
  loff_t ldvarg243 ;
  size_t ldvarg248 ;
  char *ldvarg249 ;
  void *tmp ;
  loff_t *ldvarg244 ;
  void *tmp___0 ;
  loff_t *ldvarg247 ;
  void *tmp___1 ;
  char *ldvarg246 ;
  void *tmp___2 ;
  int ldvarg242 ;
    klee_make_symbolic(&ldvarg242, sizeof(int), "ldvarg242");
  int tmp___3 ;

  {
  tmp = ldv_init_zalloc(1UL);
  ldvarg249 = (char *)tmp;
  tmp___0 = ldv_init_zalloc(8UL);
  ldvarg244 = (loff_t *)tmp___0;
  tmp___1 = ldv_init_zalloc(8UL);
  ldvarg247 = (loff_t *)tmp___1;
  tmp___2 = ldv_init_zalloc(1UL);
  ldvarg246 = (char *)tmp___2;
  ldv_memset((void *)(& ldvarg245), 0, 8UL);
  ldv_memset((void *)(& ldvarg243), 0, 8UL);
  ldv_memset((void *)(& ldvarg248), 0, 8UL);
  ldv_memset((void *)(& ldvarg242), 0, 4UL);
  tmp___3 = __VERIFIER_nondet_int();
  switch (tmp___3) {
  case 0: ;
  if (ldv_state_variable_24 == 1) {
    ldv_retval_26 = simple_open(iwl_dbgfs_protection_mode_ops_group1, iwl_dbgfs_protection_mode_ops_group2);
    if (ldv_retval_26 == 0) {
      ldv_state_variable_24 = 2;
      ref_cnt = ref_cnt + 1;
    } else {

    }
  } else {

  }
  goto ldv_56087;
  case 1: ;
  if (ldv_state_variable_24 == 1) {
    iwl_dbgfs_protection_mode_write(iwl_dbgfs_protection_mode_ops_group2, (char const   *)ldvarg249,
                                    ldvarg248, ldvarg247);
    ldv_state_variable_24 = 1;
  } else {

  }
  if (ldv_state_variable_24 == 2) {
    iwl_dbgfs_protection_mode_write(iwl_dbgfs_protection_mode_ops_group2, (char const   *)ldvarg249,
                                    ldvarg248, ldvarg247);
    ldv_state_variable_24 = 2;
  } else {

  }
  goto ldv_56087;
  case 2: ;
  if (ldv_state_variable_24 == 2) {
    iwl_dbgfs_protection_mode_read(iwl_dbgfs_protection_mode_ops_group2, ldvarg246,
                                   ldvarg245, ldvarg244);
    ldv_state_variable_24 = 2;
  } else {

  }
  goto ldv_56087;
  case 3: ;
  if (ldv_state_variable_24 == 2) {
    generic_file_llseek(iwl_dbgfs_protection_mode_ops_group2, ldvarg243, ldvarg242);
    ldv_state_variable_24 = 2;
  } else {

  }
  goto ldv_56087;
  case 4: ;
  if (ldv_state_variable_24 == 2) {
    ldv_release_24();
    ldv_state_variable_24 = 1;
    ref_cnt = ref_cnt - 1;
  } else {

  }
  goto ldv_56087;
  default: 
  ldv_stop();
  }
  ldv_56087: ;
  return;
}
}
void ldv_main_exported_31(void) 
{ 
  size_t ldvarg52 ;
  size_t ldvarg55 ;
  char *ldvarg53 ;
  void *tmp ;
  loff_t *ldvarg54 ;
  void *tmp___0 ;
  loff_t ldvarg50 ;
  int ldvarg49 ;
    klee_make_symbolic(&ldvarg49, sizeof(int), "ldvarg49");
  char *ldvarg56 ;
  void *tmp___1 ;
  loff_t *ldvarg51 ;
  void *tmp___2 ;
  int tmp___3 ;

  {
  tmp = ldv_init_zalloc(1UL);
  ldvarg53 = (char *)tmp;
  tmp___0 = ldv_init_zalloc(8UL);
  ldvarg54 = (loff_t *)tmp___0;
  tmp___1 = ldv_init_zalloc(1UL);
  ldvarg56 = (char *)tmp___1;
  tmp___2 = ldv_init_zalloc(8UL);
  ldvarg51 = (loff_t *)tmp___2;
  ldv_memset((void *)(& ldvarg52), 0, 8UL);
  ldv_memset((void *)(& ldvarg55), 0, 8UL);
  ldv_memset((void *)(& ldvarg50), 0, 8UL);
  ldv_memset((void *)(& ldvarg49), 0, 4UL);
  tmp___3 = __VERIFIER_nondet_int();
  switch (tmp___3) {
  case 0: ;
  if (ldv_state_variable_31 == 1) {
    ldv_retval_7 = simple_open(iwl_dbgfs_plcp_delta_ops_group1, iwl_dbgfs_plcp_delta_ops_group2);
    if (ldv_retval_7 == 0) {
      ldv_state_variable_31 = 2;
      ref_cnt = ref_cnt + 1;
    } else {

    }
  } else {

  }
  goto ldv_56105;
  case 1: ;
  if (ldv_state_variable_31 == 1) {
    iwl_dbgfs_plcp_delta_write(iwl_dbgfs_plcp_delta_ops_group2, (char const   *)ldvarg56,
                               ldvarg55, ldvarg54);
    ldv_state_variable_31 = 1;
  } else {

  }
  if (ldv_state_variable_31 == 2) {
    iwl_dbgfs_plcp_delta_write(iwl_dbgfs_plcp_delta_ops_group2, (char const   *)ldvarg56,
                               ldvarg55, ldvarg54);
    ldv_state_variable_31 = 2;
  } else {

  }
  goto ldv_56105;
  case 2: ;
  if (ldv_state_variable_31 == 2) {
    iwl_dbgfs_plcp_delta_read(iwl_dbgfs_plcp_delta_ops_group2, ldvarg53, ldvarg52,
                              ldvarg51);
    ldv_state_variable_31 = 2;
  } else {

  }
  goto ldv_56105;
  case 3: ;
  if (ldv_state_variable_31 == 2) {
    generic_file_llseek(iwl_dbgfs_plcp_delta_ops_group2, ldvarg50, ldvarg49);
    ldv_state_variable_31 = 2;
  } else {

  }
  goto ldv_56105;
  case 4: ;
  if (ldv_state_variable_31 == 2) {
    ldv_release_31();
    ldv_state_variable_31 = 1;
    ref_cnt = ref_cnt - 1;
  } else {

  }
  goto ldv_56105;
  default: 
  ldv_stop();
  }
  ldv_56105: ;
  return;
}
}
void ldv_main_exported_35(void) 
{ 
  loff_t *ldvarg59 ;
  void *tmp ;
  size_t ldvarg60 ;
  char *ldvarg61 ;
  void *tmp___0 ;
  loff_t ldvarg58 ;
  int ldvarg57 ;
    klee_make_symbolic(&ldvarg57, sizeof(int), "ldvarg57");
  int tmp___1 ;

  {
  tmp = ldv_init_zalloc(8UL);
  ldvarg59 = (loff_t *)tmp;
  tmp___0 = ldv_init_zalloc(1UL);
  ldvarg61 = (char *)tmp___0;
  ldv_memset((void *)(& ldvarg60), 0, 8UL);
  ldv_memset((void *)(& ldvarg58), 0, 8UL);
  ldv_memset((void *)(& ldvarg57), 0, 4UL);
  tmp___1 = __VERIFIER_nondet_int();
  switch (tmp___1) {
  case 0: ;
  if (ldv_state_variable_35 == 1) {
    ldv_retval_8 = simple_open(iwl_dbgfs_power_save_status_ops_group1, iwl_dbgfs_power_save_status_ops_group2);
    if (ldv_retval_8 == 0) {
      ldv_state_variable_35 = 2;
      ref_cnt = ref_cnt + 1;
    } else {

    }
  } else {

  }
  goto ldv_56120;
  case 1: ;
  if (ldv_state_variable_35 == 2) {
    iwl_dbgfs_power_save_status_read(iwl_dbgfs_power_save_status_ops_group2, ldvarg61,
                                     ldvarg60, ldvarg59);
    ldv_state_variable_35 = 2;
  } else {

  }
  goto ldv_56120;
  case 2: ;
  if (ldv_state_variable_35 == 2) {
    generic_file_llseek(iwl_dbgfs_power_save_status_ops_group2, ldvarg58, ldvarg57);
    ldv_state_variable_35 = 2;
  } else {

  }
  goto ldv_56120;
  case 3: ;
  if (ldv_state_variable_35 == 2) {
    ldv_release_35();
    ldv_state_variable_35 = 1;
    ref_cnt = ref_cnt - 1;
  } else {

  }
  goto ldv_56120;
  default: 
  ldv_stop();
  }
  ldv_56120: ;
  return;
}
}
void ldv_main_exported_53(void) 
{ 
  loff_t *ldvarg255 ;
  void *tmp ;
  size_t ldvarg253 ;
  char *ldvarg254 ;
  void *tmp___0 ;
  int ldvarg250 ;
    klee_make_symbolic(&ldvarg250, sizeof(int), "ldvarg250");
  loff_t ldvarg251 ;
  char *ldvarg257 ;
  void *tmp___1 ;
  loff_t *ldvarg252 ;
  void *tmp___2 ;
  size_t ldvarg256 ;
  int tmp___3 ;

  {
  tmp = ldv_init_zalloc(8UL);
  ldvarg255 = (loff_t *)tmp;
  tmp___0 = ldv_init_zalloc(1UL);
  ldvarg254 = (char *)tmp___0;
  tmp___1 = ldv_init_zalloc(1UL);
  ldvarg257 = (char *)tmp___1;
  tmp___2 = ldv_init_zalloc(8UL);
  ldvarg252 = (loff_t *)tmp___2;
  ldv_memset((void *)(& ldvarg253), 0, 8UL);
  ldv_memset((void *)(& ldvarg250), 0, 4UL);
  ldv_memset((void *)(& ldvarg251), 0, 8UL);
  ldv_memset((void *)(& ldvarg256), 0, 8UL);
  tmp___3 = __VERIFIER_nondet_int();
  switch (tmp___3) {
  case 0: ;
  if (ldv_state_variable_53 == 1) {
    ldv_retval_27 = simple_open(iwl_dbgfs_sram_ops_group1, iwl_dbgfs_sram_ops_group2);
    if (ldv_retval_27 == 0) {
      ldv_state_variable_53 = 2;
      ref_cnt = ref_cnt + 1;
    } else {

    }
  } else {

  }
  goto ldv_56137;
  case 1: ;
  if (ldv_state_variable_53 == 1) {
    iwl_dbgfs_sram_write(iwl_dbgfs_sram_ops_group2, (char const   *)ldvarg257, ldvarg256,
                         ldvarg255);
    ldv_state_variable_53 = 1;
  } else {

  }
  if (ldv_state_variable_53 == 2) {
    iwl_dbgfs_sram_write(iwl_dbgfs_sram_ops_group2, (char const   *)ldvarg257, ldvarg256,
                         ldvarg255);
    ldv_state_variable_53 = 2;
  } else {

  }
  goto ldv_56137;
  case 2: ;
  if (ldv_state_variable_53 == 2) {
    iwl_dbgfs_sram_read(iwl_dbgfs_sram_ops_group2, ldvarg254, ldvarg253, ldvarg252);
    ldv_state_variable_53 = 2;
  } else {

  }
  goto ldv_56137;
  case 3: ;
  if (ldv_state_variable_53 == 2) {
    generic_file_llseek(iwl_dbgfs_sram_ops_group2, ldvarg251, ldvarg250);
    ldv_state_variable_53 = 2;
  } else {

  }
  goto ldv_56137;
  case 4: ;
  if (ldv_state_variable_53 == 2) {
    ldv_release_53();
    ldv_state_variable_53 = 1;
    ref_cnt = ref_cnt - 1;
  } else {

  }
  goto ldv_56137;
  default: 
  ldv_stop();
  }
  ldv_56137: ;
  return;
}
}
void ldv_main_exported_48(void) 
{ 
  int ldvarg62 ;
    klee_make_symbolic(&ldvarg62, sizeof(int), "ldvarg62");
  loff_t *ldvarg64 ;
  void *tmp ;
  char *ldvarg66 ;
  void *tmp___0 ;
  loff_t ldvarg63 ;
  size_t ldvarg65 ;
  int tmp___1 ;

  {
  tmp = ldv_init_zalloc(8UL);
  ldvarg64 = (loff_t *)tmp;
  tmp___0 = ldv_init_zalloc(1UL);
  ldvarg66 = (char *)tmp___0;
  ldv_memset((void *)(& ldvarg62), 0, 4UL);
  ldv_memset((void *)(& ldvarg63), 0, 8UL);
  ldv_memset((void *)(& ldvarg65), 0, 8UL);
  tmp___1 = __VERIFIER_nondet_int();
  switch (tmp___1) {
  case 0: ;
  if (ldv_state_variable_48 == 1) {
    ldv_retval_9 = simple_open(iwl_dbgfs_status_ops_group1, iwl_dbgfs_status_ops_group2);
    if (ldv_retval_9 == 0) {
      ldv_state_variable_48 = 2;
      ref_cnt = ref_cnt + 1;
    } else {

    }
  } else {

  }
  goto ldv_56152;
  case 1: ;
  if (ldv_state_variable_48 == 2) {
    iwl_dbgfs_status_read(iwl_dbgfs_status_ops_group2, ldvarg66, ldvarg65, ldvarg64);
    ldv_state_variable_48 = 2;
  } else {

  }
  goto ldv_56152;
  case 2: ;
  if (ldv_state_variable_48 == 2) {
    generic_file_llseek(iwl_dbgfs_status_ops_group2, ldvarg63, ldvarg62);
    ldv_state_variable_48 = 2;
  } else {

  }
  goto ldv_56152;
  case 3: ;
  if (ldv_state_variable_48 == 2) {
    ldv_release_48();
    ldv_state_variable_48 = 1;
    ref_cnt = ref_cnt - 1;
  } else {

  }
  goto ldv_56152;
  default: 
  ldv_stop();
  }
  ldv_56152: ;
  return;
}
}
void ldv_main_exported_22(void) 
{ 
  loff_t *ldvarg260 ;
  void *tmp ;
  size_t ldvarg261 ;
  int ldvarg258 ;
    klee_make_symbolic(&ldvarg258, sizeof(int), "ldvarg258");
  char *ldvarg262 ;
  void *tmp___0 ;
  loff_t ldvarg259 ;
  int tmp___1 ;

  {
  tmp = ldv_init_zalloc(8UL);
  ldvarg260 = (loff_t *)tmp;
  tmp___0 = ldv_init_zalloc(1UL);
  ldvarg262 = (char *)tmp___0;
  ldv_memset((void *)(& ldvarg261), 0, 8UL);
  ldv_memset((void *)(& ldvarg258), 0, 4UL);
  ldv_memset((void *)(& ldvarg259), 0, 8UL);
  tmp___1 = __VERIFIER_nondet_int();
  switch (tmp___1) {
  case 0: ;
  if (ldv_state_variable_22 == 1) {
    ldv_retval_28 = simple_open(iwl_dbgfs_echo_test_ops_group1, iwl_dbgfs_echo_test_ops_group2);
    if (ldv_retval_28 == 0) {
      ldv_state_variable_22 = 2;
      ref_cnt = ref_cnt + 1;
    } else {

    }
  } else {

  }
  goto ldv_56166;
  case 1: ;
  if (ldv_state_variable_22 == 1) {
    iwl_dbgfs_echo_test_write(iwl_dbgfs_echo_test_ops_group2, (char const   *)ldvarg262,
                              ldvarg261, ldvarg260);
    ldv_state_variable_22 = 1;
  } else {

  }
  if (ldv_state_variable_22 == 2) {
    iwl_dbgfs_echo_test_write(iwl_dbgfs_echo_test_ops_group2, (char const   *)ldvarg262,
                              ldvarg261, ldvarg260);
    ldv_state_variable_22 = 2;
  } else {

  }
  goto ldv_56166;
  case 2: ;
  if (ldv_state_variable_22 == 2) {
    generic_file_llseek(iwl_dbgfs_echo_test_ops_group2, ldvarg259, ldvarg258);
    ldv_state_variable_22 = 2;
  } else {

  }
  goto ldv_56166;
  case 3: ;
  if (ldv_state_variable_22 == 2) {
    ldv_release_22();
    ldv_state_variable_22 = 1;
    ref_cnt = ref_cnt - 1;
  } else {

  }
  goto ldv_56166;
  default: 
  ldv_stop();
  }
  ldv_56166: ;
  return;
}
}
void ldv_main_exported_42(void) 
{ 
  char *ldvarg267 ;
  void *tmp ;
  int ldvarg263 ;
    klee_make_symbolic(&ldvarg263, sizeof(int), "ldvarg263");
  size_t ldvarg266 ;
  loff_t *ldvarg265 ;
  void *tmp___0 ;
  char *ldvarg270 ;
  void *tmp___1 ;
  loff_t *ldvarg268 ;
  void *tmp___2 ;
  size_t ldvarg269 ;
  loff_t ldvarg264 ;
  int tmp___3 ;

  {
  tmp = ldv_init_zalloc(1UL);
  ldvarg267 = (char *)tmp;
  tmp___0 = ldv_init_zalloc(8UL);
  ldvarg265 = (loff_t *)tmp___0;
  tmp___1 = ldv_init_zalloc(1UL);
  ldvarg270 = (char *)tmp___1;
  tmp___2 = ldv_init_zalloc(8UL);
  ldvarg268 = (loff_t *)tmp___2;
  ldv_memset((void *)(& ldvarg263), 0, 4UL);
  ldv_memset((void *)(& ldvarg266), 0, 8UL);
  ldv_memset((void *)(& ldvarg269), 0, 8UL);
  ldv_memset((void *)(& ldvarg264), 0, 8UL);
  tmp___3 = __VERIFIER_nondet_int();
  switch (tmp___3) {
  case 0: ;
  if (ldv_state_variable_42 == 1) {
    ldv_retval_29 = simple_open(iwl_dbgfs_sleep_level_override_ops_group1, iwl_dbgfs_sleep_level_override_ops_group2);
    if (ldv_retval_29 == 0) {
      ldv_state_variable_42 = 2;
      ref_cnt = ref_cnt + 1;
    } else {

    }
  } else {

  }
  goto ldv_56183;
  case 1: ;
  if (ldv_state_variable_42 == 1) {
    iwl_dbgfs_sleep_level_override_write(iwl_dbgfs_sleep_level_override_ops_group2,
                                         (char const   *)ldvarg270, ldvarg269, ldvarg268);
    ldv_state_variable_42 = 1;
  } else {

  }
  if (ldv_state_variable_42 == 2) {
    iwl_dbgfs_sleep_level_override_write(iwl_dbgfs_sleep_level_override_ops_group2,
                                         (char const   *)ldvarg270, ldvarg269, ldvarg268);
    ldv_state_variable_42 = 2;
  } else {

  }
  goto ldv_56183;
  case 2: ;
  if (ldv_state_variable_42 == 2) {
    iwl_dbgfs_sleep_level_override_read(iwl_dbgfs_sleep_level_override_ops_group2,
                                        ldvarg267, ldvarg266, ldvarg265);
    ldv_state_variable_42 = 2;
  } else {

  }
  goto ldv_56183;
  case 3: ;
  if (ldv_state_variable_42 == 2) {
    generic_file_llseek(iwl_dbgfs_sleep_level_override_ops_group2, ldvarg264, ldvarg263);
    ldv_state_variable_42 = 2;
  } else {

  }
  goto ldv_56183;
  case 4: ;
  if (ldv_state_variable_42 == 2) {
    ldv_release_42();
    ldv_state_variable_42 = 1;
    ref_cnt = ref_cnt - 1;
  } else {

  }
  goto ldv_56183;
  default: 
  ldv_stop();
  }
  ldv_56183: ;
  return;
}
}
void ldv_main_exported_46(void) 
{ 
  size_t ldvarg274 ;
  loff_t *ldvarg273 ;
  void *tmp ;
  char *ldvarg275 ;
  void *tmp___0 ;
  int ldvarg271 ;
    klee_make_symbolic(&ldvarg271, sizeof(int), "ldvarg271");
  loff_t ldvarg272 ;
  int tmp___1 ;

  {
  tmp = ldv_init_zalloc(8UL);
  ldvarg273 = (loff_t *)tmp;
  tmp___0 = ldv_init_zalloc(1UL);
  ldvarg275 = (char *)tmp___0;
  ldv_memset((void *)(& ldvarg274), 0, 8UL);
  ldv_memset((void *)(& ldvarg271), 0, 4UL);
  ldv_memset((void *)(& ldvarg272), 0, 8UL);
  tmp___1 = __VERIFIER_nondet_int();
  switch (tmp___1) {
  case 0: ;
  if (ldv_state_variable_46 == 1) {
    ldv_retval_31 = simple_open(iwl_dbgfs_qos_ops_group1, iwl_dbgfs_qos_ops_group2);
    if (ldv_retval_31 == 0) {
      ldv_state_variable_46 = 2;
      ref_cnt = ref_cnt + 1;
    } else {

    }
  } else {

  }
  goto ldv_56198;
  case 1: ;
  if (ldv_state_variable_46 == 2) {
    iwl_dbgfs_qos_read(iwl_dbgfs_qos_ops_group2, ldvarg275, ldvarg274, ldvarg273);
    ldv_state_variable_46 = 2;
  } else {

  }
  goto ldv_56198;
  case 2: ;
  if (ldv_state_variable_46 == 2) {
    generic_file_llseek(iwl_dbgfs_qos_ops_group2, ldvarg272, ldvarg271);
    ldv_state_variable_46 = 2;
  } else {

  }
  goto ldv_56198;
  case 3: ;
  if (ldv_state_variable_46 == 2) {
    ldv_release_46();
    ldv_state_variable_46 = 1;
    ref_cnt = ref_cnt - 1;
  } else {

  }
  goto ldv_56198;
  default: 
  ldv_stop();
  }
  ldv_56198: ;
  return;
}
}
void ldv_main_exported_23(void) 
{ 
  int ldvarg276 ;
    klee_make_symbolic(&ldvarg276, sizeof(int), "ldvarg276");
  size_t ldvarg279 ;
  loff_t ldvarg277 ;
  char *ldvarg280 ;
  void *tmp ;
  loff_t *ldvarg278 ;
  void *tmp___0 ;
  int tmp___1 ;

  {
  tmp = ldv_init_zalloc(1UL);
  ldvarg280 = (char *)tmp;
  tmp___0 = ldv_init_zalloc(8UL);
  ldvarg278 = (loff_t *)tmp___0;
  ldv_memset((void *)(& ldvarg276), 0, 4UL);
  ldv_memset((void *)(& ldvarg279), 0, 8UL);
  ldv_memset((void *)(& ldvarg277), 0, 8UL);
  tmp___1 = __VERIFIER_nondet_int();
  switch (tmp___1) {
  case 0: ;
  if (ldv_state_variable_23 == 1) {
    ldv_retval_32 = simple_open(iwl_dbgfs_reply_tx_error_ops_group1, iwl_dbgfs_reply_tx_error_ops_group2);
    if (ldv_retval_32 == 0) {
      ldv_state_variable_23 = 2;
      ref_cnt = ref_cnt + 1;
    } else {

    }
  } else {

  }
  goto ldv_56212;
  case 1: ;
  if (ldv_state_variable_23 == 2) {
    iwl_dbgfs_reply_tx_error_read(iwl_dbgfs_reply_tx_error_ops_group2, ldvarg280,
                                  ldvarg279, ldvarg278);
    ldv_state_variable_23 = 2;
  } else {

  }
  goto ldv_56212;
  case 2: ;
  if (ldv_state_variable_23 == 2) {
    generic_file_llseek(iwl_dbgfs_reply_tx_error_ops_group2, ldvarg277, ldvarg276);
    ldv_state_variable_23 = 2;
  } else {

  }
  goto ldv_56212;
  case 3: ;
  if (ldv_state_variable_23 == 2) {
    ldv_release_23();
    ldv_state_variable_23 = 1;
    ref_cnt = ref_cnt - 1;
  } else {

  }
  goto ldv_56212;
  default: 
  ldv_stop();
  }
  ldv_56212: ;
  return;
}
}
void ldv_main_exported_29(void) 
{ 
  int ldvarg86 ;
    klee_make_symbolic(&ldvarg86, sizeof(int), "ldvarg86");
  loff_t ldvarg87 ;
  char *ldvarg90 ;
  void *tmp ;
  size_t ldvarg89 ;
  loff_t *ldvarg88 ;
  void *tmp___0 ;
  int tmp___1 ;

  {
  tmp = ldv_init_zalloc(1UL);
  ldvarg90 = (char *)tmp;
  tmp___0 = ldv_init_zalloc(8UL);
  ldvarg88 = (loff_t *)tmp___0;
  ldv_memset((void *)(& ldvarg86), 0, 4UL);
  ldv_memset((void *)(& ldvarg87), 0, 8UL);
  ldv_memset((void *)(& ldvarg89), 0, 8UL);
  tmp___1 = __VERIFIER_nondet_int();
  switch (tmp___1) {
  case 0: ;
  if (ldv_state_variable_29 == 1) {
    ldv_retval_10 = simple_open(iwl_dbgfs_rxon_flags_ops_group1, iwl_dbgfs_rxon_flags_ops_group2);
    if (ldv_retval_10 == 0) {
      ldv_state_variable_29 = 2;
      ref_cnt = ref_cnt + 1;
    } else {

    }
  } else {

  }
  goto ldv_56226;
  case 1: ;
  if (ldv_state_variable_29 == 2) {
    iwl_dbgfs_rxon_flags_read(iwl_dbgfs_rxon_flags_ops_group2, ldvarg90, ldvarg89,
                              ldvarg88);
    ldv_state_variable_29 = 2;
  } else {

  }
  goto ldv_56226;
  case 2: ;
  if (ldv_state_variable_29 == 2) {
    generic_file_llseek(iwl_dbgfs_rxon_flags_ops_group2, ldvarg87, ldvarg86);
    ldv_state_variable_29 = 2;
  } else {

  }
  goto ldv_56226;
  case 3: ;
  if (ldv_state_variable_29 == 2) {
    ldv_release_29();
    ldv_state_variable_29 = 1;
    ref_cnt = ref_cnt - 1;
  } else {

  }
  goto ldv_56226;
  default: 
  ldv_stop();
  }
  ldv_56226: ;
  return;
}
}
void ldv_main_exported_50(void) 
{ 
  loff_t ldvarg92 ;
  int ldvarg91 ;
    klee_make_symbolic(&ldvarg91, sizeof(int), "ldvarg91");
  size_t ldvarg94 ;
  char *ldvarg95 ;
  void *tmp ;
  loff_t *ldvarg93 ;
  void *tmp___0 ;
  int tmp___1 ;

  {
  tmp = ldv_init_zalloc(1UL);
  ldvarg95 = (char *)tmp;
  tmp___0 = ldv_init_zalloc(8UL);
  ldvarg93 = (loff_t *)tmp___0;
  ldv_memset((void *)(& ldvarg92), 0, 8UL);
  ldv_memset((void *)(& ldvarg91), 0, 4UL);
  ldv_memset((void *)(& ldvarg94), 0, 8UL);
  tmp___1 = __VERIFIER_nondet_int();
  switch (tmp___1) {
  case 0: ;
  if (ldv_state_variable_50 == 1) {
    ldv_retval_11 = simple_open(iwl_dbgfs_stations_ops_group1, iwl_dbgfs_stations_ops_group2);
    if (ldv_retval_11 == 0) {
      ldv_state_variable_50 = 2;
      ref_cnt = ref_cnt + 1;
    } else {

    }
  } else {

  }
  goto ldv_56240;
  case 1: ;
  if (ldv_state_variable_50 == 2) {
    iwl_dbgfs_stations_read(iwl_dbgfs_stations_ops_group2, ldvarg95, ldvarg94, ldvarg93);
    ldv_state_variable_50 = 2;
  } else {

  }
  goto ldv_56240;
  case 2: ;
  if (ldv_state_variable_50 == 2) {
    generic_file_llseek(iwl_dbgfs_stations_ops_group2, ldvarg92, ldvarg91);
    ldv_state_variable_50 = 2;
  } else {

  }
  goto ldv_56240;
  case 3: ;
  if (ldv_state_variable_50 == 2) {
    ldv_release_50();
    ldv_state_variable_50 = 1;
    ref_cnt = ref_cnt - 1;
  } else {

  }
  goto ldv_56240;
  default: 
  ldv_stop();
  }
  ldv_56240: ;
  return;
}
}
void ldv_main_exported_39(void) 
{ 
  size_t ldvarg99 ;
  int ldvarg96 ;
    klee_make_symbolic(&ldvarg96, sizeof(int), "ldvarg96");
  char *ldvarg100 ;
  void *tmp ;
  loff_t ldvarg97 ;
  loff_t *ldvarg98 ;
  void *tmp___0 ;
  int tmp___1 ;

  {
  tmp = ldv_init_zalloc(1UL);
  ldvarg100 = (char *)tmp;
  tmp___0 = ldv_init_zalloc(8UL);
  ldvarg98 = (loff_t *)tmp___0;
  ldv_memset((void *)(& ldvarg99), 0, 8UL);
  ldv_memset((void *)(& ldvarg96), 0, 4UL);
  ldv_memset((void *)(& ldvarg97), 0, 8UL);
  tmp___1 = __VERIFIER_nondet_int();
  switch (tmp___1) {
  case 0: ;
  if (ldv_state_variable_39 == 1) {
    ldv_retval_12 = simple_open(iwl_dbgfs_ucode_tx_stats_ops_group1, iwl_dbgfs_ucode_tx_stats_ops_group2);
    if (ldv_retval_12 == 0) {
      ldv_state_variable_39 = 2;
      ref_cnt = ref_cnt + 1;
    } else {

    }
  } else {

  }
  goto ldv_56254;
  case 1: ;
  if (ldv_state_variable_39 == 2) {
    iwl_dbgfs_ucode_tx_stats_read(iwl_dbgfs_ucode_tx_stats_ops_group2, ldvarg100,
                                  ldvarg99, ldvarg98);
    ldv_state_variable_39 = 2;
  } else {

  }
  goto ldv_56254;
  case 2: ;
  if (ldv_state_variable_39 == 2) {
    generic_file_llseek(iwl_dbgfs_ucode_tx_stats_ops_group2, ldvarg97, ldvarg96);
    ldv_state_variable_39 = 2;
  } else {

  }
  goto ldv_56254;
  case 3: ;
  if (ldv_state_variable_39 == 2) {
    ldv_release_39();
    ldv_state_variable_39 = 1;
    ref_cnt = ref_cnt - 1;
  } else {

  }
  goto ldv_56254;
  default: 
  ldv_stop();
  }
  ldv_56254: ;
  return;
}
}
void ldv_main_exported_36(void) 
{ 
  int ldvarg281 ;
    klee_make_symbolic(&ldvarg281, sizeof(int), "ldvarg281");
  loff_t *ldvarg283 ;
  void *tmp ;
  loff_t ldvarg282 ;
  size_t ldvarg284 ;
  char *ldvarg285 ;
  void *tmp___0 ;
  int tmp___1 ;

  {
  tmp = ldv_init_zalloc(8UL);
  ldvarg283 = (loff_t *)tmp;
  tmp___0 = ldv_init_zalloc(1UL);
  ldvarg285 = (char *)tmp___0;
  ldv_memset((void *)(& ldvarg281), 0, 4UL);
  ldv_memset((void *)(& ldvarg282), 0, 8UL);
  ldv_memset((void *)(& ldvarg284), 0, 8UL);
  tmp___1 = __VERIFIER_nondet_int();
  switch (tmp___1) {
  case 0: ;
  if (ldv_state_variable_36 == 1) {
    ldv_retval_33 = simple_open(iwl_dbgfs_chain_noise_ops_group1, iwl_dbgfs_chain_noise_ops_group2);
    if (ldv_retval_33 == 0) {
      ldv_state_variable_36 = 2;
      ref_cnt = ref_cnt + 1;
    } else {

    }
  } else {

  }
  goto ldv_56268;
  case 1: ;
  if (ldv_state_variable_36 == 2) {
    iwl_dbgfs_chain_noise_read(iwl_dbgfs_chain_noise_ops_group2, ldvarg285, ldvarg284,
                               ldvarg283);
    ldv_state_variable_36 = 2;
  } else {

  }
  goto ldv_56268;
  case 2: ;
  if (ldv_state_variable_36 == 2) {
    generic_file_llseek(iwl_dbgfs_chain_noise_ops_group2, ldvarg282, ldvarg281);
    ldv_state_variable_36 = 2;
  } else {

  }
  goto ldv_56268;
  case 3: ;
  if (ldv_state_variable_36 == 2) {
    ldv_release_36();
    ldv_state_variable_36 = 1;
    ref_cnt = ref_cnt - 1;
  } else {

  }
  goto ldv_56268;
  default: 
  ldv_stop();
  }
  ldv_56268: ;
  return;
}
}
void ldv_main_exported_51(void) 
{ 
  size_t ldvarg289 ;
  int ldvarg286 ;
    klee_make_symbolic(&ldvarg286, sizeof(int), "ldvarg286");
  loff_t ldvarg287 ;
  loff_t *ldvarg288 ;
  void *tmp ;
  char *ldvarg290 ;
  void *tmp___0 ;
  int tmp___1 ;

  {
  tmp = ldv_init_zalloc(8UL);
  ldvarg288 = (loff_t *)tmp;
  tmp___0 = ldv_init_zalloc(1UL);
  ldvarg290 = (char *)tmp___0;
  ldv_memset((void *)(& ldvarg289), 0, 8UL);
  ldv_memset((void *)(& ldvarg286), 0, 4UL);
  ldv_memset((void *)(& ldvarg287), 0, 8UL);
  tmp___1 = __VERIFIER_nondet_int();
  switch (tmp___1) {
  case 0: ;
  if (ldv_state_variable_51 == 1) {
    ldv_retval_34 = simple_open(iwl_dbgfs_nvm_ops_group1, iwl_dbgfs_nvm_ops_group2);
    if (ldv_retval_34 == 0) {
      ldv_state_variable_51 = 2;
      ref_cnt = ref_cnt + 1;
    } else {

    }
  } else {

  }
  goto ldv_56282;
  case 1: ;
  if (ldv_state_variable_51 == 2) {
    iwl_dbgfs_nvm_read(iwl_dbgfs_nvm_ops_group2, ldvarg290, ldvarg289, ldvarg288);
    ldv_state_variable_51 = 2;
  } else {

  }
  goto ldv_56282;
  case 2: ;
  if (ldv_state_variable_51 == 2) {
    generic_file_llseek(iwl_dbgfs_nvm_ops_group2, ldvarg287, ldvarg286);
    ldv_state_variable_51 = 2;
  } else {

  }
  goto ldv_56282;
  case 3: ;
  if (ldv_state_variable_51 == 2) {
    ldv_release_51();
    ldv_state_variable_51 = 1;
    ref_cnt = ref_cnt - 1;
  } else {

  }
  goto ldv_56282;
  default: 
  ldv_stop();
  }
  ldv_56282: ;
  return;
}
}
void ldv_main_exported_41(void) 
{ 
  loff_t *ldvarg158 ;
  void *tmp ;
  char *ldvarg160 ;
  void *tmp___0 ;
  loff_t ldvarg157 ;
  size_t ldvarg159 ;
  int ldvarg156 ;
    klee_make_symbolic(&ldvarg156, sizeof(int), "ldvarg156");
  int tmp___1 ;

  {
  tmp = ldv_init_zalloc(8UL);
  ldvarg158 = (loff_t *)tmp;
  tmp___0 = ldv_init_zalloc(1UL);
  ldvarg160 = (char *)tmp___0;
  ldv_memset((void *)(& ldvarg157), 0, 8UL);
  ldv_memset((void *)(& ldvarg159), 0, 8UL);
  ldv_memset((void *)(& ldvarg156), 0, 4UL);
  tmp___1 = __VERIFIER_nondet_int();
  switch (tmp___1) {
  case 0: ;
  if (ldv_state_variable_41 == 1) {
    ldv_retval_14 = simple_open(iwl_dbgfs_current_sleep_command_ops_group1, iwl_dbgfs_current_sleep_command_ops_group2);
    if (ldv_retval_14 == 0) {
      ldv_state_variable_41 = 2;
      ref_cnt = ref_cnt + 1;
    } else {

    }
  } else {

  }
  goto ldv_56296;
  case 1: ;
  if (ldv_state_variable_41 == 2) {
    iwl_dbgfs_current_sleep_command_read(iwl_dbgfs_current_sleep_command_ops_group2,
                                         ldvarg160, ldvarg159, ldvarg158);
    ldv_state_variable_41 = 2;
  } else {

  }
  goto ldv_56296;
  case 2: ;
  if (ldv_state_variable_41 == 2) {
    generic_file_llseek(iwl_dbgfs_current_sleep_command_ops_group2, ldvarg157, ldvarg156);
    ldv_state_variable_41 = 2;
  } else {

  }
  goto ldv_56296;
  case 3: ;
  if (ldv_state_variable_41 == 2) {
    ldv_release_41();
    ldv_state_variable_41 = 1;
    ref_cnt = ref_cnt - 1;
  } else {

  }
  goto ldv_56296;
  default: 
  ldv_stop();
  }
  ldv_56296: ;
  return;
}
}
void ldv_main_exported_47(void) 
{ 
  size_t ldvarg294 ;
  char *ldvarg298 ;
  void *tmp ;
  loff_t ldvarg292 ;
  int ldvarg291 ;
    klee_make_symbolic(&ldvarg291, sizeof(int), "ldvarg291");
  size_t ldvarg297 ;
  loff_t *ldvarg293 ;
  void *tmp___0 ;
  loff_t *ldvarg296 ;
  void *tmp___1 ;
  char *ldvarg295 ;
  void *tmp___2 ;
  int tmp___3 ;

  {
  tmp = ldv_init_zalloc(1UL);
  ldvarg298 = (char *)tmp;
  tmp___0 = ldv_init_zalloc(8UL);
  ldvarg293 = (loff_t *)tmp___0;
  tmp___1 = ldv_init_zalloc(8UL);
  ldvarg296 = (loff_t *)tmp___1;
  tmp___2 = ldv_init_zalloc(1UL);
  ldvarg295 = (char *)tmp___2;
  ldv_memset((void *)(& ldvarg294), 0, 8UL);
  ldv_memset((void *)(& ldvarg292), 0, 8UL);
  ldv_memset((void *)(& ldvarg291), 0, 4UL);
  ldv_memset((void *)(& ldvarg297), 0, 8UL);
  tmp___3 = __VERIFIER_nondet_int();
  switch (tmp___3) {
  case 0: ;
  if (ldv_state_variable_47 == 1) {
    ldv_retval_35 = simple_open(iwl_dbgfs_rx_handlers_ops_group1, iwl_dbgfs_rx_handlers_ops_group2);
    if (ldv_retval_35 == 0) {
      ldv_state_variable_47 = 2;
      ref_cnt = ref_cnt + 1;
    } else {

    }
  } else {

  }
  goto ldv_56313;
  case 1: ;
  if (ldv_state_variable_47 == 1) {
    iwl_dbgfs_rx_handlers_write(iwl_dbgfs_rx_handlers_ops_group2, (char const   *)ldvarg298,
                                ldvarg297, ldvarg296);
    ldv_state_variable_47 = 1;
  } else {

  }
  if (ldv_state_variable_47 == 2) {
    iwl_dbgfs_rx_handlers_write(iwl_dbgfs_rx_handlers_ops_group2, (char const   *)ldvarg298,
                                ldvarg297, ldvarg296);
    ldv_state_variable_47 = 2;
  } else {

  }
  goto ldv_56313;
  case 2: ;
  if (ldv_state_variable_47 == 2) {
    iwl_dbgfs_rx_handlers_read(iwl_dbgfs_rx_handlers_ops_group2, ldvarg295, ldvarg294,
                               ldvarg293);
    ldv_state_variable_47 = 2;
  } else {

  }
  goto ldv_56313;
  case 3: ;
  if (ldv_state_variable_47 == 2) {
    generic_file_llseek(iwl_dbgfs_rx_handlers_ops_group2, ldvarg292, ldvarg291);
    ldv_state_variable_47 = 2;
  } else {

  }
  goto ldv_56313;
  case 4: ;
  if (ldv_state_variable_47 == 2) {
    ldv_release_47();
    ldv_state_variable_47 = 1;
    ref_cnt = ref_cnt - 1;
  } else {

  }
  goto ldv_56313;
  default: 
  ldv_stop();
  }
  ldv_56313: ;
  return;
}
}
void ldv_main_exported_52(void) 
{ 
  int ldvarg161 ;
    klee_make_symbolic(&ldvarg161, sizeof(int), "ldvarg161");
  loff_t ldvarg162 ;
  loff_t *ldvarg163 ;
  void *tmp ;
  char *ldvarg165 ;
  void *tmp___0 ;
  size_t ldvarg164 ;
  int tmp___1 ;

  {
  tmp = ldv_init_zalloc(8UL);
  ldvarg163 = (loff_t *)tmp;
  tmp___0 = ldv_init_zalloc(1UL);
  ldvarg165 = (char *)tmp___0;
  ldv_memset((void *)(& ldvarg161), 0, 4UL);
  ldv_memset((void *)(& ldvarg162), 0, 8UL);
  ldv_memset((void *)(& ldvarg164), 0, 8UL);
  tmp___1 = __VERIFIER_nondet_int();
  switch (tmp___1) {
  case 0: ;
  if (ldv_state_variable_52 == 1) {
    ldv_retval_15 = simple_open(iwl_dbgfs_wowlan_sram_ops_group1, iwl_dbgfs_wowlan_sram_ops_group2);
    if (ldv_retval_15 == 0) {
      ldv_state_variable_52 = 2;
      ref_cnt = ref_cnt + 1;
    } else {

    }
  } else {

  }
  goto ldv_56328;
  case 1: ;
  if (ldv_state_variable_52 == 2) {
    iwl_dbgfs_wowlan_sram_read(iwl_dbgfs_wowlan_sram_ops_group2, ldvarg165, ldvarg164,
                               ldvarg163);
    ldv_state_variable_52 = 2;
  } else {

  }
  goto ldv_56328;
  case 2: ;
  if (ldv_state_variable_52 == 2) {
    generic_file_llseek(iwl_dbgfs_wowlan_sram_ops_group2, ldvarg162, ldvarg161);
    ldv_state_variable_52 = 2;
  } else {

  }
  goto ldv_56328;
  case 3: ;
  if (ldv_state_variable_52 == 2) {
    ldv_release_52();
    ldv_state_variable_52 = 1;
    ref_cnt = ref_cnt - 1;
  } else {

  }
  goto ldv_56328;
  default: 
  ldv_stop();
  }
  ldv_56328: ;
  return;
}
}
void ldv_main_exported_38(void) 
{ 
  loff_t *ldvarg301 ;
  void *tmp ;
  size_t ldvarg302 ;
  char *ldvarg303 ;
  void *tmp___0 ;
  loff_t ldvarg300 ;
  int ldvarg299 ;
    klee_make_symbolic(&ldvarg299, sizeof(int), "ldvarg299");
  int tmp___1 ;

  {
  tmp = ldv_init_zalloc(8UL);
  ldvarg301 = (loff_t *)tmp;
  tmp___0 = ldv_init_zalloc(1UL);
  ldvarg303 = (char *)tmp___0;
  ldv_memset((void *)(& ldvarg302), 0, 8UL);
  ldv_memset((void *)(& ldvarg300), 0, 8UL);
  ldv_memset((void *)(& ldvarg299), 0, 4UL);
  tmp___1 = __VERIFIER_nondet_int();
  switch (tmp___1) {
  case 0: ;
  if (ldv_state_variable_38 == 1) {
    ldv_retval_36 = simple_open(iwl_dbgfs_ucode_general_stats_ops_group1, iwl_dbgfs_ucode_general_stats_ops_group2);
    if (ldv_retval_36 == 0) {
      ldv_state_variable_38 = 2;
      ref_cnt = ref_cnt + 1;
    } else {

    }
  } else {

  }
  goto ldv_56342;
  case 1: ;
  if (ldv_state_variable_38 == 2) {
    iwl_dbgfs_ucode_general_stats_read(iwl_dbgfs_ucode_general_stats_ops_group2, ldvarg303,
                                       ldvarg302, ldvarg301);
    ldv_state_variable_38 = 2;
  } else {

  }
  goto ldv_56342;
  case 2: ;
  if (ldv_state_variable_38 == 2) {
    generic_file_llseek(iwl_dbgfs_ucode_general_stats_ops_group2, ldvarg300, ldvarg299);
    ldv_state_variable_38 = 2;
  } else {

  }
  goto ldv_56342;
  case 3: ;
  if (ldv_state_variable_38 == 2) {
    ldv_release_38();
    ldv_state_variable_38 = 1;
    ref_cnt = ref_cnt - 1;
  } else {

  }
  goto ldv_56342;
  default: 
  ldv_stop();
  }
  ldv_56342: ;
  return;
}
}
void ldv_main_exported_34(void) 
{ 
  int ldvarg304 ;
    klee_make_symbolic(&ldvarg304, sizeof(int), "ldvarg304");
  loff_t *ldvarg306 ;
  void *tmp ;
  loff_t ldvarg305 ;
  char *ldvarg308 ;
  void *tmp___0 ;
  size_t ldvarg307 ;
  int tmp___1 ;

  {
  tmp = ldv_init_zalloc(8UL);
  ldvarg306 = (loff_t *)tmp;
  tmp___0 = ldv_init_zalloc(1UL);
  ldvarg308 = (char *)tmp___0;
  ldv_memset((void *)(& ldvarg304), 0, 4UL);
  ldv_memset((void *)(& ldvarg305), 0, 8UL);
  ldv_memset((void *)(& ldvarg307), 0, 8UL);
  tmp___1 = __VERIFIER_nondet_int();
  switch (tmp___1) {
  case 0: ;
  if (ldv_state_variable_34 == 1) {
    ldv_retval_37 = simple_open(iwl_dbgfs_clear_ucode_statistics_ops_group1, iwl_dbgfs_clear_ucode_statistics_ops_group2);
    if (ldv_retval_37 == 0) {
      ldv_state_variable_34 = 2;
      ref_cnt = ref_cnt + 1;
    } else {

    }
  } else {

  }
  goto ldv_56356;
  case 1: ;
  if (ldv_state_variable_34 == 1) {
    iwl_dbgfs_clear_ucode_statistics_write(iwl_dbgfs_clear_ucode_statistics_ops_group2,
                                           (char const   *)ldvarg308, ldvarg307, ldvarg306);
    ldv_state_variable_34 = 1;
  } else {

  }
  if (ldv_state_variable_34 == 2) {
    iwl_dbgfs_clear_ucode_statistics_write(iwl_dbgfs_clear_ucode_statistics_ops_group2,
                                           (char const   *)ldvarg308, ldvarg307, ldvarg306);
    ldv_state_variable_34 = 2;
  } else {

  }
  goto ldv_56356;
  case 2: ;
  if (ldv_state_variable_34 == 2) {
    generic_file_llseek(iwl_dbgfs_clear_ucode_statistics_ops_group2, ldvarg305, ldvarg304);
    ldv_state_variable_34 = 2;
  } else {

  }
  goto ldv_56356;
  case 3: ;
  if (ldv_state_variable_34 == 2) {
    ldv_release_34();
    ldv_state_variable_34 = 1;
    ref_cnt = ref_cnt - 1;
  } else {

  }
  goto ldv_56356;
  default: 
  ldv_stop();
  }
  ldv_56356: ;
  return;
}
}
void ldv_main_exported_37(void) 
{ 
  int ldvarg309 ;
    klee_make_symbolic(&ldvarg309, sizeof(int), "ldvarg309");
  loff_t *ldvarg311 ;
  void *tmp ;
  size_t ldvarg312 ;
  loff_t ldvarg310 ;
  char *ldvarg313 ;
  void *tmp___0 ;
  int tmp___1 ;

  {
  tmp = ldv_init_zalloc(8UL);
  ldvarg311 = (loff_t *)tmp;
  tmp___0 = ldv_init_zalloc(1UL);
  ldvarg313 = (char *)tmp___0;
  ldv_memset((void *)(& ldvarg309), 0, 4UL);
  ldv_memset((void *)(& ldvarg312), 0, 8UL);
  ldv_memset((void *)(& ldvarg310), 0, 8UL);
  tmp___1 = __VERIFIER_nondet_int();
  switch (tmp___1) {
  case 0: ;
  if (ldv_state_variable_37 == 1) {
    ldv_retval_38 = simple_open(iwl_dbgfs_sensitivity_ops_group1, iwl_dbgfs_sensitivity_ops_group2);
    if (ldv_retval_38 == 0) {
      ldv_state_variable_37 = 2;
      ref_cnt = ref_cnt + 1;
    } else {

    }
  } else {

  }
  goto ldv_56370;
  case 1: ;
  if (ldv_state_variable_37 == 2) {
    iwl_dbgfs_sensitivity_read(iwl_dbgfs_sensitivity_ops_group2, ldvarg313, ldvarg312,
                               ldvarg311);
    ldv_state_variable_37 = 2;
  } else {

  }
  goto ldv_56370;
  case 2: ;
  if (ldv_state_variable_37 == 2) {
    generic_file_llseek(iwl_dbgfs_sensitivity_ops_group2, ldvarg310, ldvarg309);
    ldv_state_variable_37 = 2;
  } else {

  }
  goto ldv_56370;
  case 3: ;
  if (ldv_state_variable_37 == 2) {
    ldv_release_37();
    ldv_state_variable_37 = 1;
    ref_cnt = ref_cnt - 1;
  } else {

  }
  goto ldv_56370;
  default: 
  ldv_stop();
  }
  ldv_56370: ;
  return;
}
}
void ldv_main_exported_45(void) 
{ 
  int ldvarg172 ;
    klee_make_symbolic(&ldvarg172, sizeof(int), "ldvarg172");
  loff_t ldvarg173 ;
  char *ldvarg176 ;
  void *tmp ;
  loff_t *ldvarg174 ;
  void *tmp___0 ;
  size_t ldvarg175 ;
  int tmp___1 ;

  {
  tmp = ldv_init_zalloc(1UL);
  ldvarg176 = (char *)tmp;
  tmp___0 = ldv_init_zalloc(8UL);
  ldvarg174 = (loff_t *)tmp___0;
  ldv_memset((void *)(& ldvarg172), 0, 4UL);
  ldv_memset((void *)(& ldvarg173), 0, 8UL);
  ldv_memset((void *)(& ldvarg175), 0, 8UL);
  tmp___1 = __VERIFIER_nondet_int();
  switch (tmp___1) {
  case 0: ;
  if (ldv_state_variable_45 == 1) {
    ldv_retval_17 = simple_open(iwl_dbgfs_thermal_throttling_ops_group1, iwl_dbgfs_thermal_throttling_ops_group2);
    if (ldv_retval_17 == 0) {
      ldv_state_variable_45 = 2;
      ref_cnt = ref_cnt + 1;
    } else {

    }
  } else {

  }
  goto ldv_56384;
  case 1: ;
  if (ldv_state_variable_45 == 2) {
    iwl_dbgfs_thermal_throttling_read(iwl_dbgfs_thermal_throttling_ops_group2, ldvarg176,
                                      ldvarg175, ldvarg174);
    ldv_state_variable_45 = 2;
  } else {

  }
  goto ldv_56384;
  case 2: ;
  if (ldv_state_variable_45 == 2) {
    generic_file_llseek(iwl_dbgfs_thermal_throttling_ops_group2, ldvarg173, ldvarg172);
    ldv_state_variable_45 = 2;
  } else {

  }
  goto ldv_56384;
  case 3: ;
  if (ldv_state_variable_45 == 2) {
    ldv_release_45();
    ldv_state_variable_45 = 1;
    ref_cnt = ref_cnt - 1;
  } else {

  }
  goto ldv_56384;
  default: 
  ldv_stop();
  }
  ldv_56384: ;
  return;
}
}
void ldv_main_exported_19(void) 
{ 
  loff_t *ldvarg182 ;
  void *tmp ;
  char *ldvarg181 ;
  void *tmp___0 ;
  size_t ldvarg180 ;
  int ldvarg177 ;
    klee_make_symbolic(&ldvarg177, sizeof(int), "ldvarg177");
  loff_t *ldvarg179 ;
  void *tmp___1 ;
  char *ldvarg184 ;
  void *tmp___2 ;
  loff_t ldvarg178 ;
  size_t ldvarg183 ;
  int tmp___3 ;

  {
  tmp = ldv_init_zalloc(8UL);
  ldvarg182 = (loff_t *)tmp;
  tmp___0 = ldv_init_zalloc(1UL);
  ldvarg181 = (char *)tmp___0;
  tmp___1 = ldv_init_zalloc(8UL);
  ldvarg179 = (loff_t *)tmp___1;
  tmp___2 = ldv_init_zalloc(1UL);
  ldvarg184 = (char *)tmp___2;
  ldv_memset((void *)(& ldvarg180), 0, 8UL);
  ldv_memset((void *)(& ldvarg177), 0, 4UL);
  ldv_memset((void *)(& ldvarg178), 0, 8UL);
  ldv_memset((void *)(& ldvarg183), 0, 8UL);
  tmp___3 = __VERIFIER_nondet_int();
  switch (tmp___3) {
  case 0: ;
  if (ldv_state_variable_19 == 1) {
    ldv_retval_18 = simple_open(iwl_dbgfs_calib_disabled_ops_group1, iwl_dbgfs_calib_disabled_ops_group2);
    if (ldv_retval_18 == 0) {
      ldv_state_variable_19 = 2;
      ref_cnt = ref_cnt + 1;
    } else {

    }
  } else {

  }
  goto ldv_56401;
  case 1: ;
  if (ldv_state_variable_19 == 1) {
    iwl_dbgfs_calib_disabled_write(iwl_dbgfs_calib_disabled_ops_group2, (char const   *)ldvarg184,
                                   ldvarg183, ldvarg182);
    ldv_state_variable_19 = 1;
  } else {

  }
  if (ldv_state_variable_19 == 2) {
    iwl_dbgfs_calib_disabled_write(iwl_dbgfs_calib_disabled_ops_group2, (char const   *)ldvarg184,
                                   ldvarg183, ldvarg182);
    ldv_state_variable_19 = 2;
  } else {

  }
  goto ldv_56401;
  case 2: ;
  if (ldv_state_variable_19 == 2) {
    iwl_dbgfs_calib_disabled_read(iwl_dbgfs_calib_disabled_ops_group2, ldvarg181,
                                  ldvarg180, ldvarg179);
    ldv_state_variable_19 = 2;
  } else {

  }
  goto ldv_56401;
  case 3: ;
  if (ldv_state_variable_19 == 2) {
    generic_file_llseek(iwl_dbgfs_calib_disabled_ops_group2, ldvarg178, ldvarg177);
    ldv_state_variable_19 = 2;
  } else {

  }
  goto ldv_56401;
  case 4: ;
  if (ldv_state_variable_19 == 2) {
    ldv_release_19();
    ldv_state_variable_19 = 1;
    ref_cnt = ref_cnt - 1;
  } else {

  }
  goto ldv_56401;
  default: 
  ldv_stop();
  }
  ldv_56401: ;
  return;
}
}
void ldv_main_exported_43(void) 
{ 
  loff_t *ldvarg316 ;
  void *tmp ;
  char *ldvarg318 ;
  void *tmp___0 ;
  size_t ldvarg317 ;
  loff_t ldvarg315 ;
  int ldvarg314 ;
    klee_make_symbolic(&ldvarg314, sizeof(int), "ldvarg314");
  int tmp___1 ;

  {
  tmp = ldv_init_zalloc(8UL);
  ldvarg316 = (loff_t *)tmp;
  tmp___0 = ldv_init_zalloc(1UL);
  ldvarg318 = (char *)tmp___0;
  ldv_memset((void *)(& ldvarg317), 0, 8UL);
  ldv_memset((void *)(& ldvarg315), 0, 8UL);
  ldv_memset((void *)(& ldvarg314), 0, 4UL);
  tmp___1 = __VERIFIER_nondet_int();
  switch (tmp___1) {
  case 0: ;
  if (ldv_state_variable_43 == 1) {
    ldv_retval_39 = simple_open(iwl_dbgfs_temperature_ops_group1, iwl_dbgfs_temperature_ops_group2);
    if (ldv_retval_39 == 0) {
      ldv_state_variable_43 = 2;
      ref_cnt = ref_cnt + 1;
    } else {

    }
  } else {

  }
  goto ldv_56416;
  case 1: ;
  if (ldv_state_variable_43 == 2) {
    iwl_dbgfs_temperature_read(iwl_dbgfs_temperature_ops_group2, ldvarg318, ldvarg317,
                               ldvarg316);
    ldv_state_variable_43 = 2;
  } else {

  }
  goto ldv_56416;
  case 2: ;
  if (ldv_state_variable_43 == 2) {
    generic_file_llseek(iwl_dbgfs_temperature_ops_group2, ldvarg315, ldvarg314);
    ldv_state_variable_43 = 2;
  } else {

  }
  goto ldv_56416;
  case 3: ;
  if (ldv_state_variable_43 == 2) {
    ldv_release_43();
    ldv_state_variable_43 = 1;
    ref_cnt = ref_cnt - 1;
  } else {

  }
  goto ldv_56416;
  default: 
  ldv_stop();
  }
  ldv_56416: ;
  return;
}
}
bool ldv_queue_work_on_283(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_7(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_delayed_work_on_284(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_7(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_work_on_285(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_7(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
void ldv_flush_workqueue_286(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
  flush_workqueue(ldv_func_arg1);
  call_and_disable_all_7(2);
  return;
}
}
bool ldv_queue_delayed_work_on_287(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_7(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
int ldv_mod_timer_288(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;

  {
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
  ldv_func_res = tmp;
  activate_pending_timer_18(ldv_func_arg1, ldv_func_arg2, 1);
  return (ldv_func_res);
}
}
int ldv_del_timer_sync_289(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___4 ldv_func_res ;
  int tmp ;

  {
  tmp = del_timer_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_suitable_timer_18(ldv_func_arg1);
  return (ldv_func_res);
}
}
extern void *memset(void * , int  , size_t  ) ;
__inline static void ldv_error(void) 
{ 


  {
  ERROR: ;
  {reach_error();}
}
}
bool ldv_is_err(void const   *ptr ) 
{ 


  {
  return ((unsigned long )ptr > 2012UL);
}
}
void *ldv_err_ptr(long error ) 
{ 


  {
  return ((void *)(2012L - error));
}
}
long ldv_ptr_err(void const   *ptr ) 
{ 


  {
  return ((long )(2012UL - (unsigned long )ptr));
}
}
bool ldv_is_err_or_null(void const   *ptr ) 
{ 
  bool tmp ;
  int tmp___0 ;

  {
  if ((unsigned long )ptr == (unsigned long )((void const   *)0)) {
    tmp___0 = 1;
  } else {
    tmp = ldv_is_err(ptr);
    if ((int )tmp) {
      tmp___0 = 1;
    } else {
      tmp___0 = 0;
    }
  }
  return ((bool )tmp___0);
}
}
int ldv_module_refcounter  =    1;
void ldv_module_get(struct module *module ) 
{ 


  {
  if ((unsigned long )module != (unsigned long )((struct module *)0)) {
    ldv_module_refcounter = ldv_module_refcounter + 1;
  } else {

  }
  return;
}
}
int ldv_try_module_get(struct module *module ) 
{ 
  int module_get_succeeded ;
    klee_make_symbolic(&module_get_succeeded, sizeof(int), "module_get_succeeded");

  {
  if ((unsigned long )module != (unsigned long )((struct module *)0)) {
    module_get_succeeded = ldv_undef_int();
    if (module_get_succeeded == 1) {
      ldv_module_refcounter = ldv_module_refcounter + 1;
      return (1);
    } else {
      return (0);
    }
  } else {

  }
  return (0);
}
}
void ldv_module_put(struct module *module ) 
{ 


  {
  if ((unsigned long )module != (unsigned long )((struct module *)0)) {
    if (ldv_module_refcounter <= 1) {
      ldv_error();
    } else {

    }
    ldv_module_refcounter = ldv_module_refcounter - 1;
  } else {

  }
  return;
}
}
void ldv_module_put_and_exit(void) 
{ 


  {
  ldv_module_put((struct module *)1);
  LDV_STOP: ;
  goto LDV_STOP;
}
}
unsigned int ldv_module_refcount(void) 
{ 


  {
  return ((unsigned int )(ldv_module_refcounter + -1));
}
}
void ldv_check_final_state(void) 
{ 


  {
  if (ldv_module_refcounter != 1) {
    ldv_error();
  } else {

  }
  return;
}
}
#include "model/linux-4.2-rc1.tar.xz-08_1a-drivers--net--wireless--iwlwifi--dvm--iwldvm.ko-entry_point_true-unreach-call.cil.out.env.c"
#include <klee/klee.h>
#include "model/common.env.c"
