extern void abort(void);
#include <assert.h>
void reach_error() { assert(0); }
/* Generated by CIL v. 1.5.1 */
/* print_CIL_Input is false */

typedef unsigned char __u8;
    klee_make_symbolic(&__u8, sizeof(char), "__u8");
typedef unsigned short __u16;
    klee_make_symbolic(&__u16, sizeof(short), "__u16");
typedef int __s32;
    klee_make_symbolic(&__s32, sizeof(int), "__s32");
typedef unsigned int __u32;
    klee_make_symbolic(&__u32, sizeof(int), "__u32");
typedef unsigned long long __u64;
    klee_make_symbolic(&__u64, sizeof(long), "__u64");
typedef signed char s8;
    klee_make_symbolic(&s8, sizeof(char), "s8");
typedef unsigned char u8;
    klee_make_symbolic(&u8, sizeof(char), "u8");
typedef unsigned short u16;
    klee_make_symbolic(&u16, sizeof(short), "u16");
typedef int s32;
    klee_make_symbolic(&s32, sizeof(int), "s32");
typedef unsigned int u32;
    klee_make_symbolic(&u32, sizeof(int), "u32");
typedef long long s64;
    klee_make_symbolic(&s64, sizeof(long), "s64");
typedef unsigned long long u64;
    klee_make_symbolic(&u64, sizeof(long), "u64");
typedef long __kernel_long_t;
    klee_make_symbolic(&__kernel_long_t, sizeof(long), "__kernel_long_t");
typedef unsigned long __kernel_ulong_t;
    klee_make_symbolic(&__kernel_ulong_t, sizeof(long), "__kernel_ulong_t");
typedef int __kernel_pid_t;
    klee_make_symbolic(&__kernel_pid_t, sizeof(int), "__kernel_pid_t");
typedef __kernel_long_t __kernel_suseconds_t;
typedef unsigned int __kernel_uid32_t;
    klee_make_symbolic(&__kernel_uid32_t, sizeof(int), "__kernel_uid32_t");
typedef unsigned int __kernel_gid32_t;
    klee_make_symbolic(&__kernel_gid32_t, sizeof(int), "__kernel_gid32_t");
typedef __kernel_ulong_t __kernel_size_t;
typedef __kernel_long_t __kernel_ssize_t;
typedef long long __kernel_loff_t;
    klee_make_symbolic(&__kernel_loff_t, sizeof(long), "__kernel_loff_t");
typedef __kernel_long_t __kernel_time_t;
typedef __kernel_long_t __kernel_clock_t;
typedef int __kernel_timer_t;
    klee_make_symbolic(&__kernel_timer_t, sizeof(int), "__kernel_timer_t");
typedef int __kernel_clockid_t;
    klee_make_symbolic(&__kernel_clockid_t, sizeof(int), "__kernel_clockid_t");
typedef __u16 __be16;
typedef __u32 __be32;
struct kernel_symbol {
   unsigned long value ;
    klee_make_symbolic(&value, sizeof(long), "value");
   char const   *name ;
};
struct module;
typedef __u32 __kernel_dev_t;
typedef __kernel_dev_t dev_t;
typedef unsigned short umode_t;
    klee_make_symbolic(&umode_t, sizeof(short), "umode_t");
typedef __kernel_pid_t pid_t;
typedef __kernel_clockid_t clockid_t;
typedef _Bool bool;
typedef __kernel_uid32_t uid_t;
typedef __kernel_gid32_t gid_t;
typedef __kernel_loff_t loff_t;
typedef __kernel_size_t size_t;
typedef __kernel_ssize_t ssize_t;
typedef __kernel_time_t time_t;
typedef unsigned int uint;
    klee_make_symbolic(&uint, sizeof(int), "uint");
typedef __s32 int32_t;
typedef __u8 uint8_t;
typedef __u32 uint32_t;
typedef __u64 uint64_t;
typedef unsigned long sector_t;
    klee_make_symbolic(&sector_t, sizeof(long), "sector_t");
typedef unsigned long blkcnt_t;
    klee_make_symbolic(&blkcnt_t, sizeof(long), "blkcnt_t");
typedef u64 dma_addr_t;
typedef unsigned int gfp_t;
    klee_make_symbolic(&gfp_t, sizeof(int), "gfp_t");
typedef unsigned int fmode_t;
    klee_make_symbolic(&fmode_t, sizeof(int), "fmode_t");
typedef unsigned int oom_flags_t;
    klee_make_symbolic(&oom_flags_t, sizeof(int), "oom_flags_t");
typedef u64 phys_addr_t;
typedef phys_addr_t resource_size_t;
struct __anonstruct_atomic_t_6 {
   int counter ;
    klee_make_symbolic(&counter, sizeof(int), "counter");
};
typedef struct __anonstruct_atomic_t_6 atomic_t;
struct __anonstruct_atomic64_t_7 {
   long counter ;
};
typedef struct __anonstruct_atomic64_t_7 atomic64_t;
struct list_head {
   struct list_head *next ;
   struct list_head *prev ;
};
struct hlist_node;
struct hlist_head {
   struct hlist_node *first ;
};
struct hlist_node {
   struct hlist_node *next ;
   struct hlist_node **pprev ;
};
struct callback_head {
   struct callback_head *next ;
   void (*func)(struct callback_head * ) ;
};
struct pt_regs {
   unsigned long r15 ;
    klee_make_symbolic(&r15, sizeof(long), "r15");
   unsigned long r14 ;
    klee_make_symbolic(&r14, sizeof(long), "r14");
   unsigned long r13 ;
    klee_make_symbolic(&r13, sizeof(long), "r13");
   unsigned long r12 ;
    klee_make_symbolic(&r12, sizeof(long), "r12");
   unsigned long bp ;
    klee_make_symbolic(&bp, sizeof(long), "bp");
   unsigned long bx ;
    klee_make_symbolic(&bx, sizeof(long), "bx");
   unsigned long r11 ;
    klee_make_symbolic(&r11, sizeof(long), "r11");
   unsigned long r10 ;
    klee_make_symbolic(&r10, sizeof(long), "r10");
   unsigned long r9 ;
    klee_make_symbolic(&r9, sizeof(long), "r9");
   unsigned long r8 ;
    klee_make_symbolic(&r8, sizeof(long), "r8");
   unsigned long ax ;
    klee_make_symbolic(&ax, sizeof(long), "ax");
   unsigned long cx ;
    klee_make_symbolic(&cx, sizeof(long), "cx");
   unsigned long dx ;
    klee_make_symbolic(&dx, sizeof(long), "dx");
   unsigned long si ;
    klee_make_symbolic(&si, sizeof(long), "si");
   unsigned long di ;
    klee_make_symbolic(&di, sizeof(long), "di");
   unsigned long orig_ax ;
    klee_make_symbolic(&orig_ax, sizeof(long), "orig_ax");
   unsigned long ip ;
    klee_make_symbolic(&ip, sizeof(long), "ip");
   unsigned long cs ;
    klee_make_symbolic(&cs, sizeof(long), "cs");
   unsigned long flags ;
    klee_make_symbolic(&flags, sizeof(long), "flags");
   unsigned long sp ;
    klee_make_symbolic(&sp, sizeof(long), "sp");
   unsigned long ss ;
    klee_make_symbolic(&ss, sizeof(long), "ss");
};
struct __anonstruct____missing_field_name_9 {
   unsigned int a ;
    klee_make_symbolic(&a, sizeof(int), "a");
   unsigned int b ;
    klee_make_symbolic(&b, sizeof(int), "b");
};
struct __anonstruct____missing_field_name_10 {
   u16 limit0 ;
   u16 base0 ;
   unsigned char base1 ;
    klee_make_symbolic(&base1, sizeof(char), "base1");
   unsigned char type : 4 ;
   unsigned char s : 1 ;
   unsigned char dpl : 2 ;
   unsigned char p : 1 ;
   unsigned char limit : 4 ;
   unsigned char avl : 1 ;
   unsigned char l : 1 ;
   unsigned char d : 1 ;
   unsigned char g : 1 ;
   unsigned char base2 ;
    klee_make_symbolic(&base2, sizeof(char), "base2");
};
union __anonunion____missing_field_name_8 {
   struct __anonstruct____missing_field_name_9 __annonCompField4 ;
   struct __anonstruct____missing_field_name_10 __annonCompField5 ;
};
struct desc_struct {
   union __anonunion____missing_field_name_8 __annonCompField6 ;
};
typedef unsigned long pteval_t;
    klee_make_symbolic(&pteval_t, sizeof(long), "pteval_t");
typedef unsigned long pgdval_t;
    klee_make_symbolic(&pgdval_t, sizeof(long), "pgdval_t");
typedef unsigned long pgprotval_t;
    klee_make_symbolic(&pgprotval_t, sizeof(long), "pgprotval_t");
struct __anonstruct_pte_t_11 {
   pteval_t pte ;
};
typedef struct __anonstruct_pte_t_11 pte_t;
struct pgprot {
   pgprotval_t pgprot ;
};
typedef struct pgprot pgprot_t;
struct __anonstruct_pgd_t_12 {
   pgdval_t pgd ;
};
typedef struct __anonstruct_pgd_t_12 pgd_t;
struct page;
typedef struct page *pgtable_t;
struct file;
struct seq_file;
struct thread_struct;
struct mm_struct;
struct task_struct;
struct cpumask;
struct qspinlock {
   atomic_t val ;
};
typedef struct qspinlock arch_spinlock_t;
struct qrwlock {
   atomic_t cnts ;
   arch_spinlock_t lock ;
};
typedef struct qrwlock arch_rwlock_t;
typedef void (*ctor_fn_t)(void);
struct device;
struct file_operations;
struct completion;
struct lockdep_map;
struct kernel_vm86_regs {
   struct pt_regs pt ;
   unsigned short es ;
    klee_make_symbolic(&es, sizeof(short), "es");
   unsigned short __esh ;
    klee_make_symbolic(&__esh, sizeof(short), "__esh");
   unsigned short ds ;
    klee_make_symbolic(&ds, sizeof(short), "ds");
   unsigned short __dsh ;
    klee_make_symbolic(&__dsh, sizeof(short), "__dsh");
   unsigned short fs ;
    klee_make_symbolic(&fs, sizeof(short), "fs");
   unsigned short __fsh ;
    klee_make_symbolic(&__fsh, sizeof(short), "__fsh");
   unsigned short gs ;
    klee_make_symbolic(&gs, sizeof(short), "gs");
   unsigned short __gsh ;
    klee_make_symbolic(&__gsh, sizeof(short), "__gsh");
};
union __anonunion____missing_field_name_15 {
   struct pt_regs *regs ;
   struct kernel_vm86_regs *vm86 ;
};
struct math_emu_info {
   long ___orig_eip ;
    klee_make_symbolic(&___orig_eip, sizeof(long), "___orig_eip");
   union __anonunion____missing_field_name_15 __annonCompField7 ;
};
struct bug_entry {
   int bug_addr_disp ;
    klee_make_symbolic(&bug_addr_disp, sizeof(int), "bug_addr_disp");
   int file_disp ;
    klee_make_symbolic(&file_disp, sizeof(int), "file_disp");
   unsigned short line ;
    klee_make_symbolic(&line, sizeof(short), "line");
   unsigned short flags ;
};
struct cpumask {
   unsigned long bits[128U] ;
};
typedef struct cpumask cpumask_t;
typedef struct cpumask *cpumask_var_t;
struct fregs_state {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20U] ;
   u32 status ;
};
struct __anonstruct____missing_field_name_25 {
   u64 rip ;
   u64 rdp ;
};
struct __anonstruct____missing_field_name_26 {
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
};
union __anonunion____missing_field_name_24 {
   struct __anonstruct____missing_field_name_25 __annonCompField11 ;
   struct __anonstruct____missing_field_name_26 __annonCompField12 ;
};
union __anonunion____missing_field_name_27 {
   u32 padding1[12U] ;
   u32 sw_reserved[12U] ;
};
struct fxregs_state {
   u16 cwd ;
   u16 swd ;
   u16 twd ;
   u16 fop ;
   union __anonunion____missing_field_name_24 __annonCompField13 ;
   u32 mxcsr ;
   u32 mxcsr_mask ;
   u32 st_space[32U] ;
   u32 xmm_space[64U] ;
   u32 padding[12U] ;
   union __anonunion____missing_field_name_27 __annonCompField14 ;
};
struct swregs_state {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20U] ;
   u8 ftop ;
   u8 changed ;
   u8 lookahead ;
   u8 no_update ;
   u8 rm ;
   u8 alimit ;
   struct math_emu_info *info ;
   u32 entry_eip ;
};
struct xstate_header {
   u64 xfeatures ;
   u64 xcomp_bv ;
   u64 reserved[6U] ;
};
struct xregs_state {
   struct fxregs_state i387 ;
   struct xstate_header header ;
   u8 __reserved[464U] ;
};
union fpregs_state {
   struct fregs_state fsave ;
   struct fxregs_state fxsave ;
   struct swregs_state soft ;
   struct xregs_state xsave ;
};
struct fpu {
   union fpregs_state state ;
   unsigned int last_cpu ;
    klee_make_symbolic(&last_cpu, sizeof(int), "last_cpu");
   unsigned char fpstate_active ;
    klee_make_symbolic(&fpstate_active, sizeof(char), "fpstate_active");
   unsigned char fpregs_active ;
    klee_make_symbolic(&fpregs_active, sizeof(char), "fpregs_active");
   unsigned char counter ;
};
struct seq_operations;
struct perf_event;
struct thread_struct {
   struct desc_struct tls_array[3U] ;
   unsigned long sp0 ;
    klee_make_symbolic(&sp0, sizeof(long), "sp0");
   unsigned long sp ;
   unsigned short es ;
   unsigned short ds ;
   unsigned short fsindex ;
    klee_make_symbolic(&fsindex, sizeof(short), "fsindex");
   unsigned short gsindex ;
    klee_make_symbolic(&gsindex, sizeof(short), "gsindex");
   unsigned long fs ;
   unsigned long gs ;
   struct fpu fpu ;
   struct perf_event *ptrace_bps[4U] ;
   unsigned long debugreg6 ;
    klee_make_symbolic(&debugreg6, sizeof(long), "debugreg6");
   unsigned long ptrace_dr7 ;
    klee_make_symbolic(&ptrace_dr7, sizeof(long), "ptrace_dr7");
   unsigned long cr2 ;
    klee_make_symbolic(&cr2, sizeof(long), "cr2");
   unsigned long trap_nr ;
    klee_make_symbolic(&trap_nr, sizeof(long), "trap_nr");
   unsigned long error_code ;
    klee_make_symbolic(&error_code, sizeof(long), "error_code");
   unsigned long *io_bitmap_ptr ;
   unsigned long iopl ;
    klee_make_symbolic(&iopl, sizeof(long), "iopl");
   unsigned int io_bitmap_max ;
    klee_make_symbolic(&io_bitmap_max, sizeof(int), "io_bitmap_max");
};
typedef atomic64_t atomic_long_t;
struct stack_trace {
   unsigned int nr_entries ;
    klee_make_symbolic(&nr_entries, sizeof(int), "nr_entries");
   unsigned int max_entries ;
    klee_make_symbolic(&max_entries, sizeof(int), "max_entries");
   unsigned long *entries ;
   int skip ;
    klee_make_symbolic(&skip, sizeof(int), "skip");
};
struct lockdep_subclass_key {
   char __one_byte ;
    klee_make_symbolic(&__one_byte, sizeof(char), "__one_byte");
};
struct lock_class_key {
   struct lockdep_subclass_key subkeys[8U] ;
};
struct lock_class {
   struct list_head hash_entry ;
   struct list_head lock_entry ;
   struct lockdep_subclass_key *key ;
   unsigned int subclass ;
    klee_make_symbolic(&subclass, sizeof(int), "subclass");
   unsigned int dep_gen_id ;
    klee_make_symbolic(&dep_gen_id, sizeof(int), "dep_gen_id");
   unsigned long usage_mask ;
    klee_make_symbolic(&usage_mask, sizeof(long), "usage_mask");
   struct stack_trace usage_traces[13U] ;
   struct list_head locks_after ;
   struct list_head locks_before ;
   unsigned int version ;
    klee_make_symbolic(&version, sizeof(int), "version");
   unsigned long ops ;
    klee_make_symbolic(&ops, sizeof(long), "ops");
   char const   *name ;
   int name_version ;
    klee_make_symbolic(&name_version, sizeof(int), "name_version");
   unsigned long contention_point[4U] ;
   unsigned long contending_point[4U] ;
};
struct lockdep_map {
   struct lock_class_key *key ;
   struct lock_class *class_cache[2U] ;
   char const   *name ;
   int cpu ;
    klee_make_symbolic(&cpu, sizeof(int), "cpu");
   unsigned long ip ;
};
struct held_lock {
   u64 prev_chain_key ;
   unsigned long acquire_ip ;
    klee_make_symbolic(&acquire_ip, sizeof(long), "acquire_ip");
   struct lockdep_map *instance ;
   struct lockdep_map *nest_lock ;
   u64 waittime_stamp ;
   u64 holdtime_stamp ;
   unsigned short class_idx : 13 ;
   unsigned char irq_context : 2 ;
   unsigned char trylock : 1 ;
   unsigned char read : 2 ;
   unsigned char check : 1 ;
   unsigned char hardirqs_off : 1 ;
   unsigned short references : 12 ;
   unsigned int pin_count ;
    klee_make_symbolic(&pin_count, sizeof(int), "pin_count");
};
struct raw_spinlock {
   arch_spinlock_t raw_lock ;
   unsigned int magic ;
    klee_make_symbolic(&magic, sizeof(int), "magic");
   unsigned int owner_cpu ;
    klee_make_symbolic(&owner_cpu, sizeof(int), "owner_cpu");
   void *owner ;
   struct lockdep_map dep_map ;
};
typedef struct raw_spinlock raw_spinlock_t;
struct __anonstruct____missing_field_name_31 {
   u8 __padding[24U] ;
   struct lockdep_map dep_map ;
};
union __anonunion____missing_field_name_30 {
   struct raw_spinlock rlock ;
   struct __anonstruct____missing_field_name_31 __annonCompField16 ;
};
struct spinlock {
   union __anonunion____missing_field_name_30 __annonCompField17 ;
};
typedef struct spinlock spinlock_t;
struct __anonstruct_rwlock_t_32 {
   arch_rwlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
   struct lockdep_map dep_map ;
};
typedef struct __anonstruct_rwlock_t_32 rwlock_t;
struct optimistic_spin_queue {
   atomic_t tail ;
};
struct mutex {
   atomic_t count ;
   spinlock_t wait_lock ;
   struct list_head wait_list ;
   struct task_struct *owner ;
   void *magic ;
   struct lockdep_map dep_map ;
};
struct mutex_waiter {
   struct list_head list ;
   struct task_struct *task ;
   void *magic ;
};
struct timespec;
struct compat_timespec;
struct __anonstruct_futex_34 {
   u32 *uaddr ;
   u32 val ;
   u32 flags ;
   u32 bitset ;
   u64 time ;
   u32 *uaddr2 ;
};
struct __anonstruct_nanosleep_35 {
   clockid_t clockid ;
   struct timespec *rmtp ;
   struct compat_timespec *compat_rmtp ;
   u64 expires ;
};
struct pollfd;
struct __anonstruct_poll_36 {
   struct pollfd *ufds ;
   int nfds ;
    klee_make_symbolic(&nfds, sizeof(int), "nfds");
   int has_timeout ;
    klee_make_symbolic(&has_timeout, sizeof(int), "has_timeout");
   unsigned long tv_sec ;
    klee_make_symbolic(&tv_sec, sizeof(long), "tv_sec");
   unsigned long tv_nsec ;
    klee_make_symbolic(&tv_nsec, sizeof(long), "tv_nsec");
};
union __anonunion____missing_field_name_33 {
   struct __anonstruct_futex_34 futex ;
   struct __anonstruct_nanosleep_35 nanosleep ;
   struct __anonstruct_poll_36 poll ;
};
struct restart_block {
   long (*fn)(struct restart_block * ) ;
   union __anonunion____missing_field_name_33 __annonCompField18 ;
};
struct seqcount {
   unsigned int sequence ;
    klee_make_symbolic(&sequence, sizeof(int), "sequence");
   struct lockdep_map dep_map ;
};
typedef struct seqcount seqcount_t;
struct __anonstruct_seqlock_t_45 {
   struct seqcount seqcount ;
   spinlock_t lock ;
};
typedef struct __anonstruct_seqlock_t_45 seqlock_t;
struct timespec {
   __kernel_time_t tv_sec ;
   long tv_nsec ;
};
struct timeval {
   __kernel_time_t tv_sec ;
   __kernel_suseconds_t tv_usec ;
};
union ktime {
   s64 tv64 ;
};
typedef union ktime ktime_t;
struct timer_list {
   struct hlist_node entry ;
   unsigned long expires ;
    klee_make_symbolic(&expires, sizeof(long), "expires");
   void (*function)(unsigned long  ) ;
   unsigned long data ;
    klee_make_symbolic(&data, sizeof(long), "data");
   u32 flags ;
   int slack ;
    klee_make_symbolic(&slack, sizeof(int), "slack");
   int start_pid ;
    klee_make_symbolic(&start_pid, sizeof(int), "start_pid");
   void *start_site ;
   char start_comm[16U] ;
   struct lockdep_map lockdep_map ;
};
struct hrtimer;
enum hrtimer_restart;
struct __wait_queue_head {
   spinlock_t lock ;
   struct list_head task_list ;
};
typedef struct __wait_queue_head wait_queue_head_t;
struct completion {
   unsigned int done ;
    klee_make_symbolic(&done, sizeof(int), "done");
   wait_queue_head_t wait ;
};
struct rb_node {
   unsigned long __rb_parent_color ;
    klee_make_symbolic(&__rb_parent_color, sizeof(long), "__rb_parent_color");
   struct rb_node *rb_right ;
   struct rb_node *rb_left ;
};
struct rb_root {
   struct rb_node *rb_node ;
};
struct nsproxy;
struct workqueue_struct;
struct work_struct;
struct work_struct {
   atomic_long_t data ;
   struct list_head entry ;
   void (*func)(struct work_struct * ) ;
   struct lockdep_map lockdep_map ;
};
struct delayed_work {
   struct work_struct work ;
   struct timer_list timer ;
   struct workqueue_struct *wq ;
   int cpu ;
};
struct execute_work {
   struct work_struct work ;
};
struct vm_area_struct;
struct __anonstruct_nodemask_t_48 {
   unsigned long bits[16U] ;
};
typedef struct __anonstruct_nodemask_t_48 nodemask_t;
struct rw_semaphore;
struct rw_semaphore {
   long count ;
    klee_make_symbolic(&count, sizeof(long), "count");
   struct list_head wait_list ;
   raw_spinlock_t wait_lock ;
   struct optimistic_spin_queue osq ;
   struct task_struct *owner ;
   struct lockdep_map dep_map ;
};
struct resource {
   resource_size_t start ;
   resource_size_t end ;
   char const   *name ;
   unsigned long flags ;
   struct resource *parent ;
   struct resource *sibling ;
   struct resource *child ;
};
struct pci_dev;
struct pm_message {
   int event ;
    klee_make_symbolic(&event, sizeof(int), "event");
};
typedef struct pm_message pm_message_t;
struct dev_pm_ops {
   int (*prepare)(struct device * ) ;
   void (*complete)(struct device * ) ;
   int (*suspend)(struct device * ) ;
   int (*resume)(struct device * ) ;
   int (*freeze)(struct device * ) ;
   int (*thaw)(struct device * ) ;
   int (*poweroff)(struct device * ) ;
   int (*restore)(struct device * ) ;
   int (*suspend_late)(struct device * ) ;
   int (*resume_early)(struct device * ) ;
   int (*freeze_late)(struct device * ) ;
   int (*thaw_early)(struct device * ) ;
   int (*poweroff_late)(struct device * ) ;
   int (*restore_early)(struct device * ) ;
   int (*suspend_noirq)(struct device * ) ;
   int (*resume_noirq)(struct device * ) ;
   int (*freeze_noirq)(struct device * ) ;
   int (*thaw_noirq)(struct device * ) ;
   int (*poweroff_noirq)(struct device * ) ;
   int (*restore_noirq)(struct device * ) ;
   int (*runtime_suspend)(struct device * ) ;
   int (*runtime_resume)(struct device * ) ;
   int (*runtime_idle)(struct device * ) ;
};
enum rpm_status {
    RPM_ACTIVE = 0,
    RPM_RESUMING = 1,
    RPM_SUSPENDED = 2,
    RPM_SUSPENDING = 3
} ;
enum rpm_request {
    RPM_REQ_NONE = 0,
    RPM_REQ_IDLE = 1,
    RPM_REQ_SUSPEND = 2,
    RPM_REQ_AUTOSUSPEND = 3,
    RPM_REQ_RESUME = 4
} ;
struct wakeup_source;
struct wake_irq;
struct pm_subsys_data {
   spinlock_t lock ;
   unsigned int refcount ;
    klee_make_symbolic(&refcount, sizeof(int), "refcount");
   struct list_head clock_list ;
};
struct dev_pm_qos;
struct dev_pm_info {
   pm_message_t power_state ;
   unsigned char can_wakeup : 1 ;
   unsigned char async_suspend : 1 ;
   bool is_prepared ;
   bool is_suspended ;
   bool is_noirq_suspended ;
   bool is_late_suspended ;
   bool ignore_children ;
   bool early_init ;
   bool direct_complete ;
   spinlock_t lock ;
   struct list_head entry ;
   struct completion completion ;
   struct wakeup_source *wakeup ;
   bool wakeup_path ;
   bool syscore ;
   struct timer_list suspend_timer ;
   unsigned long timer_expires ;
    klee_make_symbolic(&timer_expires, sizeof(long), "timer_expires");
   struct work_struct work ;
   wait_queue_head_t wait_queue ;
   struct wake_irq *wakeirq ;
   atomic_t usage_count ;
   atomic_t child_count ;
   unsigned char disable_depth : 3 ;
   unsigned char idle_notification : 1 ;
   unsigned char request_pending : 1 ;
   unsigned char deferred_resume : 1 ;
   unsigned char run_wake : 1 ;
   unsigned char runtime_auto : 1 ;
   unsigned char no_callbacks : 1 ;
   unsigned char irq_safe : 1 ;
   unsigned char use_autosuspend : 1 ;
   unsigned char timer_autosuspends : 1 ;
   unsigned char memalloc_noio : 1 ;
   enum rpm_request request ;
   enum rpm_status runtime_status ;
   int runtime_error ;
    klee_make_symbolic(&runtime_error, sizeof(int), "runtime_error");
   int autosuspend_delay ;
    klee_make_symbolic(&autosuspend_delay, sizeof(int), "autosuspend_delay");
   unsigned long last_busy ;
    klee_make_symbolic(&last_busy, sizeof(long), "last_busy");
   unsigned long active_jiffies ;
    klee_make_symbolic(&active_jiffies, sizeof(long), "active_jiffies");
   unsigned long suspended_jiffies ;
    klee_make_symbolic(&suspended_jiffies, sizeof(long), "suspended_jiffies");
   unsigned long accounting_timestamp ;
    klee_make_symbolic(&accounting_timestamp, sizeof(long), "accounting_timestamp");
   struct pm_subsys_data *subsys_data ;
   void (*set_latency_tolerance)(struct device * , s32  ) ;
   struct dev_pm_qos *qos ;
};
struct dev_pm_domain {
   struct dev_pm_ops ops ;
   void (*detach)(struct device * , bool  ) ;
   int (*activate)(struct device * ) ;
   void (*sync)(struct device * ) ;
   void (*dismiss)(struct device * ) ;
};
struct pci_bus;
struct __anonstruct_mm_context_t_113 {
   void *ldt ;
   int size ;
    klee_make_symbolic(&size, sizeof(int), "size");
   unsigned short ia32_compat ;
    klee_make_symbolic(&ia32_compat, sizeof(short), "ia32_compat");
   struct mutex lock ;
   void *vdso ;
   atomic_t perf_rdpmc_allowed ;
};
typedef struct __anonstruct_mm_context_t_113 mm_context_t;
struct bio_vec;
struct llist_node;
struct llist_node {
   struct llist_node *next ;
};
struct call_single_data {
   struct llist_node llist ;
   void (*func)(void * ) ;
   void *info ;
   unsigned int flags ;
};
struct kmem_cache;
struct kernel_cap_struct {
   __u32 cap[2U] ;
};
typedef struct kernel_cap_struct kernel_cap_t;
struct inode;
struct dentry;
struct user_namespace;
struct plist_node {
   int prio ;
    klee_make_symbolic(&prio, sizeof(int), "prio");
   struct list_head prio_list ;
   struct list_head node_list ;
};
struct arch_uprobe_task {
   unsigned long saved_scratch_register ;
    klee_make_symbolic(&saved_scratch_register, sizeof(long), "saved_scratch_register");
   unsigned int saved_trap_nr ;
    klee_make_symbolic(&saved_trap_nr, sizeof(int), "saved_trap_nr");
   unsigned int saved_tf ;
    klee_make_symbolic(&saved_tf, sizeof(int), "saved_tf");
};
enum uprobe_task_state {
    UTASK_RUNNING = 0,
    UTASK_SSTEP = 1,
    UTASK_SSTEP_ACK = 2,
    UTASK_SSTEP_TRAPPED = 3
} ;
struct __anonstruct____missing_field_name_146 {
   struct arch_uprobe_task autask ;
   unsigned long vaddr ;
    klee_make_symbolic(&vaddr, sizeof(long), "vaddr");
};
struct __anonstruct____missing_field_name_147 {
   struct callback_head dup_xol_work ;
   unsigned long dup_xol_addr ;
    klee_make_symbolic(&dup_xol_addr, sizeof(long), "dup_xol_addr");
};
union __anonunion____missing_field_name_145 {
   struct __anonstruct____missing_field_name_146 __annonCompField33 ;
   struct __anonstruct____missing_field_name_147 __annonCompField34 ;
};
struct uprobe;
struct return_instance;
struct uprobe_task {
   enum uprobe_task_state state ;
   union __anonunion____missing_field_name_145 __annonCompField35 ;
   struct uprobe *active_uprobe ;
   unsigned long xol_vaddr ;
    klee_make_symbolic(&xol_vaddr, sizeof(long), "xol_vaddr");
   struct return_instance *return_instances ;
   unsigned int depth ;
    klee_make_symbolic(&depth, sizeof(int), "depth");
};
struct xol_area;
struct uprobes_state {
   struct xol_area *xol_area ;
};
struct address_space;
struct mem_cgroup;
typedef void compound_page_dtor(struct page * );
union __anonunion____missing_field_name_148 {
   struct address_space *mapping ;
   void *s_mem ;
};
union __anonunion____missing_field_name_150 {
   unsigned long index ;
    klee_make_symbolic(&index, sizeof(long), "index");
   void *freelist ;
   bool pfmemalloc ;
};
struct __anonstruct____missing_field_name_154 {
   unsigned short inuse ;
    klee_make_symbolic(&inuse, sizeof(short), "inuse");
   unsigned short objects : 15 ;
   unsigned char frozen : 1 ;
};
union __anonunion____missing_field_name_153 {
   atomic_t _mapcount ;
   struct __anonstruct____missing_field_name_154 __annonCompField38 ;
   int units ;
    klee_make_symbolic(&units, sizeof(int), "units");
};
struct __anonstruct____missing_field_name_152 {
   union __anonunion____missing_field_name_153 __annonCompField39 ;
   atomic_t _count ;
};
union __anonunion____missing_field_name_151 {
   unsigned long counters ;
    klee_make_symbolic(&counters, sizeof(long), "counters");
   struct __anonstruct____missing_field_name_152 __annonCompField40 ;
   unsigned int active ;
    klee_make_symbolic(&active, sizeof(int), "active");
};
struct __anonstruct____missing_field_name_149 {
   union __anonunion____missing_field_name_150 __annonCompField37 ;
   union __anonunion____missing_field_name_151 __annonCompField41 ;
};
struct __anonstruct____missing_field_name_156 {
   struct page *next ;
   int pages ;
    klee_make_symbolic(&pages, sizeof(int), "pages");
   int pobjects ;
    klee_make_symbolic(&pobjects, sizeof(int), "pobjects");
};
struct slab;
struct __anonstruct____missing_field_name_157 {
   compound_page_dtor *compound_dtor ;
   unsigned long compound_order ;
    klee_make_symbolic(&compound_order, sizeof(long), "compound_order");
};
union __anonunion____missing_field_name_155 {
   struct list_head lru ;
   struct __anonstruct____missing_field_name_156 __annonCompField43 ;
   struct slab *slab_page ;
   struct callback_head callback_head ;
   struct __anonstruct____missing_field_name_157 __annonCompField44 ;
   pgtable_t pmd_huge_pte ;
};
union __anonunion____missing_field_name_158 {
   unsigned long private ;
    klee_make_symbolic(&private, sizeof(long), "private");
   spinlock_t *ptl ;
   struct kmem_cache *slab_cache ;
   struct page *first_page ;
};
struct page {
   unsigned long flags ;
   union __anonunion____missing_field_name_148 __annonCompField36 ;
   struct __anonstruct____missing_field_name_149 __annonCompField42 ;
   union __anonunion____missing_field_name_155 __annonCompField45 ;
   union __anonunion____missing_field_name_158 __annonCompField46 ;
   struct mem_cgroup *mem_cgroup ;
};
struct page_frag {
   struct page *page ;
   __u32 offset ;
   __u32 size ;
};
struct __anonstruct_shared_159 {
   struct rb_node rb ;
   unsigned long rb_subtree_last ;
    klee_make_symbolic(&rb_subtree_last, sizeof(long), "rb_subtree_last");
};
struct anon_vma;
struct vm_operations_struct;
struct mempolicy;
struct vm_area_struct {
   unsigned long vm_start ;
    klee_make_symbolic(&vm_start, sizeof(long), "vm_start");
   unsigned long vm_end ;
    klee_make_symbolic(&vm_end, sizeof(long), "vm_end");
   struct vm_area_struct *vm_next ;
   struct vm_area_struct *vm_prev ;
   struct rb_node vm_rb ;
   unsigned long rb_subtree_gap ;
    klee_make_symbolic(&rb_subtree_gap, sizeof(long), "rb_subtree_gap");
   struct mm_struct *vm_mm ;
   pgprot_t vm_page_prot ;
   unsigned long vm_flags ;
    klee_make_symbolic(&vm_flags, sizeof(long), "vm_flags");
   struct __anonstruct_shared_159 shared ;
   struct list_head anon_vma_chain ;
   struct anon_vma *anon_vma ;
   struct vm_operations_struct  const  *vm_ops ;
   unsigned long vm_pgoff ;
    klee_make_symbolic(&vm_pgoff, sizeof(long), "vm_pgoff");
   struct file *vm_file ;
   void *vm_private_data ;
   struct mempolicy *vm_policy ;
};
struct core_thread {
   struct task_struct *task ;
   struct core_thread *next ;
};
struct core_state {
   atomic_t nr_threads ;
   struct core_thread dumper ;
   struct completion startup ;
};
struct task_rss_stat {
   int events ;
    klee_make_symbolic(&events, sizeof(int), "events");
   int count[3U] ;
};
struct mm_rss_stat {
   atomic_long_t count[3U] ;
};
struct kioctx_table;
struct linux_binfmt;
struct mmu_notifier_mm;
struct mm_struct {
   struct vm_area_struct *mmap ;
   struct rb_root mm_rb ;
   u32 vmacache_seqnum ;
   unsigned long (*get_unmapped_area)(struct file * , unsigned long  , unsigned long  ,
                                      unsigned long  , unsigned long  ) ;
   unsigned long mmap_base ;
    klee_make_symbolic(&mmap_base, sizeof(long), "mmap_base");
   unsigned long mmap_legacy_base ;
    klee_make_symbolic(&mmap_legacy_base, sizeof(long), "mmap_legacy_base");
   unsigned long task_size ;
    klee_make_symbolic(&task_size, sizeof(long), "task_size");
   unsigned long highest_vm_end ;
    klee_make_symbolic(&highest_vm_end, sizeof(long), "highest_vm_end");
   pgd_t *pgd ;
   atomic_t mm_users ;
   atomic_t mm_count ;
   atomic_long_t nr_ptes ;
   atomic_long_t nr_pmds ;
   int map_count ;
    klee_make_symbolic(&map_count, sizeof(int), "map_count");
   spinlock_t page_table_lock ;
   struct rw_semaphore mmap_sem ;
   struct list_head mmlist ;
   unsigned long hiwater_rss ;
    klee_make_symbolic(&hiwater_rss, sizeof(long), "hiwater_rss");
   unsigned long hiwater_vm ;
    klee_make_symbolic(&hiwater_vm, sizeof(long), "hiwater_vm");
   unsigned long total_vm ;
    klee_make_symbolic(&total_vm, sizeof(long), "total_vm");
   unsigned long locked_vm ;
    klee_make_symbolic(&locked_vm, sizeof(long), "locked_vm");
   unsigned long pinned_vm ;
    klee_make_symbolic(&pinned_vm, sizeof(long), "pinned_vm");
   unsigned long shared_vm ;
    klee_make_symbolic(&shared_vm, sizeof(long), "shared_vm");
   unsigned long exec_vm ;
    klee_make_symbolic(&exec_vm, sizeof(long), "exec_vm");
   unsigned long stack_vm ;
    klee_make_symbolic(&stack_vm, sizeof(long), "stack_vm");
   unsigned long def_flags ;
    klee_make_symbolic(&def_flags, sizeof(long), "def_flags");
   unsigned long start_code ;
    klee_make_symbolic(&start_code, sizeof(long), "start_code");
   unsigned long end_code ;
    klee_make_symbolic(&end_code, sizeof(long), "end_code");
   unsigned long start_data ;
    klee_make_symbolic(&start_data, sizeof(long), "start_data");
   unsigned long end_data ;
    klee_make_symbolic(&end_data, sizeof(long), "end_data");
   unsigned long start_brk ;
    klee_make_symbolic(&start_brk, sizeof(long), "start_brk");
   unsigned long brk ;
    klee_make_symbolic(&brk, sizeof(long), "brk");
   unsigned long start_stack ;
    klee_make_symbolic(&start_stack, sizeof(long), "start_stack");
   unsigned long arg_start ;
    klee_make_symbolic(&arg_start, sizeof(long), "arg_start");
   unsigned long arg_end ;
    klee_make_symbolic(&arg_end, sizeof(long), "arg_end");
   unsigned long env_start ;
    klee_make_symbolic(&env_start, sizeof(long), "env_start");
   unsigned long env_end ;
    klee_make_symbolic(&env_end, sizeof(long), "env_end");
   unsigned long saved_auxv[46U] ;
   struct mm_rss_stat rss_stat ;
   struct linux_binfmt *binfmt ;
   cpumask_var_t cpu_vm_mask_var ;
   mm_context_t context ;
   unsigned long flags ;
   struct core_state *core_state ;
   spinlock_t ioctx_lock ;
   struct kioctx_table *ioctx_table ;
   struct task_struct *owner ;
   struct file *exe_file ;
   struct mmu_notifier_mm *mmu_notifier_mm ;
   struct cpumask cpumask_allocation ;
   unsigned long numa_next_scan ;
    klee_make_symbolic(&numa_next_scan, sizeof(long), "numa_next_scan");
   unsigned long numa_scan_offset ;
    klee_make_symbolic(&numa_scan_offset, sizeof(long), "numa_scan_offset");
   int numa_scan_seq ;
    klee_make_symbolic(&numa_scan_seq, sizeof(int), "numa_scan_seq");
   bool tlb_flush_pending ;
   struct uprobes_state uprobes_state ;
   void *bd_addr ;
};
typedef unsigned long cputime_t;
    klee_make_symbolic(&cputime_t, sizeof(long), "cputime_t");
struct __anonstruct_kuid_t_161 {
   uid_t val ;
};
typedef struct __anonstruct_kuid_t_161 kuid_t;
struct __anonstruct_kgid_t_162 {
   gid_t val ;
};
typedef struct __anonstruct_kgid_t_162 kgid_t;
struct sem_undo_list;
struct sysv_sem {
   struct sem_undo_list *undo_list ;
};
struct user_struct;
struct sysv_shm {
   struct list_head shm_clist ;
};
struct __anonstruct_sigset_t_163 {
   unsigned long sig[1U] ;
};
typedef struct __anonstruct_sigset_t_163 sigset_t;
struct siginfo;
typedef void __signalfn_t(int  );
typedef __signalfn_t *__sighandler_t;
typedef void __restorefn_t(void);
typedef __restorefn_t *__sigrestore_t;
union sigval {
   int sival_int ;
    klee_make_symbolic(&sival_int, sizeof(int), "sival_int");
   void *sival_ptr ;
};
typedef union sigval sigval_t;
struct __anonstruct__kill_165 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
};
struct __anonstruct__timer_166 {
   __kernel_timer_t _tid ;
   int _overrun ;
    klee_make_symbolic(&_overrun, sizeof(int), "_overrun");
   char _pad[0U] ;
   sigval_t _sigval ;
   int _sys_private ;
    klee_make_symbolic(&_sys_private, sizeof(int), "_sys_private");
};
struct __anonstruct__rt_167 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
   sigval_t _sigval ;
};
struct __anonstruct__sigchld_168 {
   __kernel_pid_t _pid ;
   __kernel_uid32_t _uid ;
   int _status ;
    klee_make_symbolic(&_status, sizeof(int), "_status");
   __kernel_clock_t _utime ;
   __kernel_clock_t _stime ;
};
struct __anonstruct__addr_bnd_170 {
   void *_lower ;
   void *_upper ;
};
struct __anonstruct__sigfault_169 {
   void *_addr ;
   short _addr_lsb ;
    klee_make_symbolic(&_addr_lsb, sizeof(short), "_addr_lsb");
   struct __anonstruct__addr_bnd_170 _addr_bnd ;
};
struct __anonstruct__sigpoll_171 {
   long _band ;
    klee_make_symbolic(&_band, sizeof(long), "_band");
   int _fd ;
    klee_make_symbolic(&_fd, sizeof(int), "_fd");
};
struct __anonstruct__sigsys_172 {
   void *_call_addr ;
   int _syscall ;
    klee_make_symbolic(&_syscall, sizeof(int), "_syscall");
   unsigned int _arch ;
    klee_make_symbolic(&_arch, sizeof(int), "_arch");
};
union __anonunion__sifields_164 {
   int _pad[28U] ;
   struct __anonstruct__kill_165 _kill ;
   struct __anonstruct__timer_166 _timer ;
   struct __anonstruct__rt_167 _rt ;
   struct __anonstruct__sigchld_168 _sigchld ;
   struct __anonstruct__sigfault_169 _sigfault ;
   struct __anonstruct__sigpoll_171 _sigpoll ;
   struct __anonstruct__sigsys_172 _sigsys ;
};
struct siginfo {
   int si_signo ;
    klee_make_symbolic(&si_signo, sizeof(int), "si_signo");
   int si_errno ;
    klee_make_symbolic(&si_errno, sizeof(int), "si_errno");
   int si_code ;
    klee_make_symbolic(&si_code, sizeof(int), "si_code");
   union __anonunion__sifields_164 _sifields ;
};
typedef struct siginfo siginfo_t;
struct sigpending {
   struct list_head list ;
   sigset_t signal ;
};
struct sigaction {
   __sighandler_t sa_handler ;
   unsigned long sa_flags ;
    klee_make_symbolic(&sa_flags, sizeof(long), "sa_flags");
   __sigrestore_t sa_restorer ;
   sigset_t sa_mask ;
};
struct k_sigaction {
   struct sigaction sa ;
};
enum pid_type {
    PIDTYPE_PID = 0,
    PIDTYPE_PGID = 1,
    PIDTYPE_SID = 2,
    PIDTYPE_MAX = 3
} ;
struct pid_namespace;
struct upid {
   int nr ;
    klee_make_symbolic(&nr, sizeof(int), "nr");
   struct pid_namespace *ns ;
   struct hlist_node pid_chain ;
};
struct pid {
   atomic_t count ;
   unsigned int level ;
    klee_make_symbolic(&level, sizeof(int), "level");
   struct hlist_head tasks[3U] ;
   struct callback_head rcu ;
   struct upid numbers[1U] ;
};
struct pid_link {
   struct hlist_node node ;
   struct pid *pid ;
};
struct percpu_counter {
   raw_spinlock_t lock ;
   s64 count ;
   struct list_head list ;
   s32 *counters ;
};
struct seccomp_filter;
struct seccomp {
   int mode ;
    klee_make_symbolic(&mode, sizeof(int), "mode");
   struct seccomp_filter *filter ;
};
struct rt_mutex_waiter;
struct rlimit {
   __kernel_ulong_t rlim_cur ;
   __kernel_ulong_t rlim_max ;
};
struct timerqueue_node {
   struct rb_node node ;
   ktime_t expires ;
};
struct timerqueue_head {
   struct rb_root head ;
   struct timerqueue_node *next ;
};
struct hrtimer_clock_base;
struct hrtimer_cpu_base;
enum hrtimer_restart {
    HRTIMER_NORESTART = 0,
    HRTIMER_RESTART = 1
} ;
struct hrtimer {
   struct timerqueue_node node ;
   ktime_t _softexpires ;
   enum hrtimer_restart (*function)(struct hrtimer * ) ;
   struct hrtimer_clock_base *base ;
   unsigned long state ;
    klee_make_symbolic(&state, sizeof(long), "state");
   int start_pid ;
   void *start_site ;
   char start_comm[16U] ;
};
struct hrtimer_clock_base {
   struct hrtimer_cpu_base *cpu_base ;
   int index ;
   clockid_t clockid ;
   struct timerqueue_head active ;
   ktime_t (*get_time)(void) ;
   ktime_t offset ;
};
struct hrtimer_cpu_base {
   raw_spinlock_t lock ;
   seqcount_t seq ;
   struct hrtimer *running ;
   unsigned int cpu ;
   unsigned int active_bases ;
    klee_make_symbolic(&active_bases, sizeof(int), "active_bases");
   unsigned int clock_was_set_seq ;
    klee_make_symbolic(&clock_was_set_seq, sizeof(int), "clock_was_set_seq");
   bool migration_enabled ;
   bool nohz_active ;
   unsigned char in_hrtirq : 1 ;
   unsigned char hres_active : 1 ;
   unsigned char hang_detected : 1 ;
   ktime_t expires_next ;
   struct hrtimer *next_timer ;
   unsigned int nr_events ;
    klee_make_symbolic(&nr_events, sizeof(int), "nr_events");
   unsigned int nr_retries ;
    klee_make_symbolic(&nr_retries, sizeof(int), "nr_retries");
   unsigned int nr_hangs ;
    klee_make_symbolic(&nr_hangs, sizeof(int), "nr_hangs");
   unsigned int max_hang_time ;
    klee_make_symbolic(&max_hang_time, sizeof(int), "max_hang_time");
   struct hrtimer_clock_base clock_base[4U] ;
};
struct task_io_accounting {
   u64 rchar ;
   u64 wchar ;
   u64 syscr ;
   u64 syscw ;
   u64 read_bytes ;
   u64 write_bytes ;
   u64 cancelled_write_bytes ;
};
struct latency_record {
   unsigned long backtrace[12U] ;
   unsigned int count ;
   unsigned long time ;
    klee_make_symbolic(&time, sizeof(long), "time");
   unsigned long max ;
    klee_make_symbolic(&max, sizeof(long), "max");
};
struct assoc_array_ptr;
struct assoc_array {
   struct assoc_array_ptr *root ;
   unsigned long nr_leaves_on_tree ;
    klee_make_symbolic(&nr_leaves_on_tree, sizeof(long), "nr_leaves_on_tree");
};
typedef int32_t key_serial_t;
typedef uint32_t key_perm_t;
struct key;
struct signal_struct;
struct cred;
struct key_type;
struct keyring_index_key {
   struct key_type *type ;
   char const   *description ;
   size_t desc_len ;
};
union __anonunion____missing_field_name_179 {
   struct list_head graveyard_link ;
   struct rb_node serial_node ;
};
struct key_user;
union __anonunion____missing_field_name_180 {
   time_t expiry ;
   time_t revoked_at ;
};
struct __anonstruct____missing_field_name_182 {
   struct key_type *type ;
   char *description ;
};
union __anonunion____missing_field_name_181 {
   struct keyring_index_key index_key ;
   struct __anonstruct____missing_field_name_182 __annonCompField49 ;
};
union __anonunion_type_data_183 {
   struct list_head link ;
   unsigned long x[2U] ;
   void *p[2U] ;
   int reject_error ;
    klee_make_symbolic(&reject_error, sizeof(int), "reject_error");
};
union __anonunion_payload_185 {
   unsigned long value ;
   void *rcudata ;
   void *data ;
   void *data2[2U] ;
};
union __anonunion____missing_field_name_184 {
   union __anonunion_payload_185 payload ;
   struct assoc_array keys ;
};
struct key {
   atomic_t usage ;
   key_serial_t serial ;
   union __anonunion____missing_field_name_179 __annonCompField47 ;
   struct rw_semaphore sem ;
   struct key_user *user ;
   void *security ;
   union __anonunion____missing_field_name_180 __annonCompField48 ;
   time_t last_used_at ;
   kuid_t uid ;
   kgid_t gid ;
   key_perm_t perm ;
   unsigned short quotalen ;
    klee_make_symbolic(&quotalen, sizeof(short), "quotalen");
   unsigned short datalen ;
    klee_make_symbolic(&datalen, sizeof(short), "datalen");
   unsigned long flags ;
   union __anonunion____missing_field_name_181 __annonCompField50 ;
   union __anonunion_type_data_183 type_data ;
   union __anonunion____missing_field_name_184 __annonCompField51 ;
};
struct audit_context;
struct group_info {
   atomic_t usage ;
   int ngroups ;
    klee_make_symbolic(&ngroups, sizeof(int), "ngroups");
   int nblocks ;
    klee_make_symbolic(&nblocks, sizeof(int), "nblocks");
   kgid_t small_block[32U] ;
   kgid_t *blocks[0U] ;
};
struct cred {
   atomic_t usage ;
   atomic_t subscribers ;
   void *put_addr ;
   unsigned int magic ;
   kuid_t uid ;
   kgid_t gid ;
   kuid_t suid ;
   kgid_t sgid ;
   kuid_t euid ;
   kgid_t egid ;
   kuid_t fsuid ;
   kgid_t fsgid ;
   unsigned int securebits ;
    klee_make_symbolic(&securebits, sizeof(int), "securebits");
   kernel_cap_t cap_inheritable ;
   kernel_cap_t cap_permitted ;
   kernel_cap_t cap_effective ;
   kernel_cap_t cap_bset ;
   unsigned char jit_keyring ;
    klee_make_symbolic(&jit_keyring, sizeof(char), "jit_keyring");
   struct key *session_keyring ;
   struct key *process_keyring ;
   struct key *thread_keyring ;
   struct key *request_key_auth ;
   void *security ;
   struct user_struct *user ;
   struct user_namespace *user_ns ;
   struct group_info *group_info ;
   struct callback_head rcu ;
};
union __anonunion____missing_field_name_186 {
   unsigned long bitmap[4U] ;
   struct callback_head callback_head ;
};
struct idr_layer {
   int prefix ;
    klee_make_symbolic(&prefix, sizeof(int), "prefix");
   int layer ;
    klee_make_symbolic(&layer, sizeof(int), "layer");
   struct idr_layer *ary[256U] ;
   int count ;
   union __anonunion____missing_field_name_186 __annonCompField52 ;
};
struct idr {
   struct idr_layer *hint ;
   struct idr_layer *top ;
   int layers ;
    klee_make_symbolic(&layers, sizeof(int), "layers");
   int cur ;
    klee_make_symbolic(&cur, sizeof(int), "cur");
   spinlock_t lock ;
   int id_free_cnt ;
    klee_make_symbolic(&id_free_cnt, sizeof(int), "id_free_cnt");
   struct idr_layer *id_free ;
};
struct ida_bitmap {
   long nr_busy ;
    klee_make_symbolic(&nr_busy, sizeof(long), "nr_busy");
   unsigned long bitmap[15U] ;
};
struct ida {
   struct idr idr ;
   struct ida_bitmap *free_bitmap ;
};
struct percpu_ref;
typedef void percpu_ref_func_t(struct percpu_ref * );
struct percpu_ref {
   atomic_long_t count ;
   unsigned long percpu_count_ptr ;
    klee_make_symbolic(&percpu_count_ptr, sizeof(long), "percpu_count_ptr");
   percpu_ref_func_t *release ;
   percpu_ref_func_t *confirm_switch ;
   bool force_atomic ;
   struct callback_head rcu ;
};
struct cgroup;
struct cgroup_root;
struct cgroup_subsys;
struct cgroup_taskset;
struct kernfs_node;
struct kernfs_ops;
struct kernfs_open_file;
struct cgroup_subsys_state {
   struct cgroup *cgroup ;
   struct cgroup_subsys *ss ;
   struct percpu_ref refcnt ;
   struct cgroup_subsys_state *parent ;
   struct list_head sibling ;
   struct list_head children ;
   int id ;
    klee_make_symbolic(&id, sizeof(int), "id");
   unsigned int flags ;
   u64 serial_nr ;
   struct callback_head callback_head ;
   struct work_struct destroy_work ;
};
struct css_set {
   atomic_t refcount ;
   struct hlist_node hlist ;
   struct list_head tasks ;
   struct list_head mg_tasks ;
   struct list_head cgrp_links ;
   struct cgroup *dfl_cgrp ;
   struct cgroup_subsys_state *subsys[12U] ;
   struct list_head mg_preload_node ;
   struct list_head mg_node ;
   struct cgroup *mg_src_cgrp ;
   struct css_set *mg_dst_cset ;
   struct list_head e_cset_node[12U] ;
   struct callback_head callback_head ;
};
struct cgroup {
   struct cgroup_subsys_state self ;
   unsigned long flags ;
   int id ;
   int populated_cnt ;
    klee_make_symbolic(&populated_cnt, sizeof(int), "populated_cnt");
   struct kernfs_node *kn ;
   struct kernfs_node *procs_kn ;
   struct kernfs_node *populated_kn ;
   unsigned int subtree_control ;
    klee_make_symbolic(&subtree_control, sizeof(int), "subtree_control");
   unsigned int child_subsys_mask ;
    klee_make_symbolic(&child_subsys_mask, sizeof(int), "child_subsys_mask");
   struct cgroup_subsys_state *subsys[12U] ;
   struct cgroup_root *root ;
   struct list_head cset_links ;
   struct list_head e_csets[12U] ;
   struct list_head pidlists ;
   struct mutex pidlist_mutex ;
   wait_queue_head_t offline_waitq ;
   struct work_struct release_agent_work ;
};
struct kernfs_root;
struct cgroup_root {
   struct kernfs_root *kf_root ;
   unsigned int subsys_mask ;
    klee_make_symbolic(&subsys_mask, sizeof(int), "subsys_mask");
   int hierarchy_id ;
    klee_make_symbolic(&hierarchy_id, sizeof(int), "hierarchy_id");
   struct cgroup cgrp ;
   atomic_t nr_cgrps ;
   struct list_head root_list ;
   unsigned int flags ;
   struct idr cgroup_idr ;
   char release_agent_path[4096U] ;
   char name[64U] ;
};
struct cftype {
   char name[64U] ;
   int private ;
   umode_t mode ;
   size_t max_write_len ;
   unsigned int flags ;
   struct cgroup_subsys *ss ;
   struct list_head node ;
   struct kernfs_ops *kf_ops ;
   u64 (*read_u64)(struct cgroup_subsys_state * , struct cftype * ) ;
   s64 (*read_s64)(struct cgroup_subsys_state * , struct cftype * ) ;
   int (*seq_show)(struct seq_file * , void * ) ;
   void *(*seq_start)(struct seq_file * , loff_t * ) ;
   void *(*seq_next)(struct seq_file * , void * , loff_t * ) ;
   void (*seq_stop)(struct seq_file * , void * ) ;
   int (*write_u64)(struct cgroup_subsys_state * , struct cftype * , u64  ) ;
   int (*write_s64)(struct cgroup_subsys_state * , struct cftype * , s64  ) ;
   ssize_t (*write)(struct kernfs_open_file * , char * , size_t  , loff_t  ) ;
   struct lock_class_key lockdep_key ;
};
struct cgroup_subsys {
   struct cgroup_subsys_state *(*css_alloc)(struct cgroup_subsys_state * ) ;
   int (*css_online)(struct cgroup_subsys_state * ) ;
   void (*css_offline)(struct cgroup_subsys_state * ) ;
   void (*css_released)(struct cgroup_subsys_state * ) ;
   void (*css_free)(struct cgroup_subsys_state * ) ;
   void (*css_reset)(struct cgroup_subsys_state * ) ;
   void (*css_e_css_changed)(struct cgroup_subsys_state * ) ;
   int (*can_attach)(struct cgroup_subsys_state * , struct cgroup_taskset * ) ;
   void (*cancel_attach)(struct cgroup_subsys_state * , struct cgroup_taskset * ) ;
   void (*attach)(struct cgroup_subsys_state * , struct cgroup_taskset * ) ;
   void (*fork)(struct task_struct * ) ;
   void (*exit)(struct cgroup_subsys_state * , struct cgroup_subsys_state * , struct task_struct * ) ;
   void (*bind)(struct cgroup_subsys_state * ) ;
   int disabled ;
    klee_make_symbolic(&disabled, sizeof(int), "disabled");
   int early_init ;
    klee_make_symbolic(&early_init, sizeof(int), "early_init");
   bool broken_hierarchy ;
   bool warned_broken_hierarchy ;
   int id ;
   char const   *name ;
   struct cgroup_root *root ;
   struct idr css_idr ;
   struct list_head cfts ;
   struct cftype *dfl_cftypes ;
   struct cftype *legacy_cftypes ;
   unsigned int depends_on ;
    klee_make_symbolic(&depends_on, sizeof(int), "depends_on");
};
struct futex_pi_state;
struct robust_list_head;
struct bio_list;
struct fs_struct;
struct perf_event_context;
struct blk_plug;
struct nameidata;
struct cfs_rq;
struct task_group;
struct sighand_struct {
   atomic_t count ;
   struct k_sigaction action[64U] ;
   spinlock_t siglock ;
   wait_queue_head_t signalfd_wqh ;
};
struct pacct_struct {
   int ac_flag ;
    klee_make_symbolic(&ac_flag, sizeof(int), "ac_flag");
   long ac_exitcode ;
    klee_make_symbolic(&ac_exitcode, sizeof(long), "ac_exitcode");
   unsigned long ac_mem ;
    klee_make_symbolic(&ac_mem, sizeof(long), "ac_mem");
   cputime_t ac_utime ;
   cputime_t ac_stime ;
   unsigned long ac_minflt ;
    klee_make_symbolic(&ac_minflt, sizeof(long), "ac_minflt");
   unsigned long ac_majflt ;
    klee_make_symbolic(&ac_majflt, sizeof(long), "ac_majflt");
};
struct cpu_itimer {
   cputime_t expires ;
   cputime_t incr ;
   u32 error ;
   u32 incr_error ;
};
struct cputime {
   cputime_t utime ;
   cputime_t stime ;
};
struct task_cputime {
   cputime_t utime ;
   cputime_t stime ;
   unsigned long long sum_exec_runtime ;
    klee_make_symbolic(&sum_exec_runtime, sizeof(long), "sum_exec_runtime");
};
struct task_cputime_atomic {
   atomic64_t utime ;
   atomic64_t stime ;
   atomic64_t sum_exec_runtime ;
};
struct thread_group_cputimer {
   struct task_cputime_atomic cputime_atomic ;
   int running ;
    klee_make_symbolic(&running, sizeof(int), "running");
};
struct autogroup;
struct tty_struct;
struct taskstats;
struct tty_audit_buf;
struct signal_struct {
   atomic_t sigcnt ;
   atomic_t live ;
   int nr_threads ;
    klee_make_symbolic(&nr_threads, sizeof(int), "nr_threads");
   struct list_head thread_head ;
   wait_queue_head_t wait_chldexit ;
   struct task_struct *curr_target ;
   struct sigpending shared_pending ;
   int group_exit_code ;
    klee_make_symbolic(&group_exit_code, sizeof(int), "group_exit_code");
   int notify_count ;
    klee_make_symbolic(&notify_count, sizeof(int), "notify_count");
   struct task_struct *group_exit_task ;
   int group_stop_count ;
    klee_make_symbolic(&group_stop_count, sizeof(int), "group_stop_count");
   unsigned int flags ;
   unsigned char is_child_subreaper : 1 ;
   unsigned char has_child_subreaper : 1 ;
   int posix_timer_id ;
    klee_make_symbolic(&posix_timer_id, sizeof(int), "posix_timer_id");
   struct list_head posix_timers ;
   struct hrtimer real_timer ;
   struct pid *leader_pid ;
   ktime_t it_real_incr ;
   struct cpu_itimer it[2U] ;
   struct thread_group_cputimer cputimer ;
   struct task_cputime cputime_expires ;
   struct list_head cpu_timers[3U] ;
   struct pid *tty_old_pgrp ;
   int leader ;
    klee_make_symbolic(&leader, sizeof(int), "leader");
   struct tty_struct *tty ;
   struct autogroup *autogroup ;
   seqlock_t stats_lock ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t cutime ;
   cputime_t cstime ;
   cputime_t gtime ;
   cputime_t cgtime ;
   struct cputime prev_cputime ;
   unsigned long nvcsw ;
    klee_make_symbolic(&nvcsw, sizeof(long), "nvcsw");
   unsigned long nivcsw ;
    klee_make_symbolic(&nivcsw, sizeof(long), "nivcsw");
   unsigned long cnvcsw ;
    klee_make_symbolic(&cnvcsw, sizeof(long), "cnvcsw");
   unsigned long cnivcsw ;
    klee_make_symbolic(&cnivcsw, sizeof(long), "cnivcsw");
   unsigned long min_flt ;
    klee_make_symbolic(&min_flt, sizeof(long), "min_flt");
   unsigned long maj_flt ;
    klee_make_symbolic(&maj_flt, sizeof(long), "maj_flt");
   unsigned long cmin_flt ;
    klee_make_symbolic(&cmin_flt, sizeof(long), "cmin_flt");
   unsigned long cmaj_flt ;
    klee_make_symbolic(&cmaj_flt, sizeof(long), "cmaj_flt");
   unsigned long inblock ;
    klee_make_symbolic(&inblock, sizeof(long), "inblock");
   unsigned long oublock ;
    klee_make_symbolic(&oublock, sizeof(long), "oublock");
   unsigned long cinblock ;
    klee_make_symbolic(&cinblock, sizeof(long), "cinblock");
   unsigned long coublock ;
    klee_make_symbolic(&coublock, sizeof(long), "coublock");
   unsigned long maxrss ;
    klee_make_symbolic(&maxrss, sizeof(long), "maxrss");
   unsigned long cmaxrss ;
    klee_make_symbolic(&cmaxrss, sizeof(long), "cmaxrss");
   struct task_io_accounting ioac ;
   unsigned long long sum_sched_runtime ;
    klee_make_symbolic(&sum_sched_runtime, sizeof(long), "sum_sched_runtime");
   struct rlimit rlim[16U] ;
   struct pacct_struct pacct ;
   struct taskstats *stats ;
   unsigned int audit_tty ;
    klee_make_symbolic(&audit_tty, sizeof(int), "audit_tty");
   unsigned int audit_tty_log_passwd ;
    klee_make_symbolic(&audit_tty_log_passwd, sizeof(int), "audit_tty_log_passwd");
   struct tty_audit_buf *tty_audit_buf ;
   oom_flags_t oom_flags ;
   short oom_score_adj ;
    klee_make_symbolic(&oom_score_adj, sizeof(short), "oom_score_adj");
   short oom_score_adj_min ;
    klee_make_symbolic(&oom_score_adj_min, sizeof(short), "oom_score_adj_min");
   struct mutex cred_guard_mutex ;
};
struct user_struct {
   atomic_t __count ;
   atomic_t processes ;
   atomic_t sigpending ;
   atomic_t inotify_watches ;
   atomic_t inotify_devs ;
   atomic_t fanotify_listeners ;
   atomic_long_t epoll_watches ;
   unsigned long mq_bytes ;
    klee_make_symbolic(&mq_bytes, sizeof(long), "mq_bytes");
   unsigned long locked_shm ;
    klee_make_symbolic(&locked_shm, sizeof(long), "locked_shm");
   struct key *uid_keyring ;
   struct key *session_keyring ;
   struct hlist_node uidhash_node ;
   kuid_t uid ;
   atomic_long_t locked_vm ;
};
struct backing_dev_info;
struct reclaim_state;
struct sched_info {
   unsigned long pcount ;
    klee_make_symbolic(&pcount, sizeof(long), "pcount");
   unsigned long long run_delay ;
    klee_make_symbolic(&run_delay, sizeof(long), "run_delay");
   unsigned long long last_arrival ;
    klee_make_symbolic(&last_arrival, sizeof(long), "last_arrival");
   unsigned long long last_queued ;
    klee_make_symbolic(&last_queued, sizeof(long), "last_queued");
};
struct task_delay_info {
   spinlock_t lock ;
   unsigned int flags ;
   u64 blkio_start ;
   u64 blkio_delay ;
   u64 swapin_delay ;
   u32 blkio_count ;
   u32 swapin_count ;
   u64 freepages_start ;
   u64 freepages_delay ;
   u32 freepages_count ;
};
struct wake_q_node {
   struct wake_q_node *next ;
};
struct io_context;
struct pipe_inode_info;
struct uts_namespace;
struct load_weight {
   unsigned long weight ;
    klee_make_symbolic(&weight, sizeof(long), "weight");
   u32 inv_weight ;
};
struct sched_avg {
   u64 last_runnable_update ;
   s64 decay_count ;
   unsigned long load_avg_contrib ;
    klee_make_symbolic(&load_avg_contrib, sizeof(long), "load_avg_contrib");
   unsigned long utilization_avg_contrib ;
    klee_make_symbolic(&utilization_avg_contrib, sizeof(long), "utilization_avg_contrib");
   u32 runnable_avg_sum ;
   u32 avg_period ;
   u32 running_avg_sum ;
};
struct sched_statistics {
   u64 wait_start ;
   u64 wait_max ;
   u64 wait_count ;
   u64 wait_sum ;
   u64 iowait_count ;
   u64 iowait_sum ;
   u64 sleep_start ;
   u64 sleep_max ;
   s64 sum_sleep_runtime ;
   u64 block_start ;
   u64 block_max ;
   u64 exec_max ;
   u64 slice_max ;
   u64 nr_migrations_cold ;
   u64 nr_failed_migrations_affine ;
   u64 nr_failed_migrations_running ;
   u64 nr_failed_migrations_hot ;
   u64 nr_forced_migrations ;
   u64 nr_wakeups ;
   u64 nr_wakeups_sync ;
   u64 nr_wakeups_migrate ;
   u64 nr_wakeups_local ;
   u64 nr_wakeups_remote ;
   u64 nr_wakeups_affine ;
   u64 nr_wakeups_affine_attempts ;
   u64 nr_wakeups_passive ;
   u64 nr_wakeups_idle ;
};
struct sched_entity {
   struct load_weight load ;
   struct rb_node run_node ;
   struct list_head group_node ;
   unsigned int on_rq ;
    klee_make_symbolic(&on_rq, sizeof(int), "on_rq");
   u64 exec_start ;
   u64 sum_exec_runtime ;
   u64 vruntime ;
   u64 prev_sum_exec_runtime ;
   u64 nr_migrations ;
   struct sched_statistics statistics ;
   int depth ;
   struct sched_entity *parent ;
   struct cfs_rq *cfs_rq ;
   struct cfs_rq *my_q ;
   struct sched_avg avg ;
};
struct rt_rq;
struct sched_rt_entity {
   struct list_head run_list ;
   unsigned long timeout ;
    klee_make_symbolic(&timeout, sizeof(long), "timeout");
   unsigned long watchdog_stamp ;
    klee_make_symbolic(&watchdog_stamp, sizeof(long), "watchdog_stamp");
   unsigned int time_slice ;
    klee_make_symbolic(&time_slice, sizeof(int), "time_slice");
   struct sched_rt_entity *back ;
   struct sched_rt_entity *parent ;
   struct rt_rq *rt_rq ;
   struct rt_rq *my_q ;
};
struct sched_dl_entity {
   struct rb_node rb_node ;
   u64 dl_runtime ;
   u64 dl_deadline ;
   u64 dl_period ;
   u64 dl_bw ;
   s64 runtime ;
   u64 deadline ;
   unsigned int flags ;
   int dl_throttled ;
    klee_make_symbolic(&dl_throttled, sizeof(int), "dl_throttled");
   int dl_new ;
    klee_make_symbolic(&dl_new, sizeof(int), "dl_new");
   int dl_boosted ;
    klee_make_symbolic(&dl_boosted, sizeof(int), "dl_boosted");
   int dl_yielded ;
    klee_make_symbolic(&dl_yielded, sizeof(int), "dl_yielded");
   struct hrtimer dl_timer ;
};
struct memcg_oom_info {
   struct mem_cgroup *memcg ;
   gfp_t gfp_mask ;
   int order ;
    klee_make_symbolic(&order, sizeof(int), "order");
   unsigned char may_oom : 1 ;
};
struct sched_class;
struct files_struct;
struct compat_robust_list_head;
struct numa_group;
struct task_struct {
   long volatile   state ;
   void *stack ;
   atomic_t usage ;
   unsigned int flags ;
   unsigned int ptrace ;
    klee_make_symbolic(&ptrace, sizeof(int), "ptrace");
   struct llist_node wake_entry ;
   int on_cpu ;
    klee_make_symbolic(&on_cpu, sizeof(int), "on_cpu");
   struct task_struct *last_wakee ;
   unsigned long wakee_flips ;
    klee_make_symbolic(&wakee_flips, sizeof(long), "wakee_flips");
   unsigned long wakee_flip_decay_ts ;
    klee_make_symbolic(&wakee_flip_decay_ts, sizeof(long), "wakee_flip_decay_ts");
   int wake_cpu ;
    klee_make_symbolic(&wake_cpu, sizeof(int), "wake_cpu");
   int on_rq ;
   int prio ;
   int static_prio ;
    klee_make_symbolic(&static_prio, sizeof(int), "static_prio");
   int normal_prio ;
    klee_make_symbolic(&normal_prio, sizeof(int), "normal_prio");
   unsigned int rt_priority ;
    klee_make_symbolic(&rt_priority, sizeof(int), "rt_priority");
   struct sched_class  const  *sched_class ;
   struct sched_entity se ;
   struct sched_rt_entity rt ;
   struct task_group *sched_task_group ;
   struct sched_dl_entity dl ;
   struct hlist_head preempt_notifiers ;
   unsigned int policy ;
    klee_make_symbolic(&policy, sizeof(int), "policy");
   int nr_cpus_allowed ;
    klee_make_symbolic(&nr_cpus_allowed, sizeof(int), "nr_cpus_allowed");
   cpumask_t cpus_allowed ;
   unsigned long rcu_tasks_nvcsw ;
    klee_make_symbolic(&rcu_tasks_nvcsw, sizeof(long), "rcu_tasks_nvcsw");
   bool rcu_tasks_holdout ;
   struct list_head rcu_tasks_holdout_list ;
   int rcu_tasks_idle_cpu ;
    klee_make_symbolic(&rcu_tasks_idle_cpu, sizeof(int), "rcu_tasks_idle_cpu");
   struct sched_info sched_info ;
   struct list_head tasks ;
   struct plist_node pushable_tasks ;
   struct rb_node pushable_dl_tasks ;
   struct mm_struct *mm ;
   struct mm_struct *active_mm ;
   u32 vmacache_seqnum ;
   struct vm_area_struct *vmacache[4U] ;
   struct task_rss_stat rss_stat ;
   int exit_state ;
    klee_make_symbolic(&exit_state, sizeof(int), "exit_state");
   int exit_code ;
    klee_make_symbolic(&exit_code, sizeof(int), "exit_code");
   int exit_signal ;
    klee_make_symbolic(&exit_signal, sizeof(int), "exit_signal");
   int pdeath_signal ;
    klee_make_symbolic(&pdeath_signal, sizeof(int), "pdeath_signal");
   unsigned long jobctl ;
    klee_make_symbolic(&jobctl, sizeof(long), "jobctl");
   unsigned int personality ;
    klee_make_symbolic(&personality, sizeof(int), "personality");
   unsigned char in_execve : 1 ;
   unsigned char in_iowait : 1 ;
   unsigned char sched_reset_on_fork : 1 ;
   unsigned char sched_contributes_to_load : 1 ;
   unsigned char sched_migrated : 1 ;
   unsigned char memcg_kmem_skip_account : 1 ;
   unsigned char brk_randomized : 1 ;
   unsigned long atomic_flags ;
    klee_make_symbolic(&atomic_flags, sizeof(long), "atomic_flags");
   struct restart_block restart_block ;
   pid_t pid ;
   pid_t tgid ;
   struct task_struct *real_parent ;
   struct task_struct *parent ;
   struct list_head children ;
   struct list_head sibling ;
   struct task_struct *group_leader ;
   struct list_head ptraced ;
   struct list_head ptrace_entry ;
   struct pid_link pids[3U] ;
   struct list_head thread_group ;
   struct list_head thread_node ;
   struct completion *vfork_done ;
   int *set_child_tid ;
   int *clear_child_tid ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t utimescaled ;
   cputime_t stimescaled ;
   cputime_t gtime ;
   struct cputime prev_cputime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   u64 start_time ;
   u64 real_start_time ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   struct task_cputime cputime_expires ;
   struct list_head cpu_timers[3U] ;
   struct cred  const  *real_cred ;
   struct cred  const  *cred ;
   char comm[16U] ;
   struct nameidata *nameidata ;
   struct sysv_sem sysvsem ;
   struct sysv_shm sysvshm ;
   unsigned long last_switch_count ;
    klee_make_symbolic(&last_switch_count, sizeof(long), "last_switch_count");
   struct thread_struct thread ;
   struct fs_struct *fs ;
   struct files_struct *files ;
   struct nsproxy *nsproxy ;
   struct signal_struct *signal ;
   struct sighand_struct *sighand ;
   sigset_t blocked ;
   sigset_t real_blocked ;
   sigset_t saved_sigmask ;
   struct sigpending pending ;
   unsigned long sas_ss_sp ;
    klee_make_symbolic(&sas_ss_sp, sizeof(long), "sas_ss_sp");
   size_t sas_ss_size ;
   int (*notifier)(void * ) ;
   void *notifier_data ;
   sigset_t *notifier_mask ;
   struct callback_head *task_works ;
   struct audit_context *audit_context ;
   kuid_t loginuid ;
   unsigned int sessionid ;
    klee_make_symbolic(&sessionid, sizeof(int), "sessionid");
   struct seccomp seccomp ;
   u32 parent_exec_id ;
   u32 self_exec_id ;
   spinlock_t alloc_lock ;
   raw_spinlock_t pi_lock ;
   struct wake_q_node wake_q ;
   struct rb_root pi_waiters ;
   struct rb_node *pi_waiters_leftmost ;
   struct rt_mutex_waiter *pi_blocked_on ;
   struct mutex_waiter *blocked_on ;
   unsigned int irq_events ;
    klee_make_symbolic(&irq_events, sizeof(int), "irq_events");
   unsigned long hardirq_enable_ip ;
    klee_make_symbolic(&hardirq_enable_ip, sizeof(long), "hardirq_enable_ip");
   unsigned long hardirq_disable_ip ;
    klee_make_symbolic(&hardirq_disable_ip, sizeof(long), "hardirq_disable_ip");
   unsigned int hardirq_enable_event ;
    klee_make_symbolic(&hardirq_enable_event, sizeof(int), "hardirq_enable_event");
   unsigned int hardirq_disable_event ;
    klee_make_symbolic(&hardirq_disable_event, sizeof(int), "hardirq_disable_event");
   int hardirqs_enabled ;
    klee_make_symbolic(&hardirqs_enabled, sizeof(int), "hardirqs_enabled");
   int hardirq_context ;
    klee_make_symbolic(&hardirq_context, sizeof(int), "hardirq_context");
   unsigned long softirq_disable_ip ;
    klee_make_symbolic(&softirq_disable_ip, sizeof(long), "softirq_disable_ip");
   unsigned long softirq_enable_ip ;
    klee_make_symbolic(&softirq_enable_ip, sizeof(long), "softirq_enable_ip");
   unsigned int softirq_disable_event ;
    klee_make_symbolic(&softirq_disable_event, sizeof(int), "softirq_disable_event");
   unsigned int softirq_enable_event ;
    klee_make_symbolic(&softirq_enable_event, sizeof(int), "softirq_enable_event");
   int softirqs_enabled ;
    klee_make_symbolic(&softirqs_enabled, sizeof(int), "softirqs_enabled");
   int softirq_context ;
    klee_make_symbolic(&softirq_context, sizeof(int), "softirq_context");
   u64 curr_chain_key ;
   int lockdep_depth ;
    klee_make_symbolic(&lockdep_depth, sizeof(int), "lockdep_depth");
   unsigned int lockdep_recursion ;
    klee_make_symbolic(&lockdep_recursion, sizeof(int), "lockdep_recursion");
   struct held_lock held_locks[48U] ;
   gfp_t lockdep_reclaim_gfp ;
   void *journal_info ;
   struct bio_list *bio_list ;
   struct blk_plug *plug ;
   struct reclaim_state *reclaim_state ;
   struct backing_dev_info *backing_dev_info ;
   struct io_context *io_context ;
   unsigned long ptrace_message ;
    klee_make_symbolic(&ptrace_message, sizeof(long), "ptrace_message");
   siginfo_t *last_siginfo ;
   struct task_io_accounting ioac ;
   u64 acct_rss_mem1 ;
   u64 acct_vm_mem1 ;
   cputime_t acct_timexpd ;
   nodemask_t mems_allowed ;
   seqcount_t mems_allowed_seq ;
   int cpuset_mem_spread_rotor ;
    klee_make_symbolic(&cpuset_mem_spread_rotor, sizeof(int), "cpuset_mem_spread_rotor");
   int cpuset_slab_spread_rotor ;
    klee_make_symbolic(&cpuset_slab_spread_rotor, sizeof(int), "cpuset_slab_spread_rotor");
   struct css_set *cgroups ;
   struct list_head cg_list ;
   struct robust_list_head *robust_list ;
   struct compat_robust_list_head *compat_robust_list ;
   struct list_head pi_state_list ;
   struct futex_pi_state *pi_state_cache ;
   struct perf_event_context *perf_event_ctxp[2U] ;
   struct mutex perf_event_mutex ;
   struct list_head perf_event_list ;
   struct mempolicy *mempolicy ;
   short il_next ;
    klee_make_symbolic(&il_next, sizeof(short), "il_next");
   short pref_node_fork ;
    klee_make_symbolic(&pref_node_fork, sizeof(short), "pref_node_fork");
   int numa_scan_seq ;
   unsigned int numa_scan_period ;
    klee_make_symbolic(&numa_scan_period, sizeof(int), "numa_scan_period");
   unsigned int numa_scan_period_max ;
    klee_make_symbolic(&numa_scan_period_max, sizeof(int), "numa_scan_period_max");
   int numa_preferred_nid ;
    klee_make_symbolic(&numa_preferred_nid, sizeof(int), "numa_preferred_nid");
   unsigned long numa_migrate_retry ;
    klee_make_symbolic(&numa_migrate_retry, sizeof(long), "numa_migrate_retry");
   u64 node_stamp ;
   u64 last_task_numa_placement ;
   u64 last_sum_exec_runtime ;
   struct callback_head numa_work ;
   struct list_head numa_entry ;
   struct numa_group *numa_group ;
   unsigned long *numa_faults ;
   unsigned long total_numa_faults ;
    klee_make_symbolic(&total_numa_faults, sizeof(long), "total_numa_faults");
   unsigned long numa_faults_locality[3U] ;
   unsigned long numa_pages_migrated ;
    klee_make_symbolic(&numa_pages_migrated, sizeof(long), "numa_pages_migrated");
   struct callback_head rcu ;
   struct pipe_inode_info *splice_pipe ;
   struct page_frag task_frag ;
   struct task_delay_info *delays ;
   int make_it_fail ;
    klee_make_symbolic(&make_it_fail, sizeof(int), "make_it_fail");
   int nr_dirtied ;
    klee_make_symbolic(&nr_dirtied, sizeof(int), "nr_dirtied");
   int nr_dirtied_pause ;
    klee_make_symbolic(&nr_dirtied_pause, sizeof(int), "nr_dirtied_pause");
   unsigned long dirty_paused_when ;
    klee_make_symbolic(&dirty_paused_when, sizeof(long), "dirty_paused_when");
   int latency_record_count ;
    klee_make_symbolic(&latency_record_count, sizeof(int), "latency_record_count");
   struct latency_record latency_record[32U] ;
   unsigned long timer_slack_ns ;
    klee_make_symbolic(&timer_slack_ns, sizeof(long), "timer_slack_ns");
   unsigned long default_timer_slack_ns ;
    klee_make_symbolic(&default_timer_slack_ns, sizeof(long), "default_timer_slack_ns");
   unsigned int kasan_depth ;
    klee_make_symbolic(&kasan_depth, sizeof(int), "kasan_depth");
   unsigned long trace ;
    klee_make_symbolic(&trace, sizeof(long), "trace");
   unsigned long trace_recursion ;
    klee_make_symbolic(&trace_recursion, sizeof(long), "trace_recursion");
   struct memcg_oom_info memcg_oom ;
   struct uprobe_task *utask ;
   unsigned int sequential_io ;
    klee_make_symbolic(&sequential_io, sizeof(int), "sequential_io");
   unsigned int sequential_io_avg ;
    klee_make_symbolic(&sequential_io_avg, sizeof(int), "sequential_io_avg");
   unsigned long task_state_change ;
    klee_make_symbolic(&task_state_change, sizeof(long), "task_state_change");
   int pagefault_disabled ;
    klee_make_symbolic(&pagefault_disabled, sizeof(int), "pagefault_disabled");
};
enum irqreturn {
    IRQ_NONE = 0,
    IRQ_HANDLED = 1,
    IRQ_WAKE_THREAD = 2
} ;
typedef enum irqreturn irqreturn_t;
struct bfa_s;
struct bfa_iocfc_cfg_s;
struct scsi_cmnd;
struct scsi_device;
struct scsi_target;
struct fc_bsg_job;
struct Scsi_Host;
struct fc_vport;
struct kstat {
   u64 ino ;
   dev_t dev ;
   umode_t mode ;
   unsigned int nlink ;
    klee_make_symbolic(&nlink, sizeof(int), "nlink");
   kuid_t uid ;
   kgid_t gid ;
   dev_t rdev ;
   loff_t size ;
   struct timespec atime ;
   struct timespec mtime ;
   struct timespec ctime ;
   unsigned long blksize ;
    klee_make_symbolic(&blksize, sizeof(long), "blksize");
   unsigned long long blocks ;
    klee_make_symbolic(&blocks, sizeof(long), "blocks");
};
typedef __u64 Elf64_Addr;
typedef __u16 Elf64_Half;
typedef __u32 Elf64_Word;
typedef __u64 Elf64_Xword;
struct elf64_sym {
   Elf64_Word st_name ;
   unsigned char st_info ;
    klee_make_symbolic(&st_info, sizeof(char), "st_info");
   unsigned char st_other ;
    klee_make_symbolic(&st_other, sizeof(char), "st_other");
   Elf64_Half st_shndx ;
   Elf64_Addr st_value ;
   Elf64_Xword st_size ;
};
typedef struct elf64_sym Elf64_Sym;
struct iattr;
struct super_block;
struct file_system_type;
struct kernfs_open_node;
struct kernfs_iattrs;
struct kernfs_elem_dir {
   unsigned long subdirs ;
    klee_make_symbolic(&subdirs, sizeof(long), "subdirs");
   struct rb_root children ;
   struct kernfs_root *root ;
};
struct kernfs_elem_symlink {
   struct kernfs_node *target_kn ;
};
struct kernfs_elem_attr {
   struct kernfs_ops  const  *ops ;
   struct kernfs_open_node *open ;
   loff_t size ;
   struct kernfs_node *notify_next ;
};
union __anonunion____missing_field_name_209 {
   struct kernfs_elem_dir dir ;
   struct kernfs_elem_symlink symlink ;
   struct kernfs_elem_attr attr ;
};
struct kernfs_node {
   atomic_t count ;
   atomic_t active ;
   struct lockdep_map dep_map ;
   struct kernfs_node *parent ;
   char const   *name ;
   struct rb_node rb ;
   void const   *ns ;
   unsigned int hash ;
    klee_make_symbolic(&hash, sizeof(int), "hash");
   union __anonunion____missing_field_name_209 __annonCompField56 ;
   void *priv ;
   unsigned short flags ;
   umode_t mode ;
   unsigned int ino ;
    klee_make_symbolic(&ino, sizeof(int), "ino");
   struct kernfs_iattrs *iattr ;
};
struct kernfs_syscall_ops {
   int (*remount_fs)(struct kernfs_root * , int * , char * ) ;
   int (*show_options)(struct seq_file * , struct kernfs_root * ) ;
   int (*mkdir)(struct kernfs_node * , char const   * , umode_t  ) ;
   int (*rmdir)(struct kernfs_node * ) ;
   int (*rename)(struct kernfs_node * , struct kernfs_node * , char const   * ) ;
};
struct kernfs_root {
   struct kernfs_node *kn ;
   unsigned int flags ;
   struct ida ino_ida ;
   struct kernfs_syscall_ops *syscall_ops ;
   struct list_head supers ;
   wait_queue_head_t deactivate_waitq ;
};
struct kernfs_open_file {
   struct kernfs_node *kn ;
   struct file *file ;
   void *priv ;
   struct mutex mutex ;
   int event ;
   struct list_head list ;
   char *prealloc_buf ;
   size_t atomic_write_len ;
   bool mmapped ;
   struct vm_operations_struct  const  *vm_ops ;
};
struct kernfs_ops {
   int (*seq_show)(struct seq_file * , void * ) ;
   void *(*seq_start)(struct seq_file * , loff_t * ) ;
   void *(*seq_next)(struct seq_file * , void * , loff_t * ) ;
   void (*seq_stop)(struct seq_file * , void * ) ;
   ssize_t (*read)(struct kernfs_open_file * , char * , size_t  , loff_t  ) ;
   size_t atomic_write_len ;
   bool prealloc ;
   ssize_t (*write)(struct kernfs_open_file * , char * , size_t  , loff_t  ) ;
   int (*mmap)(struct kernfs_open_file * , struct vm_area_struct * ) ;
   struct lock_class_key lockdep_key ;
};
struct sock;
struct kobject;
enum kobj_ns_type {
    KOBJ_NS_TYPE_NONE = 0,
    KOBJ_NS_TYPE_NET = 1,
    KOBJ_NS_TYPES = 2
} ;
struct kobj_ns_type_operations {
   enum kobj_ns_type type ;
   bool (*current_may_mount)(void) ;
   void *(*grab_current_ns)(void) ;
   void const   *(*netlink_ns)(struct sock * ) ;
   void const   *(*initial_ns)(void) ;
   void (*drop_ns)(void * ) ;
};
struct bin_attribute;
struct attribute {
   char const   *name ;
   umode_t mode ;
   bool ignore_lockdep ;
   struct lock_class_key *key ;
   struct lock_class_key skey ;
};
struct attribute_group {
   char const   *name ;
   umode_t (*is_visible)(struct kobject * , struct attribute * , int  ) ;
   struct attribute **attrs ;
   struct bin_attribute **bin_attrs ;
};
struct bin_attribute {
   struct attribute attr ;
   size_t size ;
   void *private ;
   ssize_t (*read)(struct file * , struct kobject * , struct bin_attribute * , char * ,
                   loff_t  , size_t  ) ;
   ssize_t (*write)(struct file * , struct kobject * , struct bin_attribute * , char * ,
                    loff_t  , size_t  ) ;
   int (*mmap)(struct file * , struct kobject * , struct bin_attribute * , struct vm_area_struct * ) ;
};
struct sysfs_ops {
   ssize_t (*show)(struct kobject * , struct attribute * , char * ) ;
   ssize_t (*store)(struct kobject * , struct attribute * , char const   * , size_t  ) ;
};
struct kref {
   atomic_t refcount ;
};
struct kset;
struct kobj_type;
struct kobject {
   char const   *name ;
   struct list_head entry ;
   struct kobject *parent ;
   struct kset *kset ;
   struct kobj_type *ktype ;
   struct kernfs_node *sd ;
   struct kref kref ;
   struct delayed_work release ;
   unsigned char state_initialized : 1 ;
   unsigned char state_in_sysfs : 1 ;
   unsigned char state_add_uevent_sent : 1 ;
   unsigned char state_remove_uevent_sent : 1 ;
   unsigned char uevent_suppress : 1 ;
};
struct kobj_type {
   void (*release)(struct kobject * ) ;
   struct sysfs_ops  const  *sysfs_ops ;
   struct attribute **default_attrs ;
   struct kobj_ns_type_operations  const  *(*child_ns_type)(struct kobject * ) ;
   void const   *(*namespace)(struct kobject * ) ;
};
struct kobj_uevent_env {
   char *argv[3U] ;
   char *envp[32U] ;
   int envp_idx ;
    klee_make_symbolic(&envp_idx, sizeof(int), "envp_idx");
   char buf[2048U] ;
   int buflen ;
    klee_make_symbolic(&buflen, sizeof(int), "buflen");
};
struct kset_uevent_ops {
   int (* const  filter)(struct kset * , struct kobject * ) ;
   char const   *(* const  name)(struct kset * , struct kobject * ) ;
   int (* const  uevent)(struct kset * , struct kobject * , struct kobj_uevent_env * ) ;
};
struct kset {
   struct list_head list ;
   spinlock_t list_lock ;
   struct kobject kobj ;
   struct kset_uevent_ops  const  *uevent_ops ;
};
struct kernel_param;
struct kernel_param_ops {
   unsigned int flags ;
   int (*set)(char const   * , struct kernel_param  const  * ) ;
   int (*get)(char * , struct kernel_param  const  * ) ;
   void (*free)(void * ) ;
};
struct kparam_string;
struct kparam_array;
union __anonunion____missing_field_name_210 {
   void *arg ;
   struct kparam_string  const  *str ;
   struct kparam_array  const  *arr ;
};
struct kernel_param {
   char const   *name ;
   struct module *mod ;
   struct kernel_param_ops  const  *ops ;
   u16 const   perm ;
   s8 level ;
   u8 flags ;
   union __anonunion____missing_field_name_210 __annonCompField57 ;
};
struct kparam_string {
   unsigned int maxlen ;
    klee_make_symbolic(&maxlen, sizeof(int), "maxlen");
   char *string ;
};
struct kparam_array {
   unsigned int max ;
   unsigned int elemsize ;
    klee_make_symbolic(&elemsize, sizeof(int), "elemsize");
   unsigned int *num ;
   struct kernel_param_ops  const  *ops ;
   void *elem ;
};
struct latch_tree_node {
   struct rb_node node[2U] ;
};
struct mod_arch_specific {

};
struct module_param_attrs;
struct module_kobject {
   struct kobject kobj ;
   struct module *mod ;
   struct kobject *drivers_dir ;
   struct module_param_attrs *mp ;
   struct completion *kobj_completion ;
};
struct module_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct module_attribute * , struct module_kobject * , char * ) ;
   ssize_t (*store)(struct module_attribute * , struct module_kobject * , char const   * ,
                    size_t  ) ;
   void (*setup)(struct module * , char const   * ) ;
   int (*test)(struct module * ) ;
   void (*free)(struct module * ) ;
};
struct exception_table_entry;
enum module_state {
    MODULE_STATE_LIVE = 0,
    MODULE_STATE_COMING = 1,
    MODULE_STATE_GOING = 2,
    MODULE_STATE_UNFORMED = 3
} ;
struct mod_tree_node {
   struct module *mod ;
   struct latch_tree_node node ;
};
struct module_sect_attrs;
struct module_notes_attrs;
struct tracepoint;
struct trace_event_call;
struct trace_enum_map;
struct module {
   enum module_state state ;
   struct list_head list ;
   char name[56U] ;
   struct module_kobject mkobj ;
   struct module_attribute *modinfo_attrs ;
   char const   *version ;
   char const   *srcversion ;
   struct kobject *holders_dir ;
   struct kernel_symbol  const  *syms ;
   unsigned long const   *crcs ;
   unsigned int num_syms ;
    klee_make_symbolic(&num_syms, sizeof(int), "num_syms");
   struct mutex param_lock ;
   struct kernel_param *kp ;
   unsigned int num_kp ;
    klee_make_symbolic(&num_kp, sizeof(int), "num_kp");
   unsigned int num_gpl_syms ;
    klee_make_symbolic(&num_gpl_syms, sizeof(int), "num_gpl_syms");
   struct kernel_symbol  const  *gpl_syms ;
   unsigned long const   *gpl_crcs ;
   struct kernel_symbol  const  *unused_syms ;
   unsigned long const   *unused_crcs ;
   unsigned int num_unused_syms ;
    klee_make_symbolic(&num_unused_syms, sizeof(int), "num_unused_syms");
   unsigned int num_unused_gpl_syms ;
    klee_make_symbolic(&num_unused_gpl_syms, sizeof(int), "num_unused_gpl_syms");
   struct kernel_symbol  const  *unused_gpl_syms ;
   unsigned long const   *unused_gpl_crcs ;
   bool sig_ok ;
   bool async_probe_requested ;
   struct kernel_symbol  const  *gpl_future_syms ;
   unsigned long const   *gpl_future_crcs ;
   unsigned int num_gpl_future_syms ;
    klee_make_symbolic(&num_gpl_future_syms, sizeof(int), "num_gpl_future_syms");
   unsigned int num_exentries ;
    klee_make_symbolic(&num_exentries, sizeof(int), "num_exentries");
   struct exception_table_entry *extable ;
   int (*init)(void) ;
   void *module_init ;
   void *module_core ;
   unsigned int init_size ;
    klee_make_symbolic(&init_size, sizeof(int), "init_size");
   unsigned int core_size ;
    klee_make_symbolic(&core_size, sizeof(int), "core_size");
   unsigned int init_text_size ;
    klee_make_symbolic(&init_text_size, sizeof(int), "init_text_size");
   unsigned int core_text_size ;
    klee_make_symbolic(&core_text_size, sizeof(int), "core_text_size");
   struct mod_tree_node mtn_core ;
   struct mod_tree_node mtn_init ;
   unsigned int init_ro_size ;
    klee_make_symbolic(&init_ro_size, sizeof(int), "init_ro_size");
   unsigned int core_ro_size ;
    klee_make_symbolic(&core_ro_size, sizeof(int), "core_ro_size");
   struct mod_arch_specific arch ;
   unsigned int taints ;
    klee_make_symbolic(&taints, sizeof(int), "taints");
   unsigned int num_bugs ;
    klee_make_symbolic(&num_bugs, sizeof(int), "num_bugs");
   struct list_head bug_list ;
   struct bug_entry *bug_table ;
   Elf64_Sym *symtab ;
   Elf64_Sym *core_symtab ;
   unsigned int num_symtab ;
    klee_make_symbolic(&num_symtab, sizeof(int), "num_symtab");
   unsigned int core_num_syms ;
    klee_make_symbolic(&core_num_syms, sizeof(int), "core_num_syms");
   char *strtab ;
   char *core_strtab ;
   struct module_sect_attrs *sect_attrs ;
   struct module_notes_attrs *notes_attrs ;
   char *args ;
   void *percpu ;
   unsigned int percpu_size ;
    klee_make_symbolic(&percpu_size, sizeof(int), "percpu_size");
   unsigned int num_tracepoints ;
    klee_make_symbolic(&num_tracepoints, sizeof(int), "num_tracepoints");
   struct tracepoint * const  *tracepoints_ptrs ;
   unsigned int num_trace_bprintk_fmt ;
    klee_make_symbolic(&num_trace_bprintk_fmt, sizeof(int), "num_trace_bprintk_fmt");
   char const   **trace_bprintk_fmt_start ;
   struct trace_event_call **trace_events ;
   unsigned int num_trace_events ;
    klee_make_symbolic(&num_trace_events, sizeof(int), "num_trace_events");
   struct trace_enum_map **trace_enums ;
   unsigned int num_trace_enums ;
    klee_make_symbolic(&num_trace_enums, sizeof(int), "num_trace_enums");
   bool klp_alive ;
   struct list_head source_list ;
   struct list_head target_list ;
   void (*exit)(void) ;
   atomic_t refcnt ;
   ctor_fn_t (**ctors)(void) ;
   unsigned int num_ctors ;
    klee_make_symbolic(&num_ctors, sizeof(int), "num_ctors");
};
struct hlist_bl_node;
struct hlist_bl_head {
   struct hlist_bl_node *first ;
};
struct hlist_bl_node {
   struct hlist_bl_node *next ;
   struct hlist_bl_node **pprev ;
};
struct __anonstruct____missing_field_name_220 {
   spinlock_t lock ;
   int count ;
};
union __anonunion____missing_field_name_219 {
   struct __anonstruct____missing_field_name_220 __annonCompField58 ;
};
struct lockref {
   union __anonunion____missing_field_name_219 __annonCompField59 ;
};
struct path;
struct vfsmount;
struct __anonstruct____missing_field_name_222 {
   u32 hash ;
   u32 len ;
};
union __anonunion____missing_field_name_221 {
   struct __anonstruct____missing_field_name_222 __annonCompField60 ;
   u64 hash_len ;
};
struct qstr {
   union __anonunion____missing_field_name_221 __annonCompField61 ;
   unsigned char const   *name ;
};
struct dentry_operations;
union __anonunion_d_u_223 {
   struct hlist_node d_alias ;
   struct callback_head d_rcu ;
};
struct dentry {
   unsigned int d_flags ;
    klee_make_symbolic(&d_flags, sizeof(int), "d_flags");
   seqcount_t d_seq ;
   struct hlist_bl_node d_hash ;
   struct dentry *d_parent ;
   struct qstr d_name ;
   struct inode *d_inode ;
   unsigned char d_iname[32U] ;
   struct lockref d_lockref ;
   struct dentry_operations  const  *d_op ;
   struct super_block *d_sb ;
   unsigned long d_time ;
    klee_make_symbolic(&d_time, sizeof(long), "d_time");
   void *d_fsdata ;
   struct list_head d_lru ;
   struct list_head d_child ;
   struct list_head d_subdirs ;
   union __anonunion_d_u_223 d_u ;
};
struct dentry_operations {
   int (*d_revalidate)(struct dentry * , unsigned int  ) ;
   int (*d_weak_revalidate)(struct dentry * , unsigned int  ) ;
   int (*d_hash)(struct dentry  const  * , struct qstr * ) ;
   int (*d_compare)(struct dentry  const  * , struct dentry  const  * , unsigned int  ,
                    char const   * , struct qstr  const  * ) ;
   int (*d_delete)(struct dentry  const  * ) ;
   void (*d_release)(struct dentry * ) ;
   void (*d_prune)(struct dentry * ) ;
   void (*d_iput)(struct dentry * , struct inode * ) ;
   char *(*d_dname)(struct dentry * , char * , int  ) ;
   struct vfsmount *(*d_automount)(struct path * ) ;
   int (*d_manage)(struct dentry * , bool  ) ;
   struct inode *(*d_select_inode)(struct dentry * , unsigned int  ) ;
};
struct path {
   struct vfsmount *mnt ;
   struct dentry *dentry ;
};
struct shrink_control {
   gfp_t gfp_mask ;
   unsigned long nr_to_scan ;
    klee_make_symbolic(&nr_to_scan, sizeof(long), "nr_to_scan");
   int nid ;
    klee_make_symbolic(&nid, sizeof(int), "nid");
   struct mem_cgroup *memcg ;
};
struct shrinker {
   unsigned long (*count_objects)(struct shrinker * , struct shrink_control * ) ;
   unsigned long (*scan_objects)(struct shrinker * , struct shrink_control * ) ;
   int seeks ;
    klee_make_symbolic(&seeks, sizeof(int), "seeks");
   long batch ;
    klee_make_symbolic(&batch, sizeof(long), "batch");
   unsigned long flags ;
   struct list_head list ;
   atomic_long_t *nr_deferred ;
};
struct list_lru_one {
   struct list_head list ;
   long nr_items ;
    klee_make_symbolic(&nr_items, sizeof(long), "nr_items");
};
struct list_lru_memcg {
   struct list_lru_one *lru[0U] ;
};
struct list_lru_node {
   spinlock_t lock ;
   struct list_lru_one lru ;
   struct list_lru_memcg *memcg_lrus ;
};
struct list_lru {
   struct list_lru_node *node ;
   struct list_head list ;
};
struct __anonstruct____missing_field_name_227 {
   struct radix_tree_node *parent ;
   void *private_data ;
};
union __anonunion____missing_field_name_226 {
   struct __anonstruct____missing_field_name_227 __annonCompField62 ;
   struct callback_head callback_head ;
};
struct radix_tree_node {
   unsigned int path ;
    klee_make_symbolic(&path, sizeof(int), "path");
   unsigned int count ;
   union __anonunion____missing_field_name_226 __annonCompField63 ;
   struct list_head private_list ;
   void *slots[64U] ;
   unsigned long tags[3U][1U] ;
};
struct radix_tree_root {
   unsigned int height ;
    klee_make_symbolic(&height, sizeof(int), "height");
   gfp_t gfp_mask ;
   struct radix_tree_node *rnode ;
};
struct fiemap_extent {
   __u64 fe_logical ;
   __u64 fe_physical ;
   __u64 fe_length ;
   __u64 fe_reserved64[2U] ;
   __u32 fe_flags ;
   __u32 fe_reserved[3U] ;
};
enum migrate_mode {
    MIGRATE_ASYNC = 0,
    MIGRATE_SYNC_LIGHT = 1,
    MIGRATE_SYNC = 2
} ;
struct bio_set;
struct bio;
struct bio_integrity_payload;
struct block_device;
typedef void bio_end_io_t(struct bio * , int  );
struct bio_vec {
   struct page *bv_page ;
   unsigned int bv_len ;
    klee_make_symbolic(&bv_len, sizeof(int), "bv_len");
   unsigned int bv_offset ;
    klee_make_symbolic(&bv_offset, sizeof(int), "bv_offset");
};
struct bvec_iter {
   sector_t bi_sector ;
   unsigned int bi_size ;
    klee_make_symbolic(&bi_size, sizeof(int), "bi_size");
   unsigned int bi_idx ;
    klee_make_symbolic(&bi_idx, sizeof(int), "bi_idx");
   unsigned int bi_bvec_done ;
    klee_make_symbolic(&bi_bvec_done, sizeof(int), "bi_bvec_done");
};
union __anonunion____missing_field_name_230 {
   struct bio_integrity_payload *bi_integrity ;
};
struct bio {
   struct bio *bi_next ;
   struct block_device *bi_bdev ;
   unsigned long bi_flags ;
    klee_make_symbolic(&bi_flags, sizeof(long), "bi_flags");
   unsigned long bi_rw ;
    klee_make_symbolic(&bi_rw, sizeof(long), "bi_rw");
   struct bvec_iter bi_iter ;
   unsigned int bi_phys_segments ;
    klee_make_symbolic(&bi_phys_segments, sizeof(int), "bi_phys_segments");
   unsigned int bi_seg_front_size ;
    klee_make_symbolic(&bi_seg_front_size, sizeof(int), "bi_seg_front_size");
   unsigned int bi_seg_back_size ;
    klee_make_symbolic(&bi_seg_back_size, sizeof(int), "bi_seg_back_size");
   atomic_t __bi_remaining ;
   bio_end_io_t *bi_end_io ;
   void *bi_private ;
   struct io_context *bi_ioc ;
   struct cgroup_subsys_state *bi_css ;
   union __anonunion____missing_field_name_230 __annonCompField64 ;
   unsigned short bi_vcnt ;
    klee_make_symbolic(&bi_vcnt, sizeof(short), "bi_vcnt");
   unsigned short bi_max_vecs ;
    klee_make_symbolic(&bi_max_vecs, sizeof(short), "bi_max_vecs");
   atomic_t __bi_cnt ;
   struct bio_vec *bi_io_vec ;
   struct bio_set *bi_pool ;
   struct bio_vec bi_inline_vecs[0U] ;
};
struct bdi_writeback;
struct export_operations;
struct hd_geometry;
struct iovec;
struct kiocb;
struct poll_table_struct;
struct kstatfs;
struct swap_info_struct;
struct iov_iter;
struct vm_fault;
struct iattr {
   unsigned int ia_valid ;
    klee_make_symbolic(&ia_valid, sizeof(int), "ia_valid");
   umode_t ia_mode ;
   kuid_t ia_uid ;
   kgid_t ia_gid ;
   loff_t ia_size ;
   struct timespec ia_atime ;
   struct timespec ia_mtime ;
   struct timespec ia_ctime ;
   struct file *ia_file ;
};
struct dquot;
typedef __kernel_uid32_t projid_t;
struct __anonstruct_kprojid_t_231 {
   projid_t val ;
};
typedef struct __anonstruct_kprojid_t_231 kprojid_t;
enum quota_type {
    USRQUOTA = 0,
    GRPQUOTA = 1,
    PRJQUOTA = 2
} ;
typedef long long qsize_t;
    klee_make_symbolic(&qsize_t, sizeof(long), "qsize_t");
union __anonunion____missing_field_name_232 {
   kuid_t uid ;
   kgid_t gid ;
   kprojid_t projid ;
};
struct kqid {
   union __anonunion____missing_field_name_232 __annonCompField65 ;
   enum quota_type type ;
};
struct mem_dqblk {
   qsize_t dqb_bhardlimit ;
   qsize_t dqb_bsoftlimit ;
   qsize_t dqb_curspace ;
   qsize_t dqb_rsvspace ;
   qsize_t dqb_ihardlimit ;
   qsize_t dqb_isoftlimit ;
   qsize_t dqb_curinodes ;
   time_t dqb_btime ;
   time_t dqb_itime ;
};
struct quota_format_type;
struct mem_dqinfo {
   struct quota_format_type *dqi_format ;
   int dqi_fmt_id ;
    klee_make_symbolic(&dqi_fmt_id, sizeof(int), "dqi_fmt_id");
   struct list_head dqi_dirty_list ;
   unsigned long dqi_flags ;
    klee_make_symbolic(&dqi_flags, sizeof(long), "dqi_flags");
   unsigned int dqi_bgrace ;
    klee_make_symbolic(&dqi_bgrace, sizeof(int), "dqi_bgrace");
   unsigned int dqi_igrace ;
    klee_make_symbolic(&dqi_igrace, sizeof(int), "dqi_igrace");
   qsize_t dqi_max_spc_limit ;
   qsize_t dqi_max_ino_limit ;
   void *dqi_priv ;
};
struct dquot {
   struct hlist_node dq_hash ;
   struct list_head dq_inuse ;
   struct list_head dq_free ;
   struct list_head dq_dirty ;
   struct mutex dq_lock ;
   atomic_t dq_count ;
   wait_queue_head_t dq_wait_unused ;
   struct super_block *dq_sb ;
   struct kqid dq_id ;
   loff_t dq_off ;
   unsigned long dq_flags ;
    klee_make_symbolic(&dq_flags, sizeof(long), "dq_flags");
   struct mem_dqblk dq_dqb ;
};
struct quota_format_ops {
   int (*check_quota_file)(struct super_block * , int  ) ;
   int (*read_file_info)(struct super_block * , int  ) ;
   int (*write_file_info)(struct super_block * , int  ) ;
   int (*free_file_info)(struct super_block * , int  ) ;
   int (*read_dqblk)(struct dquot * ) ;
   int (*commit_dqblk)(struct dquot * ) ;
   int (*release_dqblk)(struct dquot * ) ;
};
struct dquot_operations {
   int (*write_dquot)(struct dquot * ) ;
   struct dquot *(*alloc_dquot)(struct super_block * , int  ) ;
   void (*destroy_dquot)(struct dquot * ) ;
   int (*acquire_dquot)(struct dquot * ) ;
   int (*release_dquot)(struct dquot * ) ;
   int (*mark_dirty)(struct dquot * ) ;
   int (*write_info)(struct super_block * , int  ) ;
   qsize_t *(*get_reserved_space)(struct inode * ) ;
   int (*get_projid)(struct inode * , kprojid_t * ) ;
};
struct qc_dqblk {
   int d_fieldmask ;
    klee_make_symbolic(&d_fieldmask, sizeof(int), "d_fieldmask");
   u64 d_spc_hardlimit ;
   u64 d_spc_softlimit ;
   u64 d_ino_hardlimit ;
   u64 d_ino_softlimit ;
   u64 d_space ;
   u64 d_ino_count ;
   s64 d_ino_timer ;
   s64 d_spc_timer ;
   int d_ino_warns ;
    klee_make_symbolic(&d_ino_warns, sizeof(int), "d_ino_warns");
   int d_spc_warns ;
    klee_make_symbolic(&d_spc_warns, sizeof(int), "d_spc_warns");
   u64 d_rt_spc_hardlimit ;
   u64 d_rt_spc_softlimit ;
   u64 d_rt_space ;
   s64 d_rt_spc_timer ;
   int d_rt_spc_warns ;
    klee_make_symbolic(&d_rt_spc_warns, sizeof(int), "d_rt_spc_warns");
};
struct qc_type_state {
   unsigned int flags ;
   unsigned int spc_timelimit ;
    klee_make_symbolic(&spc_timelimit, sizeof(int), "spc_timelimit");
   unsigned int ino_timelimit ;
    klee_make_symbolic(&ino_timelimit, sizeof(int), "ino_timelimit");
   unsigned int rt_spc_timelimit ;
    klee_make_symbolic(&rt_spc_timelimit, sizeof(int), "rt_spc_timelimit");
   unsigned int spc_warnlimit ;
    klee_make_symbolic(&spc_warnlimit, sizeof(int), "spc_warnlimit");
   unsigned int ino_warnlimit ;
    klee_make_symbolic(&ino_warnlimit, sizeof(int), "ino_warnlimit");
   unsigned int rt_spc_warnlimit ;
    klee_make_symbolic(&rt_spc_warnlimit, sizeof(int), "rt_spc_warnlimit");
   unsigned long long ino ;
   blkcnt_t blocks ;
   blkcnt_t nextents ;
};
struct qc_state {
   unsigned int s_incoredqs ;
    klee_make_symbolic(&s_incoredqs, sizeof(int), "s_incoredqs");
   struct qc_type_state s_state[3U] ;
};
struct qc_info {
   int i_fieldmask ;
    klee_make_symbolic(&i_fieldmask, sizeof(int), "i_fieldmask");
   unsigned int i_flags ;
    klee_make_symbolic(&i_flags, sizeof(int), "i_flags");
   unsigned int i_spc_timelimit ;
    klee_make_symbolic(&i_spc_timelimit, sizeof(int), "i_spc_timelimit");
   unsigned int i_ino_timelimit ;
    klee_make_symbolic(&i_ino_timelimit, sizeof(int), "i_ino_timelimit");
   unsigned int i_rt_spc_timelimit ;
    klee_make_symbolic(&i_rt_spc_timelimit, sizeof(int), "i_rt_spc_timelimit");
   unsigned int i_spc_warnlimit ;
    klee_make_symbolic(&i_spc_warnlimit, sizeof(int), "i_spc_warnlimit");
   unsigned int i_ino_warnlimit ;
    klee_make_symbolic(&i_ino_warnlimit, sizeof(int), "i_ino_warnlimit");
   unsigned int i_rt_spc_warnlimit ;
    klee_make_symbolic(&i_rt_spc_warnlimit, sizeof(int), "i_rt_spc_warnlimit");
};
struct quotactl_ops {
   int (*quota_on)(struct super_block * , int  , int  , struct path * ) ;
   int (*quota_off)(struct super_block * , int  ) ;
   int (*quota_enable)(struct super_block * , unsigned int  ) ;
   int (*quota_disable)(struct super_block * , unsigned int  ) ;
   int (*quota_sync)(struct super_block * , int  ) ;
   int (*set_info)(struct super_block * , int  , struct qc_info * ) ;
   int (*get_dqblk)(struct super_block * , struct kqid  , struct qc_dqblk * ) ;
   int (*set_dqblk)(struct super_block * , struct kqid  , struct qc_dqblk * ) ;
   int (*get_state)(struct super_block * , struct qc_state * ) ;
   int (*rm_xquota)(struct super_block * , unsigned int  ) ;
};
struct quota_format_type {
   int qf_fmt_id ;
    klee_make_symbolic(&qf_fmt_id, sizeof(int), "qf_fmt_id");
   struct quota_format_ops  const  *qf_ops ;
   struct module *qf_owner ;
   struct quota_format_type *qf_next ;
};
struct quota_info {
   unsigned int flags ;
   struct mutex dqio_mutex ;
   struct mutex dqonoff_mutex ;
   struct inode *files[3U] ;
   struct mem_dqinfo info[3U] ;
   struct quota_format_ops  const  *ops[3U] ;
};
struct writeback_control;
struct kiocb {
   struct file *ki_filp ;
   loff_t ki_pos ;
   void (*ki_complete)(struct kiocb * , long  , long  ) ;
   void *private ;
   int ki_flags ;
    klee_make_symbolic(&ki_flags, sizeof(int), "ki_flags");
};
struct address_space_operations {
   int (*writepage)(struct page * , struct writeback_control * ) ;
   int (*readpage)(struct file * , struct page * ) ;
   int (*writepages)(struct address_space * , struct writeback_control * ) ;
   int (*set_page_dirty)(struct page * ) ;
   int (*readpages)(struct file * , struct address_space * , struct list_head * ,
                    unsigned int  ) ;
   int (*write_begin)(struct file * , struct address_space * , loff_t  , unsigned int  ,
                      unsigned int  , struct page ** , void ** ) ;
   int (*write_end)(struct file * , struct address_space * , loff_t  , unsigned int  ,
                    unsigned int  , struct page * , void * ) ;
   sector_t (*bmap)(struct address_space * , sector_t  ) ;
   void (*invalidatepage)(struct page * , unsigned int  , unsigned int  ) ;
   int (*releasepage)(struct page * , gfp_t  ) ;
   void (*freepage)(struct page * ) ;
   ssize_t (*direct_IO)(struct kiocb * , struct iov_iter * , loff_t  ) ;
   int (*migratepage)(struct address_space * , struct page * , struct page * , enum migrate_mode  ) ;
   int (*launder_page)(struct page * ) ;
   int (*is_partially_uptodate)(struct page * , unsigned long  , unsigned long  ) ;
   void (*is_dirty_writeback)(struct page * , bool * , bool * ) ;
   int (*error_remove_page)(struct address_space * , struct page * ) ;
   int (*swap_activate)(struct swap_info_struct * , struct file * , sector_t * ) ;
   void (*swap_deactivate)(struct file * ) ;
};
struct address_space {
   struct inode *host ;
   struct radix_tree_root page_tree ;
   spinlock_t tree_lock ;
   atomic_t i_mmap_writable ;
   struct rb_root i_mmap ;
   struct rw_semaphore i_mmap_rwsem ;
   unsigned long nrpages ;
    klee_make_symbolic(&nrpages, sizeof(long), "nrpages");
   unsigned long nrshadows ;
    klee_make_symbolic(&nrshadows, sizeof(long), "nrshadows");
   unsigned long writeback_index ;
    klee_make_symbolic(&writeback_index, sizeof(long), "writeback_index");
   struct address_space_operations  const  *a_ops ;
   unsigned long flags ;
   spinlock_t private_lock ;
   struct list_head private_list ;
   void *private_data ;
};
struct request_queue;
struct hd_struct;
struct gendisk;
struct block_device {
   dev_t bd_dev ;
   int bd_openers ;
    klee_make_symbolic(&bd_openers, sizeof(int), "bd_openers");
   struct inode *bd_inode ;
   struct super_block *bd_super ;
   struct mutex bd_mutex ;
   struct list_head bd_inodes ;
   void *bd_claiming ;
   void *bd_holder ;
   int bd_holders ;
    klee_make_symbolic(&bd_holders, sizeof(int), "bd_holders");
   bool bd_write_holder ;
   struct list_head bd_holder_disks ;
   struct block_device *bd_contains ;
   unsigned int bd_block_size ;
    klee_make_symbolic(&bd_block_size, sizeof(int), "bd_block_size");
   struct hd_struct *bd_part ;
   unsigned int bd_part_count ;
    klee_make_symbolic(&bd_part_count, sizeof(int), "bd_part_count");
   int bd_invalidated ;
    klee_make_symbolic(&bd_invalidated, sizeof(int), "bd_invalidated");
   struct gendisk *bd_disk ;
   struct request_queue *bd_queue ;
   struct list_head bd_list ;
   unsigned long bd_private ;
    klee_make_symbolic(&bd_private, sizeof(long), "bd_private");
   int bd_fsfreeze_count ;
    klee_make_symbolic(&bd_fsfreeze_count, sizeof(int), "bd_fsfreeze_count");
   struct mutex bd_fsfreeze_mutex ;
};
struct posix_acl;
struct inode_operations;
union __anonunion____missing_field_name_235 {
   unsigned int const   i_nlink ;
   unsigned int __i_nlink ;
    klee_make_symbolic(&__i_nlink, sizeof(int), "__i_nlink");
};
union __anonunion____missing_field_name_236 {
   struct hlist_head i_dentry ;
   struct callback_head i_rcu ;
};
struct file_lock_context;
struct cdev;
union __anonunion____missing_field_name_237 {
   struct pipe_inode_info *i_pipe ;
   struct block_device *i_bdev ;
   struct cdev *i_cdev ;
   char *i_link ;
};
struct inode {
   umode_t i_mode ;
   unsigned short i_opflags ;
    klee_make_symbolic(&i_opflags, sizeof(short), "i_opflags");
   kuid_t i_uid ;
   kgid_t i_gid ;
   unsigned int i_flags ;
   struct posix_acl *i_acl ;
   struct posix_acl *i_default_acl ;
   struct inode_operations  const  *i_op ;
   struct super_block *i_sb ;
   struct address_space *i_mapping ;
   void *i_security ;
   unsigned long i_ino ;
    klee_make_symbolic(&i_ino, sizeof(long), "i_ino");
   union __anonunion____missing_field_name_235 __annonCompField66 ;
   dev_t i_rdev ;
   loff_t i_size ;
   struct timespec i_atime ;
   struct timespec i_mtime ;
   struct timespec i_ctime ;
   spinlock_t i_lock ;
   unsigned short i_bytes ;
    klee_make_symbolic(&i_bytes, sizeof(short), "i_bytes");
   unsigned int i_blkbits ;
    klee_make_symbolic(&i_blkbits, sizeof(int), "i_blkbits");
   blkcnt_t i_blocks ;
   unsigned long i_state ;
    klee_make_symbolic(&i_state, sizeof(long), "i_state");
   struct mutex i_mutex ;
   unsigned long dirtied_when ;
    klee_make_symbolic(&dirtied_when, sizeof(long), "dirtied_when");
   unsigned long dirtied_time_when ;
    klee_make_symbolic(&dirtied_time_when, sizeof(long), "dirtied_time_when");
   struct hlist_node i_hash ;
   struct list_head i_wb_list ;
   struct bdi_writeback *i_wb ;
   int i_wb_frn_winner ;
    klee_make_symbolic(&i_wb_frn_winner, sizeof(int), "i_wb_frn_winner");
   u16 i_wb_frn_avg_time ;
   u16 i_wb_frn_history ;
   struct list_head i_lru ;
   struct list_head i_sb_list ;
   union __anonunion____missing_field_name_236 __annonCompField67 ;
   u64 i_version ;
   atomic_t i_count ;
   atomic_t i_dio_count ;
   atomic_t i_writecount ;
   atomic_t i_readcount ;
   struct file_operations  const  *i_fop ;
   struct file_lock_context *i_flctx ;
   struct address_space i_data ;
   struct list_head i_devices ;
   union __anonunion____missing_field_name_237 __annonCompField68 ;
   __u32 i_generation ;
   __u32 i_fsnotify_mask ;
   struct hlist_head i_fsnotify_marks ;
   void *i_private ;
};
struct fown_struct {
   rwlock_t lock ;
   struct pid *pid ;
   enum pid_type pid_type ;
   kuid_t uid ;
   kuid_t euid ;
   int signum ;
    klee_make_symbolic(&signum, sizeof(int), "signum");
};
struct file_ra_state {
   unsigned long start ;
    klee_make_symbolic(&start, sizeof(long), "start");
   unsigned int size ;
   unsigned int async_size ;
    klee_make_symbolic(&async_size, sizeof(int), "async_size");
   unsigned int ra_pages ;
    klee_make_symbolic(&ra_pages, sizeof(int), "ra_pages");
   unsigned int mmap_miss ;
    klee_make_symbolic(&mmap_miss, sizeof(int), "mmap_miss");
   loff_t prev_pos ;
};
union __anonunion_f_u_238 {
   struct llist_node fu_llist ;
   struct callback_head fu_rcuhead ;
};
struct file {
   union __anonunion_f_u_238 f_u ;
   struct path f_path ;
   struct inode *f_inode ;
   struct file_operations  const  *f_op ;
   spinlock_t f_lock ;
   atomic_long_t f_count ;
   unsigned int f_flags ;
    klee_make_symbolic(&f_flags, sizeof(int), "f_flags");
   fmode_t f_mode ;
   struct mutex f_pos_lock ;
   loff_t f_pos ;
   struct fown_struct f_owner ;
   struct cred  const  *f_cred ;
   struct file_ra_state f_ra ;
   u64 f_version ;
   void *f_security ;
   void *private_data ;
   struct list_head f_ep_links ;
   struct list_head f_tfile_llink ;
   struct address_space *f_mapping ;
};
typedef void *fl_owner_t;
struct file_lock;
struct file_lock_operations {
   void (*fl_copy_lock)(struct file_lock * , struct file_lock * ) ;
   void (*fl_release_private)(struct file_lock * ) ;
};
struct lock_manager_operations {
   int (*lm_compare_owner)(struct file_lock * , struct file_lock * ) ;
   unsigned long (*lm_owner_key)(struct file_lock * ) ;
   fl_owner_t (*lm_get_owner)(fl_owner_t  ) ;
   void (*lm_put_owner)(fl_owner_t  ) ;
   void (*lm_notify)(struct file_lock * ) ;
   int (*lm_grant)(struct file_lock * , int  ) ;
   bool (*lm_break)(struct file_lock * ) ;
   int (*lm_change)(struct file_lock * , int  , struct list_head * ) ;
   void (*lm_setup)(struct file_lock * , void ** ) ;
};
struct net;
struct nlm_lockowner;
struct nfs_lock_info {
   u32 state ;
   struct nlm_lockowner *owner ;
   struct list_head list ;
};
struct nfs4_lock_state;
struct nfs4_lock_info {
   struct nfs4_lock_state *owner ;
};
struct fasync_struct;
struct __anonstruct_afs_240 {
   struct list_head link ;
   int state ;
};
union __anonunion_fl_u_239 {
   struct nfs_lock_info nfs_fl ;
   struct nfs4_lock_info nfs4_fl ;
   struct __anonstruct_afs_240 afs ;
};
struct file_lock {
   struct file_lock *fl_next ;
   struct list_head fl_list ;
   struct hlist_node fl_link ;
   struct list_head fl_block ;
   fl_owner_t fl_owner ;
   unsigned int fl_flags ;
    klee_make_symbolic(&fl_flags, sizeof(int), "fl_flags");
   unsigned char fl_type ;
    klee_make_symbolic(&fl_type, sizeof(char), "fl_type");
   unsigned int fl_pid ;
    klee_make_symbolic(&fl_pid, sizeof(int), "fl_pid");
   int fl_link_cpu ;
    klee_make_symbolic(&fl_link_cpu, sizeof(int), "fl_link_cpu");
   struct pid *fl_nspid ;
   wait_queue_head_t fl_wait ;
   struct file *fl_file ;
   loff_t fl_start ;
   loff_t fl_end ;
   struct fasync_struct *fl_fasync ;
   unsigned long fl_break_time ;
    klee_make_symbolic(&fl_break_time, sizeof(long), "fl_break_time");
   unsigned long fl_downgrade_time ;
    klee_make_symbolic(&fl_downgrade_time, sizeof(long), "fl_downgrade_time");
   struct file_lock_operations  const  *fl_ops ;
   struct lock_manager_operations  const  *fl_lmops ;
   union __anonunion_fl_u_239 fl_u ;
};
struct file_lock_context {
   spinlock_t flc_lock ;
   struct list_head flc_flock ;
   struct list_head flc_posix ;
   struct list_head flc_lease ;
};
struct fasync_struct {
   spinlock_t fa_lock ;
   int magic ;
   int fa_fd ;
    klee_make_symbolic(&fa_fd, sizeof(int), "fa_fd");
   struct fasync_struct *fa_next ;
   struct file *fa_file ;
   struct callback_head fa_rcu ;
};
struct sb_writers {
   struct percpu_counter counter[3U] ;
   wait_queue_head_t wait ;
   int frozen ;
    klee_make_symbolic(&frozen, sizeof(int), "frozen");
   wait_queue_head_t wait_unfrozen ;
   struct lockdep_map lock_map[3U] ;
};
struct super_operations;
struct xattr_handler;
struct mtd_info;
struct super_block {
   struct list_head s_list ;
   dev_t s_dev ;
   unsigned char s_blocksize_bits ;
    klee_make_symbolic(&s_blocksize_bits, sizeof(char), "s_blocksize_bits");
   unsigned long s_blocksize ;
    klee_make_symbolic(&s_blocksize, sizeof(long), "s_blocksize");
   loff_t s_maxbytes ;
   struct file_system_type *s_type ;
   struct super_operations  const  *s_op ;
   struct dquot_operations  const  *dq_op ;
   struct quotactl_ops  const  *s_qcop ;
   struct export_operations  const  *s_export_op ;
   unsigned long s_flags ;
    klee_make_symbolic(&s_flags, sizeof(long), "s_flags");
   unsigned long s_iflags ;
    klee_make_symbolic(&s_iflags, sizeof(long), "s_iflags");
   unsigned long s_magic ;
    klee_make_symbolic(&s_magic, sizeof(long), "s_magic");
   struct dentry *s_root ;
   struct rw_semaphore s_umount ;
   int s_count ;
    klee_make_symbolic(&s_count, sizeof(int), "s_count");
   atomic_t s_active ;
   void *s_security ;
   struct xattr_handler  const  **s_xattr ;
   struct list_head s_inodes ;
   struct hlist_bl_head s_anon ;
   struct list_head s_mounts ;
   struct block_device *s_bdev ;
   struct backing_dev_info *s_bdi ;
   struct mtd_info *s_mtd ;
   struct hlist_node s_instances ;
   unsigned int s_quota_types ;
    klee_make_symbolic(&s_quota_types, sizeof(int), "s_quota_types");
   struct quota_info s_dquot ;
   struct sb_writers s_writers ;
   char s_id[32U] ;
   u8 s_uuid[16U] ;
   void *s_fs_info ;
   unsigned int s_max_links ;
    klee_make_symbolic(&s_max_links, sizeof(int), "s_max_links");
   fmode_t s_mode ;
   u32 s_time_gran ;
   struct mutex s_vfs_rename_mutex ;
   char *s_subtype ;
   char *s_options ;
   struct dentry_operations  const  *s_d_op ;
   int cleancache_poolid ;
    klee_make_symbolic(&cleancache_poolid, sizeof(int), "cleancache_poolid");
   struct shrinker s_shrink ;
   atomic_long_t s_remove_count ;
   int s_readonly_remount ;
    klee_make_symbolic(&s_readonly_remount, sizeof(int), "s_readonly_remount");
   struct workqueue_struct *s_dio_done_wq ;
   struct hlist_head s_pins ;
   struct list_lru s_dentry_lru ;
   struct list_lru s_inode_lru ;
   struct callback_head rcu ;
   int s_stack_depth ;
    klee_make_symbolic(&s_stack_depth, sizeof(int), "s_stack_depth");
};
struct fiemap_extent_info {
   unsigned int fi_flags ;
    klee_make_symbolic(&fi_flags, sizeof(int), "fi_flags");
   unsigned int fi_extents_mapped ;
    klee_make_symbolic(&fi_extents_mapped, sizeof(int), "fi_extents_mapped");
   unsigned int fi_extents_max ;
    klee_make_symbolic(&fi_extents_max, sizeof(int), "fi_extents_max");
   struct fiemap_extent *fi_extents_start ;
};
struct dir_context;
struct dir_context {
   int (*actor)(struct dir_context * , char const   * , int  , loff_t  , u64  , unsigned int  ) ;
   loff_t pos ;
};
struct block_device_operations;
struct file_operations {
   struct module *owner ;
   loff_t (*llseek)(struct file * , loff_t  , int  ) ;
   ssize_t (*read)(struct file * , char * , size_t  , loff_t * ) ;
   ssize_t (*write)(struct file * , char const   * , size_t  , loff_t * ) ;
   ssize_t (*read_iter)(struct kiocb * , struct iov_iter * ) ;
   ssize_t (*write_iter)(struct kiocb * , struct iov_iter * ) ;
   int (*iterate)(struct file * , struct dir_context * ) ;
   unsigned int (*poll)(struct file * , struct poll_table_struct * ) ;
   long (*unlocked_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   long (*compat_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   int (*mmap)(struct file * , struct vm_area_struct * ) ;
   int (*mremap)(struct file * , struct vm_area_struct * ) ;
   int (*open)(struct inode * , struct file * ) ;
   int (*flush)(struct file * , fl_owner_t  ) ;
   int (*release)(struct inode * , struct file * ) ;
   int (*fsync)(struct file * , loff_t  , loff_t  , int  ) ;
   int (*aio_fsync)(struct kiocb * , int  ) ;
   int (*fasync)(int  , struct file * , int  ) ;
   int (*lock)(struct file * , int  , struct file_lock * ) ;
   ssize_t (*sendpage)(struct file * , struct page * , int  , size_t  , loff_t * ,
                       int  ) ;
   unsigned long (*get_unmapped_area)(struct file * , unsigned long  , unsigned long  ,
                                      unsigned long  , unsigned long  ) ;
   int (*check_flags)(int  ) ;
   int (*flock)(struct file * , int  , struct file_lock * ) ;
   ssize_t (*splice_write)(struct pipe_inode_info * , struct file * , loff_t * , size_t  ,
                           unsigned int  ) ;
   ssize_t (*splice_read)(struct file * , loff_t * , struct pipe_inode_info * , size_t  ,
                          unsigned int  ) ;
   int (*setlease)(struct file * , long  , struct file_lock ** , void ** ) ;
   long (*fallocate)(struct file * , int  , loff_t  , loff_t  ) ;
   void (*show_fdinfo)(struct seq_file * , struct file * ) ;
};
struct inode_operations {
   struct dentry *(*lookup)(struct inode * , struct dentry * , unsigned int  ) ;
   char const   *(*follow_link)(struct dentry * , void ** ) ;
   int (*permission)(struct inode * , int  ) ;
   struct posix_acl *(*get_acl)(struct inode * , int  ) ;
   int (*readlink)(struct dentry * , char * , int  ) ;
   void (*put_link)(struct inode * , void * ) ;
   int (*create)(struct inode * , struct dentry * , umode_t  , bool  ) ;
   int (*link)(struct dentry * , struct inode * , struct dentry * ) ;
   int (*unlink)(struct inode * , struct dentry * ) ;
   int (*symlink)(struct inode * , struct dentry * , char const   * ) ;
   int (*mkdir)(struct inode * , struct dentry * , umode_t  ) ;
   int (*rmdir)(struct inode * , struct dentry * ) ;
   int (*mknod)(struct inode * , struct dentry * , umode_t  , dev_t  ) ;
   int (*rename)(struct inode * , struct dentry * , struct inode * , struct dentry * ) ;
   int (*rename2)(struct inode * , struct dentry * , struct inode * , struct dentry * ,
                  unsigned int  ) ;
   int (*setattr)(struct dentry * , struct iattr * ) ;
   int (*getattr)(struct vfsmount * , struct dentry * , struct kstat * ) ;
   int (*setxattr)(struct dentry * , char const   * , void const   * , size_t  , int  ) ;
   ssize_t (*getxattr)(struct dentry * , char const   * , void * , size_t  ) ;
   ssize_t (*listxattr)(struct dentry * , char * , size_t  ) ;
   int (*removexattr)(struct dentry * , char const   * ) ;
   int (*fiemap)(struct inode * , struct fiemap_extent_info * , u64  , u64  ) ;
   int (*update_time)(struct inode * , struct timespec * , int  ) ;
   int (*atomic_open)(struct inode * , struct dentry * , struct file * , unsigned int  ,
                      umode_t  , int * ) ;
   int (*tmpfile)(struct inode * , struct dentry * , umode_t  ) ;
   int (*set_acl)(struct inode * , struct posix_acl * , int  ) ;
};
struct super_operations {
   struct inode *(*alloc_inode)(struct super_block * ) ;
   void (*destroy_inode)(struct inode * ) ;
   void (*dirty_inode)(struct inode * , int  ) ;
   int (*write_inode)(struct inode * , struct writeback_control * ) ;
   int (*drop_inode)(struct inode * ) ;
   void (*evict_inode)(struct inode * ) ;
   void (*put_super)(struct super_block * ) ;
   int (*sync_fs)(struct super_block * , int  ) ;
   int (*freeze_super)(struct super_block * ) ;
   int (*freeze_fs)(struct super_block * ) ;
   int (*thaw_super)(struct super_block * ) ;
   int (*unfreeze_fs)(struct super_block * ) ;
   int (*statfs)(struct dentry * , struct kstatfs * ) ;
   int (*remount_fs)(struct super_block * , int * , char * ) ;
   void (*umount_begin)(struct super_block * ) ;
   int (*show_options)(struct seq_file * , struct dentry * ) ;
   int (*show_devname)(struct seq_file * , struct dentry * ) ;
   int (*show_path)(struct seq_file * , struct dentry * ) ;
   int (*show_stats)(struct seq_file * , struct dentry * ) ;
   ssize_t (*quota_read)(struct super_block * , int  , char * , size_t  , loff_t  ) ;
   ssize_t (*quota_write)(struct super_block * , int  , char const   * , size_t  ,
                          loff_t  ) ;
   struct dquot **(*get_dquots)(struct inode * ) ;
   int (*bdev_try_to_free_page)(struct super_block * , struct page * , gfp_t  ) ;
   long (*nr_cached_objects)(struct super_block * , struct shrink_control * ) ;
   long (*free_cached_objects)(struct super_block * , struct shrink_control * ) ;
};
struct file_system_type {
   char const   *name ;
   int fs_flags ;
    klee_make_symbolic(&fs_flags, sizeof(int), "fs_flags");
   struct dentry *(*mount)(struct file_system_type * , int  , char const   * , void * ) ;
   void (*kill_sb)(struct super_block * ) ;
   struct module *owner ;
   struct file_system_type *next ;
   struct hlist_head fs_supers ;
   struct lock_class_key s_lock_key ;
   struct lock_class_key s_umount_key ;
   struct lock_class_key s_vfs_rename_key ;
   struct lock_class_key s_writers_key[3U] ;
   struct lock_class_key i_lock_key ;
   struct lock_class_key i_mutex_key ;
   struct lock_class_key i_mutex_dir_key ;
};
typedef unsigned long kernel_ulong_t;
    klee_make_symbolic(&kernel_ulong_t, sizeof(long), "kernel_ulong_t");
struct pci_device_id {
   __u32 vendor ;
   __u32 device ;
   __u32 subvendor ;
   __u32 subdevice ;
   __u32 class ;
   __u32 class_mask ;
   kernel_ulong_t driver_data ;
};
struct acpi_device_id {
   __u8 id[9U] ;
   kernel_ulong_t driver_data ;
};
struct of_device_id {
   char name[32U] ;
   char type[32U] ;
   char compatible[128U] ;
   void const   *data ;
};
struct klist_node;
struct klist {
   spinlock_t k_lock ;
   struct list_head k_list ;
   void (*get)(struct klist_node * ) ;
   void (*put)(struct klist_node * ) ;
};
struct klist_node {
   void *n_klist ;
   struct list_head n_node ;
   struct kref n_ref ;
};
struct seq_file {
   char *buf ;
   size_t size ;
   size_t from ;
   size_t count ;
   size_t pad_until ;
   loff_t index ;
   loff_t read_pos ;
   u64 version ;
   struct mutex lock ;
   struct seq_operations  const  *op ;
   int poll_event ;
    klee_make_symbolic(&poll_event, sizeof(int), "poll_event");
   struct user_namespace *user_ns ;
   void *private ;
};
struct seq_operations {
   void *(*start)(struct seq_file * , loff_t * ) ;
   void (*stop)(struct seq_file * , void * ) ;
   void *(*next)(struct seq_file * , void * , loff_t * ) ;
   int (*show)(struct seq_file * , void * ) ;
};
struct pinctrl;
struct pinctrl_state;
struct dev_pin_info {
   struct pinctrl *p ;
   struct pinctrl_state *default_state ;
   struct pinctrl_state *sleep_state ;
   struct pinctrl_state *idle_state ;
};
struct dma_map_ops;
struct dev_archdata {
   struct dma_map_ops *dma_ops ;
   void *iommu ;
};
struct device_private;
struct device_driver;
struct driver_private;
struct class;
struct subsys_private;
struct bus_type;
struct device_node;
struct fwnode_handle;
struct iommu_ops;
struct iommu_group;
struct device_attribute;
struct bus_type {
   char const   *name ;
   char const   *dev_name ;
   struct device *dev_root ;
   struct device_attribute *dev_attrs ;
   struct attribute_group  const  **bus_groups ;
   struct attribute_group  const  **dev_groups ;
   struct attribute_group  const  **drv_groups ;
   int (*match)(struct device * , struct device_driver * ) ;
   int (*uevent)(struct device * , struct kobj_uevent_env * ) ;
   int (*probe)(struct device * ) ;
   int (*remove)(struct device * ) ;
   void (*shutdown)(struct device * ) ;
   int (*online)(struct device * ) ;
   int (*offline)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
   struct iommu_ops  const  *iommu_ops ;
   struct subsys_private *p ;
   struct lock_class_key lock_key ;
};
struct device_type;
enum probe_type {
    PROBE_DEFAULT_STRATEGY = 0,
    PROBE_PREFER_ASYNCHRONOUS = 1,
    PROBE_FORCE_SYNCHRONOUS = 2
} ;
struct device_driver {
   char const   *name ;
   struct bus_type *bus ;
   struct module *owner ;
   char const   *mod_name ;
   bool suppress_bind_attrs ;
   enum probe_type probe_type ;
   struct of_device_id  const  *of_match_table ;
   struct acpi_device_id  const  *acpi_match_table ;
   int (*probe)(struct device * ) ;
   int (*remove)(struct device * ) ;
   void (*shutdown)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct attribute_group  const  **groups ;
   struct dev_pm_ops  const  *pm ;
   struct driver_private *p ;
};
struct class_attribute;
struct class {
   char const   *name ;
   struct module *owner ;
   struct class_attribute *class_attrs ;
   struct attribute_group  const  **dev_groups ;
   struct kobject *dev_kobj ;
   int (*dev_uevent)(struct device * , struct kobj_uevent_env * ) ;
   char *(*devnode)(struct device * , umode_t * ) ;
   void (*class_release)(struct class * ) ;
   void (*dev_release)(struct device * ) ;
   int (*suspend)(struct device * , pm_message_t  ) ;
   int (*resume)(struct device * ) ;
   struct kobj_ns_type_operations  const  *ns_type ;
   void const   *(*namespace)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
   struct subsys_private *p ;
};
struct class_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct class * , struct class_attribute * , char * ) ;
   ssize_t (*store)(struct class * , struct class_attribute * , char const   * , size_t  ) ;
};
struct device_type {
   char const   *name ;
   struct attribute_group  const  **groups ;
   int (*uevent)(struct device * , struct kobj_uevent_env * ) ;
   char *(*devnode)(struct device * , umode_t * , kuid_t * , kgid_t * ) ;
   void (*release)(struct device * ) ;
   struct dev_pm_ops  const  *pm ;
};
struct device_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct device * , struct device_attribute * , char * ) ;
   ssize_t (*store)(struct device * , struct device_attribute * , char const   * ,
                    size_t  ) ;
};
struct device_dma_parameters {
   unsigned int max_segment_size ;
    klee_make_symbolic(&max_segment_size, sizeof(int), "max_segment_size");
   unsigned long segment_boundary_mask ;
    klee_make_symbolic(&segment_boundary_mask, sizeof(long), "segment_boundary_mask");
};
struct dma_coherent_mem;
struct cma;
struct device {
   struct device *parent ;
   struct device_private *p ;
   struct kobject kobj ;
   char const   *init_name ;
   struct device_type  const  *type ;
   struct mutex mutex ;
   struct bus_type *bus ;
   struct device_driver *driver ;
   void *platform_data ;
   void *driver_data ;
   struct dev_pm_info power ;
   struct dev_pm_domain *pm_domain ;
   struct dev_pin_info *pins ;
   int numa_node ;
    klee_make_symbolic(&numa_node, sizeof(int), "numa_node");
   u64 *dma_mask ;
   u64 coherent_dma_mask ;
   unsigned long dma_pfn_offset ;
    klee_make_symbolic(&dma_pfn_offset, sizeof(long), "dma_pfn_offset");
   struct device_dma_parameters *dma_parms ;
   struct list_head dma_pools ;
   struct dma_coherent_mem *dma_mem ;
   struct cma *cma_area ;
   struct dev_archdata archdata ;
   struct device_node *of_node ;
   struct fwnode_handle *fwnode ;
   dev_t devt ;
   u32 id ;
   spinlock_t devres_lock ;
   struct list_head devres_head ;
   struct klist_node knode_class ;
   struct class *class ;
   struct attribute_group  const  **groups ;
   void (*release)(struct device * ) ;
   struct iommu_group *iommu_group ;
   bool offline_disabled ;
   bool offline ;
};
struct wakeup_source {
   char const   *name ;
   struct list_head entry ;
   spinlock_t lock ;
   struct wake_irq *wakeirq ;
   struct timer_list timer ;
   unsigned long timer_expires ;
   ktime_t total_time ;
   ktime_t max_time ;
   ktime_t last_time ;
   ktime_t start_prevent_time ;
   ktime_t prevent_sleep_time ;
   unsigned long event_count ;
    klee_make_symbolic(&event_count, sizeof(long), "event_count");
   unsigned long active_count ;
    klee_make_symbolic(&active_count, sizeof(long), "active_count");
   unsigned long relax_count ;
    klee_make_symbolic(&relax_count, sizeof(long), "relax_count");
   unsigned long expire_count ;
    klee_make_symbolic(&expire_count, sizeof(long), "expire_count");
   unsigned long wakeup_count ;
    klee_make_symbolic(&wakeup_count, sizeof(long), "wakeup_count");
   bool active ;
   bool autosleep_enabled ;
};
struct hotplug_slot;
struct pci_slot {
   struct pci_bus *bus ;
   struct list_head list ;
   struct hotplug_slot *hotplug ;
   unsigned char number ;
    klee_make_symbolic(&number, sizeof(char), "number");
   struct kobject kobj ;
};
typedef int pci_power_t;
    klee_make_symbolic(&pci_power_t, sizeof(int), "pci_power_t");
typedef unsigned int pci_channel_state_t;
    klee_make_symbolic(&pci_channel_state_t, sizeof(int), "pci_channel_state_t");
enum pci_channel_state {
    pci_channel_io_normal = 1,
    pci_channel_io_frozen = 2,
    pci_channel_io_perm_failure = 3
} ;
typedef unsigned short pci_dev_flags_t;
    klee_make_symbolic(&pci_dev_flags_t, sizeof(short), "pci_dev_flags_t");
typedef unsigned short pci_bus_flags_t;
    klee_make_symbolic(&pci_bus_flags_t, sizeof(short), "pci_bus_flags_t");
struct pcie_link_state;
struct pci_vpd;
struct pci_sriov;
struct pci_ats;
struct proc_dir_entry;
struct pci_driver;
union __anonunion____missing_field_name_244 {
   struct pci_sriov *sriov ;
   struct pci_dev *physfn ;
};
struct pci_dev {
   struct list_head bus_list ;
   struct pci_bus *bus ;
   struct pci_bus *subordinate ;
   void *sysdata ;
   struct proc_dir_entry *procent ;
   struct pci_slot *slot ;
   unsigned int devfn ;
    klee_make_symbolic(&devfn, sizeof(int), "devfn");
   unsigned short vendor ;
    klee_make_symbolic(&vendor, sizeof(short), "vendor");
   unsigned short device ;
    klee_make_symbolic(&device, sizeof(short), "device");
   unsigned short subsystem_vendor ;
    klee_make_symbolic(&subsystem_vendor, sizeof(short), "subsystem_vendor");
   unsigned short subsystem_device ;
    klee_make_symbolic(&subsystem_device, sizeof(short), "subsystem_device");
   unsigned int class ;
    klee_make_symbolic(&class, sizeof(int), "class");
   u8 revision ;
   u8 hdr_type ;
   u8 pcie_cap ;
   u8 msi_cap ;
   u8 msix_cap ;
   unsigned char pcie_mpss : 3 ;
   u8 rom_base_reg ;
   u8 pin ;
   u16 pcie_flags_reg ;
   u8 dma_alias_devfn ;
   struct pci_driver *driver ;
   u64 dma_mask ;
   struct device_dma_parameters dma_parms ;
   pci_power_t current_state ;
   u8 pm_cap ;
   unsigned char pme_support : 5 ;
   unsigned char pme_interrupt : 1 ;
   unsigned char pme_poll : 1 ;
   unsigned char d1_support : 1 ;
   unsigned char d2_support : 1 ;
   unsigned char no_d1d2 : 1 ;
   unsigned char no_d3cold : 1 ;
   unsigned char d3cold_allowed : 1 ;
   unsigned char mmio_always_on : 1 ;
   unsigned char wakeup_prepared : 1 ;
   unsigned char runtime_d3cold : 1 ;
   unsigned char ignore_hotplug : 1 ;
   unsigned int d3_delay ;
    klee_make_symbolic(&d3_delay, sizeof(int), "d3_delay");
   unsigned int d3cold_delay ;
    klee_make_symbolic(&d3cold_delay, sizeof(int), "d3cold_delay");
   struct pcie_link_state *link_state ;
   pci_channel_state_t error_state ;
   struct device dev ;
   int cfg_size ;
    klee_make_symbolic(&cfg_size, sizeof(int), "cfg_size");
   unsigned int irq ;
    klee_make_symbolic(&irq, sizeof(int), "irq");
   struct resource resource[17U] ;
   bool match_driver ;
   unsigned char transparent : 1 ;
   unsigned char multifunction : 1 ;
   unsigned char is_added : 1 ;
   unsigned char is_busmaster : 1 ;
   unsigned char no_msi : 1 ;
   unsigned char no_64bit_msi : 1 ;
   unsigned char block_cfg_access : 1 ;
   unsigned char broken_parity_status : 1 ;
   unsigned char irq_reroute_variant : 2 ;
   unsigned char msi_enabled : 1 ;
   unsigned char msix_enabled : 1 ;
   unsigned char ari_enabled : 1 ;
   unsigned char is_managed : 1 ;
   unsigned char needs_freset : 1 ;
   unsigned char state_saved : 1 ;
   unsigned char is_physfn : 1 ;
   unsigned char is_virtfn : 1 ;
   unsigned char reset_fn : 1 ;
   unsigned char is_hotplug_bridge : 1 ;
   unsigned char __aer_firmware_first_valid : 1 ;
   unsigned char __aer_firmware_first : 1 ;
   unsigned char broken_intx_masking : 1 ;
   unsigned char io_window_1k : 1 ;
   unsigned char irq_managed : 1 ;
   unsigned char has_secondary_link : 1 ;
   pci_dev_flags_t dev_flags ;
   atomic_t enable_cnt ;
   u32 saved_config_space[16U] ;
   struct hlist_head saved_cap_space ;
   struct bin_attribute *rom_attr ;
   int rom_attr_enabled ;
    klee_make_symbolic(&rom_attr_enabled, sizeof(int), "rom_attr_enabled");
   struct bin_attribute *res_attr[17U] ;
   struct bin_attribute *res_attr_wc[17U] ;
   struct list_head msi_list ;
   struct attribute_group  const  **msi_irq_groups ;
   struct pci_vpd *vpd ;
   union __anonunion____missing_field_name_244 __annonCompField69 ;
   struct pci_ats *ats ;
   phys_addr_t rom ;
   size_t romlen ;
   char *driver_override ;
};
struct pci_ops;
struct msi_controller;
struct pci_bus {
   struct list_head node ;
   struct pci_bus *parent ;
   struct list_head children ;
   struct list_head devices ;
   struct pci_dev *self ;
   struct list_head slots ;
   struct resource *resource[4U] ;
   struct list_head resources ;
   struct resource busn_res ;
   struct pci_ops *ops ;
   struct msi_controller *msi ;
   void *sysdata ;
   struct proc_dir_entry *procdir ;
   unsigned char number ;
   unsigned char primary ;
    klee_make_symbolic(&primary, sizeof(char), "primary");
   unsigned char max_bus_speed ;
    klee_make_symbolic(&max_bus_speed, sizeof(char), "max_bus_speed");
   unsigned char cur_bus_speed ;
    klee_make_symbolic(&cur_bus_speed, sizeof(char), "cur_bus_speed");
   char name[48U] ;
   unsigned short bridge_ctl ;
    klee_make_symbolic(&bridge_ctl, sizeof(short), "bridge_ctl");
   pci_bus_flags_t bus_flags ;
   struct device *bridge ;
   struct device dev ;
   struct bin_attribute *legacy_io ;
   struct bin_attribute *legacy_mem ;
   unsigned char is_added : 1 ;
};
struct pci_ops {
   void *(*map_bus)(struct pci_bus * , unsigned int  , int  ) ;
   int (*read)(struct pci_bus * , unsigned int  , int  , int  , u32 * ) ;
   int (*write)(struct pci_bus * , unsigned int  , int  , int  , u32  ) ;
};
struct pci_dynids {
   spinlock_t lock ;
   struct list_head list ;
};
typedef unsigned int pci_ers_result_t;
    klee_make_symbolic(&pci_ers_result_t, sizeof(int), "pci_ers_result_t");
struct pci_error_handlers {
   pci_ers_result_t (*error_detected)(struct pci_dev * , enum pci_channel_state  ) ;
   pci_ers_result_t (*mmio_enabled)(struct pci_dev * ) ;
   pci_ers_result_t (*link_reset)(struct pci_dev * ) ;
   pci_ers_result_t (*slot_reset)(struct pci_dev * ) ;
   void (*reset_notify)(struct pci_dev * , bool  ) ;
   void (*resume)(struct pci_dev * ) ;
};
struct pci_driver {
   struct list_head node ;
   char const   *name ;
   struct pci_device_id  const  *id_table ;
   int (*probe)(struct pci_dev * , struct pci_device_id  const  * ) ;
   void (*remove)(struct pci_dev * ) ;
   int (*suspend)(struct pci_dev * , pm_message_t  ) ;
   int (*suspend_late)(struct pci_dev * , pm_message_t  ) ;
   int (*resume_early)(struct pci_dev * ) ;
   int (*resume)(struct pci_dev * ) ;
   void (*shutdown)(struct pci_dev * ) ;
   int (*sriov_configure)(struct pci_dev * , int  ) ;
   struct pci_error_handlers  const  *err_handler ;
   struct device_driver driver ;
   struct pci_dynids dynids ;
};
struct vm_fault {
   unsigned int flags ;
   unsigned long pgoff ;
    klee_make_symbolic(&pgoff, sizeof(long), "pgoff");
   void *virtual_address ;
   struct page *cow_page ;
   struct page *page ;
   unsigned long max_pgoff ;
    klee_make_symbolic(&max_pgoff, sizeof(long), "max_pgoff");
   pte_t *pte ;
};
struct vm_operations_struct {
   void (*open)(struct vm_area_struct * ) ;
   void (*close)(struct vm_area_struct * ) ;
   int (*fault)(struct vm_area_struct * , struct vm_fault * ) ;
   void (*map_pages)(struct vm_area_struct * , struct vm_fault * ) ;
   int (*page_mkwrite)(struct vm_area_struct * , struct vm_fault * ) ;
   int (*pfn_mkwrite)(struct vm_area_struct * , struct vm_fault * ) ;
   int (*access)(struct vm_area_struct * , unsigned long  , void * , int  , int  ) ;
   char const   *(*name)(struct vm_area_struct * ) ;
   int (*set_policy)(struct vm_area_struct * , struct mempolicy * ) ;
   struct mempolicy *(*get_policy)(struct vm_area_struct * , unsigned long  ) ;
   struct page *(*find_special_page)(struct vm_area_struct * , unsigned long  ) ;
};
struct kvec;
struct scatterlist {
   unsigned long sg_magic ;
    klee_make_symbolic(&sg_magic, sizeof(long), "sg_magic");
   unsigned long page_link ;
    klee_make_symbolic(&page_link, sizeof(long), "page_link");
   unsigned int offset ;
    klee_make_symbolic(&offset, sizeof(int), "offset");
   unsigned int length ;
    klee_make_symbolic(&length, sizeof(int), "length");
   dma_addr_t dma_address ;
   unsigned int dma_length ;
    klee_make_symbolic(&dma_length, sizeof(int), "dma_length");
};
struct sg_table {
   struct scatterlist *sgl ;
   unsigned int nents ;
    klee_make_symbolic(&nents, sizeof(int), "nents");
   unsigned int orig_nents ;
    klee_make_symbolic(&orig_nents, sizeof(int), "orig_nents");
};
struct msix_entry {
   u32 vector ;
   u16 entry ;
};
struct dma_attrs {
   unsigned long flags[1U] ;
};
enum dma_data_direction {
    DMA_BIDIRECTIONAL = 0,
    DMA_TO_DEVICE = 1,
    DMA_FROM_DEVICE = 2,
    DMA_NONE = 3
} ;
struct dma_map_ops {
   void *(*alloc)(struct device * , size_t  , dma_addr_t * , gfp_t  , struct dma_attrs * ) ;
   void (*free)(struct device * , size_t  , void * , dma_addr_t  , struct dma_attrs * ) ;
   int (*mmap)(struct device * , struct vm_area_struct * , void * , dma_addr_t  ,
               size_t  , struct dma_attrs * ) ;
   int (*get_sgtable)(struct device * , struct sg_table * , void * , dma_addr_t  ,
                      size_t  , struct dma_attrs * ) ;
   dma_addr_t (*map_page)(struct device * , struct page * , unsigned long  , size_t  ,
                          enum dma_data_direction  , struct dma_attrs * ) ;
   void (*unmap_page)(struct device * , dma_addr_t  , size_t  , enum dma_data_direction  ,
                      struct dma_attrs * ) ;
   int (*map_sg)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ,
                 struct dma_attrs * ) ;
   void (*unmap_sg)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ,
                    struct dma_attrs * ) ;
   void (*sync_single_for_cpu)(struct device * , dma_addr_t  , size_t  , enum dma_data_direction  ) ;
   void (*sync_single_for_device)(struct device * , dma_addr_t  , size_t  , enum dma_data_direction  ) ;
   void (*sync_sg_for_cpu)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ) ;
   void (*sync_sg_for_device)(struct device * , struct scatterlist * , int  , enum dma_data_direction  ) ;
   int (*mapping_error)(struct device * , dma_addr_t  ) ;
   int (*dma_supported)(struct device * , u64  ) ;
   int (*set_dma_mask)(struct device * , u64  ) ;
   int is_phys ;
    klee_make_symbolic(&is_phys, sizeof(int), "is_phys");
};
struct firmware {
   size_t size ;
   u8 const   *data ;
   struct page **pages ;
   void *priv ;
};
struct exception_table_entry {
   int insn ;
    klee_make_symbolic(&insn, sizeof(int), "insn");
   int fixup ;
    klee_make_symbolic(&fixup, sizeof(int), "fixup");
};
struct cdev {
   struct kobject kobj ;
   struct module *owner ;
   struct file_operations  const  *ops ;
   struct list_head list ;
   dev_t dev ;
   unsigned int count ;
};
struct scsi_lun {
   __u8 scsi_lun[8U] ;
};
struct scsi_sense_hdr {
   u8 response_code ;
   u8 sense_key ;
   u8 asc ;
   u8 ascq ;
   u8 byte4 ;
   u8 byte5 ;
   u8 byte6 ;
   u8 additional_length ;
};
struct disk_stats {
   unsigned long sectors[2U] ;
   unsigned long ios[2U] ;
   unsigned long merges[2U] ;
   unsigned long ticks[2U] ;
   unsigned long io_ticks ;
    klee_make_symbolic(&io_ticks, sizeof(long), "io_ticks");
   unsigned long time_in_queue ;
    klee_make_symbolic(&time_in_queue, sizeof(long), "time_in_queue");
};
struct partition_meta_info {
   char uuid[37U] ;
   u8 volname[64U] ;
};
struct hd_struct {
   sector_t start_sect ;
   sector_t nr_sects ;
   seqcount_t nr_sects_seq ;
   sector_t alignment_offset ;
   unsigned int discard_alignment ;
    klee_make_symbolic(&discard_alignment, sizeof(int), "discard_alignment");
   struct device __dev ;
   struct kobject *holder_dir ;
   int policy ;
   int partno ;
    klee_make_symbolic(&partno, sizeof(int), "partno");
   struct partition_meta_info *info ;
   int make_it_fail ;
   unsigned long stamp ;
    klee_make_symbolic(&stamp, sizeof(long), "stamp");
   atomic_t in_flight[2U] ;
   struct disk_stats *dkstats ;
   atomic_t ref ;
   struct callback_head callback_head ;
};
struct disk_part_tbl {
   struct callback_head callback_head ;
   int len ;
    klee_make_symbolic(&len, sizeof(int), "len");
   struct hd_struct *last_lookup ;
   struct hd_struct *part[] ;
};
struct disk_events;
struct timer_rand_state;
struct blk_integrity;
struct gendisk {
   int major ;
    klee_make_symbolic(&major, sizeof(int), "major");
   int first_minor ;
    klee_make_symbolic(&first_minor, sizeof(int), "first_minor");
   int minors ;
    klee_make_symbolic(&minors, sizeof(int), "minors");
   char disk_name[32U] ;
   char *(*devnode)(struct gendisk * , umode_t * ) ;
   unsigned int events ;
   unsigned int async_events ;
    klee_make_symbolic(&async_events, sizeof(int), "async_events");
   struct disk_part_tbl *part_tbl ;
   struct hd_struct part0 ;
   struct block_device_operations  const  *fops ;
   struct request_queue *queue ;
   void *private_data ;
   int flags ;
   struct device *driverfs_dev ;
   struct kobject *slave_dir ;
   struct timer_rand_state *random ;
   atomic_t sync_io ;
   struct disk_events *ev ;
   struct blk_integrity *integrity ;
   int node_id ;
    klee_make_symbolic(&node_id, sizeof(int), "node_id");
};
struct fprop_local_percpu {
   struct percpu_counter events ;
   unsigned int period ;
    klee_make_symbolic(&period, sizeof(int), "period");
   raw_spinlock_t lock ;
};
typedef int congested_fn(void * , int  );
struct bdi_writeback_congested {
   unsigned long state ;
   atomic_t refcnt ;
   struct backing_dev_info *bdi ;
   int blkcg_id ;
    klee_make_symbolic(&blkcg_id, sizeof(int), "blkcg_id");
   struct rb_node rb_node ;
};
union __anonunion____missing_field_name_253 {
   struct work_struct release_work ;
   struct callback_head rcu ;
};
struct bdi_writeback {
   struct backing_dev_info *bdi ;
   unsigned long state ;
   unsigned long last_old_flush ;
    klee_make_symbolic(&last_old_flush, sizeof(long), "last_old_flush");
   struct list_head b_dirty ;
   struct list_head b_io ;
   struct list_head b_more_io ;
   struct list_head b_dirty_time ;
   spinlock_t list_lock ;
   struct percpu_counter stat[4U] ;
   struct bdi_writeback_congested *congested ;
   unsigned long bw_time_stamp ;
    klee_make_symbolic(&bw_time_stamp, sizeof(long), "bw_time_stamp");
   unsigned long dirtied_stamp ;
    klee_make_symbolic(&dirtied_stamp, sizeof(long), "dirtied_stamp");
   unsigned long written_stamp ;
    klee_make_symbolic(&written_stamp, sizeof(long), "written_stamp");
   unsigned long write_bandwidth ;
    klee_make_symbolic(&write_bandwidth, sizeof(long), "write_bandwidth");
   unsigned long avg_write_bandwidth ;
    klee_make_symbolic(&avg_write_bandwidth, sizeof(long), "avg_write_bandwidth");
   unsigned long dirty_ratelimit ;
    klee_make_symbolic(&dirty_ratelimit, sizeof(long), "dirty_ratelimit");
   unsigned long balanced_dirty_ratelimit ;
    klee_make_symbolic(&balanced_dirty_ratelimit, sizeof(long), "balanced_dirty_ratelimit");
   struct fprop_local_percpu completions ;
   int dirty_exceeded ;
    klee_make_symbolic(&dirty_exceeded, sizeof(int), "dirty_exceeded");
   spinlock_t work_lock ;
   struct list_head work_list ;
   struct delayed_work dwork ;
   struct percpu_ref refcnt ;
   struct fprop_local_percpu memcg_completions ;
   struct cgroup_subsys_state *memcg_css ;
   struct cgroup_subsys_state *blkcg_css ;
   struct list_head memcg_node ;
   struct list_head blkcg_node ;
   union __anonunion____missing_field_name_253 __annonCompField77 ;
};
struct backing_dev_info {
   struct list_head bdi_list ;
   unsigned long ra_pages ;
   unsigned int capabilities ;
    klee_make_symbolic(&capabilities, sizeof(int), "capabilities");
   congested_fn *congested_fn ;
   void *congested_data ;
   char *name ;
   unsigned int min_ratio ;
    klee_make_symbolic(&min_ratio, sizeof(int), "min_ratio");
   unsigned int max_ratio ;
    klee_make_symbolic(&max_ratio, sizeof(int), "max_ratio");
   unsigned int max_prop_frac ;
    klee_make_symbolic(&max_prop_frac, sizeof(int), "max_prop_frac");
   atomic_long_t tot_write_bandwidth ;
   struct bdi_writeback wb ;
   struct radix_tree_root cgwb_tree ;
   struct rb_root cgwb_congested_tree ;
   atomic_t usage_cnt ;
   wait_queue_head_t wb_waitq ;
   struct device *dev ;
   struct timer_list laptop_mode_wb_timer ;
   struct dentry *debug_dir ;
   struct dentry *debug_stats ;
};
typedef void *mempool_alloc_t(gfp_t  , void * );
typedef void mempool_free_t(void * , void * );
struct mempool_s {
   spinlock_t lock ;
   int min_nr ;
    klee_make_symbolic(&min_nr, sizeof(int), "min_nr");
   int curr_nr ;
    klee_make_symbolic(&curr_nr, sizeof(int), "curr_nr");
   void **elements ;
   void *pool_data ;
   mempool_alloc_t *alloc ;
   mempool_free_t *free ;
   wait_queue_head_t wait ;
};
typedef struct mempool_s mempool_t;
union __anonunion____missing_field_name_254 {
   struct list_head q_node ;
   struct kmem_cache *__rcu_icq_cache ;
};
union __anonunion____missing_field_name_255 {
   struct hlist_node ioc_node ;
   struct callback_head __rcu_head ;
};
struct io_cq {
   struct request_queue *q ;
   struct io_context *ioc ;
   union __anonunion____missing_field_name_254 __annonCompField78 ;
   union __anonunion____missing_field_name_255 __annonCompField79 ;
   unsigned int flags ;
};
struct io_context {
   atomic_long_t refcount ;
   atomic_t active_ref ;
   atomic_t nr_tasks ;
   spinlock_t lock ;
   unsigned short ioprio ;
    klee_make_symbolic(&ioprio, sizeof(short), "ioprio");
   int nr_batch_requests ;
    klee_make_symbolic(&nr_batch_requests, sizeof(int), "nr_batch_requests");
   unsigned long last_waited ;
    klee_make_symbolic(&last_waited, sizeof(long), "last_waited");
   struct radix_tree_root icq_tree ;
   struct io_cq *icq_hint ;
   struct hlist_head icq_list ;
   struct work_struct release_work ;
};
struct bio_integrity_payload {
   struct bio *bip_bio ;
   struct bvec_iter bip_iter ;
   bio_end_io_t *bip_end_io ;
   unsigned short bip_slab ;
    klee_make_symbolic(&bip_slab, sizeof(short), "bip_slab");
   unsigned short bip_vcnt ;
    klee_make_symbolic(&bip_vcnt, sizeof(short), "bip_vcnt");
   unsigned short bip_max_vcnt ;
    klee_make_symbolic(&bip_max_vcnt, sizeof(short), "bip_max_vcnt");
   unsigned short bip_flags ;
    klee_make_symbolic(&bip_flags, sizeof(short), "bip_flags");
   struct work_struct bip_work ;
   struct bio_vec *bip_vec ;
   struct bio_vec bip_inline_vecs[0U] ;
};
struct bio_list {
   struct bio *head ;
   struct bio *tail ;
};
struct bio_set {
   struct kmem_cache *bio_slab ;
   unsigned int front_pad ;
    klee_make_symbolic(&front_pad, sizeof(int), "front_pad");
   mempool_t *bio_pool ;
   mempool_t *bvec_pool ;
   mempool_t *bio_integrity_pool ;
   mempool_t *bvec_integrity_pool ;
   spinlock_t rescue_lock ;
   struct bio_list rescue_list ;
   struct work_struct rescue_work ;
   struct workqueue_struct *rescue_workqueue ;
};
struct bsg_class_device {
   struct device *class_dev ;
   struct device *parent ;
   int minor ;
    klee_make_symbolic(&minor, sizeof(int), "minor");
   struct request_queue *queue ;
   struct kref ref ;
   void (*release)(struct device * ) ;
};
struct elevator_queue;
struct request;
struct bsg_job;
struct blkcg_gq;
struct blk_flush_queue;
typedef void rq_end_io_fn(struct request * , int  );
struct request_list {
   struct request_queue *q ;
   struct blkcg_gq *blkg ;
   int count[2U] ;
   int starved[2U] ;
   mempool_t *rq_pool ;
   wait_queue_head_t wait[2U] ;
   unsigned int flags ;
};
union __anonunion____missing_field_name_256 {
   struct call_single_data csd ;
   unsigned long fifo_time ;
    klee_make_symbolic(&fifo_time, sizeof(long), "fifo_time");
};
struct blk_mq_ctx;
union __anonunion____missing_field_name_257 {
   struct hlist_node hash ;
   struct list_head ipi_list ;
};
union __anonunion____missing_field_name_258 {
   struct rb_node rb_node ;
   void *completion_data ;
};
struct __anonstruct_elv_260 {
   struct io_cq *icq ;
   void *priv[2U] ;
};
struct __anonstruct_flush_261 {
   unsigned int seq ;
    klee_make_symbolic(&seq, sizeof(int), "seq");
   struct list_head list ;
   rq_end_io_fn *saved_end_io ;
};
union __anonunion____missing_field_name_259 {
   struct __anonstruct_elv_260 elv ;
   struct __anonstruct_flush_261 flush ;
};
struct request {
   struct list_head queuelist ;
   union __anonunion____missing_field_name_256 __annonCompField80 ;
   struct request_queue *q ;
   struct blk_mq_ctx *mq_ctx ;
   u64 cmd_flags ;
   unsigned int cmd_type ;
    klee_make_symbolic(&cmd_type, sizeof(int), "cmd_type");
   unsigned long atomic_flags ;
   int cpu ;
   unsigned int __data_len ;
    klee_make_symbolic(&__data_len, sizeof(int), "__data_len");
   sector_t __sector ;
   struct bio *bio ;
   struct bio *biotail ;
   union __anonunion____missing_field_name_257 __annonCompField81 ;
   union __anonunion____missing_field_name_258 __annonCompField82 ;
   union __anonunion____missing_field_name_259 __annonCompField83 ;
   struct gendisk *rq_disk ;
   struct hd_struct *part ;
   unsigned long start_time ;
    klee_make_symbolic(&start_time, sizeof(long), "start_time");
   struct request_list *rl ;
   unsigned long long start_time_ns ;
    klee_make_symbolic(&start_time_ns, sizeof(long), "start_time_ns");
   unsigned long long io_start_time_ns ;
    klee_make_symbolic(&io_start_time_ns, sizeof(long), "io_start_time_ns");
   unsigned short nr_phys_segments ;
    klee_make_symbolic(&nr_phys_segments, sizeof(short), "nr_phys_segments");
   unsigned short nr_integrity_segments ;
    klee_make_symbolic(&nr_integrity_segments, sizeof(short), "nr_integrity_segments");
   unsigned short ioprio ;
   void *special ;
   int tag ;
    klee_make_symbolic(&tag, sizeof(int), "tag");
   int errors ;
    klee_make_symbolic(&errors, sizeof(int), "errors");
   unsigned char __cmd[16U] ;
   unsigned char *cmd ;
   unsigned short cmd_len ;
    klee_make_symbolic(&cmd_len, sizeof(short), "cmd_len");
   unsigned int extra_len ;
    klee_make_symbolic(&extra_len, sizeof(int), "extra_len");
   unsigned int sense_len ;
    klee_make_symbolic(&sense_len, sizeof(int), "sense_len");
   unsigned int resid_len ;
    klee_make_symbolic(&resid_len, sizeof(int), "resid_len");
   void *sense ;
   unsigned long deadline ;
    klee_make_symbolic(&deadline, sizeof(long), "deadline");
   struct list_head timeout_list ;
   unsigned int timeout ;
   int retries ;
    klee_make_symbolic(&retries, sizeof(int), "retries");
   rq_end_io_fn *end_io ;
   void *end_io_data ;
   struct request *next_rq ;
};
struct elevator_type;
typedef int elevator_merge_fn(struct request_queue * , struct request ** , struct bio * );
typedef void elevator_merge_req_fn(struct request_queue * , struct request * , struct request * );
typedef void elevator_merged_fn(struct request_queue * , struct request * , int  );
typedef int elevator_allow_merge_fn(struct request_queue * , struct request * , struct bio * );
typedef void elevator_bio_merged_fn(struct request_queue * , struct request * , struct bio * );
typedef int elevator_dispatch_fn(struct request_queue * , int  );
typedef void elevator_add_req_fn(struct request_queue * , struct request * );
typedef struct request *elevator_request_list_fn(struct request_queue * , struct request * );
typedef void elevator_completed_req_fn(struct request_queue * , struct request * );
typedef int elevator_may_queue_fn(struct request_queue * , int  );
typedef void elevator_init_icq_fn(struct io_cq * );
typedef void elevator_exit_icq_fn(struct io_cq * );
typedef int elevator_set_req_fn(struct request_queue * , struct request * , struct bio * ,
                                gfp_t  );
typedef void elevator_put_req_fn(struct request * );
typedef void elevator_activate_req_fn(struct request_queue * , struct request * );
typedef void elevator_deactivate_req_fn(struct request_queue * , struct request * );
typedef int elevator_init_fn(struct request_queue * , struct elevator_type * );
typedef void elevator_exit_fn(struct elevator_queue * );
typedef void elevator_registered_fn(struct request_queue * );
struct elevator_ops {
   elevator_merge_fn *elevator_merge_fn ;
   elevator_merged_fn *elevator_merged_fn ;
   elevator_merge_req_fn *elevator_merge_req_fn ;
   elevator_allow_merge_fn *elevator_allow_merge_fn ;
   elevator_bio_merged_fn *elevator_bio_merged_fn ;
   elevator_dispatch_fn *elevator_dispatch_fn ;
   elevator_add_req_fn *elevator_add_req_fn ;
   elevator_activate_req_fn *elevator_activate_req_fn ;
   elevator_deactivate_req_fn *elevator_deactivate_req_fn ;
   elevator_completed_req_fn *elevator_completed_req_fn ;
   elevator_request_list_fn *elevator_former_req_fn ;
   elevator_request_list_fn *elevator_latter_req_fn ;
   elevator_init_icq_fn *elevator_init_icq_fn ;
   elevator_exit_icq_fn *elevator_exit_icq_fn ;
   elevator_set_req_fn *elevator_set_req_fn ;
   elevator_put_req_fn *elevator_put_req_fn ;
   elevator_may_queue_fn *elevator_may_queue_fn ;
   elevator_init_fn *elevator_init_fn ;
   elevator_exit_fn *elevator_exit_fn ;
   elevator_registered_fn *elevator_registered_fn ;
};
struct elv_fs_entry {
   struct attribute attr ;
   ssize_t (*show)(struct elevator_queue * , char * ) ;
   ssize_t (*store)(struct elevator_queue * , char const   * , size_t  ) ;
};
struct elevator_type {
   struct kmem_cache *icq_cache ;
   struct elevator_ops ops ;
   size_t icq_size ;
   size_t icq_align ;
   struct elv_fs_entry *elevator_attrs ;
   char elevator_name[16U] ;
   struct module *elevator_owner ;
   char icq_cache_name[21U] ;
   struct list_head list ;
};
struct elevator_queue {
   struct elevator_type *type ;
   void *elevator_data ;
   struct kobject kobj ;
   struct mutex sysfs_lock ;
   unsigned char registered : 1 ;
   struct hlist_head hash[64U] ;
};
typedef void request_fn_proc(struct request_queue * );
typedef void make_request_fn(struct request_queue * , struct bio * );
typedef int prep_rq_fn(struct request_queue * , struct request * );
typedef void unprep_rq_fn(struct request_queue * , struct request * );
struct bvec_merge_data {
   struct block_device *bi_bdev ;
   sector_t bi_sector ;
   unsigned int bi_size ;
   unsigned long bi_rw ;
};
typedef int merge_bvec_fn(struct request_queue * , struct bvec_merge_data * , struct bio_vec * );
typedef void softirq_done_fn(struct request * );
typedef int dma_drain_needed_fn(struct request * );
typedef int lld_busy_fn(struct request_queue * );
typedef int bsg_job_fn(struct bsg_job * );
enum blk_eh_timer_return {
    BLK_EH_NOT_HANDLED = 0,
    BLK_EH_HANDLED = 1,
    BLK_EH_RESET_TIMER = 2
} ;
typedef enum blk_eh_timer_return rq_timed_out_fn(struct request * );
struct blk_queue_tag {
   struct request **tag_index ;
   unsigned long *tag_map ;
   int busy ;
    klee_make_symbolic(&busy, sizeof(int), "busy");
   int max_depth ;
    klee_make_symbolic(&max_depth, sizeof(int), "max_depth");
   int real_max_depth ;
    klee_make_symbolic(&real_max_depth, sizeof(int), "real_max_depth");
   atomic_t refcnt ;
   int alloc_policy ;
    klee_make_symbolic(&alloc_policy, sizeof(int), "alloc_policy");
   int next_tag ;
    klee_make_symbolic(&next_tag, sizeof(int), "next_tag");
};
struct queue_limits {
   unsigned long bounce_pfn ;
    klee_make_symbolic(&bounce_pfn, sizeof(long), "bounce_pfn");
   unsigned long seg_boundary_mask ;
    klee_make_symbolic(&seg_boundary_mask, sizeof(long), "seg_boundary_mask");
   unsigned int max_hw_sectors ;
    klee_make_symbolic(&max_hw_sectors, sizeof(int), "max_hw_sectors");
   unsigned int chunk_sectors ;
    klee_make_symbolic(&chunk_sectors, sizeof(int), "chunk_sectors");
   unsigned int max_sectors ;
    klee_make_symbolic(&max_sectors, sizeof(int), "max_sectors");
   unsigned int max_segment_size ;
   unsigned int physical_block_size ;
    klee_make_symbolic(&physical_block_size, sizeof(int), "physical_block_size");
   unsigned int alignment_offset ;
    klee_make_symbolic(&alignment_offset, sizeof(int), "alignment_offset");
   unsigned int io_min ;
    klee_make_symbolic(&io_min, sizeof(int), "io_min");
   unsigned int io_opt ;
    klee_make_symbolic(&io_opt, sizeof(int), "io_opt");
   unsigned int max_discard_sectors ;
    klee_make_symbolic(&max_discard_sectors, sizeof(int), "max_discard_sectors");
   unsigned int max_write_same_sectors ;
    klee_make_symbolic(&max_write_same_sectors, sizeof(int), "max_write_same_sectors");
   unsigned int discard_granularity ;
    klee_make_symbolic(&discard_granularity, sizeof(int), "discard_granularity");
   unsigned int discard_alignment ;
   unsigned short logical_block_size ;
    klee_make_symbolic(&logical_block_size, sizeof(short), "logical_block_size");
   unsigned short max_segments ;
    klee_make_symbolic(&max_segments, sizeof(short), "max_segments");
   unsigned short max_integrity_segments ;
    klee_make_symbolic(&max_integrity_segments, sizeof(short), "max_integrity_segments");
   unsigned char misaligned ;
    klee_make_symbolic(&misaligned, sizeof(char), "misaligned");
   unsigned char discard_misaligned ;
    klee_make_symbolic(&discard_misaligned, sizeof(char), "discard_misaligned");
   unsigned char cluster ;
    klee_make_symbolic(&cluster, sizeof(char), "cluster");
   unsigned char discard_zeroes_data ;
    klee_make_symbolic(&discard_zeroes_data, sizeof(char), "discard_zeroes_data");
   unsigned char raid_partial_stripes_expensive ;
    klee_make_symbolic(&raid_partial_stripes_expensive, sizeof(char), "raid_partial_stripes_expensive");
};
struct blk_mq_ops;
struct blk_mq_hw_ctx;
struct throtl_data;
struct blk_mq_tag_set;
struct request_queue {
   struct list_head queue_head ;
   struct request *last_merge ;
   struct elevator_queue *elevator ;
   int nr_rqs[2U] ;
   int nr_rqs_elvpriv ;
    klee_make_symbolic(&nr_rqs_elvpriv, sizeof(int), "nr_rqs_elvpriv");
   struct request_list root_rl ;
   request_fn_proc *request_fn ;
   make_request_fn *make_request_fn ;
   prep_rq_fn *prep_rq_fn ;
   unprep_rq_fn *unprep_rq_fn ;
   merge_bvec_fn *merge_bvec_fn ;
   softirq_done_fn *softirq_done_fn ;
   rq_timed_out_fn *rq_timed_out_fn ;
   dma_drain_needed_fn *dma_drain_needed ;
   lld_busy_fn *lld_busy_fn ;
   struct blk_mq_ops *mq_ops ;
   unsigned int *mq_map ;
   struct blk_mq_ctx *queue_ctx ;
   unsigned int nr_queues ;
    klee_make_symbolic(&nr_queues, sizeof(int), "nr_queues");
   struct blk_mq_hw_ctx **queue_hw_ctx ;
   unsigned int nr_hw_queues ;
    klee_make_symbolic(&nr_hw_queues, sizeof(int), "nr_hw_queues");
   sector_t end_sector ;
   struct request *boundary_rq ;
   struct delayed_work delay_work ;
   struct backing_dev_info backing_dev_info ;
   void *queuedata ;
   unsigned long queue_flags ;
    klee_make_symbolic(&queue_flags, sizeof(long), "queue_flags");
   int id ;
   gfp_t bounce_gfp ;
   spinlock_t __queue_lock ;
   spinlock_t *queue_lock ;
   struct kobject kobj ;
   struct kobject mq_kobj ;
   struct device *dev ;
   int rpm_status ;
    klee_make_symbolic(&rpm_status, sizeof(int), "rpm_status");
   unsigned int nr_pending ;
    klee_make_symbolic(&nr_pending, sizeof(int), "nr_pending");
   unsigned long nr_requests ;
    klee_make_symbolic(&nr_requests, sizeof(long), "nr_requests");
   unsigned int nr_congestion_on ;
    klee_make_symbolic(&nr_congestion_on, sizeof(int), "nr_congestion_on");
   unsigned int nr_congestion_off ;
    klee_make_symbolic(&nr_congestion_off, sizeof(int), "nr_congestion_off");
   unsigned int nr_batching ;
    klee_make_symbolic(&nr_batching, sizeof(int), "nr_batching");
   unsigned int dma_drain_size ;
    klee_make_symbolic(&dma_drain_size, sizeof(int), "dma_drain_size");
   void *dma_drain_buffer ;
   unsigned int dma_pad_mask ;
    klee_make_symbolic(&dma_pad_mask, sizeof(int), "dma_pad_mask");
   unsigned int dma_alignment ;
    klee_make_symbolic(&dma_alignment, sizeof(int), "dma_alignment");
   struct blk_queue_tag *queue_tags ;
   struct list_head tag_busy_list ;
   unsigned int nr_sorted ;
    klee_make_symbolic(&nr_sorted, sizeof(int), "nr_sorted");
   unsigned int in_flight[2U] ;
   unsigned int request_fn_active ;
    klee_make_symbolic(&request_fn_active, sizeof(int), "request_fn_active");
   unsigned int rq_timeout ;
    klee_make_symbolic(&rq_timeout, sizeof(int), "rq_timeout");
   struct timer_list timeout ;
   struct list_head timeout_list ;
   struct list_head icq_list ;
   unsigned long blkcg_pols[1U] ;
   struct blkcg_gq *root_blkg ;
   struct list_head blkg_list ;
   struct queue_limits limits ;
   unsigned int sg_timeout ;
    klee_make_symbolic(&sg_timeout, sizeof(int), "sg_timeout");
   unsigned int sg_reserved_size ;
    klee_make_symbolic(&sg_reserved_size, sizeof(int), "sg_reserved_size");
   int node ;
    klee_make_symbolic(&node, sizeof(int), "node");
   unsigned int flush_flags ;
    klee_make_symbolic(&flush_flags, sizeof(int), "flush_flags");
   unsigned char flush_not_queueable : 1 ;
   struct blk_flush_queue *fq ;
   struct list_head requeue_list ;
   spinlock_t requeue_lock ;
   struct work_struct requeue_work ;
   struct mutex sysfs_lock ;
   int bypass_depth ;
    klee_make_symbolic(&bypass_depth, sizeof(int), "bypass_depth");
   atomic_t mq_freeze_depth ;
   bsg_job_fn *bsg_job_fn ;
   int bsg_job_size ;
    klee_make_symbolic(&bsg_job_size, sizeof(int), "bsg_job_size");
   struct bsg_class_device bsg_dev ;
   struct throtl_data *td ;
   struct callback_head callback_head ;
   wait_queue_head_t mq_freeze_wq ;
   struct percpu_ref mq_usage_counter ;
   struct list_head all_q_node ;
   struct blk_mq_tag_set *tag_set ;
   struct list_head tag_set_list ;
};
struct blk_plug {
   struct list_head list ;
   struct list_head mq_list ;
   struct list_head cb_list ;
};
struct blk_integrity_iter {
   void *prot_buf ;
   void *data_buf ;
   sector_t seed ;
   unsigned int data_size ;
    klee_make_symbolic(&data_size, sizeof(int), "data_size");
   unsigned short interval ;
    klee_make_symbolic(&interval, sizeof(short), "interval");
   char const   *disk_name ;
};
typedef int integrity_processing_fn(struct blk_integrity_iter * );
struct blk_integrity {
   integrity_processing_fn *generate_fn ;
   integrity_processing_fn *verify_fn ;
   unsigned short flags ;
   unsigned short tuple_size ;
    klee_make_symbolic(&tuple_size, sizeof(short), "tuple_size");
   unsigned short interval ;
   unsigned short tag_size ;
    klee_make_symbolic(&tag_size, sizeof(short), "tag_size");
   char const   *name ;
   struct kobject kobj ;
};
struct block_device_operations {
   int (*open)(struct block_device * , fmode_t  ) ;
   void (*release)(struct gendisk * , fmode_t  ) ;
   int (*rw_page)(struct block_device * , sector_t  , struct page * , int  ) ;
   int (*ioctl)(struct block_device * , fmode_t  , unsigned int  , unsigned long  ) ;
   int (*compat_ioctl)(struct block_device * , fmode_t  , unsigned int  , unsigned long  ) ;
   long (*direct_access)(struct block_device * , sector_t  , void ** , unsigned long * ,
                         long  ) ;
   unsigned int (*check_events)(struct gendisk * , unsigned int  ) ;
   int (*media_changed)(struct gendisk * ) ;
   void (*unlock_native_capacity)(struct gendisk * ) ;
   int (*revalidate_disk)(struct gendisk * ) ;
   int (*getgeo)(struct block_device * , struct hd_geometry * ) ;
   void (*swap_slot_free_notify)(struct block_device * , unsigned long  ) ;
   struct module *owner ;
};
struct blk_mq_tags;
struct blk_mq_cpu_notifier {
   struct list_head list ;
   void *data ;
   int (*notify)(void * , unsigned long  , unsigned int  ) ;
};
struct blk_align_bitmap;
struct blk_mq_ctxmap {
   unsigned int size ;
   unsigned int bits_per_word ;
    klee_make_symbolic(&bits_per_word, sizeof(int), "bits_per_word");
   struct blk_align_bitmap *map ;
};
struct __anonstruct____missing_field_name_263 {
   spinlock_t lock ;
   struct list_head dispatch ;
};
struct blk_mq_hw_ctx {
   struct __anonstruct____missing_field_name_263 __annonCompField84 ;
   unsigned long state ;
   struct delayed_work run_work ;
   struct delayed_work delay_work ;
   cpumask_var_t cpumask ;
   int next_cpu ;
    klee_make_symbolic(&next_cpu, sizeof(int), "next_cpu");
   int next_cpu_batch ;
    klee_make_symbolic(&next_cpu_batch, sizeof(int), "next_cpu_batch");
   unsigned long flags ;
   struct request_queue *queue ;
   struct blk_flush_queue *fq ;
   void *driver_data ;
   struct blk_mq_ctxmap ctx_map ;
   unsigned int nr_ctx ;
    klee_make_symbolic(&nr_ctx, sizeof(int), "nr_ctx");
   struct blk_mq_ctx **ctxs ;
   atomic_t wait_index ;
   struct blk_mq_tags *tags ;
   unsigned long queued ;
    klee_make_symbolic(&queued, sizeof(long), "queued");
   unsigned long run ;
    klee_make_symbolic(&run, sizeof(long), "run");
   unsigned long dispatched[10U] ;
   unsigned int numa_node ;
   unsigned int queue_num ;
    klee_make_symbolic(&queue_num, sizeof(int), "queue_num");
   atomic_t nr_active ;
   struct blk_mq_cpu_notifier cpu_notifier ;
   struct kobject kobj ;
};
struct blk_mq_tag_set {
   struct blk_mq_ops *ops ;
   unsigned int nr_hw_queues ;
   unsigned int queue_depth ;
    klee_make_symbolic(&queue_depth, sizeof(int), "queue_depth");
   unsigned int reserved_tags ;
    klee_make_symbolic(&reserved_tags, sizeof(int), "reserved_tags");
   unsigned int cmd_size ;
    klee_make_symbolic(&cmd_size, sizeof(int), "cmd_size");
   int numa_node ;
   unsigned int timeout ;
   unsigned int flags ;
   void *driver_data ;
   struct blk_mq_tags **tags ;
   struct mutex tag_list_lock ;
   struct list_head tag_list ;
};
struct blk_mq_queue_data {
   struct request *rq ;
   struct list_head *list ;
   bool last ;
};
typedef int queue_rq_fn(struct blk_mq_hw_ctx * , struct blk_mq_queue_data  const  * );
typedef struct blk_mq_hw_ctx *map_queue_fn(struct request_queue * , int const    );
typedef enum blk_eh_timer_return timeout_fn(struct request * , bool  );
typedef int init_hctx_fn(struct blk_mq_hw_ctx * , void * , unsigned int  );
typedef void exit_hctx_fn(struct blk_mq_hw_ctx * , unsigned int  );
typedef int init_request_fn(void * , struct request * , unsigned int  , unsigned int  ,
                            unsigned int  );
typedef void exit_request_fn(void * , struct request * , unsigned int  , unsigned int  );
struct blk_mq_ops {
   queue_rq_fn *queue_rq ;
   map_queue_fn *map_queue ;
   timeout_fn *timeout ;
   softirq_done_fn *complete ;
   init_hctx_fn *init_hctx ;
   exit_hctx_fn *exit_hctx ;
   init_request_fn *init_request ;
   exit_request_fn *exit_request ;
};
struct scsi_host_cmd_pool;
struct scsi_transport_template;
struct scsi_host_template {
   struct module *module ;
   char const   *name ;
   int (*detect)(struct scsi_host_template * ) ;
   int (*release)(struct Scsi_Host * ) ;
   char const   *(*info)(struct Scsi_Host * ) ;
   int (*ioctl)(struct scsi_device * , int  , void * ) ;
   int (*compat_ioctl)(struct scsi_device * , int  , void * ) ;
   int (*queuecommand)(struct Scsi_Host * , struct scsi_cmnd * ) ;
   int (*eh_abort_handler)(struct scsi_cmnd * ) ;
   int (*eh_device_reset_handler)(struct scsi_cmnd * ) ;
   int (*eh_target_reset_handler)(struct scsi_cmnd * ) ;
   int (*eh_bus_reset_handler)(struct scsi_cmnd * ) ;
   int (*eh_host_reset_handler)(struct scsi_cmnd * ) ;
   int (*slave_alloc)(struct scsi_device * ) ;
   int (*slave_configure)(struct scsi_device * ) ;
   void (*slave_destroy)(struct scsi_device * ) ;
   int (*target_alloc)(struct scsi_target * ) ;
   void (*target_destroy)(struct scsi_target * ) ;
   int (*scan_finished)(struct Scsi_Host * , unsigned long  ) ;
   void (*scan_start)(struct Scsi_Host * ) ;
   int (*change_queue_depth)(struct scsi_device * , int  ) ;
   int (*bios_param)(struct scsi_device * , struct block_device * , sector_t  , int * ) ;
   void (*unlock_native_capacity)(struct scsi_device * ) ;
   int (*show_info)(struct seq_file * , struct Scsi_Host * ) ;
   int (*write_info)(struct Scsi_Host * , char * , int  ) ;
   enum blk_eh_timer_return (*eh_timed_out)(struct scsi_cmnd * ) ;
   int (*host_reset)(struct Scsi_Host * , int  ) ;
   char const   *proc_name ;
   struct proc_dir_entry *proc_dir ;
   int can_queue ;
    klee_make_symbolic(&can_queue, sizeof(int), "can_queue");
   int this_id ;
    klee_make_symbolic(&this_id, sizeof(int), "this_id");
   unsigned short sg_tablesize ;
    klee_make_symbolic(&sg_tablesize, sizeof(short), "sg_tablesize");
   unsigned short sg_prot_tablesize ;
    klee_make_symbolic(&sg_prot_tablesize, sizeof(short), "sg_prot_tablesize");
   unsigned int max_sectors ;
   unsigned long dma_boundary ;
    klee_make_symbolic(&dma_boundary, sizeof(long), "dma_boundary");
   short cmd_per_lun ;
    klee_make_symbolic(&cmd_per_lun, sizeof(short), "cmd_per_lun");
   unsigned char present ;
    klee_make_symbolic(&present, sizeof(char), "present");
   int tag_alloc_policy ;
    klee_make_symbolic(&tag_alloc_policy, sizeof(int), "tag_alloc_policy");
   unsigned char use_blk_tags : 1 ;
   unsigned char track_queue_depth : 1 ;
   unsigned char supported_mode : 2 ;
   unsigned char unchecked_isa_dma : 1 ;
   unsigned char use_clustering : 1 ;
   unsigned char emulated : 1 ;
   unsigned char skip_settle_delay : 1 ;
   unsigned char no_write_same : 1 ;
   unsigned char no_async_abort : 1 ;
   unsigned int max_host_blocked ;
    klee_make_symbolic(&max_host_blocked, sizeof(int), "max_host_blocked");
   struct device_attribute **shost_attrs ;
   struct device_attribute **sdev_attrs ;
   struct list_head legacy_hosts ;
   u64 vendor_id ;
   unsigned int cmd_size ;
   struct scsi_host_cmd_pool *cmd_pool ;
   bool disable_blk_mq ;
};
enum scsi_host_state {
    SHOST_CREATED = 1,
    SHOST_RUNNING = 2,
    SHOST_CANCEL = 3,
    SHOST_DEL = 4,
    SHOST_RECOVERY = 5,
    SHOST_CANCEL_RECOVERY = 6,
    SHOST_DEL_RECOVERY = 7
} ;
union __anonunion____missing_field_name_264 {
   struct blk_queue_tag *bqt ;
   struct blk_mq_tag_set tag_set ;
};
struct Scsi_Host {
   struct list_head __devices ;
   struct list_head __targets ;
   struct scsi_host_cmd_pool *cmd_pool ;
   spinlock_t free_list_lock ;
   struct list_head free_list ;
   struct list_head starved_list ;
   spinlock_t default_lock ;
   spinlock_t *host_lock ;
   struct mutex scan_mutex ;
   struct list_head eh_cmd_q ;
   struct task_struct *ehandler ;
   struct completion *eh_action ;
   wait_queue_head_t host_wait ;
   struct scsi_host_template *hostt ;
   struct scsi_transport_template *transportt ;
   union __anonunion____missing_field_name_264 __annonCompField85 ;
   atomic_t host_busy ;
   atomic_t host_blocked ;
   unsigned int host_failed ;
    klee_make_symbolic(&host_failed, sizeof(int), "host_failed");
   unsigned int host_eh_scheduled ;
    klee_make_symbolic(&host_eh_scheduled, sizeof(int), "host_eh_scheduled");
   unsigned int host_no ;
    klee_make_symbolic(&host_no, sizeof(int), "host_no");
   int eh_deadline ;
    klee_make_symbolic(&eh_deadline, sizeof(int), "eh_deadline");
   unsigned long last_reset ;
    klee_make_symbolic(&last_reset, sizeof(long), "last_reset");
   unsigned int max_channel ;
    klee_make_symbolic(&max_channel, sizeof(int), "max_channel");
   unsigned int max_id ;
    klee_make_symbolic(&max_id, sizeof(int), "max_id");
   u64 max_lun ;
   unsigned int unique_id ;
    klee_make_symbolic(&unique_id, sizeof(int), "unique_id");
   unsigned short max_cmd_len ;
    klee_make_symbolic(&max_cmd_len, sizeof(short), "max_cmd_len");
   int this_id ;
   int can_queue ;
   short cmd_per_lun ;
   unsigned short sg_tablesize ;
   unsigned short sg_prot_tablesize ;
   unsigned int max_sectors ;
   unsigned long dma_boundary ;
   unsigned int nr_hw_queues ;
   unsigned long cmd_serial_number ;
    klee_make_symbolic(&cmd_serial_number, sizeof(long), "cmd_serial_number");
   unsigned char active_mode : 2 ;
   unsigned char unchecked_isa_dma : 1 ;
   unsigned char use_clustering : 1 ;
   unsigned char host_self_blocked : 1 ;
   unsigned char reverse_ordering : 1 ;
   unsigned char tmf_in_progress : 1 ;
   unsigned char async_scan : 1 ;
   unsigned char eh_noresume : 1 ;
   unsigned char no_write_same : 1 ;
   unsigned char use_blk_mq : 1 ;
   unsigned char use_cmd_list : 1 ;
   char work_q_name[20U] ;
   struct workqueue_struct *work_q ;
   struct workqueue_struct *tmf_work_q ;
   unsigned char no_scsi2_lun_in_cdb : 1 ;
   unsigned int max_host_blocked ;
   unsigned int prot_capabilities ;
    klee_make_symbolic(&prot_capabilities, sizeof(int), "prot_capabilities");
   unsigned char prot_guard_type ;
    klee_make_symbolic(&prot_guard_type, sizeof(char), "prot_guard_type");
   struct request_queue *uspace_req_q ;
   unsigned long base ;
    klee_make_symbolic(&base, sizeof(long), "base");
   unsigned long io_port ;
    klee_make_symbolic(&io_port, sizeof(long), "io_port");
   unsigned char n_io_port ;
    klee_make_symbolic(&n_io_port, sizeof(char), "n_io_port");
   unsigned char dma_channel ;
    klee_make_symbolic(&dma_channel, sizeof(char), "dma_channel");
   unsigned int irq ;
   enum scsi_host_state shost_state ;
   struct device shost_gendev ;
   struct device shost_dev ;
   struct list_head sht_legacy_list ;
   void *shost_data ;
   struct device *dma_dev ;
   unsigned long hostdata[0U] ;
};
enum scsi_device_state {
    SDEV_CREATED = 1,
    SDEV_RUNNING = 2,
    SDEV_CANCEL = 3,
    SDEV_DEL = 4,
    SDEV_QUIESCE = 5,
    SDEV_OFFLINE = 6,
    SDEV_TRANSPORT_OFFLINE = 7,
    SDEV_BLOCK = 8,
    SDEV_CREATED_BLOCK = 9
} ;
struct scsi_dh_data;
struct scsi_device {
   struct Scsi_Host *host ;
   struct request_queue *request_queue ;
   struct list_head siblings ;
   struct list_head same_target_siblings ;
   atomic_t device_busy ;
   atomic_t device_blocked ;
   spinlock_t list_lock ;
   struct list_head cmd_list ;
   struct list_head starved_entry ;
   struct scsi_cmnd *current_cmnd ;
   unsigned short queue_depth ;
   unsigned short max_queue_depth ;
    klee_make_symbolic(&max_queue_depth, sizeof(short), "max_queue_depth");
   unsigned short last_queue_full_depth ;
    klee_make_symbolic(&last_queue_full_depth, sizeof(short), "last_queue_full_depth");
   unsigned short last_queue_full_count ;
    klee_make_symbolic(&last_queue_full_count, sizeof(short), "last_queue_full_count");
   unsigned long last_queue_full_time ;
    klee_make_symbolic(&last_queue_full_time, sizeof(long), "last_queue_full_time");
   unsigned long queue_ramp_up_period ;
    klee_make_symbolic(&queue_ramp_up_period, sizeof(long), "queue_ramp_up_period");
   unsigned long last_queue_ramp_up ;
    klee_make_symbolic(&last_queue_ramp_up, sizeof(long), "last_queue_ramp_up");
   unsigned int id ;
   unsigned int channel ;
    klee_make_symbolic(&channel, sizeof(int), "channel");
   u64 lun ;
   unsigned int manufacturer ;
    klee_make_symbolic(&manufacturer, sizeof(int), "manufacturer");
   unsigned int sector_size ;
    klee_make_symbolic(&sector_size, sizeof(int), "sector_size");
   void *hostdata ;
   char type ;
    klee_make_symbolic(&type, sizeof(char), "type");
   char scsi_level ;
    klee_make_symbolic(&scsi_level, sizeof(char), "scsi_level");
   char inq_periph_qual ;
    klee_make_symbolic(&inq_periph_qual, sizeof(char), "inq_periph_qual");
   unsigned char inquiry_len ;
    klee_make_symbolic(&inquiry_len, sizeof(char), "inquiry_len");
   unsigned char *inquiry ;
   char const   *vendor ;
   char const   *model ;
   char const   *rev ;
   int vpd_pg83_len ;
    klee_make_symbolic(&vpd_pg83_len, sizeof(int), "vpd_pg83_len");
   unsigned char *vpd_pg83 ;
   int vpd_pg80_len ;
    klee_make_symbolic(&vpd_pg80_len, sizeof(int), "vpd_pg80_len");
   unsigned char *vpd_pg80 ;
   unsigned char current_tag ;
    klee_make_symbolic(&current_tag, sizeof(char), "current_tag");
   struct scsi_target *sdev_target ;
   unsigned int sdev_bflags ;
    klee_make_symbolic(&sdev_bflags, sizeof(int), "sdev_bflags");
   unsigned int eh_timeout ;
    klee_make_symbolic(&eh_timeout, sizeof(int), "eh_timeout");
   unsigned char removable : 1 ;
   unsigned char changed : 1 ;
   unsigned char busy : 1 ;
   unsigned char lockable : 1 ;
   unsigned char locked : 1 ;
   unsigned char borken : 1 ;
   unsigned char disconnect : 1 ;
   unsigned char soft_reset : 1 ;
   unsigned char sdtr : 1 ;
   unsigned char wdtr : 1 ;
   unsigned char ppr : 1 ;
   unsigned char tagged_supported : 1 ;
   unsigned char simple_tags : 1 ;
   unsigned char was_reset : 1 ;
   unsigned char expecting_cc_ua : 1 ;
   unsigned char use_10_for_rw : 1 ;
   unsigned char use_10_for_ms : 1 ;
   unsigned char no_report_opcodes : 1 ;
   unsigned char no_write_same : 1 ;
   unsigned char use_16_for_rw : 1 ;
   unsigned char skip_ms_page_8 : 1 ;
   unsigned char skip_ms_page_3f : 1 ;
   unsigned char skip_vpd_pages : 1 ;
   unsigned char try_vpd_pages : 1 ;
   unsigned char use_192_bytes_for_3f : 1 ;
   unsigned char no_start_on_add : 1 ;
   unsigned char allow_restart : 1 ;
   unsigned char manage_start_stop : 1 ;
   unsigned char start_stop_pwr_cond : 1 ;
   unsigned char no_uld_attach : 1 ;
   unsigned char select_no_atn : 1 ;
   unsigned char fix_capacity : 1 ;
   unsigned char guess_capacity : 1 ;
   unsigned char retry_hwerror : 1 ;
   unsigned char last_sector_bug : 1 ;
   unsigned char no_read_disc_info : 1 ;
   unsigned char no_read_capacity_16 : 1 ;
   unsigned char try_rc_10_first : 1 ;
   unsigned char is_visible : 1 ;
   unsigned char wce_default_on : 1 ;
   unsigned char no_dif : 1 ;
   unsigned char broken_fua : 1 ;
   unsigned char lun_in_cdb : 1 ;
   atomic_t disk_events_disable_depth ;
   unsigned long supported_events[1U] ;
   unsigned long pending_events[1U] ;
   struct list_head event_list ;
   struct work_struct event_work ;
   unsigned int max_device_blocked ;
    klee_make_symbolic(&max_device_blocked, sizeof(int), "max_device_blocked");
   atomic_t iorequest_cnt ;
   atomic_t iodone_cnt ;
   atomic_t ioerr_cnt ;
   struct device sdev_gendev ;
   struct device sdev_dev ;
   struct execute_work ew ;
   struct work_struct requeue_work ;
   struct scsi_dh_data *scsi_dh_data ;
   enum scsi_device_state sdev_state ;
   unsigned long sdev_data[0U] ;
};
struct scsi_device_handler {
   struct list_head list ;
   struct module *module ;
   char const   *name ;
   int (*check_sense)(struct scsi_device * , struct scsi_sense_hdr * ) ;
   struct scsi_dh_data *(*attach)(struct scsi_device * ) ;
   void (*detach)(struct scsi_device * ) ;
   int (*activate)(struct scsi_device * , void (*)(void * , int  ) , void * ) ;
   int (*prep_fn)(struct scsi_device * , struct request * ) ;
   int (*set_params)(struct scsi_device * , char const   * ) ;
   bool (*match)(struct scsi_device * ) ;
};
struct scsi_dh_data {
   struct scsi_device_handler *scsi_dh ;
   struct scsi_device *sdev ;
   struct kref kref ;
};
enum scsi_target_state {
    STARGET_CREATED = 1,
    STARGET_RUNNING = 2,
    STARGET_DEL = 3
} ;
struct scsi_target {
   struct scsi_device *starget_sdev_user ;
   struct list_head siblings ;
   struct list_head devices ;
   struct device dev ;
   struct kref reap_ref ;
   unsigned int channel ;
   unsigned int id ;
   unsigned char create : 1 ;
   unsigned char single_lun : 1 ;
   unsigned char pdt_1f_for_no_lun : 1 ;
   unsigned char no_report_luns : 1 ;
   unsigned char expecting_lun_change : 1 ;
   atomic_t target_busy ;
   atomic_t target_blocked ;
   unsigned int can_queue ;
   unsigned int max_target_blocked ;
    klee_make_symbolic(&max_target_blocked, sizeof(int), "max_target_blocked");
   char scsi_level ;
   enum scsi_target_state state ;
   void *hostdata ;
   unsigned long starget_data[0U] ;
};
struct scsi_data_buffer {
   struct sg_table table ;
   unsigned int length ;
   int resid ;
    klee_make_symbolic(&resid, sizeof(int), "resid");
};
struct scsi_pointer {
   char *ptr ;
   int this_residual ;
    klee_make_symbolic(&this_residual, sizeof(int), "this_residual");
   struct scatterlist *buffer ;
   int buffers_residual ;
    klee_make_symbolic(&buffers_residual, sizeof(int), "buffers_residual");
   dma_addr_t dma_handle ;
   int volatile   Status ;
   int volatile   Message ;
   int volatile   have_data_in ;
   int volatile   sent_command ;
   int volatile   phase ;
};
struct scsi_cmnd {
   struct scsi_device *device ;
   struct list_head list ;
   struct list_head eh_entry ;
   struct delayed_work abort_work ;
   int eh_eflags ;
    klee_make_symbolic(&eh_eflags, sizeof(int), "eh_eflags");
   unsigned long serial_number ;
    klee_make_symbolic(&serial_number, sizeof(long), "serial_number");
   unsigned long jiffies_at_alloc ;
    klee_make_symbolic(&jiffies_at_alloc, sizeof(long), "jiffies_at_alloc");
   int retries ;
   int allowed ;
    klee_make_symbolic(&allowed, sizeof(int), "allowed");
   unsigned char prot_op ;
    klee_make_symbolic(&prot_op, sizeof(char), "prot_op");
   unsigned char prot_type ;
    klee_make_symbolic(&prot_type, sizeof(char), "prot_type");
   unsigned char prot_flags ;
    klee_make_symbolic(&prot_flags, sizeof(char), "prot_flags");
   unsigned short cmd_len ;
   enum dma_data_direction sc_data_direction ;
   unsigned char *cmnd ;
   struct scsi_data_buffer sdb ;
   struct scsi_data_buffer *prot_sdb ;
   unsigned int underflow ;
    klee_make_symbolic(&underflow, sizeof(int), "underflow");
   unsigned int transfersize ;
    klee_make_symbolic(&transfersize, sizeof(int), "transfersize");
   struct request *request ;
   unsigned char *sense_buffer ;
   void (*scsi_done)(struct scsi_cmnd * ) ;
   struct scsi_pointer SCp ;
   unsigned char *host_scribble ;
   int result ;
    klee_make_symbolic(&result, sizeof(int), "result");
   int flags ;
   unsigned char tag ;
};
struct iovec {
   void *iov_base ;
   __kernel_size_t iov_len ;
};
struct kvec {
   void *iov_base ;
   size_t iov_len ;
};
union __anonunion____missing_field_name_267 {
   struct iovec  const  *iov ;
   struct kvec  const  *kvec ;
   struct bio_vec  const  *bvec ;
};
struct iov_iter {
   int type ;
   size_t iov_offset ;
   size_t count ;
   union __anonunion____missing_field_name_267 __annonCompField86 ;
   unsigned long nr_segs ;
    klee_make_symbolic(&nr_segs, sizeof(long), "nr_segs");
};
struct pipe_buf_operations;
struct pipe_buffer {
   struct page *page ;
   unsigned int offset ;
   unsigned int len ;
   struct pipe_buf_operations  const  *ops ;
   unsigned int flags ;
   unsigned long private ;
};
struct pipe_inode_info {
   struct mutex mutex ;
   wait_queue_head_t wait ;
   unsigned int nrbufs ;
    klee_make_symbolic(&nrbufs, sizeof(int), "nrbufs");
   unsigned int curbuf ;
    klee_make_symbolic(&curbuf, sizeof(int), "curbuf");
   unsigned int buffers ;
    klee_make_symbolic(&buffers, sizeof(int), "buffers");
   unsigned int readers ;
    klee_make_symbolic(&readers, sizeof(int), "readers");
   unsigned int writers ;
    klee_make_symbolic(&writers, sizeof(int), "writers");
   unsigned int files ;
    klee_make_symbolic(&files, sizeof(int), "files");
   unsigned int waiting_writers ;
    klee_make_symbolic(&waiting_writers, sizeof(int), "waiting_writers");
   unsigned int r_counter ;
    klee_make_symbolic(&r_counter, sizeof(int), "r_counter");
   unsigned int w_counter ;
    klee_make_symbolic(&w_counter, sizeof(int), "w_counter");
   struct page *tmp_page ;
   struct fasync_struct *fasync_readers ;
   struct fasync_struct *fasync_writers ;
   struct pipe_buffer *bufs ;
};
struct pipe_buf_operations {
   int can_merge ;
    klee_make_symbolic(&can_merge, sizeof(int), "can_merge");
   int (*confirm)(struct pipe_inode_info * , struct pipe_buffer * ) ;
   void (*release)(struct pipe_inode_info * , struct pipe_buffer * ) ;
   int (*steal)(struct pipe_inode_info * , struct pipe_buffer * ) ;
   void (*get)(struct pipe_inode_info * , struct pipe_buffer * ) ;
};
struct mnt_namespace;
struct ipc_namespace;
struct nsproxy {
   atomic_t count ;
   struct uts_namespace *uts_ns ;
   struct ipc_namespace *ipc_ns ;
   struct mnt_namespace *mnt_ns ;
   struct pid_namespace *pid_ns_for_children ;
   struct net *net_ns ;
};
enum fc_port_type {
    FC_PORTTYPE_UNKNOWN = 0,
    FC_PORTTYPE_OTHER = 1,
    FC_PORTTYPE_NOTPRESENT = 2,
    FC_PORTTYPE_NPORT = 3,
    FC_PORTTYPE_NLPORT = 4,
    FC_PORTTYPE_LPORT = 5,
    FC_PORTTYPE_PTP = 6,
    FC_PORTTYPE_NPIV = 7
} ;
enum fc_port_state {
    FC_PORTSTATE_UNKNOWN = 0,
    FC_PORTSTATE_NOTPRESENT = 1,
    FC_PORTSTATE_ONLINE = 2,
    FC_PORTSTATE_OFFLINE = 3,
    FC_PORTSTATE_BLOCKED = 4,
    FC_PORTSTATE_BYPASSED = 5,
    FC_PORTSTATE_DIAGNOSTICS = 6,
    FC_PORTSTATE_LINKDOWN = 7,
    FC_PORTSTATE_ERROR = 8,
    FC_PORTSTATE_LOOPBACK = 9,
    FC_PORTSTATE_DELETED = 10
} ;
enum fc_vport_state {
    FC_VPORT_UNKNOWN = 0,
    FC_VPORT_ACTIVE = 1,
    FC_VPORT_DISABLED = 2,
    FC_VPORT_LINKDOWN = 3,
    FC_VPORT_INITIALIZING = 4,
    FC_VPORT_NO_FABRIC_SUPP = 5,
    FC_VPORT_NO_FABRIC_RSCS = 6,
    FC_VPORT_FABRIC_LOGOUT = 7,
    FC_VPORT_FABRIC_REJ_WWN = 8,
    FC_VPORT_FAILED = 9
} ;
struct fc_vport_identifiers {
   u64 node_name ;
   u64 port_name ;
   u32 roles ;
   bool disable ;
   enum fc_port_type vport_type ;
   char symbolic_name[64U] ;
};
struct fc_vport {
   enum fc_vport_state vport_state ;
   enum fc_vport_state vport_last_state ;
   u64 node_name ;
   u64 port_name ;
   u32 roles ;
   u32 vport_id ;
   enum fc_port_type vport_type ;
   char symbolic_name[64U] ;
   void *dd_data ;
   struct Scsi_Host *shost ;
   unsigned int channel ;
   u32 number ;
   u8 flags ;
   struct list_head peers ;
   struct device dev ;
   struct work_struct vport_delete_work ;
};
struct fc_rport {
   u32 maxframe_size ;
   u32 supported_classes ;
   u32 dev_loss_tmo ;
   u64 node_name ;
   u64 port_name ;
   u32 port_id ;
   u32 roles ;
   enum fc_port_state port_state ;
   u32 scsi_target_id ;
   u32 fast_io_fail_tmo ;
   void *dd_data ;
   unsigned int channel ;
   u32 number ;
   u8 flags ;
   struct list_head peers ;
   struct device dev ;
   struct delayed_work dev_loss_work ;
   struct work_struct scan_work ;
   struct delayed_work fail_io_work ;
   struct work_struct stgt_delete_work ;
   struct work_struct rport_delete_work ;
   struct request_queue *rqst_q ;
};
struct fc_host_statistics {
   u64 seconds_since_last_reset ;
   u64 tx_frames ;
   u64 tx_words ;
   u64 rx_frames ;
   u64 rx_words ;
   u64 lip_count ;
   u64 nos_count ;
   u64 error_frames ;
   u64 dumped_frames ;
   u64 link_failure_count ;
   u64 loss_of_sync_count ;
   u64 loss_of_signal_count ;
   u64 prim_seq_protocol_err_count ;
   u64 invalid_tx_word_count ;
   u64 invalid_crc_count ;
   u64 fcp_input_requests ;
   u64 fcp_output_requests ;
   u64 fcp_control_requests ;
   u64 fcp_input_megabytes ;
   u64 fcp_output_megabytes ;
   u64 fcp_packet_alloc_failures ;
   u64 fcp_packet_aborts ;
   u64 fcp_frame_alloc_failures ;
   u64 fc_no_free_exch ;
   u64 fc_no_free_exch_xid ;
   u64 fc_xid_not_found ;
   u64 fc_xid_busy ;
   u64 fc_seq_not_found ;
   u64 fc_non_bls_resp ;
};
struct fc_bsg_buffer {
   unsigned int payload_len ;
    klee_make_symbolic(&payload_len, sizeof(int), "payload_len");
   int sg_cnt ;
    klee_make_symbolic(&sg_cnt, sizeof(int), "sg_cnt");
   struct scatterlist *sg_list ;
};
struct fc_bsg_request;
struct fc_bsg_reply;
struct fc_bsg_job {
   struct Scsi_Host *shost ;
   struct fc_rport *rport ;
   struct device *dev ;
   struct request *req ;
   spinlock_t job_lock ;
   unsigned int state_flags ;
    klee_make_symbolic(&state_flags, sizeof(int), "state_flags");
   unsigned int ref_cnt ;
    klee_make_symbolic(&ref_cnt, sizeof(int), "ref_cnt");
   void (*job_done)(struct fc_bsg_job * ) ;
   struct fc_bsg_request *request ;
   struct fc_bsg_reply *reply ;
   unsigned int request_len ;
    klee_make_symbolic(&request_len, sizeof(int), "request_len");
   unsigned int reply_len ;
    klee_make_symbolic(&reply_len, sizeof(int), "reply_len");
   struct fc_bsg_buffer request_payload ;
   struct fc_bsg_buffer reply_payload ;
   void *dd_data ;
};
struct attribute_container {
   struct list_head node ;
   struct klist containers ;
   struct class *class ;
   struct attribute_group  const  *grp ;
   struct device_attribute **attrs ;
   int (*match)(struct attribute_container * , struct device * ) ;
   unsigned long flags ;
};
struct transport_container;
struct transport_container {
   struct attribute_container ac ;
   struct attribute_group  const  *statistics ;
};
struct scsi_transport_template {
   struct transport_container host_attrs ;
   struct transport_container target_attrs ;
   struct transport_container device_attrs ;
   int (*user_scan)(struct Scsi_Host * , uint  , uint  , u64  ) ;
   int device_size ;
    klee_make_symbolic(&device_size, sizeof(int), "device_size");
   int device_private_offset ;
    klee_make_symbolic(&device_private_offset, sizeof(int), "device_private_offset");
   int target_size ;
    klee_make_symbolic(&target_size, sizeof(int), "target_size");
   int target_private_offset ;
    klee_make_symbolic(&target_private_offset, sizeof(int), "target_private_offset");
   int host_size ;
    klee_make_symbolic(&host_size, sizeof(int), "host_size");
   unsigned char create_work_queue : 1 ;
   void (*eh_strategy_handler)(struct Scsi_Host * ) ;
   enum blk_eh_timer_return (*eh_timed_out)(struct scsi_cmnd * ) ;
   int (*it_nexus_response)(struct Scsi_Host * , u64  , int  ) ;
   int (*tsk_mgmt_response)(struct Scsi_Host * , u64  , u64  , int  ) ;
};
struct fc_bsg_host_add_rport {
   uint8_t reserved ;
   uint8_t port_id[3U] ;
};
struct fc_bsg_host_del_rport {
   uint8_t reserved ;
   uint8_t port_id[3U] ;
};
struct fc_bsg_host_els {
   uint8_t command_code ;
   uint8_t port_id[3U] ;
};
struct __anonstruct_rjt_data_286 {
   uint8_t action ;
   uint8_t reason_code ;
   uint8_t reason_explanation ;
   uint8_t vendor_unique ;
};
struct fc_bsg_ctels_reply {
   uint32_t status ;
   struct __anonstruct_rjt_data_286 rjt_data ;
};
struct fc_bsg_host_ct {
   uint8_t reserved ;
   uint8_t port_id[3U] ;
   uint32_t preamble_word0 ;
   uint32_t preamble_word1 ;
   uint32_t preamble_word2 ;
};
struct fc_bsg_host_vendor {
   uint64_t vendor_id ;
   uint32_t vendor_cmd[0U] ;
};
struct fc_bsg_host_vendor_reply {
   uint32_t vendor_rsp[0U] ;
};
struct fc_bsg_rport_els {
   uint8_t els_code ;
};
struct fc_bsg_rport_ct {
   uint32_t preamble_word0 ;
   uint32_t preamble_word1 ;
   uint32_t preamble_word2 ;
};
union __anonunion_rqst_data_287 {
   struct fc_bsg_host_add_rport h_addrport ;
   struct fc_bsg_host_del_rport h_delrport ;
   struct fc_bsg_host_els h_els ;
   struct fc_bsg_host_ct h_ct ;
   struct fc_bsg_host_vendor h_vendor ;
   struct fc_bsg_rport_els r_els ;
   struct fc_bsg_rport_ct r_ct ;
};
struct fc_bsg_request {
   uint32_t msgcode ;
   union __anonunion_rqst_data_287 rqst_data ;
};
union __anonunion_reply_data_288 {
   struct fc_bsg_host_vendor_reply vendor_reply ;
   struct fc_bsg_ctels_reply ctels_reply ;
};
struct fc_bsg_reply {
   uint32_t result ;
   uint32_t reply_payload_rcv_len ;
   union __anonunion_reply_data_288 reply_data ;
};
struct __anonstruct_u32_290 {
   u32 rsvd ;
   u32 u32 ;
};
union __anonunion_data_289 {
   struct __anonstruct_u32_290 u32 ;
   u64 u64 ;
};
struct bfa_trc_s {
   u16 line ;
   u16 fileno ;
   u32 timestamp ;
   union __anonunion_data_289 data ;
};
struct bfa_trc_mod_s {
   u32 head ;
   u32 tail ;
   u32 ntrc ;
   u32 stopped ;
   u32 ticks ;
   u32 rsvd[3U] ;
   struct bfa_trc_s trc[4096U] ;
};
struct bfa_wc_s {
   void (*wc_resume)(void * ) ;
   void *wc_cbarg ;
   int wc_count ;
    klee_make_symbolic(&wc_count, sizeof(int), "wc_count");
};
union __anonunion_w_292 {
   u64 wwn ;
   u8 byte[8U] ;
};
typedef u64 wwn_t;
struct mac_s {
   u8 mac[6U] ;
};
struct fchs_s {
   unsigned char cat_info : 4 ;
   unsigned char routing : 4 ;
   unsigned int d_id : 24 ;
   unsigned char cs_ctl ;
    klee_make_symbolic(&cs_ctl, sizeof(char), "cs_ctl");
   unsigned int s_id : 24 ;
   unsigned char type ;
   unsigned int f_ctl : 24 ;
   u8 seq_id ;
   u8 df_ctl ;
   u16 seq_cnt ;
   __be16 ox_id ;
   u16 rx_id ;
   u32 ro ;
};
enum fc_cos {
    FC_CLASS_2 = 4,
    FC_CLASS_3 = 8,
    FC_CLASS_2_3 = 12
} ;
struct fc_alpabm_s {
   u8 alpa_bm[16U] ;
};
enum fcp_tm_cmnd {
    FCP_TM_ABORT_TASK_SET = 2,
    FCP_TM_CLEAR_TASK_SET = 4,
    FCP_TM_LUN_RESET = 16,
    FCP_TM_TARGET_RESET = 32,
    FCP_TM_CLEAR_ACA = 64
} ;
struct bfa_mfg_vpd_s {
   u8 version ;
   u8 vpd_sig[3U] ;
   u8 chksum ;
   u8 vendor ;
   u8 len ;
   u8 rsv ;
   u8 data[512U] ;
};
enum bfa_status {
    BFA_STATUS_OK = 0,
    BFA_STATUS_FAILED = 1,
    BFA_STATUS_EINVAL = 2,
    BFA_STATUS_ENOMEM = 3,
    BFA_STATUS_ETIMER = 5,
    BFA_STATUS_EPROTOCOL = 6,
    BFA_STATUS_BADFLASH = 9,
    BFA_STATUS_SFP_UNSUPP = 10,
    BFA_STATUS_UNKNOWN_VFID = 11,
    BFA_STATUS_DATACORRUPTED = 12,
    BFA_STATUS_DEVBUSY = 13,
    BFA_STATUS_HDMA_FAILED = 16,
    BFA_STATUS_FLASH_BAD_LEN = 17,
    BFA_STATUS_UNKNOWN_LWWN = 18,
    BFA_STATUS_UNKNOWN_RWWN = 19,
    BFA_STATUS_VPORT_EXISTS = 21,
    BFA_STATUS_VPORT_MAX = 22,
    BFA_STATUS_UNSUPP_SPEED = 23,
    BFA_STATUS_INVLD_DFSZ = 24,
    BFA_STATUS_CMD_NOTSUPP = 26,
    BFA_STATUS_FABRIC_RJT = 29,
    BFA_STATUS_UNKNOWN_VWWN = 30,
    BFA_STATUS_PORT_OFFLINE = 34,
    BFA_STATUS_VPORT_WWN_BP = 46,
    BFA_STATUS_PORT_NOT_DISABLED = 47,
    BFA_STATUS_NO_FCPIM_NEXUS = 52,
    BFA_STATUS_IOC_FAILURE = 56,
    BFA_STATUS_INVALID_WWN = 57,
    BFA_STATUS_ADAPTER_ENABLED = 60,
    BFA_STATUS_IOC_NON_OP = 61,
    BFA_STATUS_VERSION_FAIL = 70,
    BFA_STATUS_DIAG_BUSY = 71,
    BFA_STATUS_BEACON_ON = 72,
    BFA_STATUS_ENOFSAVE = 78,
    BFA_STATUS_IOC_DISABLED = 82,
    BFA_STATUS_ERROR_TRL_ENABLED = 87,
    BFA_STATUS_ERROR_QOS_ENABLED = 88,
    BFA_STATUS_NO_SFP_DEV = 89,
    BFA_STATUS_MEMTEST_FAILED = 90,
    BFA_STATUS_LEDTEST_OP = 109,
    BFA_STATUS_INVALID_MAC = 134,
    BFA_STATUS_CMD_NOTSUPP_CNA = 146,
    BFA_STATUS_PBC = 154,
    BFA_STATUS_BAD_FWCFG = 156,
    BFA_STATUS_INVALID_VENDOR = 158,
    BFA_STATUS_SFP_NOT_READY = 159,
    BFA_STATUS_TRUNK_ENABLED = 164,
    BFA_STATUS_TRUNK_DISABLED = 165,
    BFA_STATUS_IOPROFILE_OFF = 175,
    BFA_STATUS_PHY_NOT_PRESENT = 183,
    BFA_STATUS_FEATURE_NOT_SUPPORTED = 192,
    BFA_STATUS_ENTRY_EXISTS = 193,
    BFA_STATUS_ENTRY_NOT_EXISTS = 194,
    BFA_STATUS_NO_CHANGE = 195,
    BFA_STATUS_FAA_ENABLED = 197,
    BFA_STATUS_FAA_DISABLED = 198,
    BFA_STATUS_FAA_ACQUIRED = 199,
    BFA_STATUS_FAA_ACQ_ADDR = 200,
    BFA_STATUS_BBCR_FC_ONLY = 201,
    BFA_STATUS_ERROR_TRUNK_ENABLED = 203,
    BFA_STATUS_MAX_ENTRY_REACHED = 212,
    BFA_STATUS_TOPOLOGY_LOOP = 230,
    BFA_STATUS_LOOP_UNSUPP_MEZZ = 231,
    BFA_STATUS_INVALID_BW = 233,
    BFA_STATUS_QOS_BW_INVALID = 234,
    BFA_STATUS_DPORT_ENABLED = 235,
    BFA_STATUS_DPORT_DISABLED = 236,
    BFA_STATUS_CMD_NOTSUPP_MEZZ = 239,
    BFA_STATUS_FRU_NOT_PRESENT = 240,
    BFA_STATUS_DPORT_NO_SFP = 243,
    BFA_STATUS_DPORT_ERR = 245,
    BFA_STATUS_DPORT_ENOSYS = 254,
    BFA_STATUS_DPORT_CANT_PERF = 255,
    BFA_STATUS_DPORT_LOGICALERR = 256,
    BFA_STATUS_DPORT_SWBUSY = 257,
    BFA_STATUS_ERR_BBCR_SPEED_UNSUPPORT = 258,
    BFA_STATUS_ERROR_BBCR_ENABLED = 259,
    BFA_STATUS_INVALID_BBSCN = 260,
    BFA_STATUS_DDPORT_ERR = 261,
    BFA_STATUS_DPORT_SFPWRAP_ERR = 262,
    BFA_STATUS_BBCR_CFG_NO_CHANGE = 265,
    BFA_STATUS_DPORT_SW_NOTREADY = 268,
    BFA_STATUS_DPORT_INV_SFP = 271,
    BFA_STATUS_DPORT_CMD_NOTSUPP = 273,
    BFA_STATUS_MAX_VAL = 274
} ;
enum bfa_eproto_status {
    BFA_EPROTO_BAD_ACCEPT = 0,
    BFA_EPROTO_UNKNOWN_RSP = 1
} ;
enum bfa_boolean {
    BFA_FALSE = 0,
    BFA_TRUE = 1
} ;
struct bfa_ioc_pci_attr_s {
   u16 vendor_id ;
   u16 device_id ;
   u16 ssid ;
   u16 ssvid ;
   u32 pcifn ;
   u32 rsvd ;
   char chip_rev[8U] ;
};
struct bfa_ioc_drv_stats_s {
   u32 ioc_isrs ;
   u32 ioc_enables ;
   u32 ioc_disables ;
   u32 ioc_hbfails ;
   u32 ioc_boots ;
   u32 stats_tmos ;
   u32 hb_count ;
   u32 disable_reqs ;
   u32 enable_reqs ;
   u32 disable_replies ;
   u32 enable_replies ;
   u32 rsvd ;
};
enum bfa_aen_category {
    BFA_AEN_CAT_ADAPTER = 1,
    BFA_AEN_CAT_PORT = 2,
    BFA_AEN_CAT_LPORT = 3,
    BFA_AEN_CAT_RPORT = 4,
    BFA_AEN_CAT_ITNIM = 5,
    BFA_AEN_CAT_AUDIT = 8,
    BFA_AEN_CAT_IOC = 9
} ;
struct bfa_adapter_aen_data_s {
   char serial_num[12U] ;
   u32 nports ;
   wwn_t pwwn ;
};
struct bfa_port_aen_data_s {
   wwn_t pwwn ;
   wwn_t fwwn ;
   u32 phy_port_num ;
   u16 ioc_type ;
   u16 level ;
   struct mac_s mac ;
   u16 rsvd ;
};
struct bfa_lport_aen_data_s {
   u16 vf_id ;
   u16 roles ;
   u32 rsvd ;
   wwn_t ppwwn ;
   wwn_t lpwwn ;
};
struct bfa_itnim_aen_data_s {
   u16 vf_id ;
   u16 rsvd[3U] ;
   wwn_t ppwwn ;
   wwn_t lpwwn ;
   wwn_t rpwwn ;
};
struct bfa_audit_aen_data_s {
   wwn_t pwwn ;
   int partition_inst ;
    klee_make_symbolic(&partition_inst, sizeof(int), "partition_inst");
   int partition_type ;
    klee_make_symbolic(&partition_type, sizeof(int), "partition_type");
};
struct bfa_ioc_aen_data_s {
   wwn_t pwwn ;
   u16 ioc_type ;
   struct mac_s mac ;
};
enum bfa_port_speed {
    BFA_PORT_SPEED_UNKNOWN = 0,
    BFA_PORT_SPEED_1GBPS = 1,
    BFA_PORT_SPEED_2GBPS = 2,
    BFA_PORT_SPEED_4GBPS = 4,
    BFA_PORT_SPEED_8GBPS = 8,
    BFA_PORT_SPEED_10GBPS = 10,
    BFA_PORT_SPEED_16GBPS = 16,
    BFA_PORT_SPEED_AUTO = 15
} ;
enum bfa_mode_s {
    BFA_MODE_HBA = 1,
    BFA_MODE_CNA = 2,
    BFA_MODE_NIC = 3
} ;
struct bfa_ablk_cfg_pf_s {
   u16 pers ;
   u8 port_id ;
   u8 optrom ;
   u8 valid ;
   u8 sriov ;
   u8 max_vfs ;
   u8 rsvd[1U] ;
   u16 num_qpairs ;
   u16 num_vectors ;
   u16 bw_min ;
   u16 bw_max ;
};
struct bfa_ablk_cfg_port_s {
   u8 mode ;
   u8 type ;
   u8 max_pfs ;
   u8 rsvd[5U] ;
};
struct bfa_ablk_cfg_inst_s {
   u8 nports ;
   u8 max_pfs ;
   u8 rsvd[6U] ;
   struct bfa_ablk_cfg_pf_s pf_cfg[16U] ;
   struct bfa_ablk_cfg_port_s port_cfg[2U] ;
};
struct bfa_ablk_cfg_s {
   struct bfa_ablk_cfg_inst_s inst[2U] ;
};
enum bfa_defs_sfp_media_e {
    BFA_SFP_MEDIA_UNKNOWN = 0,
    BFA_SFP_MEDIA_CU = 1,
    BFA_SFP_MEDIA_LW = 2,
    BFA_SFP_MEDIA_SW = 3,
    BFA_SFP_MEDIA_EL = 4,
    BFA_SFP_MEDIA_UNSUPPORT = 5
} ;
struct sfp_srlid_base_s {
   u8 id ;
   u8 extid ;
   u8 connector ;
   u8 xcvr[8U] ;
   u8 encoding ;
   u8 br_norm ;
   u8 rate_id ;
   u8 len_km ;
   u8 len_100m ;
   u8 len_om2 ;
   u8 len_om1 ;
   u8 len_cu ;
   u8 len_om3 ;
   u8 vendor_name[16U] ;
   u8 unalloc1 ;
   u8 vendor_oui[3U] ;
   u8 vendor_pn[16U] ;
   u8 vendor_rev[4U] ;
   u8 wavelen[2U] ;
   u8 unalloc2 ;
   u8 cc_base ;
};
struct sfp_srlid_ext_s {
   u8 options[2U] ;
   u8 br_max ;
   u8 br_min ;
   u8 vendor_sn[16U] ;
   u8 date_code[8U] ;
   u8 diag_mon_type ;
   u8 en_options ;
   u8 sff_8472 ;
   u8 cc_ext ;
};
struct sfp_diag_base_s {
   u8 temp_high_alarm[2U] ;
   u8 temp_low_alarm[2U] ;
   u8 temp_high_warning[2U] ;
   u8 temp_low_warning[2U] ;
   u8 volt_high_alarm[2U] ;
   u8 volt_low_alarm[2U] ;
   u8 volt_high_warning[2U] ;
   u8 volt_low_warning[2U] ;
   u8 bias_high_alarm[2U] ;
   u8 bias_low_alarm[2U] ;
   u8 bias_high_warning[2U] ;
   u8 bias_low_warning[2U] ;
   u8 tx_pwr_high_alarm[2U] ;
   u8 tx_pwr_low_alarm[2U] ;
   u8 tx_pwr_high_warning[2U] ;
   u8 tx_pwr_low_warning[2U] ;
   u8 rx_pwr_high_alarm[2U] ;
   u8 rx_pwr_low_alarm[2U] ;
   u8 rx_pwr_high_warning[2U] ;
   u8 rx_pwr_low_warning[2U] ;
   u8 unallocate_1[16U] ;
   u8 rx_pwr[20U] ;
   u8 tx_i[4U] ;
   u8 tx_pwr[4U] ;
   u8 temp[4U] ;
   u8 volt[4U] ;
   u8 unallocate_2[3U] ;
   u8 cc_dmi ;
};
struct sfp_diag_ext_s {
   u8 diag[10U] ;
   u8 unalloc1[4U] ;
   u8 status_ctl ;
   u8 rsvd ;
   u8 alarm_flags[2U] ;
   u8 unalloc2[2U] ;
   u8 warning_flags[2U] ;
   u8 ext_status_ctl[2U] ;
};
struct sfp_usr_eeprom_s {
   u8 rsvd1[2U] ;
   u8 ewrap ;
   u8 rsvd2[2U] ;
   u8 owrap ;
   u8 rsvd3[2U] ;
   u8 prbs ;
   u8 rsvd4[2U] ;
   u8 tx_eqz_16 ;
   u8 tx_eqz_8 ;
   u8 rsvd5[2U] ;
   u8 rx_emp_16 ;
   u8 rx_emp_8 ;
   u8 rsvd6[2U] ;
   u8 tx_eye_adj ;
   u8 rsvd7[3U] ;
   u8 tx_eye_qctl ;
   u8 tx_eye_qres ;
   u8 rsvd8[2U] ;
   u8 poh[3U] ;
   u8 rsvd9[2U] ;
};
struct sfp_mem_s {
   struct sfp_srlid_base_s srlid_base ;
   struct sfp_srlid_ext_s srlid_ext ;
   struct sfp_diag_base_s diag_base ;
   struct sfp_diag_ext_s diag_ext ;
   struct sfp_usr_eeprom_s usr_eeprom ;
};
struct bfa_diag_dport_subtest_result_s {
   u8 status ;
   u8 rsvd[7U] ;
   u64 start_time ;
};
struct bfa_diag_dport_result_s {
   wwn_t rp_pwwn ;
   wwn_t rp_nwwn ;
   u64 start_time ;
   u64 end_time ;
   u8 status ;
   u8 mode ;
   u8 rsvd ;
   u8 speed ;
   u16 buffer_required ;
   u16 frmsz ;
   u32 lpcnt ;
   u32 pat ;
   u32 roundtrip_latency ;
   u32 est_cable_distance ;
   struct bfa_diag_dport_subtest_result_s subtest[4U] ;
};
union __anonunion_log_entry_302 {
   char string_log[32U] ;
   u32 int_log[8U] ;
};
struct bfa_plog_rec_s {
   u64 tv ;
   u8 port ;
   u8 mid ;
   u8 eid ;
   u8 log_type ;
   u8 log_num_ints ;
   u8 rsvd ;
   u16 misc ;
   union __anonunion_log_entry_302 log_entry ;
};
enum bfa_plog_mid {
    BFA_PL_MID_INVALID = 0,
    BFA_PL_MID_DEBUG = 1,
    BFA_PL_MID_DRVR = 2,
    BFA_PL_MID_HAL = 3,
    BFA_PL_MID_HAL_FCXP = 4,
    BFA_PL_MID_HAL_UF = 5,
    BFA_PL_MID_FCS = 6,
    BFA_PL_MID_LPS = 7,
    BFA_PL_MID_MAX = 8
} ;
enum bfa_plog_eid {
    BFA_PL_EID_INVALID = 0,
    BFA_PL_EID_IOC_DISABLE = 1,
    BFA_PL_EID_IOC_ENABLE = 2,
    BFA_PL_EID_PORT_DISABLE = 3,
    BFA_PL_EID_PORT_ENABLE = 4,
    BFA_PL_EID_PORT_ST_CHANGE = 5,
    BFA_PL_EID_TX = 6,
    BFA_PL_EID_TX_ACK1 = 7,
    BFA_PL_EID_TX_RJT = 8,
    BFA_PL_EID_TX_BSY = 9,
    BFA_PL_EID_RX = 10,
    BFA_PL_EID_RX_ACK1 = 11,
    BFA_PL_EID_RX_RJT = 12,
    BFA_PL_EID_RX_BSY = 13,
    BFA_PL_EID_CT_IN = 14,
    BFA_PL_EID_CT_OUT = 15,
    BFA_PL_EID_DRIVER_START = 16,
    BFA_PL_EID_RSCN = 17,
    BFA_PL_EID_DEBUG = 18,
    BFA_PL_EID_MISC = 19,
    BFA_PL_EID_FIP_FCF_DISC = 20,
    BFA_PL_EID_FIP_FCF_CVL = 21,
    BFA_PL_EID_LOGIN = 22,
    BFA_PL_EID_LOGO = 23,
    BFA_PL_EID_TRUNK_SCN = 24,
    BFA_PL_EID_MAX = 25
} ;
struct bfa_plog_s {
   char plog_sig[8U] ;
   u8 plog_enabled ;
   u8 rsvd[7U] ;
   u32 ticks ;
   u16 head ;
   u16 tail ;
   struct bfa_plog_rec_s plog_recs[256U] ;
};
struct __anonstruct_h2i_304 {
   u8 qid ;
   u8 fn_lpu ;
};
union __anonunion_mtag_303 {
   struct __anonstruct_h2i_304 h2i ;
   u16 i2htok ;
};
struct bfi_mhdr_s {
   u8 msg_class ;
   u8 msg_id ;
   union __anonunion_mtag_303 mtag ;
};
struct __anonstruct_a32_305 {
   __be32 addr_lo ;
   __be32 addr_hi ;
};
union bfi_addr_u {
   struct __anonstruct_a32_305 a32 ;
};
struct bfi_sge_s {
   unsigned int sg_len : 28 ;
   unsigned char rsvd : 2 ;
   unsigned char flags : 2 ;
   union bfi_addr_u sga ;
};
struct bfi_alen_s {
   union bfi_addr_u al_addr ;
   u32 al_len ;
};
struct bfi_sgpg_s {
   struct bfi_sge_s sges[8U] ;
   u32 rsvd[8U] ;
};
struct bfi_msg_s {
   struct bfi_mhdr_s mhdr ;
   u32 pl[31U] ;
};
struct bfi_mbmsg_s {
   struct bfi_mhdr_s mh ;
   u32 pl[7U] ;
};
enum bfi_pcifn_class {
    BFI_PCIFN_CLASS_FC = 3076,
    BFI_PCIFN_CLASS_ETH = 512
} ;
enum bfi_asic_gen {
    BFI_ASIC_GEN_CB = 1,
    BFI_ASIC_GEN_CT = 2,
    BFI_ASIC_GEN_CT2 = 3
} ;
enum bfi_asic_mode {
    BFI_ASIC_MODE_FC = 1,
    BFI_ASIC_MODE_FC16 = 2,
    BFI_ASIC_MODE_ETH = 3,
    BFI_ASIC_MODE_COMBO = 4
} ;
struct bfi_ioc_attr_s {
   wwn_t mfg_pwwn ;
   wwn_t mfg_nwwn ;
   struct mac_s mfg_mac ;
   u8 port_mode ;
   u8 rsvd_a ;
   wwn_t pwwn ;
   wwn_t nwwn ;
   struct mac_s mac ;
   u16 rsvd_b ;
   struct mac_s fcoe_mac ;
   u16 rsvd_c ;
   char brcd_serialnum[12U] ;
   u8 pcie_gen ;
   u8 pcie_lanes_orig ;
   u8 pcie_lanes ;
   u8 rx_bbcredit ;
   u32 adapter_prop ;
   u16 maxfrsize ;
   char asic_rev ;
    klee_make_symbolic(&asic_rev, sizeof(char), "asic_rev");
   u8 rsvd_d ;
   char fw_version[64U] ;
   char optrom_version[64U] ;
   struct bfa_mfg_vpd_s vpd ;
   u32 card_type ;
   u8 mfg_day ;
   u8 mfg_month ;
   u16 mfg_year ;
   u8 uuid[16U] ;
};
enum bfi_port_mode {
    BFI_PORT_MODE_FC = 1,
    BFI_PORT_MODE_ETH = 2
} ;
enum bfi_ioc_state {
    BFI_IOC_UNINIT = 0,
    BFI_IOC_INITING = 1,
    BFI_IOC_HWINIT = 2,
    BFI_IOC_CFG = 3,
    BFI_IOC_OP = 4,
    BFI_IOC_DISABLING = 5,
    BFI_IOC_DISABLED = 6,
    BFI_IOC_CFG_DISABLED = 7,
    BFI_IOC_FAIL = 8,
    BFI_IOC_MEMTEST = 9
} ;
struct bfi_pbc_blun_s {
   wwn_t tgt_pwwn ;
   struct scsi_lun tgt_lun ;
};
struct bfi_pbc_vport_s {
   wwn_t vp_pwwn ;
   wwn_t vp_nwwn ;
};
struct bfi_pbc_s {
   u8 port_enabled ;
   u8 boot_enabled ;
   u8 nbluns ;
   u8 nvports ;
   u8 port_speed ;
   u8 rsvd_a ;
   u16 hss ;
   wwn_t pbc_pwwn ;
   wwn_t pbc_nwwn ;
   struct bfi_pbc_blun_s blun[8U] ;
   struct bfi_pbc_vport_s vport[16U] ;
};
enum bfi_sfp_mem_e {
    BFI_SFP_MEM_ALL = 1,
    BFI_SFP_MEM_DIAGEXT = 2
} ;
struct bfi_diag_dport_req_s {
   struct bfi_mhdr_s mh ;
   u8 req ;
   u8 rsvd[3U] ;
   u32 lpcnt ;
   u32 payload ;
};
struct bfi_diag_dport_rsp_s {
   struct bfi_mhdr_s mh ;
   enum bfa_status status ;
   wwn_t pwwn ;
   wwn_t nwwn ;
};
struct bfi_diag_dport_scn_teststart_s {
   wwn_t pwwn ;
   wwn_t nwwn ;
   u8 type ;
   u8 mode ;
   u8 rsvd[2U] ;
   u32 numfrm ;
};
struct bfi_diag_dport_scn_testcomp_s {
   u8 status ;
   u8 speed ;
   u16 numbuffer ;
   u8 subtest_status[4U] ;
   u32 latency ;
   u32 distance ;
   u16 frm_sz ;
   u8 rsvd[2U] ;
};
union __anonunion_info_306 {
   struct bfi_diag_dport_scn_teststart_s teststart ;
   struct bfi_diag_dport_scn_testcomp_s testcomp ;
};
struct bfi_diag_dport_scn_s {
   struct bfi_mhdr_s mh ;
   u8 state ;
   u8 rsvd[3U] ;
   union __anonunion_info_306 info ;
};
union bfi_diag_dport_msg_u {
   struct bfi_diag_dport_req_s req ;
   struct bfi_diag_dport_rsp_s rsp ;
   struct bfi_diag_dport_scn_s scn ;
};
struct bfa_iocfc_intr_attr_s {
   u8 coalesce ;
   u8 rsvd[3U] ;
   __be16 latency ;
   __be16 delay ;
};
struct bfa_iocfc_fwcfg_s {
   u16 num_fabrics ;
   u16 num_lports ;
   u16 num_rports ;
   u16 num_ioim_reqs ;
   u16 num_tskim_reqs ;
   u16 num_fwtio_reqs ;
   u16 num_fcxp_reqs ;
   u16 num_uf_bufs ;
   u8 num_cqs ;
   u8 fw_tick_res ;
   u8 rsvd[6U] ;
};
struct bfa_iocfc_drvcfg_s {
   u16 num_reqq_elems ;
   u16 num_rspq_elems ;
   u16 num_sgpgs ;
   u16 num_sboot_tgts ;
   u16 num_sboot_luns ;
   u16 ioc_recover ;
   u16 min_cfg ;
   u16 path_tov ;
   u16 num_tio_reqs ;
   u8 port_mode ;
   u8 rsvd_a ;
   enum bfa_boolean delay_comp ;
   u16 num_ttsk_reqs ;
   u32 rsvd ;
};
struct bfa_iocfc_cfg_s {
   struct bfa_iocfc_fwcfg_s fwcfg ;
   struct bfa_iocfc_drvcfg_s drvcfg ;
};
struct bfa_qos_bw_s {
   u8 qos_bw_set ;
   u8 high ;
   u8 med ;
   u8 low ;
};
struct bfa_qos_attr_s {
   u8 state ;
   u8 rsvd1[3U] ;
   u32 total_bb_cr ;
   struct bfa_qos_bw_s qos_bw ;
   struct bfa_qos_bw_s qos_bw_op ;
};
struct bfa_bbcr_attr_s {
   u8 state ;
   u8 peer_bb_scn ;
   u8 reason ;
   u8 rsvd ;
};
struct bfa_qos_vc_info_s {
   u8 vc_credit ;
   u8 borrow_credit ;
   u8 priority ;
   u8 resvd ;
};
struct bfa_qos_vc_attr_s {
   u16 total_vc_count ;
   u16 shared_credit ;
   u32 elp_opmode_flags ;
   struct bfa_qos_vc_info_s vc_info[16U] ;
};
struct bfa_qos_stats_s {
   u32 flogi_sent ;
   u32 flogi_acc_recvd ;
   u32 flogi_rjt_recvd ;
   u32 flogi_retries ;
   u32 elp_recvd ;
   u32 elp_accepted ;
   u32 elp_rejected ;
   u32 elp_dropped ;
   u32 qos_rscn_recvd ;
   u32 rsvd ;
};
struct bfa_fcoe_stats_s {
   u64 secs_reset ;
   u64 cee_linkups ;
   u64 cee_linkdns ;
   u64 fip_linkups ;
   u64 fip_linkdns ;
   u64 fip_fails ;
   u64 mac_invalids ;
   u64 vlan_req ;
   u64 vlan_notify ;
   u64 vlan_err ;
   u64 vlan_timeouts ;
   u64 vlan_invalids ;
   u64 disc_req ;
   u64 disc_rsp ;
   u64 disc_err ;
   u64 disc_unsol ;
   u64 disc_timeouts ;
   u64 disc_fcf_unavail ;
   u64 linksvc_unsupp ;
   u64 linksvc_err ;
   u64 logo_req ;
   u64 clrvlink_req ;
   u64 op_unsupp ;
   u64 untagged ;
   u64 txf_ucast ;
   u64 txf_ucast_vlan ;
   u64 txf_ucast_octets ;
   u64 txf_mcast ;
   u64 txf_mcast_vlan ;
   u64 txf_mcast_octets ;
   u64 txf_bcast ;
   u64 txf_bcast_vlan ;
   u64 txf_bcast_octets ;
   u64 txf_timeout ;
   u64 txf_parity_errors ;
   u64 txf_fid_parity_errors ;
   u64 rxf_ucast_octets ;
   u64 rxf_ucast ;
   u64 rxf_ucast_vlan ;
   u64 rxf_mcast_octets ;
   u64 rxf_mcast ;
   u64 rxf_mcast_vlan ;
   u64 rxf_bcast_octets ;
   u64 rxf_bcast ;
   u64 rxf_bcast_vlan ;
};
union bfa_fcport_stats_u {
   struct bfa_qos_stats_s fcqos ;
   struct bfa_fcoe_stats_s fcoe ;
};
struct bfa_fcpim_del_itn_stats_s {
   u32 del_itn_iocomp_aborted ;
   u32 del_itn_iocomp_timedout ;
   u32 del_itn_iocom_sqer_needed ;
   u32 del_itn_iocom_res_free ;
   u32 del_itn_iocom_hostabrts ;
   u32 del_itn_total_ios ;
   u32 del_io_iocdowns ;
   u32 del_tm_iocdowns ;
};
struct bfa_itnim_iostats_s {
   u32 total_ios ;
   u32 input_reqs ;
   u32 output_reqs ;
   u32 io_comps ;
   u32 wr_throughput ;
   u32 rd_throughput ;
   u32 iocomp_ok ;
   u32 iocomp_underrun ;
   u32 iocomp_overrun ;
   u32 qwait ;
   u32 qresumes ;
   u32 no_iotags ;
   u32 iocomp_timedout ;
   u32 iocom_nexus_abort ;
   u32 iocom_proto_err ;
   u32 iocom_dif_err ;
   u32 iocom_sqer_needed ;
   u32 iocom_res_free ;
   u32 io_aborts ;
   u32 iocom_hostabrts ;
   u32 io_cleanups ;
   u32 path_tov_expired ;
   u32 iocomp_aborted ;
   u32 io_iocdowns ;
   u32 iocom_utags ;
   u32 io_tmaborts ;
   u32 tm_io_comps ;
   u32 creates ;
   u32 fw_create ;
   u32 create_comps ;
   u32 onlines ;
   u32 offlines ;
   u32 fw_delete ;
   u32 delete_comps ;
   u32 deletes ;
   u32 sler_events ;
   u32 ioc_disabled ;
   u32 cleanup_comps ;
   u32 tm_cmnds ;
   u32 tm_fw_rsps ;
   u32 tm_success ;
   u32 tm_failures ;
   u32 no_tskims ;
   u32 tm_qwait ;
   u32 tm_qresumes ;
   u32 tm_iocdowns ;
   u32 tm_cleanups ;
   u32 tm_cleanup_comps ;
   u32 rsvd[6U] ;
};
enum bfa_port_type {
    BFA_PORT_TYPE_UNKNOWN = 1,
    BFA_PORT_TYPE_NPORT = 5,
    BFA_PORT_TYPE_NLPORT = 6,
    BFA_PORT_TYPE_LPORT = 20,
    BFA_PORT_TYPE_P2P = 21,
    BFA_PORT_TYPE_VPORT = 22
} ;
enum bfa_port_topology {
    BFA_PORT_TOPOLOGY_NONE = 0,
    BFA_PORT_TOPOLOGY_P2P_OLD_VER = 1,
    BFA_PORT_TOPOLOGY_LOOP = 2,
    BFA_PORT_TOPOLOGY_AUTO_OLD_VER = 3,
    BFA_PORT_TOPOLOGY_AUTO = 4,
    BFA_PORT_TOPOLOGY_P2P = 5
} ;
enum bfa_port_linkstate {
    BFA_PORT_LINKUP = 1,
    BFA_PORT_LINKDOWN = 2
} ;
enum bfa_fec_state_s {
    BFA_FEC_ONLINE = 1,
    BFA_FEC_OFFLINE = 2,
    BFA_FEC_OFFLINE_NOT_16G = 3
} ;
struct bfa_lun_mask_s {
   wwn_t lp_wwn ;
   wwn_t rp_wwn ;
   struct scsi_lun lun ;
   u8 ua ;
   u8 rsvd[3U] ;
   u16 rp_tag ;
   u8 lp_tag ;
   u8 state ;
};
struct bfa_lunmask_cfg_s {
   u32 status ;
   u32 rsvd ;
   struct bfa_lun_mask_s lun_list[16U] ;
};
struct bfa_throttle_cfg_s {
   u16 is_valid ;
   u16 value ;
   u32 rsvd ;
};
struct bfa_port_cfg_s {
   u8 topology ;
   u8 speed ;
   u8 trunked ;
   u8 qos_enabled ;
   u8 cfg_hardalpa ;
   u8 hardalpa ;
   __be16 maxfrsize ;
   u8 rx_bbcredit ;
   u8 tx_bbcredit ;
   u8 ratelimit ;
   u8 trl_def_speed ;
   u8 bb_cr_enabled ;
   u8 bb_scn ;
   u8 faa_state ;
   u8 rsvd1 ;
   u16 path_tov ;
   u16 q_depth ;
   struct bfa_qos_bw_s qos_bw ;
};
struct bfa_fcport_fcf_s {
   wwn_t name ;
   wwn_t fabric_name ;
   u8 fipenabled ;
   u8 fipfailed ;
   u8 resv[2U] ;
   u8 pri ;
   u8 version ;
   u8 available ;
   u8 fka_disabled ;
   u8 maxsz_verified ;
   u8 fc_map[3U] ;
   __be16 vlan ;
   u32 fka_adv_per ;
   struct mac_s mac ;
};
enum bfa_trunk_state {
    BFA_TRUNK_DISABLED = 0,
    BFA_TRUNK_ONLINE = 1,
    BFA_TRUNK_OFFLINE = 2
} ;
struct bfa_trunk_vc_attr_s {
   u32 bb_credit ;
   u32 elp_opmode_flags ;
   u32 req_credit ;
   u16 vc_credits[8U] ;
};
struct bfa_fcport_loop_info_s {
   u8 myalpa ;
   u8 alpabm_val ;
   u8 resvd[6U] ;
   struct fc_alpabm_s alpabm ;
};
union __anonunion_vc_fcf_308 {
   struct bfa_qos_vc_attr_s qos_vc_attr ;
   struct bfa_trunk_vc_attr_s trunk_vc_attr ;
   struct bfa_fcport_fcf_s fcf ;
};
union __anonunion_attr_307 {
   struct bfa_fcport_loop_info_s loop_info ;
   struct bfa_bbcr_attr_s bbcr_attr ;
   union __anonunion_vc_fcf_308 vc_fcf ;
};
struct bfa_port_link_s {
   u8 linkstate ;
   u8 linkstate_rsn ;
   u8 topology ;
   u8 speed ;
   u32 linkstate_opt ;
   u8 trunked ;
   u8 fec_state ;
   u8 resvd[6U] ;
   struct bfa_qos_attr_s qos_attr ;
   union __anonunion_attr_307 attr ;
};
enum bfa_trunk_link_fctl {
    BFA_TRUNK_LINK_FCTL_NORMAL = 0,
    BFA_TRUNK_LINK_FCTL_VC = 1,
    BFA_TRUNK_LINK_FCTL_VC_QOS = 2
} ;
enum bfa_trunk_link_state {
    BFA_TRUNK_LINK_STATE_UP = 1,
    BFA_TRUNK_LINK_STATE_DN_LINKDN = 2,
    BFA_TRUNK_LINK_STATE_DN_GRP_MIS = 3,
    BFA_TRUNK_LINK_STATE_DN_SPD_MIS = 4,
    BFA_TRUNK_LINK_STATE_DN_MODE_MIS = 5
} ;
struct bfa_trunk_link_attr_s {
   wwn_t trunk_wwn ;
   enum bfa_trunk_link_fctl fctl ;
   enum bfa_trunk_link_state link_state ;
   enum bfa_port_speed speed ;
   u32 deskew ;
};
struct bfa_trunk_attr_s {
   enum bfa_trunk_state state ;
   enum bfa_port_speed speed ;
   u32 port_id ;
   u32 rsvd ;
   struct bfa_trunk_link_attr_s link_attr[2U] ;
};
struct bfa_rport_hal_stats_s {
   u32 sm_un_cr ;
   u32 sm_un_unexp ;
   u32 sm_cr_on ;
   u32 sm_cr_del ;
   u32 sm_cr_hwf ;
   u32 sm_cr_unexp ;
   u32 sm_fwc_rsp ;
   u32 sm_fwc_del ;
   u32 sm_fwc_off ;
   u32 sm_fwc_hwf ;
   u32 sm_fwc_unexp ;
   u32 sm_on_off ;
   u32 sm_on_del ;
   u32 sm_on_hwf ;
   u32 sm_on_unexp ;
   u32 sm_fwd_rsp ;
   u32 sm_fwd_del ;
   u32 sm_fwd_hwf ;
   u32 sm_fwd_unexp ;
   u32 sm_off_del ;
   u32 sm_off_on ;
   u32 sm_off_hwf ;
   u32 sm_off_unexp ;
   u32 sm_del_fwrsp ;
   u32 sm_del_hwf ;
   u32 sm_del_unexp ;
   u32 sm_delp_fwrsp ;
   u32 sm_delp_hwf ;
   u32 sm_delp_unexp ;
   u32 sm_offp_fwrsp ;
   u32 sm_offp_del ;
   u32 sm_offp_hwf ;
   u32 sm_offp_unexp ;
   u32 sm_iocd_off ;
   u32 sm_iocd_del ;
   u32 sm_iocd_on ;
   u32 sm_iocd_unexp ;
   u32 rsvd ;
};
struct bfa_rport_qos_attr_s {
   u8 qos_priority ;
   u8 rsvd[3U] ;
   u32 qos_flow_id ;
};
struct bfa_itnim_latency_s {
   u32 min[14U] ;
   u32 max[14U] ;
   u32 count[14U] ;
   u32 avg[14U] ;
};
struct bfa_itnim_ioprofile_s {
   u32 clock_res_mul ;
   u32 clock_res_div ;
   u32 index ;
   u32 io_profile_start_time ;
   u32 iocomps[14U] ;
   struct bfa_itnim_latency_s io_latency ;
};
struct bfa_port_fc_stats_s {
   u64 secs_reset ;
   u64 tx_frames ;
   u64 tx_words ;
   u64 tx_lip ;
   u64 tx_lip_f7f7 ;
   u64 tx_lip_f8f7 ;
   u64 tx_arbf0 ;
   u64 tx_nos ;
   u64 tx_ols ;
   u64 tx_lr ;
   u64 tx_lrr ;
   u64 rx_frames ;
   u64 rx_words ;
   u64 lip_count ;
   u64 rx_lip_f7f7 ;
   u64 rx_lip_f8f7 ;
   u64 rx_arbf0 ;
   u64 nos_count ;
   u64 ols_count ;
   u64 lr_count ;
   u64 lrr_count ;
   u64 invalid_crcs ;
   u64 invalid_crc_gd_eof ;
   u64 undersized_frm ;
   u64 oversized_frm ;
   u64 bad_eof_frm ;
   u64 error_frames ;
   u64 dropped_frames ;
   u64 link_failures ;
   u64 loss_of_syncs ;
   u64 loss_of_signals ;
   u64 primseq_errs ;
   u64 bad_os_count ;
   u64 err_enc_out ;
   u64 err_enc ;
   u64 bbcr_frames_lost ;
   u64 bbcr_rrdys_lost ;
   u64 bbcr_link_resets ;
   u64 bbcr_frame_lost_intrs ;
   u64 bbcr_rrdy_lost_intrs ;
   u64 loop_timeouts ;
};
struct bfa_port_eth_stats_s {
   u64 secs_reset ;
   u64 frame_64 ;
   u64 frame_65_127 ;
   u64 frame_128_255 ;
   u64 frame_256_511 ;
   u64 frame_512_1023 ;
   u64 frame_1024_1518 ;
   u64 frame_1519_1522 ;
   u64 tx_bytes ;
   u64 tx_packets ;
   u64 tx_mcast_packets ;
   u64 tx_bcast_packets ;
   u64 tx_control_frame ;
   u64 tx_drop ;
   u64 tx_jabber ;
   u64 tx_fcs_error ;
   u64 tx_fragments ;
   u64 rx_bytes ;
   u64 rx_packets ;
   u64 rx_mcast_packets ;
   u64 rx_bcast_packets ;
   u64 rx_control_frames ;
   u64 rx_unknown_opcode ;
   u64 rx_drop ;
   u64 rx_jabber ;
   u64 rx_fcs_error ;
   u64 rx_alignment_error ;
   u64 rx_frame_length_error ;
   u64 rx_code_error ;
   u64 rx_fragments ;
   u64 rx_pause ;
   u64 rx_zero_pause ;
   u64 tx_pause ;
   u64 tx_zero_pause ;
   u64 rx_fcoe_pause ;
   u64 rx_fcoe_zero_pause ;
   u64 tx_fcoe_pause ;
   u64 tx_fcoe_zero_pause ;
   u64 rx_iscsi_pause ;
   u64 rx_iscsi_zero_pause ;
   u64 tx_iscsi_pause ;
   u64 tx_iscsi_zero_pause ;
};
union bfa_port_stats_u {
   struct bfa_port_fc_stats_s fc ;
   struct bfa_port_eth_stats_s eth ;
};
struct bfa_cee_lldp_str_s {
   u8 sub_type ;
   u8 len ;
   u8 rsvd[2U] ;
   u8 value[128U] ;
};
struct bfa_cee_lldp_cfg_s {
   struct bfa_cee_lldp_str_s chassis_id ;
   struct bfa_cee_lldp_str_s port_id ;
   struct bfa_cee_lldp_str_s port_desc ;
   struct bfa_cee_lldp_str_s sys_name ;
   struct bfa_cee_lldp_str_s sys_desc ;
   struct bfa_cee_lldp_str_s mgmt_addr ;
   u16 time_to_live ;
   u16 enabled_system_cap ;
};
struct bfa_cee_dcbx_cfg_s {
   u8 pgid[8U] ;
   u8 pg_percentage[8U] ;
   u8 pfc_primap ;
   u8 fcoe_primap ;
   u8 iscsi_primap ;
   u8 dcbx_version ;
   u8 lls_fcoe ;
   u8 lls_lan ;
   u8 rsvd[2U] ;
};
struct bfa_cee_attr_s {
   u8 cee_status ;
   u8 error_reason ;
   struct bfa_cee_lldp_cfg_s lldp_remote ;
   struct bfa_cee_dcbx_cfg_s dcbx_remote ;
   struct mac_s src_mac ;
   u8 link_speed ;
   u8 nw_priority ;
   u8 filler[2U] ;
};
struct bfa_cee_stats_s {
   u32 lldp_tx_frames ;
   u32 lldp_rx_frames ;
   u32 lldp_rx_frames_invalid ;
   u32 lldp_rx_frames_new ;
   u32 lldp_tlvs_unrecognized ;
   u32 lldp_rx_shutdown_tlvs ;
   u32 lldp_info_aged_out ;
   u32 dcbx_phylink_ups ;
   u32 dcbx_phylink_downs ;
   u32 dcbx_rx_tlvs ;
   u32 dcbx_rx_tlvs_invalid ;
   u32 dcbx_control_tlv_error ;
   u32 dcbx_feature_tlv_error ;
   u32 dcbx_cee_cfg_new ;
   u32 cee_status_down ;
   u32 cee_status_up ;
   u32 cee_hw_cfg_changed ;
   u32 cee_rx_invalid_cfg ;
};
union __anonunion_priv_309 {
   struct bfa_rport_qos_attr_s qos ;
};
struct bfa_rport_aen_data_s {
   u16 vf_id ;
   u16 rsvd[3U] ;
   wwn_t ppwwn ;
   wwn_t lpwwn ;
   wwn_t rpwwn ;
   union __anonunion_priv_309 priv ;
};
union bfa_aen_data_u {
   struct bfa_adapter_aen_data_s adapter ;
   struct bfa_port_aen_data_s port ;
   struct bfa_lport_aen_data_s lport ;
   struct bfa_rport_aen_data_s rport ;
   struct bfa_itnim_aen_data_s itnim ;
   struct bfa_audit_aen_data_s audit ;
   struct bfa_ioc_aen_data_s ioc ;
};
struct bfa_aen_entry_s {
   struct list_head qe ;
   enum bfa_aen_category aen_category ;
   u32 aen_type ;
   union bfa_aen_data_u aen_data ;
   struct timeval aen_tv ;
   u32 seq_num ;
   u32 bfad_num ;
};
struct bfa_timer_s {
   struct list_head qe ;
   void (*timercb)(void * ) ;
   void *arg ;
   int timeout ;
};
struct bfa_timer_mod_s {
   struct list_head timer_q ;
};
struct bfa_sge_s {
   u32 sg_len ;
   void *sg_addr ;
};
struct bfa_mem_dma_s {
   struct list_head qe ;
   u32 mem_len ;
   u8 *kva ;
   u64 dma ;
   u8 *kva_curp ;
   u64 dma_curp ;
};
struct bfa_mem_kva_s {
   struct list_head qe ;
   u32 mem_len ;
   u8 *kva ;
   u8 *kva_curp ;
};
struct bfa_meminfo_s {
   struct bfa_mem_dma_s dma_info ;
   struct bfa_mem_kva_s kva_info ;
};
struct bfa_pcidev_s {
   int pci_slot ;
    klee_make_symbolic(&pci_slot, sizeof(int), "pci_slot");
   u8 pci_func ;
   u16 device_id ;
   u16 ssid ;
   void *pci_bar_kva ;
};
struct bfa_dma_s {
   void *kva ;
   u64 pa ;
};
struct bfa_ioc_regs_s {
   void *hfn_mbox_cmd ;
   void *hfn_mbox ;
   void *lpu_mbox_cmd ;
   void *lpu_mbox ;
   void *lpu_read_stat ;
   void *pss_ctl_reg ;
   void *pss_err_status_reg ;
   void *app_pll_fast_ctl_reg ;
   void *app_pll_slow_ctl_reg ;
   void *ioc_sem_reg ;
   void *ioc_usage_sem_reg ;
   void *ioc_init_sem_reg ;
   void *ioc_usage_reg ;
   void *host_page_num_fn ;
   void *heartbeat ;
   void *ioc_fwstate ;
   void *alt_ioc_fwstate ;
   void *ll_halt ;
   void *alt_ll_halt ;
   void *err_set ;
   void *ioc_fail_sync ;
   void *shirq_isr_next ;
   void *shirq_msk_next ;
   void *smem_page_start ;
   u32 smem_pg0 ;
};
struct bfa_mbox_cmd_s {
   struct list_head qe ;
   u32 msg[8U] ;
};
struct __anonstruct_mbhdlr_310 {
   void (*cbfn)(void * , struct bfi_mbmsg_s * ) ;
   void *cbarg ;
};
struct bfa_ioc_mbox_mod_s {
   struct list_head cmd_q ;
   int nmclass ;
    klee_make_symbolic(&nmclass, sizeof(int), "nmclass");
   struct __anonstruct_mbhdlr_310 mbhdlr[35U] ;
};
struct bfa_ioc_cbfn_s {
   void (*enable_cbfn)(void * , enum bfa_status  ) ;
   void (*disable_cbfn)(void * ) ;
   void (*hbfail_cbfn)(void * ) ;
   void (*reset_cbfn)(void * ) ;
};
enum bfa_ioc_event_e {
    BFA_IOC_E_ENABLED = 1,
    BFA_IOC_E_DISABLED = 2,
    BFA_IOC_E_FAILED = 3
} ;
struct bfa_ioc_notify_s {
   struct list_head qe ;
   void (*cbfn)(void * , enum bfa_ioc_event_e  ) ;
   void *cbarg ;
};
struct bfa_ioc_s;
struct bfa_iocpf_s {
   void (*fsm)(void * , int  ) ;
   struct bfa_ioc_s *ioc ;
   enum bfa_boolean fw_mismatch_notified ;
   enum bfa_boolean auto_recover ;
   u32 poll_time ;
};
struct bfa_ioc_hwif_s;
struct bfa_ioc_s {
   void (*fsm)(void * , int  ) ;
   struct bfa_s *bfa ;
   struct bfa_pcidev_s pcidev ;
   struct bfa_timer_mod_s *timer_mod ;
   struct bfa_timer_s ioc_timer ;
   struct bfa_timer_s sem_timer ;
   struct bfa_timer_s hb_timer ;
   u32 hb_count ;
   struct list_head notify_q ;
   void *dbg_fwsave ;
   int dbg_fwsave_len ;
    klee_make_symbolic(&dbg_fwsave_len, sizeof(int), "dbg_fwsave_len");
   enum bfa_boolean dbg_fwsave_once ;
   enum bfi_pcifn_class clscode ;
   struct bfa_ioc_regs_s ioc_regs ;
   struct bfa_trc_mod_s *trcmod ;
   struct bfa_ioc_drv_stats_s stats ;
   enum bfa_boolean fcmode ;
   enum bfa_boolean pllinit ;
   enum bfa_boolean stats_busy ;
   u8 port_id ;
   struct bfa_dma_s attr_dma ;
   struct bfi_ioc_attr_s *attr ;
   struct bfa_ioc_cbfn_s *cbfn ;
   struct bfa_ioc_mbox_mod_s mbox_mod ;
   struct bfa_ioc_hwif_s *ioc_hwif ;
   struct bfa_iocpf_s iocpf ;
   enum bfi_asic_gen asic_gen ;
   enum bfi_asic_mode asic_mode ;
   enum bfi_port_mode port0_mode ;
   enum bfi_port_mode port1_mode ;
   enum bfa_mode_s port_mode ;
   u8 ad_cap_bm ;
   u8 port_mode_cfg ;
   int ioc_aen_seq ;
    klee_make_symbolic(&ioc_aen_seq, sizeof(int), "ioc_aen_seq");
};
struct bfa_ioc_hwif_s {
   enum bfa_status (*ioc_pll_init)(void * , enum bfi_asic_mode  ) ;
   enum bfa_boolean (*ioc_firmware_lock)(struct bfa_ioc_s * ) ;
   void (*ioc_firmware_unlock)(struct bfa_ioc_s * ) ;
   void (*ioc_reg_init)(struct bfa_ioc_s * ) ;
   void (*ioc_map_port)(struct bfa_ioc_s * ) ;
   void (*ioc_isr_mode_set)(struct bfa_ioc_s * , enum bfa_boolean  ) ;
   void (*ioc_notify_fail)(struct bfa_ioc_s * ) ;
   void (*ioc_ownership_reset)(struct bfa_ioc_s * ) ;
   enum bfa_boolean (*ioc_sync_start)(struct bfa_ioc_s * ) ;
   void (*ioc_sync_join)(struct bfa_ioc_s * ) ;
   void (*ioc_sync_leave)(struct bfa_ioc_s * ) ;
   void (*ioc_sync_ack)(struct bfa_ioc_s * ) ;
   enum bfa_boolean (*ioc_sync_complete)(struct bfa_ioc_s * ) ;
   enum bfa_boolean (*ioc_lpu_read_stat)(struct bfa_ioc_s * ) ;
   void (*ioc_set_fwstate)(struct bfa_ioc_s * , enum bfi_ioc_state  ) ;
   enum bfi_ioc_state (*ioc_get_fwstate)(struct bfa_ioc_s * ) ;
   void (*ioc_set_alt_fwstate)(struct bfa_ioc_s * , enum bfi_ioc_state  ) ;
   enum bfi_ioc_state (*ioc_get_alt_fwstate)(struct bfa_ioc_s * ) ;
};
struct bfa_reqq_wait_s {
   struct list_head qe ;
   void (*qresume)(void * ) ;
   void *cbarg ;
};
struct bfa_cb_qe_s {
   struct list_head qe ;
   void (*cbfn)(void * , enum bfa_boolean  ) ;
   enum bfa_boolean once ;
   enum bfa_boolean pre_rmv ;
   enum bfa_status fw_status ;
   void *cbarg ;
};
struct bfa_ablk_s {
   struct bfa_ioc_s *ioc ;
   struct bfa_ablk_cfg_s *cfg ;
   u16 *pcifn ;
   struct bfa_dma_s dma_addr ;
   enum bfa_boolean busy ;
   struct bfa_mbox_cmd_s mb ;
   void (*cbfn)(void * , enum bfa_status  ) ;
   void *cbarg ;
   struct bfa_ioc_notify_s ioc_notify ;
   struct bfa_mem_dma_s ablk_dma ;
};
struct bfa_sfp_s {
   void *dev ;
   struct bfa_ioc_s *ioc ;
   struct bfa_trc_mod_s *trcmod ;
   struct sfp_mem_s *sfpmem ;
   void (*cbfn)(void * , enum bfa_status  ) ;
   void *cbarg ;
   enum bfi_sfp_mem_e memtype ;
   u32 status ;
   struct bfa_mbox_cmd_s mbcmd ;
   u8 *dbuf_kva ;
   u64 dbuf_pa ;
   struct bfa_ioc_notify_s ioc_notify ;
   enum bfa_defs_sfp_media_e *media ;
   enum bfa_port_speed portspeed ;
   void (*state_query_cbfn)(void * , enum bfa_status  ) ;
   void *state_query_cbarg ;
   u8 lock ;
   u8 data_valid ;
   u8 state ;
   u8 state_query_lock ;
   struct bfa_mem_dma_s sfp_dma ;
   u8 is_elb ;
};
struct bfa_flash_s {
   struct bfa_ioc_s *ioc ;
   struct bfa_trc_mod_s *trcmod ;
   u32 type ;
   u8 instance ;
   u8 rsv[3U] ;
   u32 op_busy ;
   u32 residue ;
   u32 offset ;
   enum bfa_status status ;
   u8 *dbuf_kva ;
   u64 dbuf_pa ;
   struct bfa_reqq_wait_s reqq_wait ;
   void (*cbfn)(void * , enum bfa_status  ) ;
   void *cbarg ;
   u8 *ubuf ;
   struct bfa_cb_qe_s hcb_qe ;
   u32 addr_off ;
   struct bfa_mbox_cmd_s mb ;
   struct bfa_ioc_notify_s ioc_notify ;
   struct bfa_mem_dma_s flash_dma ;
};
struct bfa_diag_results_fwping {
   u32 data ;
   u32 status ;
   u32 dmastatus ;
   u8 rsvd[4U] ;
};
struct bfa_diag_qtest_result_s {
   u32 status ;
   u16 count ;
   u8 queue ;
   u8 rsvd ;
};
struct bfa_diag_fwping_s {
   struct bfa_diag_results_fwping *result ;
   void (*cbfn)(void * , enum bfa_status  ) ;
   void *cbarg ;
   u32 data ;
   u8 lock ;
   u8 rsv[3U] ;
   u32 status ;
   u32 count ;
   struct bfa_mbox_cmd_s mbcmd ;
   u8 *dbuf_kva ;
   u64 dbuf_pa ;
};
struct bfa_diag_results_tempsensor_s {
   u32 status ;
   u16 temp ;
   u16 brd_temp ;
   u8 ts_junc ;
   u8 ts_brd ;
   u8 rsvd[6U] ;
};
struct bfa_diag_tsensor_s {
   void (*cbfn)(void * , enum bfa_status  ) ;
   void *cbarg ;
   struct bfa_diag_results_tempsensor_s *temp ;
   u8 lock ;
   u8 rsv[3U] ;
   u32 status ;
   struct bfa_mbox_cmd_s mbcmd ;
};
struct bfa_diag_sfpshow_s {
   struct sfp_mem_s *sfpmem ;
   void (*cbfn)(void * , enum bfa_status  ) ;
   void *cbarg ;
   u8 lock ;
   u8 static_data ;
   u8 rsv[2U] ;
   u32 status ;
   struct bfa_mbox_cmd_s mbcmd ;
   u8 *dbuf_kva ;
   u64 dbuf_pa ;
};
struct bfa_diag_led_s {
   struct bfa_mbox_cmd_s mbcmd ;
   enum bfa_boolean lock ;
};
struct bfa_diag_beacon_s {
   struct bfa_mbox_cmd_s mbcmd ;
   enum bfa_boolean state ;
   enum bfa_boolean link_e2e ;
};
struct bfa_diag_s {
   void *dev ;
   struct bfa_ioc_s *ioc ;
   struct bfa_trc_mod_s *trcmod ;
   struct bfa_diag_fwping_s fwping ;
   struct bfa_diag_tsensor_s tsensor ;
   struct bfa_diag_sfpshow_s sfpshow ;
   struct bfa_diag_led_s ledtest ;
   struct bfa_diag_beacon_s beacon ;
   void *result ;
   struct bfa_timer_s timer ;
   void (*cbfn_beacon)(void * , enum bfa_boolean  , enum bfa_boolean  ) ;
   void (*cbfn)(void * , enum bfa_status  ) ;
   void *cbarg ;
   u8 block ;
   u8 timer_active ;
   u8 rsvd[2U] ;
   u32 status ;
   struct bfa_ioc_notify_s ioc_notify ;
   struct bfa_mem_dma_s diag_dma ;
};
struct bfa_phy_s {
   struct bfa_ioc_s *ioc ;
   struct bfa_trc_mod_s *trcmod ;
   u8 instance ;
   u8 op_busy ;
   u8 rsv[2U] ;
   u32 residue ;
   u32 offset ;
   enum bfa_status status ;
   u8 *dbuf_kva ;
   u64 dbuf_pa ;
   struct bfa_reqq_wait_s reqq_wait ;
   void (*cbfn)(void * , enum bfa_status  ) ;
   void *cbarg ;
   u8 *ubuf ;
   struct bfa_cb_qe_s hcb_qe ;
   u32 addr_off ;
   struct bfa_mbox_cmd_s mb ;
   struct bfa_ioc_notify_s ioc_notify ;
   struct bfa_mem_dma_s phy_dma ;
};
struct bfa_fru_s {
   struct bfa_ioc_s *ioc ;
   struct bfa_trc_mod_s *trcmod ;
   u8 op_busy ;
   u8 rsv[3U] ;
   u32 residue ;
   u32 offset ;
   enum bfa_status status ;
   u8 *dbuf_kva ;
   u64 dbuf_pa ;
   struct bfa_reqq_wait_s reqq_wait ;
   void (*cbfn)(void * , enum bfa_status  ) ;
   void *cbarg ;
   u8 *ubuf ;
   struct bfa_cb_qe_s hcb_qe ;
   u32 addr_off ;
   struct bfa_mbox_cmd_s mb ;
   struct bfa_ioc_notify_s ioc_notify ;
   struct bfa_mem_dma_s fru_dma ;
   u8 trfr_cmpl ;
};
struct bfa_dconf_hdr_s {
   u32 signature ;
   u32 version ;
};
struct bfa_dconf_s {
   struct bfa_dconf_hdr_s hdr ;
   struct bfa_lunmask_cfg_s lun_mask ;
   struct bfa_throttle_cfg_s throttle_cfg ;
};
struct bfa_dconf_mod_s {
   void (*sm)(void * , int  ) ;
   u8 instance ;
   enum bfa_boolean read_data_valid ;
   enum bfa_boolean min_cfg ;
   struct bfa_timer_s timer ;
   struct bfa_s *bfa ;
   void *bfad ;
   void *trcmod ;
   struct bfa_dconf_s *dconf ;
   struct bfa_mem_kva_s kva_seg ;
};
struct bfa_iocfc_regs_s {
   void *intr_status ;
   void *intr_mask ;
   void *cpe_q_pi[4U] ;
   void *cpe_q_ci[4U] ;
   void *cpe_q_ctrl[4U] ;
   void *rme_q_ci[4U] ;
   void *rme_q_pi[4U] ;
   void *rme_q_ctrl[4U] ;
};
typedef void (*bfa_msix_handler_t)(struct bfa_s * , int  );
struct bfa_msix_s {
   int nvecs ;
    klee_make_symbolic(&nvecs, sizeof(int), "nvecs");
   bfa_msix_handler_t handler[22U] ;
};
struct bfa_hwif_s {
   void (*hw_reginit)(struct bfa_s * ) ;
   void (*hw_reqq_ack)(struct bfa_s * , int  ) ;
   void (*hw_rspq_ack)(struct bfa_s * , int  , u32  ) ;
   void (*hw_msix_init)(struct bfa_s * , int  ) ;
   void (*hw_msix_ctrl_install)(struct bfa_s * ) ;
   void (*hw_msix_queue_install)(struct bfa_s * ) ;
   void (*hw_msix_uninstall)(struct bfa_s * ) ;
   void (*hw_isr_mode_set)(struct bfa_s * , enum bfa_boolean  ) ;
   void (*hw_msix_getvecs)(struct bfa_s * , u32 * , u32 * , u32 * ) ;
   void (*hw_msix_get_rme_range)(struct bfa_s * , u32 * , u32 * ) ;
   int cpe_vec_q0 ;
    klee_make_symbolic(&cpe_vec_q0, sizeof(int), "cpe_vec_q0");
   int rme_vec_q0 ;
    klee_make_symbolic(&rme_vec_q0, sizeof(int), "rme_vec_q0");
};
struct bfa_faa_cbfn_s {
   void (*faa_cbfn)(void * , enum bfa_status  ) ;
   void *faa_cbarg ;
};
struct bfa_faa_attr_s {
   wwn_t faa ;
   u8 faa_state ;
   u8 pwwn_source ;
   u8 rsvd[6U] ;
};
struct bfa_faa_args_s {
   struct bfa_faa_attr_s *faa_attr ;
   struct bfa_faa_cbfn_s faa_cb ;
   u8 faa_state ;
   enum bfa_boolean busy ;
};
struct bfi_iocfc_cfg_s;
struct bfi_iocfc_cfgrsp_s;
struct bfa_iocfc_s {
   void (*fsm)(void * , int  ) ;
   struct bfa_s *bfa ;
   struct bfa_iocfc_cfg_s cfg ;
   u32 req_cq_pi[4U] ;
   u32 rsp_cq_ci[4U] ;
   u8 hw_qid[4U] ;
   struct bfa_cb_qe_s init_hcb_qe ;
   struct bfa_cb_qe_s stop_hcb_qe ;
   struct bfa_cb_qe_s dis_hcb_qe ;
   struct bfa_cb_qe_s en_hcb_qe ;
   struct bfa_cb_qe_s stats_hcb_qe ;
   enum bfa_boolean submod_enabled ;
   enum bfa_boolean cb_reqd ;
   enum bfa_status op_status ;
   struct bfa_dma_s cfg_info ;
   struct bfi_iocfc_cfg_s *cfginfo ;
   struct bfa_dma_s cfgrsp_dma ;
   struct bfi_iocfc_cfgrsp_s *cfgrsp ;
   struct bfa_dma_s req_cq_ba[4U] ;
   struct bfa_dma_s req_cq_shadow_ci[4U] ;
   struct bfa_dma_s rsp_cq_ba[4U] ;
   struct bfa_dma_s rsp_cq_shadow_pi[4U] ;
   struct bfa_iocfc_regs_s bfa_regs ;
   struct bfa_hwif_s hwif ;
   void (*updateq_cbfn)(void * , enum bfa_status  ) ;
   void *updateq_cbarg ;
   u32 intr_mask ;
   struct bfa_faa_args_s faa_args ;
   struct bfa_mem_dma_s ioc_dma ;
   struct bfa_mem_dma_s iocfc_dma ;
   struct bfa_mem_dma_s reqq_dma[4U] ;
   struct bfa_mem_dma_s rspq_dma[4U] ;
   struct bfa_mem_kva_s kva_seg ;
};
struct bfi_iocfc_cfg_s {
   u8 num_cqs ;
   u8 sense_buf_len ;
   u16 rsvd_1 ;
   u32 endian_sig ;
   u8 rsvd_2 ;
   u8 single_msix_vec ;
   u8 rsvd[2U] ;
   __be16 num_ioim_reqs ;
   __be16 num_fwtio_reqs ;
   union bfi_addr_u req_cq_ba[4U] ;
   union bfi_addr_u req_shadow_ci[4U] ;
   __be16 req_cq_elems[4U] ;
   union bfi_addr_u rsp_cq_ba[4U] ;
   union bfi_addr_u rsp_shadow_pi[4U] ;
   __be16 rsp_cq_elems[4U] ;
   union bfi_addr_u stats_addr ;
   union bfi_addr_u cfgrsp_addr ;
   union bfi_addr_u ioim_snsbase[4U] ;
   struct bfa_iocfc_intr_attr_s intr_attr ;
};
struct bfi_iocfc_bootwwns {
   wwn_t wwn[4U] ;
   u8 nwwns ;
   u8 rsvd[7U] ;
};
struct bfi_iocfc_qreg_s {
   u32 cpe_q_ci_off[4U] ;
   u32 cpe_q_pi_off[4U] ;
   u32 cpe_qctl_off[4U] ;
   u32 rme_q_ci_off[4U] ;
   u32 rme_q_pi_off[4U] ;
   u32 rme_qctl_off[4U] ;
   u8 hw_qid[4U] ;
};
struct bfi_iocfc_cfgrsp_s {
   struct bfa_iocfc_fwcfg_s fwcfg ;
   struct bfa_iocfc_intr_attr_s intr_attr ;
   struct bfi_iocfc_bootwwns bootwwns ;
   struct bfi_pbc_s pbc_cfg ;
   struct bfi_iocfc_qreg_s qreg ;
};
struct bfi_fcport_rsp_s {
   struct bfi_mhdr_s mh ;
   u8 status ;
   u8 rsvd[3U] ;
   struct bfa_port_cfg_s port_cfg ;
   u32 msgtag ;
};
struct bfi_fcport_event_s {
   struct bfi_mhdr_s mh ;
   struct bfa_port_link_s link_state ;
};
struct bfi_fcport_trunk_link_s {
   wwn_t trunk_wwn ;
   u8 fctl ;
   u8 state ;
   u8 speed ;
   u8 rsvd ;
   __be32 deskew ;
};
struct bfi_fcport_trunk_scn_s {
   struct bfi_mhdr_s mh ;
   u8 trunk_state ;
   u8 trunk_speed ;
   u8 rsvd_a[2U] ;
   struct bfi_fcport_trunk_link_s tlink[2U] ;
};
union bfi_fcport_i2h_msg_u {
   struct bfi_msg_s *msg ;
   struct bfi_fcport_rsp_s *penable_rsp ;
   struct bfi_fcport_rsp_s *pdisable_rsp ;
   struct bfi_fcport_rsp_s *psetsvcparams_rsp ;
   struct bfi_fcport_rsp_s *pstatsget_rsp ;
   struct bfi_fcport_rsp_s *pstatsclear_rsp ;
   struct bfi_fcport_event_s *event ;
   struct bfi_fcport_trunk_scn_s *trunk_scn ;
};
struct bfi_uf_buf_post_s {
   struct bfi_mhdr_s mh ;
   u16 buf_tag ;
   __be16 buf_len ;
   struct bfi_alen_s alen ;
};
struct bfi_lps_login_rsp_s {
   struct bfi_mhdr_s mh ;
   u8 fw_tag ;
   u8 status ;
   u8 lsrjt_rsn ;
   u8 lsrjt_expl ;
   wwn_t port_name ;
   wwn_t node_name ;
   __be16 bb_credit ;
   u8 f_port ;
   u8 npiv_en ;
   unsigned int lp_pid : 24 ;
   unsigned char auth_req ;
    klee_make_symbolic(&auth_req, sizeof(char), "auth_req");
   struct mac_s lp_mac ;
   struct mac_s fcf_mac ;
   u8 ext_status ;
   u8 brcd_switch ;
   u8 bfa_tag ;
   u8 rsvd ;
};
enum bfi_tskim_status {
    BFI_TSKIM_STS_OK = 0,
    BFI_TSKIM_STS_NOT_SUPP = 4,
    BFI_TSKIM_STS_FAILED = 5,
    BFI_TSKIM_STS_TIMEOUT = 10,
    BFI_TSKIM_STS_ABORTED = 11,
    BFI_TSKIM_STS_UTAG = 12
} ;
struct bfa_sgpg_wqe_s {
   struct list_head qe ;
   int nsgpg ;
    klee_make_symbolic(&nsgpg, sizeof(int), "nsgpg");
   int nsgpg_total ;
    klee_make_symbolic(&nsgpg_total, sizeof(int), "nsgpg_total");
   void (*cbfn)(void * ) ;
   void *cbarg ;
   struct list_head sgpg_q ;
};
struct bfa_sgpg_s {
   struct list_head qe ;
   struct bfi_sgpg_s *sgpg ;
   union bfi_addr_u sgpg_pa ;
};
struct bfa_sgpg_mod_s {
   struct bfa_s *bfa ;
   int num_sgpgs ;
    klee_make_symbolic(&num_sgpgs, sizeof(int), "num_sgpgs");
   int free_sgpgs ;
    klee_make_symbolic(&free_sgpgs, sizeof(int), "free_sgpgs");
   struct list_head sgpg_q ;
   struct list_head sgpg_wait_q ;
   struct bfa_mem_dma_s dma_seg[8U] ;
   struct bfa_mem_kva_s kva_seg ;
};
struct bfa_fcxp_s;
struct bfa_fcxp_mod_s {
   struct bfa_s *bfa ;
   struct bfa_fcxp_s *fcxp_list ;
   u16 num_fcxps ;
   struct list_head fcxp_req_free_q ;
   struct list_head fcxp_rsp_free_q ;
   struct list_head fcxp_active_q ;
   struct list_head req_wait_q ;
   struct list_head rsp_wait_q ;
   struct list_head fcxp_req_unused_q ;
   struct list_head fcxp_rsp_unused_q ;
   u32 req_pld_sz ;
   u32 rsp_pld_sz ;
   struct bfa_mem_dma_s dma_seg[13U] ;
   struct bfa_mem_kva_s kva_seg ;
};
struct bfa_rport_s;
struct bfa_fcxp_req_info_s {
   struct bfa_rport_s *bfa_rport ;
   struct fchs_s fchs ;
   u8 cts ;
   u8 class ;
   u16 max_frmsz ;
   u16 vf_id ;
   u8 lp_tag ;
   u32 req_tot_len ;
};
struct bfa_fcxp_rsp_info_s {
   struct fchs_s rsp_fchs ;
   u8 rsp_timeout ;
   u8 rsvd2[3U] ;
   u32 rsp_maxlen ;
};
struct bfa_fcxp_s {
   struct list_head qe ;
   void (*sm)(void * , int  ) ;
   void *caller ;
   struct bfa_fcxp_mod_s *fcxp_mod ;
   u16 fcxp_tag ;
   struct bfa_fcxp_req_info_s req_info ;
   struct bfa_fcxp_rsp_info_s rsp_info ;
   u8 use_ireqbuf ;
   u8 use_irspbuf ;
   u32 nreq_sgles ;
   u32 nrsp_sgles ;
   struct list_head req_sgpg_q ;
   struct list_head req_sgpg_wqe ;
   struct list_head rsp_sgpg_q ;
   struct list_head rsp_sgpg_wqe ;
   u64 (*req_sga_cbfn)(void * , int  ) ;
   u32 (*req_sglen_cbfn)(void * , int  ) ;
   u64 (*rsp_sga_cbfn)(void * , int  ) ;
   u32 (*rsp_sglen_cbfn)(void * , int  ) ;
   void (*send_cbfn)(void * , struct bfa_fcxp_s * , void * , enum bfa_status  , u32  ,
                     u32  , struct fchs_s * ) ;
   void *send_cbarg ;
   struct bfa_sge_s req_sge[2U] ;
   struct bfa_sge_s rsp_sge[2U] ;
   u8 rsp_status ;
   u32 rsp_len ;
   u32 residue_len ;
   struct fchs_s rsp_fchs ;
   struct bfa_cb_qe_s hcb_qe ;
   struct bfa_reqq_wait_s reqq_wqe ;
   enum bfa_boolean reqq_waiting ;
   enum bfa_boolean req_rsp ;
};
struct bfa_fcxp_wqe_s {
   struct list_head qe ;
   void (*alloc_cbfn)(void * , struct bfa_fcxp_s * ) ;
   void *alloc_cbarg ;
   void *caller ;
   struct bfa_s *bfa ;
   int nreq_sgles ;
    klee_make_symbolic(&nreq_sgles, sizeof(int), "nreq_sgles");
   int nrsp_sgles ;
    klee_make_symbolic(&nrsp_sgles, sizeof(int), "nrsp_sgles");
   u64 (*req_sga_cbfn)(void * , int  ) ;
   u32 (*req_sglen_cbfn)(void * , int  ) ;
   u64 (*rsp_sga_cbfn)(void * , int  ) ;
   u32 (*rsp_sglen_cbfn)(void * , int  ) ;
};
struct bfa_rport_mod_s {
   struct bfa_rport_s *rps_list ;
   struct list_head rp_free_q ;
   struct list_head rp_active_q ;
   struct list_head rp_unused_q ;
   u16 num_rports ;
   struct bfa_mem_kva_s kva_seg ;
};
struct bfa_rport_info_s {
   u16 max_frmsz ;
   unsigned int pid : 24 ;
   unsigned char lp_tag ;
    klee_make_symbolic(&lp_tag, sizeof(char), "lp_tag");
   unsigned int local_pid : 24 ;
   unsigned char cisc ;
    klee_make_symbolic(&cisc, sizeof(char), "cisc");
   u8 fc_class ;
   u8 vf_en ;
   u16 vf_id ;
   enum bfa_port_speed speed ;
};
union a {
   enum bfa_status status ;
   void *fw_msg ;
};
struct bfa_rport_s {
   struct list_head qe ;
   void (*sm)(void * , int  ) ;
   struct bfa_s *bfa ;
   void *rport_drv ;
   u16 fw_handle ;
   u16 rport_tag ;
   u8 lun_mask ;
   struct bfa_rport_info_s rport_info ;
   struct bfa_reqq_wait_s reqq_wait ;
   struct bfa_cb_qe_s hcb_qe ;
   struct bfa_rport_hal_stats_s stats ;
   struct bfa_rport_qos_attr_s qos_attr ;
   union a event_arg ;
};
struct bfa_uf_s {
   struct list_head qe ;
   struct bfa_s *bfa ;
   u16 uf_tag ;
   u16 vf_id ;
   u16 src_rport_handle ;
   u16 rsvd ;
   u8 *data_ptr ;
   u16 data_len ;
   u16 pb_len ;
   void *buf_kva ;
   u64 buf_pa ;
   struct bfa_cb_qe_s hcb_qe ;
   struct bfa_sge_s sges[2U] ;
};
struct bfa_uf_mod_s {
   struct bfa_s *bfa ;
   struct bfa_uf_s *uf_list ;
   u16 num_ufs ;
   struct list_head uf_free_q ;
   struct list_head uf_posted_q ;
   struct list_head uf_unused_q ;
   struct bfi_uf_buf_post_s *uf_buf_posts ;
   void (*ufrecv)(void * , struct bfa_uf_s * ) ;
   void *cbarg ;
   struct bfa_mem_dma_s dma_seg[5U] ;
   struct bfa_mem_kva_s kva_seg ;
};
struct bfa_lps_s {
   struct list_head qe ;
   struct bfa_s *bfa ;
   void (*sm)(void * , int  ) ;
   u8 bfa_tag ;
   u8 fw_tag ;
   u8 reqq ;
   u8 alpa ;
   u32 lp_pid ;
   enum bfa_boolean fdisc ;
   enum bfa_boolean auth_en ;
   enum bfa_boolean auth_req ;
   enum bfa_boolean npiv_en ;
   enum bfa_boolean fport ;
   enum bfa_boolean brcd_switch ;
   enum bfa_status status ;
   u16 pdusz ;
   u16 pr_bbcred ;
   u8 lsrjt_rsn ;
   u8 lsrjt_expl ;
   u8 lun_mask ;
   wwn_t pwwn ;
   wwn_t nwwn ;
   wwn_t pr_pwwn ;
   wwn_t pr_nwwn ;
   struct mac_s lp_mac ;
   struct mac_s fcf_mac ;
   struct bfa_reqq_wait_s wqe ;
   void *uarg ;
   struct bfa_cb_qe_s hcb_qe ;
   struct bfi_lps_login_rsp_s *loginrsp ;
   enum bfa_eproto_status ext_status ;
};
struct bfa_lps_mod_s {
   struct list_head lps_free_q ;
   struct list_head lps_active_q ;
   struct list_head lps_login_q ;
   struct bfa_lps_s *lps_arr ;
   int num_lps ;
    klee_make_symbolic(&num_lps, sizeof(int), "num_lps");
   struct bfa_mem_kva_s kva_seg ;
};
struct bfa_fcport_s;
struct bfa_fcport_ln_s {
   struct bfa_fcport_s *fcport ;
   void (*sm)(void * , int  ) ;
   struct bfa_cb_qe_s ln_qe ;
   enum bfa_port_linkstate ln_event ;
};
struct bfa_fcport_trunk_s {
   struct bfa_trunk_attr_s attr ;
};
union __anonunion_event_arg_311 {
   union bfi_fcport_i2h_msg_u i2hmsg ;
};
struct bfa_fcport_s {
   struct bfa_s *bfa ;
   void (*sm)(void * , int  ) ;
   wwn_t nwwn ;
   wwn_t pwwn ;
   enum bfa_port_speed speed_sup ;
   enum bfa_port_speed speed ;
   enum bfa_port_topology topology ;
   u8 rsvd[3U] ;
   u8 myalpa ;
   u8 alpabm_valid ;
   struct fc_alpabm_s alpabm ;
   struct bfa_port_cfg_s cfg ;
   enum bfa_boolean use_flash_cfg ;
   struct bfa_qos_attr_s qos_attr ;
   struct bfa_qos_vc_attr_s qos_vc_attr ;
   struct bfa_reqq_wait_s reqq_wait ;
   struct bfa_reqq_wait_s svcreq_wait ;
   struct bfa_reqq_wait_s stats_reqq_wait ;
   void *event_cbarg ;
   void (*event_cbfn)(void * , enum bfa_port_linkstate  ) ;
   union __anonunion_event_arg_311 event_arg ;
   void *bfad ;
   struct bfa_fcport_ln_s ln ;
   struct bfa_cb_qe_s hcb_qe ;
   struct bfa_timer_s timer ;
   u32 msgtag ;
   u8 *stats_kva ;
   u64 stats_pa ;
   union bfa_fcport_stats_u *stats ;
   enum bfa_status stats_status ;
   struct list_head stats_pending_q ;
   struct list_head statsclr_pending_q ;
   enum bfa_boolean stats_qfull ;
   u32 stats_reset_time ;
   enum bfa_boolean diag_busy ;
   enum bfa_boolean beacon ;
   enum bfa_boolean link_e2e_beacon ;
   struct bfa_fcport_trunk_s trunk ;
   u16 fcoe_vlan ;
   struct bfa_mem_dma_s fcport_dma ;
   enum bfa_boolean stats_dma_ready ;
   struct bfa_bbcr_attr_s bbcr_attr ;
   enum bfa_fec_state_s fec_state ;
};
struct bfa_fcdiag_qtest_s {
   struct bfa_diag_qtest_result_s *result ;
   void (*cbfn)(void * , enum bfa_status  ) ;
   void *cbarg ;
   struct bfa_timer_s timer ;
   u32 status ;
   u32 count ;
   u8 lock ;
   u8 queue ;
   u8 all ;
   u8 timer_active ;
};
struct bfa_fcdiag_lb_s {
   void (*cbfn)(void * , enum bfa_status  ) ;
   void *cbarg ;
   void *result ;
   enum bfa_boolean lock ;
   u32 status ;
};
struct bfa_dport_s {
   struct bfa_s *bfa ;
   void (*sm)(void * , int  ) ;
   struct bfa_reqq_wait_s reqq_wait ;
   void (*cbfn)(void * , enum bfa_status  ) ;
   void *cbarg ;
   union bfi_diag_dport_msg_u i2hmsg ;
   u8 test_state ;
   u8 dynamic ;
   u8 rsvd[2U] ;
   u32 lpcnt ;
   u32 payload ;
   wwn_t rp_pwwn ;
   wwn_t rp_nwwn ;
   struct bfa_diag_dport_result_s result ;
};
struct bfa_fcdiag_s {
   struct bfa_s *bfa ;
   struct bfa_trc_mod_s *trcmod ;
   struct bfa_fcdiag_lb_s lb ;
   struct bfa_fcdiag_qtest_s qtest ;
   struct bfa_dport_s dport ;
};
struct bfa_fcp_mod_s;
struct bfa_iotag_s {
   struct list_head qe ;
   u16 tag ;
};
struct bfa_itn_s {
   void (*isr)(struct bfa_s * , struct bfi_msg_s * ) ;
};
struct bfa_ioim_s;
struct bfa_tskim_s;
struct bfad_ioim_s;
struct bfad_tskim_s;
struct bfa_itnim_s;
struct bfa_ioim_sp_s;
struct bfa_fcpim_s {
   struct bfa_s *bfa ;
   struct bfa_fcp_mod_s *fcp ;
   struct bfa_itnim_s *itnim_arr ;
   struct bfa_ioim_s *ioim_arr ;
   struct bfa_ioim_sp_s *ioim_sp_arr ;
   struct bfa_tskim_s *tskim_arr ;
   int num_itnims ;
    klee_make_symbolic(&num_itnims, sizeof(int), "num_itnims");
   int num_tskim_reqs ;
    klee_make_symbolic(&num_tskim_reqs, sizeof(int), "num_tskim_reqs");
   u32 path_tov ;
   u16 q_depth ;
   u8 reqq ;
   struct list_head itnim_q ;
   struct list_head ioim_resfree_q ;
   struct list_head ioim_comp_q ;
   struct list_head tskim_free_q ;
   struct list_head tskim_unused_q ;
   u32 ios_active ;
   u32 delay_comp ;
   struct bfa_fcpim_del_itn_stats_s del_itn_stats ;
   enum bfa_boolean ioredirect ;
   enum bfa_boolean io_profile ;
   u32 io_profile_start_time ;
   void (*profile_comp)(struct bfa_ioim_s * ) ;
   void (*profile_start)(struct bfa_ioim_s * ) ;
};
struct bfa_fcp_mod_s {
   struct bfa_s *bfa ;
   struct list_head iotag_ioim_free_q ;
   struct list_head iotag_tio_free_q ;
   struct list_head iotag_unused_q ;
   struct bfa_iotag_s *iotag_arr ;
   struct bfa_itn_s *itn_arr ;
   int max_ioim_reqs ;
    klee_make_symbolic(&max_ioim_reqs, sizeof(int), "max_ioim_reqs");
   int num_ioim_reqs ;
    klee_make_symbolic(&num_ioim_reqs, sizeof(int), "num_ioim_reqs");
   int num_fwtio_reqs ;
    klee_make_symbolic(&num_fwtio_reqs, sizeof(int), "num_fwtio_reqs");
   int num_itns ;
    klee_make_symbolic(&num_itns, sizeof(int), "num_itns");
   struct bfa_dma_s snsbase[4U] ;
   struct bfa_fcpim_s fcpim ;
   struct bfa_mem_dma_s dma_seg[4U] ;
   struct bfa_mem_kva_s kva_seg ;
   int throttle_update_required ;
    klee_make_symbolic(&throttle_update_required, sizeof(int), "throttle_update_required");
};
struct bfa_ioim_s {
   struct list_head qe ;
   void (*sm)(void * , int  ) ;
   struct bfa_s *bfa ;
   struct bfa_fcpim_s *fcpim ;
   struct bfa_itnim_s *itnim ;
   struct bfad_ioim_s *dio ;
   u16 iotag ;
   u16 abort_tag ;
   u16 nsges ;
   u16 nsgpgs ;
   struct bfa_sgpg_s *sgpg ;
   struct list_head sgpg_q ;
   struct bfa_cb_qe_s hcb_qe ;
   void (*io_cbfn)(void * , enum bfa_boolean  ) ;
   struct bfa_ioim_sp_s *iosp ;
   u8 reqq ;
   u8 mode ;
   u64 start_time ;
};
struct bfa_ioim_sp_s {
   struct bfi_msg_s comp_rspmsg ;
   struct bfa_sgpg_wqe_s sgpg_wqe ;
   struct bfa_reqq_wait_s reqq_wait ;
   enum bfa_boolean abort_explicit ;
   struct bfa_tskim_s *tskim ;
};
struct bfa_tskim_s {
   struct list_head qe ;
   void (*sm)(void * , int  ) ;
   struct bfa_s *bfa ;
   struct bfa_fcpim_s *fcpim ;
   struct bfa_itnim_s *itnim ;
   struct bfad_tskim_s *dtsk ;
   enum bfa_boolean notify ;
   struct scsi_lun lun ;
   enum fcp_tm_cmnd tm_cmnd ;
   u16 tsk_tag ;
   u8 tsecs ;
   struct bfa_reqq_wait_s reqq_wait ;
   struct list_head io_q ;
   struct bfa_wc_s wc ;
   struct bfa_cb_qe_s hcb_qe ;
   enum bfi_tskim_status tsk_status ;
};
struct bfa_itnim_s {
   struct list_head qe ;
   void (*sm)(void * , int  ) ;
   struct bfa_s *bfa ;
   struct bfa_rport_s *rport ;
   void *ditn ;
   struct bfi_mhdr_s mhdr ;
   u8 msg_no ;
   u8 reqq ;
   struct bfa_cb_qe_s hcb_qe ;
   struct list_head pending_q ;
   struct list_head io_q ;
   struct list_head io_cleanup_q ;
   struct list_head tsk_q ;
   struct list_head delay_comp_q ;
   enum bfa_boolean seq_rec ;
   enum bfa_boolean is_online ;
   enum bfa_boolean iotov_active ;
   struct bfa_wc_s wc ;
   struct bfa_timer_s timer ;
   struct bfa_reqq_wait_s reqq_wait ;
   struct bfa_fcpim_s *fcpim ;
   struct bfa_itnim_iostats_s stats ;
   struct bfa_itnim_ioprofile_s ioprofile ;
};
struct bfa_port_s {
   void *dev ;
   struct bfa_ioc_s *ioc ;
   struct bfa_trc_mod_s *trcmod ;
   u32 msgtag ;
   enum bfa_boolean stats_busy ;
   struct bfa_mbox_cmd_s stats_mb ;
   void (*stats_cbfn)(void * , enum bfa_status  ) ;
   void *stats_cbarg ;
   enum bfa_status stats_status ;
   u32 stats_reset_time ;
   union bfa_port_stats_u *stats ;
   struct bfa_dma_s stats_dma ;
   enum bfa_boolean endis_pending ;
   struct bfa_mbox_cmd_s endis_mb ;
   void (*endis_cbfn)(void * , enum bfa_status  ) ;
   void *endis_cbarg ;
   enum bfa_status endis_status ;
   struct bfa_ioc_notify_s ioc_notify ;
   enum bfa_boolean pbc_disabled ;
   enum bfa_boolean dport_enabled ;
   struct bfa_mem_dma_s port_dma ;
};
struct bfa_cee_cbfn_s {
   void (*get_attr_cbfn)(void * , enum bfa_status  ) ;
   void *get_attr_cbarg ;
   void (*get_stats_cbfn)(void * , enum bfa_status  ) ;
   void *get_stats_cbarg ;
   void (*reset_stats_cbfn)(void * , enum bfa_status  ) ;
   void *reset_stats_cbarg ;
};
struct bfa_cee_s {
   void *dev ;
   enum bfa_boolean get_attr_pending ;
   enum bfa_boolean get_stats_pending ;
   enum bfa_boolean reset_stats_pending ;
   enum bfa_status get_attr_status ;
   enum bfa_status get_stats_status ;
   enum bfa_status reset_stats_status ;
   struct bfa_cee_cbfn_s cbfn ;
   struct bfa_ioc_notify_s ioc_notify ;
   struct bfa_trc_mod_s *trcmod ;
   struct bfa_cee_attr_s *attr ;
   struct bfa_cee_stats_s *stats ;
   struct bfa_dma_s attr_dma ;
   struct bfa_dma_s stats_dma ;
   struct bfa_ioc_s *ioc ;
   struct bfa_mbox_cmd_s get_cfg_mb ;
   struct bfa_mbox_cmd_s get_stats_mb ;
   struct bfa_mbox_cmd_s reset_stats_mb ;
   struct bfa_mem_dma_s cee_dma ;
};
struct bfa_modules_s {
   struct bfa_fcdiag_s fcdiag ;
   struct bfa_fcport_s fcport ;
   struct bfa_fcxp_mod_s fcxp_mod ;
   struct bfa_lps_mod_s lps_mod ;
   struct bfa_uf_mod_s uf_mod ;
   struct bfa_rport_mod_s rport_mod ;
   struct bfa_fcp_mod_s fcp_mod ;
   struct bfa_sgpg_mod_s sgpg_mod ;
   struct bfa_port_s port ;
   struct bfa_ablk_s ablk ;
   struct bfa_cee_s cee ;
   struct bfa_sfp_s sfp ;
   struct bfa_flash_s flash ;
   struct bfa_diag_s diag_mod ;
   struct bfa_phy_s phy ;
   struct bfa_dconf_mod_s dconf_mod ;
   struct bfa_fru_s fru ;
};
struct bfa_s {
   void *bfad ;
   struct bfa_plog_s *plog ;
   struct bfa_trc_mod_s *trcmod ;
   struct bfa_ioc_s ioc ;
   struct bfa_iocfc_s iocfc ;
   struct bfa_timer_mod_s timer_mod ;
   struct bfa_modules_s modules ;
   struct list_head comp_q ;
   enum bfa_boolean queue_process ;
   struct list_head reqq_waitq[4U] ;
   enum bfa_boolean fcs ;
   struct bfa_msix_s msix ;
   int bfa_aen_seq ;
    klee_make_symbolic(&bfa_aen_seq, sizeof(int), "bfa_aen_seq");
   enum bfa_boolean intr_enabled ;
};
struct bfa_vf_stats_s {
   u32 flogi_sent ;
   u32 flogi_rsp_err ;
   u32 flogi_acc_err ;
   u32 flogi_accepts ;
   u32 flogi_rejects ;
   u32 flogi_unknown_rsp ;
   u32 flogi_alloc_wait ;
   u32 flogi_rcvd ;
   u32 flogi_rejected ;
   u32 fabric_onlines ;
   u32 fabric_offlines ;
   u32 resvd ;
};
struct bfa_lport_symname_s {
   char symname[128U] ;
};
enum bfa_lport_role {
    BFA_LPORT_ROLE_FCP_IM = 1,
    BFA_LPORT_ROLE_FCP_MAX = 1
} ;
struct bfa_lport_cfg_s {
   wwn_t pwwn ;
   wwn_t nwwn ;
   struct bfa_lport_symname_s sym_name ;
   struct bfa_lport_symname_s node_sym_name ;
   enum bfa_lport_role roles ;
   u32 rsvd ;
   enum bfa_boolean preboot_vp ;
   u8 tag[16U] ;
   u8 padding[4U] ;
};
struct bfa_lport_stats_s {
   u32 ns_plogi_sent ;
   u32 ns_plogi_rsp_err ;
   u32 ns_plogi_acc_err ;
   u32 ns_plogi_accepts ;
   u32 ns_rejects ;
   u32 ns_plogi_unknown_rsp ;
   u32 ns_plogi_alloc_wait ;
   u32 ns_retries ;
   u32 ns_timeouts ;
   u32 ns_rspnid_sent ;
   u32 ns_rspnid_accepts ;
   u32 ns_rspnid_rsp_err ;
   u32 ns_rspnid_rejects ;
   u32 ns_rspnid_alloc_wait ;
   u32 ns_rftid_sent ;
   u32 ns_rftid_accepts ;
   u32 ns_rftid_rsp_err ;
   u32 ns_rftid_rejects ;
   u32 ns_rftid_alloc_wait ;
   u32 ns_rffid_sent ;
   u32 ns_rffid_accepts ;
   u32 ns_rffid_rsp_err ;
   u32 ns_rffid_rejects ;
   u32 ns_rffid_alloc_wait ;
   u32 ns_gidft_sent ;
   u32 ns_gidft_accepts ;
   u32 ns_gidft_rsp_err ;
   u32 ns_gidft_rejects ;
   u32 ns_gidft_unknown_rsp ;
   u32 ns_gidft_alloc_wait ;
   u32 ns_rnnid_sent ;
   u32 ns_rnnid_accepts ;
   u32 ns_rnnid_rsp_err ;
   u32 ns_rnnid_rejects ;
   u32 ns_rnnid_alloc_wait ;
   u32 ns_rsnn_nn_sent ;
   u32 ns_rsnn_nn_accepts ;
   u32 ns_rsnn_nn_rsp_err ;
   u32 ns_rsnn_nn_rejects ;
   u32 ns_rsnn_nn_alloc_wait ;
   u32 ms_retries ;
   u32 ms_timeouts ;
   u32 ms_plogi_sent ;
   u32 ms_plogi_rsp_err ;
   u32 ms_plogi_acc_err ;
   u32 ms_plogi_accepts ;
   u32 ms_rejects ;
   u32 ms_plogi_unknown_rsp ;
   u32 ms_plogi_alloc_wait ;
   u32 num_rscn ;
   u32 num_portid_rscn ;
   u32 uf_recvs ;
   u32 uf_recv_drops ;
   u32 plogi_rcvd ;
   u32 prli_rcvd ;
   u32 adisc_rcvd ;
   u32 prlo_rcvd ;
   u32 logo_rcvd ;
   u32 rpsc_rcvd ;
   u32 un_handled_els_rcvd ;
   u32 rport_plogi_timeouts ;
   u32 rport_del_max_plogi_retry ;
};
struct bfa_vport_stats_s {
   struct bfa_lport_stats_s port_stats ;
   u32 fdisc_sent ;
   u32 fdisc_accepts ;
   u32 fdisc_retries ;
   u32 fdisc_timeouts ;
   u32 fdisc_rsp_err ;
   u32 fdisc_acc_bad ;
   u32 fdisc_rejects ;
   u32 fdisc_unknown_rsp ;
   u32 fdisc_alloc_wait ;
   u32 logo_alloc_wait ;
   u32 logo_sent ;
   u32 logo_accepts ;
   u32 logo_rejects ;
   u32 logo_rsp_err ;
   u32 logo_unknown_rsp ;
   u32 fab_no_npiv ;
   u32 fab_offline ;
   u32 fab_online ;
   u32 fab_cleanup ;
   u32 rsvd ;
};
enum bfa_rport_function {
    BFA_RPORT_INITIATOR = 1,
    BFA_RPORT_TARGET = 2
} ;
struct bfa_rport_symname_s {
   char symname[255U] ;
};
struct bfa_rport_stats_s {
   u32 offlines ;
   u32 onlines ;
   u32 rscns ;
   u32 plogis ;
   u32 plogi_accs ;
   u32 plogi_timeouts ;
   u32 plogi_rejects ;
   u32 plogi_failed ;
   u32 plogi_rcvd ;
   u32 prli_rcvd ;
   u32 adisc_rcvd ;
   u32 adisc_rejects ;
   u32 adisc_sent ;
   u32 adisc_accs ;
   u32 adisc_failed ;
   u32 adisc_rejected ;
   u32 logos ;
   u32 logo_accs ;
   u32 logo_failed ;
   u32 logo_rejected ;
   u32 logo_rcvd ;
   u32 rpsc_rcvd ;
   u32 rpsc_rejects ;
   u32 rpsc_sent ;
   u32 rpsc_accs ;
   u32 rpsc_failed ;
   u32 rpsc_rejected ;
   u32 rjt_insuff_res ;
   struct bfa_rport_hal_stats_s hal_stats ;
};
struct bfa_itnim_stats_s {
   u32 onlines ;
   u32 offlines ;
   u32 prli_sent ;
   u32 fcxp_alloc_wait ;
   u32 prli_rsp_err ;
   u32 prli_rsp_acc ;
   u32 initiator ;
   u32 prli_rsp_parse_err ;
   u32 prli_rsp_rjt ;
   u32 timeout ;
   u32 sler ;
   u32 rsvd ;
};
struct bfa_fcs_s;
struct bfa_fcs_lport_s;
struct bfa_fcs_lport_ns_s {
   void (*sm)(void * , int  ) ;
   struct bfa_timer_s timer ;
   struct bfa_fcs_lport_s *port ;
   struct bfa_fcxp_s *fcxp ;
   struct bfa_fcxp_wqe_s fcxp_wqe ;
   u8 num_rnnid_retries ;
   u8 num_rsnn_nn_retries ;
};
struct bfa_fcs_lport_scn_s {
   void (*sm)(void * , int  ) ;
   struct bfa_timer_s timer ;
   struct bfa_fcs_lport_s *port ;
   struct bfa_fcxp_s *fcxp ;
   struct bfa_fcxp_wqe_s fcxp_wqe ;
};
struct bfa_fcs_lport_ms_s;
struct bfa_fcs_lport_fdmi_s {
   void (*sm)(void * , int  ) ;
   struct bfa_timer_s timer ;
   struct bfa_fcs_lport_ms_s *ms ;
   struct bfa_fcxp_s *fcxp ;
   struct bfa_fcxp_wqe_s fcxp_wqe ;
   u8 retry_cnt ;
   u8 rsvd[3U] ;
};
struct bfa_fcs_lport_ms_s {
   void (*sm)(void * , int  ) ;
   struct bfa_timer_s timer ;
   struct bfa_fcs_lport_s *port ;
   struct bfa_fcxp_s *fcxp ;
   struct bfa_fcxp_wqe_s fcxp_wqe ;
   struct bfa_fcs_lport_fdmi_s fdmi ;
   u8 retry_cnt ;
   u8 rsvd[3U] ;
};
struct bfa_fcs_lport_fab_s {
   struct bfa_fcs_lport_ns_s ns ;
   struct bfa_fcs_lport_scn_s scn ;
   struct bfa_fcs_lport_ms_s ms ;
};
struct bfa_fcs_lport_loop_s {
   u8 num_alpa ;
   u8 alpabm_valid ;
   u8 alpa_pos_map[127U] ;
   struct bfa_fcs_lport_s *port ;
};
struct bfa_fcs_lport_n2n_s {
   u32 rsvd ;
   __be16 reply_oxid ;
   wwn_t rem_port_wwn ;
};
union bfa_fcs_lport_topo_u {
   struct bfa_fcs_lport_fab_s pfab ;
   struct bfa_fcs_lport_loop_s ploop ;
   struct bfa_fcs_lport_n2n_s pn2n ;
};
struct bfa_fcs_fabric_s;
struct bfad_port_s;
struct bfa_fcs_vport_s;
struct bfa_fcs_lport_s {
   struct list_head qe ;
   void (*sm)(void * , int  ) ;
   struct bfa_fcs_fabric_s *fabric ;
   struct bfa_lport_cfg_s port_cfg ;
   struct bfa_timer_s link_timer ;
   unsigned int pid : 24 ;
   u8 lp_tag ;
   u16 num_rports ;
   struct list_head rport_q ;
   struct bfa_fcs_s *fcs ;
   union bfa_fcs_lport_topo_u port_topo ;
   struct bfad_port_s *bfad_port ;
   struct bfa_fcs_vport_s *vport ;
   struct bfa_fcxp_s *fcxp ;
   struct bfa_fcxp_wqe_s fcxp_wqe ;
   struct bfa_lport_stats_s stats ;
   struct bfa_wc_s wc ;
};
struct bfad_vf_s;
enum bfa_fcs_fabric_type {
    BFA_FCS_FABRIC_UNKNOWN = 0,
    BFA_FCS_FABRIC_SWITCHED = 1,
    BFA_FCS_FABRIC_N2N = 2,
    BFA_FCS_FABRIC_LOOP = 3
} ;
union __anonunion_event_arg_312 {
   u16 swp_vfid ;
};
struct bfa_fcs_fabric_s {
   struct list_head qe ;
   void (*sm)(void * , int  ) ;
   struct bfa_fcs_s *fcs ;
   struct bfa_fcs_lport_s bport ;
   enum bfa_fcs_fabric_type fab_type ;
   enum bfa_port_type oper_type ;
   u8 is_vf ;
   u8 is_npiv ;
   u8 is_auth ;
   u16 bb_credit ;
   u16 vf_id ;
   u16 num_vports ;
   u16 rsvd ;
   struct list_head vport_q ;
   struct list_head vf_q ;
   struct bfad_vf_s *vf_drv ;
   struct bfa_timer_s link_timer ;
   wwn_t fabric_name ;
   enum bfa_boolean auth_reqd ;
   struct bfa_timer_s delay_timer ;
   union __anonunion_event_arg_312 event_arg ;
   struct bfa_wc_s wc ;
   struct bfa_vf_stats_s stats ;
   struct bfa_lps_s *lps ;
   u8 fabric_ip_addr[16U] ;
   struct bfa_wc_s stop_wc ;
};
struct bfa_fcs_rport_s;
struct bfad_vport_s;
struct bfa_fcs_vport_s {
   struct list_head qe ;
   void (*sm)(void * , int  ) ;
   struct bfa_fcs_lport_s lport ;
   struct bfa_timer_s timer ;
   struct bfad_vport_s *vport_drv ;
   struct bfa_vport_stats_s vport_stats ;
   struct bfa_lps_s *lps ;
   int fdisc_retries ;
    klee_make_symbolic(&fdisc_retries, sizeof(int), "fdisc_retries");
};
struct bfad_rport_s;
struct bfa_fcs_itnim_s;
struct bfa_fcs_tin_s;
struct bfa_fcs_iprp_s;
struct bfa_fcs_rpf_s {
   void (*sm)(void * , int  ) ;
   struct bfa_fcs_rport_s *rport ;
   struct bfa_timer_s timer ;
   struct bfa_fcxp_s *fcxp ;
   struct bfa_fcxp_wqe_s fcxp_wqe ;
   int rpsc_retries ;
    klee_make_symbolic(&rpsc_retries, sizeof(int), "rpsc_retries");
   enum bfa_port_speed rpsc_speed ;
   enum bfa_port_speed assigned_speed ;
};
struct bfa_fcs_rport_s {
   struct list_head qe ;
   struct bfa_fcs_lport_s *port ;
   struct bfa_fcs_s *fcs ;
   struct bfad_rport_s *rp_drv ;
   u32 pid ;
   u32 old_pid ;
   u16 maxfrsize ;
   __be16 reply_oxid ;
   enum fc_cos fc_cos ;
   enum bfa_boolean cisc ;
   enum bfa_boolean prlo ;
   enum bfa_boolean plogi_pending ;
   wwn_t pwwn ;
   wwn_t nwwn ;
   struct bfa_rport_symname_s psym_name ;
   void (*sm)(void * , int  ) ;
   struct bfa_timer_s timer ;
   struct bfa_fcs_itnim_s *itnim ;
   struct bfa_fcs_tin_s *tin ;
   struct bfa_fcs_iprp_s *iprp ;
   struct bfa_rport_s *bfa_rport ;
   struct bfa_fcxp_s *fcxp ;
   int plogi_retries ;
    klee_make_symbolic(&plogi_retries, sizeof(int), "plogi_retries");
   int ns_retries ;
    klee_make_symbolic(&ns_retries, sizeof(int), "ns_retries");
   struct bfa_fcxp_wqe_s fcxp_wqe ;
   struct bfa_rport_stats_s stats ;
   enum bfa_rport_function scsi_function ;
   struct bfa_fcs_rpf_s rpf ;
   enum bfa_boolean scn_online ;
};
struct bfad_itnim_s;
struct bfa_fcs_itnim_s {
   void (*sm)(void * , int  ) ;
   struct bfa_fcs_rport_s *rport ;
   struct bfad_itnim_s *itnim_drv ;
   struct bfa_fcs_s *fcs ;
   struct bfa_timer_s timer ;
   struct bfa_itnim_s *bfa_itnim ;
   u32 prli_retries ;
   enum bfa_boolean seq_rec ;
   enum bfa_boolean rec_support ;
   enum bfa_boolean conf_comp ;
   enum bfa_boolean task_retry_id ;
   struct bfa_fcxp_wqe_s fcxp_wqe ;
   struct bfa_fcxp_s *fcxp ;
   struct bfa_itnim_stats_s stats ;
};
struct __anonstruct_uf_313 {
   u32 untagged ;
   u32 tagged ;
   u32 vfid_unknown ;
};
struct bfa_fcs_stats_s {
   struct __anonstruct_uf_313 uf ;
};
struct bfa_fcs_driver_info_s {
   u8 version[64U] ;
   u8 host_machine_name[64U] ;
   u8 host_os_name[64U] ;
   u8 host_os_patch[64U] ;
   u8 os_device_name[64U] ;
};
struct bfad_s;
struct bfa_fcs_s {
   struct bfa_s *bfa ;
   struct bfad_s *bfad ;
   struct bfa_trc_mod_s *trcmod ;
   enum bfa_boolean vf_enabled ;
   enum bfa_boolean fdmi_enabled ;
   enum bfa_boolean min_cfg ;
   u16 port_vfid ;
   struct bfa_fcs_driver_info_s driver_info ;
   struct bfa_fcs_fabric_s fabric ;
   struct bfa_fcs_stats_s stats ;
   struct bfa_wc_s wc ;
   int fcs_aen_seq ;
    klee_make_symbolic(&fcs_aen_seq, sizeof(int), "fcs_aen_seq");
   u32 num_rport_logins ;
};
struct bfad_msix_s {
   struct bfad_s *bfad ;
   struct msix_entry msix ;
   char name[32U] ;
};
enum bfad_port_pvb_type {
    BFAD_PORT_PHYS_BASE = 0,
    BFAD_PORT_PHYS_VPORT = 1,
    BFAD_PORT_VF_BASE = 2,
    BFAD_PORT_VF_VPORT = 3
} ;
struct bfad_im_port_s;
struct bfad_port_s {
   struct list_head list_entry ;
   struct bfad_s *bfad ;
   struct bfa_fcs_lport_s *fcs_port ;
   u32 roles ;
   s32 flags ;
   u32 supported_fc4s ;
   enum bfad_port_pvb_type pvb_type ;
   struct bfad_im_port_s *im_port ;
   struct dentry *port_debugfs_root ;
};
struct bfad_vport_s {
   struct bfad_port_s drv_port ;
   struct bfa_fcs_vport_s fcs_vport ;
   struct completion *comp_del ;
   struct list_head list_entry ;
};
struct bfad_vf_s {
   struct bfa_fcs_fabric_s fcs_vf ;
   struct bfad_port_s base_port ;
   struct bfad_s *bfad ;
};
struct bfad_cfg_param_s {
   u32 rport_del_timeout ;
   u32 ioc_queue_depth ;
   u32 lun_queue_depth ;
   u32 io_max_sge ;
   u32 binding_method ;
};
union bfad_tmp_buf {
   char manufacturer[8U] ;
   char serial_num[12U] ;
   char model[16U] ;
   char fw_ver[64U] ;
   char optrom_ver[64U] ;
   u8 chip_rev[8U] ;
   wwn_t wwn[256U] ;
};
struct bfad_im_s;
struct bfad_s {
   void (*sm)(void * , int  ) ;
   struct list_head list_entry ;
   struct bfa_s bfa ;
   struct bfa_fcs_s bfa_fcs ;
   struct pci_dev *pcidev ;
   char const   *pci_name ;
   struct bfa_pcidev_s hal_pcidev ;
   struct bfa_ioc_pci_attr_s pci_attr ;
   void *pci_bar0_kva ;
   void *pci_bar2_kva ;
   struct completion comp ;
   struct completion suspend ;
   struct completion enable_comp ;
   struct completion disable_comp ;
   enum bfa_boolean disable_active ;
   struct bfad_port_s pport ;
   struct bfa_meminfo_s meminfo ;
   struct bfa_iocfc_cfg_s ioc_cfg ;
   u32 inst_no ;
   u32 bfad_flags ;
   spinlock_t bfad_lock ;
   struct task_struct *bfad_tsk ;
   struct bfad_cfg_param_s cfg_data ;
   struct bfad_msix_s msix_tab[22U] ;
   int nvec ;
    klee_make_symbolic(&nvec, sizeof(int), "nvec");
   char adapter_name[64U] ;
   char port_name[64U] ;
   struct timer_list hal_tmo ;
   unsigned long hs_start ;
    klee_make_symbolic(&hs_start, sizeof(long), "hs_start");
   struct bfad_im_s *im ;
   struct bfa_trc_mod_s *trcmod ;
   struct bfa_plog_s plog_buf ;
   int ref_count ;
    klee_make_symbolic(&ref_count, sizeof(int), "ref_count");
   union bfad_tmp_buf tmp_buf ;
   struct fc_host_statistics link_stats ;
   struct list_head pbc_vport_list ;
   char *regdata ;
   u32 reglen ;
   struct dentry *bfad_dentry_files[5U] ;
   struct list_head free_aen_q ;
   struct list_head active_aen_q ;
   struct bfa_aen_entry_s aen_list[512U] ;
   spinlock_t bfad_aen_spinlock ;
   struct list_head vport_list ;
};
enum bfad_sm_event {
    BFAD_E_CREATE = 1,
    BFAD_E_KTHREAD_CREATE_FAILED = 2,
    BFAD_E_INIT = 3,
    BFAD_E_INIT_SUCCESS = 4,
    BFAD_E_HAL_INIT_FAILED = 5,
    BFAD_E_INIT_FAILED = 6,
    BFAD_E_FCS_EXIT_COMP = 7,
    BFAD_E_EXIT_COMP = 8,
    BFAD_E_STOP = 9
} ;
struct bfad_rport_s {
   struct bfa_fcs_rport_s fcs_rport ;
};
struct bfad_hal_comp {
   enum bfa_status status ;
   struct completion comp ;
};
struct bfad_im_port_s {
   struct bfad_s *bfad ;
   struct bfad_port_s *port ;
   struct work_struct port_delete_work ;
   int idr_id ;
    klee_make_symbolic(&idr_id, sizeof(int), "idr_id");
   u16 cur_scsi_id ;
   u16 flags ;
   struct list_head binding_list ;
   struct Scsi_Host *shost ;
   struct list_head itnim_mapped_list ;
   struct fc_vport *fc_vport ;
};
enum bfad_itnim_state {
    ITNIM_STATE_NONE = 0,
    ITNIM_STATE_ONLINE = 1,
    ITNIM_STATE_OFFLINE_PENDING = 2,
    ITNIM_STATE_OFFLINE = 3,
    ITNIM_STATE_TIMEOUT = 4,
    ITNIM_STATE_FREE = 5
} ;
struct bfad_itnim_s {
   struct list_head list_entry ;
   struct bfa_fcs_itnim_s fcs_itnim ;
   struct work_struct itnim_work ;
   u32 flags ;
   enum bfad_itnim_state state ;
   struct bfad_im_s *im ;
   struct bfad_im_port_s *im_port ;
   struct bfad_rport_s *drv_rport ;
   struct fc_rport *fc_rport ;
   struct bfa_itnim_s *bfa_itnim ;
   u16 scsi_tgt_id ;
   u16 channel ;
   u16 queue_work ;
   unsigned long last_ramp_up_time ;
    klee_make_symbolic(&last_ramp_up_time, sizeof(long), "last_ramp_up_time");
   unsigned long last_queue_full_time ;
};
struct bfad_im_s {
   struct bfad_s *bfad ;
   struct workqueue_struct *drv_workq ;
   char drv_workq_name[20U] ;
   struct work_struct aen_im_notify_work ;
};
typedef bool ldv_func_ret_type;
typedef bool ldv_func_ret_type___0;
typedef bool ldv_func_ret_type___1;
typedef bool ldv_func_ret_type___2;
typedef int ldv_func_ret_type___3;
    klee_make_symbolic(&ldv_func_ret_type___3, sizeof(int), "ldv_func_ret_type___3");
typedef int ldv_func_ret_type___4;
    klee_make_symbolic(&ldv_func_ret_type___4, sizeof(int), "ldv_func_ret_type___4");
typedef int ldv_func_ret_type___5;
    klee_make_symbolic(&ldv_func_ret_type___5, sizeof(int), "ldv_func_ret_type___5");
typedef int ldv_func_ret_type___6;
    klee_make_symbolic(&ldv_func_ret_type___6, sizeof(int), "ldv_func_ret_type___6");
typedef int ldv_func_ret_type___7;
    klee_make_symbolic(&ldv_func_ret_type___7, sizeof(int), "ldv_func_ret_type___7");
typedef int ldv_func_ret_type___8;
    klee_make_symbolic(&ldv_func_ret_type___8, sizeof(int), "ldv_func_ret_type___8");
typedef int ldv_func_ret_type___9;
    klee_make_symbolic(&ldv_func_ret_type___9, sizeof(int), "ldv_func_ret_type___9");
typedef int ldv_func_ret_type___10;
    klee_make_symbolic(&ldv_func_ret_type___10, sizeof(int), "ldv_func_ret_type___10");
typedef int ldv_func_ret_type___11;
    klee_make_symbolic(&ldv_func_ret_type___11, sizeof(int), "ldv_func_ret_type___11");
typedef int ldv_func_ret_type___12;
    klee_make_symbolic(&ldv_func_ret_type___12, sizeof(int), "ldv_func_ret_type___12");
typedef int ldv_func_ret_type___13;
    klee_make_symbolic(&ldv_func_ret_type___13, sizeof(int), "ldv_func_ret_type___13");
typedef int ldv_func_ret_type___14;
    klee_make_symbolic(&ldv_func_ret_type___14, sizeof(int), "ldv_func_ret_type___14");
typedef int ldv_func_ret_type___15;
    klee_make_symbolic(&ldv_func_ret_type___15, sizeof(int), "ldv_func_ret_type___15");
enum hrtimer_restart;
struct __wait_queue;
typedef struct __wait_queue wait_queue_t;
struct __wait_queue {
   unsigned int flags ;
   void *private ;
   int (*func)(wait_queue_t * , unsigned int  , int  , void * ) ;
   struct list_head task_list ;
};
enum fc_tgtid_binding_type {
    FC_TGTID_BIND_NONE = 0,
    FC_TGTID_BIND_BY_WWPN = 1,
    FC_TGTID_BIND_BY_WWNN = 2,
    FC_TGTID_BIND_BY_ID = 3
} ;
struct fc_rport_identifiers {
   u64 node_name ;
   u64 port_name ;
   u32 port_id ;
   u32 roles ;
};
struct fc_host_attrs {
   u64 node_name ;
   u64 port_name ;
   u64 permanent_port_name ;
   u32 supported_classes ;
   u8 supported_fc4s[32U] ;
   u32 supported_speeds ;
   u32 maxframe_size ;
   u16 max_npiv_vports ;
   char serial_number[80U] ;
   char manufacturer[80U] ;
   char model[256U] ;
   char model_description[256U] ;
   char hardware_version[64U] ;
   char driver_version[64U] ;
   char firmware_version[64U] ;
   char optionrom_version[64U] ;
   u32 port_id ;
   enum fc_port_type port_type ;
   enum fc_port_state port_state ;
   u8 active_fc4s[32U] ;
   u32 speed ;
   u64 fabric_name ;
   char symbolic_name[256U] ;
   char system_hostname[256U] ;
   u32 dev_loss_tmo ;
   enum fc_tgtid_binding_type tgtid_bind_type ;
   struct list_head rports ;
   struct list_head rport_bindings ;
   struct list_head vports ;
   u32 next_rport_number ;
   u32 next_target_id ;
   u32 next_vport_number ;
   u16 npiv_vports_inuse ;
   char work_q_name[20U] ;
   struct workqueue_struct *work_q ;
   char devloss_work_q_name[20U] ;
   struct workqueue_struct *devloss_work_q ;
   struct request_queue *rqst_q ;
};
struct fc_function_template {
   void (*get_rport_dev_loss_tmo)(struct fc_rport * ) ;
   void (*set_rport_dev_loss_tmo)(struct fc_rport * , u32  ) ;
   void (*get_starget_node_name)(struct scsi_target * ) ;
   void (*get_starget_port_name)(struct scsi_target * ) ;
   void (*get_starget_port_id)(struct scsi_target * ) ;
   void (*get_host_port_id)(struct Scsi_Host * ) ;
   void (*get_host_port_type)(struct Scsi_Host * ) ;
   void (*get_host_port_state)(struct Scsi_Host * ) ;
   void (*get_host_active_fc4s)(struct Scsi_Host * ) ;
   void (*get_host_speed)(struct Scsi_Host * ) ;
   void (*get_host_fabric_name)(struct Scsi_Host * ) ;
   void (*get_host_symbolic_name)(struct Scsi_Host * ) ;
   void (*set_host_system_hostname)(struct Scsi_Host * ) ;
   struct fc_host_statistics *(*get_fc_host_stats)(struct Scsi_Host * ) ;
   void (*reset_fc_host_stats)(struct Scsi_Host * ) ;
   int (*issue_fc_host_lip)(struct Scsi_Host * ) ;
   void (*dev_loss_tmo_callbk)(struct fc_rport * ) ;
   void (*terminate_rport_io)(struct fc_rport * ) ;
   void (*set_vport_symbolic_name)(struct fc_vport * ) ;
   int (*vport_create)(struct fc_vport * , bool  ) ;
   int (*vport_disable)(struct fc_vport * , bool  ) ;
   int (*vport_delete)(struct fc_vport * ) ;
   int (*tsk_mgmt_response)(struct Scsi_Host * , u64  , u64  , int  ) ;
   int (*it_nexus_response)(struct Scsi_Host * , u64  , int  ) ;
   int (*bsg_request)(struct fc_bsg_job * ) ;
   int (*bsg_timeout)(struct fc_bsg_job * ) ;
   u32 dd_fcrport_size ;
   u32 dd_fcvport_size ;
   u32 dd_bsg_size ;
   unsigned char show_rport_maxframe_size : 1 ;
   unsigned char show_rport_supported_classes : 1 ;
   unsigned char show_rport_dev_loss_tmo : 1 ;
   unsigned char show_starget_node_name : 1 ;
   unsigned char show_starget_port_name : 1 ;
   unsigned char show_starget_port_id : 1 ;
   unsigned char show_host_node_name : 1 ;
   unsigned char show_host_port_name : 1 ;
   unsigned char show_host_permanent_port_name : 1 ;
   unsigned char show_host_supported_classes : 1 ;
   unsigned char show_host_supported_fc4s : 1 ;
   unsigned char show_host_supported_speeds : 1 ;
   unsigned char show_host_maxframe_size : 1 ;
   unsigned char show_host_serial_number : 1 ;
   unsigned char show_host_manufacturer : 1 ;
   unsigned char show_host_model : 1 ;
   unsigned char show_host_model_description : 1 ;
   unsigned char show_host_hardware_version : 1 ;
   unsigned char show_host_driver_version : 1 ;
   unsigned char show_host_firmware_version : 1 ;
   unsigned char show_host_optionrom_version : 1 ;
   unsigned char show_host_port_id : 1 ;
   unsigned char show_host_port_type : 1 ;
   unsigned char show_host_port_state : 1 ;
   unsigned char show_host_active_fc4s : 1 ;
   unsigned char show_host_speed : 1 ;
   unsigned char show_host_fabric_name : 1 ;
   unsigned char show_host_symbolic_name : 1 ;
   unsigned char show_host_system_hostname : 1 ;
   unsigned char disable_target_scan : 1 ;
};
union __anonunion_w_281 {
   u64 wwn ;
   u8 byte[8U] ;
};
union __anonunion_f_283 {
   u32 fcid ;
   u8 byte[4U] ;
};
struct bfa_adapter_attr_s {
   char manufacturer[8U] ;
   char serial_num[12U] ;
   u32 card_type ;
   char model[16U] ;
   char model_descr[128U] ;
   wwn_t pwwn ;
   char node_symname[256U] ;
   char hw_ver[64U] ;
   char fw_ver[64U] ;
   char optrom_ver[64U] ;
   char os_type[64U] ;
   struct bfa_mfg_vpd_s vpd ;
   struct mac_s mac ;
   u8 nports ;
   u8 max_speed ;
   u8 prototype ;
   char asic_rev ;
   u8 pcie_gen ;
   u8 pcie_lanes_orig ;
   u8 pcie_lanes ;
   u8 cna_capable ;
   u8 is_mezz ;
   u8 trunk_capable ;
   u8 mfg_day ;
   u8 mfg_month ;
   u16 mfg_year ;
   u16 rsvd ;
   u8 uuid[16U] ;
};
struct bfa_ioc_driver_attr_s {
   char driver[16U] ;
   char driver_ver[64U] ;
   char fw_ver[64U] ;
   char bios_ver[64U] ;
   char efi_ver[64U] ;
   char ob_ver[64U] ;
};
enum bfa_ioc_state {
    BFA_IOC_UNINIT = 1,
    BFA_IOC_RESET = 2,
    BFA_IOC_SEMWAIT = 3,
    BFA_IOC_HWINIT = 4,
    BFA_IOC_GETATTR = 5,
    BFA_IOC_OPERATIONAL = 6,
    BFA_IOC_INITFAIL = 7,
    BFA_IOC_FAIL = 8,
    BFA_IOC_DISABLING = 9,
    BFA_IOC_DISABLED = 10,
    BFA_IOC_FWMISMATCH = 11,
    BFA_IOC_ENABLING = 12,
    BFA_IOC_HWFAIL = 13,
    BFA_IOC_ACQ_ADDR = 14
} ;
enum bfa_ioc_type_e {
    BFA_IOC_TYPE_FC = 1,
    BFA_IOC_TYPE_FCoE = 2,
    BFA_IOC_TYPE_LL = 3
} ;
struct bfa_ioc_attr_s {
   enum bfa_ioc_type_e ioc_type ;
   enum bfa_ioc_state state ;
   struct bfa_adapter_attr_s adapter_attr ;
   struct bfa_ioc_driver_attr_s driver_attr ;
   struct bfa_ioc_pci_attr_s pci_attr ;
   u8 port_id ;
   u8 port_mode ;
   u8 cap_bm ;
   u8 port_mode_cfg ;
   u8 def_fn ;
   u8 rsvd[3U] ;
};
enum bfi_ioim_status {
    BFI_IOIM_STS_OK = 0,
    BFI_IOIM_STS_HOST_ABORTED = 1,
    BFI_IOIM_STS_ABORTED = 2,
    BFI_IOIM_STS_TIMEDOUT = 3,
    BFI_IOIM_STS_RES_FREE = 4,
    BFI_IOIM_STS_SQER_NEEDED = 5,
    BFI_IOIM_STS_PROTO_ERR = 6,
    BFI_IOIM_STS_UTAG = 7,
    BFI_IOIM_STS_PATHTOV = 8
} ;
struct bfad_itnim_data_s {
   struct bfad_itnim_s *itnim ;
};
enum bfad_binding_type {
    FCP_PWWN_BINDING = 1,
    FCP_NWWN_BINDING = 2,
    FCP_FCID_BINDING = 3
} ;
struct bfad_fcp_binding {
   struct list_head list_entry ;
   enum bfad_binding_type binding_type ;
   u16 scsi_target_id ;
   u32 fc_id ;
   wwn_t nwwn ;
   wwn_t pwwn ;
};
typedef struct Scsi_Host *ldv_func_ret_type___16;
typedef __u16 uint16_t;
enum hrtimer_restart;
struct fc_starget_attrs {
   u64 node_name ;
   u64 port_name ;
   u32 port_id ;
};
struct fc_symname_s {
   u8 symname[256U] ;
};
enum bfa_port_states {
    BFA_PORT_ST_UNINIT = 1,
    BFA_PORT_ST_ENABLING_QWAIT = 2,
    BFA_PORT_ST_ENABLING = 3,
    BFA_PORT_ST_LINKDOWN = 4,
    BFA_PORT_ST_LINKUP = 5,
    BFA_PORT_ST_DISABLING_QWAIT = 6,
    BFA_PORT_ST_DISABLING = 7,
    BFA_PORT_ST_DISABLED = 8,
    BFA_PORT_ST_STOPPED = 9,
    BFA_PORT_ST_IOCDOWN = 10,
    BFA_PORT_ST_IOCDIS = 11,
    BFA_PORT_ST_FWMISMATCH = 12,
    BFA_PORT_ST_PREBOOT_DISABLED = 13,
    BFA_PORT_ST_TOGGLING_QWAIT = 14,
    BFA_PORT_ST_FAA_MISCONFIG = 15,
    BFA_PORT_ST_DPORT = 16,
    BFA_PORT_ST_DDPORT = 17,
    BFA_PORT_ST_MAX_STATE = 18
} ;
struct bfa_port_attr_s {
   wwn_t nwwn ;
   wwn_t pwwn ;
   wwn_t factorynwwn ;
   wwn_t factorypwwn ;
   enum fc_cos cos_supported ;
   u32 rsvd ;
   struct fc_symname_s port_symname ;
   enum bfa_port_speed speed_supported ;
   enum bfa_boolean pbind_enabled ;
   struct bfa_port_cfg_s pport_cfg ;
   enum bfa_port_states port_state ;
   enum bfa_port_speed speed ;
   enum bfa_port_topology topology ;
   enum bfa_boolean beacon ;
   enum bfa_boolean link_e2e_beacon ;
   enum bfa_boolean bbsc_op_status ;
   enum bfa_fec_state_s fec_state ;
   u32 pid ;
   enum bfa_port_type port_type ;
   u32 loopback ;
   u32 authfail ;
   u16 fcoe_vlan ;
   u8 rsvd1[2U] ;
};
enum bfa_lport_state {
    BFA_LPORT_UNINIT = 0,
    BFA_LPORT_FDISC = 1,
    BFA_LPORT_ONLINE = 2,
    BFA_LPORT_OFFLINE = 3
} ;
struct bfa_lport_attr_s {
   enum bfa_lport_state state ;
   u32 pid ;
   struct bfa_lport_cfg_s port_cfg ;
   enum bfa_port_type port_type ;
   u32 loopback ;
   wwn_t fabric_name ;
   u8 fabric_ip_addr[16U] ;
   struct mac_s fpma_mac ;
   u16 authfail ;
};
struct bfa_rport_qualifier_s {
   wwn_t pwwn ;
   u32 pid ;
   u32 rsvd ;
};
enum hrtimer_restart;
struct bfad_debug_info {
   char *debug_buffer ;
   void *i_private ;
   int buffer_len ;
    klee_make_symbolic(&buffer_len, sizeof(int), "buffer_len");
};
enum hrtimer_restart;
struct bfa_fw_ioc_stats_s {
   u32 enable_reqs ;
   u32 disable_reqs ;
   u32 get_attr_reqs ;
   u32 dbg_sync ;
   u32 dbg_dump ;
   u32 unknown_reqs ;
};
struct bfa_ioc_stats_s {
   struct bfa_ioc_drv_stats_s drv_stats ;
   struct bfa_fw_ioc_stats_s fw_stats ;
};
struct bfa_boot_bootlun_s {
   wwn_t pwwn ;
   struct scsi_lun lun ;
};
struct bfa_boot_cfg_s {
   u8 version ;
   u8 rsvd1 ;
   u16 chksum ;
   u8 enable ;
   u8 speed ;
   u8 topology ;
   u8 bootopt ;
   u32 nbluns ;
   u32 rsvd2 ;
   struct bfa_boot_bootlun_s blun[4U] ;
   struct bfa_boot_bootlun_s blun_disc[4U] ;
};
struct bfa_boot_pbc_s {
   u8 enable ;
   u8 speed ;
   u8 topology ;
   u8 rsvd1 ;
   u32 nbluns ;
   struct bfa_boot_bootlun_s pblun[8U] ;
};
struct bfa_ethboot_cfg_s {
   u8 version ;
   u8 rsvd1 ;
   u16 chksum ;
   u8 enable ;
   u8 rsvd2 ;
   u16 vlan ;
};
struct bfa_adapter_cfg_mode_s {
   u16 max_pf ;
   u16 max_vf ;
   enum bfa_mode_s mode ;
};
enum bfa_flash_part_type {
    BFA_FLASH_PART_OPTROM = 1,
    BFA_FLASH_PART_FWIMG = 2,
    BFA_FLASH_PART_FWCFG = 3,
    BFA_FLASH_PART_DRV = 4,
    BFA_FLASH_PART_BOOT = 5,
    BFA_FLASH_PART_ASIC = 6,
    BFA_FLASH_PART_MFG = 7,
    BFA_FLASH_PART_OPTROM2 = 8,
    BFA_FLASH_PART_VPD = 9,
    BFA_FLASH_PART_PBC = 10,
    BFA_FLASH_PART_BOOTOVL = 11,
    BFA_FLASH_PART_LOG = 12,
    BFA_FLASH_PART_PXECFG = 13,
    BFA_FLASH_PART_PXEOVL = 14,
    BFA_FLASH_PART_PORTCFG = 15,
    BFA_FLASH_PART_ASICBK = 16
} ;
struct bfa_flash_part_attr_s {
   u32 part_type ;
   u32 part_instance ;
   u32 part_off ;
   u32 part_size ;
   u32 part_len ;
   u32 part_status ;
   char rsv[8U] ;
};
struct bfa_flash_attr_s {
   u32 status ;
   u32 npart ;
   struct bfa_flash_part_attr_s part[32U] ;
};
struct bfa_diag_memtest_s {
   u8 algo ;
   u8 rsvd[7U] ;
};
struct bfa_diag_memtest_result {
   u32 status ;
   u32 addr ;
   u32 exp ;
   u32 act ;
   u32 err_status ;
   u32 err_status1 ;
   u32 err_addr ;
   u8 algo ;
   u8 rsv[3U] ;
};
struct bfa_diag_loopback_result_s {
   u32 numtxmfrm ;
   u32 numosffrm ;
   u32 numrcvfrm ;
   u32 badfrminf ;
   u32 badfrmnum ;
   u8 status ;
   u8 rsvd[3U] ;
};
struct bfa_diag_ledtest_s {
   u32 cmd ;
   u32 color ;
   u16 freq ;
   u8 led ;
   u8 rsvd[5U] ;
};
struct bfa_phy_attr_s {
   u32 status ;
   u32 length ;
   u32 fw_ver ;
   u32 an_status ;
   u32 pma_pmd_status ;
   u32 pma_pmd_signal ;
   u32 pcs_status ;
};
struct bfa_phy_stats_s {
   u32 status ;
   u32 link_breaks ;
   u32 pma_pmd_fault ;
   u32 pcs_fault ;
   u32 speed_neg ;
   u32 tx_eq_training ;
   u32 tx_eq_timeout ;
   u32 crc_error ;
};
struct bfa_iocfc_attr_s {
   struct bfa_iocfc_cfg_s config ;
   struct bfa_iocfc_intr_attr_s intr_attr ;
};
enum bfa_port_opmode {
    BFA_PORT_OPMODE_NORMAL = 0,
    BFA_PORT_OPMODE_LB_INT = 1,
    BFA_PORT_OPMODE_LB_SLW = 2,
    BFA_PORT_OPMODE_LB_EXT = 4,
    BFA_PORT_OPMODE_LB_CBL = 8,
    BFA_PORT_OPMODE_LB_NLINT = 32
} ;
struct bfa_defs_fcpim_throttle_s {
   u16 max_value ;
   u16 cur_value ;
   u16 cfg_value ;
   u16 rsvd ;
};
struct bfa_vhba_attr_s {
   wwn_t nwwn ;
   wwn_t pwwn ;
   u32 pid ;
   enum bfa_boolean io_profile ;
   enum bfa_boolean plog_enabled ;
   u16 path_tov ;
   u8 rsvd[2U] ;
};
struct bfa_port_cfg_mode_s {
   u16 max_pf ;
   u16 max_vf ;
   enum bfa_mode_s mode ;
};
struct bfa_cb_pending_q_s {
   struct bfa_cb_qe_s hcb_qe ;
   void *data ;
};
enum bfa_vport_state {
    BFA_FCS_VPORT_UNINIT = 0,
    BFA_FCS_VPORT_CREATED = 1,
    BFA_FCS_VPORT_OFFLINE = 1,
    BFA_FCS_VPORT_FDISC_SEND = 2,
    BFA_FCS_VPORT_FDISC = 3,
    BFA_FCS_VPORT_FDISC_RETRY = 4,
    BFA_FCS_VPORT_FDISC_RSP_WAIT = 5,
    BFA_FCS_VPORT_ONLINE = 6,
    BFA_FCS_VPORT_DELETING = 7,
    BFA_FCS_VPORT_CLEANUP = 8,
    BFA_FCS_VPORT_LOGO_SEND = 9,
    BFA_FCS_VPORT_LOGO = 10,
    BFA_FCS_VPORT_ERROR = 11,
    BFA_FCS_VPORT_MAX_STATE = 12
} ;
struct bfa_vport_attr_s {
   struct bfa_lport_attr_s port_attr ;
   enum bfa_vport_state vport_state ;
   u32 rsvd ;
};
enum bfa_rport_state {
    BFA_RPORT_UNINIT = 0,
    BFA_RPORT_OFFLINE = 1,
    BFA_RPORT_PLOGI = 2,
    BFA_RPORT_ONLINE = 3,
    BFA_RPORT_PLOGI_RETRY = 4,
    BFA_RPORT_NSQUERY = 5,
    BFA_RPORT_ADISC = 6,
    BFA_RPORT_LOGO = 7,
    BFA_RPORT_LOGORCV = 8,
    BFA_RPORT_NSDISC = 9
} ;
struct bfa_rport_attr_s {
   wwn_t nwwn ;
   wwn_t pwwn ;
   enum fc_cos cos_supported ;
   u32 pid ;
   u32 df_sz ;
   enum bfa_rport_state state ;
   enum fc_cos fc_cos ;
   enum bfa_boolean cisc ;
   struct bfa_rport_symname_s symname ;
   enum bfa_rport_function scsi_function ;
   struct bfa_rport_qos_attr_s qos_attr ;
   enum bfa_port_speed curr_speed ;
   enum bfa_boolean trl_enforced ;
   enum bfa_port_speed assigned_speed ;
};
enum bfa_itnim_state {
    BFA_ITNIM_OFFLINE = 0,
    BFA_ITNIM_PRLI_SEND = 1,
    BFA_ITNIM_PRLI_SENT = 2,
    BFA_ITNIM_PRLI_RETRY = 3,
    BFA_ITNIM_HCB_ONLINE = 4,
    BFA_ITNIM_ONLINE = 5,
    BFA_ITNIM_HCB_OFFLINE = 6,
    BFA_ITNIM_INITIATIOR = 7
} ;
struct bfa_itnim_attr_s {
   enum bfa_itnim_state state ;
   u8 retry ;
   u8 task_retry_id ;
   u8 rec_support ;
   u8 conf_comp ;
};
struct bfad_buf_info {
   void *virt ;
   dma_addr_t phys ;
   u32 size ;
};
struct bfad_fcxp {
   struct bfad_port_s *port ;
   struct bfa_rport_s *bfa_rport ;
   enum bfa_status req_status ;
   u16 tag ;
   u16 rsp_len ;
   u16 rsp_maxlen ;
   u8 use_ireqbuf ;
   u8 use_irspbuf ;
   u32 num_req_sgles ;
   u32 num_rsp_sgles ;
   struct fchs_s fchs ;
   void *reqbuf_info ;
   void *rspbuf_info ;
   struct bfa_sge_s *req_sge ;
   struct bfa_sge_s *rsp_sge ;
   void (*send_cbfn)(struct bfa_s * , struct bfa_fcxp_s * , void * , enum bfa_status  ,
                     u32  , u32  , struct fchs_s * ) ;
   void *send_cbarg ;
   void *bfa_fcxp ;
   struct completion comp ;
};
struct bfa_bsg_gen_s {
   enum bfa_status status ;
   u16 bfad_num ;
   u16 rsvd ;
};
struct bfa_bsg_portlogctl_s {
   enum bfa_status status ;
   u16 bfad_num ;
   u16 rsvd ;
   enum bfa_boolean ctl ;
   int inst_no ;
    klee_make_symbolic(&inst_no, sizeof(int), "inst_no");
};
struct bfa_bsg_fcpim_profile_s {
   enum bfa_status status ;
   u16 bfad_num ;
   u16 rsvd ;
};
struct bfa_bsg_itnim_ioprofile_s {
   enum bfa_status status ;
   u16 bfad_num ;
   u16 vf_id ;
   wwn_t lpwwn ;
   wwn_t rpwwn ;
   struct bfa_itnim_ioprofile_s ioprofile ;
};
struct bfa_bsg_fcport_stats_s {
   enum bfa_status status ;
   u16 bfad_num ;
   u16 rsvd ;
   union bfa_fcport_stats_u stats ;
};
struct bfa_bsg_ioc_name_s {
   enum bfa_status status ;
   u16 bfad_num ;
   u16 rsvd ;
   char name[64U] ;
};
struct bfa_bsg_ioc_info_s {
   enum bfa_status status ;
   u16 bfad_num ;
   u16 rsvd ;
   char serialnum[64U] ;
   char hwpath[32U] ;
   char adapter_hwpath[32U] ;
   char guid[128U] ;
   char name[64U] ;
   char port_name[64U] ;
   char eth_name[64U] ;
   wwn_t pwwn ;
   wwn_t nwwn ;
   wwn_t factorypwwn ;
   wwn_t factorynwwn ;
   struct mac_s mac ;
   struct mac_s factory_mac ;
   struct mac_s current_mac ;
   enum bfa_ioc_type_e ioc_type ;
   u16 pvid ;
   u16 rsvd1 ;
   u32 host ;
   u32 bandwidth ;
   u32 rsvd2 ;
};
struct bfa_bsg_ioc_attr_s {
   enum bfa_status status ;
   u16 bfad_num ;
   u16 rsvd ;
   struct bfa_ioc_attr_s ioc_attr ;
};
struct bfa_bsg_ioc_stats_s {
   enum bfa_status status ;
   u16 bfad_num ;
   u16 rsvd ;
   struct bfa_ioc_stats_s ioc_stats ;
};
struct bfa_bsg_ioc_fwstats_s {
   enum bfa_status status ;
   u16 bfad_num ;
   u16 rsvd ;
   u32 buf_size ;
   u32 rsvd1 ;
   u64 buf_ptr ;
};
struct bfa_bsg_iocfc_attr_s {
   enum bfa_status status ;
   u16 bfad_num ;
   u16 rsvd ;
   struct bfa_iocfc_attr_s iocfc_attr ;
};
struct bfa_bsg_iocfc_intr_s {
   enum bfa_status status ;
   u16 bfad_num ;
   u16 rsvd ;
   struct bfa_iocfc_intr_attr_s attr ;
};
struct bfa_bsg_port_attr_s {
   enum bfa_status status ;
   u16 bfad_num ;
   u16 rsvd ;
   struct bfa_port_attr_s attr ;
};
struct bfa_bsg_port_cfg_s {
   enum bfa_status status ;
   u16 bfad_num ;
   u16 rsvd ;
   u32 param ;
   u32 rsvd1 ;
};
struct bfa_bsg_port_cfg_maxfrsize_s {
   enum bfa_status status ;
   u16 bfad_num ;
   u16 maxfrsize ;
};
struct bfa_bsg_port_stats_s {
   enum bfa_status status ;
   u16 bfad_num ;
   u16 rsvd ;
   u32 buf_size ;
   u32 rsvd1 ;
   u64 buf_ptr ;
};
struct bfa_bsg_lport_attr_s {
   enum bfa_status status ;
   u16 bfad_num ;
   u16 vf_id ;
   wwn_t pwwn ;
   struct bfa_lport_attr_s port_attr ;
};
struct bfa_bsg_lport_stats_s {
   enum bfa_status status ;
   u16 bfad_num ;
   u16 vf_id ;
   wwn_t pwwn ;
   struct bfa_lport_stats_s port_stats ;
};
struct bfa_bsg_lport_iostats_s {
   enum bfa_status status ;
   u16 bfad_num ;
   u16 vf_id ;
   wwn_t pwwn ;
   struct bfa_itnim_iostats_s iostats ;
};
struct bfa_bsg_lport_get_rports_s {
   enum bfa_status status ;
   u16 bfad_num ;
   u16 vf_id ;
   wwn_t pwwn ;
   u64 rbuf_ptr ;
   u32 nrports ;
   u32 rsvd ;
};
struct bfa_bsg_rport_attr_s {
   enum bfa_status status ;
   u16 bfad_num ;
   u16 vf_id ;
   wwn_t pwwn ;
   wwn_t rpwwn ;
   u32 pid ;
   u32 rsvd ;
   struct bfa_rport_attr_s attr ;
};
struct bfa_bsg_rport_stats_s {
   enum bfa_status status ;
   u16 bfad_num ;
   u16 vf_id ;
   wwn_t pwwn ;
   wwn_t rpwwn ;
   struct bfa_rport_stats_s stats ;
};
struct bfa_bsg_rport_scsi_addr_s {
   enum bfa_status status ;
   u16 bfad_num ;
   u16 vf_id ;
   wwn_t pwwn ;
   wwn_t rpwwn ;
   u32 host ;
   u32 bus ;
   u32 target ;
   u32 lun ;
};
struct bfa_bsg_rport_reset_stats_s {
   enum bfa_status status ;
   u16 bfad_num ;
   u16 vf_id ;
   wwn_t pwwn ;
   wwn_t rpwwn ;
};
struct bfa_bsg_rport_set_speed_s {
   enum bfa_status status ;
   u16 bfad_num ;
   u16 vf_id ;
   enum bfa_port_speed speed ;
   u32 rsvd ;
   wwn_t pwwn ;
   wwn_t rpwwn ;
};
struct bfa_bsg_vport_attr_s {
   enum bfa_status status ;
   u16 bfad_num ;
   u16 vf_id ;
   wwn_t vpwwn ;
   struct bfa_vport_attr_s vport_attr ;
};
struct bfa_bsg_vport_stats_s {
   enum bfa_status status ;
   u16 bfad_num ;
   u16 vf_id ;
   wwn_t vpwwn ;
   struct bfa_vport_stats_s vport_stats ;
};
struct bfa_bsg_reset_stats_s {
   enum bfa_status status ;
   u16 bfad_num ;
   u16 vf_id ;
   wwn_t vpwwn ;
};
struct bfa_bsg_fabric_get_lports_s {
   enum bfa_status status ;
   u16 bfad_num ;
   u16 vf_id ;
   u64 buf_ptr ;
   u32 nports ;
   u32 rsvd ;
};
struct bfa_bsg_trl_speed_s {
   enum bfa_status status ;
   u16 bfad_num ;
   u16 rsvd ;
   enum bfa_port_speed speed ;
};
struct bfa_bsg_fcpim_s {
   enum bfa_status status ;
   u16 bfad_num ;
   u16 param ;
};
struct bfa_bsg_fcpim_modstats_s {
   enum bfa_status status ;
   u16 bfad_num ;
   struct bfa_itnim_iostats_s modstats ;
};
struct bfa_bsg_fcpim_del_itn_stats_s {
   enum bfa_status status ;
   u16 bfad_num ;
   struct bfa_fcpim_del_itn_stats_s modstats ;
};
struct bfa_bsg_fcpim_modstatsclr_s {
   enum bfa_status status ;
   u16 bfad_num ;
};
struct bfa_bsg_itnim_attr_s {
   enum bfa_status status ;
   u16 bfad_num ;
   u16 vf_id ;
   wwn_t lpwwn ;
   wwn_t rpwwn ;
   struct bfa_itnim_attr_s attr ;
};
struct bfa_bsg_itnim_iostats_s {
   enum bfa_status status ;
   u16 bfad_num ;
   u16 vf_id ;
   wwn_t lpwwn ;
   wwn_t rpwwn ;
   struct bfa_itnim_iostats_s iostats ;
};
struct bfa_bsg_itnim_itnstats_s {
   enum bfa_status status ;
   u16 bfad_num ;
   u16 vf_id ;
   wwn_t lpwwn ;
   wwn_t rpwwn ;
   struct bfa_itnim_stats_s itnstats ;
};
struct bfa_bsg_pcifn_cfg_s {
   enum bfa_status status ;
   u16 bfad_num ;
   u16 rsvd ;
   struct bfa_ablk_cfg_s pcifn_cfg ;
};
struct bfa_bsg_pcifn_s {
   enum bfa_status status ;
   u16 bfad_num ;
   u16 pcifn_id ;
   u16 bw_min ;
   u16 bw_max ;
   u8 port ;
   enum bfi_pcifn_class pcifn_class ;
   u8 rsvd[1U] ;
};
struct bfa_bsg_adapter_cfg_mode_s {
   enum bfa_status status ;
   u16 bfad_num ;
   u16 rsvd ;
   struct bfa_adapter_cfg_mode_s cfg ;
};
struct bfa_bsg_port_cfg_mode_s {
   enum bfa_status status ;
   u16 bfad_num ;
   u16 instance ;
   struct bfa_port_cfg_mode_s cfg ;
};
struct bfa_bsg_bbcr_enable_s {
   enum bfa_status status ;
   u16 bfad_num ;
   u8 bb_scn ;
   u8 rsvd ;
};
struct bfa_bsg_bbcr_attr_s {
   enum bfa_status status ;
   u16 bfad_num ;
   u16 rsvd ;
   struct bfa_bbcr_attr_s attr ;
};
struct bfa_bsg_faa_attr_s {
   enum bfa_status status ;
   u16 bfad_num ;
   u16 rsvd ;
   struct bfa_faa_attr_s faa_attr ;
};
struct bfa_bsg_cee_attr_s {
   enum bfa_status status ;
   u16 bfad_num ;
   u16 rsvd ;
   u32 buf_size ;
   u32 rsvd1 ;
   u64 buf_ptr ;
};
struct bfa_bsg_cee_stats_s {
   enum bfa_status status ;
   u16 bfad_num ;
   u16 rsvd ;
   u32 buf_size ;
   u32 rsvd1 ;
   u64 buf_ptr ;
};
struct bfa_bsg_sfp_media_s {
   enum bfa_status status ;
   u16 bfad_num ;
   u16 rsvd ;
   enum bfa_defs_sfp_media_e media ;
};
struct bfa_bsg_sfp_speed_s {
   enum bfa_status status ;
   u16 bfad_num ;
   u16 rsvd ;
   enum bfa_port_speed speed ;
};
struct bfa_bsg_flash_attr_s {
   enum bfa_status status ;
   u16 bfad_num ;
   u16 rsvd ;
   struct bfa_flash_attr_s attr ;
};
struct bfa_bsg_flash_s {
   enum bfa_status status ;
   u16 bfad_num ;
   u8 instance ;
   u8 rsvd ;
   enum bfa_flash_part_type type ;
   int bufsz ;
    klee_make_symbolic(&bufsz, sizeof(int), "bufsz");
   u64 buf_ptr ;
};
struct bfa_bsg_diag_get_temp_s {
   enum bfa_status status ;
   u16 bfad_num ;
   u16 rsvd ;
   struct bfa_diag_results_tempsensor_s result ;
};
struct bfa_bsg_diag_memtest_s {
   enum bfa_status status ;
   u16 bfad_num ;
   u16 rsvd[3U] ;
   u32 pat ;
   struct bfa_diag_memtest_result result ;
   struct bfa_diag_memtest_s memtest ;
};
struct bfa_bsg_diag_loopback_s {
   enum bfa_status status ;
   u16 bfad_num ;
   u16 rsvd ;
   enum bfa_port_opmode opmode ;
   enum bfa_port_speed speed ;
   u32 lpcnt ;
   u32 pat ;
   struct bfa_diag_loopback_result_s result ;
};
struct bfa_bsg_diag_dport_show_s {
   enum bfa_status status ;
   u16 bfad_num ;
   u16 rsvd ;
   struct bfa_diag_dport_result_s result ;
};
struct bfa_bsg_dport_enable_s {
   enum bfa_status status ;
   u16 bfad_num ;
   u16 rsvd ;
   u16 lpcnt ;
   u16 pat ;
};
struct bfa_bsg_diag_fwping_s {
   enum bfa_status status ;
   u16 bfad_num ;
   u16 rsvd ;
   u32 cnt ;
   u32 pattern ;
   struct bfa_diag_results_fwping result ;
};
struct bfa_bsg_diag_qtest_s {
   enum bfa_status status ;
   u16 bfad_num ;
   u16 rsvd ;
   u32 force ;
   u32 queue ;
   struct bfa_diag_qtest_result_s result ;
};
struct bfa_bsg_sfp_show_s {
   enum bfa_status status ;
   u16 bfad_num ;
   u16 rsvd ;
   struct sfp_mem_s sfp ;
};
struct bfa_bsg_diag_led_s {
   enum bfa_status status ;
   u16 bfad_num ;
   u16 rsvd ;
   struct bfa_diag_ledtest_s ledtest ;
};
struct bfa_bsg_diag_beacon_s {
   enum bfa_status status ;
   u16 bfad_num ;
   u16 rsvd ;
   enum bfa_boolean beacon ;
   enum bfa_boolean link_e2e_beacon ;
   u32 second ;
};
struct bfa_bsg_diag_lb_stat_s {
   enum bfa_status status ;
   u16 bfad_num ;
   u16 rsvd ;
};
struct bfa_bsg_phy_attr_s {
   enum bfa_status status ;
   u16 bfad_num ;
   u16 instance ;
   struct bfa_phy_attr_s attr ;
};
struct bfa_bsg_phy_s {
   enum bfa_status status ;
   u16 bfad_num ;
   u16 instance ;
   u64 bufsz ;
   u64 buf_ptr ;
};
struct bfa_bsg_debug_s {
   enum bfa_status status ;
   u16 bfad_num ;
   u16 rsvd ;
   u32 bufsz ;
   int inst_no ;
   u64 buf_ptr ;
   u64 offset ;
};
struct bfa_bsg_phy_stats_s {
   enum bfa_status status ;
   u16 bfad_num ;
   u16 instance ;
   struct bfa_phy_stats_s stats ;
};
struct bfa_bsg_vhba_attr_s {
   enum bfa_status status ;
   u16 bfad_num ;
   u16 pcifn_id ;
   struct bfa_vhba_attr_s attr ;
};
struct bfa_bsg_boot_s {
   enum bfa_status status ;
   u16 bfad_num ;
   u16 rsvd ;
   struct bfa_boot_cfg_s cfg ;
};
struct bfa_bsg_preboot_s {
   enum bfa_status status ;
   u16 bfad_num ;
   u16 rsvd ;
   struct bfa_boot_pbc_s cfg ;
};
struct bfa_bsg_ethboot_s {
   enum bfa_status status ;
   u16 bfad_num ;
   u16 rsvd ;
   struct bfa_ethboot_cfg_s cfg ;
};
struct bfa_bsg_trunk_attr_s {
   enum bfa_status status ;
   u16 bfad_num ;
   u16 rsvd ;
   struct bfa_trunk_attr_s attr ;
};
struct bfa_bsg_qos_attr_s {
   enum bfa_status status ;
   u16 bfad_num ;
   u16 rsvd ;
   struct bfa_qos_attr_s attr ;
};
struct bfa_bsg_qos_vc_attr_s {
   enum bfa_status status ;
   u16 bfad_num ;
   u16 rsvd ;
   struct bfa_qos_vc_attr_s attr ;
};
struct bfa_bsg_qos_bw_s {
   enum bfa_status status ;
   u16 bfad_num ;
   u16 rsvd ;
   struct bfa_qos_bw_s qos_bw ;
};
struct bfa_bsg_vf_stats_s {
   enum bfa_status status ;
   u16 bfad_num ;
   u16 vf_id ;
   struct bfa_vf_stats_s stats ;
};
struct bfa_bsg_vf_reset_stats_s {
   enum bfa_status status ;
   u16 bfad_num ;
   u16 vf_id ;
};
struct bfa_bsg_fcpim_lunmask_query_s {
   enum bfa_status status ;
   u16 bfad_num ;
   struct bfa_lunmask_cfg_s lun_mask ;
};
struct bfa_bsg_fcpim_lunmask_s {
   enum bfa_status status ;
   u16 bfad_num ;
   u16 vf_id ;
   wwn_t pwwn ;
   wwn_t rpwwn ;
   struct scsi_lun lun ;
};
struct bfa_bsg_fcpim_throttle_s {
   enum bfa_status status ;
   u16 bfad_num ;
   u16 vf_id ;
   struct bfa_defs_fcpim_throttle_s throttle ;
};
struct bfa_bsg_tfru_s {
   enum bfa_status status ;
   u16 bfad_num ;
   u16 rsvd ;
   u32 offset ;
   u32 len ;
   u8 data[64U] ;
};
struct bfa_bsg_fruvpd_s {
   enum bfa_status status ;
   u16 bfad_num ;
   u16 rsvd1 ;
   u32 offset ;
   u32 len ;
   u8 data[4096U] ;
   u8 trfr_cmpl ;
   u8 rsvd2[3U] ;
};
struct bfa_bsg_fruvpd_max_size_s {
   enum bfa_status status ;
   u16 bfad_num ;
   u16 rsvd ;
   u32 max_size ;
};
struct bfa_bsg_fcpt_s {
   enum bfa_status status ;
   u16 vf_id ;
   wwn_t lpwwn ;
   wwn_t dpwwn ;
   u32 tsecs ;
   int cts ;
    klee_make_symbolic(&cts, sizeof(int), "cts");
   enum fc_cos cos ;
   struct fchs_s fchs ;
};
struct bfa_bsg_data {
   int payload_len ;
   u64 payload ;
};
enum hrtimer_restart;
struct bfa_sm_table_s {
   void (*sm)(void * , int  ) ;
   int state ;
   char *name ;
};
enum bfa_port_aen_event {
    BFA_PORT_AEN_ONLINE = 1,
    BFA_PORT_AEN_OFFLINE = 2,
    BFA_PORT_AEN_RLIR = 3,
    BFA_PORT_AEN_SFP_INSERT = 4,
    BFA_PORT_AEN_SFP_REMOVE = 5,
    BFA_PORT_AEN_SFP_POM = 6,
    BFA_PORT_AEN_ENABLE = 7,
    BFA_PORT_AEN_DISABLE = 8,
    BFA_PORT_AEN_AUTH_ON = 9,
    BFA_PORT_AEN_AUTH_OFF = 10,
    BFA_PORT_AEN_DISCONNECT = 11,
    BFA_PORT_AEN_QOS_NEG = 12,
    BFA_PORT_AEN_FABRIC_NAME_CHANGE = 13,
    BFA_PORT_AEN_SFP_ACCESS_ERROR = 14,
    BFA_PORT_AEN_SFP_UNSUPPORT = 15
} ;
enum bfa_audit_aen_event {
    BFA_AUDIT_AEN_AUTH_ENABLE = 1,
    BFA_AUDIT_AEN_AUTH_DISABLE = 2,
    BFA_AUDIT_AEN_FLASH_ERASE = 3,
    BFA_AUDIT_AEN_FLASH_UPDATE = 4
} ;
enum bfa_ioc_aen_event {
    BFA_IOC_AEN_HBGOOD = 1,
    BFA_IOC_AEN_HBFAIL = 2,
    BFA_IOC_AEN_ENABLE = 3,
    BFA_IOC_AEN_DISABLE = 4,
    BFA_IOC_AEN_FWMISMATCH = 5,
    BFA_IOC_AEN_FWCFG_ERROR = 6,
    BFA_IOC_AEN_INVALID_VENDOR = 7,
    BFA_IOC_AEN_INVALID_NWWN = 8,
    BFA_IOC_AEN_INVALID_PWWN = 9
} ;
struct __anonstruct_r_285 {
   unsigned char ib_cu_p : 1 ;
   unsigned char ib_cu_a : 1 ;
   unsigned char ib_lx : 1 ;
   unsigned char ib_sx : 1 ;
   unsigned char e10g_sr : 1 ;
   unsigned char e10g_lr : 1 ;
   unsigned char e10g_lrm : 1 ;
   unsigned char e10g_unall : 1 ;
};
union sfp_xcvr_e10g_code_u {
   u8 b ;
   struct __anonstruct_r_285 r ;
};
struct __anonstruct_r_286 {
   unsigned char escon : 2 ;
   unsigned char oc192_reach : 1 ;
   unsigned char so_reach : 2 ;
   unsigned char oc48_reach : 3 ;
};
union sfp_xcvr_so1_code_u {
   u8 b ;
   struct __anonstruct_r_286 r ;
};
struct __anonstruct_r_287 {
   unsigned char reserved : 1 ;
   unsigned char oc12_reach : 3 ;
   unsigned char reserved1 : 1 ;
   unsigned char oc3_reach : 3 ;
};
union sfp_xcvr_so2_code_u {
   u8 b ;
   struct __anonstruct_r_287 r ;
};
struct __anonstruct_r_288 {
   unsigned char base_px : 1 ;
   unsigned char base_bx10 : 1 ;
   unsigned char e100base_fx : 1 ;
   unsigned char e100base_lx : 1 ;
   unsigned char e1000base_t : 1 ;
   unsigned char e1000base_cx : 1 ;
   unsigned char e1000base_lx : 1 ;
   unsigned char e1000base_sx : 1 ;
};
union sfp_xcvr_eth_code_u {
   u8 b ;
   struct __anonstruct_r_288 r ;
};
struct sfp_xcvr_fc1_code_s {
   unsigned char link_len : 5 ;
   unsigned char xmtr_tech2 : 3 ;
   unsigned char xmtr_tech1 : 7 ;
   unsigned char reserved1 : 1 ;
};
struct __anonstruct_r_289 {
   unsigned char tw_media : 1 ;
   unsigned char tp_media : 1 ;
   unsigned char mi_media : 1 ;
   unsigned char tv_media : 1 ;
   unsigned char m6_media : 1 ;
   unsigned char m5_media : 1 ;
   unsigned char reserved : 1 ;
   unsigned char sm_media : 1 ;
};
union sfp_xcvr_fc2_code_u {
   u8 b ;
   struct __anonstruct_r_289 r ;
};
struct __anonstruct_r_290 {
   unsigned char mb100 : 1 ;
   unsigned char rsv1 : 1 ;
   unsigned char mb200 : 1 ;
   unsigned char rsv2 : 1 ;
   unsigned char mb400 : 1 ;
   unsigned char mb1600 : 1 ;
   unsigned char mb800 : 1 ;
   unsigned char rsv4 : 1 ;
};
union sfp_xcvr_fc3_code_u {
   u8 b ;
   struct __anonstruct_r_290 r ;
};
struct sfp_xcvr_s {
   union sfp_xcvr_e10g_code_u e10g ;
   union sfp_xcvr_so1_code_u so1 ;
   union sfp_xcvr_so2_code_u so2 ;
   union sfp_xcvr_eth_code_u eth ;
   struct sfp_xcvr_fc1_code_s fc1 ;
   union sfp_xcvr_fc2_code_u fc2 ;
   union sfp_xcvr_fc3_code_u fc3 ;
};
enum bfi_mclass {
    BFI_MC_IOC = 1,
    BFI_MC_DIAG = 2,
    BFI_MC_FLASH = 3,
    BFI_MC_CEE = 4,
    BFI_MC_FCPORT = 5,
    BFI_MC_IOCFC = 6,
    BFI_MC_ABLK = 7,
    BFI_MC_UF = 8,
    BFI_MC_FCXP = 9,
    BFI_MC_LPS = 10,
    BFI_MC_RPORT = 11,
    BFI_MC_ITN = 12,
    BFI_MC_IOIM_READ = 13,
    BFI_MC_IOIM_WRITE = 14,
    BFI_MC_IOIM_IO = 15,
    BFI_MC_IOIM = 16,
    BFI_MC_IOIM_IOCOM = 17,
    BFI_MC_TSKIM = 18,
    BFI_MC_PORT = 21,
    BFI_MC_SFP = 22,
    BFI_MC_PHY = 25,
    BFI_MC_FRU = 34,
    BFI_MC_MAX = 35
} ;
struct bfi_ioc_getattr_req_s {
   struct bfi_mhdr_s mh ;
   union bfi_addr_u attr_addr ;
};
struct bfi_ioc_fwver_s {
   uint8_t major ;
   uint8_t minor ;
   uint8_t maint ;
   uint8_t patch ;
   uint8_t phase ;
   uint8_t build ;
   uint8_t rsvd[2U] ;
};
struct bfi_ioc_image_hdr_s {
   u32 signature ;
   u8 asic_gen ;
   u8 asic_mode ;
   u8 port0_mode ;
   u8 port1_mode ;
   u32 exec ;
   u32 bootenv ;
   u32 rsvd_b[2U] ;
   struct bfi_ioc_fwver_s fwver ;
   u32 md5sum[4U] ;
};
enum bfi_ioc_img_ver_cmp_e {
    BFI_IOC_IMG_VER_INCOMP = 0,
    BFI_IOC_IMG_VER_OLD = 1,
    BFI_IOC_IMG_VER_SAME = 2,
    BFI_IOC_IMG_VER_BETTER = 3
} ;
struct bfi_ioc_ctrl_req_s {
   struct bfi_mhdr_s mh ;
   u16 clscode ;
   u16 rsvd ;
   u32 tv_sec ;
};
struct bfi_ioc_ctrl_reply_s {
   struct bfi_mhdr_s mh ;
   u8 status ;
   u8 port_mode ;
   u8 cap_bm ;
   u8 rsvd ;
};
union bfi_ioc_i2h_msg_u {
   struct bfi_mhdr_s mh ;
   struct bfi_ioc_ctrl_reply_s fw_event ;
   u32 mboxmsg[8U] ;
};
struct bfi_ablk_h2i_query_s {
   struct bfi_mhdr_s mh ;
   union bfi_addr_u addr ;
};
struct bfi_ablk_h2i_cfg_req_s {
   struct bfi_mhdr_s mh ;
   u8 mode ;
   u8 port ;
   u8 max_pf ;
   u8 max_vf ;
};
struct bfi_ablk_h2i_pf_req_s {
   struct bfi_mhdr_s mh ;
   u8 pcifn ;
   u8 port ;
   u16 pers ;
   u16 bw_min ;
   u16 bw_max ;
};
struct bfi_ablk_h2i_optrom_s {
   struct bfi_mhdr_s mh ;
};
struct bfi_ablk_i2h_rsp_s {
   struct bfi_mhdr_s mh ;
   u8 status ;
   u8 pcifn ;
   u8 port_mode ;
};
struct bfi_sfp_scn_s {
   struct bfi_mhdr_s mhr ;
   u8 event ;
   u8 sfpid ;
   u8 pomlvl ;
   u8 is_elb ;
};
struct bfi_sfp_req_s {
   struct bfi_mhdr_s mh ;
   u8 memtype ;
   u8 rsvd[3U] ;
   struct bfi_alen_s alen ;
};
struct bfi_sfp_rsp_s {
   struct bfi_mhdr_s mh ;
   u8 status ;
   u8 state ;
   u8 rsvd[2U] ;
};
struct bfi_flash_query_req_s {
   struct bfi_mhdr_s mh ;
   struct bfi_alen_s alen ;
};
struct bfi_flash_erase_req_s {
   struct bfi_mhdr_s mh ;
   u32 type ;
   u8 instance ;
   u8 rsv[3U] ;
};
struct bfi_flash_write_req_s {
   struct bfi_mhdr_s mh ;
   struct bfi_alen_s alen ;
   u32 type ;
   u8 instance ;
   u8 last ;
   u8 rsv[2U] ;
   u32 offset ;
   u32 length ;
};
struct bfi_flash_read_req_s {
   struct bfi_mhdr_s mh ;
   u32 type ;
   u8 instance ;
   u8 rsv[3U] ;
   u32 offset ;
   u32 length ;
   struct bfi_alen_s alen ;
};
struct bfi_flash_query_rsp_s {
   struct bfi_mhdr_s mh ;
   u32 status ;
};
struct bfi_flash_read_rsp_s {
   struct bfi_mhdr_s mh ;
   u32 type ;
   u8 instance ;
   u8 rsv[3U] ;
   u32 status ;
   u32 length ;
};
struct bfi_flash_write_rsp_s {
   struct bfi_mhdr_s mh ;
   u32 type ;
   u8 instance ;
   u8 rsv[3U] ;
   u32 status ;
   u32 length ;
};
struct bfi_flash_erase_rsp_s {
   struct bfi_mhdr_s mh ;
   u32 type ;
   u8 instance ;
   u8 rsv[3U] ;
   u32 status ;
};
struct bfi_flash_event_s {
   struct bfi_mhdr_s mh ;
   enum bfa_status status ;
   u32 param ;
};
struct bfi_diag_fwping_req_s {
   struct bfi_mhdr_s mh ;
   struct bfi_alen_s alen ;
   u32 data ;
   u32 count ;
   u8 qtag ;
   u8 rsv[3U] ;
};
struct bfi_diag_fwping_rsp_s {
   struct bfi_mhdr_s mh ;
   u32 data ;
   u8 qtag ;
   u8 dma_status ;
   u8 rsv[2U] ;
};
struct bfi_diag_ts_req_s {
   struct bfi_mhdr_s mh ;
   u16 temp ;
   u16 brd_temp ;
   u8 status ;
   u8 ts_junc ;
   u8 ts_brd ;
   u8 rsv ;
};
struct bfi_diag_ledtest_req_s {
   struct bfi_mhdr_s mh ;
   u8 cmd ;
   u8 color ;
   u8 portid ;
   u8 led ;
   u16 freq ;
   u8 rsv[2U] ;
};
struct bfi_diag_ledtest_rsp_s {
   struct bfi_mhdr_s mh ;
};
struct bfi_diag_portbeacon_req_s {
   struct bfi_mhdr_s mh ;
   u32 period ;
   u8 beacon ;
   u8 rsvd[3U] ;
};
struct bfi_phy_query_req_s {
   struct bfi_mhdr_s mh ;
   u8 instance ;
   u8 rsv[3U] ;
   struct bfi_alen_s alen ;
};
struct bfi_phy_stats_req_s {
   struct bfi_mhdr_s mh ;
   u8 instance ;
   u8 rsv[3U] ;
   struct bfi_alen_s alen ;
};
struct bfi_phy_write_req_s {
   struct bfi_mhdr_s mh ;
   u8 instance ;
   u8 last ;
   u8 rsv[2U] ;
   u32 offset ;
   u32 length ;
   struct bfi_alen_s alen ;
};
struct bfi_phy_read_req_s {
   struct bfi_mhdr_s mh ;
   u8 instance ;
   u8 rsv[3U] ;
   u32 offset ;
   u32 length ;
   struct bfi_alen_s alen ;
};
struct bfi_phy_query_rsp_s {
   struct bfi_mhdr_s mh ;
   u32 status ;
};
struct bfi_phy_stats_rsp_s {
   struct bfi_mhdr_s mh ;
   u32 status ;
};
struct bfi_phy_read_rsp_s {
   struct bfi_mhdr_s mh ;
   u32 status ;
   u32 length ;
};
struct bfi_phy_write_rsp_s {
   struct bfi_mhdr_s mh ;
   u32 status ;
   u32 length ;
};
enum bfi_fru_h2i_msgs {
    BFI_FRUVPD_H2I_WRITE_REQ = 1,
    BFI_FRUVPD_H2I_READ_REQ = 2,
    BFI_TFRU_H2I_WRITE_REQ = 3,
    BFI_TFRU_H2I_READ_REQ = 4
} ;
struct bfi_fru_write_req_s {
   struct bfi_mhdr_s mh ;
   u8 last ;
   u8 rsv_1[3U] ;
   u8 trfr_cmpl ;
   u8 rsv_2[3U] ;
   u32 offset ;
   u32 length ;
   struct bfi_alen_s alen ;
};
struct bfi_fru_read_req_s {
   struct bfi_mhdr_s mh ;
   u32 offset ;
   u32 length ;
   struct bfi_alen_s alen ;
};
struct bfi_fru_rsp_s {
   struct bfi_mhdr_s mh ;
   u32 status ;
   u32 length ;
};
typedef void (*bfa_ioc_mbox_mcfunc_t)(void * , struct bfi_mbmsg_s * );
struct bfa_module_s {
   void (*meminfo)(struct bfa_iocfc_cfg_s * , struct bfa_meminfo_s * , struct bfa_s * ) ;
   void (*attach)(struct bfa_s * , void * , struct bfa_iocfc_cfg_s * , struct bfa_pcidev_s * ) ;
   void (*detach)(struct bfa_s * ) ;
   void (*start)(struct bfa_s * ) ;
   void (*stop)(struct bfa_s * ) ;
   void (*iocdisable)(struct bfa_s * ) ;
};
enum ioc_event {
    IOC_E_RESET = 1,
    IOC_E_ENABLE = 2,
    IOC_E_DISABLE = 3,
    IOC_E_DETACH = 4,
    IOC_E_ENABLED = 5,
    IOC_E_FWRSP_GETATTR = 6,
    IOC_E_DISABLED = 7,
    IOC_E_PFFAILED = 8,
    IOC_E_HBFAIL = 9,
    IOC_E_HWERROR = 10,
    IOC_E_TIMEOUT = 11,
    IOC_E_HWFAILED = 12
} ;
enum iocpf_event {
    IOCPF_E_ENABLE = 1,
    IOCPF_E_DISABLE = 2,
    IOCPF_E_STOP = 3,
    IOCPF_E_FWREADY = 4,
    IOCPF_E_FWRSP_ENABLE = 5,
    IOCPF_E_FWRSP_DISABLE = 6,
    IOCPF_E_FAIL = 7,
    IOCPF_E_INITFAIL = 8,
    IOCPF_E_GETATTRFAIL = 9,
    IOCPF_E_SEMLOCKED = 10,
    IOCPF_E_TIMEOUT = 11,
    IOCPF_E_SEM_ERROR = 12
} ;
enum bfa_iocpf_state {
    BFA_IOCPF_RESET = 1,
    BFA_IOCPF_SEMWAIT = 2,
    BFA_IOCPF_HWINIT = 3,
    BFA_IOCPF_READY = 4,
    BFA_IOCPF_INITFAIL = 5,
    BFA_IOCPF_FAIL = 6,
    BFA_IOCPF_DISABLING = 7,
    BFA_IOCPF_DISABLED = 8,
    BFA_IOCPF_FWMISMATCH = 9
} ;
union __anonunion_m_304 {
   struct bfi_flash_query_rsp_s *query ;
   struct bfi_flash_erase_rsp_s *erase ;
   struct bfi_flash_write_rsp_s *write ;
   struct bfi_flash_read_rsp_s *read ;
   struct bfi_flash_event_s *event ;
   struct bfi_mbmsg_s *msg ;
};
union __anonunion_m_306 {
   struct bfi_phy_query_rsp_s *query ;
   struct bfi_phy_stats_rsp_s *stats ;
   struct bfi_phy_write_rsp_s *write ;
   struct bfi_phy_read_rsp_s *read ;
   struct bfi_mbmsg_s *msg ;
};
enum bfa_dconf_event {
    BFA_DCONF_SM_INIT = 1,
    BFA_DCONF_SM_FLASH_COMP = 2,
    BFA_DCONF_SM_WR = 3,
    BFA_DCONF_SM_TIMEOUT = 4,
    BFA_DCONF_SM_EXIT = 5,
    BFA_DCONF_SM_IOCDISABLE = 6
} ;
struct __anonstruct_r_307 {
   unsigned char cmd ;
    klee_make_symbolic(&cmd, sizeof(char), "cmd");
   unsigned char addr_cnt : 4 ;
   unsigned short read_cnt : 9 ;
   unsigned short write_cnt : 9 ;
   unsigned char rsv : 1 ;
   unsigned char act : 1 ;
};
union bfa_flash_cmd_reg_u {
   struct __anonstruct_r_307 r ;
   u32 i ;
};
struct __anonstruct_r_308 {
   unsigned char good : 1 ;
   unsigned char bad : 1 ;
   unsigned char present : 1 ;
   unsigned char init_status : 1 ;
   unsigned char busy : 1 ;
   unsigned char fifo_cnt : 6 ;
   unsigned int rsv : 21 ;
};
union bfa_flash_dev_status_reg_u {
   struct __anonstruct_r_308 r ;
   u32 i ;
};
struct __anonstruct_r_309 {
   unsigned char dummy ;
    klee_make_symbolic(&dummy, sizeof(char), "dummy");
   unsigned int addr : 24 ;
};
union bfa_flash_addr_reg_u {
   struct __anonstruct_r_309 r ;
   u32 i ;
};
enum hrtimer_restart;
struct __anonstruct_iocreg_fnreg_303 {
   u32 hfn_mbox ;
   u32 lpu_mbox ;
   u32 hfn_pgn ;
};
struct __anonstruct_iocreg_mbcmd_304 {
   u32 hfn ;
   u32 lpu ;
};
enum hrtimer_restart;
struct __anonstruct_ct_fnreg_303 {
   u32 hfn_mbox ;
   u32 lpu_mbox ;
   u32 hfn_pgn ;
};
struct __anonstruct_ct_p0reg_304 {
   u32 hfn ;
   u32 lpu ;
};
struct __anonstruct_ct_p1reg_305 {
   u32 hfn ;
   u32 lpu ;
};
struct __anonstruct_ct2_reg_306 {
   uint32_t hfn_mbox ;
   uint32_t lpu_mbox ;
   uint32_t hfn_pgn ;
   uint32_t hfn ;
   uint32_t lpu ;
   uint32_t lpu_read ;
};
enum hrtimer_restart;
enum hrtimer_restart;
enum hrtimer_restart;
union __anonunion_w_281___0 {
   u64 wwn ;
   u8 byte[8U] ;
};
struct fc_els_cmd_s {
   unsigned char els_code ;
    klee_make_symbolic(&els_code, sizeof(char), "els_code");
   unsigned int reserved : 24 ;
};
struct fc_plogi_csp_s {
   u8 verhi ;
   u8 verlo ;
   __be16 bbcred ;
   unsigned char reserved2 : 2 ;
   unsigned char resolution : 1 ;
   unsigned char altbbcred : 1 ;
   unsigned char port_type : 1 ;
   unsigned char npiv_supp : 1 ;
   unsigned char rro : 1 ;
   unsigned char ciro : 1 ;
   unsigned char payload : 1 ;
   unsigned char cisc : 1 ;
   unsigned char dh_dup_supp : 1 ;
   unsigned char r_t_tov : 1 ;
   unsigned char sync_cap : 1 ;
   unsigned char security : 1 ;
   unsigned char query_dbc : 1 ;
   unsigned char hg_supp : 1 ;
   __be16 rxsz ;
   __be16 conseq ;
   __be16 ro_bitmap ;
   __be32 e_d_tov ;
};
struct fc_plogi_clp_s {
   unsigned char reserved2 : 3 ;
   unsigned char sequential : 1 ;
   unsigned char reserved1 : 2 ;
   unsigned char intermix : 1 ;
   unsigned char class_valid : 1 ;
   unsigned int reserved3 : 24 ;
   unsigned short reserved4 ;
    klee_make_symbolic(&reserved4, sizeof(short), "reserved4");
   unsigned short rxsz ;
    klee_make_symbolic(&rxsz, sizeof(short), "rxsz");
   unsigned char reserved5 ;
    klee_make_symbolic(&reserved5, sizeof(char), "reserved5");
   unsigned char conseq ;
    klee_make_symbolic(&conseq, sizeof(char), "conseq");
   unsigned short e2e_credit ;
    klee_make_symbolic(&e2e_credit, sizeof(short), "e2e_credit");
   unsigned char reserved7 ;
    klee_make_symbolic(&reserved7, sizeof(char), "reserved7");
   unsigned char ospx ;
    klee_make_symbolic(&ospx, sizeof(char), "ospx");
   unsigned short reserved8 ;
    klee_make_symbolic(&reserved8, sizeof(short), "reserved8");
};
struct fc_logi_s {
   struct fc_els_cmd_s els_cmd ;
   struct fc_plogi_csp_s csp ;
   wwn_t port_name ;
   wwn_t node_name ;
   struct fc_plogi_clp_s class1 ;
   struct fc_plogi_clp_s class2 ;
   struct fc_plogi_clp_s class3 ;
   struct fc_plogi_clp_s class4 ;
   u8 vvl[16U] ;
};
struct fc_vft_s {
   unsigned char r_ctl ;
    klee_make_symbolic(&r_ctl, sizeof(char), "r_ctl");
   unsigned char ver : 2 ;
   unsigned char type : 4 ;
   unsigned char res_a : 2 ;
   unsigned char priority : 3 ;
   unsigned short vf_id : 12 ;
   unsigned char res_b : 1 ;
   unsigned char hopct ;
    klee_make_symbolic(&hopct, sizeof(char), "hopct");
   unsigned int res_c : 24 ;
};
enum bfa_fcs_fabric_event {
    BFA_FCS_FABRIC_SM_CREATE = 1,
    BFA_FCS_FABRIC_SM_DELETE = 2,
    BFA_FCS_FABRIC_SM_LINK_DOWN = 3,
    BFA_FCS_FABRIC_SM_LINK_UP = 4,
    BFA_FCS_FABRIC_SM_CONT_OP = 5,
    BFA_FCS_FABRIC_SM_RETRY_OP = 6,
    BFA_FCS_FABRIC_SM_NO_FABRIC = 7,
    BFA_FCS_FABRIC_SM_PERF_EVFP = 8,
    BFA_FCS_FABRIC_SM_ISOLATE = 9,
    BFA_FCS_FABRIC_SM_NO_TAGGING = 10,
    BFA_FCS_FABRIC_SM_DELAYED = 11,
    BFA_FCS_FABRIC_SM_AUTH_FAILED = 12,
    BFA_FCS_FABRIC_SM_AUTH_SUCCESS = 13,
    BFA_FCS_FABRIC_SM_DELCOMP = 14,
    BFA_FCS_FABRIC_SM_LOOPBACK = 15,
    BFA_FCS_FABRIC_SM_START = 16,
    BFA_FCS_FABRIC_SM_STOP = 17,
    BFA_FCS_FABRIC_SM_STOPCOMP = 18,
    BFA_FCS_FABRIC_SM_LOGOCOMP = 19
} ;
struct bfa_fcs_mod_s {
   void (*attach)(struct bfa_fcs_s * ) ;
   void (*modinit)(struct bfa_fcs_s * ) ;
   void (*modexit)(struct bfa_fcs_s * ) ;
};
enum hrtimer_restart;
union __anonunion_w_281___1 {
   u64 wwn ;
   u8 byte[8U] ;
};
struct fc_scr_s {
   unsigned char command ;
    klee_make_symbolic(&command, sizeof(char), "command");
   unsigned int res : 24 ;
   unsigned char vu_reg_func ;
    klee_make_symbolic(&vu_reg_func, sizeof(char), "vu_reg_func");
   unsigned short res1 ;
    klee_make_symbolic(&res1, sizeof(short), "res1");
   unsigned char reg_func ;
    klee_make_symbolic(&reg_func, sizeof(char), "reg_func");
};
struct fc_ls_rjt_s {
   struct fc_els_cmd_s els_cmd ;
   unsigned char res1 ;
   unsigned char reason_code ;
    klee_make_symbolic(&reason_code, sizeof(char), "reason_code");
   unsigned char reason_code_expl ;
    klee_make_symbolic(&reason_code_expl, sizeof(char), "reason_code_expl");
   unsigned char vendor_unique ;
    klee_make_symbolic(&vendor_unique, sizeof(char), "vendor_unique");
};
struct fc_ba_acc_s {
   unsigned char seq_id_valid ;
    klee_make_symbolic(&seq_id_valid, sizeof(char), "seq_id_valid");
   unsigned char seq_id ;
    klee_make_symbolic(&seq_id, sizeof(char), "seq_id");
   unsigned short res2 ;
    klee_make_symbolic(&res2, sizeof(short), "res2");
   unsigned short ox_id ;
    klee_make_symbolic(&ox_id, sizeof(short), "ox_id");
   unsigned short rx_id ;
    klee_make_symbolic(&rx_id, sizeof(short), "rx_id");
   unsigned short low_seq_cnt ;
    klee_make_symbolic(&low_seq_cnt, sizeof(short), "low_seq_cnt");
   unsigned short high_seq_cnt ;
    klee_make_symbolic(&high_seq_cnt, sizeof(short), "high_seq_cnt");
};
enum fc_rscn_format {
    FC_RSCN_FORMAT_PORTID = 0,
    FC_RSCN_FORMAT_AREA = 1,
    FC_RSCN_FORMAT_DOMAIN = 2,
    FC_RSCN_FORMAT_FABRIC = 3
} ;
struct fc_rscn_event_s {
   unsigned char format : 2 ;
   unsigned char qualifier : 4 ;
   unsigned char resvd : 2 ;
   unsigned int portid : 24 ;
};
struct fc_rscn_pl_s {
   u8 command ;
   u8 pagelen ;
   __be16 payldlen ;
   struct fc_rscn_event_s event[1U] ;
};
struct fc_echo_s {
   struct fc_els_cmd_s els_cmd ;
};
struct fc_rnid_cmd_s {
   struct fc_els_cmd_s els_cmd ;
   unsigned char node_id_data_format ;
    klee_make_symbolic(&node_id_data_format, sizeof(char), "node_id_data_format");
   unsigned int reserved : 24 ;
};
struct fc_rnid_common_id_data_s {
   wwn_t port_name ;
   wwn_t node_name ;
};
struct fc_rnid_general_topology_data_s {
   u32 vendor_unique[4U] ;
   __be32 asso_type ;
   u32 phy_port_num ;
   __be32 num_attached_nodes ;
   unsigned char node_mgmt ;
    klee_make_symbolic(&node_mgmt, sizeof(char), "node_mgmt");
   unsigned char ip_version ;
    klee_make_symbolic(&ip_version, sizeof(char), "ip_version");
   unsigned short udp_tcp_port_num ;
    klee_make_symbolic(&udp_tcp_port_num, sizeof(short), "udp_tcp_port_num");
   u32 ip_address[4U] ;
   unsigned short reserved ;
    klee_make_symbolic(&reserved, sizeof(short), "reserved");
   unsigned short vendor_specific ;
    klee_make_symbolic(&vendor_specific, sizeof(short), "vendor_specific");
};
struct fc_rnid_acc_s {
   struct fc_els_cmd_s els_cmd ;
   unsigned char node_id_data_format ;
   unsigned char common_id_data_length ;
    klee_make_symbolic(&common_id_data_length, sizeof(char), "common_id_data_length");
   unsigned char reserved ;
   unsigned char specific_id_data_length ;
    klee_make_symbolic(&specific_id_data_length, sizeof(char), "specific_id_data_length");
   struct fc_rnid_common_id_data_s common_id_data ;
   struct fc_rnid_general_topology_data_s gen_topology_data ;
};
struct ct_hdr_s {
   unsigned char rev_id ;
    klee_make_symbolic(&rev_id, sizeof(char), "rev_id");
   unsigned int in_id : 24 ;
   unsigned char gs_type ;
    klee_make_symbolic(&gs_type, sizeof(char), "gs_type");
   unsigned char gs_sub_type ;
    klee_make_symbolic(&gs_sub_type, sizeof(char), "gs_sub_type");
   unsigned char options ;
    klee_make_symbolic(&options, sizeof(char), "options");
   unsigned char rsvrd ;
    klee_make_symbolic(&rsvrd, sizeof(char), "rsvrd");
   unsigned short cmd_rsp_code ;
    klee_make_symbolic(&cmd_rsp_code, sizeof(short), "cmd_rsp_code");
   unsigned short max_res_size ;
    klee_make_symbolic(&max_res_size, sizeof(short), "max_res_size");
   unsigned char frag_id ;
    klee_make_symbolic(&frag_id, sizeof(char), "frag_id");
   unsigned char reason_code ;
   unsigned char exp_code ;
    klee_make_symbolic(&exp_code, sizeof(char), "exp_code");
   unsigned char vendor_unq ;
    klee_make_symbolic(&vendor_unq, sizeof(char), "vendor_unq");
};
struct fcgs_gidft_resp_s {
   unsigned char last : 1 ;
   unsigned char reserved : 7 ;
   unsigned int pid : 24 ;
};
struct fcgs_gmal_resp_s {
   __be32 ms_len ;
   u8 ms_ma[256U] ;
};
struct fcgs_gmal_entry_s {
   u8 len ;
   u8 prefix[7U] ;
   u8 ip_addr[248U] ;
};
struct fdmi_attr_s {
   __be16 type ;
   __be16 len ;
   u8 value[1U] ;
};
struct fdmi_hba_attr_s {
   __be32 attr_count ;
   struct fdmi_attr_s hba_attr ;
};
struct fdmi_port_list_s {
   __be32 num_ports ;
   wwn_t port_entry ;
};
struct fdmi_port_attr_s {
   __be32 attr_count ;
   struct fdmi_attr_s port_attr ;
};
struct fdmi_rhba_s {
   wwn_t hba_id ;
   struct fdmi_port_list_s port_list ;
   struct fdmi_hba_attr_s hba_attr_blk ;
};
struct fdmi_rprt_s {
   wwn_t hba_id ;
   wwn_t port_name ;
   struct fdmi_port_attr_s port_attr_blk ;
};
struct fdmi_rpa_s {
   wwn_t port_name ;
   struct fdmi_port_attr_s port_attr_blk ;
};
enum bfa_lport_aen_event {
    BFA_LPORT_AEN_NEW = 1,
    BFA_LPORT_AEN_DELETE = 2,
    BFA_LPORT_AEN_ONLINE = 3,
    BFA_LPORT_AEN_OFFLINE = 4,
    BFA_LPORT_AEN_DISCONNECT = 5,
    BFA_LPORT_AEN_NEW_PROP = 6,
    BFA_LPORT_AEN_DELETE_PROP = 7,
    BFA_LPORT_AEN_NEW_STANDARD = 8,
    BFA_LPORT_AEN_DELETE_STANDARD = 9,
    BFA_LPORT_AEN_NPIV_DUP_WWN = 10,
    BFA_LPORT_AEN_NPIV_FABRIC_MAX = 11,
    BFA_LPORT_AEN_NPIV_UNKNOWN = 12
} ;
struct bfa_lport_info_s {
   u8 port_type ;
   u8 port_state ;
   u8 offline_reason ;
   wwn_t port_wwn ;
   wwn_t node_wwn ;
   u32 max_vports_supp ;
   u32 num_vports_inuse ;
   u32 max_rports_supp ;
   u32 num_rports_inuse ;
};
struct bfa_fcs_fdmi_hba_attr_s {
   wwn_t node_name ;
   u8 manufacturer[64U] ;
   u8 serial_num[64U] ;
   u8 model[16U] ;
   u8 model_desc[128U] ;
   u8 hw_version[8U] ;
   u8 driver_version[64U] ;
   u8 option_rom_ver[64U] ;
   u8 fw_version[64U] ;
   u8 os_name[256U] ;
   __be32 max_ct_pyld ;
   struct bfa_lport_symname_s node_sym_name ;
   u8 vendor_info[8U] ;
   __be32 num_ports ;
   wwn_t fabric_name ;
   u8 bios_ver[64U] ;
};
struct bfa_fcs_fdmi_port_attr_s {
   u8 supp_fc4_types[32U] ;
   __be32 supp_speed ;
   __be32 curr_speed ;
   __be32 max_frm_size ;
   u8 os_device_name[256U] ;
   u8 host_name[256U] ;
   wwn_t port_name ;
   wwn_t node_name ;
   struct bfa_lport_symname_s port_sym_name ;
   __be32 port_type ;
   enum fc_cos scos ;
   wwn_t port_fabric_name ;
   u8 port_act_fc4_type[32U] ;
   __be32 port_state ;
   __be32 num_ports ;
};
enum fc_parse_status {
    FC_PARSE_OK = 0,
    FC_PARSE_FAILURE = 1,
    FC_PARSE_BUSY = 2,
    FC_PARSE_LEN_INVAL = 3,
    FC_PARSE_ACC_INVAL = 4,
    FC_PARSE_PWWN_NOT_EQUAL = 5,
    FC_PARSE_NWWN_NOT_EQUAL = 6,
    FC_PARSE_RXSZ_INVAL = 7,
    FC_PARSE_NOT_FCP = 8,
    FC_PARSE_OPAFLAG_INVAL = 9,
    FC_PARSE_RPAFLAG_INVAL = 10,
    FC_PARSE_OPA_INVAL = 11,
    FC_PARSE_RPA_INVAL = 12
} ;
struct __anonstruct___port_action_303 {
   void (*init)(struct bfa_fcs_lport_s * ) ;
   void (*online)(struct bfa_fcs_lport_s * ) ;
   void (*offline)(struct bfa_fcs_lport_s * ) ;
};
enum bfa_fcs_lport_event {
    BFA_FCS_PORT_SM_CREATE = 1,
    BFA_FCS_PORT_SM_ONLINE = 2,
    BFA_FCS_PORT_SM_OFFLINE = 3,
    BFA_FCS_PORT_SM_DELETE = 4,
    BFA_FCS_PORT_SM_DELRPORT = 5,
    BFA_FCS_PORT_SM_STOP = 6
} ;
enum port_fdmi_event {
    FDMISM_EVENT_PORT_ONLINE = 1,
    FDMISM_EVENT_PORT_OFFLINE = 2,
    FDMISM_EVENT_RSP_OK = 4,
    FDMISM_EVENT_RSP_ERROR = 5,
    FDMISM_EVENT_TIMEOUT = 6,
    FDMISM_EVENT_RHBA_SENT = 7,
    FDMISM_EVENT_RPRT_SENT = 8,
    FDMISM_EVENT_RPA_SENT = 9
} ;
enum port_ms_event {
    MSSM_EVENT_PORT_ONLINE = 1,
    MSSM_EVENT_PORT_OFFLINE = 2,
    MSSM_EVENT_RSP_OK = 3,
    MSSM_EVENT_RSP_ERROR = 4,
    MSSM_EVENT_TIMEOUT = 5,
    MSSM_EVENT_FCXP_SENT = 6,
    MSSM_EVENT_PORT_FABRIC_RSCN = 7
} ;
enum vport_ns_event {
    NSSM_EVENT_PORT_ONLINE = 1,
    NSSM_EVENT_PORT_OFFLINE = 2,
    NSSM_EVENT_PLOGI_SENT = 3,
    NSSM_EVENT_RSP_OK = 4,
    NSSM_EVENT_RSP_ERROR = 5,
    NSSM_EVENT_TIMEOUT = 6,
    NSSM_EVENT_NS_QUERY = 7,
    NSSM_EVENT_RSPNID_SENT = 8,
    NSSM_EVENT_RFTID_SENT = 9,
    NSSM_EVENT_RFFID_SENT = 10,
    NSSM_EVENT_GIDFT_SENT = 11,
    NSSM_EVENT_RNNID_SENT = 12,
    NSSM_EVENT_RSNN_NN_SENT = 13
} ;
enum port_scn_event {
    SCNSM_EVENT_PORT_ONLINE = 1,
    SCNSM_EVENT_PORT_OFFLINE = 2,
    SCNSM_EVENT_RSP_OK = 3,
    SCNSM_EVENT_RSP_ERROR = 4,
    SCNSM_EVENT_TIMEOUT = 5,
    SCNSM_EVENT_SCR_SENT = 6
} ;
enum bfa_fcs_vport_event {
    BFA_FCS_VPORT_SM_CREATE = 1,
    BFA_FCS_VPORT_SM_DELETE = 2,
    BFA_FCS_VPORT_SM_START = 3,
    BFA_FCS_VPORT_SM_STOP = 4,
    BFA_FCS_VPORT_SM_ONLINE = 5,
    BFA_FCS_VPORT_SM_OFFLINE = 6,
    BFA_FCS_VPORT_SM_FRMSENT = 7,
    BFA_FCS_VPORT_SM_RSP_OK = 8,
    BFA_FCS_VPORT_SM_RSP_ERROR = 9,
    BFA_FCS_VPORT_SM_TIMEOUT = 10,
    BFA_FCS_VPORT_SM_DELCOMP = 11,
    BFA_FCS_VPORT_SM_RSP_DUP_WWN = 12,
    BFA_FCS_VPORT_SM_RSP_FAILED = 13,
    BFA_FCS_VPORT_SM_STOPCOMP = 14,
    BFA_FCS_VPORT_SM_FABRIC_MAX = 15
} ;
enum hrtimer_restart;
union __anonunion_w_281___2 {
   u64 wwn ;
   u8 byte[8U] ;
};
struct fc_logo_s {
   struct fc_els_cmd_s els_cmd ;
   unsigned char res1 ;
   unsigned int nport_id : 24 ;
   wwn_t orig_port_name ;
};
struct fc_adisc_s {
   struct fc_els_cmd_s els_cmd ;
   unsigned char res1 ;
   unsigned int orig_HA : 24 ;
   wwn_t orig_port_name ;
   wwn_t orig_node_name ;
   unsigned char res2 ;
   unsigned int nport_id : 24 ;
};
struct fc_prli_params_s {
   unsigned short reserved ;
   unsigned char retry : 1 ;
   unsigned char task_retry_id : 1 ;
   unsigned char rec_support : 1 ;
   unsigned char reserved1 : 5 ;
   unsigned char wxrdisab : 1 ;
   unsigned char rxrdisab : 1 ;
   unsigned char drmix : 1 ;
   unsigned char cdmix : 1 ;
   unsigned char target : 1 ;
   unsigned char initiator : 1 ;
   unsigned char doverlay : 1 ;
   unsigned char confirm : 1 ;
};
struct fc_prli_params_page_s {
   unsigned char type ;
   unsigned char codext ;
    klee_make_symbolic(&codext, sizeof(char), "codext");
   unsigned char rspcode : 4 ;
   unsigned char reserved1 : 1 ;
   unsigned char imagepair : 1 ;
   unsigned char rsppav : 1 ;
   unsigned char origprocasv : 1 ;
   unsigned char reserved2 ;
    klee_make_symbolic(&reserved2, sizeof(char), "reserved2");
   u32 origprocas ;
   u32 rspprocas ;
   struct fc_prli_params_s servparams ;
};
struct fc_prli_s {
   unsigned char command ;
   unsigned char pglen ;
    klee_make_symbolic(&pglen, sizeof(char), "pglen");
   unsigned short pagebytes ;
    klee_make_symbolic(&pagebytes, sizeof(short), "pagebytes");
   struct fc_prli_params_page_s parampage ;
};
struct fc_prlo_acc_params_page_s {
   unsigned char type ;
   unsigned char type_ext ;
    klee_make_symbolic(&type_ext, sizeof(char), "type_ext");
   unsigned short res1 : 14 ;
   unsigned char rpa_valid : 1 ;
   unsigned char opa_valid : 1 ;
   u32 orig_process_assc ;
   u32 resp_process_assc ;
   u32 fc4type_csp ;
};
struct fc_prlo_acc_s {
   unsigned char command ;
   unsigned char page_len ;
    klee_make_symbolic(&page_len, sizeof(char), "page_len");
   unsigned short payload_len ;
   struct fc_prlo_acc_params_page_s prlo_acc_params[1U] ;
};
enum fc_rpsc_op_speed {
    RPSC_OP_SPEED_1G = 32768,
    RPSC_OP_SPEED_2G = 16384,
    RPSC_OP_SPEED_4G = 8192,
    RPSC_OP_SPEED_10G = 4096,
    RPSC_OP_SPEED_8G = 2048,
    RPSC_OP_SPEED_16G = 1024,
    RPSC_OP_SPEED_NOT_EST = 1
} ;
struct fc_rpsc_speed_info_s {
   __be16 port_speed_cap ;
   __be16 port_op_speed ;
};
struct fc_rpsc_acc_s {
   unsigned char command ;
   unsigned char rsvd ;
    klee_make_symbolic(&rsvd, sizeof(char), "rsvd");
   unsigned short num_entries ;
    klee_make_symbolic(&num_entries, sizeof(short), "num_entries");
   struct fc_rpsc_speed_info_s speed_info[1U] ;
};
struct __anonstruct_pid_list_284 {
   unsigned char rsvd1 ;
    klee_make_symbolic(&rsvd1, sizeof(char), "rsvd1");
   unsigned int pid : 24 ;
};
struct fc_rpsc2_cmd_s {
   struct fc_els_cmd_s els_cmd ;
   __be32 token ;
   u16 resvd ;
   __be16 num_pids ;
   struct __anonstruct_pid_list_284 pid_list[1U] ;
};
struct fc_rpsc2_port_info_s {
   __be32 pid ;
   u16 resvd1 ;
   __be16 index ;
   u8 resvd2 ;
   u8 type ;
   __be16 speed ;
};
struct fc_rpsc2_acc_s {
   u8 els_cmd ;
   u8 resvd ;
   __be16 num_pids ;
   struct fc_rpsc2_port_info_s port_info[1U] ;
};
struct fcgs_gidpn_resp_s {
   unsigned char rsvd ;
   unsigned int dap : 24 ;
};
enum bfa_rport_aen_event {
    BFA_RPORT_AEN_ONLINE = 1,
    BFA_RPORT_AEN_OFFLINE = 2,
    BFA_RPORT_AEN_DISCONNECT = 3,
    BFA_RPORT_AEN_QOS_PRIO = 4,
    BFA_RPORT_AEN_QOS_FLOWID = 5
} ;
enum rport_event {
    RPSM_EVENT_PLOGI_SEND = 1,
    RPSM_EVENT_PLOGI_RCVD = 2,
    RPSM_EVENT_PLOGI_COMP = 3,
    RPSM_EVENT_LOGO_RCVD = 4,
    RPSM_EVENT_LOGO_IMP = 5,
    RPSM_EVENT_FCXP_SENT = 6,
    RPSM_EVENT_DELETE = 7,
    RPSM_EVENT_FAB_SCN = 8,
    RPSM_EVENT_ACCEPTED = 9,
    RPSM_EVENT_FAILED = 10,
    RPSM_EVENT_TIMEOUT = 11,
    RPSM_EVENT_HCB_ONLINE = 12,
    RPSM_EVENT_HCB_OFFLINE = 13,
    RPSM_EVENT_FC4_OFFLINE = 14,
    RPSM_EVENT_ADDRESS_CHANGE = 15,
    RPSM_EVENT_ADDRESS_DISC = 16,
    RPSM_EVENT_PRLO_RCVD = 17,
    RPSM_EVENT_PLOGI_RETRY = 18,
    RPSM_EVENT_SCN_OFFLINE = 19,
    RPSM_EVENT_SCN_ONLINE = 20,
    RPSM_EVENT_FC4_FCS_ONLINE = 21
} ;
enum rpf_event {
    RPFSM_EVENT_RPORT_OFFLINE = 1,
    RPFSM_EVENT_RPORT_ONLINE = 2,
    RPFSM_EVENT_FCXP_SENT = 3,
    RPFSM_EVENT_TIMEOUT = 4,
    RPFSM_EVENT_RPSC_COMP = 5,
    RPFSM_EVENT_RPSC_FAIL = 6,
    RPFSM_EVENT_RPSC_ERROR = 7
} ;
enum hrtimer_restart;
union __anonunion_w_281___3 {
   u64 wwn ;
   u8 byte[8U] ;
};
enum bfa_itnim_aen_event {
    BFA_ITNIM_AEN_ONLINE = 1,
    BFA_ITNIM_AEN_OFFLINE = 2,
    BFA_ITNIM_AEN_DISCONNECT = 3
} ;
enum bfa_fcs_itnim_event {
    BFA_FCS_ITNIM_SM_FCS_ONLINE = 1,
    BFA_FCS_ITNIM_SM_OFFLINE = 2,
    BFA_FCS_ITNIM_SM_FRMSENT = 3,
    BFA_FCS_ITNIM_SM_RSP_OK = 4,
    BFA_FCS_ITNIM_SM_RSP_ERROR = 5,
    BFA_FCS_ITNIM_SM_TIMEOUT = 6,
    BFA_FCS_ITNIM_SM_HCB_OFFLINE = 7,
    BFA_FCS_ITNIM_SM_HCB_ONLINE = 8,
    BFA_FCS_ITNIM_SM_INITIATOR = 9,
    BFA_FCS_ITNIM_SM_DELETE = 10,
    BFA_FCS_ITNIM_SM_PRLO = 11,
    BFA_FCS_ITNIM_SM_RSP_NOT_SUPP = 12,
    BFA_FCS_ITNIM_SM_HAL_ONLINE = 13
} ;
enum hrtimer_restart;
struct fc_prlo_params_page_s {
   unsigned char type ;
   unsigned char type_ext ;
   unsigned short res1 : 14 ;
   unsigned char rpa_valid : 1 ;
   unsigned char opa_valid : 1 ;
   u32 orig_process_assc ;
   u32 resp_process_assc ;
   u32 res2 ;
};
struct fc_prlo_s {
   unsigned char command ;
   unsigned char page_len ;
   unsigned short payload_len ;
   struct fc_prlo_params_page_s prlo_params[1U] ;
};
struct fc_rrq_s {
   struct fc_els_cmd_s els_cmd ;
   unsigned char res1 ;
   unsigned int s_id : 24 ;
   unsigned short ox_id ;
   unsigned short rx_id ;
   u32 res2[8U] ;
};
struct fc_ba_rjt_s {
   unsigned char res1 ;
   unsigned char reason_code ;
   unsigned char reason_expl ;
    klee_make_symbolic(&reason_expl, sizeof(char), "reason_expl");
   unsigned char vendor_unique ;
};
struct fc_tprlo_params_page_s {
   unsigned char type ;
   unsigned char type_ext ;
   unsigned short res1 : 12 ;
   unsigned char global_process_logout : 1 ;
   unsigned char tpo_nport_valid : 1 ;
   unsigned char rpa_valid : 1 ;
   unsigned char opa_valid : 1 ;
   u32 orig_process_assc ;
   u32 resp_process_assc ;
   unsigned char res2 ;
   u32 tpo_nport_id ;
};
struct fc_tprlo_s {
   unsigned char command ;
   unsigned char page_len ;
   unsigned short payload_len ;
   struct fc_tprlo_params_page_s tprlo_params[1U] ;
};
enum fc_tprlo_type {
    FC_GLOBAL_LOGO = 1,
    FC_TPR_LOGO = 2
} ;
struct fc_tprlo_acc_s {
   unsigned char command ;
   unsigned char page_len ;
   unsigned short payload_len ;
   struct fc_prlo_acc_params_page_s tprlo_acc_params[1U] ;
};
struct fc_rpsc_cmd_s {
   struct fc_els_cmd_s els_cmd ;
};
struct fcgs_id_req_s {
   unsigned char rsvd ;
   unsigned int dap : 24 ;
};
struct fcgs_gidpn_req_s {
   wwn_t port_name ;
};
struct fcgs_rftid_req_s {
   unsigned char rsvd ;
   unsigned int dap : 24 ;
   __be32 fc4_type[8U] ;
};
struct fcgs_rffid_req_s {
   unsigned char rsvd ;
   unsigned int dap : 24 ;
   unsigned short rsvd1 ;
   unsigned char fc4ftr_bits ;
    klee_make_symbolic(&fc4ftr_bits, sizeof(char), "fc4ftr_bits");
   unsigned char fc4_type ;
    klee_make_symbolic(&fc4_type, sizeof(char), "fc4_type");
};
struct fcgs_gidft_req_s {
   u8 reserved ;
   u8 domain_id ;
   u8 area_id ;
   u8 fc4_type ;
};
struct fcgs_rspnid_req_s {
   unsigned char rsvd ;
   unsigned int dap : 24 ;
   u8 spn_len ;
   u8 spn[256U] ;
};
struct fcgs_rsnn_nn_req_s {
   wwn_t node_name ;
   u8 snn_len ;
   u8 snn[256U] ;
};
struct fcgs_rpnid_req_s {
   unsigned char rsvd ;
   unsigned int port_id : 24 ;
   wwn_t port_name ;
};
struct fcgs_rnnid_req_s {
   unsigned char rsvd ;
   unsigned int port_id : 24 ;
   wwn_t node_name ;
};
struct fcgs_rcsid_req_s {
   unsigned char rsvd ;
   unsigned int port_id : 24 ;
   u32 cos ;
};
struct fcgs_rptid_req_s {
   unsigned char rsvd ;
   unsigned int port_id : 24 ;
   unsigned char port_type ;
    klee_make_symbolic(&port_type, sizeof(char), "port_type");
   unsigned int rsvd1 : 24 ;
};
struct fcgs_ganxt_req_s {
   unsigned char rsvd ;
   unsigned int port_id : 24 ;
};
struct fcgs_req_s {
   wwn_t wwn ;
};
enum hrtimer_restart;
struct bfi_port_generic_req_s {
   struct bfi_mhdr_s mh ;
   u32 msgtag ;
   u32 rsvd ;
};
struct bfi_port_generic_rsp_s {
   struct bfi_mhdr_s mh ;
   u8 status ;
   u8 rsvd[3U] ;
   u32 msgtag ;
};
struct bfi_port_get_stats_req_s {
   struct bfi_mhdr_s mh ;
   union bfi_addr_u dma_addr ;
};
union bfi_port_i2h_msg_u {
   struct bfi_mhdr_s mh ;
   struct bfi_port_generic_rsp_s enable_rsp ;
   struct bfi_port_generic_rsp_s disable_rsp ;
   struct bfi_port_generic_rsp_s getstats_rsp ;
   struct bfi_port_generic_rsp_s clearstats_rsp ;
};
struct bfi_cee_reset_stats_s {
   struct bfi_mhdr_s mh ;
};
struct bfi_cee_get_req_s {
   struct bfi_mhdr_s mh ;
   union bfi_addr_u dma_addr ;
};
struct bfi_cee_get_rsp_s {
   struct bfi_mhdr_s mh ;
   u8 cmd_status ;
   u8 rsvd[3U] ;
};
struct bfi_cee_stats_rsp_s {
   struct bfi_mhdr_s mh ;
   u8 cmd_status ;
   u8 rsvd[3U] ;
};
union bfi_cee_i2h_msg_u {
   struct bfi_mhdr_s mh ;
   struct bfi_cee_get_rsp_s get_rsp ;
   struct bfi_cee_stats_rsp_s stats_rsp ;
};
enum hrtimer_restart;
struct scsi_cdb_s {
   u8 scsi_cdb[16U] ;
};
struct fcp_cmnd_s {
   struct scsi_lun lun ;
   u8 crn ;
   unsigned char taskattr : 3 ;
   unsigned char priority : 4 ;
   unsigned char resvd : 1 ;
   u8 tm_flags ;
   unsigned char iodir : 2 ;
   unsigned char addl_cdb_len : 6 ;
   struct scsi_cdb_s cdb ;
   __be32 fcp_dl ;
};
struct bfi_itn_create_req_s {
   struct bfi_mhdr_s mh ;
   u16 fw_handle ;
   u8 class ;
   u8 seq_rec ;
   u8 msg_no ;
   u8 role ;
};
struct bfi_itn_create_rsp_s {
   struct bfi_mhdr_s mh ;
   u16 bfa_handle ;
   u8 status ;
   u8 seq_id ;
};
struct bfi_itn_delete_req_s {
   struct bfi_mhdr_s mh ;
   u16 fw_handle ;
   u8 seq_id ;
   u8 rsvd ;
};
struct bfi_itn_delete_rsp_s {
   struct bfi_mhdr_s mh ;
   u16 bfa_handle ;
   u8 status ;
   u8 seq_id ;
};
struct bfi_itn_sler_event_s {
   struct bfi_mhdr_s mh ;
   u16 bfa_handle ;
   u16 rsvd ;
};
union bfi_itn_i2h_msg_u {
   struct bfi_itn_create_rsp_s *create_rsp ;
   struct bfi_itn_delete_rsp_s *delete_rsp ;
   struct bfi_itn_sler_event_s *sler_event ;
   struct bfi_msg_s *msg ;
};
enum bfi_ioim_h2i {
    BFI_IOIM_H2I_IOABORT_REQ = 1,
    BFI_IOIM_H2I_IOCLEANUP_REQ = 2
} ;
struct bfi_ioim_dif_s {
   u32 dif_info[4U] ;
};
struct bfi_ioim_req_s {
   struct bfi_mhdr_s mh ;
   __be16 io_tag ;
   u16 rport_hdl ;
   struct fcp_cmnd_s cmnd ;
   struct bfi_sge_s sges[2U] ;
   u8 io_timeout ;
   u8 dif_en ;
   u8 rsvd_a[2U] ;
   struct bfi_ioim_dif_s dif ;
};
struct bfi_ioim_rsp_s {
   struct bfi_mhdr_s mh ;
   __be16 io_tag ;
   u16 bfa_rport_hndl ;
   u8 io_status ;
   u8 reuse_io_tag ;
   u16 abort_tag ;
   u8 scsi_status ;
   u8 sns_len ;
   u8 resid_flags ;
   u8 rsvd_a ;
   __be32 residue ;
   u32 rsvd_b[3U] ;
};
struct bfi_ioim_abort_req_s {
   struct bfi_mhdr_s mh ;
   __be16 io_tag ;
   u16 abort_tag ;
};
struct bfi_tskim_req_s {
   struct bfi_mhdr_s mh ;
   __be16 tsk_tag ;
   u16 itn_fhdl ;
   struct scsi_lun lun ;
   u8 tm_flags ;
   u8 t_secs ;
   u8 rsvd[2U] ;
};
struct bfi_tskim_abortreq_s {
   struct bfi_mhdr_s mh ;
   __be16 tsk_tag ;
   u16 rsvd ;
};
struct bfi_tskim_rsp_s {
   struct bfi_mhdr_s mh ;
   __be16 tsk_tag ;
   u8 tsk_status ;
   u8 rsvd ;
};
enum bfa_itnim_event {
    BFA_ITNIM_SM_CREATE = 1,
    BFA_ITNIM_SM_ONLINE = 2,
    BFA_ITNIM_SM_OFFLINE = 3,
    BFA_ITNIM_SM_FWRSP = 4,
    BFA_ITNIM_SM_DELETE = 5,
    BFA_ITNIM_SM_CLEANUP = 6,
    BFA_ITNIM_SM_SLER = 7,
    BFA_ITNIM_SM_HWFAIL = 8,
    BFA_ITNIM_SM_QRESUME = 9
} ;
enum bfa_ioim_event {
    BFA_IOIM_SM_START = 1,
    BFA_IOIM_SM_COMP_GOOD = 2,
    BFA_IOIM_SM_COMP = 3,
    BFA_IOIM_SM_COMP_UTAG = 4,
    BFA_IOIM_SM_DONE = 5,
    BFA_IOIM_SM_FREE = 6,
    BFA_IOIM_SM_ABORT = 7,
    BFA_IOIM_SM_ABORT_COMP = 8,
    BFA_IOIM_SM_ABORT_DONE = 9,
    BFA_IOIM_SM_QRESUME = 10,
    BFA_IOIM_SM_SGALLOCED = 11,
    BFA_IOIM_SM_SQRETRY = 12,
    BFA_IOIM_SM_HCB = 13,
    BFA_IOIM_SM_CLEANUP = 14,
    BFA_IOIM_SM_TMSTART = 15,
    BFA_IOIM_SM_TMDONE = 16,
    BFA_IOIM_SM_HWFAIL = 17,
    BFA_IOIM_SM_IOTOV = 18
} ;
enum bfa_tskim_event {
    BFA_TSKIM_SM_START = 1,
    BFA_TSKIM_SM_DONE = 2,
    BFA_TSKIM_SM_QRESUME = 3,
    BFA_TSKIM_SM_HWFAIL = 5,
    BFA_TSKIM_SM_HCB = 6,
    BFA_TSKIM_SM_IOS_DONE = 7,
    BFA_TSKIM_SM_CLEANUP = 8,
    BFA_TSKIM_SM_CLEANUP_DONE = 9,
    BFA_TSKIM_SM_UTAG = 10
} ;
enum hrtimer_restart;
enum iocfc_event {
    IOCFC_E_INIT = 1,
    IOCFC_E_START = 2,
    IOCFC_E_STOP = 3,
    IOCFC_E_ENABLE = 4,
    IOCFC_E_DISABLE = 5,
    IOCFC_E_IOC_ENABLED = 6,
    IOCFC_E_IOC_DISABLED = 7,
    IOCFC_E_IOC_FAILED = 8,
    IOCFC_E_DCONF_DONE = 9,
    IOCFC_E_CFG_DONE = 10
} ;
typedef void (*bfa_isr_func_t)(struct bfa_s * , struct bfi_msg_s * );
struct bfa_pciid_s {
   u16 device_id ;
   u16 vendor_id ;
};
struct bfi_iocfc_cfg_req_s {
   struct bfi_mhdr_s mh ;
   union bfi_addr_u ioc_cfg_dma_addr ;
};
struct bfi_iocfc_cfg_reply_s {
   struct bfi_mhdr_s mh ;
   u8 cfg_success ;
   u8 lpu_bm ;
   u8 rsvd[2U] ;
};
struct bfi_iocfc_set_intr_req_s {
   struct bfi_mhdr_s mh ;
   u8 coalesce ;
   u8 rsvd[3U] ;
   __be16 delay ;
   __be16 latency ;
};
struct bfi_iocfc_updateq_rsp_s {
   struct bfi_mhdr_s mh ;
   u8 status ;
   u8 rsvd[3U] ;
};
union bfi_iocfc_i2h_msg_u {
   struct bfi_mhdr_s mh ;
   struct bfi_iocfc_cfg_reply_s cfg_reply ;
   struct bfi_iocfc_updateq_rsp_s updateq_rsp ;
   u32 mboxmsg[8U] ;
};
struct bfi_faa_addr_msg_s {
   struct bfi_mhdr_s mh ;
   u8 rsvd[4U] ;
   wwn_t pwwn ;
   wwn_t nwwn ;
};
struct bfi_faa_query_s {
   struct bfi_mhdr_s mh ;
   u8 faa_status ;
   u8 addr_source ;
   u8 rsvd[2U] ;
   wwn_t faa ;
};
enum hrtimer_restart;
union __anonunion_w_281___4 {
   u64 wwn ;
   u8 byte[8U] ;
};
struct bfa_diag_loopback_s {
   u32 loopcnt ;
   u32 pattern ;
   u8 lb_mode ;
   u8 speed ;
   u8 rsvd[2U] ;
};
struct bfi_diag_lb_req_s {
   struct bfi_mhdr_s mh ;
   u32 loopcnt ;
   u32 pattern ;
   u8 lb_mode ;
   u8 speed ;
   u8 rsvd[2U] ;
};
struct bfi_diag_lb_rsp_s {
   struct bfi_mhdr_s mh ;
   struct bfa_diag_loopback_result_s res ;
};
struct bfi_diag_qtest_req_s {
   struct bfi_mhdr_s mh ;
   u32 data[31U] ;
};
enum bfi_dport_req {
    BFI_DPORT_DISABLE = 0,
    BFI_DPORT_ENABLE = 1,
    BFI_DPORT_START = 2,
    BFI_DPORT_SHOW = 3,
    BFI_DPORT_DYN_DISABLE = 4
} ;
struct bfi_fcport_req_s {
   struct bfi_mhdr_s mh ;
   u32 msgtag ;
};
struct bfi_fcport_enable_req_s {
   struct bfi_mhdr_s mh ;
   u32 rsvd1 ;
   wwn_t nwwn ;
   wwn_t pwwn ;
   struct bfa_port_cfg_s port_cfg ;
   union bfi_addr_u stats_dma_addr ;
   u32 msgtag ;
   u8 use_flash_cfg ;
   u8 rsvd2[3U] ;
};
struct bfi_fcxp_send_req_s {
   struct bfi_mhdr_s mh ;
   __be16 fcxp_tag ;
   __be16 max_frmsz ;
   __be16 vf_id ;
   u16 rport_fw_hndl ;
   u8 class ;
   u8 rsp_timeout ;
   u8 cts ;
   u8 lp_fwtag ;
   struct fchs_s fchs ;
   __be32 req_len ;
   __be32 rsp_maxlen ;
   struct bfi_alen_s req_alen ;
   struct bfi_alen_s rsp_alen ;
};
struct bfi_fcxp_send_rsp_s {
   struct bfi_mhdr_s mh ;
   __be16 fcxp_tag ;
   u8 req_status ;
   u8 rsvd ;
   __be32 rsp_len ;
   __be32 residue_len ;
   struct fchs_s fchs ;
};
struct bfi_uf_frm_rcvd_s {
   struct bfi_mhdr_s mh ;
   u16 buf_tag ;
   u16 rsvd ;
   u16 frm_len ;
   u16 xfr_len ;
};
struct bfi_lps_login_req_s {
   struct bfi_mhdr_s mh ;
   u8 bfa_tag ;
   u8 alpa ;
   __be16 pdu_size ;
   wwn_t pwwn ;
   wwn_t nwwn ;
   u8 fdisc ;
   u8 auth_en ;
   u8 lps_role ;
   u8 bb_scn ;
   u32 vvl_flag ;
};
struct bfi_lps_logout_req_s {
   struct bfi_mhdr_s mh ;
   u8 fw_tag ;
   u8 rsvd[3U] ;
   wwn_t port_name ;
};
struct bfi_lps_logout_rsp_s {
   struct bfi_mhdr_s mh ;
   u8 bfa_tag ;
   u8 status ;
   u8 rsvd[2U] ;
};
struct bfi_lps_cvl_event_s {
   struct bfi_mhdr_s mh ;
   u8 bfa_tag ;
   u8 rsvd[3U] ;
};
struct bfi_lps_n2n_pid_req_s {
   struct bfi_mhdr_s mh ;
   u8 fw_tag ;
   unsigned int lp_pid : 24 ;
};
union bfi_lps_i2h_msg_u {
   struct bfi_msg_s *msg ;
   struct bfi_lps_login_rsp_s *login_rsp ;
   struct bfi_lps_logout_rsp_s *logout_rsp ;
   struct bfi_lps_cvl_event_s *cvl_event ;
};
struct bfi_rport_create_req_s {
   struct bfi_mhdr_s mh ;
   u16 bfa_handle ;
   __be16 max_frmsz ;
   unsigned int pid : 24 ;
   unsigned char lp_fwtag ;
    klee_make_symbolic(&lp_fwtag, sizeof(char), "lp_fwtag");
   unsigned int local_pid : 24 ;
   unsigned char cisc ;
   u8 fc_class ;
   u8 vf_en ;
   u16 vf_id ;
};
struct bfi_rport_create_rsp_s {
   struct bfi_mhdr_s mh ;
   u8 status ;
   u8 rsvd[3U] ;
   u16 bfa_handle ;
   u16 fw_handle ;
   struct bfa_rport_qos_attr_s qos_attr ;
};
struct bfa_rport_speed_req_s {
   struct bfi_mhdr_s mh ;
   u16 fw_handle ;
   u8 speed ;
   u8 rsvd ;
};
struct bfi_rport_delete_req_s {
   struct bfi_mhdr_s mh ;
   u16 fw_handle ;
   u16 rsvd ;
};
struct bfi_rport_delete_rsp_s {
   struct bfi_mhdr_s mh ;
   u16 bfa_handle ;
   u8 status ;
   u8 rsvd ;
};
struct bfi_rport_qos_scn_s {
   struct bfi_mhdr_s mh ;
   u16 bfa_handle ;
   u16 rsvd ;
   struct bfa_rport_qos_attr_s old_qos_attr ;
   struct bfa_rport_qos_attr_s new_qos_attr ;
};
struct bfi_rport_lip_scn_s {
   struct bfi_mhdr_s mh ;
   u16 bfa_handle ;
   u8 status ;
   u8 rsvd ;
   struct bfa_fcport_loop_info_s loop_info ;
};
union bfi_rport_i2h_msg_u {
   struct bfi_msg_s *msg ;
   struct bfi_rport_create_rsp_s *create_rsp ;
   struct bfi_rport_delete_rsp_s *delete_rsp ;
   struct bfi_rport_qos_scn_s *qos_scn_evt ;
   struct bfi_rport_lip_scn_s *lip_scn ;
};
typedef u64 (*bfa_fcxp_get_sgaddr_t)(void * , int  );
typedef u32 (*bfa_fcxp_get_sglen_t)(void * , int  );
enum bfa_rport_event {
    BFA_RPORT_SM_CREATE = 1,
    BFA_RPORT_SM_DELETE = 2,
    BFA_RPORT_SM_ONLINE = 3,
    BFA_RPORT_SM_OFFLINE = 4,
    BFA_RPORT_SM_FWRSP = 5,
    BFA_RPORT_SM_HWFAIL = 6,
    BFA_RPORT_SM_QOS_SCN = 7,
    BFA_RPORT_SM_SET_SPEED = 8,
    BFA_RPORT_SM_QRESUME = 9
} ;
struct bfa_uf_buf_s {
   u8 d[2304U] ;
};
enum bfa_lps_event {
    BFA_LPS_SM_LOGIN = 1,
    BFA_LPS_SM_LOGOUT = 2,
    BFA_LPS_SM_FWRSP = 3,
    BFA_LPS_SM_RESUME = 4,
    BFA_LPS_SM_DELETE = 5,
    BFA_LPS_SM_OFFLINE = 6,
    BFA_LPS_SM_RX_CVL = 7,
    BFA_LPS_SM_SET_N2N_PID = 8
} ;
enum bfa_fcport_sm_event {
    BFA_FCPORT_SM_START = 1,
    BFA_FCPORT_SM_STOP = 2,
    BFA_FCPORT_SM_ENABLE = 3,
    BFA_FCPORT_SM_DISABLE = 4,
    BFA_FCPORT_SM_FWRSP = 5,
    BFA_FCPORT_SM_LINKUP = 6,
    BFA_FCPORT_SM_LINKDOWN = 7,
    BFA_FCPORT_SM_QRESUME = 8,
    BFA_FCPORT_SM_HWFAIL = 9,
    BFA_FCPORT_SM_DPORTENABLE = 10,
    BFA_FCPORT_SM_DPORTDISABLE = 11,
    BFA_FCPORT_SM_FAA_MISCONFIG = 12,
    BFA_FCPORT_SM_DDPORTENABLE = 13,
    BFA_FCPORT_SM_DDPORTDISABLE = 14
} ;
enum bfa_fcport_ln_sm_event {
    BFA_FCPORT_LN_SM_LINKUP = 1,
    BFA_FCPORT_LN_SM_LINKDOWN = 2,
    BFA_FCPORT_LN_SM_NOTIFICATION = 3
} ;
union __anonunion_sgpg_pa_304 {
   u64 pa ;
   union bfi_addr_u addr ;
};
union __anonunion_sgpg_pa_tmp_305 {
   u64 pa ;
   union bfi_addr_u addr ;
};
enum bfa_dport_sm_event {
    BFA_DPORT_SM_ENABLE = 1,
    BFA_DPORT_SM_DISABLE = 2,
    BFA_DPORT_SM_FWRSP = 3,
    BFA_DPORT_SM_QRESUME = 4,
    BFA_DPORT_SM_HWFAIL = 5,
    BFA_DPORT_SM_START = 6,
    BFA_DPORT_SM_REQFAIL = 7,
    BFA_DPORT_SM_SCN = 8
} ;
__inline static long ldv__builtin_expect(long exp , long c ) ;
extern struct module __this_module ;
__inline static bool is_power_of_2(unsigned long n ) 
{ 


  {
  return ((bool )(n != 0UL && ((n - 1UL) & n) == 0UL));
}
}
extern int printk(char const   *  , ...) ;
extern int sprintf(char * , char const   *  , ...) ;
bool ldv_is_err(void const   *ptr ) ;
__inline static void INIT_LIST_HEAD(struct list_head *list ) 
{ 


  {
  list->next = list;
  list->prev = list;
  return;
}
}
extern void __list_add(struct list_head * , struct list_head * , struct list_head * ) ;
__inline static void list_add_tail(struct list_head *new , struct list_head *head ) 
{ 


  {
  __list_add(new, head->prev, head);
  return;
}
}
extern void list_del(struct list_head * ) ;
__inline static int list_empty(struct list_head  const  *head ) 
{ 


  {
  return ((unsigned long )((struct list_head  const  *)head->next) == (unsigned long )head);
}
}
extern void *memcpy(void * , void const   * , size_t  ) ;
extern void *memset(void * , int  , size_t  ) ;
extern int strcmp(char const   * , char const   * ) ;
extern char *strncpy(char * , char const   * , __kernel_size_t  ) ;
extern void warn_slowpath_null(char const   * , int const    ) ;
__inline static bool IS_ERR(void const   *ptr ) ;
extern int mutex_trylock(struct mutex * ) ;
int ldv_mutex_trylock_15(struct mutex *ldv_func_arg1 ) ;
extern void mutex_unlock(struct mutex * ) ;
void ldv_mutex_unlock_11(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_12(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_16(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_30(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_32(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_34(struct mutex *ldv_func_arg1 ) ;
extern void *malloc(size_t  ) ;
extern void *calloc(size_t  , size_t  ) ;
extern int __VERIFIER_nondet_int(void) ;
extern unsigned long __VERIFIER_nondet_ulong(void) ;
extern void abort(void);
void assume_abort_if_not(int cond) {
  if(!cond) {abort();}
}
__inline static bool IS_ERR(void const *ptr ) ;

void *ldv_malloc(size_t size ) 
{ 
  void *p ;
  void *tmp ;
  int tmp___0 ;
    klee_make_symbolic(&tmp___0, sizeof(int), "tmp___0");

  {
  tmp___0 = __VERIFIER_nondet_int();
  if (tmp___0 != 0) {
    return ((void *)0);
  } else {
    tmp = malloc(size);
    p = tmp;
    assume_abort_if_not((unsigned long )p != (unsigned long )((void *)0));
    assume_abort_if_not(IS_ERR(p) == 0);
    return (p);
  }
}
}
void *ldv_zalloc(size_t size ) 
{ 
  void *p ;
  void *tmp ;
  int tmp___0 ;

  {
  tmp___0 = __VERIFIER_nondet_int();
  if (tmp___0 != 0) {
    return ((void *)0);
  } else {
    tmp = calloc(1UL, size);
    p = tmp;
    assume_abort_if_not((unsigned long )p != (unsigned long )((void *)0));
    assume_abort_if_not(IS_ERR(p) == 0);
    return (p);
  }
}
}
void *ldv_init_zalloc(size_t size ) 
{ 
  void *p ;
  void *tmp ;

  {
  tmp = calloc(1UL, size);
  p = tmp;
  assume_abort_if_not((unsigned long )p != (unsigned long )((void *)0));
  return (p);
}
}
void *ldv_memset(void *s , int c , size_t n ) 
{ 
  void *tmp ;

  {
  tmp = memset(s, c, n);
  return (tmp);
}
}
int ldv_undef_int(void) 
{ 
  int tmp ;
    klee_make_symbolic(&tmp, sizeof(int), "tmp");

  {
  tmp = __VERIFIER_nondet_int();
  return (tmp);
}
}
unsigned long ldv_undef_ulong(void) 
{ 
  unsigned long tmp ;

  {
  tmp = __VERIFIER_nondet_ulong();
  return (tmp);
}
}
__inline static void ldv_stop(void) 
{ 


  {
  LDV_STOP: ;
  goto LDV_STOP;
}
}
__inline static long ldv__builtin_expect(long exp , long c ) 
{ 


  {
  return (exp);
}
}
extern void mutex_lock(struct mutex * ) ;
void ldv_mutex_lock_10(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_13(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_14(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_29(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_31(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_33(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_bfad_mutex(struct mutex *lock ) ;
void ldv_mutex_unlock_bfad_mutex(struct mutex *lock ) ;
void ldv_mutex_lock_i_mutex_of_inode(struct mutex *lock ) ;
void ldv_mutex_unlock_i_mutex_of_inode(struct mutex *lock ) ;
void ldv_mutex_lock_lock(struct mutex *lock ) ;
void ldv_mutex_unlock_lock(struct mutex *lock ) ;
void ldv_mutex_lock_mutex_of_device(struct mutex *lock ) ;
int ldv_mutex_trylock_mutex_of_device(struct mutex *lock ) ;
void ldv_mutex_unlock_mutex_of_device(struct mutex *lock ) ;
extern void __raw_spin_lock_init(raw_spinlock_t * , char const   * , struct lock_class_key * ) ;
extern unsigned long _raw_spin_lock_irqsave(raw_spinlock_t * ) ;
extern void _raw_spin_unlock_irqrestore(raw_spinlock_t * , unsigned long  ) ;
__inline static raw_spinlock_t *spinlock_check(spinlock_t *lock ) 
{ 


  {
  return (& lock->__annonCompField17.rlock);
}
}
__inline static void spin_unlock_irqrestore(spinlock_t *lock , unsigned long flags ) 
{ 


  {
  _raw_spin_unlock_irqrestore(& lock->__annonCompField17.rlock, flags);
  return;
}
}
extern unsigned long volatile   jiffies ;
extern unsigned long __msecs_to_jiffies(unsigned int const    ) ;
__inline static unsigned long msecs_to_jiffies(unsigned int const   m ) 
{ 
  unsigned long tmp___0 ;

  {
  tmp___0 = __msecs_to_jiffies(m);
  return (tmp___0);
}
}
extern void do_gettimeofday(struct timeval * ) ;
extern int mod_timer(struct timer_list * , unsigned long  ) ;
int ldv_mod_timer_20(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
int ldv_mod_timer_21(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) ;
extern int del_timer_sync(struct timer_list * ) ;
int ldv_del_timer_sync_18(struct timer_list *ldv_func_arg1 ) ;
int ldv_del_timer_sync_19(struct timer_list *ldv_func_arg1 ) ;
int ldv_del_timer_sync_22(struct timer_list *ldv_func_arg1 ) ;
int ldv_del_timer_sync_35(struct timer_list *ldv_func_arg1 ) ;
int ldv_del_timer_sync_36(struct timer_list *ldv_func_arg1 ) ;
int ldv_del_timer_sync_37(struct timer_list *ldv_func_arg1 ) ;
extern void __init_waitqueue_head(wait_queue_head_t * , char const   * , struct lock_class_key * ) ;
__inline static void init_completion(struct completion *x ) 
{ 
  struct lock_class_key __key ;

  {
  x->done = 0U;
  __init_waitqueue_head(& x->wait, "&x->wait", & __key);
  return;
}
}
extern void wait_for_completion(struct completion * ) ;
extern void complete(struct completion * ) ;
extern bool queue_work_on(int  , struct workqueue_struct * , struct work_struct * ) ;
bool ldv_queue_work_on_5(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                         struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_work_on_7(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                         struct work_struct *ldv_func_arg3 ) ;
extern bool queue_delayed_work_on(int  , struct workqueue_struct * , struct delayed_work * ,
                                  unsigned long  ) ;
bool ldv_queue_delayed_work_on_6(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                 struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
bool ldv_queue_delayed_work_on_9(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                 struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
extern void flush_workqueue(struct workqueue_struct * ) ;
void ldv_flush_workqueue_8(struct workqueue_struct *ldv_func_arg1 ) ;
void ldv_flush_workqueue_23(struct workqueue_struct *ldv_func_arg1 ) ;
extern void pci_iounmap(struct pci_dev * , void * ) ;
extern void *pci_iomap(struct pci_dev * , int  , unsigned long  ) ;
extern int wake_up_process(struct task_struct * ) ;
extern void kfree(void const   * ) ;
extern void *ldv_malloc(size_t);
void *__kmalloc(size_t size, gfp_t t)
{
	return ldv_malloc(size);
}
void *ldv_malloc(size_t size ) ;
__inline static void *kmalloc(size_t size , gfp_t flags ) 
{ 
  void *tmp___2 ;

  {
  tmp___2 = __kmalloc(size, flags);
  return (tmp___2);
}
}
void *ldv_zalloc(size_t size ) ;
__inline static void *kzalloc(size_t size , gfp_t flags ) 
{ 
  void *tmp ;

  {
  tmp = kmalloc(size, flags | 32768U);
  return (tmp);
}
}
struct bfa_s *hal_mod_fcport_group1  ;
struct file *bfad_debugfs_op_regwr_group2  ;
int ldv_state_variable_20  ;
    klee_make_symbolic(&ldv_state_variable_20, sizeof(int), "ldv_state_variable_20");
int pci_counter  ;
    klee_make_symbolic(&pci_counter, sizeof(int), "pci_counter");
struct work_struct *ldv_work_struct_3_1  ;
int ldv_state_variable_30  ;
    klee_make_symbolic(&ldv_state_variable_30, sizeof(int), "ldv_state_variable_30");
int ldv_state_variable_0  ;
    klee_make_symbolic(&ldv_state_variable_0, sizeof(int), "ldv_state_variable_0");
int ldv_irq_2_0  =    0;
int ldv_state_variable_12  ;
    klee_make_symbolic(&ldv_state_variable_12, sizeof(int), "ldv_state_variable_12");
int ldv_state_variable_22  ;
    klee_make_symbolic(&ldv_state_variable_22, sizeof(int), "ldv_state_variable_22");
struct file *bfad_debugfs_op_fwsave_group2  ;
int ldv_state_variable_14  ;
    klee_make_symbolic(&ldv_state_variable_14, sizeof(int), "ldv_state_variable_14");
struct inode *bfad_debugfs_op_fwtrc_group1  ;
int ldv_state_variable_37  ;
    klee_make_symbolic(&ldv_state_variable_37, sizeof(int), "ldv_state_variable_37");
int ldv_state_variable_29  ;
    klee_make_symbolic(&ldv_state_variable_29, sizeof(int), "ldv_state_variable_29");
int ldv_state_variable_17  ;
    klee_make_symbolic(&ldv_state_variable_17, sizeof(int), "ldv_state_variable_17");
struct bfa_s *hal_mod_fcxp_group1  ;
struct bfa_iocfc_cfg_s *hal_mod_uf_group0  ;
void *ldv_irq_data_2_3  ;
int ldv_state_variable_19  ;
    klee_make_symbolic(&ldv_state_variable_19, sizeof(int), "ldv_state_variable_19");
struct work_struct *ldv_work_struct_4_3  ;
int ldv_state_variable_27  ;
    klee_make_symbolic(&ldv_state_variable_27, sizeof(int), "ldv_state_variable_27");
int ldv_state_variable_9  ;
    klee_make_symbolic(&ldv_state_variable_9, sizeof(int), "ldv_state_variable_9");
struct scsi_cmnd *bfad_im_vport_template_group0  ;
int ref_cnt  ;
int ldv_irq_line_1_1  ;
    klee_make_symbolic(&ldv_irq_line_1_1, sizeof(int), "ldv_irq_line_1_1");
void *ldv_irq_data_2_2  ;
int ldv_work_3_3  ;
    klee_make_symbolic(&ldv_work_3_3, sizeof(int), "ldv_work_3_3");
struct work_struct *ldv_work_struct_4_0  ;
int ldv_state_variable_7  ;
    klee_make_symbolic(&ldv_state_variable_7, sizeof(int), "ldv_state_variable_7");
int ldv_state_variable_23  ;
    klee_make_symbolic(&ldv_state_variable_23, sizeof(int), "ldv_state_variable_23");
struct work_struct *ldv_work_struct_3_3  ;
int ldv_irq_2_1  =    0;
void *ldv_irq_data_2_1  ;
int ldv_irq_1_3  =    0;
int ldv_irq_line_2_2  ;
    klee_make_symbolic(&ldv_irq_line_2_2, sizeof(int), "ldv_irq_line_2_2");
struct inode *bfad_debugfs_op_regrd_group1  ;
struct timer_list *ldv_timer_list_6  ;
int ldv_work_4_0  ;
    klee_make_symbolic(&ldv_work_4_0, sizeof(int), "ldv_work_4_0");
struct work_struct *ldv_work_struct_3_2  ;
int ldv_state_variable_6  ;
    klee_make_symbolic(&ldv_state_variable_6, sizeof(int), "ldv_state_variable_6");
void *ldv_irq_data_1_0  ;
struct scsi_device *bfad_im_scsi_host_template_group2  ;
struct scsi_target *bfad_im_fc_function_template_group2  ;
int ldv_work_5_0  ;
    klee_make_symbolic(&ldv_work_5_0, sizeof(int), "ldv_work_5_0");
void *ldv_irq_data_1_3  ;
int ldv_state_variable_26  ;
    klee_make_symbolic(&ldv_state_variable_26, sizeof(int), "ldv_state_variable_26");
struct work_struct *ldv_work_struct_4_2  ;
int ldv_state_variable_28  ;
    klee_make_symbolic(&ldv_state_variable_28, sizeof(int), "ldv_state_variable_28");
struct bfa_s *hal_mod_fcdiag_group1  ;
struct scsi_cmnd *bfad_im_scsi_host_template_group0  ;
int LDV_IN_INTERRUPT  =    1;
int ldv_state_variable_38  ;
    klee_make_symbolic(&ldv_state_variable_38, sizeof(int), "ldv_state_variable_38");
int ldv_irq_1_1  =    0;
struct work_struct *ldv_work_struct_5_1  ;
struct inode *bfad_debugfs_op_fwsave_group1  ;
struct fc_bsg_job *bfad_im_fc_function_template_group3  ;
int ldv_work_5_2  ;
    klee_make_symbolic(&ldv_work_5_2, sizeof(int), "ldv_work_5_2");
int ldv_state_variable_3  ;
    klee_make_symbolic(&ldv_state_variable_3, sizeof(int), "ldv_state_variable_3");
struct bfa_iocfc_cfg_s *hal_mod_fcp_group0  ;
int ldv_irq_line_1_0  ;
    klee_make_symbolic(&ldv_irq_line_1_0, sizeof(int), "ldv_irq_line_1_0");
struct Scsi_Host *bfad_im_vport_fc_function_template_group0  ;
int ldv_state_variable_31  ;
    klee_make_symbolic(&ldv_state_variable_31, sizeof(int), "ldv_state_variable_31");
struct file *bfad_debugfs_op_regrd_group2  ;
int ldv_state_variable_4  ;
    klee_make_symbolic(&ldv_state_variable_4, sizeof(int), "ldv_state_variable_4");
struct inode *bfad_debugfs_op_drvtrc_group1  ;
int ldv_state_variable_36  ;
    klee_make_symbolic(&ldv_state_variable_36, sizeof(int), "ldv_state_variable_36");
int ldv_state_variable_8  ;
    klee_make_symbolic(&ldv_state_variable_8, sizeof(int), "ldv_state_variable_8");
int ldv_state_variable_15  ;
    klee_make_symbolic(&ldv_state_variable_15, sizeof(int), "ldv_state_variable_15");
struct bfa_iocfc_cfg_s *hal_mod_dconf_group0  ;
struct work_struct *ldv_work_struct_5_2  ;
struct work_struct *ldv_work_struct_5_3  ;
int ldv_state_variable_5  ;
    klee_make_symbolic(&ldv_state_variable_5, sizeof(int), "ldv_state_variable_5");
int ldv_state_variable_21  ;
    klee_make_symbolic(&ldv_state_variable_21, sizeof(int), "ldv_state_variable_21");
int ldv_state_variable_33  ;
    klee_make_symbolic(&ldv_state_variable_33, sizeof(int), "ldv_state_variable_33");
struct bfa_s *hal_mod_uf_group1  ;
int ldv_state_variable_13  ;
    klee_make_symbolic(&ldv_state_variable_13, sizeof(int), "ldv_state_variable_13");
struct bfa_s *hal_mod_lps_group1  ;
struct scsi_device *bfad_im_vport_template_group2  ;
struct bfa_iocfc_cfg_s *hal_mod_lps_group0  ;
struct bfa_iocfc_cfg_s *hal_mod_fcport_group0  ;
int ldv_work_3_2  ;
    klee_make_symbolic(&ldv_work_3_2, sizeof(int), "ldv_work_3_2");
struct pci_dev *bfad_pci_driver_group1  ;
struct file *bfad_debugfs_op_fwtrc_group2  ;
int ldv_work_3_0  ;
    klee_make_symbolic(&ldv_work_3_0, sizeof(int), "ldv_work_3_0");
int ldv_irq_2_2  =    0;
int ldv_timer_state_6  =    0;
struct bfa_iocfc_cfg_s *hal_mod_fcdiag_group0  ;
int ldv_state_variable_24  ;
    klee_make_symbolic(&ldv_state_variable_24, sizeof(int), "ldv_state_variable_24");
int ldv_irq_line_2_0  ;
    klee_make_symbolic(&ldv_irq_line_2_0, sizeof(int), "ldv_irq_line_2_0");
struct Scsi_Host *bfad_im_fc_function_template_group0  ;
struct bfa_s *hal_mod_sgpg_group1  ;
struct bfa_s *hal_mod_dconf_group1  ;
struct Scsi_Host *bfad_im_vport_template_group1  ;
struct bfa_s *hal_mod_fcp_group1  ;
int ldv_state_variable_1  ;
    klee_make_symbolic(&ldv_state_variable_1, sizeof(int), "ldv_state_variable_1");
int ldv_work_5_3  ;
    klee_make_symbolic(&ldv_work_5_3, sizeof(int), "ldv_work_5_3");
int ldv_irq_line_1_2  ;
    klee_make_symbolic(&ldv_irq_line_1_2, sizeof(int), "ldv_irq_line_1_2");
struct inode *bfad_debugfs_op_regwr_group1  ;
struct bfa_iocfc_cfg_s *hal_mod_rport_group0  ;
int ldv_irq_line_2_3  ;
    klee_make_symbolic(&ldv_irq_line_2_3, sizeof(int), "ldv_irq_line_2_3");
struct bfa_s *hal_mod_rport_group1  ;
struct bfa_iocfc_cfg_s *hal_mod_sgpg_group0  ;
void *ldv_irq_data_1_1  ;
int ldv_state_variable_10  ;
    klee_make_symbolic(&ldv_state_variable_10, sizeof(int), "ldv_state_variable_10");
int ldv_irq_1_0  =    0;
int ldv_work_4_1  ;
    klee_make_symbolic(&ldv_work_4_1, sizeof(int), "ldv_work_4_1");
int ldv_work_4_3  ;
    klee_make_symbolic(&ldv_work_4_3, sizeof(int), "ldv_work_4_3");
int ldv_work_3_1  ;
    klee_make_symbolic(&ldv_work_3_1, sizeof(int), "ldv_work_3_1");
int ldv_state_variable_16  ;
    klee_make_symbolic(&ldv_state_variable_16, sizeof(int), "ldv_state_variable_16");
int ldv_irq_line_2_1  ;
    klee_make_symbolic(&ldv_irq_line_2_1, sizeof(int), "ldv_irq_line_2_1");
int ldv_state_variable_2  ;
    klee_make_symbolic(&ldv_state_variable_2, sizeof(int), "ldv_state_variable_2");
int ldv_state_variable_25  ;
    klee_make_symbolic(&ldv_state_variable_25, sizeof(int), "ldv_state_variable_25");
int ldv_work_5_1  ;
    klee_make_symbolic(&ldv_work_5_1, sizeof(int), "ldv_work_5_1");
void *ldv_irq_data_1_2  ;
struct pci_dev *bfad_err_handler_group0  ;
void *ldv_irq_data_2_0  ;
struct work_struct *ldv_work_struct_3_0  ;
int ldv_work_4_2  ;
    klee_make_symbolic(&ldv_work_4_2, sizeof(int), "ldv_work_4_2");
int ldv_state_variable_11  ;
    klee_make_symbolic(&ldv_state_variable_11, sizeof(int), "ldv_state_variable_11");
int ldv_irq_1_2  =    0;
int ldv_state_variable_18  ;
    klee_make_symbolic(&ldv_state_variable_18, sizeof(int), "ldv_state_variable_18");
struct fc_vport *bfad_im_fc_function_template_group1  ;
int ldv_irq_2_3  =    0;
struct work_struct *ldv_work_struct_5_0  ;
int ldv_irq_line_1_3  ;
    klee_make_symbolic(&ldv_irq_line_1_3, sizeof(int), "ldv_irq_line_1_3");
struct work_struct *ldv_work_struct_4_1  ;
int ldv_state_variable_32  ;
    klee_make_symbolic(&ldv_state_variable_32, sizeof(int), "ldv_state_variable_32");
int ldv_state_variable_34  ;
    klee_make_symbolic(&ldv_state_variable_34, sizeof(int), "ldv_state_variable_34");
struct Scsi_Host *bfad_im_scsi_host_template_group1  ;
struct bfa_iocfc_cfg_s *hal_mod_fcxp_group0  ;
int ldv_state_variable_35  ;
    klee_make_symbolic(&ldv_state_variable_35, sizeof(int), "ldv_state_variable_35");
struct file *bfad_debugfs_op_drvtrc_group2  ;
struct scsi_target *bfad_im_vport_fc_function_template_group1  ;
void ldv_file_operations_20(void) ;
void ldv_file_operations_19(void) ;
void ldv_initialize_fc_function_template_33(void) ;
void work_init_3(void) ;
void disable_suitable_irq_2(int line , void *data ) ;
void ldv_initialize_bfa_module_s_12(void) ;
int reg_check_1(irqreturn_t (*handler)(int  , void * ) ) ;
void activate_work_3(struct work_struct *work , int state ) ;
void work_init_5(void) ;
void ldv_file_operations_16(void) ;
void ldv_initialize_bfa_module_s_14(void) ;
void ldv_pci_driver_37(void) ;
void disable_suitable_irq_1(int line , void *data ) ;
void activate_suitable_irq_1(int line , void *data ) ;
void ldv_initialize_pci_error_handlers_38(void) ;
void disable_suitable_timer_6(struct timer_list *timer ) ;
void ldv_file_operations_17(void) ;
int ldv_irq_2(int state , int line , void *data ) ;
void ldv_initialize_bfa_module_s_15(void) ;
void activate_pending_timer_6(struct timer_list *timer , unsigned long data , int pending_flag ) ;
void ldv_initialize_scsi_host_template_35(void) ;
void choose_interrupt_2(void) ;
void ldv_initialize_bfa_module_s_13(void) ;
void ldv_initialize_bfa_module_s_9(void) ;
void activate_suitable_irq_2(int line , void *data ) ;
void choose_timer_6(struct timer_list *timer ) ;
int reg_timer_6(struct timer_list *timer ) ;
void ldv_initialize_bfa_module_s_11(void) ;
void choose_interrupt_1(void) ;
int reg_check_2(irqreturn_t (*handler)(int  , void * ) ) ;
void ldv_file_operations_18(void) ;
void work_init_4(void) ;
void ldv_initialize_bfa_module_s_7(void) ;
int ldv_irq_1(int state , int line , void *data ) ;
void ldv_initialize_bfa_module_s_8(void) ;
void ldv_initialize_fc_function_template_34(void) ;
void call_and_disable_all_3(int state ) ;
void ldv_initialize_bfa_module_s_10(void) ;
__inline static char const   *kobject_name(struct kobject  const  *kobj ) 
{ 


  {
  return ((char const   *)kobj->name);
}
}
extern struct task_struct *kthread_create_on_node(int (*)(void * ) , void * , int  ,
                                                  char const   *  , ...) ;
extern int kthread_stop(struct task_struct * ) ;
extern bool kthread_should_stop(void) ;
__inline static char const   *dev_name(struct device  const  *dev ) 
{ 
  char const   *tmp ;

  {
  if ((unsigned long )dev->init_name != (unsigned long )((char const   */* const  */)0)) {
    return ((char const   *)dev->init_name);
  } else {

  }
  tmp = kobject_name(& dev->kobj);
  return (tmp);
}
}
__inline static void *dev_get_drvdata(struct device  const  *dev ) 
{ 


  {
  return ((void *)dev->driver_data);
}
}
__inline static void dev_set_drvdata(struct device *dev , void *data ) 
{ 


  {
  dev->driver_data = data;
  return;
}
}
extern void dev_printk(char const   * , struct device  const  * , char const   * 
                       , ...) ;
extern int pci_bus_read_config_byte(struct pci_bus * , unsigned int  , int  , u8 * ) ;
extern int pci_bus_read_config_word(struct pci_bus * , unsigned int  , int  , u16 * ) ;
extern int pci_bus_write_config_word(struct pci_bus * , unsigned int  , int  , u16  ) ;
__inline static int pci_read_config_byte(struct pci_dev  const  *dev , int where ,
                                         u8 *val ) 
{ 
  int tmp ;

  {
  tmp = pci_bus_read_config_byte(dev->bus, dev->devfn, where, val);
  return (tmp);
}
}
__inline static int pci_read_config_word(struct pci_dev  const  *dev , int where ,
                                         u16 *val ) 
{ 
  int tmp ;

  {
  tmp = pci_bus_read_config_word(dev->bus, dev->devfn, where, val);
  return (tmp);
}
}
__inline static int pci_write_config_word(struct pci_dev  const  *dev , int where ,
                                          u16 val ) 
{ 
  int tmp ;

  {
  tmp = pci_bus_write_config_word(dev->bus, dev->devfn, where, (int )val);
  return (tmp);
}
}
extern int pci_enable_device(struct pci_dev * ) ;
extern void pci_disable_device(struct pci_dev * ) ;
extern void pci_set_master(struct pci_dev * ) ;
extern int pcie_get_readrq(struct pci_dev * ) ;
extern int pcie_set_readrq(struct pci_dev * , int  ) ;
extern int pci_save_state(struct pci_dev * ) ;
extern void pci_restore_state(struct pci_dev * ) ;
extern int pci_request_regions(struct pci_dev * , char const   * ) ;
extern void pci_release_regions(struct pci_dev * ) ;
extern int __pci_register_driver(struct pci_driver * , struct module * , char const   * ) ;
int ldv___pci_register_driver_38(struct pci_driver *ldv_func_arg1 , struct module *ldv_func_arg2 ,
                                 char const   *ldv_func_arg3 ) ;
extern void pci_unregister_driver(struct pci_driver * ) ;
void ldv_pci_unregister_driver_39(struct pci_driver *ldv_func_arg1 ) ;
extern void pci_disable_msix(struct pci_dev * ) ;
extern int pci_enable_msix_range(struct pci_dev * , struct msix_entry * , int  , int  ) ;
__inline static int pci_enable_msix_exact(struct pci_dev *dev , struct msix_entry *entries ,
                                          int nvec ) 
{ 
  int rc ;
    klee_make_symbolic(&rc, sizeof(int), "rc");
  int tmp ;

  {
  tmp = pci_enable_msix_range(dev, entries, nvec, nvec);
  rc = tmp;
  if (rc < 0) {
    return (rc);
  } else {

  }
  return (0);
}
}
extern int dma_supported(struct device * , u64  ) ;
extern int dma_set_mask(struct device * , u64  ) ;
extern void *dma_alloc_attrs(struct device * , size_t  , dma_addr_t * , gfp_t  , struct dma_attrs * ) ;
extern void dma_free_attrs(struct device * , size_t  , void * , dma_addr_t  , struct dma_attrs * ) ;
__inline static int dma_set_coherent_mask(struct device *dev , u64 mask ) 
{ 
  int tmp ;

  {
  tmp = dma_supported(dev, mask);
  if (tmp == 0) {
    return (-5);
  } else {

  }
  dev->coherent_dma_mask = mask;
  return (0);
}
}
__inline static int pci_set_dma_mask(struct pci_dev *dev , u64 mask ) 
{ 
  int tmp ;

  {
  tmp = dma_set_mask(& dev->dev, mask);
  return (tmp);
}
}
__inline static int pci_set_consistent_dma_mask(struct pci_dev *dev , u64 mask ) 
{ 
  int tmp ;

  {
  tmp = dma_set_coherent_mask(& dev->dev, mask);
  return (tmp);
}
}
__inline static void *pci_get_drvdata(struct pci_dev *pdev ) 
{ 
  void *tmp ;

  {
  tmp = dev_get_drvdata((struct device  const  *)(& pdev->dev));
  return (tmp);
}
}
__inline static void pci_set_drvdata(struct pci_dev *pdev , void *data ) 
{ 


  {
  dev_set_drvdata(& pdev->dev, data);
  return;
}
}
__inline static char const   *pci_name(struct pci_dev  const  *pdev ) 
{ 
  char const   *tmp ;

  {
  tmp = dev_name(& pdev->dev);
  return (tmp);
}
}
__inline static int pci_pcie_cap(struct pci_dev *dev ) 
{ 


  {
  return ((int )dev->pcie_cap);
}
}
__inline static bool pci_is_pcie(struct pci_dev *dev ) 
{ 
  int tmp ;

  {
  tmp = pci_pcie_cap(dev);
  return (tmp != 0);
}
}
extern int request_firmware(struct firmware  const  ** , char const   * , struct device * ) ;
extern void release_firmware(struct firmware  const  * ) ;
extern int request_threaded_irq(unsigned int  , irqreturn_t (*)(int  , void * ) ,
                                irqreturn_t (*)(int  , void * ) , unsigned long  ,
                                char const   * , void * ) ;
__inline static int request_irq(unsigned int irq , irqreturn_t (*handler)(int  , void * ) ,
                                unsigned long flags , char const   *name , void *dev ) 
{ 
  int tmp ;

  {
  tmp = request_threaded_irq(irq, handler, (irqreturn_t (*)(int  , void * ))0, flags,
                             name, dev);
  return (tmp);
}
}
__inline static int ldv_request_irq_24(unsigned int irq , irqreturn_t (*handler)(int  ,
                                                                                 void * ) ,
                                       unsigned long flags , char const   *name ,
                                       void *dev ) ;
__inline static int ldv_request_irq_26(unsigned int irq , irqreturn_t (*handler)(int  ,
                                                                                 void * ) ,
                                       unsigned long flags , char const   *name ,
                                       void *dev ) ;
extern void free_irq(unsigned int  , void * ) ;
void ldv_free_irq_25(unsigned int ldv_func_arg1 , void *ldv_func_arg2 ) ;
void ldv_free_irq_27(unsigned int ldv_func_arg1 , void *ldv_func_arg2 ) ;
void ldv_free_irq_28(unsigned int ldv_func_arg1 , void *ldv_func_arg2 ) ;
extern void *vmalloc(unsigned long  ) ;
extern void vfree(void const   * ) ;
extern int pci_enable_pcie_error_reporting(struct pci_dev * ) ;
extern int pci_disable_pcie_error_reporting(struct pci_dev * ) ;
extern int pci_cleanup_aer_uncorrect_error_status(struct pci_dev * ) ;
extern int scsi_add_host_with_dma(struct Scsi_Host * , struct device * , struct device * ) ;
int ldv_scsi_add_host_with_dma_17(struct Scsi_Host *shost , struct device *dev , struct device *dma_dev ) ;
__inline static u64 wwn_to_u64(u8 *wwn ) 
{ 


  {
  return (((((((((unsigned long long )*wwn << 56) | ((unsigned long long )*(wwn + 1UL) << 48)) | ((unsigned long long )*(wwn + 2UL) << 40)) | ((unsigned long long )*(wwn + 3UL) << 32)) | ((unsigned long long )*(wwn + 4UL) << 24)) | ((unsigned long long )*(wwn + 5UL) << 16)) | ((unsigned long long )*(wwn + 6UL) << 8)) | (unsigned long long )*(wwn + 7UL));
}
}
extern struct fc_vport *fc_vport_create(struct Scsi_Host * , int  , struct fc_vport_identifiers * ) ;
__inline static void bfa_trc_init(struct bfa_trc_mod_s *trcm ) 
{ 
  u32 tmp ;
  u32 tmp___0 ;

  {
  tmp___0 = 0U;
  trcm->stopped = tmp___0;
  tmp = tmp___0;
  trcm->tail = tmp;
  trcm->head = tmp;
  trcm->ntrc = 4096U;
  return;
}
}
__inline static void __bfa_trc(struct bfa_trc_mod_s *trcm , int fileno , int line ,
                               u64 data ) 
{ 
  int tail ;
    klee_make_symbolic(&tail, sizeof(int), "tail");
  struct bfa_trc_s *trc ;
  struct timeval tv ;

  {
  tail = (int )trcm->tail;
  trc = (struct bfa_trc_s *)(& trcm->trc) + (unsigned long )tail;
  if (trcm->stopped != 0U) {
    return;
  } else {

  }
  trc->fileno = (unsigned short )fileno;
  trc->line = (unsigned short )line;
  trc->data.u64 = data;
  do_gettimeofday(& tv);
  trc->timestamp = (u32 )(tv.tv_sec * 1000000L + tv.tv_usec);
  trcm->tail = (trcm->tail + 1U) & 4095U;
  if (trcm->tail == trcm->head) {
    trcm->head = (trcm->head + 1U) & 4095U;
  } else {

  }
  return;
}
}
__inline static void wwn2str(char *wwn_str , u64 wwn ) 
{ 
  union __anonunion_w_292 w ;

  {
  w.wwn = wwn;
  sprintf(wwn_str, "%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x", (int )w.byte[0], (int )w.byte[1],
          (int )w.byte[2], (int )w.byte[3], (int )w.byte[4], (int )w.byte[5], (int )w.byte[6],
          (int )w.byte[7]);
  return;
}
}
void bfa_plog_init(struct bfa_plog_s *plog ) ;
void bfa_plog_str(struct bfa_plog_s *plog , enum bfa_plog_mid mid , enum bfa_plog_eid event ,
                  u16 misc , char *log_str ) ;
void bfa_timer_beat(struct bfa_timer_mod_s *mod ) ;
void bfa_ioc_suspend(struct bfa_ioc_s *ioc ) ;
void bfa_ioc_debug_save_ftrc(struct bfa_ioc_s *ioc ) ;
u32 bfi_image_cb_size  ;
u32 bfi_image_ct_size  ;
u32 bfi_image_ct2_size  ;
u32 *bfi_image_cb  ;
u32 *bfi_image_ct  ;
u32 *bfi_image_ct2  ;
void bfa_iocfc_init(struct bfa_s *bfa ) ;
void bfa_iocfc_start(struct bfa_s *bfa ) ;
void bfa_iocfc_stop(struct bfa_s *bfa ) ;
void bfa_cfg_get_default(struct bfa_iocfc_cfg_s *cfg ) ;
void bfa_cfg_get_meminfo(struct bfa_iocfc_cfg_s *cfg , struct bfa_meminfo_s *meminfo ,
                         struct bfa_s *bfa ) ;
void bfa_attach(struct bfa_s *bfa , void *bfad , struct bfa_iocfc_cfg_s *cfg , struct bfa_meminfo_s *meminfo ,
                struct bfa_pcidev_s *pcidev ) ;
void bfa_detach(struct bfa_s *bfa ) ;
void bfa_cb_init(void *drv , enum bfa_status init_status ) ;
enum bfa_boolean bfa_intx(struct bfa_s *bfa ) ;
void bfa_isr_disable(struct bfa_s *bfa ) ;
void bfa_comp_deq(struct bfa_s *bfa , struct list_head *comp_q ) ;
void bfa_comp_process(struct bfa_s *bfa , struct list_head *comp_q ) ;
void bfa_comp_free(struct bfa_s *bfa , struct list_head *comp_q ) ;
enum bfa_boolean bfa_auto_recover ;
enum bfa_status bfa_fcs_vport_create(struct bfa_fcs_vport_s *vport , struct bfa_fcs_s *fcs ,
                                     u16 vf_id , struct bfa_lport_cfg_s *vport_cfg ,
                                     struct bfad_vport_s *vport_drv ) ;
enum bfa_status bfa_fcs_pbc_vport_create(struct bfa_fcs_vport_s *vport , struct bfa_fcs_s *fcs ,
                                         u16 vf_id , struct bfa_lport_cfg_s *vport_cfg ,
                                         struct bfad_vport_s *vport_drv ) ;
enum bfa_status bfa_fcs_vport_delete(struct bfa_fcs_vport_s *vport ) ;
enum bfa_status bfa_fcs_vport_start(struct bfa_fcs_vport_s *vport ) ;
void bfa_fcs_rport_set_del_timeout(u8 rport_tmo ) ;
void bfa_fcs_rport_set_max_logins(u32 max_logins ) ;
void bfa_fcs_attach(struct bfa_fcs_s *fcs , struct bfa_s *bfa , struct bfad_s *bfad ,
                    enum bfa_boolean min_cfg ) ;
void bfa_fcs_init(struct bfa_fcs_s *fcs ) ;
void bfa_fcs_pbc_vport_init(struct bfa_fcs_s *fcs ) ;
void bfa_fcs_update_cfg(struct bfa_fcs_s *fcs ) ;
void bfa_fcs_driver_info_init(struct bfa_fcs_s *fcs , struct bfa_fcs_driver_info_s *driver_info ) ;
void bfa_fcs_exit(struct bfa_fcs_s *fcs ) ;
void bfa_fcs_stop(struct bfa_fcs_s *fcs ) ;
void bfa_fcs_fabric_modstart(struct bfa_fcs_s *fcs ) ;
struct bfad_port_s *bfa_fcb_lport_new(struct bfad_s *bfad , struct bfa_fcs_lport_s *port ,
                                      enum bfa_lport_role roles , struct bfad_vf_s *vf_drv ,
                                      struct bfad_vport_s *vp_drv ) ;
void bfa_fcb_pbc_vport_create(struct bfad_s *bfad , struct bfi_pbc_vport_s pbc_vport ) ;
enum bfa_status bfa_fcb_rport_alloc(struct bfad_s *bfad , struct bfa_fcs_rport_s **rport ,
                                    struct bfad_rport_s **rport_drv ) ;
enum bfa_status bfad_vport_create(struct bfad_s *bfad , u16 vf_id , struct bfa_lport_cfg_s *port_cfg ,
                                  struct device *dev ) ;
enum bfa_status bfad_cfg_pport(struct bfad_s *bfad , enum bfa_lport_role role ) ;
enum bfa_status bfad_drv_init(struct bfad_s *bfad ) ;
enum bfa_status bfad_start_ops(struct bfad_s *bfad ) ;
void bfad_drv_start(struct bfad_s *bfad ) ;
void bfad_uncfg_pport(struct bfad_s *bfad ) ;
void bfad_stop(struct bfad_s *bfad ) ;
void bfad_fcs_stop(struct bfad_s *bfad ) ;
void bfad_remove_intr(struct bfad_s *bfad ) ;
void bfad_hal_mem_release(struct bfad_s *bfad ) ;
void bfad_hcb_comp(void *arg , enum bfa_status status ) ;
int bfad_setup_intr(struct bfad_s *bfad ) ;
void bfad_update_hal_cfg(struct bfa_iocfc_cfg_s *bfa_cfg ) ;
enum bfa_status bfad_hal_mem_alloc(struct bfad_s *bfad ) ;
void bfad_bfa_tmo(unsigned long data ) ;
void bfad_init_timer(struct bfad_s *bfad ) ;
int bfad_pci_init(struct pci_dev *pdev , struct bfad_s *bfad ) ;
void bfad_pci_uninit(struct pci_dev *pdev , struct bfad_s *bfad ) ;
void bfad_drv_uninit(struct bfad_s *bfad ) ;
int bfad_worker(void *ptr ) ;
extern void bfad_debugfs_init(struct bfad_port_s * ) ;
extern void bfad_debugfs_exit(struct bfad_port_s * ) ;
void bfad_pci_remove(struct pci_dev *pdev ) ;
int bfad_pci_probe(struct pci_dev *pdev , struct pci_device_id  const  *pid ) ;
void bfad_rport_online_wait(struct bfad_s *bfad ) ;
int bfad_get_linkup_delay(struct bfad_s *bfad ) ;
int bfad_install_msix_handler(struct bfad_s *bfad ) ;
struct pci_device_id bfad_id_table[7U] ;
struct list_head bfad_list ;
char *os_name  ;
char *os_patch  ;
char *host_name  ;
int num_rports  ;
    klee_make_symbolic(&num_rports, sizeof(int), "num_rports");
int num_ios  ;
    klee_make_symbolic(&num_ios, sizeof(int), "num_ios");
int num_tms  ;
    klee_make_symbolic(&num_tms, sizeof(int), "num_tms");
int num_fcxps  ;
    klee_make_symbolic(&num_fcxps, sizeof(int), "num_fcxps");
int num_ufbufs  ;
    klee_make_symbolic(&num_ufbufs, sizeof(int), "num_ufbufs");
int reqq_size  ;
    klee_make_symbolic(&reqq_size, sizeof(int), "reqq_size");
int rspq_size  ;
    klee_make_symbolic(&rspq_size, sizeof(int), "rspq_size");
int num_sgpgs  ;
int rport_del_timeout ;
    klee_make_symbolic(&rport_del_timeout, sizeof(int), "rport_del_timeout");
int bfa_lun_queue_depth ;
    klee_make_symbolic(&bfa_lun_queue_depth, sizeof(int), "bfa_lun_queue_depth");
int bfa_io_max_sge ;
    klee_make_symbolic(&bfa_io_max_sge, sizeof(int), "bfa_io_max_sge");
int bfa_log_level ;
    klee_make_symbolic(&bfa_log_level, sizeof(int), "bfa_log_level");
int ioc_auto_recover ;
    klee_make_symbolic(&ioc_auto_recover, sizeof(int), "ioc_auto_recover");
int bfa_linkup_delay ;
    klee_make_symbolic(&bfa_linkup_delay, sizeof(int), "bfa_linkup_delay");
int msix_disable_cb ;
    klee_make_symbolic(&msix_disable_cb, sizeof(int), "msix_disable_cb");
int msix_disable_ct ;
    klee_make_symbolic(&msix_disable_ct, sizeof(int), "msix_disable_ct");
int fdmi_enable ;
    klee_make_symbolic(&fdmi_enable, sizeof(int), "fdmi_enable");
int supported_fc4s  ;
    klee_make_symbolic(&supported_fc4s, sizeof(int), "supported_fc4s");
int pcie_max_read_reqsz  ;
    klee_make_symbolic(&pcie_max_read_reqsz, sizeof(int), "pcie_max_read_reqsz");
int max_xfer_size ;
    klee_make_symbolic(&max_xfer_size, sizeof(int), "max_xfer_size");
int bfa_debugfs_enable ;
    klee_make_symbolic(&bfa_debugfs_enable, sizeof(int), "bfa_debugfs_enable");
struct mutex bfad_mutex ;
enum bfa_status bfad_im_module_init(void) ;
void bfad_im_module_exit(void) ;
enum bfa_status bfad_im_probe(struct bfad_s *bfad ) ;
void bfad_im_probe_undo(struct bfad_s *bfad ) ;
enum bfa_status bfad_im_port_new(struct bfad_s *bfad , struct bfad_port_s *port ) ;
void bfad_im_port_delete(struct bfad_s *bfad , struct bfad_port_s *port ) ;
void bfad_im_port_clean(struct bfad_im_port_s *im_port ) ;
int bfad_im_scsi_host_alloc(struct bfad_s *bfad , struct bfad_im_port_s *im_port ,
                            struct device *dev ) ;
void bfad_im_scsi_host_free(struct bfad_s *bfad , struct bfad_im_port_s *im_port ) ;
void bfad_fc_host_init(struct bfad_im_port_s *im_port ) ;
irqreturn_t bfad_intx(int irq , void *dev_id ) ;
static int __trc_fileno  =    3073;
struct mutex bfad_mutex  =    {{1}, {{{{{0}}, 3735899821U, 4294967295U, (void *)-1, {0, {0, 0}, "bfad_mutex.wait_lock",
                                                          0, 0UL}}}}, {& bfad_mutex.wait_list,
                                                                       & bfad_mutex.wait_list},
    0, (void *)(& bfad_mutex), {0, {0, 0}, "bfad_mutex", 0, 0UL}};
struct list_head bfad_list  =    {& bfad_list, & bfad_list};
static int bfad_inst  ;
    klee_make_symbolic(&bfad_inst, sizeof(int), "bfad_inst");
static int num_sgpgs_parm  ;
    klee_make_symbolic(&num_sgpgs_parm, sizeof(int), "num_sgpgs_parm");
int rport_del_timeout  =    90;
int bfa_lun_queue_depth  =    32;
int bfa_io_max_sge  =    128;
int bfa_log_level  =    3;
int ioc_auto_recover  =    1;
int bfa_linkup_delay  =    -1;
int fdmi_enable  =    1;
int bfa_debugfs_enable  =    1;
int msix_disable_cb  =    0;
int msix_disable_ct  =    0;
int max_xfer_size  =    32767;
int max_rport_logins  =    1024;
static u32 *bfad_load_fwimg(struct pci_dev *pdev ) ;
static void bfad_free_fwimg(void) ;
static void bfad_read_firmware(struct pci_dev *pdev , u32 **bfi_image , u32 *bfi_image_size ,
                               char *fw_name ) ;
static char const   *msix_name_ct[9U]  = 
  {      "ctrl",      "cpe0",      "cpe1",      "cpe2", 
        "cpe3",      "rme0",      "rme1",      "rme2", 
        "rme3"};
static char const   *msix_name_cb[13U]  = 
  {      "cpe0",      "cpe1",      "cpe2",      "cpe3", 
        "rme0",      "rme1",      "rme2",      "rme3", 
        "eemc",      "elpu0",      "elpu1",      "epss", 
        "mlpu"};
static void bfad_sm_uninit(struct bfad_s *bfad , enum bfad_sm_event event ) ;
static void bfad_sm_created(struct bfad_s *bfad , enum bfad_sm_event event ) ;
static void bfad_sm_initializing(struct bfad_s *bfad , enum bfad_sm_event event ) ;
static void bfad_sm_operational(struct bfad_s *bfad , enum bfad_sm_event event ) ;
static void bfad_sm_stopping(struct bfad_s *bfad , enum bfad_sm_event event ) ;
static void bfad_sm_failed(struct bfad_s *bfad , enum bfad_sm_event event ) ;
static void bfad_sm_fcs_exit(struct bfad_s *bfad , enum bfad_sm_event event ) ;
static void bfad_sm_uninit(struct bfad_s *bfad , enum bfad_sm_event event ) 
{ 
  bool tmp ;

  {
  __bfa_trc(bfad->trcmod, __trc_fileno, 176, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 1U: 
  bfad->sm = (void (*)(void * , int  ))(& bfad_sm_created);
  bfad->bfad_tsk = kthread_create_on_node(& bfad_worker, (void *)bfad, -1, "%s", (char *)"bfad_worker");
  tmp = IS_ERR((void const   *)bfad->bfad_tsk);
  if ((int )tmp) {
    printk("\016bfad[%d]: Kernel thread creation failed!\n", bfad->inst_no);
    (*(bfad->sm))((void *)bfad, 2);
  } else {

  }
  (*(bfad->sm))((void *)bfad, 3);
  goto ldv_49929;
  case 9U: ;
  goto ldv_49929;
  default: 
  __bfa_trc(bfad->trcmod, __trc_fileno, 196, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfad.c",
         196, (unsigned int )event);
  }
  ldv_49929: ;
  return;
}
}
static void bfad_sm_created(struct bfad_s *bfad , enum bfad_sm_event event ) 
{ 
  unsigned long flags ;
  enum bfa_status ret ;
  int tmp ;
  raw_spinlock_t *tmp___0 ;
  int tmp___1 ;
  raw_spinlock_t *tmp___2 ;
  raw_spinlock_t *tmp___3 ;

  {
  __bfa_trc(bfad->trcmod, __trc_fileno, 209, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 3U: 
  bfad->sm = (void (*)(void * , int  ))(& bfad_sm_initializing);
  init_completion(& bfad->comp);
  tmp = bfad_setup_intr(bfad);
  if (tmp != 0) {
    printk("\fbfad%d: bfad_setup_intr failed\n", bfad->inst_no);
    (*(bfad->sm))((void *)bfad, 6);
    goto ldv_49939;
  } else {

  }
  tmp___0 = spinlock_check(& bfad->bfad_lock);
  flags = _raw_spin_lock_irqsave(tmp___0);
  bfa_iocfc_init(& bfad->bfa);
  spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  if ((int )bfad->bfad_flags & 1) {
    tmp___1 = bfad_install_msix_handler(bfad);
    if (tmp___1 != 0) {
      printk("\f%s: install_msix failed, bfad%d\n", "bfad_sm_created", bfad->inst_no);
    } else {

    }
  } else {

  }
  bfad_init_timer(bfad);
  wait_for_completion(& bfad->comp);
  if ((bfad->bfad_flags & 2U) != 0U) {
    (*(bfad->sm))((void *)bfad, 4);
  } else {
    printk("\fbfa %s: bfa init failed\n", bfad->pci_name);
    tmp___2 = spinlock_check(& bfad->bfad_lock);
    flags = _raw_spin_lock_irqsave(tmp___2);
    bfa_fcs_init(& bfad->bfa_fcs);
    spin_unlock_irqrestore(& bfad->bfad_lock, flags);
    ret = bfad_cfg_pport(bfad, 1);
    if ((unsigned int )ret != 0U) {
      init_completion(& bfad->comp);
      tmp___3 = spinlock_check(& bfad->bfad_lock);
      flags = _raw_spin_lock_irqsave(tmp___3);
      bfad->pport.flags = bfad->pport.flags | 1;
      bfa_fcs_exit(& bfad->bfa_fcs);
      spin_unlock_irqrestore(& bfad->bfad_lock, flags);
      wait_for_completion(& bfad->comp);
      (*(bfad->sm))((void *)bfad, 6);
      goto ldv_49939;
    } else {

    }
    bfad->bfad_flags = bfad->bfad_flags | 256U;
    (*(bfad->sm))((void *)bfad, 5);
  }
  goto ldv_49939;
  case 2U: 
  bfad->sm = (void (*)(void * , int  ))(& bfad_sm_uninit);
  goto ldv_49939;
  default: 
  __bfa_trc(bfad->trcmod, __trc_fileno, 275, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfad.c",
         275, (unsigned int )event);
  }
  ldv_49939: ;
  return;
}
}
static void bfad_sm_initializing(struct bfad_s *bfad , enum bfad_sm_event event ) 
{ 
  int retval ;
    klee_make_symbolic(&retval, sizeof(int), "retval");
  unsigned long flags ;
  raw_spinlock_t *tmp ;
  enum bfa_status tmp___0 ;
  raw_spinlock_t *tmp___1 ;

  {
  __bfa_trc(bfad->trcmod, __trc_fileno, 285, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 4U: 
  kthread_stop(bfad->bfad_tsk);
  tmp = spinlock_check(& bfad->bfad_lock);
  flags = _raw_spin_lock_irqsave(tmp);
  bfad->bfad_tsk = (struct task_struct *)0;
  spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  tmp___0 = bfad_start_ops(bfad);
  retval = (int )tmp___0;
  if (retval != 0) {
    bfad->sm = (void (*)(void * , int  ))(& bfad_sm_failed);
    goto ldv_49962;
  } else {

  }
  bfad->sm = (void (*)(void * , int  ))(& bfad_sm_operational);
  goto ldv_49962;
  case 6U: 
  bfad->sm = (void (*)(void * , int  ))(& bfad_sm_uninit);
  kthread_stop(bfad->bfad_tsk);
  tmp___1 = spinlock_check(& bfad->bfad_lock);
  flags = _raw_spin_lock_irqsave(tmp___1);
  bfad->bfad_tsk = (struct task_struct *)0;
  spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  goto ldv_49962;
  case 5U: 
  bfad->sm = (void (*)(void * , int  ))(& bfad_sm_failed);
  goto ldv_49962;
  default: 
  __bfa_trc(bfad->trcmod, __trc_fileno, 314, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfad.c",
         314, (unsigned int )event);
  }
  ldv_49962: ;
  return;
}
}
static void bfad_sm_failed(struct bfad_s *bfad , enum bfad_sm_event event ) 
{ 
  int retval ;
  enum bfa_status tmp ;

  {
  __bfa_trc(bfad->trcmod, __trc_fileno, 323, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 4U: 
  tmp = bfad_start_ops(bfad);
  retval = (int )tmp;
  if (retval != 0) {
    goto ldv_49975;
  } else {

  }
  bfad->sm = (void (*)(void * , int  ))(& bfad_sm_operational);
  goto ldv_49975;
  case 9U: 
  bfad->sm = (void (*)(void * , int  ))(& bfad_sm_fcs_exit);
  (*(bfad->sm))((void *)bfad, 7);
  goto ldv_49975;
  case 8U: 
  bfad->sm = (void (*)(void * , int  ))(& bfad_sm_uninit);
  bfad_remove_intr(bfad);
  ldv_del_timer_sync_18(& bfad->hal_tmo);
  goto ldv_49975;
  default: 
  __bfa_trc(bfad->trcmod, __trc_fileno, 345, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfad.c",
         345, (unsigned int )event);
  }
  ldv_49975: ;
  return;
}
}
static void bfad_sm_operational(struct bfad_s *bfad , enum bfad_sm_event event ) 
{ 


  {
  __bfa_trc(bfad->trcmod, __trc_fileno, 352, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 9U: 
  bfad->sm = (void (*)(void * , int  ))(& bfad_sm_fcs_exit);
  bfad_fcs_stop(bfad);
  goto ldv_49984;
  default: 
  __bfa_trc(bfad->trcmod, __trc_fileno, 361, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfad.c",
         361, (unsigned int )event);
  }
  ldv_49984: ;
  return;
}
}
static void bfad_sm_fcs_exit(struct bfad_s *bfad , enum bfad_sm_event event ) 
{ 


  {
  __bfa_trc(bfad->trcmod, __trc_fileno, 368, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 7U: 
  bfad->sm = (void (*)(void * , int  ))(& bfad_sm_stopping);
  bfad_stop(bfad);
  goto ldv_49991;
  default: 
  __bfa_trc(bfad->trcmod, __trc_fileno, 377, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfad.c",
         377, (unsigned int )event);
  }
  ldv_49991: ;
  return;
}
}
static void bfad_sm_stopping(struct bfad_s *bfad , enum bfad_sm_event event ) 
{ 


  {
  __bfa_trc(bfad->trcmod, __trc_fileno, 384, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 8U: 
  bfad->sm = (void (*)(void * , int  ))(& bfad_sm_uninit);
  bfad_remove_intr(bfad);
  ldv_del_timer_sync_19(& bfad->hal_tmo);
  bfad_im_probe_undo(bfad);
  bfad->bfad_flags = bfad->bfad_flags & 4294966783U;
  bfad_uncfg_pport(bfad);
  goto ldv_49998;
  default: 
  __bfa_trc(bfad->trcmod, __trc_fileno, 397, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfad.c",
         397, (unsigned int )event);
  goto ldv_49998;
  }
  ldv_49998: ;
  return;
}
}
void bfad_hcb_comp(void *arg , enum bfa_status status ) 
{ 
  struct bfad_hal_comp *fcomp ;

  {
  fcomp = (struct bfad_hal_comp *)arg;
  fcomp->status = status;
  complete(& fcomp->comp);
  return;
}
}
void bfa_cb_init(void *drv , enum bfa_status init_status ) 
{ 
  struct bfad_s *bfad ;

  {
  bfad = (struct bfad_s *)drv;
  if ((unsigned int )init_status == 0U) {
    bfad->bfad_flags = bfad->bfad_flags | 2U;
    if ((bfad->bfad_flags & 256U) != 0U) {
      bfad->bfad_flags = bfad->bfad_flags & 4294967039U;
      wake_up_process(bfad->bfad_tsk);
    } else {

    }
  } else {

  }
  complete(& bfad->comp);
  return;
}
}
struct bfad_port_s *bfa_fcb_lport_new(struct bfad_s *bfad , struct bfa_fcs_lport_s *port ,
                                      enum bfa_lport_role roles , struct bfad_vf_s *vf_drv ,
                                      struct bfad_vport_s *vp_drv ) 
{ 
  enum bfa_status rc ;
  struct bfad_port_s *port_drv ;

  {
  if ((unsigned long )vp_drv == (unsigned long )((struct bfad_vport_s *)0) && (unsigned long )vf_drv == (unsigned long )((struct bfad_vf_s *)0)) {
    port_drv = & bfad->pport;
    port_drv->pvb_type = 0;
  } else
  if ((unsigned long )vp_drv == (unsigned long )((struct bfad_vport_s *)0) && (unsigned long )vf_drv != (unsigned long )((struct bfad_vf_s *)0)) {
    port_drv = & vf_drv->base_port;
    port_drv->pvb_type = 2;
  } else
  if ((unsigned long )vp_drv != (unsigned long )((struct bfad_vport_s *)0) && (unsigned long )vf_drv == (unsigned long )((struct bfad_vf_s *)0)) {
    port_drv = & vp_drv->drv_port;
    port_drv->pvb_type = 1;
  } else {
    port_drv = & vp_drv->drv_port;
    port_drv->pvb_type = 3;
  }
  port_drv->fcs_port = port;
  port_drv->roles = (u32 )roles;
  if ((int )roles & 1) {
    rc = bfad_im_port_new(bfad, port_drv);
    if ((unsigned int )rc != 0U) {
      bfad_im_port_delete(bfad, port_drv);
      port_drv = (struct bfad_port_s *)0;
    } else {

    }
  } else {

  }
  return (port_drv);
}
}
enum bfa_status bfa_fcb_rport_alloc(struct bfad_s *bfad , struct bfa_fcs_rport_s **rport ,
                                    struct bfad_rport_s **rport_drv ) 
{ 
  enum bfa_status rc ;
  void *tmp ;

  {
  rc = 0;
  tmp = kzalloc(976UL, 32U);
  *rport_drv = (struct bfad_rport_s *)tmp;
  if ((unsigned long )*rport_drv == (unsigned long )((struct bfad_rport_s *)0)) {
    rc = 3;
    goto ext;
  } else {

  }
  *rport = & (*rport_drv)->fcs_rport;
  ext: ;
  return (rc);
}
}
void bfa_fcb_pbc_vport_create(struct bfad_s *bfad , struct bfi_pbc_vport_s pbc_vport ) 
{ 
  struct bfa_lport_cfg_s port_cfg ;
  struct bfad_vport_s *vport ;
  int rc ;
  void *tmp ;
  enum bfa_status tmp___0 ;

  {
  port_cfg.pwwn = 0ULL;
  port_cfg.nwwn = 0ULL;
  port_cfg.sym_name.symname[0] = (char)0;
  port_cfg.sym_name.symname[1] = (char)0;
  port_cfg.sym_name.symname[2] = (char)0;
  port_cfg.sym_name.symname[3] = (char)0;
  port_cfg.sym_name.symname[4] = (char)0;
  port_cfg.sym_name.symname[5] = (char)0;
  port_cfg.sym_name.symname[6] = (char)0;
  port_cfg.sym_name.symname[7] = (char)0;
  port_cfg.sym_name.symname[8] = (char)0;
  port_cfg.sym_name.symname[9] = (char)0;
  port_cfg.sym_name.symname[10] = (char)0;
  port_cfg.sym_name.symname[11] = (char)0;
  port_cfg.sym_name.symname[12] = (char)0;
  port_cfg.sym_name.symname[13] = (char)0;
  port_cfg.sym_name.symname[14] = (char)0;
  port_cfg.sym_name.symname[15] = (char)0;
  port_cfg.sym_name.symname[16] = (char)0;
  port_cfg.sym_name.symname[17] = (char)0;
  port_cfg.sym_name.symname[18] = (char)0;
  port_cfg.sym_name.symname[19] = (char)0;
  port_cfg.sym_name.symname[20] = (char)0;
  port_cfg.sym_name.symname[21] = (char)0;
  port_cfg.sym_name.symname[22] = (char)0;
  port_cfg.sym_name.symname[23] = (char)0;
  port_cfg.sym_name.symname[24] = (char)0;
  port_cfg.sym_name.symname[25] = (char)0;
  port_cfg.sym_name.symname[26] = (char)0;
  port_cfg.sym_name.symname[27] = (char)0;
  port_cfg.sym_name.symname[28] = (char)0;
  port_cfg.sym_name.symname[29] = (char)0;
  port_cfg.sym_name.symname[30] = (char)0;
  port_cfg.sym_name.symname[31] = (char)0;
  port_cfg.sym_name.symname[32] = (char)0;
  port_cfg.sym_name.symname[33] = (char)0;
  port_cfg.sym_name.symname[34] = (char)0;
  port_cfg.sym_name.symname[35] = (char)0;
  port_cfg.sym_name.symname[36] = (char)0;
  port_cfg.sym_name.symname[37] = (char)0;
  port_cfg.sym_name.symname[38] = (char)0;
  port_cfg.sym_name.symname[39] = (char)0;
  port_cfg.sym_name.symname[40] = (char)0;
  port_cfg.sym_name.symname[41] = (char)0;
  port_cfg.sym_name.symname[42] = (char)0;
  port_cfg.sym_name.symname[43] = (char)0;
  port_cfg.sym_name.symname[44] = (char)0;
  port_cfg.sym_name.symname[45] = (char)0;
  port_cfg.sym_name.symname[46] = (char)0;
  port_cfg.sym_name.symname[47] = (char)0;
  port_cfg.sym_name.symname[48] = (char)0;
  port_cfg.sym_name.symname[49] = (char)0;
  port_cfg.sym_name.symname[50] = (char)0;
  port_cfg.sym_name.symname[51] = (char)0;
  port_cfg.sym_name.symname[52] = (char)0;
  port_cfg.sym_name.symname[53] = (char)0;
  port_cfg.sym_name.symname[54] = (char)0;
  port_cfg.sym_name.symname[55] = (char)0;
  port_cfg.sym_name.symname[56] = (char)0;
  port_cfg.sym_name.symname[57] = (char)0;
  port_cfg.sym_name.symname[58] = (char)0;
  port_cfg.sym_name.symname[59] = (char)0;
  port_cfg.sym_name.symname[60] = (char)0;
  port_cfg.sym_name.symname[61] = (char)0;
  port_cfg.sym_name.symname[62] = (char)0;
  port_cfg.sym_name.symname[63] = (char)0;
  port_cfg.sym_name.symname[64] = (char)0;
  port_cfg.sym_name.symname[65] = (char)0;
  port_cfg.sym_name.symname[66] = (char)0;
  port_cfg.sym_name.symname[67] = (char)0;
  port_cfg.sym_name.symname[68] = (char)0;
  port_cfg.sym_name.symname[69] = (char)0;
  port_cfg.sym_name.symname[70] = (char)0;
  port_cfg.sym_name.symname[71] = (char)0;
  port_cfg.sym_name.symname[72] = (char)0;
  port_cfg.sym_name.symname[73] = (char)0;
  port_cfg.sym_name.symname[74] = (char)0;
  port_cfg.sym_name.symname[75] = (char)0;
  port_cfg.sym_name.symname[76] = (char)0;
  port_cfg.sym_name.symname[77] = (char)0;
  port_cfg.sym_name.symname[78] = (char)0;
  port_cfg.sym_name.symname[79] = (char)0;
  port_cfg.sym_name.symname[80] = (char)0;
  port_cfg.sym_name.symname[81] = (char)0;
  port_cfg.sym_name.symname[82] = (char)0;
  port_cfg.sym_name.symname[83] = (char)0;
  port_cfg.sym_name.symname[84] = (char)0;
  port_cfg.sym_name.symname[85] = (char)0;
  port_cfg.sym_name.symname[86] = (char)0;
  port_cfg.sym_name.symname[87] = (char)0;
  port_cfg.sym_name.symname[88] = (char)0;
  port_cfg.sym_name.symname[89] = (char)0;
  port_cfg.sym_name.symname[90] = (char)0;
  port_cfg.sym_name.symname[91] = (char)0;
  port_cfg.sym_name.symname[92] = (char)0;
  port_cfg.sym_name.symname[93] = (char)0;
  port_cfg.sym_name.symname[94] = (char)0;
  port_cfg.sym_name.symname[95] = (char)0;
  port_cfg.sym_name.symname[96] = (char)0;
  port_cfg.sym_name.symname[97] = (char)0;
  port_cfg.sym_name.symname[98] = (char)0;
  port_cfg.sym_name.symname[99] = (char)0;
  port_cfg.sym_name.symname[100] = (char)0;
  port_cfg.sym_name.symname[101] = (char)0;
  port_cfg.sym_name.symname[102] = (char)0;
  port_cfg.sym_name.symname[103] = (char)0;
  port_cfg.sym_name.symname[104] = (char)0;
  port_cfg.sym_name.symname[105] = (char)0;
  port_cfg.sym_name.symname[106] = (char)0;
  port_cfg.sym_name.symname[107] = (char)0;
  port_cfg.sym_name.symname[108] = (char)0;
  port_cfg.sym_name.symname[109] = (char)0;
  port_cfg.sym_name.symname[110] = (char)0;
  port_cfg.sym_name.symname[111] = (char)0;
  port_cfg.sym_name.symname[112] = (char)0;
  port_cfg.sym_name.symname[113] = (char)0;
  port_cfg.sym_name.symname[114] = (char)0;
  port_cfg.sym_name.symname[115] = (char)0;
  port_cfg.sym_name.symname[116] = (char)0;
  port_cfg.sym_name.symname[117] = (char)0;
  port_cfg.sym_name.symname[118] = (char)0;
  port_cfg.sym_name.symname[119] = (char)0;
  port_cfg.sym_name.symname[120] = (char)0;
  port_cfg.sym_name.symname[121] = (char)0;
  port_cfg.sym_name.symname[122] = (char)0;
  port_cfg.sym_name.symname[123] = (char)0;
  port_cfg.sym_name.symname[124] = (char)0;
  port_cfg.sym_name.symname[125] = (char)0;
  port_cfg.sym_name.symname[126] = (char)0;
  port_cfg.sym_name.symname[127] = (char)0;
  port_cfg.node_sym_name.symname[0] = (char)0;
  port_cfg.node_sym_name.symname[1] = (char)0;
  port_cfg.node_sym_name.symname[2] = (char)0;
  port_cfg.node_sym_name.symname[3] = (char)0;
  port_cfg.node_sym_name.symname[4] = (char)0;
  port_cfg.node_sym_name.symname[5] = (char)0;
  port_cfg.node_sym_name.symname[6] = (char)0;
  port_cfg.node_sym_name.symname[7] = (char)0;
  port_cfg.node_sym_name.symname[8] = (char)0;
  port_cfg.node_sym_name.symname[9] = (char)0;
  port_cfg.node_sym_name.symname[10] = (char)0;
  port_cfg.node_sym_name.symname[11] = (char)0;
  port_cfg.node_sym_name.symname[12] = (char)0;
  port_cfg.node_sym_name.symname[13] = (char)0;
  port_cfg.node_sym_name.symname[14] = (char)0;
  port_cfg.node_sym_name.symname[15] = (char)0;
  port_cfg.node_sym_name.symname[16] = (char)0;
  port_cfg.node_sym_name.symname[17] = (char)0;
  port_cfg.node_sym_name.symname[18] = (char)0;
  port_cfg.node_sym_name.symname[19] = (char)0;
  port_cfg.node_sym_name.symname[20] = (char)0;
  port_cfg.node_sym_name.symname[21] = (char)0;
  port_cfg.node_sym_name.symname[22] = (char)0;
  port_cfg.node_sym_name.symname[23] = (char)0;
  port_cfg.node_sym_name.symname[24] = (char)0;
  port_cfg.node_sym_name.symname[25] = (char)0;
  port_cfg.node_sym_name.symname[26] = (char)0;
  port_cfg.node_sym_name.symname[27] = (char)0;
  port_cfg.node_sym_name.symname[28] = (char)0;
  port_cfg.node_sym_name.symname[29] = (char)0;
  port_cfg.node_sym_name.symname[30] = (char)0;
  port_cfg.node_sym_name.symname[31] = (char)0;
  port_cfg.node_sym_name.symname[32] = (char)0;
  port_cfg.node_sym_name.symname[33] = (char)0;
  port_cfg.node_sym_name.symname[34] = (char)0;
  port_cfg.node_sym_name.symname[35] = (char)0;
  port_cfg.node_sym_name.symname[36] = (char)0;
  port_cfg.node_sym_name.symname[37] = (char)0;
  port_cfg.node_sym_name.symname[38] = (char)0;
  port_cfg.node_sym_name.symname[39] = (char)0;
  port_cfg.node_sym_name.symname[40] = (char)0;
  port_cfg.node_sym_name.symname[41] = (char)0;
  port_cfg.node_sym_name.symname[42] = (char)0;
  port_cfg.node_sym_name.symname[43] = (char)0;
  port_cfg.node_sym_name.symname[44] = (char)0;
  port_cfg.node_sym_name.symname[45] = (char)0;
  port_cfg.node_sym_name.symname[46] = (char)0;
  port_cfg.node_sym_name.symname[47] = (char)0;
  port_cfg.node_sym_name.symname[48] = (char)0;
  port_cfg.node_sym_name.symname[49] = (char)0;
  port_cfg.node_sym_name.symname[50] = (char)0;
  port_cfg.node_sym_name.symname[51] = (char)0;
  port_cfg.node_sym_name.symname[52] = (char)0;
  port_cfg.node_sym_name.symname[53] = (char)0;
  port_cfg.node_sym_name.symname[54] = (char)0;
  port_cfg.node_sym_name.symname[55] = (char)0;
  port_cfg.node_sym_name.symname[56] = (char)0;
  port_cfg.node_sym_name.symname[57] = (char)0;
  port_cfg.node_sym_name.symname[58] = (char)0;
  port_cfg.node_sym_name.symname[59] = (char)0;
  port_cfg.node_sym_name.symname[60] = (char)0;
  port_cfg.node_sym_name.symname[61] = (char)0;
  port_cfg.node_sym_name.symname[62] = (char)0;
  port_cfg.node_sym_name.symname[63] = (char)0;
  port_cfg.node_sym_name.symname[64] = (char)0;
  port_cfg.node_sym_name.symname[65] = (char)0;
  port_cfg.node_sym_name.symname[66] = (char)0;
  port_cfg.node_sym_name.symname[67] = (char)0;
  port_cfg.node_sym_name.symname[68] = (char)0;
  port_cfg.node_sym_name.symname[69] = (char)0;
  port_cfg.node_sym_name.symname[70] = (char)0;
  port_cfg.node_sym_name.symname[71] = (char)0;
  port_cfg.node_sym_name.symname[72] = (char)0;
  port_cfg.node_sym_name.symname[73] = (char)0;
  port_cfg.node_sym_name.symname[74] = (char)0;
  port_cfg.node_sym_name.symname[75] = (char)0;
  port_cfg.node_sym_name.symname[76] = (char)0;
  port_cfg.node_sym_name.symname[77] = (char)0;
  port_cfg.node_sym_name.symname[78] = (char)0;
  port_cfg.node_sym_name.symname[79] = (char)0;
  port_cfg.node_sym_name.symname[80] = (char)0;
  port_cfg.node_sym_name.symname[81] = (char)0;
  port_cfg.node_sym_name.symname[82] = (char)0;
  port_cfg.node_sym_name.symname[83] = (char)0;
  port_cfg.node_sym_name.symname[84] = (char)0;
  port_cfg.node_sym_name.symname[85] = (char)0;
  port_cfg.node_sym_name.symname[86] = (char)0;
  port_cfg.node_sym_name.symname[87] = (char)0;
  port_cfg.node_sym_name.symname[88] = (char)0;
  port_cfg.node_sym_name.symname[89] = (char)0;
  port_cfg.node_sym_name.symname[90] = (char)0;
  port_cfg.node_sym_name.symname[91] = (char)0;
  port_cfg.node_sym_name.symname[92] = (char)0;
  port_cfg.node_sym_name.symname[93] = (char)0;
  port_cfg.node_sym_name.symname[94] = (char)0;
  port_cfg.node_sym_name.symname[95] = (char)0;
  port_cfg.node_sym_name.symname[96] = (char)0;
  port_cfg.node_sym_name.symname[97] = (char)0;
  port_cfg.node_sym_name.symname[98] = (char)0;
  port_cfg.node_sym_name.symname[99] = (char)0;
  port_cfg.node_sym_name.symname[100] = (char)0;
  port_cfg.node_sym_name.symname[101] = (char)0;
  port_cfg.node_sym_name.symname[102] = (char)0;
  port_cfg.node_sym_name.symname[103] = (char)0;
  port_cfg.node_sym_name.symname[104] = (char)0;
  port_cfg.node_sym_name.symname[105] = (char)0;
  port_cfg.node_sym_name.symname[106] = (char)0;
  port_cfg.node_sym_name.symname[107] = (char)0;
  port_cfg.node_sym_name.symname[108] = (char)0;
  port_cfg.node_sym_name.symname[109] = (char)0;
  port_cfg.node_sym_name.symname[110] = (char)0;
  port_cfg.node_sym_name.symname[111] = (char)0;
  port_cfg.node_sym_name.symname[112] = (char)0;
  port_cfg.node_sym_name.symname[113] = (char)0;
  port_cfg.node_sym_name.symname[114] = (char)0;
  port_cfg.node_sym_name.symname[115] = (char)0;
  port_cfg.node_sym_name.symname[116] = (char)0;
  port_cfg.node_sym_name.symname[117] = (char)0;
  port_cfg.node_sym_name.symname[118] = (char)0;
  port_cfg.node_sym_name.symname[119] = (char)0;
  port_cfg.node_sym_name.symname[120] = (char)0;
  port_cfg.node_sym_name.symname[121] = (char)0;
  port_cfg.node_sym_name.symname[122] = (char)0;
  port_cfg.node_sym_name.symname[123] = (char)0;
  port_cfg.node_sym_name.symname[124] = (char)0;
  port_cfg.node_sym_name.symname[125] = (char)0;
  port_cfg.node_sym_name.symname[126] = (char)0;
  port_cfg.node_sym_name.symname[127] = (char)0;
  port_cfg.roles = 0;
  port_cfg.rsvd = 0U;
  port_cfg.preboot_vp = 0;
  port_cfg.tag[0] = (unsigned char)0;
  port_cfg.tag[1] = (unsigned char)0;
  port_cfg.tag[2] = (unsigned char)0;
  port_cfg.tag[3] = (unsigned char)0;
  port_cfg.tag[4] = (unsigned char)0;
  port_cfg.tag[5] = (unsigned char)0;
  port_cfg.tag[6] = (unsigned char)0;
  port_cfg.tag[7] = (unsigned char)0;
  port_cfg.tag[8] = (unsigned char)0;
  port_cfg.tag[9] = (unsigned char)0;
  port_cfg.tag[10] = (unsigned char)0;
  port_cfg.tag[11] = (unsigned char)0;
  port_cfg.tag[12] = (unsigned char)0;
  port_cfg.tag[13] = (unsigned char)0;
  port_cfg.tag[14] = (unsigned char)0;
  port_cfg.tag[15] = (unsigned char)0;
  port_cfg.padding[0] = (unsigned char)0;
  port_cfg.padding[1] = (unsigned char)0;
  port_cfg.padding[2] = (unsigned char)0;
  port_cfg.padding[3] = (unsigned char)0;
  tmp = kzalloc(1928UL, 32U);
  vport = (struct bfad_vport_s *)tmp;
  if ((unsigned long )vport == (unsigned long )((struct bfad_vport_s *)0)) {
    __bfa_trc(bfad->trcmod, __trc_fileno, 512, 0ULL);
    return;
  } else {

  }
  vport->drv_port.bfad = bfad;
  port_cfg.roles = 1;
  port_cfg.pwwn = pbc_vport.vp_pwwn;
  port_cfg.nwwn = pbc_vport.vp_nwwn;
  port_cfg.preboot_vp = 1;
  tmp___0 = bfa_fcs_pbc_vport_create(& vport->fcs_vport, & bfad->bfa_fcs, 0, & port_cfg,
                                     vport);
  rc = (int )tmp___0;
  if (rc != 0) {
    __bfa_trc(bfad->trcmod, __trc_fileno, 526, 0ULL);
    return;
  } else {

  }
  list_add_tail(& vport->list_entry, & bfad->pbc_vport_list);
  return;
}
}
void bfad_hal_mem_release(struct bfad_s *bfad ) 
{ 
  struct bfa_meminfo_s *hal_meminfo ;
  struct bfa_mem_dma_s *dma_info ;
  struct bfa_mem_dma_s *dma_elem ;
  struct bfa_mem_kva_s *kva_info ;
  struct bfa_mem_kva_s *kva_elem ;
  struct list_head *dm_qe ;
  struct list_head *km_qe ;

  {
  hal_meminfo = & bfad->meminfo;
  dma_info = & hal_meminfo->dma_info;
  kva_info = & hal_meminfo->kva_info;
  km_qe = kva_info->qe.next;
  goto ldv_50044;
  ldv_50043: 
  kva_elem = (struct bfa_mem_kva_s *)km_qe;
  vfree((void const   *)kva_elem->kva);
  km_qe = km_qe->next;
  ldv_50044: ;
  if ((unsigned long )(& kva_info->qe) != (unsigned long )km_qe) {
    goto ldv_50043;
  } else {

  }
  dm_qe = dma_info->qe.next;
  goto ldv_50047;
  ldv_50046: 
  dma_elem = (struct bfa_mem_dma_s *)dm_qe;
  dma_free_attrs(& (bfad->pcidev)->dev, (size_t )dma_elem->mem_len, (void *)dma_elem->kva,
                 dma_elem->dma, (struct dma_attrs *)0);
  dm_qe = dm_qe->next;
  ldv_50047: ;
  if ((unsigned long )(& dma_info->qe) != (unsigned long )dm_qe) {
    goto ldv_50046;
  } else {

  }
  memset((void *)hal_meminfo, 0, 96UL);
  return;
}
}
void bfad_update_hal_cfg(struct bfa_iocfc_cfg_s *bfa_cfg ) 
{ 


  {
  if (num_rports > 0) {
    bfa_cfg->fwcfg.num_rports = (u16 )num_rports;
  } else {

  }
  if (num_ios > 0) {
    bfa_cfg->fwcfg.num_ioim_reqs = (u16 )num_ios;
  } else {

  }
  if (num_tms > 0) {
    bfa_cfg->fwcfg.num_tskim_reqs = (u16 )num_tms;
  } else {

  }
  if (num_fcxps > 0 && num_fcxps <= 256) {
    bfa_cfg->fwcfg.num_fcxp_reqs = (u16 )num_fcxps;
  } else {

  }
  if (num_ufbufs > 0 && num_ufbufs <= 256) {
    bfa_cfg->fwcfg.num_uf_bufs = (u16 )num_ufbufs;
  } else {

  }
  if (reqq_size > 0) {
    bfa_cfg->drvcfg.num_reqq_elems = (u16 )reqq_size;
  } else {

  }
  if (rspq_size > 0) {
    bfa_cfg->drvcfg.num_rspq_elems = (u16 )rspq_size;
  } else {

  }
  if (num_sgpgs > 0 && num_sgpgs <= 8192) {
    bfa_cfg->drvcfg.num_sgpgs = (u16 )num_sgpgs;
  } else {

  }
  num_rports = (int )bfa_cfg->fwcfg.num_rports;
  num_ios = (int )bfa_cfg->fwcfg.num_ioim_reqs;
  num_tms = (int )bfa_cfg->fwcfg.num_tskim_reqs;
  num_fcxps = (int )bfa_cfg->fwcfg.num_fcxp_reqs;
  num_ufbufs = (int )bfa_cfg->fwcfg.num_uf_bufs;
  reqq_size = (int )bfa_cfg->drvcfg.num_reqq_elems;
  rspq_size = (int )bfa_cfg->drvcfg.num_rspq_elems;
  num_sgpgs = (int )bfa_cfg->drvcfg.num_sgpgs;
  return;
}
}
enum bfa_status bfad_hal_mem_alloc(struct bfad_s *bfad ) 
{ 
  struct bfa_meminfo_s *hal_meminfo ;
  struct bfa_mem_dma_s *dma_info ;
  struct bfa_mem_dma_s *dma_elem ;
  struct bfa_mem_kva_s *kva_info ;
  struct bfa_mem_kva_s *kva_elem ;
  struct list_head *dm_qe ;
  struct list_head *km_qe ;
  enum bfa_status rc ;
  dma_addr_t phys_addr ;
  void *tmp ;
  void *tmp___0 ;

  {
  hal_meminfo = & bfad->meminfo;
  rc = 0;
  bfa_cfg_get_default(& bfad->ioc_cfg);
  bfad_update_hal_cfg(& bfad->ioc_cfg);
  bfad->cfg_data.ioc_queue_depth = (u32 )bfad->ioc_cfg.fwcfg.num_ioim_reqs;
  bfa_cfg_get_meminfo(& bfad->ioc_cfg, hal_meminfo, & bfad->bfa);
  dma_info = & hal_meminfo->dma_info;
  kva_info = & hal_meminfo->kva_info;
  km_qe = kva_info->qe.next;
  goto ldv_50066;
  ldv_50065: 
  kva_elem = (struct bfa_mem_kva_s *)km_qe;
  tmp = vmalloc((unsigned long )kva_elem->mem_len);
  kva_elem->kva = (u8 *)tmp;
  if ((unsigned long )kva_elem->kva == (unsigned long )((u8 *)0U)) {
    bfad_hal_mem_release(bfad);
    rc = 3;
    goto ext;
  } else {

  }
  memset((void *)kva_elem->kva, 0, (size_t )kva_elem->mem_len);
  km_qe = km_qe->next;
  ldv_50066: ;
  if ((unsigned long )(& kva_info->qe) != (unsigned long )km_qe) {
    goto ldv_50065;
  } else {

  }
  dm_qe = dma_info->qe.next;
  goto ldv_50069;
  ldv_50068: 
  dma_elem = (struct bfa_mem_dma_s *)dm_qe;
  tmp___0 = dma_alloc_attrs(& (bfad->pcidev)->dev, (size_t )dma_elem->mem_len, & phys_addr,
                            208U, (struct dma_attrs *)0);
  dma_elem->kva = (u8 *)tmp___0;
  if ((unsigned long )dma_elem->kva == (unsigned long )((u8 *)0U)) {
    bfad_hal_mem_release(bfad);
    rc = 3;
    goto ext;
  } else {

  }
  dma_elem->dma = phys_addr;
  memset((void *)dma_elem->kva, 0, (size_t )dma_elem->mem_len);
  dm_qe = dm_qe->next;
  ldv_50069: ;
  if ((unsigned long )(& dma_info->qe) != (unsigned long )dm_qe) {
    goto ldv_50068;
  } else {

  }

  ext: ;
  return (rc);
}
}
enum bfa_status bfad_vport_create(struct bfad_s *bfad , u16 vf_id , struct bfa_lport_cfg_s *port_cfg ,
                                  struct device *dev ) 
{ 
  struct bfad_vport_s *vport ;
  int rc ;
  unsigned long flags ;
  struct completion fcomp ;
  void *tmp ;
  raw_spinlock_t *tmp___0 ;
  enum bfa_status tmp___1 ;
  raw_spinlock_t *tmp___2 ;
  raw_spinlock_t *tmp___3 ;

  {
  rc = 0;
  tmp = kzalloc(1928UL, 208U);
  vport = (struct bfad_vport_s *)tmp;
  if ((unsigned long )vport == (unsigned long )((struct bfad_vport_s *)0)) {
    rc = 3;
    goto ext;
  } else {

  }
  vport->drv_port.bfad = bfad;
  tmp___0 = spinlock_check(& bfad->bfad_lock);
  flags = _raw_spin_lock_irqsave(tmp___0);
  tmp___1 = bfa_fcs_vport_create(& vport->fcs_vport, & bfad->bfa_fcs, (int )vf_id,
                                 port_cfg, vport);
  rc = (int )tmp___1;
  spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  if (rc != 0) {
    goto ext_free_vport;
  } else {

  }
  if ((int )port_cfg->roles & 1) {
    rc = bfad_im_scsi_host_alloc(bfad, vport->drv_port.im_port, dev);
    if (rc != 0) {
      goto ext_free_fcs_vport;
    } else {

    }
  } else {

  }
  tmp___2 = spinlock_check(& bfad->bfad_lock);
  flags = _raw_spin_lock_irqsave(tmp___2);
  bfa_fcs_vport_start(& vport->fcs_vport);
  list_add_tail(& vport->list_entry, & bfad->vport_list);
  spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  return (0);
  ext_free_fcs_vport: 
  tmp___3 = spinlock_check(& bfad->bfad_lock);
  flags = _raw_spin_lock_irqsave(tmp___3);
  vport->comp_del = & fcomp;
  init_completion(vport->comp_del);
  bfa_fcs_vport_delete(& vport->fcs_vport);
  spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  wait_for_completion(vport->comp_del);
  ext_free_vport: 
  kfree((void const   *)vport);
  ext: ;
  return ((enum bfa_status )rc);
}
}
void bfad_bfa_tmo(unsigned long data ) 
{ 
  struct bfad_s *bfad ;
  unsigned long flags ;
  struct list_head doneq ;
  raw_spinlock_t *tmp ;
  raw_spinlock_t *tmp___0 ;
  int tmp___1 ;
  unsigned long tmp___2 ;

  {
  bfad = (struct bfad_s *)data;
  tmp = spinlock_check(& bfad->bfad_lock);
  flags = _raw_spin_lock_irqsave(tmp);
  bfa_timer_beat(& bfad->bfa.timer_mod);
  bfa_comp_deq(& bfad->bfa, & doneq);
  spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  tmp___1 = list_empty((struct list_head  const  *)(& doneq));
  if (tmp___1 == 0) {
    bfa_comp_process(& bfad->bfa, & doneq);
    tmp___0 = spinlock_check(& bfad->bfad_lock);
    flags = _raw_spin_lock_irqsave(tmp___0);
    bfa_comp_free(& bfad->bfa, & doneq);
    spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  } else {

  }
  tmp___2 = msecs_to_jiffies(200U);
  ldv_mod_timer_20(& bfad->hal_tmo, tmp___2 + (unsigned long )jiffies);
  return;
}
}
void bfad_init_timer(struct bfad_s *bfad ) 
{ 
  unsigned long tmp ;

  {
  reg_timer_6(& bfad->hal_tmo);
  bfad->hal_tmo.function = & bfad_bfa_tmo;
  bfad->hal_tmo.data = (unsigned long )bfad;
  tmp = msecs_to_jiffies(200U);
  ldv_mod_timer_21(& bfad->hal_tmo, tmp + (unsigned long )jiffies);
  return;
}
}
int bfad_pci_init(struct pci_dev *pdev , struct bfad_s *bfad ) 
{ 
  int rc ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
    klee_make_symbolic(&tmp___4, sizeof(int), "tmp___4");
  int max_rq ;
    klee_make_symbolic(&max_rq, sizeof(int), "max_rq");
  int tmp___5 ;
    klee_make_symbolic(&tmp___5, sizeof(int), "tmp___5");
  bool tmp___6 ;
  bool tmp___7 ;

  {
  rc = -19;
  tmp = pci_enable_device(pdev);
  if (tmp != 0) {
    printk("\vpci_enable_device fail %p\n", pdev);
    goto out;
  } else {

  }
  tmp___0 = pci_request_regions(pdev, "bfa");
  if (tmp___0 != 0) {
    goto out_disable_device;
  } else {

  }
  pci_set_master(pdev);
  tmp___3 = pci_set_dma_mask(pdev, 0xffffffffffffffffULL);
  if (tmp___3 != 0) {
    goto _L;
  } else {
    tmp___4 = pci_set_consistent_dma_mask(pdev, 0xffffffffffffffffULL);
    if (tmp___4 != 0) {
      _L: /* CIL Label */ 
      tmp___1 = pci_set_dma_mask(pdev, 4294967295ULL);
      if (tmp___1 != 0) {
        printk("\vpci_set_dma_mask fail %p\n", pdev);
        goto out_release_region;
      } else {
        tmp___2 = pci_set_consistent_dma_mask(pdev, 4294967295ULL);
        if (tmp___2 != 0) {
          printk("\vpci_set_dma_mask fail %p\n", pdev);
          goto out_release_region;
        } else {

        }
      }
    } else {

    }
  }
  pci_enable_pcie_error_reporting(pdev);
  bfad->pci_bar0_kva = pci_iomap(pdev, 0, pdev->resource[0].start != 0ULL || pdev->resource[0].end != pdev->resource[0].start ? (unsigned long )((pdev->resource[0].end - pdev->resource[0].start) + 1ULL) : 0UL);
  bfad->pci_bar2_kva = pci_iomap(pdev, 2, pdev->resource[2].start != 0ULL || pdev->resource[2].end != pdev->resource[2].start ? (unsigned long )((pdev->resource[2].end - pdev->resource[2].start) + 1ULL) : 0UL);
  if ((unsigned long )bfad->pci_bar0_kva == (unsigned long )((void *)0)) {
    printk("\vFail to map bar0\n");
    goto out_release_region;
  } else {

  }
  bfad->hal_pcidev.pci_slot = (int )(pdev->devfn >> 3) & 31;
  bfad->hal_pcidev.pci_func = (unsigned int )((u8 )pdev->devfn) & 7U;
  bfad->hal_pcidev.pci_bar_kva = bfad->pci_bar0_kva;
  bfad->hal_pcidev.device_id = pdev->device;
  bfad->hal_pcidev.ssid = pdev->subsystem_device;
  bfad->pci_name = pci_name((struct pci_dev  const  *)pdev);
  bfad->pci_attr.vendor_id = pdev->vendor;
  bfad->pci_attr.device_id = pdev->device;
  bfad->pci_attr.ssid = pdev->subsystem_device;
  bfad->pci_attr.ssvid = pdev->subsystem_vendor;
  bfad->pci_attr.pcifn = pdev->devfn & 7U;
  bfad->pcidev = pdev;
  tmp___7 = pci_is_pcie(pdev);
  if ((int )tmp___7 && pcie_max_read_reqsz != 0) {
    if (pcie_max_read_reqsz > 127 && pcie_max_read_reqsz <= 4096) {
      tmp___6 = is_power_of_2((unsigned long )pcie_max_read_reqsz);
      if ((int )tmp___6) {
        tmp___5 = pcie_get_readrq(pdev);
        max_rq = tmp___5;
        printk("\fBFA[%s]: pcie_max_read_request_size is %d, reset to %d\n", bfad->pci_name,
               max_rq, pcie_max_read_reqsz);
        pcie_set_readrq(pdev, pcie_max_read_reqsz);
      } else {
        printk("\fBFA[%s]: invalid pcie_max_read_request_size %d ignored\n", bfad->pci_name,
               pcie_max_read_reqsz);
      }
    } else {
      printk("\fBFA[%s]: invalid pcie_max_read_request_size %d ignored\n", bfad->pci_name,
             pcie_max_read_reqsz);
    }
  } else {

  }
  pci_save_state(pdev);
  return (0);
  out_release_region: 
  pci_release_regions(pdev);
  out_disable_device: 
  pci_disable_device(pdev);
  out: ;
  return (rc);
}
}
void bfad_pci_uninit(struct pci_dev *pdev , struct bfad_s *bfad ) 
{ 


  {
  pci_iounmap(pdev, bfad->pci_bar0_kva);
  pci_iounmap(pdev, bfad->pci_bar2_kva);
  pci_release_regions(pdev);
  pci_disable_pcie_error_reporting(pdev);
  pci_disable_device(pdev);
  return;
}
}
enum bfa_status bfad_drv_init(struct bfad_s *bfad ) 
{ 
  enum bfa_status rc ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;

  {
  bfad->cfg_data.rport_del_timeout = (u32 )rport_del_timeout;
  bfad->cfg_data.lun_queue_depth = (u32 )bfa_lun_queue_depth;
  bfad->cfg_data.io_max_sge = (u32 )bfa_io_max_sge;
  bfad->cfg_data.binding_method = 1U;
  rc = bfad_hal_mem_alloc(bfad);
  if ((unsigned int )rc != 0U) {
    printk("\fbfad%d bfad_hal_mem_alloc failure\n", bfad->inst_no);
    printk("\fNot enough memory to attach all Brocade HBA ports, %s", (char *)"System may need more memory.\n");
    return (1);
  } else {

  }
  bfad->bfa.trcmod = bfad->trcmod;
  bfad->bfa.plog = & bfad->plog_buf;
  bfa_plog_init(& bfad->plog_buf);
  bfa_plog_str(& bfad->plog_buf, 2, 16, 0, (char *)"Driver Attach");
  bfa_attach(& bfad->bfa, (void *)bfad, & bfad->ioc_cfg, & bfad->meminfo, & bfad->hal_pcidev);
  tmp = spinlock_check(& bfad->bfad_lock);
  flags = _raw_spin_lock_irqsave(tmp);
  bfad->bfa_fcs.trcmod = bfad->trcmod;
  bfa_fcs_attach(& bfad->bfa_fcs, & bfad->bfa, bfad, 0);
  bfad->bfa_fcs.fdmi_enabled = (enum bfa_boolean )fdmi_enable;
  spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  bfad->bfad_flags = bfad->bfad_flags | 4U;
  return (0);
}
}
void bfad_drv_uninit(struct bfad_s *bfad ) 
{ 
  unsigned long flags ;
  raw_spinlock_t *tmp ;

  {
  tmp = spinlock_check(& bfad->bfad_lock);
  flags = _raw_spin_lock_irqsave(tmp);
  init_completion(& bfad->comp);
  bfa_iocfc_stop(& bfad->bfa);
  spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  wait_for_completion(& bfad->comp);
  ldv_del_timer_sync_22(& bfad->hal_tmo);
  bfa_isr_disable(& bfad->bfa);
  bfa_detach(& bfad->bfa);
  bfad_remove_intr(bfad);
  bfad_hal_mem_release(bfad);
  bfad->bfad_flags = bfad->bfad_flags & 4294967291U;
  return;
}
}
void bfad_drv_start(struct bfad_s *bfad ) 
{ 
  unsigned long flags ;
  raw_spinlock_t *tmp ;

  {
  tmp = spinlock_check(& bfad->bfad_lock);
  flags = _raw_spin_lock_irqsave(tmp);
  bfa_iocfc_start(& bfad->bfa);
  bfa_fcs_pbc_vport_init(& bfad->bfa_fcs);
  bfa_fcs_fabric_modstart(& bfad->bfa_fcs);
  bfad->bfad_flags = bfad->bfad_flags | 16U;
  spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  if ((unsigned long )bfad->im != (unsigned long )((struct bfad_im_s *)0)) {
    ldv_flush_workqueue_23((bfad->im)->drv_workq);
  } else {

  }
  return;
}
}
void bfad_fcs_stop(struct bfad_s *bfad ) 
{ 
  unsigned long flags ;
  raw_spinlock_t *tmp ;

  {
  tmp = spinlock_check(& bfad->bfad_lock);
  flags = _raw_spin_lock_irqsave(tmp);
  init_completion(& bfad->comp);
  bfad->pport.flags = bfad->pport.flags | 1;
  bfa_fcs_exit(& bfad->bfa_fcs);
  spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  wait_for_completion(& bfad->comp);
  (*(bfad->sm))((void *)bfad, 7);
  return;
}
}
void bfad_stop(struct bfad_s *bfad ) 
{ 
  unsigned long flags ;
  raw_spinlock_t *tmp ;

  {
  tmp = spinlock_check(& bfad->bfad_lock);
  flags = _raw_spin_lock_irqsave(tmp);
  init_completion(& bfad->comp);
  bfa_iocfc_stop(& bfad->bfa);
  bfad->bfad_flags = bfad->bfad_flags & 4294967279U;
  spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  wait_for_completion(& bfad->comp);
  (*(bfad->sm))((void *)bfad, 8);
  return;
}
}
enum bfa_status bfad_cfg_pport(struct bfad_s *bfad , enum bfa_lport_role role ) 
{ 
  int rc ;

  {
  rc = 0;
  if (supported_fc4s & 1 && (int )role & 1) {
    if ((unsigned long )bfad->pport.im_port == (unsigned long )((struct bfad_im_port_s *)0)) {
      rc = 1;
      goto out;
    } else {

    }
    rc = bfad_im_scsi_host_alloc(bfad, bfad->pport.im_port, & (bfad->pcidev)->dev);
    if (rc != 0) {
      goto out;
    } else {

    }
    bfad->pport.roles = bfad->pport.roles | 1U;
  } else {

  }
  bfad->bfad_flags = bfad->bfad_flags | 8U;
  out: ;
  return ((enum bfa_status )rc);
}
}
void bfad_uncfg_pport(struct bfad_s *bfad ) 
{ 


  {
  if (supported_fc4s & 1 && (int )bfad->pport.roles & 1) {
    bfad_im_scsi_host_free(bfad, bfad->pport.im_port);
    bfad_im_port_clean(bfad->pport.im_port);
    kfree((void const   *)bfad->pport.im_port);
    bfad->pport.roles = bfad->pport.roles & 4294967294U;
  } else {

  }
  bfad->bfad_flags = bfad->bfad_flags & 4294967287U;
  return;
}
}
enum bfa_status bfad_start_ops(struct bfad_s *bfad ) 
{ 
  int retval ;
  unsigned long flags ;
  struct bfad_vport_s *vport ;
  struct bfad_vport_s *vport_new ;
  struct bfa_fcs_driver_info_s driver_info ;
  raw_spinlock_t *tmp ;
  enum bfa_status tmp___0 ;
  enum bfa_status tmp___1 ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  struct fc_vport_identifiers vid ;
  struct fc_vport *fc_vport ;
  char pwwn_buf[32U] ;
  struct list_head  const  *__mptr___1 ;

  {
  if (max_xfer_size <= 63) {
    max_xfer_size = 64;
  } else {

  }
  if (max_xfer_size > 32767) {
    max_xfer_size = 32767;
  } else {

  }
  memset((void *)(& driver_info), 0, 320UL);
  strncpy((char *)(& driver_info.version), "3.2.23.0", 63UL);
  if ((unsigned long )host_name != (unsigned long )((char *)0)) {
    strncpy((char *)(& driver_info.host_machine_name), (char const   *)host_name,
            63UL);
  } else {

  }
  if ((unsigned long )os_name != (unsigned long )((char *)0)) {
    strncpy((char *)(& driver_info.host_os_name), (char const   *)os_name, 63UL);
  } else {

  }
  if ((unsigned long )os_patch != (unsigned long )((char *)0)) {
    strncpy((char *)(& driver_info.host_os_patch), (char const   *)os_patch, 63UL);
  } else {

  }
  strncpy((char *)(& driver_info.os_device_name), bfad->pci_name, 63UL);
  tmp = spinlock_check(& bfad->bfad_lock);
  flags = _raw_spin_lock_irqsave(tmp);
  bfa_fcs_driver_info_init(& bfad->bfa_fcs, & driver_info);
  if ((bfad->bfad_flags & 8U) != 0U) {
    bfa_fcs_update_cfg(& bfad->bfa_fcs);
  } else {
    bfa_fcs_init(& bfad->bfa_fcs);
  }
  spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  if ((bfad->bfad_flags & 8U) == 0U) {
    tmp___0 = bfad_cfg_pport(bfad, 1);
    retval = (int )tmp___0;
    if (retval != 0) {
      return (1);
    } else {

    }
  } else {

  }
  bfad_fc_host_init(bfad->pport.im_port);
  tmp___1 = bfad_im_probe(bfad);
  retval = (int )tmp___1;
  if (retval != 0) {
    printk("\fbfad_im_probe failed\n");
    if ((unsigned long )bfad->sm == (unsigned long )((void (*)(void * , int  ))(& bfad_sm_initializing))) {
      bfad->sm = (void (*)(void * , int  ))(& bfad_sm_failed);
    } else {

    }
    return (1);
  } else {
    bfad->bfad_flags = bfad->bfad_flags | 512U;
  }
  bfad_drv_start(bfad);
  __mptr = (struct list_head  const  *)bfad->pbc_vport_list.next;
  vport = (struct bfad_vport_s *)__mptr + 0xfffffffffffff888UL;
  __mptr___0 = (struct list_head  const  *)vport->list_entry.next;
  vport_new = (struct bfad_vport_s *)__mptr___0 + 0xfffffffffffff888UL;
  goto ldv_50187;
  ldv_50186: 
  memset((void *)(& vid), 0, 96UL);
  vid.roles = 2U;
  vid.vport_type = 7;
  vid.disable = 0;
  vid.node_name = wwn_to_u64((u8 *)(& vport->fcs_vport.lport.port_cfg.nwwn));
  vid.port_name = wwn_to_u64((u8 *)(& vport->fcs_vport.lport.port_cfg.pwwn));
  fc_vport = fc_vport_create((bfad->pport.im_port)->shost, 0, & vid);
  if ((unsigned long )fc_vport == (unsigned long )((struct fc_vport *)0)) {
    wwn2str((char *)(& pwwn_buf), vid.port_name);
    printk("\fbfad%d: failed to create pbc vport %s\n", bfad->inst_no, (char *)(& pwwn_buf));
  } else {

  }
  list_del(& vport->list_entry);
  kfree((void const   *)vport);
  vport = vport_new;
  __mptr___1 = (struct list_head  const  *)vport_new->list_entry.next;
  vport_new = (struct bfad_vport_s *)__mptr___1 + 0xfffffffffffff888UL;
  ldv_50187: ;
  if ((unsigned long )(& vport->list_entry) != (unsigned long )(& bfad->pbc_vport_list)) {
    goto ldv_50186;
  } else {

  }

  if (bfa_linkup_delay < 0) {
    bfa_linkup_delay = bfad_get_linkup_delay(bfad);
    bfad_rport_online_wait(bfad);
    bfa_linkup_delay = -1;
  } else {
    bfad_rport_online_wait(bfad);
  }
  if (bfa_log_level == 4 || (int )((signed char )*("\016" + 1)) <= 52) {
    dev_printk("\016", (struct device  const  *)(& (bfad->pcidev)->dev), "bfa device claimed\n");
  } else {

  }
  return (0);
}
}
int bfad_worker(void *ptr ) 
{ 
  struct bfad_s *bfad ;
  unsigned long flags ;
  bool tmp ;
  raw_spinlock_t *tmp___0 ;

  {
  bfad = (struct bfad_s *)ptr;
  tmp = kthread_should_stop();
  if ((int )tmp) {
    return (0);
  } else {

  }
  (*(bfad->sm))((void *)bfad, 4);
  tmp___0 = spinlock_check(& bfad->bfad_lock);
  flags = _raw_spin_lock_irqsave(tmp___0);
  bfad->bfad_tsk = (struct task_struct *)0;
  spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  return (0);
}
}
irqreturn_t bfad_intx(int irq , void *dev_id ) 
{ 
  struct bfad_s *bfad ;
  struct list_head doneq ;
  unsigned long flags ;
  enum bfa_boolean rc ;
  raw_spinlock_t *tmp ;
  raw_spinlock_t *tmp___0 ;
  int tmp___1 ;

  {
  bfad = (struct bfad_s *)dev_id;
  tmp = spinlock_check(& bfad->bfad_lock);
  flags = _raw_spin_lock_irqsave(tmp);
  rc = bfa_intx(& bfad->bfa);
  if ((unsigned int )rc == 0U) {
    spin_unlock_irqrestore(& bfad->bfad_lock, flags);
    return (0);
  } else {

  }
  bfa_comp_deq(& bfad->bfa, & doneq);
  spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  tmp___1 = list_empty((struct list_head  const  *)(& doneq));
  if (tmp___1 == 0) {
    bfa_comp_process(& bfad->bfa, & doneq);
    tmp___0 = spinlock_check(& bfad->bfad_lock);
    flags = _raw_spin_lock_irqsave(tmp___0);
    bfa_comp_free(& bfad->bfa, & doneq);
    spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  } else {

  }
  return (1);
}
}
static irqreturn_t bfad_msix(int irq , void *dev_id ) 
{ 
  struct bfad_msix_s *vec ;
  struct bfad_s *bfad ;
  struct list_head doneq ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;
  raw_spinlock_t *tmp___0 ;
  int tmp___1 ;

  {
  vec = (struct bfad_msix_s *)dev_id;
  bfad = vec->bfad;
  tmp = spinlock_check(& bfad->bfad_lock);
  flags = _raw_spin_lock_irqsave(tmp);
  (*(bfad->bfa.msix.handler[(int )vec->msix.entry]))(& bfad->bfa, (int )vec->msix.entry);
  bfa_comp_deq(& bfad->bfa, & doneq);
  spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  tmp___1 = list_empty((struct list_head  const  *)(& doneq));
  if (tmp___1 == 0) {
    bfa_comp_process(& bfad->bfa, & doneq);
    tmp___0 = spinlock_check(& bfad->bfad_lock);
    flags = _raw_spin_lock_irqsave(tmp___0);
    bfa_comp_free(& bfad->bfa, & doneq);
    spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  } else {

  }
  return (1);
}
}
static void bfad_init_msix_entry(struct bfad_s *bfad , struct msix_entry *msix_entries ,
                                 int mask , int max_bit ) 
{ 
  int i ;
    klee_make_symbolic(&i, sizeof(int), "i");
  int match ;
    klee_make_symbolic(&match, sizeof(int), "match");

  {
  match = 1;
  i = 0;
  bfad->nvec = 0;
  goto ldv_50234;
  ldv_50233: ;
  if ((mask & match) != 0) {
    bfad->msix_tab[bfad->nvec].msix.entry = (u16 )i;
    bfad->msix_tab[bfad->nvec].bfad = bfad;
    (msix_entries + (unsigned long )bfad->nvec)->entry = (u16 )i;
    bfad->nvec = bfad->nvec + 1;
  } else {

  }
  match = match << 1;
  i = i + 1;
  ldv_50234: ;
  if (i <= 21) {
    goto ldv_50233;
  } else {

  }

  return;
}
}
int bfad_install_msix_handler(struct bfad_s *bfad ) 
{ 
  int i ;
  int error ;
    klee_make_symbolic(&error, sizeof(int), "error");
  int j ;
    klee_make_symbolic(&j, sizeof(int), "j");

  {
  error = 0;
  i = 0;
  goto ldv_50246;
  ldv_50245: 
  sprintf((char *)(& bfad->msix_tab[i].name), "bfa-%s-%s", bfad->pci_name, (unsigned int )bfad->hal_pcidev.device_id == 19U || (unsigned int )bfad->hal_pcidev.device_id == 23U ? msix_name_cb[i] : msix_name_ct[i]);
  error = ldv_request_irq_24(bfad->msix_tab[i].msix.vector, & bfad_msix, 0UL, (char const   *)(& bfad->msix_tab[i].name),
                             (void *)(& bfad->msix_tab) + (unsigned long )i);
  __bfa_trc(bfad->trcmod, __trc_fileno, 1193, (unsigned long long )i);
  __bfa_trc(bfad->trcmod, __trc_fileno, 1194, (unsigned long long )bfad->msix_tab[i].msix.vector);
  if (error != 0) {
    j = 0;
    goto ldv_50243;
    ldv_50242: 
    ldv_free_irq_25(bfad->msix_tab[j].msix.vector, (void *)(& bfad->msix_tab) + (unsigned long )j);
    j = j + 1;
    ldv_50243: ;
    if (j < i) {
      goto ldv_50242;
    } else {

    }
    bfad->bfad_flags = bfad->bfad_flags & 4294967294U;
    pci_disable_msix(bfad->pcidev);
    return (1);
  } else {

  }
  i = i + 1;
  ldv_50246: ;
  if (bfad->nvec > i) {
    goto ldv_50245;
  } else {

  }

  return (0);
}
}
int bfad_setup_intr(struct bfad_s *bfad ) 
{ 
  int error ;
  u32 mask ;
  u32 i ;
  u32 num_bit ;
  u32 max_bit ;
  struct msix_entry msix_entries[22U] ;
  struct pci_dev *pdev ;
  u16 reg ;

  {
  mask = 0U;
  num_bit = 0U;
  max_bit = 0U;
  pdev = bfad->pcidev;
  (*(bfad->bfa.iocfc.hwif.hw_msix_getvecs))(& bfad->bfa, & mask, & num_bit, & max_bit);
  bfad_init_msix_entry(bfad, (struct msix_entry *)(& msix_entries), (int )mask, (int )max_bit);
  if (((((unsigned int )pdev->device == 20U || (unsigned int )pdev->device == 33U) || ((unsigned int )pdev->device == 34U || (unsigned int )pdev->device == 35U)) && msix_disable_ct == 0) || (((unsigned int )pdev->device == 19U || (unsigned int )pdev->device == 23U) && msix_disable_cb == 0)) {
    error = pci_enable_msix_exact(bfad->pcidev, (struct msix_entry *)(& msix_entries),
                                  bfad->nvec);
    if (error == -28 && (((unsigned int )pdev->device == 20U || (unsigned int )pdev->device == 33U) || ((unsigned int )pdev->device == 34U || (unsigned int )pdev->device == 35U))) {
      printk("\fbfa %s: trying one msix vector failed to allocate %d[%d]\n", bfad->pci_name,
             bfad->nvec, error);
      bfad->nvec = 1;
      error = pci_enable_msix_exact(bfad->pcidev, (struct msix_entry *)(& msix_entries),
                                    1);
    } else {

    }
    if (error != 0) {
      printk("\fbfad%d: pci_enable_msix_exact failed (%d), use line based.\n", bfad->inst_no,
             error);
      goto line_based;
    } else {

    }
    pci_read_config_word((struct pci_dev  const  *)pdev, 4, & reg);
    if (((int )reg & 1024) == 0) {
      pci_write_config_word((struct pci_dev  const  *)pdev, 4, (int )((unsigned int )reg | 1024U));
    } else {

    }
    i = 0U;
    goto ldv_50261;
    ldv_50260: 
    __bfa_trc(bfad->trcmod, __trc_fileno, 1262, (unsigned long long )msix_entries[i].vector);
    bfad->msix_tab[i].msix.vector = msix_entries[i].vector;
    i = i + 1U;
    ldv_50261: ;
    if ((u32 )bfad->nvec > i) {
      goto ldv_50260;
    } else {

    }
    (*(bfad->bfa.iocfc.hwif.hw_msix_init))(& bfad->bfa, bfad->nvec);
    bfad->bfad_flags = bfad->bfad_flags | 1U;
    return (0);
  } else {

  }
  line_based: 
  error = ldv_request_irq_26((bfad->pcidev)->irq, & bfad_intx, 128UL, "bfa", (void *)bfad);
  if (error != 0) {
    return (error);
  } else {

  }
  bfad->bfad_flags = bfad->bfad_flags | 1024U;
  return (0);
}
}
void bfad_remove_intr(struct bfad_s *bfad ) 
{ 
  int i ;

  {
  if ((int )bfad->bfad_flags & 1) {
    i = 0;
    goto ldv_50268;
    ldv_50267: 
    ldv_free_irq_27(bfad->msix_tab[i].msix.vector, (void *)(& bfad->msix_tab) + (unsigned long )i);
    i = i + 1;
    ldv_50268: ;
    if (bfad->nvec > i) {
      goto ldv_50267;
    } else {

    }
    pci_disable_msix(bfad->pcidev);
    bfad->bfad_flags = bfad->bfad_flags & 4294967294U;
  } else
  if ((bfad->bfad_flags & 1024U) != 0U) {
    ldv_free_irq_28((bfad->pcidev)->irq, (void *)bfad);
  } else {

  }
  return;
}
}
int bfad_pci_probe(struct pci_dev *pdev , struct pci_device_id  const  *pid ) 
{ 
  struct bfad_s *bfad ;
  int error ;
  int retval ;
  int i ;
  void *tmp ;
  void *tmp___0 ;
  u32 *tmp___1 ;
  int tmp___2 ;
  struct lock_class_key __key ;
  struct lock_class_key __key___0 ;
  enum bfa_status tmp___3 ;

  {
  error = -19;
  if ((unsigned int )pdev->device == 23U && (pdev->devfn & 7U) != 0U) {
    return (-19);
  } else {

  }
  tmp = kzalloc(73856UL, 208U);
  bfad = (struct bfad_s *)tmp;
  if ((unsigned long )bfad == (unsigned long )((struct bfad_s *)0)) {
    error = -12;
    goto out;
  } else {

  }
  tmp___0 = kzalloc(65568UL, 208U);
  bfad->trcmod = (struct bfa_trc_mod_s *)tmp___0;
  if ((unsigned long )bfad->trcmod == (unsigned long )((struct bfa_trc_mod_s *)0)) {
    printk("\fError alloc trace buffer!\n");
    error = -12;
    goto out_alloc_trace_failure;
  } else {

  }
  bfa_trc_init(bfad->trcmod);
  __bfa_trc(bfad->trcmod, __trc_fileno, 1330, (unsigned long long )bfad_inst);
  INIT_LIST_HEAD(& bfad->free_aen_q);
  INIT_LIST_HEAD(& bfad->active_aen_q);
  i = 0;
  goto ldv_50281;
  ldv_50280: 
  list_add_tail(& bfad->aen_list[i].qe, & bfad->free_aen_q);
  i = i + 1;
  ldv_50281: ;
  if (i <= 511) {
    goto ldv_50280;
  } else {

  }
  tmp___1 = bfad_load_fwimg(pdev);
  if ((unsigned long )tmp___1 == (unsigned long )((u32 *)0U)) {
    kfree((void const   *)bfad->trcmod);
    goto out_alloc_trace_failure;
  } else {

  }
  retval = bfad_pci_init(pdev, bfad);
  if (retval != 0) {
    printk("\fbfad_pci_init failure!\n");
    error = retval;
    goto out_pci_init_failure;
  } else {

  }
  ldv_mutex_lock_29(& bfad_mutex);
  tmp___2 = bfad_inst;
  bfad_inst = bfad_inst + 1;
  bfad->inst_no = (u32 )tmp___2;
  list_add_tail(& bfad->list_entry, & bfad_list);
  ldv_mutex_unlock_30(& bfad_mutex);
  bfad->sm = (void (*)(void * , int  ))(& bfad_sm_uninit);
  spinlock_check(& bfad->bfad_lock);
  __raw_spin_lock_init(& bfad->bfad_lock.__annonCompField17.rlock, "&(&bfad->bfad_lock)->rlock",
                       & __key);
  spinlock_check(& bfad->bfad_aen_spinlock);
  __raw_spin_lock_init(& bfad->bfad_aen_spinlock.__annonCompField17.rlock, "&(&bfad->bfad_aen_spinlock)->rlock",
                       & __key___0);
  pci_set_drvdata(pdev, (void *)bfad);
  bfad->ref_count = 0;
  bfad->pport.bfad = bfad;
  INIT_LIST_HEAD(& bfad->pbc_vport_list);
  INIT_LIST_HEAD(& bfad->vport_list);
  if (bfa_debugfs_enable != 0) {
    bfad_debugfs_init(& bfad->pport);
  } else {

  }
  tmp___3 = bfad_drv_init(bfad);
  retval = (int )tmp___3;
  if (retval != 0) {
    goto out_drv_init_failure;
  } else {

  }
  (*(bfad->sm))((void *)bfad, 1);
  if ((unsigned long )bfad->sm == (unsigned long )((void (*)(void * , int  ))(& bfad_sm_uninit))) {
    goto out_bfad_sm_failure;
  } else {

  }
  return (0);
  out_bfad_sm_failure: 
  bfad_hal_mem_release(bfad);
  out_drv_init_failure: 
  kfree((void const   *)bfad->regdata);
  bfad_debugfs_exit(& bfad->pport);
  ldv_mutex_lock_31(& bfad_mutex);
  bfad_inst = bfad_inst - 1;
  list_del(& bfad->list_entry);
  ldv_mutex_unlock_32(& bfad_mutex);
  bfad_pci_uninit(pdev, bfad);
  out_pci_init_failure: 
  kfree((void const   *)bfad->trcmod);
  out_alloc_trace_failure: 
  kfree((void const   *)bfad);
  out: ;
  return (error);
}
}
void bfad_pci_remove(struct pci_dev *pdev ) 
{ 
  struct bfad_s *bfad ;
  void *tmp ;
  unsigned long flags ;
  raw_spinlock_t *tmp___0 ;
  raw_spinlock_t *tmp___1 ;

  {
  tmp = pci_get_drvdata(pdev);
  bfad = (struct bfad_s *)tmp;
  __bfa_trc(bfad->trcmod, __trc_fileno, 1411, (unsigned long long )bfad->inst_no);
  tmp___0 = spinlock_check(& bfad->bfad_lock);
  flags = _raw_spin_lock_irqsave(tmp___0);
  if ((unsigned long )bfad->bfad_tsk != (unsigned long )((struct task_struct *)0)) {
    spin_unlock_irqrestore(& bfad->bfad_lock, flags);
    kthread_stop(bfad->bfad_tsk);
  } else {
    spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  }
  (*(bfad->sm))((void *)bfad, 9);
  tmp___1 = spinlock_check(& bfad->bfad_lock);
  flags = _raw_spin_lock_irqsave(tmp___1);
  bfa_detach(& bfad->bfa);
  spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  bfad_hal_mem_release(bfad);
  kfree((void const   *)bfad->regdata);
  bfad_debugfs_exit(& bfad->pport);
  ldv_mutex_lock_33(& bfad_mutex);
  bfad_inst = bfad_inst - 1;
  list_del(& bfad->list_entry);
  ldv_mutex_unlock_34(& bfad_mutex);
  bfad_pci_uninit(pdev, bfad);
  kfree((void const   *)bfad->trcmod);
  kfree((void const   *)bfad);
  return;
}
}
static pci_ers_result_t bfad_pci_error_detected(struct pci_dev *pdev , pci_channel_state_t state ) 
{ 
  struct bfad_s *bfad ;
  void *tmp ;
  unsigned long flags ;
  pci_ers_result_t ret ;
  raw_spinlock_t *tmp___0 ;
  raw_spinlock_t *tmp___1 ;
  raw_spinlock_t *tmp___2 ;
  int __ret_warn_on ;
    klee_make_symbolic(&__ret_warn_on, sizeof(int), "__ret_warn_on");
  long tmp___3 ;
    klee_make_symbolic(&tmp___3, sizeof(long), "tmp___3");

  {
  tmp = pci_get_drvdata(pdev);
  bfad = (struct bfad_s *)tmp;
  ret = 1U;
  dev_printk("\v", (struct device  const  *)(& pdev->dev), "error detected state: %d - flags: 0x%x\n",
             state, bfad->bfad_flags);
  switch (state) {
  case 1U: 
  tmp___0 = spinlock_check(& bfad->bfad_lock);
  flags = _raw_spin_lock_irqsave(tmp___0);
  bfad->bfad_flags = bfad->bfad_flags & 4294965247U;
  bfa_ioc_suspend(& bfad->bfa.ioc);
  spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  ldv_del_timer_sync_35(& bfad->hal_tmo);
  ret = 2U;
  goto ldv_50310;
  case 2U: 
  init_completion(& bfad->comp);
  tmp___1 = spinlock_check(& bfad->bfad_lock);
  flags = _raw_spin_lock_irqsave(tmp___1);
  bfad->bfad_flags = bfad->bfad_flags | 2048U;
  bfa_ioc_suspend(& bfad->bfa.ioc);
  bfa_fcs_stop(& bfad->bfa_fcs);
  spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  wait_for_completion(& bfad->comp);
  bfad_remove_intr(bfad);
  ldv_del_timer_sync_36(& bfad->hal_tmo);
  pci_disable_device(pdev);
  ret = 3U;
  goto ldv_50310;
  case 3U: 
  tmp___2 = spinlock_check(& bfad->bfad_lock);
  flags = _raw_spin_lock_irqsave(tmp___2);
  bfad->bfad_flags = bfad->bfad_flags | 6144U;
  spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  ret = 4U;
  goto ldv_50310;
  default: 
  __ret_warn_on = 1;
  tmp___3 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp___3 != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfad.c",
                       1499);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  }
  ldv_50310: ;
  return (ret);
}
}
int restart_bfa(struct bfad_s *bfad ) 
{ 
  unsigned long flags ;
  struct pci_dev *pdev ;
  int tmp ;
  raw_spinlock_t *tmp___0 ;
  int tmp___1 ;

  {
  pdev = bfad->pcidev;
  bfa_attach(& bfad->bfa, (void *)bfad, & bfad->ioc_cfg, & bfad->meminfo, & bfad->hal_pcidev);
  tmp = bfad_setup_intr(bfad);
  if (tmp != 0) {
    dev_printk("\f", (struct device  const  *)(& pdev->dev), "%s: bfad_setup_intr failed\n",
               bfad->pci_name);
    (*(bfad->sm))((void *)bfad, 6);
    return (-1);
  } else {

  }
  init_completion(& bfad->comp);
  tmp___0 = spinlock_check(& bfad->bfad_lock);
  flags = _raw_spin_lock_irqsave(tmp___0);
  bfa_iocfc_init(& bfad->bfa);
  spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  if ((int )bfad->bfad_flags & 1) {
    tmp___1 = bfad_install_msix_handler(bfad);
    if (tmp___1 != 0) {
      dev_printk("\f", (struct device  const  *)(& pdev->dev), "%s: install_msix failed.\n",
                 bfad->pci_name);
    } else {

    }
  } else {

  }
  bfad_init_timer(bfad);
  wait_for_completion(& bfad->comp);
  bfad_drv_start(bfad);
  return (0);
}
}
static pci_ers_result_t bfad_pci_slot_reset(struct pci_dev *pdev ) 
{ 
  struct bfad_s *bfad ;
  void *tmp ;
  u8 byte ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  tmp = pci_get_drvdata(pdev);
  bfad = (struct bfad_s *)tmp;
  dev_printk("\v", (struct device  const  *)(& pdev->dev), "bfad_pci_slot_reset flags: 0x%x\n",
             bfad->bfad_flags);
  tmp___0 = pci_enable_device(pdev);
  if (tmp___0 != 0) {
    dev_printk("\v", (struct device  const  *)(& pdev->dev), "Cannot re-enable PCI device after reset.\n");
    return (4U);
  } else {

  }
  pci_restore_state(pdev);
  pci_read_config_byte((struct pci_dev  const  *)pdev, 104, & byte);
  if ((unsigned int )byte == 255U) {
    dev_printk("\v", (struct device  const  *)(& pdev->dev), "slot_reset failed ... got another PCI error !\n");
    goto out_disable_device;
  } else {

  }
  pci_save_state(pdev);
  pci_set_master(pdev);
  tmp___2 = pci_set_dma_mask(bfad->pcidev, 0xffffffffffffffffULL);
  if (tmp___2 != 0) {
    tmp___1 = pci_set_dma_mask(bfad->pcidev, 4294967295ULL);
    if (tmp___1 != 0) {
      goto out_disable_device;
    } else {

    }
  } else {

  }
  pci_cleanup_aer_uncorrect_error_status(pdev);
  tmp___3 = restart_bfa(bfad);
  if (tmp___3 == -1) {
    goto out_disable_device;
  } else {

  }
  pci_enable_pcie_error_reporting(pdev);
  dev_printk("\f", (struct device  const  *)(& pdev->dev), "slot_reset completed  flags: 0x%x!\n",
             bfad->bfad_flags);
  return (5U);
  out_disable_device: 
  pci_disable_device(pdev);
  return (4U);
}
}
static pci_ers_result_t bfad_pci_mmio_enabled(struct pci_dev *pdev ) 
{ 
  unsigned long flags ;
  struct bfad_s *bfad ;
  void *tmp ;
  raw_spinlock_t *tmp___0 ;

  {
  tmp = pci_get_drvdata(pdev);
  bfad = (struct bfad_s *)tmp;
  dev_printk("\016", (struct device  const  *)(& pdev->dev), "mmio_enabled\n");
  bfa_ioc_debug_save_ftrc(& bfad->bfa.ioc);
  tmp___0 = spinlock_check(& bfad->bfad_lock);
  flags = _raw_spin_lock_irqsave(tmp___0);
  init_completion(& bfad->comp);
  bfa_fcs_stop(& bfad->bfa_fcs);
  spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  wait_for_completion(& bfad->comp);
  bfad_remove_intr(bfad);
  ldv_del_timer_sync_37(& bfad->hal_tmo);
  pci_disable_device(pdev);
  return (3U);
}
}
static void bfad_pci_resume(struct pci_dev *pdev ) 
{ 
  unsigned long flags ;
  struct bfad_s *bfad ;
  void *tmp ;
  raw_spinlock_t *tmp___0 ;

  {
  tmp = pci_get_drvdata(pdev);
  bfad = (struct bfad_s *)tmp;
  dev_printk("\f", (struct device  const  *)(& pdev->dev), "resume\n");
  bfad_rport_online_wait(bfad);
  tmp___0 = spinlock_check(& bfad->bfad_lock);
  flags = _raw_spin_lock_irqsave(tmp___0);
  bfad->bfad_flags = bfad->bfad_flags & 4294965247U;
  spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  return;
}
}
struct pci_device_id bfad_id_table[7U]  = {      {5719U, 19U, 4294967295U, 4294967295U, 0U, 0U, 0UL}, 
        {5719U, 23U, 4294967295U, 4294967295U, 0U, 0U, 0UL}, 
        {5719U, 20U, 4294967295U, 4294967295U, 787456U, 4294967295U, 0UL}, 
        {5719U, 33U, 4294967295U, 4294967295U, 787456U, 4294967295U, 0UL}, 
        {5719U, 34U, 4294967295U, 4294967295U, 787456U, 4294967295U, 0UL}, 
        {5719U, 35U, 4294967295U, 4294967295U, 787456U, 4294967295U, 0UL}, 
        {0U, 0U, 0U, 0U, 0U, 0U, 0UL}};
struct pci_device_id  const  __mod_pci__bfad_id_table_device_table[7U]  ;
static struct pci_error_handlers bfad_err_handler  =    {(pci_ers_result_t (*)(struct pci_dev * , enum pci_channel_state  ))(& bfad_pci_error_detected),
    & bfad_pci_mmio_enabled, 0, & bfad_pci_slot_reset, 0, & bfad_pci_resume};
static struct pci_driver bfad_pci_driver  = 
     {{0, 0}, "bfa", (struct pci_device_id  const  *)(& bfad_id_table), & bfad_pci_probe,
    & bfad_pci_remove, 0, 0, 0, 0, 0, 0, (struct pci_error_handlers  const  *)(& bfad_err_handler),
    {0, 0, 0, 0, (_Bool)0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {{{{{{0}}, 0U, 0U, 0,
                                                                 {0, {0, 0}, 0, 0,
                                                                  0UL}}}}, {0, 0}}};
static int bfad_init(void) 
{ 
  int error ;
  enum bfa_status tmp ;
  int tmp___0 ;

  {
  error = 0;
  printk("\016Brocade BFA FC/FCOE SCSI driver - version: %s\n", (char *)"3.2.23.0");
  if (num_sgpgs > 0) {
    num_sgpgs_parm = num_sgpgs;
  } else {

  }
  tmp = bfad_im_module_init();
  error = (int )tmp;
  if (error != 0) {
    error = -12;
    printk("\fbfad_im_module_init failure\n");
    goto ext;
  } else {

  }
  tmp___0 = strcmp(" fcpim", " fcpim");
  if (tmp___0 == 0) {
    supported_fc4s = supported_fc4s | 1;
  } else {

  }
  bfa_auto_recover = (enum bfa_boolean )ioc_auto_recover;
  bfa_fcs_rport_set_del_timeout((int )((u8 )rport_del_timeout));
  bfa_fcs_rport_set_max_logins((u32 )max_rport_logins);
  error = ldv___pci_register_driver_38(& bfad_pci_driver, & __this_module, "bfa");
  if (error != 0) {
    printk("\fpci_register_driver failure\n");
    goto ext;
  } else {

  }
  return (0);
  ext: 
  bfad_im_module_exit();
  return (error);
}
}
static void bfad_exit(void) 
{ 


  {
  ldv_pci_unregister_driver_39(& bfad_pci_driver);
  bfad_im_module_exit();
  bfad_free_fwimg();
  return;
}
}
static void bfad_read_firmware(struct pci_dev *pdev , u32 **bfi_image , u32 *bfi_image_size ,
                               char *fw_name ) 
{ 
  struct firmware  const  *fw ;
  int tmp ;
  void *tmp___0 ;

  {
  tmp = request_firmware(& fw, (char const   *)fw_name, & pdev->dev);
  if (tmp != 0) {
    printk("\tCan\'t locate firmware %s\n", fw_name);
    *bfi_image = (u32 *)0U;
    goto out;
  } else {

  }
  tmp___0 = vmalloc(fw->size);
  *bfi_image = (u32 *)tmp___0;
  if ((unsigned long )*bfi_image == (unsigned long )((u32 *)0U)) {
    printk("\tFail to allocate buffer for fw image size=%x!\n", (unsigned int )fw->size);
    goto out;
  } else {

  }
  memcpy((void *)*bfi_image, (void const   *)fw->data, fw->size);
  *bfi_image_size = (u32 )((unsigned long )fw->size / 4UL);
  out: 
  release_firmware(fw);
  return;
}
}
static u32 *bfad_load_fwimg(struct pci_dev *pdev ) 
{ 


  {
  if ((unsigned int )pdev->device == 34U || (unsigned int )pdev->device == 35U) {
    if (bfi_image_ct2_size == 0U) {
      bfad_read_firmware(pdev, & bfi_image_ct2, & bfi_image_ct2_size, (char *)"ct2fw-3.2.3.0.bin");
    } else {

    }
    return (bfi_image_ct2);
  } else
  if ((unsigned int )pdev->device == 20U || (unsigned int )pdev->device == 33U) {
    if (bfi_image_ct_size == 0U) {
      bfad_read_firmware(pdev, & bfi_image_ct, & bfi_image_ct_size, (char *)"ctfw-3.2.3.0.bin");
    } else {

    }
    return (bfi_image_ct);
  } else
  if ((unsigned int )pdev->device == 19U || (unsigned int )pdev->device == 23U) {
    if (bfi_image_cb_size == 0U) {
      bfad_read_firmware(pdev, & bfi_image_cb, & bfi_image_cb_size, (char *)"cbfw-3.2.3.0.bin");
    } else {

    }
    return (bfi_image_cb);
  } else {

  }
  return ((u32 *)0U);
}
}
static void bfad_free_fwimg(void) 
{ 


  {
  if (bfi_image_ct2_size != 0U && (unsigned long )bfi_image_ct2 != (unsigned long )((u32 *)0U)) {
    vfree((void const   *)bfi_image_ct2);
  } else {

  }
  if (bfi_image_ct_size != 0U && (unsigned long )bfi_image_ct != (unsigned long )((u32 *)0U)) {
    vfree((void const   *)bfi_image_ct);
  } else {

  }
  if (bfi_image_cb_size != 0U && (unsigned long )bfi_image_cb != (unsigned long )((u32 *)0U)) {
    vfree((void const   *)bfi_image_cb);
  } else {

  }
  return;
}
}
extern int ldv_shutdown_37(void) ;
int ldv_retval_5  ;
    klee_make_symbolic(&ldv_retval_5, sizeof(int), "ldv_retval_5");
int ldv_retval_4  ;
    klee_make_symbolic(&ldv_retval_4, sizeof(int), "ldv_retval_4");
extern void ldv_initialize(void) ;
extern int ldv_probe_38(void) ;
void ldv_check_final_state(void) ;
extern int ldv_suspend_38(void) ;
extern int ldv_release_38(void) ;
void disable_suitable_irq_2(int line , void *data ) 
{ 


  {
  if (ldv_irq_2_0 != 0 && line == ldv_irq_line_2_0) {
    ldv_irq_2_0 = 0;
    return;
  } else {

  }
  if (ldv_irq_2_1 != 0 && line == ldv_irq_line_2_1) {
    ldv_irq_2_1 = 0;
    return;
  } else {

  }
  if (ldv_irq_2_2 != 0 && line == ldv_irq_line_2_2) {
    ldv_irq_2_2 = 0;
    return;
  } else {

  }
  if (ldv_irq_2_3 != 0 && line == ldv_irq_line_2_3) {
    ldv_irq_2_3 = 0;
    return;
  } else {

  }
  return;
}
}
int reg_check_1(irqreturn_t (*handler)(int  , void * ) ) 
{ 


  {
  if ((unsigned long )handler == (unsigned long )(& bfad_msix)) {
    return (1);
  } else {

  }
  return (0);
}
}
void ldv_pci_driver_37(void) 
{ 
  void *tmp ;

  {
  tmp = ldv_init_zalloc(2976UL);
  bfad_pci_driver_group1 = (struct pci_dev *)tmp;
  return;
}
}
void disable_suitable_irq_1(int line , void *data ) 
{ 


  {
  if (ldv_irq_1_0 != 0 && line == ldv_irq_line_1_0) {
    ldv_irq_1_0 = 0;
    return;
  } else {

  }
  if (ldv_irq_1_1 != 0 && line == ldv_irq_line_1_1) {
    ldv_irq_1_1 = 0;
    return;
  } else {

  }
  if (ldv_irq_1_2 != 0 && line == ldv_irq_line_1_2) {
    ldv_irq_1_2 = 0;
    return;
  } else {

  }
  if (ldv_irq_1_3 != 0 && line == ldv_irq_line_1_3) {
    ldv_irq_1_3 = 0;
    return;
  } else {

  }
  return;
}
}
void activate_suitable_irq_1(int line , void *data ) 
{ 


  {
  if (ldv_irq_1_0 == 0) {
    ldv_irq_line_1_0 = line;
    ldv_irq_data_1_0 = data;
    ldv_irq_1_0 = 1;
    return;
  } else {

  }
  if (ldv_irq_1_1 == 0) {
    ldv_irq_line_1_1 = line;
    ldv_irq_data_1_1 = data;
    ldv_irq_1_1 = 1;
    return;
  } else {

  }
  if (ldv_irq_1_2 == 0) {
    ldv_irq_line_1_2 = line;
    ldv_irq_data_1_2 = data;
    ldv_irq_1_2 = 1;
    return;
  } else {

  }
  if (ldv_irq_1_3 == 0) {
    ldv_irq_line_1_3 = line;
    ldv_irq_data_1_3 = data;
    ldv_irq_1_3 = 1;
    return;
  } else {

  }
  return;
}
}
void ldv_initialize_pci_error_handlers_38(void) 
{ 

  {
  bfad_err_handler_group0 = ldv_malloc(sizeof(struct pci_dev));
  return;
}
}
void disable_suitable_timer_6(struct timer_list *timer ) 
{ 


  {
  if ((unsigned long )timer == (unsigned long )ldv_timer_list_6) {
    ldv_timer_state_6 = 0;
    return;
  } else {

  }
  return;
}
}
int ldv_irq_2(int state , int line , void *data ) 
{ 
  irqreturn_t irq_retval ;
  int tmp ;
  int tmp___0 ;

  {
  tmp = __VERIFIER_nondet_int();
  irq_retval = (irqreturn_t )tmp;
  if (state != 0) {
    tmp___0 = __VERIFIER_nondet_int();
    switch (tmp___0) {
    case 0: ;
    if (state == 1) {
      LDV_IN_INTERRUPT = 2;
      irq_retval = bfad_intx(line, data);
      LDV_IN_INTERRUPT = 1;
      return (state);
    } else {

    }
    goto ldv_50439;
    default: 
    ldv_stop();
    }
    ldv_50439: ;
  } else {

  }
  return (state);
}
}
void activate_pending_timer_6(struct timer_list *timer , unsigned long data , int pending_flag ) 
{ 


  {
  if ((unsigned long )ldv_timer_list_6 == (unsigned long )timer) {
    if (ldv_timer_state_6 == 2 || pending_flag != 0) {
      ldv_timer_list_6 = timer;
      ldv_timer_list_6->data = data;
      ldv_timer_state_6 = 1;
    } else {

    }
    return;
  } else {

  }
  reg_timer_6(timer);
  ldv_timer_list_6->data = data;
  return;
}
}
void choose_interrupt_2(void) 
{ 
  int tmp ;

  {
  tmp = __VERIFIER_nondet_int();
  switch (tmp) {
  case 0: 
  ldv_irq_2_0 = ldv_irq_2(ldv_irq_2_0, ldv_irq_line_2_0, ldv_irq_data_2_0);
  goto ldv_50450;
  case 1: 
  ldv_irq_2_0 = ldv_irq_2(ldv_irq_2_1, ldv_irq_line_2_1, ldv_irq_data_2_1);
  goto ldv_50450;
  case 2: 
  ldv_irq_2_0 = ldv_irq_2(ldv_irq_2_2, ldv_irq_line_2_2, ldv_irq_data_2_2);
  goto ldv_50450;
  case 3: 
  ldv_irq_2_0 = ldv_irq_2(ldv_irq_2_3, ldv_irq_line_2_3, ldv_irq_data_2_3);
  goto ldv_50450;
  default: 
  ldv_stop();
  }
  ldv_50450: ;
  return;
}
}
void activate_suitable_irq_2(int line , void *data ) 
{ 


  {
  if (ldv_irq_2_0 == 0) {
    ldv_irq_line_2_0 = line;
    ldv_irq_data_2_0 = data;
    ldv_irq_2_0 = 1;
    return;
  } else {

  }
  if (ldv_irq_2_1 == 0) {
    ldv_irq_line_2_1 = line;
    ldv_irq_data_2_1 = data;
    ldv_irq_2_1 = 1;
    return;
  } else {

  }
  if (ldv_irq_2_2 == 0) {
    ldv_irq_line_2_2 = line;
    ldv_irq_data_2_2 = data;
    ldv_irq_2_2 = 1;
    return;
  } else {

  }
  if (ldv_irq_2_3 == 0) {
    ldv_irq_line_2_3 = line;
    ldv_irq_data_2_3 = data;
    ldv_irq_2_3 = 1;
    return;
  } else {

  }
  return;
}
}
void choose_timer_6(struct timer_list *timer ) 
{ 


  {
  LDV_IN_INTERRUPT = 2;
  (*(timer->function))(timer->data);
  LDV_IN_INTERRUPT = 1;
  ldv_timer_state_6 = 2;
  return;
}
}
int reg_timer_6(struct timer_list *timer ) 
{ 


  {
  ldv_timer_list_6 = timer;
  ldv_timer_state_6 = 1;
  return (0);
}
}
void choose_interrupt_1(void) 
{ 
  int tmp ;

  {
  tmp = __VERIFIER_nondet_int();
  switch (tmp) {
  case 0: 
  ldv_irq_1_0 = ldv_irq_1(ldv_irq_1_0, ldv_irq_line_1_0, ldv_irq_data_1_0);
  goto ldv_50469;
  case 1: 
  ldv_irq_1_0 = ldv_irq_1(ldv_irq_1_1, ldv_irq_line_1_1, ldv_irq_data_1_1);
  goto ldv_50469;
  case 2: 
  ldv_irq_1_0 = ldv_irq_1(ldv_irq_1_2, ldv_irq_line_1_2, ldv_irq_data_1_2);
  goto ldv_50469;
  case 3: 
  ldv_irq_1_0 = ldv_irq_1(ldv_irq_1_3, ldv_irq_line_1_3, ldv_irq_data_1_3);
  goto ldv_50469;
  default: 
  ldv_stop();
  }
  ldv_50469: ;
  return;
}
}
int reg_check_2(irqreturn_t (*handler)(int  , void * ) ) 
{ 


  {
  if ((unsigned long )handler == (unsigned long )(& bfad_intx)) {
    return (1);
  } else {

  }
  return (0);
}
}
int ldv_irq_1(int state , int line , void *data ) 
{ 
  irqreturn_t irq_retval ;
  int tmp ;
  int tmp___0 ;

  {
  tmp = __VERIFIER_nondet_int();
  irq_retval = (irqreturn_t )tmp;
  if (state != 0) {
    tmp___0 = __VERIFIER_nondet_int();
    switch (tmp___0) {
    case 0: ;
    if (state == 1) {
      LDV_IN_INTERRUPT = 2;
      irq_retval = bfad_msix(line, data);
      LDV_IN_INTERRUPT = 1;
      return (state);
    } else {

    }
    goto ldv_50486;
    default: 
    ldv_stop();
    }
    ldv_50486: ;
  } else {

  }
  return (state);
}
}
void ldv_main_exported_35(void) ;
void ldv_main_exported_36(void) ;
void ldv_main_exported_27(void) ;
void ldv_main_exported_25(void) ;
void ldv_main_exported_33(void) ;
void ldv_main_exported_32(void) ;
void ldv_main_exported_28(void) ;
void ldv_main_exported_21(void) ;
void ldv_main_exported_26(void) ;
void ldv_main_exported_22(void) ;
void ldv_main_exported_34(void) ;
void ldv_main_exported_30(void) ;
void ldv_main_exported_24(void) ;
void ldv_main_exported_23(void) ;
void ldv_main_exported_31(void) ;
void ldv_main_exported_29(void) ;
void ldv_main_exported_8(void) ;
void ldv_main_exported_11(void) ;
void ldv_main_exported_7(void) ;
void ldv_main_exported_13(void) ;
void ldv_main_exported_10(void) ;
void ldv_main_exported_9(void) ;
void ldv_main_exported_12(void) ;
void ldv_main_exported_18(void) ;
void ldv_main_exported_19(void) ;
void ldv_main_exported_16(void) ;
void ldv_main_exported_17(void) ;
void ldv_main_exported_20(void) ;
void ldv_main_exported_15(void) ;
void ldv_main_exported_14(void) ;
int main(void) 
{ 
  enum pci_channel_state ldvarg85 ;
  struct pci_device_id *ldvarg93 ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  tmp = ldv_init_zalloc(32UL);
  ldvarg93 = (struct pci_device_id *)tmp;
  ldv_initialize();
  ldv_memset((void *)(& ldvarg85), 0, 4UL);
  ldv_state_variable_33 = 0;
  ldv_state_variable_32 = 0;
  ldv_state_variable_21 = 0;
  ldv_state_variable_7 = 0;
  ldv_state_variable_26 = 0;
  ldv_state_variable_17 = 0;
  ldv_state_variable_2 = 1;
  ldv_state_variable_1 = 1;
  ldv_state_variable_18 = 0;
  ldv_state_variable_30 = 0;
  ldv_state_variable_16 = 0;
  ldv_state_variable_27 = 0;
  ldv_state_variable_25 = 0;
  ldv_state_variable_28 = 0;
  ldv_state_variable_20 = 0;
  ldv_state_variable_14 = 0;
  ldv_state_variable_24 = 0;
  ldv_state_variable_10 = 0;
  ldv_state_variable_31 = 0;
  ldv_state_variable_35 = 0;
  ldv_state_variable_11 = 0;
  ldv_state_variable_22 = 0;
  ref_cnt = 0;
  ldv_state_variable_0 = 1;
  ldv_state_variable_13 = 0;
  ldv_state_variable_23 = 0;
  ldv_state_variable_29 = 0;
  ldv_state_variable_6 = 1;
  ldv_state_variable_36 = 0;
  work_init_3();
  ldv_state_variable_3 = 1;
  ldv_state_variable_9 = 0;
  ldv_state_variable_12 = 0;
  ldv_state_variable_15 = 0;
  ldv_state_variable_38 = 0;
  ldv_state_variable_8 = 0;
  work_init_4();
  ldv_state_variable_4 = 1;
  ldv_state_variable_34 = 0;
  ldv_state_variable_37 = 0;
  ldv_state_variable_19 = 0;
  work_init_5();
  ldv_state_variable_5 = 1;
  ldv_50621: 
  tmp___0 = __VERIFIER_nondet_int();
  switch (tmp___0) {
  case 0: ;
  if (ldv_state_variable_33 != 0) {
    ldv_main_exported_33();
  } else {

  }
  goto ldv_50562;
  case 1: ;
  if (ldv_state_variable_32 != 0) {
    ldv_main_exported_32();
  } else {

  }
  goto ldv_50562;
  case 2: ;
  if (ldv_state_variable_21 != 0) {
    ldv_main_exported_21();
  } else {

  }
  goto ldv_50562;
  case 3: ;
  if (ldv_state_variable_7 != 0) {
    ldv_main_exported_7();
  } else {

  }
  goto ldv_50562;
  case 4: ;
  if (ldv_state_variable_26 != 0) {
    ldv_main_exported_26();
  } else {

  }
  goto ldv_50562;
  case 5: ;
  if (ldv_state_variable_17 != 0) {
    ldv_main_exported_17();
  } else {

  }
  goto ldv_50562;
  case 6: ;
  if (ldv_state_variable_2 != 0) {
    choose_interrupt_2();
  } else {

  }
  goto ldv_50562;
  case 7: ;
  if (ldv_state_variable_1 != 0) {
    choose_interrupt_1();
  } else {

  }
  goto ldv_50562;
  case 8: ;
  if (ldv_state_variable_18 != 0) {
    ldv_main_exported_18();
  } else {

  }
  goto ldv_50562;
  case 9: ;
  if (ldv_state_variable_30 != 0) {
    ldv_main_exported_30();
  } else {

  }
  goto ldv_50562;
  case 10: ;
  if (ldv_state_variable_16 != 0) {
    ldv_main_exported_16();
  } else {

  }
  goto ldv_50562;
  case 11: ;
  if (ldv_state_variable_27 != 0) {
    ldv_main_exported_27();
  } else {

  }
  goto ldv_50562;
  case 12: ;
  if (ldv_state_variable_25 != 0) {
    ldv_main_exported_25();
  } else {

  }
  goto ldv_50562;
  case 13: ;
  if (ldv_state_variable_28 != 0) {
    ldv_main_exported_28();
  } else {

  }
  goto ldv_50562;
  case 14: ;
  if (ldv_state_variable_20 != 0) {
    ldv_main_exported_20();
  } else {

  }
  goto ldv_50562;
  case 15: ;
  if (ldv_state_variable_14 != 0) {
    ldv_main_exported_14();
  } else {

  }
  goto ldv_50562;
  case 16: ;
  if (ldv_state_variable_24 != 0) {
    ldv_main_exported_24();
  } else {

  }
  goto ldv_50562;
  case 17: ;
  if (ldv_state_variable_10 != 0) {
    ldv_main_exported_10();
  } else {

  }
  goto ldv_50562;
  case 18: ;
  if (ldv_state_variable_31 != 0) {
    ldv_main_exported_31();
  } else {

  }
  goto ldv_50562;
  case 19: ;
  if (ldv_state_variable_35 != 0) {
    ldv_main_exported_35();
  } else {

  }
  goto ldv_50562;
  case 20: ;
  if (ldv_state_variable_11 != 0) {
    ldv_main_exported_11();
  } else {

  }
  goto ldv_50562;
  case 21: ;
  if (ldv_state_variable_22 != 0) {
    ldv_main_exported_22();
  } else {

  }
  goto ldv_50562;
  case 22: ;
  if (ldv_state_variable_0 != 0) {
    tmp___1 = __VERIFIER_nondet_int();
    switch (tmp___1) {
    case 0: ;
    if (ldv_state_variable_0 == 3 && ref_cnt == 0) {
      bfad_exit();
      ldv_state_variable_0 = 2;
      goto ldv_final;
    } else {

    }
    goto ldv_50587;
    case 1: ;
    if (ldv_state_variable_0 == 1) {
      ldv_retval_4 = bfad_init();
      if (ldv_retval_4 == 0) {
        ldv_state_variable_0 = 3;
        ldv_state_variable_31 = 1;
        ldv_state_variable_19 = 1;
        ldv_file_operations_19();
        ldv_state_variable_10 = 1;
        ldv_initialize_bfa_module_s_10();
        ldv_state_variable_24 = 1;
        ldv_state_variable_34 = 1;
        ldv_initialize_fc_function_template_34();
        ldv_state_variable_8 = 1;
        ldv_initialize_bfa_module_s_8();
        ldv_state_variable_38 = 1;
        ldv_initialize_pci_error_handlers_38();
        ldv_state_variable_20 = 1;
        ldv_file_operations_20();
        ldv_state_variable_15 = 1;
        ldv_initialize_bfa_module_s_15();
        ldv_state_variable_14 = 1;
        ldv_initialize_bfa_module_s_14();
        ldv_state_variable_12 = 1;
        ldv_initialize_bfa_module_s_12();
        ldv_state_variable_9 = 1;
        ldv_initialize_bfa_module_s_9();
        ldv_state_variable_28 = 1;
        ldv_state_variable_25 = 1;
        ldv_state_variable_27 = 1;
        ldv_state_variable_29 = 1;
        ldv_state_variable_13 = 1;
        ldv_initialize_bfa_module_s_13();
        ldv_state_variable_16 = 1;
        ldv_file_operations_16();
        ldv_state_variable_23 = 1;
        ldv_state_variable_30 = 1;
        ldv_state_variable_18 = 1;
        ldv_file_operations_18();
        ldv_state_variable_22 = 1;
        ldv_state_variable_17 = 1;
        ldv_file_operations_17();
        ldv_state_variable_26 = 1;
        ldv_state_variable_7 = 1;
        ldv_initialize_bfa_module_s_7();
        ldv_state_variable_21 = 1;
        ldv_state_variable_11 = 1;
        ldv_initialize_bfa_module_s_11();
        ldv_state_variable_32 = 1;
        ldv_state_variable_33 = 1;
        ldv_initialize_fc_function_template_33();
      } else {

      }
      if (ldv_retval_4 != 0) {
        ldv_state_variable_0 = 2;
        goto ldv_final;
      } else {

      }
    } else {

    }
    goto ldv_50587;
    default: 
    ldv_stop();
    }
    ldv_50587: ;
  } else {

  }
  goto ldv_50562;
  case 23: ;
  if (ldv_state_variable_13 != 0) {
    ldv_main_exported_13();
  } else {

  }
  goto ldv_50562;
  case 24: ;
  if (ldv_state_variable_23 != 0) {
    ldv_main_exported_23();
  } else {

  }
  goto ldv_50562;
  case 25: ;
  if (ldv_state_variable_29 != 0) {
    ldv_main_exported_29();
  } else {

  }
  goto ldv_50562;
  case 26: ;
  if (ldv_state_variable_6 != 0) {
    choose_timer_6(ldv_timer_list_6);
  } else {

  }
  goto ldv_50562;
  case 27: ;
  if (ldv_state_variable_36 != 0) {
    ldv_main_exported_36();
  } else {

  }
  goto ldv_50562;
  case 28: ;
  goto ldv_50562;
  case 29: ;
  if (ldv_state_variable_9 != 0) {
    ldv_main_exported_9();
  } else {

  }
  goto ldv_50562;
  case 30: ;
  if (ldv_state_variable_12 != 0) {
    ldv_main_exported_12();
  } else {

  }
  goto ldv_50562;
  case 31: ;
  if (ldv_state_variable_15 != 0) {
    ldv_main_exported_15();
  } else {

  }
  goto ldv_50562;
  case 32: ;
  if (ldv_state_variable_38 != 0) {
    tmp___2 = __VERIFIER_nondet_int();
    switch (tmp___2) {
    case 0: ;
    if (ldv_state_variable_38 == 1) {
      bfad_pci_slot_reset(bfad_err_handler_group0);
      ldv_state_variable_38 = 1;
    } else {

    }
    if (ldv_state_variable_38 == 3) {
      bfad_pci_slot_reset(bfad_err_handler_group0);
      ldv_state_variable_38 = 3;
    } else {

    }
    if (ldv_state_variable_38 == 2) {
      bfad_pci_slot_reset(bfad_err_handler_group0);
      ldv_state_variable_38 = 2;
    } else {

    }
    goto ldv_50601;
    case 1: ;
    if (ldv_state_variable_38 == 1) {
      bfad_pci_error_detected(bfad_err_handler_group0, (pci_channel_state_t )ldvarg85);
      ldv_state_variable_38 = 1;
    } else {

    }
    if (ldv_state_variable_38 == 3) {
      bfad_pci_error_detected(bfad_err_handler_group0, (pci_channel_state_t )ldvarg85);
      ldv_state_variable_38 = 3;
    } else {

    }
    if (ldv_state_variable_38 == 2) {
      bfad_pci_error_detected(bfad_err_handler_group0, (pci_channel_state_t )ldvarg85);
      ldv_state_variable_38 = 2;
    } else {

    }
    goto ldv_50601;
    case 2: ;
    if (ldv_state_variable_38 == 1) {
      bfad_pci_mmio_enabled(bfad_err_handler_group0);
      ldv_state_variable_38 = 1;
    } else {

    }
    if (ldv_state_variable_38 == 3) {
      bfad_pci_mmio_enabled(bfad_err_handler_group0);
      ldv_state_variable_38 = 3;
    } else {

    }
    if (ldv_state_variable_38 == 2) {
      bfad_pci_mmio_enabled(bfad_err_handler_group0);
      ldv_state_variable_38 = 2;
    } else {

    }
    goto ldv_50601;
    case 3: ;
    if (ldv_state_variable_38 == 3) {
      bfad_pci_resume(bfad_err_handler_group0);
      ldv_state_variable_38 = 2;
    } else {

    }
    goto ldv_50601;
    case 4: ;
    if (ldv_state_variable_38 == 2) {
      ldv_suspend_38();
      ldv_state_variable_38 = 3;
    } else {

    }
    goto ldv_50601;
    case 5: ;
    if (ldv_state_variable_38 == 3) {
      ldv_release_38();
      ldv_state_variable_38 = 1;
      ref_cnt = ref_cnt - 1;
    } else {

    }
    if (ldv_state_variable_38 == 2) {
      ldv_release_38();
      ldv_state_variable_38 = 1;
      ref_cnt = ref_cnt - 1;
    } else {

    }
    goto ldv_50601;
    case 6: ;
    if (ldv_state_variable_38 == 1) {
      ldv_probe_38();
      ldv_state_variable_38 = 2;
      ref_cnt = ref_cnt + 1;
    } else {

    }
    goto ldv_50601;
    default: 
    ldv_stop();
    }
    ldv_50601: ;
  } else {

  }
  goto ldv_50562;
  case 33: ;
  if (ldv_state_variable_8 != 0) {
    ldv_main_exported_8();
  } else {

  }
  goto ldv_50562;
  case 34: ;
  goto ldv_50562;
  case 35: ;
  if (ldv_state_variable_34 != 0) {
    ldv_main_exported_34();
  } else {

  }
  goto ldv_50562;
  case 36: ;
  if (ldv_state_variable_37 != 0) {
    tmp___3 = __VERIFIER_nondet_int();
    switch (tmp___3) {
    case 0: ;
    if (ldv_state_variable_37 == 1) {
      ldv_retval_5 = bfad_pci_probe(bfad_pci_driver_group1, (struct pci_device_id  const  *)ldvarg93);
      if (ldv_retval_5 == 0) {
        ldv_state_variable_37 = 2;
        ref_cnt = ref_cnt + 1;
      } else {

      }
    } else {

    }
    goto ldv_50614;
    case 1: ;
    if (ldv_state_variable_37 == 2) {
      bfad_pci_remove(bfad_pci_driver_group1);
      ldv_state_variable_37 = 1;
    } else {

    }
    goto ldv_50614;
    case 2: ;
    if (ldv_state_variable_37 == 2) {
      ldv_shutdown_37();
      ldv_state_variable_37 = 2;
    } else {

    }
    goto ldv_50614;
    default: 
    ldv_stop();
    }
    ldv_50614: ;
  } else {

  }
  goto ldv_50562;
  case 37: ;
  if (ldv_state_variable_19 != 0) {
    ldv_main_exported_19();
  } else {

  }
  goto ldv_50562;
  case 38: ;
  goto ldv_50562;
  default: 
  ldv_stop();
  }
  ldv_50562: ;
  goto ldv_50621;
  ldv_final: 
  ldv_check_final_state();
  return 0;
}
}
__inline static bool IS_ERR(void const   *ptr ) 
{ 
  bool tmp ;

  {
  tmp = ldv_is_err(ptr);
  return (tmp);
}
}
bool ldv_queue_work_on_5(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                         struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_3(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_delayed_work_on_6(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                 struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_3(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_work_on_7(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                         struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_3(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
void ldv_flush_workqueue_8(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
  flush_workqueue(ldv_func_arg1);
  call_and_disable_all_3(2);
  return;
}
}
bool ldv_queue_delayed_work_on_9(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                 struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_3(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
void ldv_mutex_lock_10(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_lock_lock(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_11(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_unlock_lock(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_12(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_unlock_i_mutex_of_inode(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_13(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_lock_i_mutex_of_inode(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_14(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
int ldv_mutex_trylock_15(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
  tmp = mutex_trylock(ldv_func_arg1);
  ldv_func_res = tmp;
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
  return (tmp___0);
  return (ldv_func_res);
}
}
void ldv_mutex_unlock_16(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
int ldv_scsi_add_host_with_dma_17(struct Scsi_Host *shost , struct device *dev , struct device *dma_dev ) 
{ 
  ldv_func_ret_type___4 ldv_func_res ;
  int tmp ;

  {
  tmp = scsi_add_host_with_dma(shost, dev, dma_dev);
  ldv_func_res = tmp;
  if (ldv_func_res == 0) {
    ldv_state_variable_35 = 1;
    ldv_initialize_scsi_host_template_35();
  } else {

  }
  return (ldv_func_res);
}
}
int ldv_del_timer_sync_18(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___5 ldv_func_res ;
  int tmp ;

  {
  tmp = del_timer_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_suitable_timer_6(ldv_func_arg1);
  return (ldv_func_res);
}
}
int ldv_del_timer_sync_19(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___6 ldv_func_res ;
  int tmp ;

  {
  tmp = del_timer_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_suitable_timer_6(ldv_func_arg1);
  return (ldv_func_res);
}
}
int ldv_mod_timer_20(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___7 ldv_func_res ;
  int tmp ;

  {
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
  ldv_func_res = tmp;
  activate_pending_timer_6(ldv_func_arg1, ldv_func_arg2, 1);
  return (ldv_func_res);
}
}
int ldv_mod_timer_21(struct timer_list *ldv_func_arg1 , unsigned long ldv_func_arg2 ) 
{ 
  ldv_func_ret_type___8 ldv_func_res ;
  int tmp ;

  {
  tmp = mod_timer(ldv_func_arg1, ldv_func_arg2);
  ldv_func_res = tmp;
  activate_pending_timer_6(ldv_func_arg1, ldv_func_arg2, 1);
  return (ldv_func_res);
}
}
int ldv_del_timer_sync_22(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___9 ldv_func_res ;
  int tmp ;

  {
  tmp = del_timer_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_suitable_timer_6(ldv_func_arg1);
  return (ldv_func_res);
}
}
void ldv_flush_workqueue_23(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
  flush_workqueue(ldv_func_arg1);
  call_and_disable_all_3(2);
  return;
}
}
__inline static int ldv_request_irq_24(unsigned int irq , irqreturn_t (*handler)(int  ,
                                                                                 void * ) ,
                                       unsigned long flags , char const   *name ,
                                       void *dev ) 
{ 
  ldv_func_ret_type___10 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
  tmp = request_irq(irq, handler, flags, name, dev);
  ldv_func_res = tmp;
  tmp___0 = reg_check_2(handler);
  if (tmp___0 != 0 && ldv_func_res == 0) {
    activate_suitable_irq_2((int )irq, dev);
  } else {

  }
  return (ldv_func_res);
}
}
void ldv_free_irq_25(unsigned int ldv_func_arg1 , void *ldv_func_arg2 ) 
{ 


  {
  free_irq(ldv_func_arg1, ldv_func_arg2);
  disable_suitable_irq_2((int )ldv_func_arg1, ldv_func_arg2);
  return;
}
}
__inline static int ldv_request_irq_26(unsigned int irq , irqreturn_t (*handler)(int  ,
                                                                                 void * ) ,
                                       unsigned long flags , char const   *name ,
                                       void *dev ) 
{ 
  ldv_func_ret_type___11 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
  tmp = request_irq(irq, handler, flags, name, dev);
  ldv_func_res = tmp;
  tmp___0 = reg_check_2(handler);
  if (tmp___0 != 0 && ldv_func_res == 0) {
    activate_suitable_irq_2((int )irq, dev);
  } else {

  }
  return (ldv_func_res);
}
}
void ldv_free_irq_27(unsigned int ldv_func_arg1 , void *ldv_func_arg2 ) 
{ 


  {
  free_irq(ldv_func_arg1, ldv_func_arg2);
  disable_suitable_irq_2((int )ldv_func_arg1, ldv_func_arg2);
  return;
}
}
void ldv_free_irq_28(unsigned int ldv_func_arg1 , void *ldv_func_arg2 ) 
{ 


  {
  free_irq(ldv_func_arg1, ldv_func_arg2);
  disable_suitable_irq_2((int )ldv_func_arg1, ldv_func_arg2);
  return;
}
}
void ldv_mutex_lock_29(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_lock_bfad_mutex(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_30(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_unlock_bfad_mutex(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_31(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_lock_bfad_mutex(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_32(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_unlock_bfad_mutex(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_33(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_lock_bfad_mutex(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_34(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_unlock_bfad_mutex(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
int ldv_del_timer_sync_35(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___12 ldv_func_res ;
  int tmp ;

  {
  tmp = del_timer_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_suitable_timer_6(ldv_func_arg1);
  return (ldv_func_res);
}
}
int ldv_del_timer_sync_36(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___13 ldv_func_res ;
  int tmp ;

  {
  tmp = del_timer_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_suitable_timer_6(ldv_func_arg1);
  return (ldv_func_res);
}
}
int ldv_del_timer_sync_37(struct timer_list *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___14 ldv_func_res ;
  int tmp ;

  {
  tmp = del_timer_sync(ldv_func_arg1);
  ldv_func_res = tmp;
  disable_suitable_timer_6(ldv_func_arg1);
  return (ldv_func_res);
}
}
int ldv___pci_register_driver_38(struct pci_driver *ldv_func_arg1 , struct module *ldv_func_arg2 ,
                                 char const   *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___15 ldv_func_res ;
  int tmp ;

  {
  tmp = __pci_register_driver(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  ldv_state_variable_37 = 1;
  ldv_pci_driver_37();
  return (ldv_func_res);
}
}
void ldv_pci_unregister_driver_39(struct pci_driver *ldv_func_arg1 ) 
{ 


  {
  pci_unregister_driver(ldv_func_arg1);
  ldv_state_variable_37 = 0;
  return;
}
}
__inline static long ldv__builtin_expect(long exp , long c ) ;
__inline static void set_bit(long nr , unsigned long volatile   *addr ) 
{ 


  {
  __asm__  volatile   (".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; bts %1,%0": "+m" (*((long volatile   *)addr)): "Ir" (nr): "memory");
  return;
}
}
__inline static int constant_test_bit(long nr , unsigned long const volatile   *addr ) 
{ 


  {
  return ((int )((unsigned long )*(addr + (unsigned long )(nr >> 6)) >> ((int )nr & 63)) & 1);
}
}
__inline static __u64 __arch_swab64(__u64 val ) 
{ 


  {
  __asm__  ("bswapq %0": "=r" (val): "0" (val));
  return (val);
}
}
__inline static __u64 __fswab64(__u64 val ) 
{ 
  __u64 tmp ;

  {
  tmp = __arch_swab64(val);
  return (tmp);
}
}
extern void __might_sleep(char const   * , int  , int  ) ;
extern int snprintf(char * , size_t  , char const   *  , ...) ;
extern void __bad_percpu_size(void) ;
extern struct task_struct *current_task ;
__inline static struct task_struct *get_current(void) 
{ 
  struct task_struct *pfo_ret__ ;

  {
  switch (8UL) {
  case 1UL: 
  __asm__  ("movb %%gs:%P1,%0": "=q" (pfo_ret__): "p" (& current_task));
  goto ldv_2696;
  case 2UL: 
  __asm__  ("movw %%gs:%P1,%0": "=r" (pfo_ret__): "p" (& current_task));
  goto ldv_2696;
  case 4UL: 
  __asm__  ("movl %%gs:%P1,%0": "=r" (pfo_ret__): "p" (& current_task));
  goto ldv_2696;
  case 8UL: 
  __asm__  ("movq %%gs:%P1,%0": "=r" (pfo_ret__): "p" (& current_task));
  goto ldv_2696;
  default: 
  __bad_percpu_size();
  }
  ldv_2696: ;
  return (pfo_ret__);
}
}
extern size_t strlcpy(char * , char const   * , size_t  ) ;
extern void __xchg_wrong_size(void) ;
extern void lockdep_init_map(struct lockdep_map * , char const   * , struct lock_class_key * ,
                             int  ) ;
int ldv_mutex_trylock_87(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_85(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_88(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_89(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_93(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_94(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_97(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_100(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_84(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_86(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_90(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_92(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_96(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_99(struct mutex *ldv_func_arg1 ) ;
extern void __wake_up(wait_queue_head_t * , unsigned int  , int  , void * ) ;
extern long prepare_to_wait_event(wait_queue_head_t * , wait_queue_t * , int  ) ;
extern void finish_wait(wait_queue_head_t * , wait_queue_t * ) ;
extern void __init_work(struct work_struct * , int  ) ;
extern struct workqueue_struct *__alloc_workqueue_key(char const   * , unsigned int  ,
                                                      int  , struct lock_class_key * ,
                                                      char const   *  , ...) ;
extern void destroy_workqueue(struct workqueue_struct * ) ;
void ldv_destroy_workqueue_104(struct workqueue_struct *ldv_func_arg1 ) ;
bool ldv_queue_work_on_79(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_work_on_81(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_delayed_work_on_80(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
bool ldv_queue_delayed_work_on_83(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
void ldv_flush_workqueue_82(struct workqueue_struct *ldv_func_arg1 ) ;
void ldv_flush_workqueue_102(struct workqueue_struct *ldv_func_arg1 ) ;
void ldv_flush_workqueue_103(struct workqueue_struct *ldv_func_arg1 ) ;
__inline static bool queue_work(struct workqueue_struct *wq , struct work_struct *work ) 
{ 
  bool tmp ;

  {
  tmp = ldv_queue_work_on_79(8192, wq, work);
  return (tmp);
}
}
extern int idr_alloc(struct idr * , void * , int  , int  , gfp_t  ) ;
extern void idr_remove(struct idr * , int  ) ;
extern long schedule_timeout(long  ) ;
extern void schedule(void) ;
void activate_work_5(struct work_struct *work , int state ) ;
void ldv_initialize_scsi_host_template_36(void) ;
void call_and_disable_all_4(int state ) ;
void disable_work_5(struct work_struct *work ) ;
void call_and_disable_work_3(struct work_struct *work ) ;
void disable_work_3(struct work_struct *work ) ;
void invoke_work_4(void) ;
void call_and_disable_work_5(struct work_struct *work ) ;
void activate_work_4(struct work_struct *work , int state ) ;
void call_and_disable_all_5(int state ) ;
void invoke_work_5(void) ;
void disable_work_4(struct work_struct *work ) ;
void invoke_work_3(void) ;
void call_and_disable_work_4(struct work_struct *work ) ;
extern void int_to_scsilun(u64  , struct scsi_lun * ) ;
extern u64 scsilun_to_int(struct scsi_lun * ) ;
extern struct Scsi_Host *scsi_host_alloc(struct scsi_host_template * , int  ) ;
struct Scsi_Host *ldv_scsi_host_alloc_101(struct scsi_host_template *sht , int privsize ) ;
int ldv_scsi_add_host_with_dma_91(struct Scsi_Host *shost , struct device *dev , struct device *dma_dev ) ;
int ldv_scsi_add_host_with_dma_95(struct Scsi_Host *shost , struct device *dev , struct device *dma_dev ) ;
extern void scsi_remove_host(struct Scsi_Host * ) ;
void ldv_scsi_remove_host_98(struct Scsi_Host *shost ) ;
extern void scsi_host_put(struct Scsi_Host * ) ;
extern void scsi_cmd_get_serial(struct Scsi_Host * , struct scsi_cmnd * ) ;
__inline static struct scsi_target *scsi_target(struct scsi_device *sdev ) 
{ 
  struct device  const  *__mptr ;

  {
  __mptr = (struct device  const  *)sdev->sdev_gendev.parent;
  return ((struct scsi_target *)__mptr + 0xffffffffffffffd8UL);
}
}
extern struct scsi_device *__scsi_iterate_devices(struct Scsi_Host * , struct scsi_device * ) ;
extern int scsi_change_queue_depth(struct scsi_device * , int  ) ;
extern int scsi_track_queue_full(struct scsi_device * , int  ) ;
extern int scsi_dma_map(struct scsi_cmnd * ) ;
extern void scsi_dma_unmap(struct scsi_cmnd * ) ;
__inline static unsigned int scsi_bufflen(struct scsi_cmnd *cmd ) 
{ 


  {
  return (cmd->sdb.length);
}
}
__inline static void scsi_set_resid(struct scsi_cmnd *cmd , int resid ) 
{ 


  {
  cmd->sdb.resid = resid;
  return;
}
}
__inline static int fc_remote_port_chkready(struct fc_rport *rport ) 
{ 
  int result ;

  {
  switch ((unsigned int )rport->port_state) {
  case 2U: ;
  if ((int )rport->roles & 1) {
    result = 0;
  } else
  if ((int )rport->flags & 1) {
    result = 786432;
  } else {
    result = 65536;
  }
  goto ldv_40526;
  case 4U: ;
  if (((int )rport->flags & 4) != 0) {
    result = 983040;
  } else {
    result = 786432;
  }
  goto ldv_40526;
  default: 
  result = 65536;
  goto ldv_40526;
  }
  ldv_40526: ;
  return (result);
}
}
extern struct scsi_transport_template *fc_attach_transport(struct fc_function_template * ) ;
extern void fc_release_transport(struct scsi_transport_template * ) ;
extern void fc_remove_host(struct Scsi_Host * ) ;
extern struct fc_rport *fc_remote_port_add(struct Scsi_Host * , int  , struct fc_rport_identifiers * ) ;
extern void fc_remote_port_delete(struct fc_rport * ) ;
extern void fc_remote_port_rolechg(struct fc_rport * , u32  ) ;
extern int scsi_is_fc_rport(struct device  const  * ) ;
extern u32 fc_get_event_number(void) ;
extern void fc_host_post_vendor_event(struct Scsi_Host * , u32  , u32  , char * ,
                                      u64  ) ;
extern int fc_vport_terminate(struct fc_vport * ) ;
__inline static void wwn2str___0(char *wwn_str , u64 wwn ) 
{ 
  union __anonunion_w_281 w ;

  {
  w.wwn = wwn;
  sprintf(wwn_str, "%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x", (int )w.byte[0], (int )w.byte[1],
          (int )w.byte[2], (int )w.byte[3], (int )w.byte[4], (int )w.byte[5], (int )w.byte[6],
          (int )w.byte[7]);
  return;
}
}
__inline static void fcid2str(char *fcid_str , u32 fcid ) 
{ 
  union __anonunion_f_283 f ;

  {
  f.fcid = fcid;
  sprintf(fcid_str, "%02x:%02x:%02x", (int )f.byte[1], (int )f.byte[2], (int )f.byte[3]);
  return;
}
}
void bfa_ioc_get_attr(struct bfa_ioc_s *ioc , struct bfa_ioc_attr_s *ioc_attr ) ;
void bfa_iocfc_get_bootwwns(struct bfa_s *bfa , u8 *nwwns , wwn_t *wwns ) ;
u32 bfa_lps_get_max_vport(struct bfa_s *bfa ) ;
u16 bfa_fcpim_path_tov_get(struct bfa_s *bfa ) ;
struct bfa_ioim_s *bfa_ioim_alloc(struct bfa_s *bfa , struct bfad_ioim_s *dio , struct bfa_itnim_s *itnim ,
                                  u16 nsges ) ;
void bfa_ioim_start(struct bfa_ioim_s *ioim ) ;
enum bfa_status bfa_ioim_abort(struct bfa_ioim_s *ioim ) ;
void bfa_cb_ioim_done(void *drv , struct bfad_ioim_s *dio , enum bfi_ioim_status io_status ,
                      u8 scsi_status , int sns_len , u8 *sns_info , s32 residue ) ;
void bfa_cb_ioim_good_comp(void *drv , struct bfad_ioim_s *dio ) ;
void bfa_cb_ioim_abort(void *drv , struct bfad_ioim_s *dio ) ;
struct bfa_tskim_s *bfa_tskim_alloc(struct bfa_s *bfa , struct bfad_tskim_s *dtsk ) ;
void bfa_tskim_start(struct bfa_tskim_s *tskim , struct bfa_itnim_s *itnim , struct scsi_lun lun ,
                     enum fcp_tm_cmnd tm_cmnd , u8 tsecs ) ;
void bfa_cb_tskim_done(void *bfad , struct bfad_tskim_s *dtsk , enum bfi_tskim_status tsk_status ) ;
__inline static struct bfad_port_s *bfa_fcs_itnim_get_drvport(struct bfa_fcs_itnim_s *itnim ) 
{ 


  {
  return (((itnim->rport)->port)->bfad_port);
}
}
__inline static wwn_t bfa_fcs_itnim_get_nwwn(struct bfa_fcs_itnim_s *itnim ) 
{ 


  {
  return ((itnim->rport)->nwwn);
}
}
__inline static wwn_t bfa_fcs_itnim_get_pwwn(struct bfa_fcs_itnim_s *itnim ) 
{ 


  {
  return ((itnim->rport)->pwwn);
}
}
__inline static u32 bfa_fcs_itnim_get_fcid(struct bfa_fcs_itnim_s *itnim ) 
{ 


  {
  return ((itnim->rport)->pid);
}
}
__inline static u32 bfa_fcs_itnim_get_maxfrsize(struct bfa_fcs_itnim_s *itnim ) 
{ 


  {
  return ((u32 )(itnim->rport)->maxfrsize);
}
}
__inline static enum fc_cos bfa_fcs_itnim_get_cos(struct bfa_fcs_itnim_s *itnim ) 
{ 


  {
  return ((itnim->rport)->fc_cos);
}
}
__inline static struct bfa_itnim_s *bfa_fcs_itnim_get_halitn(struct bfa_fcs_itnim_s *itnim ) 
{ 


  {
  return (itnim->bfa_itnim);
}
}
void bfa_fcb_itnim_alloc(struct bfad_s *bfad , struct bfa_fcs_itnim_s **itnim , struct bfad_itnim_s **itnim_drv ) ;
void bfa_fcb_itnim_free(struct bfad_s *bfad , struct bfad_itnim_s *itnim_drv ) ;
void bfa_fcb_itnim_online(struct bfad_itnim_s *itnim_drv ) ;
void bfa_fcb_itnim_offline(struct bfad_itnim_s *itnim_drv ) ;
struct idr bfad_im_port_index ;
u32 bfad_im_supported_speeds(struct bfa_s *bfa ) ;
struct Scsi_Host *bfad_scsi_host_alloc(struct bfad_im_port_s *im_port , struct bfad_s *bfad ) ;
enum bfa_status bfad_thread_workq(struct bfad_s *bfad ) ;
void bfad_destroy_workq(struct bfad_im_s *im ) ;
void bfad_scsi_host_free(struct bfad_s *bfad , struct bfad_im_port_s *im_port ) ;
void bfad_ramp_up_qdepth(struct bfad_itnim_s *itnim , struct scsi_device *sdev ) ;
void bfad_handle_qfull(struct bfad_itnim_s *itnim , struct scsi_device *sdev ) ;
struct bfad_itnim_s *bfad_get_itnim(struct bfad_im_port_s *im_port , int id ) ;
struct scsi_host_template bfad_im_scsi_host_template ;
struct scsi_host_template bfad_im_vport_template ;
struct fc_function_template bfad_im_fc_function_template ;
struct fc_function_template bfad_im_vport_fc_function_template ;
struct scsi_transport_template *bfad_im_scsi_transport_template  ;
struct scsi_transport_template *bfad_im_scsi_vport_transport_template  ;
struct device_attribute *bfad_im_host_attrs[13U] ;
struct device_attribute *bfad_im_vport_attrs[13U] ;
static int __trc_fileno___0  =    3074;
struct idr bfad_im_port_index  =    {0, 0, 0, 0, {{{{{0}}, 3735899821U, 4294967295U, (void *)-1, {0, {0, 0}, "bfad_im_port_index.lock",
                                                                 0, 0UL}}}}, 0, 0};
static void bfad_im_itnim_work_handler(struct work_struct *work ) ;
static int bfad_im_queuecommand(struct Scsi_Host *shost , struct scsi_cmnd *cmd ) ;
static int bfad_im_slave_alloc(struct scsi_device *sdev ) ;
static void bfad_im_fc_rport_add(struct bfad_im_port_s *im_port , struct bfad_itnim_s *itnim ) ;
void bfa_cb_ioim_done(void *drv , struct bfad_ioim_s *dio , enum bfi_ioim_status io_status ,
                      u8 scsi_status , int sns_len , u8 *sns_info , s32 residue ) 
{ 
  struct scsi_cmnd *cmnd ;
  struct bfad_s *bfad ;
  struct bfad_itnim_data_s *itnim_data ;
  struct bfad_itnim_s *itnim ;
  u8 host_status ;
  unsigned int tmp ;

  {
  cmnd = (struct scsi_cmnd *)dio;
  bfad = (struct bfad_s *)drv;
  host_status = 0U;
  switch ((unsigned int )io_status) {
  case 0U: 
  __bfa_trc(bfad->trcmod, __trc_fileno___0, 52, (unsigned long long )scsi_status);
  scsi_set_resid(cmnd, 0);
  if (sns_len > 0) {
    __bfa_trc(bfad->trcmod, __trc_fileno___0, 56, (unsigned long long )sns_len);
    if (sns_len > 96) {
      sns_len = 96;
    } else {

    }
    memcpy((void *)cmnd->sense_buffer, (void const   *)sns_info, (size_t )sns_len);
  } else {

  }
  if (residue > 0) {
    __bfa_trc(bfad->trcmod, __trc_fileno___0, 63, (unsigned long long )residue);
    scsi_set_resid(cmnd, residue);
    if (sns_len == 0 && (unsigned int )scsi_status == 0U) {
      tmp = scsi_bufflen(cmnd);
      if (tmp - (unsigned int )residue < cmnd->underflow) {
        __bfa_trc(bfad->trcmod, __trc_fileno___0, 68, 0ULL);
        host_status = 7U;
      } else {

      }
    } else {

    }
  } else {

  }
  cmnd->result = ((int )host_status << 16) | (int )scsi_status;
  goto ldv_48359;
  case 3U: 
  host_status = 3U;
  cmnd->result = (int )host_status << 16;
  goto ldv_48359;
  case 8U: 
  host_status = 14U;
  cmnd->result = (int )host_status << 16;
  goto ldv_48359;
  default: 
  host_status = 7U;
  cmnd->result = (int )host_status << 16;
  }
  ldv_48359: ;
  if ((unsigned long )(cmnd->device)->host != (unsigned long )((struct Scsi_Host *)0)) {
    scsi_dma_unmap(cmnd);
  } else {

  }
  cmnd->host_scribble = (unsigned char *)0U;
  __bfa_trc(bfad->trcmod, __trc_fileno___0, 94, (unsigned long long )cmnd->result);
  itnim_data = (struct bfad_itnim_data_s *)(cmnd->device)->hostdata;
  if ((unsigned long )itnim_data != (unsigned long )((struct bfad_itnim_data_s *)0)) {
    itnim = itnim_data->itnim;
    if ((cmnd->result == 0 && (unsigned long )itnim != (unsigned long )((struct bfad_itnim_s *)0)) && (int )(cmnd->device)->queue_depth < bfa_lun_queue_depth) {
      bfad_ramp_up_qdepth(itnim, cmnd->device);
    } else
    if (cmnd->result == 40 && (unsigned long )itnim != (unsigned long )((struct bfad_itnim_s *)0)) {
      bfad_handle_qfull(itnim, cmnd->device);
    } else {

    }
  } else {

  }
  (*(cmnd->scsi_done))(cmnd);
  return;
}
}
void bfa_cb_ioim_good_comp(void *drv , struct bfad_ioim_s *dio ) 
{ 
  struct scsi_cmnd *cmnd ;
  struct bfad_itnim_data_s *itnim_data ;
  struct bfad_itnim_s *itnim ;

  {
  cmnd = (struct scsi_cmnd *)dio;
  cmnd->result = 0;
  if ((unsigned long )(cmnd->device)->host != (unsigned long )((struct Scsi_Host *)0)) {
    scsi_dma_unmap(cmnd);
  } else {

  }
  cmnd->host_scribble = (unsigned char *)0U;
  if ((int )(cmnd->device)->queue_depth < bfa_lun_queue_depth) {
    itnim_data = (struct bfad_itnim_data_s *)(cmnd->device)->hostdata;
    if ((unsigned long )itnim_data != (unsigned long )((struct bfad_itnim_data_s *)0)) {
      itnim = itnim_data->itnim;
      if ((unsigned long )itnim != (unsigned long )((struct bfad_itnim_s *)0)) {
        bfad_ramp_up_qdepth(itnim, cmnd->device);
      } else {

      }
    } else {

    }
  } else {

  }
  (*(cmnd->scsi_done))(cmnd);
  return;
}
}
void bfa_cb_ioim_abort(void *drv , struct bfad_ioim_s *dio ) 
{ 
  struct scsi_cmnd *cmnd ;
  struct bfad_s *bfad ;

  {
  cmnd = (struct scsi_cmnd *)dio;
  bfad = (struct bfad_s *)drv;
  cmnd->result = 458752;
  if ((unsigned long )(cmnd->device)->host != (unsigned long )((struct Scsi_Host *)0)) {
    scsi_dma_unmap(cmnd);
  } else {

  }
  __bfa_trc(bfad->trcmod, __trc_fileno___0, 152, (unsigned long long )cmnd->result);
  cmnd->host_scribble = (unsigned char *)0U;
  return;
}
}
void bfa_cb_tskim_done(void *bfad , struct bfad_tskim_s *dtsk , enum bfi_tskim_status tsk_status ) 
{ 
  struct scsi_cmnd *cmnd ;
  wait_queue_head_t *wq ;

  {
  cmnd = (struct scsi_cmnd *)dtsk;
  cmnd->SCp.Status = (int volatile   )((unsigned int )cmnd->SCp.Status | ((unsigned int )tsk_status << 1));
  set_bit(0L, (unsigned long volatile   *)(& cmnd->SCp.Status));
  wq = (wait_queue_head_t *)cmnd->SCp.ptr;
  cmnd->SCp.ptr = (char *)0;
  if ((unsigned long )wq != (unsigned long )((wait_queue_head_t *)0)) {
    __wake_up(wq, 3U, 1, (void *)0);
  } else {

  }
  return;
}
}
static char const   *bfad_im_info(struct Scsi_Host *shost ) 
{ 
  char bfa_buf[256U] ;
  struct bfad_im_port_s *im_port ;
  struct bfad_s *bfad ;

  {
  im_port = (struct bfad_im_port_s *)shost->hostdata[0];
  bfad = im_port->bfad;
  memset((void *)(& bfa_buf), 0, 256UL);
  snprintf((char *)(& bfa_buf), 256UL, "Brocade FC/FCOE Adapter, hwpath: %s driver: %s",
           bfad->pci_name, (char *)"3.2.23.0");
  return ((char const   *)(& bfa_buf));
}
}
static int bfad_im_abort_handler(struct scsi_cmnd *cmnd ) 
{ 
  struct Scsi_Host *shost ;
  struct bfad_im_port_s *im_port ;
  struct bfad_s *bfad ;
  struct bfa_ioim_s *hal_io ;
  unsigned long flags ;
  u32 timeout ;
  int rc ;
  raw_spinlock_t *tmp ;
  struct task_struct *tmp___0 ;
  long volatile   __ret ;
  struct task_struct *tmp___1 ;
  struct task_struct *tmp___2 ;
  struct task_struct *tmp___3 ;
  struct task_struct *tmp___4 ;

  {
  shost = (cmnd->device)->host;
  im_port = (struct bfad_im_port_s *)shost->hostdata[0];
  bfad = im_port->bfad;
  rc = 8195;
  tmp = spinlock_check(& bfad->bfad_lock);
  flags = _raw_spin_lock_irqsave(tmp);
  hal_io = (struct bfa_ioim_s *)cmnd->host_scribble;
  if ((unsigned long )hal_io == (unsigned long )((struct bfa_ioim_s *)0)) {
    rc = 8194;
    goto out;
  } else {

  }
  if ((unsigned long )hal_io->dio != (unsigned long )((struct bfad_ioim_s *)cmnd)) {
    rc = 8195;
    goto out;
  } else {

  }
  __bfa_trc(bfad->trcmod, __trc_fileno___0, 223, (unsigned long long )hal_io->iotag);
  if (bfa_log_level == 4 || (int )((signed char )*("\016" + 1)) <= 52) {
    dev_printk("\016", (struct device  const  *)(& (bfad->pcidev)->dev), "scsi%d: abort cmnd %p iotag %x\n",
               (im_port->shost)->host_no, cmnd, (int )hal_io->iotag);
  } else {

  }
  bfa_ioim_abort(hal_io);
  spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  timeout = 10U;
  goto ldv_48412;
  ldv_48411: 
  tmp___0 = get_current();
  tmp___0->task_state_change = 0UL;
  __ret = 2L;
  switch (8UL) {
  case 1UL: 
  tmp___1 = get_current();
  __asm__  volatile   ("xchgb %b0, %1\n": "+q" (__ret), "+m" (tmp___1->state): : "memory",
                       "cc");
  goto ldv_48405;
  case 2UL: 
  tmp___2 = get_current();
  __asm__  volatile   ("xchgw %w0, %1\n": "+r" (__ret), "+m" (tmp___2->state): : "memory",
                       "cc");
  goto ldv_48405;
  case 4UL: 
  tmp___3 = get_current();
  __asm__  volatile   ("xchgl %0, %1\n": "+r" (__ret), "+m" (tmp___3->state): : "memory",
                       "cc");
  goto ldv_48405;
  case 8UL: 
  tmp___4 = get_current();
  __asm__  volatile   ("xchgq %q0, %1\n": "+r" (__ret), "+m" (tmp___4->state): : "memory",
                       "cc");
  goto ldv_48405;
  default: 
  __xchg_wrong_size();
  }
  ldv_48405: 
  schedule_timeout((long )timeout);
  if (timeout <= 999U) {
    timeout = timeout * 2U;
  } else {

  }
  ldv_48412: ;
  if ((unsigned long )((struct bfa_ioim_s *)cmnd->host_scribble) == (unsigned long )hal_io) {
    goto ldv_48411;
  } else {

  }
  (*(cmnd->scsi_done))(cmnd);
  __bfa_trc(bfad->trcmod, __trc_fileno___0, 240, (unsigned long long )hal_io->iotag);
  if (bfa_log_level == 4 || (int )((signed char )*("\016" + 1)) <= 52) {
    dev_printk("\016", (struct device  const  *)(& (bfad->pcidev)->dev), "scsi%d: complete abort 0x%p iotag 0x%x\n",
               (im_port->shost)->host_no, cmnd, (int )hal_io->iotag);
  } else {

  }
  return (8194);
  out: 
  spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  return (rc);
}
}
static enum bfa_status bfad_im_target_reset_send(struct bfad_s *bfad , struct scsi_cmnd *cmnd ,
                                                 struct bfad_itnim_s *itnim ) 
{ 
  struct bfa_tskim_s *tskim ;
  struct bfa_itnim_s *bfa_itnim ;
  enum bfa_status rc ;
  struct scsi_lun scsilun ;

  {
  rc = 0;
  tskim = bfa_tskim_alloc(& bfad->bfa, (struct bfad_tskim_s *)cmnd);
  if ((unsigned long )tskim == (unsigned long )((struct bfa_tskim_s *)0)) {
    if (bfa_log_level == 4 || (int )((signed char )*("\v" + 1)) <= 52) {
      dev_printk("\v", (struct device  const  *)(& (bfad->pcidev)->dev), "target reset, fail to allocate tskim\n");
    } else {

    }
    rc = 1;
    goto out;
  } else {

  }
  cmnd->host_scribble = (unsigned char *)0U;
  cmnd->SCp.Status = 0;
  bfa_itnim = bfa_fcs_itnim_get_halitn(& itnim->fcs_itnim);
  memset((void *)(& scsilun), 0, 8UL);
  bfa_tskim_start(tskim, bfa_itnim, scsilun, 32, 60);
  out: ;
  return (rc);
}
}
static int bfad_im_reset_lun_handler(struct scsi_cmnd *cmnd ) 
{ 
  struct Scsi_Host *shost ;
  struct bfad_im_port_s *im_port ;
  struct bfad_itnim_data_s *itnim_data ;
  struct bfad_s *bfad ;
  struct bfa_tskim_s *tskim ;
  struct bfad_itnim_s *itnim ;
  struct bfa_itnim_s *bfa_itnim ;
  wait_queue_head_t wq ;
  struct lock_class_key __key ;
  int rc ;
  unsigned long flags ;
  enum bfi_tskim_status task_status ;
  struct scsi_lun scsilun ;
  raw_spinlock_t *tmp ;
  int tmp___0 ;
  wait_queue_t __wait ;
  long __ret ;
    klee_make_symbolic(&__ret, sizeof(long), "__ret");
  long __int ;
    klee_make_symbolic(&__int, sizeof(long), "__int");
  long tmp___1 ;
    klee_make_symbolic(&tmp___1, sizeof(long), "tmp___1");
  int tmp___2 ;

  {
  shost = (cmnd->device)->host;
  im_port = (struct bfad_im_port_s *)shost->hostdata[0];
  itnim_data = (struct bfad_itnim_data_s *)(cmnd->device)->hostdata;
  bfad = im_port->bfad;
  __init_waitqueue_head(& wq, "&wq", & __key);
  wq = wq;
  rc = 8194;
  tmp = spinlock_check(& bfad->bfad_lock);
  flags = _raw_spin_lock_irqsave(tmp);
  itnim = itnim_data->itnim;
  if ((unsigned long )itnim == (unsigned long )((struct bfad_itnim_s *)0)) {
    spin_unlock_irqrestore(& bfad->bfad_lock, flags);
    rc = 8195;
    goto out;
  } else {

  }
  tskim = bfa_tskim_alloc(& bfad->bfa, (struct bfad_tskim_s *)cmnd);
  if ((unsigned long )tskim == (unsigned long )((struct bfa_tskim_s *)0)) {
    if (bfa_log_level == 4 || (int )((signed char )*("\v" + 1)) <= 52) {
      dev_printk("\v", (struct device  const  *)(& (bfad->pcidev)->dev), "LUN reset, fail to allocate tskim");
    } else {

    }
    spin_unlock_irqrestore(& bfad->bfad_lock, flags);
    rc = 8195;
    goto out;
  } else {

  }
  cmnd->host_scribble = (unsigned char *)0U;
  cmnd->SCp.ptr = (char *)(& wq);
  cmnd->SCp.Status = 0;
  bfa_itnim = bfa_fcs_itnim_get_halitn(& itnim->fcs_itnim);
  int_to_scsilun((cmnd->device)->lun, & scsilun);
  bfa_tskim_start(tskim, bfa_itnim, scsilun, 16, 60);
  spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  __might_sleep("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfad_im.c",
                335, 0);
  tmp___0 = constant_test_bit(0L, (unsigned long const volatile   *)(& cmnd->SCp.Status));
  if (tmp___0 != 0) {
    goto ldv_48445;
  } else {

  }
  __ret = 0L;
  INIT_LIST_HEAD(& __wait.task_list);
  __wait.flags = 0U;
  ldv_48451: 
  tmp___1 = prepare_to_wait_event(& wq, & __wait, 2);
  __int = tmp___1;
  tmp___2 = constant_test_bit(0L, (unsigned long const volatile   *)(& cmnd->SCp.Status));
  if (tmp___2 != 0) {
    goto ldv_48450;
  } else {

  }
  schedule();
  goto ldv_48451;
  ldv_48450: 
  finish_wait(& wq, & __wait);

  ldv_48445: 
  task_status = (enum bfi_tskim_status )(cmnd->SCp.Status >> 1);
  if ((unsigned int )task_status != 0U) {
    if (bfa_log_level == 4 || (int )((signed char )*("\v" + 1)) <= 52) {
      dev_printk("\v", (struct device  const  *)(& (bfad->pcidev)->dev), "LUN reset failure, status: %d\n",
                 (unsigned int )task_status);
    } else {

    }
    rc = 8195;
  } else {

  }
  out: ;
  return (rc);
}
}
static int bfad_im_reset_bus_handler(struct scsi_cmnd *cmnd ) 
{ 
  struct Scsi_Host *shost ;
  struct bfad_im_port_s *im_port ;
  struct bfad_s *bfad ;
  struct bfad_itnim_s *itnim ;
  unsigned long flags ;
  u32 i ;
  u32 rc ;
  u32 err_cnt ;
  wait_queue_head_t wq ;
  struct lock_class_key __key ;
  enum bfi_tskim_status task_status ;
  raw_spinlock_t *tmp ;
  enum bfa_status tmp___0 ;
  int tmp___1 ;
  wait_queue_t __wait ;
  long __ret ;
  long __int ;
  long tmp___2 ;
  int tmp___3 ;
  raw_spinlock_t *tmp___4 ;

  {
  shost = (cmnd->device)->host;
  im_port = (struct bfad_im_port_s *)shost->hostdata[0];
  bfad = im_port->bfad;
  err_cnt = 0U;
  __init_waitqueue_head(& wq, "&wq", & __key);
  wq = wq;
  tmp = spinlock_check(& bfad->bfad_lock);
  flags = _raw_spin_lock_irqsave(tmp);
  i = 0U;
  goto ldv_48484;
  ldv_48483: 
  itnim = bfad_get_itnim(im_port, (int )i);
  if ((unsigned long )itnim != (unsigned long )((struct bfad_itnim_s *)0)) {
    cmnd->SCp.ptr = (char *)(& wq);
    tmp___0 = bfad_im_target_reset_send(bfad, cmnd, itnim);
    rc = (u32 )tmp___0;
    if (rc != 0U) {
      err_cnt = err_cnt + 1U;
      goto ldv_48471;
    } else {

    }
    spin_unlock_irqrestore(& bfad->bfad_lock, flags);
    __might_sleep("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfad_im.c",
                  378, 0);
    tmp___1 = constant_test_bit(0L, (unsigned long const volatile   *)(& cmnd->SCp.Status));
    if (tmp___1 != 0) {
      goto ldv_48472;
    } else {

    }
    __ret = 0L;
    INIT_LIST_HEAD(& __wait.task_list);
    __wait.flags = 0U;
    ldv_48478: 
    tmp___2 = prepare_to_wait_event(& wq, & __wait, 2);
    __int = tmp___2;
    tmp___3 = constant_test_bit(0L, (unsigned long const volatile   *)(& cmnd->SCp.Status));
    if (tmp___3 != 0) {
      goto ldv_48477;
    } else {

    }
    schedule();
    goto ldv_48478;
    ldv_48477: 
    finish_wait(& wq, & __wait);

    ldv_48472: 
    tmp___4 = spinlock_check(& bfad->bfad_lock);
    flags = _raw_spin_lock_irqsave(tmp___4);
    task_status = (enum bfi_tskim_status )(cmnd->SCp.Status >> 1);
    if ((unsigned int )task_status != 0U) {
      if (bfa_log_level == 4 || (int )((signed char )*("\v" + 1)) <= 52) {
        dev_printk("\v", (struct device  const  *)(& (bfad->pcidev)->dev), "target reset failure, status: %d\n",
                   (unsigned int )task_status);
      } else {

      }
      err_cnt = err_cnt + 1U;
    } else {

    }
  } else {

  }
  ldv_48471: 
  i = i + 1U;
  ldv_48484: ;
  if (i <= 1023U) {
    goto ldv_48483;
  } else {

  }
  spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  if (err_cnt != 0U) {
    return (8195);
  } else {

  }
  return (8194);
}
}
static void bfad_im_slave_destroy(struct scsi_device *sdev ) 
{ 


  {
  sdev->hostdata = (void *)0;
  return;
}
}
void bfa_fcb_itnim_alloc(struct bfad_s *bfad , struct bfa_fcs_itnim_s **itnim , struct bfad_itnim_s **itnim_drv ) 
{ 
  void *tmp ;
  struct lock_class_key __key ;
  atomic_long_t __constr_expr_0 ;

  {
  tmp = kzalloc(416UL, 32U);
  *itnim_drv = (struct bfad_itnim_s *)tmp;
  if ((unsigned long )*itnim_drv == (unsigned long )((struct bfad_itnim_s *)0)) {
    return;
  } else {

  }
  (*itnim_drv)->im = bfad->im;
  *itnim = & (*itnim_drv)->fcs_itnim;
  (*itnim_drv)->state = 0;
  __init_work(& (*itnim_drv)->itnim_work, 0);
  __constr_expr_0.counter = 137438953408L;
  (*itnim_drv)->itnim_work.data = __constr_expr_0;
  lockdep_init_map(& (*itnim_drv)->itnim_work.lockdep_map, "(&(*itnim_drv)->itnim_work)",
                   & __key, 0);
  INIT_LIST_HEAD(& (*itnim_drv)->itnim_work.entry);
  (*itnim_drv)->itnim_work.func = & bfad_im_itnim_work_handler;
  bfad->bfad_flags = bfad->bfad_flags | 64U;
  return;
}
}
void bfa_fcb_itnim_free(struct bfad_s *bfad , struct bfad_itnim_s *itnim_drv ) 
{ 
  struct bfad_port_s *port ;
  wwn_t wwpn ;
  u32 fcid ;
  char wwpn_str[32U] ;
  char fcid_str[16U] ;
  struct bfad_im_s *im ;
  int __ret_warn_on ;
  long tmp ;

  {
  im = itnim_drv->im;
  __ret_warn_on = (unsigned int )itnim_drv->state == 1U;
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfad_im.c",
                       449);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  itnim_drv->queue_work = 1U;
  if ((unsigned int )itnim_drv->state == 2U) {
    itnim_drv->queue_work = 0U;
  } else {

  }
  itnim_drv->state = 5;
  port = bfa_fcs_itnim_get_drvport(& itnim_drv->fcs_itnim);
  itnim_drv->im_port = port->im_port;
  wwpn = bfa_fcs_itnim_get_pwwn(& itnim_drv->fcs_itnim);
  fcid = bfa_fcs_itnim_get_fcid(& itnim_drv->fcs_itnim);
  wwn2str___0((char *)(& wwpn_str), wwpn);
  fcid2str((char *)(& fcid_str), fcid);
  if (bfa_log_level == 4 || (int )((signed char )*("\016" + 1)) <= 52) {
    dev_printk("\016", (struct device  const  *)(& (bfad->pcidev)->dev), "ITNIM FREE scsi%d: FCID: %s WWPN: %s\n",
               ((port->im_port)->shost)->host_no, (char *)(& fcid_str), (char *)(& wwpn_str));
  } else {

  }
  if ((unsigned int )itnim_drv->queue_work != 0U) {
    queue_work(im->drv_workq, & itnim_drv->itnim_work);
  } else {

  }
  return;
}
}
void bfa_fcb_itnim_online(struct bfad_itnim_s *itnim_drv ) 
{ 
  struct bfad_port_s *port ;
  struct bfad_im_s *im ;

  {
  im = itnim_drv->im;
  itnim_drv->bfa_itnim = bfa_fcs_itnim_get_halitn(& itnim_drv->fcs_itnim);
  port = bfa_fcs_itnim_get_drvport(& itnim_drv->fcs_itnim);
  itnim_drv->state = 1;
  itnim_drv->queue_work = 1U;
  itnim_drv->im_port = port->im_port;
  if ((unsigned int )itnim_drv->queue_work != 0U) {
    queue_work(im->drv_workq, & itnim_drv->itnim_work);
  } else {

  }
  return;
}
}
void bfa_fcb_itnim_offline(struct bfad_itnim_s *itnim_drv ) 
{ 
  struct bfad_port_s *port ;
  struct bfad_s *bfad ;
  struct bfad_im_s *im ;

  {
  im = itnim_drv->im;
  port = bfa_fcs_itnim_get_drvport(& itnim_drv->fcs_itnim);
  bfad = port->bfad;
  if (bfad->pport.flags & 1 || port->flags & 1) {
    itnim_drv->state = 3;
    return;
  } else {

  }
  itnim_drv->im_port = port->im_port;
  itnim_drv->state = 2;
  itnim_drv->queue_work = 1U;
  if ((unsigned int )itnim_drv->queue_work != 0U) {
    queue_work(im->drv_workq, & itnim_drv->itnim_work);
  } else {

  }
  return;
}
}
int bfad_im_scsi_host_alloc(struct bfad_s *bfad , struct bfad_im_port_s *im_port ,
                            struct device *dev ) 
{ 
  int error ;

  {
  error = 1;
  ldv_mutex_lock_92(& bfad_mutex);
  error = idr_alloc(& bfad_im_port_index, (void *)im_port, 0, 0, 208U);
  if (error < 0) {
    ldv_mutex_unlock_93(& bfad_mutex);
    printk("\fidr_alloc failure\n");
    goto out;
  } else {

  }
  im_port->idr_id = error;
  ldv_mutex_unlock_94(& bfad_mutex);
  im_port->shost = bfad_scsi_host_alloc(im_port, bfad);
  if ((unsigned long )im_port->shost == (unsigned long )((struct Scsi_Host *)0)) {
    error = 1;
    goto out_free_idr;
  } else {

  }
  (im_port->shost)->hostdata[0] = (unsigned long )im_port;
  (im_port->shost)->unique_id = (unsigned int )im_port->idr_id;
  (im_port->shost)->this_id = -1;
  (im_port->shost)->max_id = 1024U;
  (im_port->shost)->max_lun = 16384ULL;
  (im_port->shost)->max_cmd_len = 16U;
  (im_port->shost)->can_queue = (int )bfad->cfg_data.ioc_queue_depth;
  if ((unsigned int )(im_port->port)->pvb_type == 0U) {
    (im_port->shost)->transportt = bfad_im_scsi_transport_template;
  } else {
    (im_port->shost)->transportt = bfad_im_scsi_vport_transport_template;
  }
  error = ldv_scsi_add_host_with_dma_95(im_port->shost, dev, & (bfad->pcidev)->dev);
  if (error != 0) {
    printk("\fscsi_add_host failure %d\n", error);
    goto out_fc_rel;
  } else {

  }
  return (0);
  out_fc_rel: 
  scsi_host_put(im_port->shost);
  im_port->shost = (struct Scsi_Host *)0;
  out_free_idr: 
  ldv_mutex_lock_96(& bfad_mutex);
  idr_remove(& bfad_im_port_index, im_port->idr_id);
  ldv_mutex_unlock_97(& bfad_mutex);
  out: ;
  return (error);
}
}
void bfad_im_scsi_host_free(struct bfad_s *bfad , struct bfad_im_port_s *im_port ) 
{ 


  {
  __bfa_trc(bfad->trcmod, __trc_fileno___0, 581, (unsigned long long )bfad->inst_no);
  if (bfa_log_level == 4 || (int )((signed char )*("\016" + 1)) <= 52) {
    dev_printk("\016", (struct device  const  *)(& (bfad->pcidev)->dev), "Free scsi%d\n",
               (im_port->shost)->host_no);
  } else {

  }
  fc_remove_host(im_port->shost);
  ldv_scsi_remove_host_98(im_port->shost);
  scsi_host_put(im_port->shost);
  ldv_mutex_lock_99(& bfad_mutex);
  idr_remove(& bfad_im_port_index, im_port->idr_id);
  ldv_mutex_unlock_100(& bfad_mutex);
  return;
}
}
static void bfad_im_port_delete_handler(struct work_struct *work ) 
{ 
  struct bfad_im_port_s *im_port ;
  struct work_struct  const  *__mptr ;

  {
  __mptr = (struct work_struct  const  *)work;
  im_port = (struct bfad_im_port_s *)__mptr + 0xfffffffffffffff0UL;
  if ((unsigned int )(im_port->port)->pvb_type != 0U) {
    im_port->flags = (u16 )((unsigned int )im_port->flags | 1U);
    fc_vport_terminate(im_port->fc_vport);
  } else {

  }
  return;
}
}
enum bfa_status bfad_im_port_new(struct bfad_s *bfad , struct bfad_port_s *port ) 
{ 
  int rc ;
  struct bfad_im_port_s *im_port ;
  void *tmp ;
  struct lock_class_key __key ;
  atomic_long_t __constr_expr_0 ;

  {
  rc = 0;
  tmp = kzalloc(152UL, 32U);
  im_port = (struct bfad_im_port_s *)tmp;
  if ((unsigned long )im_port == (unsigned long )((struct bfad_im_port_s *)0)) {
    rc = 3;
    goto ext;
  } else {

  }
  port->im_port = im_port;
  im_port->port = port;
  im_port->bfad = bfad;
  __init_work(& im_port->port_delete_work, 0);
  __constr_expr_0.counter = 137438953408L;
  im_port->port_delete_work.data = __constr_expr_0;
  lockdep_init_map(& im_port->port_delete_work.lockdep_map, "(&im_port->port_delete_work)",
                   & __key, 0);
  INIT_LIST_HEAD(& im_port->port_delete_work.entry);
  im_port->port_delete_work.func = & bfad_im_port_delete_handler;
  INIT_LIST_HEAD(& im_port->itnim_mapped_list);
  INIT_LIST_HEAD(& im_port->binding_list);
  ext: ;
  return ((enum bfa_status )rc);
}
}
void bfad_im_port_delete(struct bfad_s *bfad , struct bfad_port_s *port ) 
{ 
  struct bfad_im_port_s *im_port ;

  {
  im_port = port->im_port;
  queue_work((bfad->im)->drv_workq, & im_port->port_delete_work);
  return;
}
}
void bfad_im_port_clean(struct bfad_im_port_s *im_port ) 
{ 
  struct bfad_fcp_binding *bp ;
  struct bfad_fcp_binding *bp_new ;
  unsigned long flags ;
  struct bfad_s *bfad ;
  raw_spinlock_t *tmp ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;
  int __ret_warn_on ;
  int tmp___0 ;
  long tmp___1 ;

  {
  bfad = im_port->bfad;
  tmp = spinlock_check(& bfad->bfad_lock);
  flags = _raw_spin_lock_irqsave(tmp);
  __mptr = (struct list_head  const  *)im_port->binding_list.next;
  bp = (struct bfad_fcp_binding *)__mptr;
  __mptr___0 = (struct list_head  const  *)bp->list_entry.next;
  bp_new = (struct bfad_fcp_binding *)__mptr___0;
  goto ldv_48569;
  ldv_48568: 
  list_del(& bp->list_entry);
  kfree((void const   *)bp);
  bp = bp_new;
  __mptr___1 = (struct list_head  const  *)bp_new->list_entry.next;
  bp_new = (struct bfad_fcp_binding *)__mptr___1;
  ldv_48569: ;
  if ((unsigned long )(& bp->list_entry) != (unsigned long )(& im_port->binding_list)) {
    goto ldv_48568;
  } else {

  }
  tmp___0 = list_empty((struct list_head  const  *)(& im_port->itnim_mapped_list));
  __ret_warn_on = tmp___0 == 0;
  tmp___1 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp___1 != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfad_im.c",
                       654);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  return;
}
}
static void bfad_aen_im_notify_handler(struct work_struct *work ) 
{ 
  struct bfad_im_s *im ;
  struct work_struct  const  *__mptr ;
  struct bfa_aen_entry_s *aen_entry ;
  struct bfad_s *bfad ;
  struct Scsi_Host *shost ;
  void *event_data ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;
  int tmp___0 ;
  u32 tmp___1 ;
  raw_spinlock_t *tmp___2 ;
  int tmp___3 ;

  {
  __mptr = (struct work_struct  const  *)work;
  im = (struct bfad_im_s *)__mptr + 0xffffffffffffffd8UL;
  bfad = im->bfad;
  shost = (bfad->pport.im_port)->shost;
  goto ldv_48591;
  ldv_48590: 
  tmp = spinlock_check(& bfad->bfad_aen_spinlock);
  flags = _raw_spin_lock_irqsave(tmp);
  tmp___0 = list_empty((struct list_head  const  *)(& bfad->active_aen_q));
  if (tmp___0 == 0) {
    *((struct list_head **)(& aen_entry)) = bfad->active_aen_q.next;
    ((*((struct list_head **)(& aen_entry)))->next)->prev = & bfad->active_aen_q;
    bfad->active_aen_q.next = (*((struct list_head **)(& aen_entry)))->next;
  } else {
    *((struct list_head **)(& aen_entry)) = (struct list_head *)0;
  }
  spin_unlock_irqrestore(& bfad->bfad_aen_spinlock, flags);
  event_data = (void *)aen_entry + 16U;
  tmp___1 = fc_get_event_number();
  fc_host_post_vendor_event(shost, tmp___1, 72U, (char *)event_data, 72057594037933655ULL);
  tmp___2 = spinlock_check(& bfad->bfad_aen_spinlock);
  flags = _raw_spin_lock_irqsave(tmp___2);
  list_add_tail(& aen_entry->qe, & bfad->free_aen_q);
  spin_unlock_irqrestore(& bfad->bfad_aen_spinlock, flags);
  ldv_48591: 
  tmp___3 = list_empty((struct list_head  const  *)(& bfad->active_aen_q));
  if (tmp___3 == 0) {
    goto ldv_48590;
  } else {

  }

  return;
}
}
enum bfa_status bfad_im_probe(struct bfad_s *bfad ) 
{ 
  struct bfad_im_s *im ;
  void *tmp ;
  enum bfa_status tmp___0 ;
  struct lock_class_key __key ;
  atomic_long_t __constr_expr_0 ;

  {
  tmp = kzalloc(120UL, 208U);
  im = (struct bfad_im_s *)tmp;
  if ((unsigned long )im == (unsigned long )((struct bfad_im_s *)0)) {
    return (3);
  } else {

  }
  bfad->im = im;
  im->bfad = bfad;
  tmp___0 = bfad_thread_workq(bfad);
  if ((unsigned int )tmp___0 != 0U) {
    kfree((void const   *)im);
    return (1);
  } else {

  }
  __init_work(& im->aen_im_notify_work, 0);
  __constr_expr_0.counter = 137438953408L;
  im->aen_im_notify_work.data = __constr_expr_0;
  lockdep_init_map(& im->aen_im_notify_work.lockdep_map, "(&im->aen_im_notify_work)",
                   & __key, 0);
  INIT_LIST_HEAD(& im->aen_im_notify_work.entry);
  im->aen_im_notify_work.func = & bfad_aen_im_notify_handler;
  return (0);
}
}
void bfad_im_probe_undo(struct bfad_s *bfad ) 
{ 


  {
  if ((unsigned long )bfad->im != (unsigned long )((struct bfad_im_s *)0)) {
    bfad_destroy_workq(bfad->im);
    kfree((void const   *)bfad->im);
    bfad->im = (struct bfad_im_s *)0;
  } else {

  }
  return;
}
}
struct Scsi_Host *bfad_scsi_host_alloc(struct bfad_im_port_s *im_port , struct bfad_s *bfad ) 
{ 
  struct scsi_host_template *sht ;
  struct Scsi_Host *tmp ;

  {
  if ((unsigned int )(im_port->port)->pvb_type == 0U) {
    sht = & bfad_im_scsi_host_template;
  } else {
    sht = & bfad_im_vport_template;
  }
  if (max_xfer_size != 32767) {
    sht->max_sectors = (unsigned int )(max_xfer_size << 1);
  } else {

  }
  sht->sg_tablesize = (unsigned short )bfad->cfg_data.io_max_sge;
  tmp = ldv_scsi_host_alloc_101(sht, 8);
  return (tmp);
}
}
void bfad_scsi_host_free(struct bfad_s *bfad , struct bfad_im_port_s *im_port ) 
{ 


  {
  if (((int )im_port->flags & 1) == 0) {
    ldv_flush_workqueue_102((bfad->im)->drv_workq);
  } else {

  }
  bfad_im_scsi_host_free(im_port->bfad, im_port);
  bfad_im_port_clean(im_port);
  kfree((void const   *)im_port);
  return;
}
}
void bfad_destroy_workq(struct bfad_im_s *im ) 
{ 


  {
  if ((unsigned long )im != (unsigned long )((struct bfad_im_s *)0) && (unsigned long )im->drv_workq != (unsigned long )((struct workqueue_struct *)0)) {
    ldv_flush_workqueue_103(im->drv_workq);
    ldv_destroy_workqueue_104(im->drv_workq);
    im->drv_workq = (struct workqueue_struct *)0;
  } else {

  }
  return;
}
}
enum bfa_status bfad_thread_workq(struct bfad_s *bfad ) 
{ 
  struct bfad_im_s *im ;
  struct lock_class_key __key ;
  char const   *__lock_name ;
  struct workqueue_struct *tmp ;

  {
  im = bfad->im;
  __bfa_trc(bfad->trcmod, __trc_fileno___0, 758, 0ULL);
  snprintf((char *)(& im->drv_workq_name), 20UL, "bfad_wq_%d", bfad->inst_no);
  __lock_name = "\"%s\"im->drv_workq_name";
  tmp = __alloc_workqueue_key("%s", 131082U, 1, & __key, __lock_name, (char *)(& im->drv_workq_name));
  im->drv_workq = tmp;
  if ((unsigned long )im->drv_workq == (unsigned long )((struct workqueue_struct *)0)) {
    return (1);
  } else {

  }
  return (0);
}
}
static int bfad_im_slave_configure(struct scsi_device *sdev ) 
{ 


  {
  scsi_change_queue_depth(sdev, bfa_lun_queue_depth);
  return (0);
}
}
struct scsi_host_template bfad_im_scsi_host_template  = 
     {& __this_module, "bfa", 0, 0, & bfad_im_info, 0, 0, & bfad_im_queuecommand, & bfad_im_abort_handler,
    & bfad_im_reset_lun_handler, 0, & bfad_im_reset_bus_handler, 0, & bfad_im_slave_alloc,
    & bfad_im_slave_configure, & bfad_im_slave_destroy, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, -1, 128U, (unsigned short)0, 65535U, 0UL, 3, (unsigned char)0,
    0, 1U, (unsigned char)0, (unsigned char)0, (unsigned char)0, 1U, (unsigned char)0,
    (unsigned char)0, (unsigned char)0, (unsigned char)0, 0U, (struct device_attribute **)(& bfad_im_host_attrs),
    0, {0, 0}, 5719ULL, 0U, 0, (_Bool)0};
struct scsi_host_template bfad_im_vport_template  = 
     {& __this_module, "bfa", 0, 0, & bfad_im_info, 0, 0, & bfad_im_queuecommand, & bfad_im_abort_handler,
    & bfad_im_reset_lun_handler, 0, & bfad_im_reset_bus_handler, 0, & bfad_im_slave_alloc,
    & bfad_im_slave_configure, & bfad_im_slave_destroy, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, -1, 128U, (unsigned short)0, 65535U, 0UL, 3, (unsigned char)0,
    0, 1U, (unsigned char)0, (unsigned char)0, (unsigned char)0, 1U, (unsigned char)0,
    (unsigned char)0, (unsigned char)0, (unsigned char)0, 0U, (struct device_attribute **)(& bfad_im_vport_attrs),
    0, {0, 0}, 0ULL, 0U, 0, (_Bool)0};
enum bfa_status bfad_im_module_init(void) 
{ 


  {
  bfad_im_scsi_transport_template = fc_attach_transport(& bfad_im_fc_function_template);
  if ((unsigned long )bfad_im_scsi_transport_template == (unsigned long )((struct scsi_transport_template *)0)) {
    return (3);
  } else {

  }
  bfad_im_scsi_vport_transport_template = fc_attach_transport(& bfad_im_vport_fc_function_template);
  if ((unsigned long )bfad_im_scsi_vport_transport_template == (unsigned long )((struct scsi_transport_template *)0)) {
    fc_release_transport(bfad_im_scsi_transport_template);
    return (3);
  } else {

  }
  return (0);
}
}
void bfad_im_module_exit(void) 
{ 


  {
  if ((unsigned long )bfad_im_scsi_transport_template != (unsigned long )((struct scsi_transport_template *)0)) {
    fc_release_transport(bfad_im_scsi_transport_template);
  } else {

  }
  if ((unsigned long )bfad_im_scsi_vport_transport_template != (unsigned long )((struct scsi_transport_template *)0)) {
    fc_release_transport(bfad_im_scsi_vport_transport_template);
  } else {

  }
  return;
}
}
void bfad_ramp_up_qdepth(struct bfad_itnim_s *itnim , struct scsi_device *sdev ) 
{ 
  struct scsi_device *tmp_sdev ;

  {
  if ((unsigned long )jiffies - itnim->last_ramp_up_time > 30000UL && (unsigned long )jiffies - itnim->last_queue_full_time > 30000UL) {
    tmp_sdev = __scsi_iterate_devices(sdev->host, (struct scsi_device *)0);
    goto ldv_48639;
    ldv_48638: ;
    if ((int )tmp_sdev->queue_depth < bfa_lun_queue_depth) {
      if (tmp_sdev->id != sdev->id) {
        goto ldv_48637;
      } else {

      }
      scsi_change_queue_depth(tmp_sdev, (int )tmp_sdev->queue_depth + 1);
      itnim->last_ramp_up_time = jiffies;
    } else {

    }
    ldv_48637: 
    tmp_sdev = __scsi_iterate_devices(sdev->host, tmp_sdev);
    ldv_48639: ;
    if ((unsigned long )tmp_sdev != (unsigned long )((struct scsi_device *)0)) {
      goto ldv_48638;
    } else {

    }

  } else {

  }
  return;
}
}
void bfad_handle_qfull(struct bfad_itnim_s *itnim , struct scsi_device *sdev ) 
{ 
  struct scsi_device *tmp_sdev ;

  {
  itnim->last_queue_full_time = jiffies;
  tmp_sdev = __scsi_iterate_devices(sdev->host, (struct scsi_device *)0);
  goto ldv_48648;
  ldv_48647: ;
  if (tmp_sdev->id != sdev->id) {
    goto ldv_48646;
  } else {

  }
  scsi_track_queue_full(tmp_sdev, (int )tmp_sdev->queue_depth + -1);
  ldv_48646: 
  tmp_sdev = __scsi_iterate_devices(sdev->host, tmp_sdev);
  ldv_48648: ;
  if ((unsigned long )tmp_sdev != (unsigned long )((struct scsi_device *)0)) {
    goto ldv_48647;
  } else {

  }

  return;
}
}
struct bfad_itnim_s *bfad_get_itnim(struct bfad_im_port_s *im_port , int id ) 
{ 
  struct bfad_itnim_s *itnim ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;

  {
  itnim = (struct bfad_itnim_s *)0;
  __mptr = (struct list_head  const  *)im_port->itnim_mapped_list.next;
  itnim = (struct bfad_itnim_s *)__mptr;
  goto ldv_48660;
  ldv_48659: ;
  if ((int )itnim->scsi_tgt_id == id) {
    return (itnim);
  } else {

  }
  __mptr___0 = (struct list_head  const  *)itnim->list_entry.next;
  itnim = (struct bfad_itnim_s *)__mptr___0;
  ldv_48660: ;
  if ((unsigned long )(& itnim->list_entry) != (unsigned long )(& im_port->itnim_mapped_list)) {
    goto ldv_48659;
  } else {

  }

  return ((struct bfad_itnim_s *)0);
}
}
static int bfad_im_check_if_make_lun_visible(struct scsi_device *sdev , struct fc_rport *rport ) 
{ 
  struct bfad_itnim_data_s *itnim_data ;
  struct bfa_s *bfa ;
  struct bfa_rport_s *bfa_rport ;
  struct bfa_lun_mask_s *lun_list ;
  int i ;
  int ret ;
    klee_make_symbolic(&ret, sizeof(int), "ret");
  u64 tmp ;

  {
  itnim_data = (struct bfad_itnim_data_s *)rport->dd_data;
  bfa = ((itnim_data->itnim)->bfa_itnim)->bfa;
  bfa_rport = ((itnim_data->itnim)->bfa_itnim)->rport;
  lun_list = (unsigned int )bfa->modules.dconf_mod.min_cfg == 0U ? ((unsigned int )bfa->modules.dconf_mod.min_cfg == 0U ? (struct bfa_lun_mask_s *)(& (bfa->modules.dconf_mod.dconf)->lun_mask.lun_list) : (struct bfa_lun_mask_s *)0) : (struct bfa_lun_mask_s *)0;
  i = 0;
  ret = -6;
  i = 0;
  goto ldv_48674;
  ldv_48673: ;
  if ((unsigned int )(lun_list + (unsigned long )i)->state == 1U) {
    tmp = scsilun_to_int(& (lun_list + (unsigned long )i)->lun);
    if (tmp == sdev->lun) {
      if ((int )(lun_list + (unsigned long )i)->rp_tag == (int )bfa_rport->rport_tag) {
        if ((int )(lun_list + (unsigned long )i)->lp_tag == (int )bfa_rport->rport_info.lp_tag) {
          ret = 0;
          goto ldv_48672;
        } else {

        }
      } else {

      }
    } else {

    }
  } else {

  }
  i = i + 1;
  ldv_48674: ;
  if (i <= 15) {
    goto ldv_48673;
  } else {

  }
  ldv_48672: ;
  return (ret);
}
}
static int bfad_im_slave_alloc(struct scsi_device *sdev ) 
{ 
  struct fc_rport *rport ;
  struct device  const  *__mptr ;
  struct scsi_target *tmp___1 ;
  struct fc_rport *tmp___2 ;
  struct scsi_target *tmp___3 ;
  int tmp___4 ;
  struct bfad_itnim_data_s *itnim_data ;
  struct bfa_s *bfa ;
  int tmp___5 ;
  int tmp___6 ;
    klee_make_symbolic(&tmp___6, sizeof(int), "tmp___6");

  {
  tmp___3 = scsi_target(sdev);
  tmp___4 = scsi_is_fc_rport((struct device  const  *)tmp___3->dev.parent);
  if (tmp___4 != 0) {
    tmp___1 = scsi_target(sdev);
    __mptr = (struct device  const  *)tmp___1->dev.parent;
    tmp___2 = (struct fc_rport *)__mptr + 0xffffffffffffffa0UL;
  } else {
    tmp___2 = (struct fc_rport *)0;
  }
  rport = tmp___2;
  if ((unsigned long )rport == (unsigned long )((struct fc_rport *)0)) {
    return (-6);
  } else {
    tmp___5 = fc_remote_port_chkready(rport);
    if (tmp___5 != 0) {
      return (-6);
    } else {

    }
  }
  itnim_data = (struct bfad_itnim_data_s *)rport->dd_data;
  bfa = ((itnim_data->itnim)->bfa_itnim)->bfa;
  if ((unsigned int )bfa->modules.dconf_mod.min_cfg == 0U && ((unsigned int )bfa->modules.dconf_mod.min_cfg == 0U ? & (bfa->modules.dconf_mod.dconf)->lun_mask : (struct bfa_lunmask_cfg_s *)0)->status == 1U) {
    if (sdev->lun == 0ULL) {
      sdev->sdev_bflags = sdev->sdev_bflags | 262208U;
      goto done;
    } else {

    }
    tmp___6 = bfad_im_check_if_make_lun_visible(sdev, rport);
    if (tmp___6 != 0) {
      return (-6);
    } else {

    }
  } else {

  }
  done: 
  sdev->hostdata = rport->dd_data;
  return (0);
}
}
u32 bfad_im_supported_speeds(struct bfa_s *bfa ) 
{ 
  struct bfa_ioc_attr_s *ioc_attr ;
  u32 supported_speed ;
  void *tmp ;

  {
  supported_speed = 0U;
  tmp = kzalloc(1624UL, 208U);
  ioc_attr = (struct bfa_ioc_attr_s *)tmp;
  if ((unsigned long )ioc_attr == (unsigned long )((struct bfa_ioc_attr_s *)0)) {
    return (0U);
  } else {

  }
  bfa_ioc_get_attr(& bfa->ioc, ioc_attr);
  if ((unsigned int )ioc_attr->adapter_attr.max_speed == 16U) {
    supported_speed = supported_speed | 58U;
  } else
  if ((unsigned int )ioc_attr->adapter_attr.max_speed == 8U) {
    if ((unsigned int )ioc_attr->adapter_attr.is_mezz != 0U) {
      supported_speed = supported_speed | 27U;
    } else {
      supported_speed = supported_speed | 26U;
    }
  } else
  if ((unsigned int )ioc_attr->adapter_attr.max_speed == 4U) {
    supported_speed = supported_speed | 11U;
  } else
  if ((unsigned int )ioc_attr->adapter_attr.max_speed == 10U) {
    supported_speed = supported_speed | 4U;
  } else {

  }
  kfree((void const   *)ioc_attr);
  return (supported_speed);
}
}
void bfad_fc_host_init(struct bfad_im_port_s *im_port ) 
{ 
  struct Scsi_Host *host ;
  struct bfad_s *bfad ;
  struct bfad_port_s *port ;
  char symname[128U] ;
  struct bfa_fcport_s *fcport ;
  __u64 tmp ;
  __u64 tmp___0 ;
  u32 tmp___1 ;

  {
  host = im_port->shost;
  bfad = im_port->bfad;
  port = im_port->port;
  fcport = & bfad->bfa.modules.fcport;
  tmp = __fswab64((port->fcs_port)->port_cfg.nwwn);
  ((struct fc_host_attrs *)host->shost_data)->node_name = tmp;
  tmp___0 = __fswab64((port->fcs_port)->port_cfg.pwwn);
  ((struct fc_host_attrs *)host->shost_data)->port_name = tmp___0;
  tmp___1 = bfa_lps_get_max_vport(& bfad->bfa);
  ((struct fc_host_attrs *)host->shost_data)->max_npiv_vports = (u16 )tmp___1;
  ((struct fc_host_attrs *)host->shost_data)->supported_classes = 8U;
  memset((void *)(& ((struct fc_host_attrs *)host->shost_data)->supported_fc4s),
           0, 32UL);
  if (supported_fc4s & 1) {
    ((struct fc_host_attrs *)host->shost_data)->supported_fc4s[2] = 1U;
  } else {

  }
  ((struct fc_host_attrs *)host->shost_data)->supported_fc4s[7] = 1U;
  strlcpy((char *)(& symname), (char const   *)(& bfad->bfa_fcs.fabric.bport.port_cfg.sym_name.symname),
          128UL);
  sprintf((char *)(& ((struct fc_host_attrs *)host->shost_data)->symbolic_name), "%s",
          (char *)(& symname));
  ((struct fc_host_attrs *)host->shost_data)->supported_speeds = bfad_im_supported_speeds(& bfad->bfa);
  ((struct fc_host_attrs *)host->shost_data)->maxframe_size = (u32 )fcport->cfg.maxfrsize;
  return;
}
}
static void bfad_im_fc_rport_add(struct bfad_im_port_s *im_port , struct bfad_itnim_s *itnim ) 
{ 
  struct fc_rport_identifiers rport_ids ;
  struct fc_rport *fc_rport ;
  struct bfad_itnim_data_s *itnim_data ;
  wwn_t tmp ;
  __u64 tmp___0 ;
  wwn_t tmp___1 ;
  __u64 tmp___2 ;
  u32 tmp___3 ;
  u32 tmp___4 ;
  u32 tmp___5 ;
  enum fc_cos tmp___6 ;

  {
  tmp = bfa_fcs_itnim_get_nwwn(& itnim->fcs_itnim);
  tmp___0 = __fswab64(tmp);
  rport_ids.node_name = tmp___0;
  tmp___1 = bfa_fcs_itnim_get_pwwn(& itnim->fcs_itnim);
  tmp___2 = __fswab64(tmp___1);
  rport_ids.port_name = tmp___2;
  tmp___3 = bfa_fcs_itnim_get_fcid(& itnim->fcs_itnim);
  tmp___4 = bfa_fcs_itnim_get_fcid(& itnim->fcs_itnim);
  tmp___5 = bfa_fcs_itnim_get_fcid(& itnim->fcs_itnim);
  rport_ids.port_id = (((tmp___3 & 255U) << 16) | (tmp___4 & 65280U)) | ((tmp___5 & 16711680U) >> 16);
  rport_ids.roles = 0U;
  fc_rport = fc_remote_port_add(im_port->shost, 0, & rport_ids);
  itnim->fc_rport = fc_rport;
  if ((unsigned long )fc_rport == (unsigned long )((struct fc_rport *)0)) {
    return;
  } else {

  }
  fc_rport->maxframe_size = bfa_fcs_itnim_get_maxfrsize(& itnim->fcs_itnim);
  tmp___6 = bfa_fcs_itnim_get_cos(& itnim->fcs_itnim);
  fc_rport->supported_classes = (u32 )tmp___6;
  itnim_data = (struct bfad_itnim_data_s *)fc_rport->dd_data;
  itnim_data->itnim = itnim;
  rport_ids.roles = rport_ids.roles | 1U;
  if (rport_ids.roles != 0U) {
    fc_remote_port_rolechg(fc_rport, rport_ids.roles);
  } else {

  }
  if (fc_rport->scsi_target_id != 4294967295U && fc_rport->scsi_target_id <= 1023U) {
    itnim->scsi_tgt_id = (u16 )fc_rport->scsi_target_id;
  } else {

  }
  itnim->channel = (u16 )fc_rport->channel;
  return;
}
}
static void bfad_im_itnim_work_handler(struct work_struct *work ) 
{ 
  struct bfad_itnim_s *itnim ;
  struct work_struct  const  *__mptr ;
  struct bfad_im_s *im ;
  struct bfad_s *bfad ;
  struct bfad_im_port_s *im_port ;
  unsigned long flags ;
  struct fc_rport *fc_rport ;
  wwn_t wwpn ;
  u32 fcid ;
  char wwpn_str[32U] ;
  char fcid_str[16U] ;
  raw_spinlock_t *tmp ;
  raw_spinlock_t *tmp___0 ;
  wwn_t tmp___1 ;
  u16 tmp___2 ;
  raw_spinlock_t *tmp___3 ;
  u16 tmp___4 ;
  raw_spinlock_t *tmp___5 ;
  int __ret_warn_on ;
  long tmp___6 ;

  {
  __mptr = (struct work_struct  const  *)work;
  itnim = (struct bfad_itnim_s *)__mptr + 0xfffffffffffffef8UL;
  im = itnim->im;
  bfad = im->bfad;
  tmp = spinlock_check(& bfad->bfad_lock);
  flags = _raw_spin_lock_irqsave(tmp);
  im_port = itnim->im_port;
  __bfa_trc(bfad->trcmod, __trc_fileno___0, 1107, (unsigned long long )itnim->state);
  switch ((unsigned int )itnim->state) {
  case 1U: ;
  if ((unsigned long )itnim->fc_rport == (unsigned long )((struct fc_rport *)0)) {
    spin_unlock_irqrestore(& bfad->bfad_lock, flags);
    bfad_im_fc_rport_add(im_port, itnim);
    tmp___0 = spinlock_check(& bfad->bfad_lock);
    flags = _raw_spin_lock_irqsave(tmp___0);
    wwpn = bfa_fcs_itnim_get_pwwn(& itnim->fcs_itnim);
    fcid = bfa_fcs_itnim_get_fcid(& itnim->fcs_itnim);
    wwn2str___0((char *)(& wwpn_str), wwpn);
    fcid2str((char *)(& fcid_str), fcid);
    list_add_tail(& itnim->list_entry, & im_port->itnim_mapped_list);
    if (bfa_log_level == 4 || (int )((signed char )*("\016" + 1)) <= 52) {
      dev_printk("\016", (struct device  const  *)(& (bfad->pcidev)->dev), "ITNIM ONLINE Target: %d:0:%d FCID: %s WWPN: %s\n",
                 (im_port->shost)->host_no, (int )itnim->scsi_tgt_id, (char *)(& fcid_str),
                 (char *)(& wwpn_str));
    } else {

    }
  } else {
    tmp___1 = bfa_fcs_itnim_get_pwwn(& itnim->fcs_itnim);
    printk("\f%s: itnim %llx is already in online state\n", "bfad_im_itnim_work_handler",
           tmp___1);
  }
  goto ldv_48727;
  case 2U: 
  itnim->state = 3;
  if ((unsigned long )itnim->fc_rport != (unsigned long )((struct fc_rport *)0)) {
    fc_rport = itnim->fc_rport;
    ((struct bfad_itnim_data_s *)fc_rport->dd_data)->itnim = (struct bfad_itnim_s *)0;
    itnim->fc_rport = (struct fc_rport *)0;
    if (((im_port->port)->flags & 1) == 0) {
      spin_unlock_irqrestore(& bfad->bfad_lock, flags);
      tmp___2 = bfa_fcpim_path_tov_get(& bfad->bfa);
      fc_rport->dev_loss_tmo = (u32 )((int )tmp___2 + 1);
      fc_remote_port_delete(fc_rport);
      tmp___3 = spinlock_check(& bfad->bfad_lock);
      flags = _raw_spin_lock_irqsave(tmp___3);
    } else {

    }
    wwpn = bfa_fcs_itnim_get_pwwn(& itnim->fcs_itnim);
    fcid = bfa_fcs_itnim_get_fcid(& itnim->fcs_itnim);
    wwn2str___0((char *)(& wwpn_str), wwpn);
    fcid2str((char *)(& fcid_str), fcid);
    list_del(& itnim->list_entry);
    if (bfa_log_level == 4 || (int )((signed char )*("\016" + 1)) <= 52) {
      dev_printk("\016", (struct device  const  *)(& (bfad->pcidev)->dev), "ITNIM OFFLINE Target: %d:0:%d FCID: %s WWPN: %s\n",
                 (im_port->shost)->host_no, (int )itnim->scsi_tgt_id, (char *)(& fcid_str),
                 (char *)(& wwpn_str));
    } else {

    }
  } else {

  }
  goto ldv_48727;
  case 5U: ;
  if ((unsigned long )itnim->fc_rport != (unsigned long )((struct fc_rport *)0)) {
    fc_rport = itnim->fc_rport;
    ((struct bfad_itnim_data_s *)fc_rport->dd_data)->itnim = (struct bfad_itnim_s *)0;
    itnim->fc_rport = (struct fc_rport *)0;
    if (((im_port->port)->flags & 1) == 0) {
      spin_unlock_irqrestore(& bfad->bfad_lock, flags);
      tmp___4 = bfa_fcpim_path_tov_get(& bfad->bfa);
      fc_rport->dev_loss_tmo = (u32 )((int )tmp___4 + 1);
      fc_remote_port_delete(fc_rport);
      tmp___5 = spinlock_check(& bfad->bfad_lock);
      flags = _raw_spin_lock_irqsave(tmp___5);
    } else {

    }
    list_del(& itnim->list_entry);
  } else {

  }
  kfree((void const   *)itnim);
  goto ldv_48727;
  default: 
  __ret_warn_on = 1;
  tmp___6 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp___6 != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfad_im.c",
                       1180);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  goto ldv_48727;
  }
  ldv_48727: 
  spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  return;
}
}
static int bfad_im_queuecommand_lck(struct scsi_cmnd *cmnd , void (*done)(struct scsi_cmnd * ) ) 
{ 
  struct bfad_im_port_s *im_port ;
  struct bfad_s *bfad ;
  struct bfad_itnim_data_s *itnim_data ;
  struct bfad_itnim_s *itnim ;
  struct bfa_ioim_s *hal_io ;
  unsigned long flags ;
  int rc ;
  int sg_cnt ;
  struct fc_rport *rport ;
  struct device  const  *__mptr ;
  struct scsi_target *tmp___1 ;
  struct fc_rport *tmp___2 ;
  struct scsi_target *tmp___3 ;
  int tmp___4 ;
  raw_spinlock_t *tmp___5 ;

  {
  im_port = (struct bfad_im_port_s *)((cmnd->device)->host)->hostdata[0];
  bfad = im_port->bfad;
  itnim_data = (struct bfad_itnim_data_s *)(cmnd->device)->hostdata;
  sg_cnt = 0;
  tmp___3 = scsi_target(cmnd->device);
  tmp___4 = scsi_is_fc_rport((struct device  const  *)tmp___3->dev.parent);
  if (tmp___4 != 0) {
    tmp___1 = scsi_target(cmnd->device);
    __mptr = (struct device  const  *)tmp___1->dev.parent;
    tmp___2 = (struct fc_rport *)__mptr + 0xffffffffffffffa0UL;
  } else {
    tmp___2 = (struct fc_rport *)0;
  }
  rport = tmp___2;
  rc = fc_remote_port_chkready(rport);
  if (rc != 0) {
    cmnd->result = rc;
    (*done)(cmnd);
    return (0);
  } else {

  }
  if ((bfad->bfad_flags & 2048U) != 0U) {
    if ((bfad->bfad_flags & 4096U) != 0U) {
      cmnd->result = 65536;
    } else {
      cmnd->result = 851968;
    }
    (*done)(cmnd);
    return (0);
  } else {

  }
  sg_cnt = scsi_dma_map(cmnd);
  if (sg_cnt < 0) {
    return (4181);
  } else {

  }
  cmnd->scsi_done = done;
  tmp___5 = spinlock_check(& bfad->bfad_lock);
  flags = _raw_spin_lock_irqsave(tmp___5);
  if ((bfad->bfad_flags & 16U) == 0U) {
    printk("\fbfad%d, queuecommand %p %x failed, BFA stopped\n", bfad->inst_no, cmnd,
           (int )*(cmnd->cmnd));
    cmnd->result = 65536;
    goto out_fail_cmd;
  } else {

  }
  itnim = itnim_data->itnim;
  if ((unsigned long )itnim == (unsigned long )((struct bfad_itnim_s *)0)) {
    cmnd->result = 786432;
    goto out_fail_cmd;
  } else {

  }
  hal_io = bfa_ioim_alloc(& bfad->bfa, (struct bfad_ioim_s *)cmnd, itnim->bfa_itnim,
                          (int )((u16 )sg_cnt));
  if ((unsigned long )hal_io == (unsigned long )((struct bfa_ioim_s *)0)) {
    printk("\fhal_io failure\n");
    spin_unlock_irqrestore(& bfad->bfad_lock, flags);
    scsi_dma_unmap(cmnd);
    return (4181);
  } else {

  }
  cmnd->host_scribble = (unsigned char *)hal_io;
  bfa_ioim_start(hal_io);
  spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  return (0);
  out_fail_cmd: 
  spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  scsi_dma_unmap(cmnd);
  if ((unsigned long )done != (unsigned long )((void (*)(struct scsi_cmnd * ))0)) {
    (*done)(cmnd);
  } else {

  }
  return (0);
}
}
static int bfad_im_queuecommand(struct Scsi_Host *shost , struct scsi_cmnd *cmd ) 
{ 
  unsigned long irq_flags ;
    klee_make_symbolic(&irq_flags, sizeof(long), "irq_flags");
  int rc ;
  raw_spinlock_t *tmp ;

  {
  tmp = spinlock_check(shost->host_lock);
  irq_flags = _raw_spin_lock_irqsave(tmp);
  scsi_cmd_get_serial(shost, cmd);
  rc = bfad_im_queuecommand_lck(cmd, cmd->scsi_done);
  spin_unlock_irqrestore(shost->host_lock, irq_flags);
  return (rc);
}
}
void bfad_rport_online_wait(struct bfad_s *bfad ) 
{ 
  int i ;
  int rport_delay ;
    klee_make_symbolic(&rport_delay, sizeof(int), "rport_delay");
  struct task_struct *tmp ;
  long volatile   __ret ;
  struct task_struct *tmp___0 ;
  struct task_struct *tmp___1 ;
  struct task_struct *tmp___2 ;
  struct task_struct *tmp___3 ;
  struct task_struct *tmp___4 ;
  long volatile   __ret___0 ;
  struct task_struct *tmp___5 ;
  struct task_struct *tmp___6 ;
  struct task_struct *tmp___7 ;
  struct task_struct *tmp___8 ;
  struct task_struct *tmp___9 ;
  long volatile   __ret___1 ;
  struct task_struct *tmp___10 ;
  struct task_struct *tmp___11 ;
  struct task_struct *tmp___12 ;
  struct task_struct *tmp___13 ;

  {
  rport_delay = 10;
  i = 0;
  goto ldv_48782;
  ldv_48781: 
  tmp = get_current();
  tmp->task_state_change = 0UL;
  __ret = 2L;
  switch (8UL) {
  case 1UL: 
  tmp___0 = get_current();
  __asm__  volatile   ("xchgb %b0, %1\n": "+q" (__ret), "+m" (tmp___0->state): : "memory",
                       "cc");
  goto ldv_48775;
  case 2UL: 
  tmp___1 = get_current();
  __asm__  volatile   ("xchgw %w0, %1\n": "+r" (__ret), "+m" (tmp___1->state): : "memory",
                       "cc");
  goto ldv_48775;
  case 4UL: 
  tmp___2 = get_current();
  __asm__  volatile   ("xchgl %0, %1\n": "+r" (__ret), "+m" (tmp___2->state): : "memory",
                       "cc");
  goto ldv_48775;
  case 8UL: 
  tmp___3 = get_current();
  __asm__  volatile   ("xchgq %q0, %1\n": "+r" (__ret), "+m" (tmp___3->state): : "memory",
                       "cc");
  goto ldv_48775;
  default: 
  __xchg_wrong_size();
  }
  ldv_48775: 
  schedule_timeout(250L);
  i = i + 1;
  ldv_48782: ;
  if ((bfad->bfad_flags & 32U) == 0U && i < bfa_linkup_delay) {
    goto ldv_48781;
  } else {

  }

  if ((bfad->bfad_flags & 32U) != 0U) {
    rport_delay = rport_delay < bfa_linkup_delay ? rport_delay : bfa_linkup_delay;
    i = 0;
    goto ldv_48793;
    ldv_48792: 
    tmp___4 = get_current();
    tmp___4->task_state_change = 0UL;
    __ret___0 = 2L;
    switch (8UL) {
    case 1UL: 
    tmp___5 = get_current();
    __asm__  volatile   ("xchgb %b0, %1\n": "+q" (__ret___0), "+m" (tmp___5->state): : "memory",
                         "cc");
    goto ldv_48786;
    case 2UL: 
    tmp___6 = get_current();
    __asm__  volatile   ("xchgw %w0, %1\n": "+r" (__ret___0), "+m" (tmp___6->state): : "memory",
                         "cc");
    goto ldv_48786;
    case 4UL: 
    tmp___7 = get_current();
    __asm__  volatile   ("xchgl %0, %1\n": "+r" (__ret___0), "+m" (tmp___7->state): : "memory",
                         "cc");
    goto ldv_48786;
    case 8UL: 
    tmp___8 = get_current();
    __asm__  volatile   ("xchgq %q0, %1\n": "+r" (__ret___0), "+m" (tmp___8->state): : "memory",
                         "cc");
    goto ldv_48786;
    default: 
    __xchg_wrong_size();
    }
    ldv_48786: 
    schedule_timeout(250L);
    i = i + 1;
    ldv_48793: ;
    if ((bfad->bfad_flags & 64U) == 0U && i < rport_delay) {
      goto ldv_48792;
    } else {

    }

    if (rport_delay > 0 && (bfad->bfad_flags & 64U) != 0U) {
      tmp___9 = get_current();
      tmp___9->task_state_change = 0UL;
      __ret___1 = 2L;
      switch (8UL) {
      case 1UL: 
      tmp___10 = get_current();
      __asm__  volatile   ("xchgb %b0, %1\n": "+q" (__ret___1), "+m" (tmp___10->state): : "memory",
                           "cc");
      goto ldv_48797;
      case 2UL: 
      tmp___11 = get_current();
      __asm__  volatile   ("xchgw %w0, %1\n": "+r" (__ret___1), "+m" (tmp___11->state): : "memory",
                           "cc");
      goto ldv_48797;
      case 4UL: 
      tmp___12 = get_current();
      __asm__  volatile   ("xchgl %0, %1\n": "+r" (__ret___1), "+m" (tmp___12->state): : "memory",
                           "cc");
      goto ldv_48797;
      case 8UL: 
      tmp___13 = get_current();
      __asm__  volatile   ("xchgq %q0, %1\n": "+r" (__ret___1), "+m" (tmp___13->state): : "memory",
                           "cc");
      goto ldv_48797;
      default: 
      __xchg_wrong_size();
      }
      ldv_48797: 
      schedule_timeout((long )(rport_delay * 250));
    } else {

    }
  } else {

  }
  return;
}
}
int bfad_get_linkup_delay(struct bfad_s *bfad ) 
{ 
  u8 nwwns ;
  wwn_t wwns[8U] ;
  int linkup_delay ;
    klee_make_symbolic(&linkup_delay, sizeof(int), "linkup_delay");

  {
  nwwns = 0U;
  bfa_iocfc_get_bootwwns(& bfad->bfa, & nwwns, (wwn_t *)(& wwns));
  if ((unsigned int )nwwns != 0U) {
    linkup_delay = 30;
  } else {
    linkup_delay = 0;
  }
  return (linkup_delay);
}
}
void activate_work_5(struct work_struct *work , int state ) 
{ 


  {
  if (ldv_work_5_0 == 0) {
    ldv_work_struct_5_0 = work;
    ldv_work_5_0 = state;
    return;
  } else {

  }
  if (ldv_work_5_1 == 0) {
    ldv_work_struct_5_1 = work;
    ldv_work_5_1 = state;
    return;
  } else {

  }
  if (ldv_work_5_2 == 0) {
    ldv_work_struct_5_2 = work;
    ldv_work_5_2 = state;
    return;
  } else {

  }
  if (ldv_work_5_3 == 0) {
    ldv_work_struct_5_3 = work;
    ldv_work_5_3 = state;
    return;
  } else {

  }
  return;
}
}
void work_init_3(void) 
{ 


  {
  ldv_work_3_0 = 0;
  ldv_work_3_1 = 0;
  ldv_work_3_2 = 0;
  ldv_work_3_3 = 0;
  return;
}
}
void ldv_initialize_scsi_host_template_36(void) 
{ 
  void *tmp___0 ;

  {
  bfad_im_scsi_host_template_group0 = ldv_malloc(sizeof(struct scsi_cmnd));
  tmp___0 = ldv_init_zalloc(3816UL);
  bfad_im_scsi_host_template_group1 = (struct Scsi_Host *)tmp___0;
  bfad_im_scsi_host_template_group2 = ldv_malloc(sizeof(struct scsi_device));
  return;
}
}
void activate_work_3(struct work_struct *work , int state ) 
{ 


  {
  if (ldv_work_3_0 == 0) {
    ldv_work_struct_3_0 = work;
    ldv_work_3_0 = state;
    return;
  } else {

  }
  if (ldv_work_3_1 == 0) {
    ldv_work_struct_3_1 = work;
    ldv_work_3_1 = state;
    return;
  } else {

  }
  if (ldv_work_3_2 == 0) {
    ldv_work_struct_3_2 = work;
    ldv_work_3_2 = state;
    return;
  } else {

  }
  if (ldv_work_3_3 == 0) {
    ldv_work_struct_3_3 = work;
    ldv_work_3_3 = state;
    return;
  } else {

  }
  return;
}
}
void work_init_5(void) 
{ 


  {
  ldv_work_5_0 = 0;
  ldv_work_5_1 = 0;
  ldv_work_5_2 = 0;
  ldv_work_5_3 = 0;
  return;
}
}
void call_and_disable_all_4(int state ) 
{ 


  {
  if (ldv_work_4_0 == state) {
    call_and_disable_work_4(ldv_work_struct_4_0);
  } else {

  }
  if (ldv_work_4_1 == state) {
    call_and_disable_work_4(ldv_work_struct_4_1);
  } else {

  }
  if (ldv_work_4_2 == state) {
    call_and_disable_work_4(ldv_work_struct_4_2);
  } else {

  }
  if (ldv_work_4_3 == state) {
    call_and_disable_work_4(ldv_work_struct_4_3);
  } else {

  }
  return;
}
}
void disable_work_5(struct work_struct *work ) 
{ 


  {
  if ((ldv_work_5_0 == 3 || ldv_work_5_0 == 2) && (unsigned long )ldv_work_struct_5_0 == (unsigned long )work) {
    ldv_work_5_0 = 1;
  } else {

  }
  if ((ldv_work_5_1 == 3 || ldv_work_5_1 == 2) && (unsigned long )ldv_work_struct_5_1 == (unsigned long )work) {
    ldv_work_5_1 = 1;
  } else {

  }
  if ((ldv_work_5_2 == 3 || ldv_work_5_2 == 2) && (unsigned long )ldv_work_struct_5_2 == (unsigned long )work) {
    ldv_work_5_2 = 1;
  } else {

  }
  if ((ldv_work_5_3 == 3 || ldv_work_5_3 == 2) && (unsigned long )ldv_work_struct_5_3 == (unsigned long )work) {
    ldv_work_5_3 = 1;
  } else {

  }
  return;
}
}
void call_and_disable_work_3(struct work_struct *work ) 
{ 


  {
  if ((ldv_work_3_0 == 2 || ldv_work_3_0 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_3_0) {
    bfad_im_itnim_work_handler(work);
    ldv_work_3_0 = 1;
    return;
  } else {

  }
  if ((ldv_work_3_1 == 2 || ldv_work_3_1 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_3_1) {
    bfad_im_itnim_work_handler(work);
    ldv_work_3_1 = 1;
    return;
  } else {

  }
  if ((ldv_work_3_2 == 2 || ldv_work_3_2 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_3_2) {
    bfad_im_itnim_work_handler(work);
    ldv_work_3_2 = 1;
    return;
  } else {

  }
  if ((ldv_work_3_3 == 2 || ldv_work_3_3 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_3_3) {
    bfad_im_itnim_work_handler(work);
    ldv_work_3_3 = 1;
    return;
  } else {

  }
  return;
}
}
void disable_work_3(struct work_struct *work ) 
{ 


  {
  if ((ldv_work_3_0 == 3 || ldv_work_3_0 == 2) && (unsigned long )ldv_work_struct_3_0 == (unsigned long )work) {
    ldv_work_3_0 = 1;
  } else {

  }
  if ((ldv_work_3_1 == 3 || ldv_work_3_1 == 2) && (unsigned long )ldv_work_struct_3_1 == (unsigned long )work) {
    ldv_work_3_1 = 1;
  } else {

  }
  if ((ldv_work_3_2 == 3 || ldv_work_3_2 == 2) && (unsigned long )ldv_work_struct_3_2 == (unsigned long )work) {
    ldv_work_3_2 = 1;
  } else {

  }
  if ((ldv_work_3_3 == 3 || ldv_work_3_3 == 2) && (unsigned long )ldv_work_struct_3_3 == (unsigned long )work) {
    ldv_work_3_3 = 1;
  } else {

  }
  return;
}
}
void invoke_work_4(void) 
{ 
  int tmp ;

  {
  tmp = __VERIFIER_nondet_int();
  switch (tmp) {
  case 0: ;
  if (ldv_work_4_0 == 2 || ldv_work_4_0 == 3) {
    ldv_work_4_0 = 4;
    bfad_im_port_delete_handler(ldv_work_struct_4_0);
    ldv_work_4_0 = 1;
  } else {

  }
  goto ldv_48846;
  case 1: ;
  if (ldv_work_4_1 == 2 || ldv_work_4_1 == 3) {
    ldv_work_4_1 = 4;
    bfad_im_port_delete_handler(ldv_work_struct_4_0);
    ldv_work_4_1 = 1;
  } else {

  }
  goto ldv_48846;
  case 2: ;
  if (ldv_work_4_2 == 2 || ldv_work_4_2 == 3) {
    ldv_work_4_2 = 4;
    bfad_im_port_delete_handler(ldv_work_struct_4_0);
    ldv_work_4_2 = 1;
  } else {

  }
  goto ldv_48846;
  case 3: ;
  if (ldv_work_4_3 == 2 || ldv_work_4_3 == 3) {
    ldv_work_4_3 = 4;
    bfad_im_port_delete_handler(ldv_work_struct_4_0);
    ldv_work_4_3 = 1;
  } else {

  }
  goto ldv_48846;
  default: 
  ldv_stop();
  }
  ldv_48846: ;
  return;
}
}
void call_and_disable_work_5(struct work_struct *work ) 
{ 


  {
  if ((ldv_work_5_0 == 2 || ldv_work_5_0 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_5_0) {
    bfad_aen_im_notify_handler(work);
    ldv_work_5_0 = 1;
    return;
  } else {

  }
  if ((ldv_work_5_1 == 2 || ldv_work_5_1 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_5_1) {
    bfad_aen_im_notify_handler(work);
    ldv_work_5_1 = 1;
    return;
  } else {

  }
  if ((ldv_work_5_2 == 2 || ldv_work_5_2 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_5_2) {
    bfad_aen_im_notify_handler(work);
    ldv_work_5_2 = 1;
    return;
  } else {

  }
  if ((ldv_work_5_3 == 2 || ldv_work_5_3 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_5_3) {
    bfad_aen_im_notify_handler(work);
    ldv_work_5_3 = 1;
    return;
  } else {

  }
  return;
}
}
void ldv_initialize_scsi_host_template_35(void) 
{ 
  void *tmp___0 ;

  {
  bfad_im_vport_template_group0 = ldv_malloc(sizeof(struct scsi_cmnd));
  tmp___0 = ldv_init_zalloc(3816UL);
  bfad_im_vport_template_group1 = (struct Scsi_Host *)tmp___0;
  bfad_im_vport_template_group2 = ldv_malloc(sizeof(struct scsi_device));
  return;
}
}
void activate_work_4(struct work_struct *work , int state ) 
{ 


  {
  if (ldv_work_4_0 == 0) {
    ldv_work_struct_4_0 = work;
    ldv_work_4_0 = state;
    return;
  } else {

  }
  if (ldv_work_4_1 == 0) {
    ldv_work_struct_4_1 = work;
    ldv_work_4_1 = state;
    return;
  } else {

  }
  if (ldv_work_4_2 == 0) {
    ldv_work_struct_4_2 = work;
    ldv_work_4_2 = state;
    return;
  } else {

  }
  if (ldv_work_4_3 == 0) {
    ldv_work_struct_4_3 = work;
    ldv_work_4_3 = state;
    return;
  } else {

  }
  return;
}
}
void call_and_disable_all_5(int state ) 
{ 


  {
  if (ldv_work_5_0 == state) {
    call_and_disable_work_5(ldv_work_struct_5_0);
  } else {

  }
  if (ldv_work_5_1 == state) {
    call_and_disable_work_5(ldv_work_struct_5_1);
  } else {

  }
  if (ldv_work_5_2 == state) {
    call_and_disable_work_5(ldv_work_struct_5_2);
  } else {

  }
  if (ldv_work_5_3 == state) {
    call_and_disable_work_5(ldv_work_struct_5_3);
  } else {

  }
  return;
}
}
void invoke_work_5(void) 
{ 
  int tmp ;

  {
  tmp = __VERIFIER_nondet_int();
  switch (tmp) {
  case 0: ;
  if (ldv_work_5_0 == 2 || ldv_work_5_0 == 3) {
    ldv_work_5_0 = 4;
    bfad_aen_im_notify_handler(ldv_work_struct_5_0);
    ldv_work_5_0 = 1;
  } else {

  }
  goto ldv_48872;
  case 1: ;
  if (ldv_work_5_1 == 2 || ldv_work_5_1 == 3) {
    ldv_work_5_1 = 4;
    bfad_aen_im_notify_handler(ldv_work_struct_5_0);
    ldv_work_5_1 = 1;
  } else {

  }
  goto ldv_48872;
  case 2: ;
  if (ldv_work_5_2 == 2 || ldv_work_5_2 == 3) {
    ldv_work_5_2 = 4;
    bfad_aen_im_notify_handler(ldv_work_struct_5_0);
    ldv_work_5_2 = 1;
  } else {

  }
  goto ldv_48872;
  case 3: ;
  if (ldv_work_5_3 == 2 || ldv_work_5_3 == 3) {
    ldv_work_5_3 = 4;
    bfad_aen_im_notify_handler(ldv_work_struct_5_0);
    ldv_work_5_3 = 1;
  } else {

  }
  goto ldv_48872;
  default: 
  ldv_stop();
  }
  ldv_48872: ;
  return;
}
}
void disable_work_4(struct work_struct *work ) 
{ 


  {
  if ((ldv_work_4_0 == 3 || ldv_work_4_0 == 2) && (unsigned long )ldv_work_struct_4_0 == (unsigned long )work) {
    ldv_work_4_0 = 1;
  } else {

  }
  if ((ldv_work_4_1 == 3 || ldv_work_4_1 == 2) && (unsigned long )ldv_work_struct_4_1 == (unsigned long )work) {
    ldv_work_4_1 = 1;
  } else {

  }
  if ((ldv_work_4_2 == 3 || ldv_work_4_2 == 2) && (unsigned long )ldv_work_struct_4_2 == (unsigned long )work) {
    ldv_work_4_2 = 1;
  } else {

  }
  if ((ldv_work_4_3 == 3 || ldv_work_4_3 == 2) && (unsigned long )ldv_work_struct_4_3 == (unsigned long )work) {
    ldv_work_4_3 = 1;
  } else {

  }
  return;
}
}
void work_init_4(void) 
{ 


  {
  ldv_work_4_0 = 0;
  ldv_work_4_1 = 0;
  ldv_work_4_2 = 0;
  ldv_work_4_3 = 0;
  return;
}
}
void invoke_work_3(void) 
{ 
  int tmp ;

  {
  tmp = __VERIFIER_nondet_int();
  switch (tmp) {
  case 0: ;
  if (ldv_work_3_0 == 2 || ldv_work_3_0 == 3) {
    ldv_work_3_0 = 4;
    bfad_im_itnim_work_handler(ldv_work_struct_3_0);
    ldv_work_3_0 = 1;
  } else {

  }
  goto ldv_48889;
  case 1: ;
  if (ldv_work_3_1 == 2 || ldv_work_3_1 == 3) {
    ldv_work_3_1 = 4;
    bfad_im_itnim_work_handler(ldv_work_struct_3_0);
    ldv_work_3_1 = 1;
  } else {

  }
  goto ldv_48889;
  case 2: ;
  if (ldv_work_3_2 == 2 || ldv_work_3_2 == 3) {
    ldv_work_3_2 = 4;
    bfad_im_itnim_work_handler(ldv_work_struct_3_0);
    ldv_work_3_2 = 1;
  } else {

  }
  goto ldv_48889;
  case 3: ;
  if (ldv_work_3_3 == 2 || ldv_work_3_3 == 3) {
    ldv_work_3_3 = 4;
    bfad_im_itnim_work_handler(ldv_work_struct_3_0);
    ldv_work_3_3 = 1;
  } else {

  }
  goto ldv_48889;
  default: 
  ldv_stop();
  }
  ldv_48889: ;
  return;
}
}
void call_and_disable_all_3(int state ) 
{ 


  {
  if (ldv_work_3_0 == state) {
    call_and_disable_work_3(ldv_work_struct_3_0);
  } else {

  }
  if (ldv_work_3_1 == state) {
    call_and_disable_work_3(ldv_work_struct_3_1);
  } else {

  }
  if (ldv_work_3_2 == state) {
    call_and_disable_work_3(ldv_work_struct_3_2);
  } else {

  }
  if (ldv_work_3_3 == state) {
    call_and_disable_work_3(ldv_work_struct_3_3);
  } else {

  }
  return;
}
}
void call_and_disable_work_4(struct work_struct *work ) 
{ 


  {
  if ((ldv_work_4_0 == 2 || ldv_work_4_0 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_4_0) {
    bfad_im_port_delete_handler(work);
    ldv_work_4_0 = 1;
    return;
  } else {

  }
  if ((ldv_work_4_1 == 2 || ldv_work_4_1 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_4_1) {
    bfad_im_port_delete_handler(work);
    ldv_work_4_1 = 1;
    return;
  } else {

  }
  if ((ldv_work_4_2 == 2 || ldv_work_4_2 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_4_2) {
    bfad_im_port_delete_handler(work);
    ldv_work_4_2 = 1;
    return;
  } else {

  }
  if ((ldv_work_4_3 == 2 || ldv_work_4_3 == 3) && (unsigned long )work == (unsigned long )ldv_work_struct_4_3) {
    bfad_im_port_delete_handler(work);
    ldv_work_4_3 = 1;
    return;
  } else {

  }
  return;
}
}
void ldv_main_exported_35(void) 
{ 
  int tmp ;

  {
  tmp = __VERIFIER_nondet_int();
  switch (tmp) {
  case 0: ;
  if (ldv_state_variable_35 == 1) {
    bfad_im_slave_configure(bfad_im_vport_template_group2);
    ldv_state_variable_35 = 1;
  } else {

  }
  goto ldv_48906;
  case 1: ;
  if (ldv_state_variable_35 == 1) {
    bfad_im_queuecommand(bfad_im_vport_template_group1, bfad_im_vport_template_group0);
    ldv_state_variable_35 = 1;
  } else {

  }
  goto ldv_48906;
  case 2: ;
  if (ldv_state_variable_35 == 1) {
    bfad_im_reset_lun_handler(bfad_im_vport_template_group0);
    ldv_state_variable_35 = 1;
  } else {

  }
  goto ldv_48906;
  case 3: ;
  if (ldv_state_variable_35 == 1) {
    bfad_im_abort_handler(bfad_im_vport_template_group0);
    ldv_state_variable_35 = 1;
  } else {

  }
  goto ldv_48906;
  case 4: ;
  if (ldv_state_variable_35 == 1) {
    bfad_im_slave_alloc(bfad_im_vport_template_group2);
    ldv_state_variable_35 = 1;
  } else {

  }
  goto ldv_48906;
  case 5: ;
  if (ldv_state_variable_35 == 1) {
    bfad_im_slave_destroy(bfad_im_vport_template_group2);
    ldv_state_variable_35 = 1;
  } else {

  }
  goto ldv_48906;
  case 6: ;
  if (ldv_state_variable_35 == 1) {
    bfad_im_reset_bus_handler(bfad_im_vport_template_group0);
    ldv_state_variable_35 = 1;
  } else {

  }
  goto ldv_48906;
  case 7: ;
  if (ldv_state_variable_35 == 1) {
    bfad_im_info(bfad_im_vport_template_group1);
    ldv_state_variable_35 = 1;
  } else {

  }
  goto ldv_48906;
  default: 
  ldv_stop();
  }
  ldv_48906: ;
  return;
}
}
void ldv_main_exported_36(void) 
{ 
  int tmp ;

  {
  tmp = __VERIFIER_nondet_int();
  switch (tmp) {
  case 0: ;
  if (ldv_state_variable_36 == 1) {
    bfad_im_slave_configure(bfad_im_scsi_host_template_group2);
    ldv_state_variable_36 = 1;
  } else {

  }
  goto ldv_48919;
  case 1: ;
  if (ldv_state_variable_36 == 1) {
    bfad_im_queuecommand(bfad_im_scsi_host_template_group1, bfad_im_scsi_host_template_group0);
    ldv_state_variable_36 = 1;
  } else {

  }
  goto ldv_48919;
  case 2: ;
  if (ldv_state_variable_36 == 1) {
    bfad_im_reset_lun_handler(bfad_im_scsi_host_template_group0);
    ldv_state_variable_36 = 1;
  } else {

  }
  goto ldv_48919;
  case 3: ;
  if (ldv_state_variable_36 == 1) {
    bfad_im_abort_handler(bfad_im_scsi_host_template_group0);
    ldv_state_variable_36 = 1;
  } else {

  }
  goto ldv_48919;
  case 4: ;
  if (ldv_state_variable_36 == 1) {
    bfad_im_slave_alloc(bfad_im_scsi_host_template_group2);
    ldv_state_variable_36 = 1;
  } else {

  }
  goto ldv_48919;
  case 5: ;
  if (ldv_state_variable_36 == 1) {
    bfad_im_slave_destroy(bfad_im_scsi_host_template_group2);
    ldv_state_variable_36 = 1;
  } else {

  }
  goto ldv_48919;
  case 6: ;
  if (ldv_state_variable_36 == 1) {
    bfad_im_reset_bus_handler(bfad_im_scsi_host_template_group0);
    ldv_state_variable_36 = 1;
  } else {

  }
  goto ldv_48919;
  case 7: ;
  if (ldv_state_variable_36 == 1) {
    bfad_im_info(bfad_im_scsi_host_template_group1);
    ldv_state_variable_36 = 1;
  } else {

  }
  goto ldv_48919;
  default: 
  ldv_stop();
  }
  ldv_48919: ;
  return;
}
}
bool ldv_queue_work_on_79(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_3(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_delayed_work_on_80(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_3(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_work_on_81(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                          struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_3(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
void ldv_flush_workqueue_82(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
  flush_workqueue(ldv_func_arg1);
  call_and_disable_all_3(2);
  return;
}
}
bool ldv_queue_delayed_work_on_83(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                  struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_3(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
void ldv_mutex_lock_84(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_lock_lock(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_85(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_unlock_lock(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_86(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
int ldv_mutex_trylock_87(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
  tmp = mutex_trylock(ldv_func_arg1);
  ldv_func_res = tmp;
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
  return (tmp___0);
  return (ldv_func_res);
}
}
void ldv_mutex_unlock_88(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_89(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_unlock_i_mutex_of_inode(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_90(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_lock_i_mutex_of_inode(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
int ldv_scsi_add_host_with_dma_91(struct Scsi_Host *shost , struct device *dev , struct device *dma_dev ) 
{ 
  ldv_func_ret_type___4 ldv_func_res ;
  int tmp ;

  {
  tmp = scsi_add_host_with_dma(shost, dev, dma_dev);
  ldv_func_res = tmp;
  if (ldv_func_res == 0) {
    ldv_state_variable_35 = 1;
    ldv_initialize_scsi_host_template_35();
  } else {

  }
  return (ldv_func_res);
}
}
void ldv_mutex_lock_92(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_lock_bfad_mutex(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_93(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_unlock_bfad_mutex(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_94(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_unlock_bfad_mutex(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
int ldv_scsi_add_host_with_dma_95(struct Scsi_Host *shost , struct device *dev , struct device *dma_dev ) 
{ 
  ldv_func_ret_type___5 ldv_func_res ;
  int tmp ;

  {
  tmp = scsi_add_host_with_dma(shost, dev, dma_dev);
  ldv_func_res = tmp;
  if (ldv_func_res == 0) {
    ldv_state_variable_35 = 1;
    ldv_initialize_scsi_host_template_35();
  } else {

  }
  return (ldv_func_res);
}
}
void ldv_mutex_lock_96(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_lock_bfad_mutex(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_97(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_unlock_bfad_mutex(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_scsi_remove_host_98(struct Scsi_Host *shost ) 
{ 


  {
  scsi_remove_host(shost);
  ldv_state_variable_35 = 0;
  return;
}
}
void ldv_mutex_lock_99(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_lock_bfad_mutex(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_100(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_unlock_bfad_mutex(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
struct Scsi_Host *ldv_scsi_host_alloc_101(struct scsi_host_template *sht , int privsize ) 
{ 
  ldv_func_ret_type___16 ldv_func_res ;
  struct Scsi_Host *tmp ;

  {
  tmp = scsi_host_alloc(sht, privsize);
  ldv_func_res = tmp;
  if ((unsigned long )ldv_func_res != (unsigned long )((ldv_func_ret_type___16 )0)) {
    ldv_state_variable_35 = 1;
    ldv_initialize_scsi_host_template_35();
  } else {

  }
  return (ldv_func_res);
}
}
void ldv_flush_workqueue_102(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
  flush_workqueue(ldv_func_arg1);
  call_and_disable_all_3(2);
  return;
}
}
void ldv_flush_workqueue_103(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
  flush_workqueue(ldv_func_arg1);
  call_and_disable_all_3(2);
  return;
}
}
void ldv_destroy_workqueue_104(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
  destroy_workqueue(ldv_func_arg1);
  call_and_disable_all_3(2);
  return;
}
}
extern size_t strlen(char const   * ) ;
extern char *strcpy(char * , char const   * ) ;
extern char *strstr(char const   * , char const   * ) ;
int ldv_mutex_trylock_143(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_141(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_144(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_145(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_140(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_142(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_146(struct mutex *ldv_func_arg1 ) ;
bool ldv_queue_work_on_135(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_work_on_137(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_delayed_work_on_136(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
bool ldv_queue_delayed_work_on_139(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
void ldv_flush_workqueue_138(struct workqueue_struct *ldv_func_arg1 ) ;
extern int scsi_is_host_device(struct device  const  * ) ;
__inline static struct Scsi_Host *dev_to_shost(struct device *dev ) 
{ 
  int tmp ;
  struct device  const  *__mptr ;

  {
  goto ldv_35671;
  ldv_35670: ;
  if ((unsigned long )dev->parent == (unsigned long )((struct device *)0)) {
    return ((struct Scsi_Host *)0);
  } else {

  }
  dev = dev->parent;
  ldv_35671: 
  tmp = scsi_is_host_device((struct device  const  *)dev);
  if (tmp == 0) {
    goto ldv_35670;
  } else {

  }
  __mptr = (struct device  const  *)dev;
  return ((struct Scsi_Host *)__mptr + 0xfffffffffffffc48UL);
}
}
int ldv_scsi_add_host_with_dma_147(struct Scsi_Host *shost , struct device *dev ,
                                   struct device *dma_dev ) ;
__inline static void u64_to_wwn(u64 inm , u8 *wwn ) 
{ 


  {
  *wwn = (u8 )(inm >> 56);
  *(wwn + 1UL) = (u8 )(inm >> 48);
  *(wwn + 2UL) = (u8 )(inm >> 40);
  *(wwn + 3UL) = (u8 )(inm >> 32);
  *(wwn + 4UL) = (u8 )(inm >> 24);
  *(wwn + 5UL) = (u8 )(inm >> 16);
  *(wwn + 6UL) = (u8 )(inm >> 8);
  *(wwn + 7UL) = (u8 )inm;
  return;
}
}
__inline static void fc_vport_set_state(struct fc_vport *vport , enum fc_vport_state new_state ) 
{ 


  {
  if ((unsigned int )new_state != 0U && (unsigned int )new_state != 4U) {
    vport->vport_last_state = vport->vport_state;
  } else {

  }
  vport->vport_state = new_state;
  return;
}
}
enum bfa_ioc_type_e bfa_ioc_get_type(struct bfa_ioc_s *ioc ) ;
void bfa_ioc_get_adapter_serial_num(struct bfa_ioc_s *ioc , char *serial_num ) ;
void bfa_ioc_get_adapter_fw_ver(struct bfa_ioc_s *ioc , char *fw_ver ) ;
void bfa_ioc_get_adapter_optrom_ver(struct bfa_ioc_s *ioc , char *optrom_ver ) ;
void bfa_ioc_get_adapter_model(struct bfa_ioc_s *ioc , char *model ) ;
void bfa_ioc_get_pci_chip_rev(struct bfa_ioc_s *ioc , char *chip_rev ) ;
u16 bfa_fcport_get_maxfrsize(struct bfa_s *bfa ) ;
void bfa_fcport_get_attr(struct bfa_s *bfa , struct bfa_port_attr_s *attr ) ;
enum bfa_status bfa_port_get_stats(struct bfa_port_s *port , union bfa_port_stats_u *stats ,
                                   void (*cbfn)(void * , enum bfa_status  ) , void *cbarg ) ;
enum bfa_status bfa_port_clear_stats(struct bfa_port_s *port , void (*cbfn)(void * ,
                                                                            enum bfa_status  ) ,
                                     void *cbarg ) ;
enum bfa_status bfa_port_enable(struct bfa_port_s *port , void (*cbfn)(void * , enum bfa_status  ) ,
                                void *cbarg ) ;
enum bfa_status bfa_port_disable(struct bfa_port_s *port , void (*cbfn)(void * , enum bfa_status  ) ,
                                 void *cbarg ) ;
void bfa_fcs_lport_get_rport_quals(struct bfa_fcs_lport_s *port , struct bfa_rport_qualifier_s *rports ,
                                   int *nrports ) ;
void bfa_fcs_lport_set_symname(struct bfa_fcs_lport_s *port , char *symname ) ;
void bfa_fcs_lport_get_attr(struct bfa_fcs_lport_s *port , struct bfa_lport_attr_s *port_attr ) ;
enum bfa_status bfa_fcs_vport_stop(struct bfa_fcs_vport_s *vport ) ;
struct bfa_fcs_vport_s *bfa_fcs_vport_lookup(struct bfa_fcs_s *fcs , u16 vf_id , wwn_t vpwwn ) ;
int bfad_im_bsg_request(struct fc_bsg_job *job ) ;
int bfad_im_bsg_timeout(struct fc_bsg_job *job ) ;
static void bfad_im_get_starget_port_id(struct scsi_target *starget ) 
{ 
  struct Scsi_Host *shost ;
  struct bfad_im_port_s *im_port ;
  struct bfad_s *bfad ;
  struct bfad_itnim_s *itnim ;
  u32 fc_id ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;

  {
  itnim = (struct bfad_itnim_s *)0;
  fc_id = 4294967295U;
  shost = dev_to_shost(starget->dev.parent);
  im_port = (struct bfad_im_port_s *)shost->hostdata[0];
  bfad = im_port->bfad;
  tmp = spinlock_check(& bfad->bfad_lock);
  flags = _raw_spin_lock_irqsave(tmp);
  itnim = bfad_get_itnim(im_port, (int )starget->id);
  if ((unsigned long )itnim != (unsigned long )((struct bfad_itnim_s *)0)) {
    fc_id = bfa_fcs_itnim_get_fcid(& itnim->fcs_itnim);
  } else {

  }
  ((struct fc_starget_attrs *)(& starget->starget_data))->port_id = fc_id;
  spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  return;
}
}
static void bfad_im_get_starget_node_name(struct scsi_target *starget ) 
{ 
  struct Scsi_Host *shost ;
  struct bfad_im_port_s *im_port ;
  struct bfad_s *bfad ;
  struct bfad_itnim_s *itnim ;
  u64 node_name ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;
  __u64 tmp___0 ;

  {
  itnim = (struct bfad_itnim_s *)0;
  node_name = 0ULL;
  shost = dev_to_shost(starget->dev.parent);
  im_port = (struct bfad_im_port_s *)shost->hostdata[0];
  bfad = im_port->bfad;
  tmp = spinlock_check(& bfad->bfad_lock);
  flags = _raw_spin_lock_irqsave(tmp);
  itnim = bfad_get_itnim(im_port, (int )starget->id);
  if ((unsigned long )itnim != (unsigned long )((struct bfad_itnim_s *)0)) {
    node_name = bfa_fcs_itnim_get_nwwn(& itnim->fcs_itnim);
  } else {

  }
  tmp___0 = __fswab64(node_name);
  ((struct fc_starget_attrs *)(& starget->starget_data))->node_name = tmp___0;
  spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  return;
}
}
static void bfad_im_get_starget_port_name(struct scsi_target *starget ) 
{ 
  struct Scsi_Host *shost ;
  struct bfad_im_port_s *im_port ;
  struct bfad_s *bfad ;
  struct bfad_itnim_s *itnim ;
  u64 port_name ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;
  __u64 tmp___0 ;

  {
  itnim = (struct bfad_itnim_s *)0;
  port_name = 0ULL;
  shost = dev_to_shost(starget->dev.parent);
  im_port = (struct bfad_im_port_s *)shost->hostdata[0];
  bfad = im_port->bfad;
  tmp = spinlock_check(& bfad->bfad_lock);
  flags = _raw_spin_lock_irqsave(tmp);
  itnim = bfad_get_itnim(im_port, (int )starget->id);
  if ((unsigned long )itnim != (unsigned long )((struct bfad_itnim_s *)0)) {
    port_name = bfa_fcs_itnim_get_pwwn(& itnim->fcs_itnim);
  } else {

  }
  tmp___0 = __fswab64(port_name);
  ((struct fc_starget_attrs *)(& starget->starget_data))->port_name = tmp___0;
  spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  return;
}
}
static void bfad_im_get_host_port_id(struct Scsi_Host *shost ) 
{ 
  struct bfad_im_port_s *im_port ;
  struct bfad_port_s *port ;

  {
  im_port = (struct bfad_im_port_s *)shost->hostdata[0];
  port = im_port->port;
  ((struct fc_host_attrs *)shost->shost_data)->port_id = (u32 )(((((int )(port->fcs_port)->pid & 255) << 16) | ((int )(port->fcs_port)->pid & 65280)) | (((int )(port->fcs_port)->pid & 16711680) >> 16));
  return;
}
}
static void bfad_im_get_host_port_type(struct Scsi_Host *shost ) 
{ 
  struct bfad_im_port_s *im_port ;
  struct bfad_s *bfad ;
  struct bfa_lport_attr_s port_attr ;

  {
  im_port = (struct bfad_im_port_s *)shost->hostdata[0];
  bfad = im_port->bfad;
  bfa_fcs_lport_get_attr(& bfad->bfa_fcs.fabric.bport, & port_attr);
  switch ((unsigned int )port_attr.port_type) {
  case 5U: 
  ((struct fc_host_attrs *)shost->shost_data)->port_type = 3;
  goto ldv_48319;
  case 6U: 
  ((struct fc_host_attrs *)shost->shost_data)->port_type = 4;
  goto ldv_48319;
  case 21U: 
  ((struct fc_host_attrs *)shost->shost_data)->port_type = 6;
  goto ldv_48319;
  case 20U: 
  ((struct fc_host_attrs *)shost->shost_data)->port_type = 5;
  goto ldv_48319;
  default: 
  ((struct fc_host_attrs *)shost->shost_data)->port_type = 0;
  goto ldv_48319;
  }
  ldv_48319: ;
  return;
}
}
static void bfad_im_get_host_port_state(struct Scsi_Host *shost ) 
{ 
  struct bfad_im_port_s *im_port ;
  struct bfad_s *bfad ;
  struct bfa_port_attr_s attr ;

  {
  im_port = (struct bfad_im_port_s *)shost->hostdata[0];
  bfad = im_port->bfad;
  bfa_fcport_get_attr(& bfad->bfa, & attr);
  switch ((unsigned int )attr.port_state) {
  case 4U: 
  ((struct fc_host_attrs *)shost->shost_data)->port_state = 7;
  goto ldv_48331;
  case 5U: 
  ((struct fc_host_attrs *)shost->shost_data)->port_state = 2;
  goto ldv_48331;
  case 8U: ;
  case 9U: ;
  case 10U: ;
  case 11U: 
  ((struct fc_host_attrs *)shost->shost_data)->port_state = 3;
  goto ldv_48331;
  case 1U: ;
  case 2U: ;
  case 3U: ;
  case 6U: ;
  case 7U: ;
  default: 
  ((struct fc_host_attrs *)shost->shost_data)->port_state = 0;
  goto ldv_48331;
  }
  ldv_48331: ;
  return;
}
}
static void bfad_im_get_host_active_fc4s(struct Scsi_Host *shost ) 
{ 
  struct bfad_im_port_s *im_port ;
  struct bfad_port_s *port ;

  {
  im_port = (struct bfad_im_port_s *)shost->hostdata[0];
  port = im_port->port;
  memset((void *)(& ((struct fc_host_attrs *)shost->shost_data)->active_fc4s), 0,
           32UL);
  if ((int )port->supported_fc4s & 1) {
    ((struct fc_host_attrs *)shost->shost_data)->active_fc4s[2] = 1U;
  } else {

  }
  ((struct fc_host_attrs *)shost->shost_data)->active_fc4s[7] = 1U;
  return;
}
}
static void bfad_im_get_host_speed(struct Scsi_Host *shost ) 
{ 
  struct bfad_im_port_s *im_port ;
  struct bfad_s *bfad ;
  struct bfa_port_attr_s attr ;

  {
  im_port = (struct bfad_im_port_s *)shost->hostdata[0];
  bfad = im_port->bfad;
  bfa_fcport_get_attr(& bfad->bfa, & attr);
  switch ((unsigned int )attr.speed) {
  case 10U: 
  ((struct fc_host_attrs *)shost->shost_data)->speed = 4U;
  goto ldv_48355;
  case 16U: 
  ((struct fc_host_attrs *)shost->shost_data)->speed = 32U;
  goto ldv_48355;
  case 8U: 
  ((struct fc_host_attrs *)shost->shost_data)->speed = 16U;
  goto ldv_48355;
  case 4U: 
  ((struct fc_host_attrs *)shost->shost_data)->speed = 8U;
  goto ldv_48355;
  case 2U: 
  ((struct fc_host_attrs *)shost->shost_data)->speed = 2U;
  goto ldv_48355;
  case 1U: 
  ((struct fc_host_attrs *)shost->shost_data)->speed = 1U;
  goto ldv_48355;
  default: 
  ((struct fc_host_attrs *)shost->shost_data)->speed = 0U;
  goto ldv_48355;
  }
  ldv_48355: ;
  return;
}
}
static void bfad_im_get_host_fabric_name(struct Scsi_Host *shost ) 
{ 
  struct bfad_im_port_s *im_port ;
  struct bfad_port_s *port ;
  wwn_t fabric_nwwn ;
  __u64 tmp ;

  {
  im_port = (struct bfad_im_port_s *)shost->hostdata[0];
  port = im_port->port;
  fabric_nwwn = 0ULL;
  fabric_nwwn = ((port->fcs_port)->fabric)->fabric_name;
  tmp = __fswab64(fabric_nwwn);
  ((struct fc_host_attrs *)shost->shost_data)->fabric_name = tmp;
  return;
}
}
static struct fc_host_statistics *bfad_im_get_stats(struct Scsi_Host *shost ) 
{ 
  struct bfad_im_port_s *im_port ;
  struct bfad_s *bfad ;
  struct bfad_hal_comp fcomp ;
  union bfa_port_stats_u *fcstats ;
  struct fc_host_statistics *hstats ;
  enum bfa_status rc ;
  unsigned long flags ;
  void *tmp ;
  raw_spinlock_t *tmp___0 ;

  {
  im_port = (struct bfad_im_port_s *)shost->hostdata[0];
  bfad = im_port->bfad;
  tmp = kzalloc(336UL, 208U);
  fcstats = (union bfa_port_stats_u *)tmp;
  if ((unsigned long )fcstats == (unsigned long )((union bfa_port_stats_u *)0)) {
    return ((struct fc_host_statistics *)0);
  } else {

  }
  hstats = & bfad->link_stats;
  init_completion(& fcomp.comp);
  tmp___0 = spinlock_check(& bfad->bfad_lock);
  flags = _raw_spin_lock_irqsave(tmp___0);
  memset((void *)hstats, 0, 232UL);
  rc = bfa_port_get_stats(& bfad->bfa.modules.port, fcstats, & bfad_hcb_comp, (void *)(& fcomp));
  spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  if ((unsigned int )rc != 0U) {
    return ((struct fc_host_statistics *)0);
  } else {

  }
  wait_for_completion(& fcomp.comp);
  hstats->seconds_since_last_reset = fcstats->fc.secs_reset;
  hstats->tx_frames = fcstats->fc.tx_frames;
  hstats->tx_words = fcstats->fc.tx_words;
  hstats->rx_frames = fcstats->fc.rx_frames;
  hstats->rx_words = fcstats->fc.rx_words;
  hstats->lip_count = fcstats->fc.lip_count;
  hstats->nos_count = fcstats->fc.nos_count;
  hstats->error_frames = fcstats->fc.error_frames;
  hstats->dumped_frames = fcstats->fc.dropped_frames;
  hstats->link_failure_count = fcstats->fc.link_failures;
  hstats->loss_of_sync_count = fcstats->fc.loss_of_syncs;
  hstats->loss_of_signal_count = fcstats->fc.loss_of_signals;
  hstats->prim_seq_protocol_err_count = fcstats->fc.primseq_errs;
  hstats->invalid_crc_count = fcstats->fc.invalid_crcs;
  kfree((void const   *)fcstats);
  return (hstats);
}
}
static void bfad_im_reset_stats(struct Scsi_Host *shost ) 
{ 
  struct bfad_im_port_s *im_port ;
  struct bfad_s *bfad ;
  struct bfad_hal_comp fcomp ;
  unsigned long flags ;
  enum bfa_status rc ;
  raw_spinlock_t *tmp ;

  {
  im_port = (struct bfad_im_port_s *)shost->hostdata[0];
  bfad = im_port->bfad;
  init_completion(& fcomp.comp);
  tmp = spinlock_check(& bfad->bfad_lock);
  flags = _raw_spin_lock_irqsave(tmp);
  rc = bfa_port_clear_stats(& bfad->bfa.modules.port, & bfad_hcb_comp, (void *)(& fcomp));
  spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  if ((unsigned int )rc != 0U) {
    return;
  } else {

  }
  wait_for_completion(& fcomp.comp);
  return;
}
}
static void bfad_im_set_rport_loss_tmo(struct fc_rport *rport , u32 timeout ) 
{ 
  struct bfad_itnim_data_s *itnim_data ;
  struct bfad_itnim_s *itnim ;
  struct bfad_s *bfad ;
  uint16_t path_tov ;
  u16 tmp ;

  {
  itnim_data = (struct bfad_itnim_data_s *)rport->dd_data;
  itnim = itnim_data->itnim;
  bfad = (itnim->im)->bfad;
  tmp = bfa_fcpim_path_tov_get(& bfad->bfa);
  path_tov = tmp;
  rport->dev_loss_tmo = timeout;
  if ((u32 )path_tov > timeout) {
    rport->dev_loss_tmo = (u32 )((int )path_tov + 1);
  } else {

  }
  return;
}
}
static int bfad_im_vport_create(struct fc_vport *fc_vport , bool disable ) 
{ 
  char *vname ;
  struct Scsi_Host *shost ;
  struct bfad_im_port_s *im_port ;
  struct bfad_s *bfad ;
  struct bfa_lport_cfg_s port_cfg ;
  struct bfad_vport_s *vp ;
  int status ;
    klee_make_symbolic(&status, sizeof(int), "status");
  int rc ;
  unsigned long flags ;
  size_t tmp ;
  raw_spinlock_t *tmp___0 ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  enum bfa_status tmp___1 ;
  struct bfad_vport_s *vport ;
  struct bfa_fcs_vport_s *fcs_vport ;
  struct Scsi_Host *vshost ;
  raw_spinlock_t *tmp___2 ;
  raw_spinlock_t *tmp___3 ;
  u16 tmp___4 ;

  {
  vname = (char *)(& fc_vport->symbolic_name);
  shost = fc_vport->shost;
  im_port = (struct bfad_im_port_s *)shost->hostdata[0];
  bfad = im_port->bfad;
  status = 0;
  memset((void *)(& port_cfg), 0, 304UL);
  u64_to_wwn(fc_vport->node_name, (u8 *)(& port_cfg.nwwn));
  u64_to_wwn(fc_vport->port_name, (u8 *)(& port_cfg.pwwn));
  tmp = strlen((char const   *)vname);
  if (tmp != 0UL) {
    strcpy((char *)(& port_cfg.sym_name), (char const   *)vname);
  } else {

  }
  port_cfg.roles = 1;
  tmp___0 = spinlock_check(& bfad->bfad_lock);
  flags = _raw_spin_lock_irqsave(tmp___0);
  __mptr = (struct list_head  const  *)bfad->pbc_vport_list.next;
  vp = (struct bfad_vport_s *)__mptr + 0xfffffffffffff888UL;
  goto ldv_48422;
  ldv_48421: ;
  if (port_cfg.pwwn == vp->fcs_vport.lport.port_cfg.pwwn) {
    port_cfg.preboot_vp = vp->fcs_vport.lport.port_cfg.preboot_vp;
    goto ldv_48420;
  } else {

  }
  __mptr___0 = (struct list_head  const  *)vp->list_entry.next;
  vp = (struct bfad_vport_s *)__mptr___0 + 0xfffffffffffff888UL;
  ldv_48422: ;
  if ((unsigned long )(& vp->list_entry) != (unsigned long )(& bfad->pbc_vport_list)) {
    goto ldv_48421;
  } else {

  }
  ldv_48420: 
  spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  tmp___1 = bfad_vport_create(bfad, 0, & port_cfg, & fc_vport->dev);
  rc = (int )tmp___1;
  if (rc == 0) {
    tmp___2 = spinlock_check(& bfad->bfad_lock);
    flags = _raw_spin_lock_irqsave(tmp___2);
    fcs_vport = bfa_fcs_vport_lookup(& bfad->bfa_fcs, 0, port_cfg.pwwn);
    spin_unlock_irqrestore(& bfad->bfad_lock, flags);
    if ((unsigned long )fcs_vport == (unsigned long )((struct bfa_fcs_vport_s *)0)) {
      return (-76);
    } else {

    }
    fc_vport_set_state(fc_vport, 1);
    if ((int )disable) {
      tmp___3 = spinlock_check(& bfad->bfad_lock);
      flags = _raw_spin_lock_irqsave(tmp___3);
      bfa_fcs_vport_stop(fcs_vport);
      spin_unlock_irqrestore(& bfad->bfad_lock, flags);
      fc_vport_set_state(fc_vport, 2);
    } else {

    }
    vport = fcs_vport->vport_drv;
    vshost = (vport->drv_port.im_port)->shost;
    ((struct fc_host_attrs *)vshost->shost_data)->node_name = wwn_to_u64((u8 *)(& port_cfg.nwwn));
    ((struct fc_host_attrs *)vshost->shost_data)->port_name = wwn_to_u64((u8 *)(& port_cfg.pwwn));
    ((struct fc_host_attrs *)vshost->shost_data)->supported_classes = 8U;
    memset((void *)(& ((struct fc_host_attrs *)vshost->shost_data)->supported_fc4s),
             0, 32UL);
    if (supported_fc4s & 1) {
      ((struct fc_host_attrs *)vshost->shost_data)->supported_fc4s[2] = 1U;
    } else {

    }
    ((struct fc_host_attrs *)vshost->shost_data)->supported_fc4s[7] = 1U;
    ((struct fc_host_attrs *)vshost->shost_data)->supported_speeds = bfad_im_supported_speeds(& bfad->bfa);
    tmp___4 = bfa_fcport_get_maxfrsize(& bfad->bfa);
    ((struct fc_host_attrs *)vshost->shost_data)->maxframe_size = (u32 )tmp___4;
    fc_vport->dd_data = (void *)vport;
    (vport->drv_port.im_port)->fc_vport = fc_vport;
  } else
  if (rc == 57) {
    return (-76);
  } else
  if (rc == 21) {
    return (-76);
  } else
  if (rc == 22) {
    return (-95);
  } else
  if (rc == 46) {
    return (-76);
  } else {
    return (9);
  }
  return (status);
}
}
int bfad_im_issue_fc_host_lip(struct Scsi_Host *shost ) 
{ 
  struct bfad_im_port_s *im_port ;
  struct bfad_s *bfad ;
  struct bfad_hal_comp fcomp ;
  unsigned long flags ;
  uint32_t status ;
  raw_spinlock_t *tmp ;
  enum bfa_status tmp___0 ;
  raw_spinlock_t *tmp___1 ;
  enum bfa_status tmp___2 ;

  {
  im_port = (struct bfad_im_port_s *)shost->hostdata[0];
  bfad = im_port->bfad;
  init_completion(& fcomp.comp);
  tmp = spinlock_check(& bfad->bfad_lock);
  flags = _raw_spin_lock_irqsave(tmp);
  tmp___0 = bfa_port_disable(& bfad->bfa.modules.port, & bfad_hcb_comp, (void *)(& fcomp));
  status = (uint32_t )tmp___0;
  spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  if (status != 0U) {
    return (-5);
  } else {

  }
  wait_for_completion(& fcomp.comp);
  if ((unsigned int )fcomp.status != 0U) {
    return (-5);
  } else {

  }
  tmp___1 = spinlock_check(& bfad->bfad_lock);
  flags = _raw_spin_lock_irqsave(tmp___1);
  tmp___2 = bfa_port_enable(& bfad->bfa.modules.port, & bfad_hcb_comp, (void *)(& fcomp));
  status = (uint32_t )tmp___2;
  spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  if (status != 0U) {
    return (-5);
  } else {

  }
  wait_for_completion(& fcomp.comp);
  if ((unsigned int )fcomp.status != 0U) {
    return (-5);
  } else {

  }
  return (0);
}
}
static int bfad_im_vport_delete(struct fc_vport *fc_vport ) 
{ 
  struct bfad_vport_s *vport ;
  struct bfad_im_port_s *im_port ;
  struct bfad_s *bfad ;
  struct bfad_port_s *port ;
  struct bfa_fcs_vport_s *fcs_vport ;
  struct Scsi_Host *vshost ;
  wwn_t pwwn ;
  int rc ;
  unsigned long flags ;
  struct completion fcomp ;
  raw_spinlock_t *tmp ;
  raw_spinlock_t *tmp___0 ;
  enum bfa_status tmp___1 ;

  {
  vport = (struct bfad_vport_s *)fc_vport->dd_data;
  im_port = vport->drv_port.im_port;
  bfad = im_port->bfad;
  if ((int )im_port->flags & 1) {
    bfad_scsi_host_free(bfad, im_port);
    list_del(& vport->list_entry);
    kfree((void const   *)vport);
    return (0);
  } else {

  }
  port = im_port->port;
  vshost = (vport->drv_port.im_port)->shost;
  u64_to_wwn(((struct fc_host_attrs *)vshost->shost_data)->port_name, (u8 *)(& pwwn));
  tmp = spinlock_check(& bfad->bfad_lock);
  flags = _raw_spin_lock_irqsave(tmp);
  fcs_vport = bfa_fcs_vport_lookup(& bfad->bfa_fcs, 0, pwwn);
  spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  if ((unsigned long )fcs_vport == (unsigned long )((struct bfa_fcs_vport_s *)0)) {
    return (-76);
  } else {

  }
  vport->drv_port.flags = vport->drv_port.flags | 1;
  vport->comp_del = & fcomp;
  init_completion(vport->comp_del);
  tmp___0 = spinlock_check(& bfad->bfad_lock);
  flags = _raw_spin_lock_irqsave(tmp___0);
  tmp___1 = bfa_fcs_vport_delete(& vport->fcs_vport);
  rc = (int )tmp___1;
  spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  if (rc == 154) {
    vport->drv_port.flags = vport->drv_port.flags & -2;
    vport->comp_del = (struct completion *)0;
    return (-1);
  } else {

  }
  wait_for_completion(vport->comp_del);
  bfad_scsi_host_free(bfad, im_port);
  list_del(& vport->list_entry);
  kfree((void const   *)vport);
  return (0);
}
}
static int bfad_im_vport_disable(struct fc_vport *fc_vport , bool disable ) 
{ 
  struct bfad_vport_s *vport ;
  struct bfad_s *bfad ;
  struct bfa_fcs_vport_s *fcs_vport ;
  struct Scsi_Host *vshost ;
  wwn_t pwwn ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;

  {
  vport = (struct bfad_vport_s *)fc_vport->dd_data;
  bfad = vport->drv_port.bfad;
  vshost = (vport->drv_port.im_port)->shost;
  u64_to_wwn(((struct fc_host_attrs *)vshost->shost_data)->port_name, (u8 *)(& pwwn));
  tmp = spinlock_check(& bfad->bfad_lock);
  flags = _raw_spin_lock_irqsave(tmp);
  fcs_vport = bfa_fcs_vport_lookup(& bfad->bfa_fcs, 0, pwwn);
  spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  if ((unsigned long )fcs_vport == (unsigned long )((struct bfa_fcs_vport_s *)0)) {
    return (-76);
  } else {

  }
  if ((int )disable) {
    bfa_fcs_vport_stop(fcs_vport);
    fc_vport_set_state(fc_vport, 2);
  } else {
    bfa_fcs_vport_start(fcs_vport);
    fc_vport_set_state(fc_vport, 1);
  }
  return (0);
}
}
void bfad_im_vport_set_symbolic_name(struct fc_vport *fc_vport ) 
{ 
  struct bfad_vport_s *vport ;
  struct bfad_im_port_s *im_port ;
  struct bfad_s *bfad ;
  struct Scsi_Host *vshost ;
  char *sym_name ;
  struct bfa_fcs_vport_s *fcs_vport ;
  wwn_t pwwn ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;
  raw_spinlock_t *tmp___0 ;
  size_t tmp___1 ;

  {
  vport = (struct bfad_vport_s *)fc_vport->dd_data;
  im_port = vport->drv_port.im_port;
  bfad = im_port->bfad;
  vshost = (vport->drv_port.im_port)->shost;
  sym_name = (char *)(& fc_vport->symbolic_name);
  u64_to_wwn(((struct fc_host_attrs *)vshost->shost_data)->port_name, (u8 *)(& pwwn));
  tmp = spinlock_check(& bfad->bfad_lock);
  flags = _raw_spin_lock_irqsave(tmp);
  fcs_vport = bfa_fcs_vport_lookup(& bfad->bfa_fcs, 0, pwwn);
  spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  if ((unsigned long )fcs_vport == (unsigned long )((struct bfa_fcs_vport_s *)0)) {
    return;
  } else {

  }
  tmp___0 = spinlock_check(& bfad->bfad_lock);
  flags = _raw_spin_lock_irqsave(tmp___0);
  tmp___1 = strlen((char const   *)sym_name);
  if (tmp___1 != 0UL) {
    bfa_fcs_lport_set_symname(& fcs_vport->lport, sym_name);
  } else {

  }
  spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  return;
}
}
struct fc_function_template bfad_im_fc_function_template  = 
     {0, & bfad_im_set_rport_loss_tmo, & bfad_im_get_starget_node_name, & bfad_im_get_starget_port_name,
    & bfad_im_get_starget_port_id, & bfad_im_get_host_port_id, & bfad_im_get_host_port_type,
    & bfad_im_get_host_port_state, & bfad_im_get_host_active_fc4s, & bfad_im_get_host_speed,
    & bfad_im_get_host_fabric_name, 0, 0, & bfad_im_get_stats, & bfad_im_reset_stats,
    & bfad_im_issue_fc_host_lip, 0, 0, & bfad_im_vport_set_symbolic_name, & bfad_im_vport_create,
    & bfad_im_vport_disable, & bfad_im_vport_delete, 0, 0, & bfad_im_bsg_request,
    & bfad_im_bsg_timeout, 8U, 0U, 0U, 1U, 1U, 1U, 1U, 1U, 1U, 1U, 1U, (unsigned char)0,
    1U, 1U, 1U, 1U, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
    (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, 1U, 1U,
    1U, 1U, 1U, 1U, 1U, (unsigned char)0, (unsigned char)0};
struct fc_function_template bfad_im_vport_fc_function_template  = 
     {0, & bfad_im_set_rport_loss_tmo, & bfad_im_get_starget_node_name, & bfad_im_get_starget_port_name,
    & bfad_im_get_starget_port_id, & bfad_im_get_host_port_id, & bfad_im_get_host_port_type,
    & bfad_im_get_host_port_state, & bfad_im_get_host_active_fc4s, & bfad_im_get_host_speed,
    & bfad_im_get_host_fabric_name, 0, 0, & bfad_im_get_stats, & bfad_im_reset_stats,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8U, 0U, 0U, 1U, 1U, 1U, 1U, 1U, 1U, 1U, 1U, (unsigned char)0,
    1U, 1U, 1U, 1U, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
    (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, 1U, 1U,
    1U, 1U, 1U, 1U, 1U, (unsigned char)0, (unsigned char)0};
static ssize_t bfad_im_serial_num_show(struct device *dev , struct device_attribute *attr ,
                                       char *buf ) 
{ 
  struct Scsi_Host *shost ;
  struct device  const  *__mptr ;
  struct bfad_im_port_s *im_port ;
  struct bfad_s *bfad ;
  char serial_num[12U] ;
  int tmp ;

  {
  __mptr = (struct device  const  *)dev;
  shost = (struct Scsi_Host *)__mptr + 0xfffffffffffff6c0UL;
  im_port = (struct bfad_im_port_s *)shost->hostdata[0];
  bfad = im_port->bfad;
  bfa_ioc_get_adapter_serial_num(& bfad->bfa.ioc, (char *)(& serial_num));
  tmp = snprintf(buf, 4096UL, "%s\n", (char *)(& serial_num));
  return ((ssize_t )tmp);
}
}
static ssize_t bfad_im_model_show(struct device *dev , struct device_attribute *attr ,
                                  char *buf ) 
{ 
  struct Scsi_Host *shost ;
  struct device  const  *__mptr ;
  struct bfad_im_port_s *im_port ;
  struct bfad_s *bfad ;
  char model[16U] ;
  int tmp ;

  {
  __mptr = (struct device  const  *)dev;
  shost = (struct Scsi_Host *)__mptr + 0xfffffffffffff6c0UL;
  im_port = (struct bfad_im_port_s *)shost->hostdata[0];
  bfad = im_port->bfad;
  bfa_ioc_get_adapter_model(& bfad->bfa.ioc, (char *)(& model));
  tmp = snprintf(buf, 4096UL, "%s\n", (char *)(& model));
  return ((ssize_t )tmp);
}
}
static ssize_t bfad_im_model_desc_show(struct device *dev , struct device_attribute *attr ,
                                       char *buf ) 
{ 
  struct Scsi_Host *shost ;
  struct device  const  *__mptr ;
  struct bfad_im_port_s *im_port ;
  struct bfad_s *bfad ;
  char model[16U] ;
  char model_descr[128U] ;
  int nports ;
    klee_make_symbolic(&nports, sizeof(int), "nports");
  enum bfa_ioc_type_e tmp ;
  enum bfa_ioc_type_e tmp___0 ;
  enum bfa_ioc_type_e tmp___1 ;
  enum bfa_ioc_type_e tmp___2 ;
  enum bfa_ioc_type_e tmp___3 ;
  enum bfa_ioc_type_e tmp___4 ;
  enum bfa_ioc_type_e tmp___5 ;
  enum bfa_ioc_type_e tmp___6 ;
  enum bfa_ioc_type_e tmp___7 ;
  enum bfa_ioc_type_e tmp___8 ;
  enum bfa_ioc_type_e tmp___9 ;
  enum bfa_ioc_type_e tmp___10 ;
  int tmp___11 ;
    klee_make_symbolic(&tmp___11, sizeof(int), "tmp___11");
  char *tmp___12 ;
  int tmp___13 ;
    klee_make_symbolic(&tmp___13, sizeof(int), "tmp___13");
  int tmp___14 ;
    klee_make_symbolic(&tmp___14, sizeof(int), "tmp___14");
  int tmp___15 ;
    klee_make_symbolic(&tmp___15, sizeof(int), "tmp___15");
  int tmp___16 ;
    klee_make_symbolic(&tmp___16, sizeof(int), "tmp___16");
  int tmp___17 ;
    klee_make_symbolic(&tmp___17, sizeof(int), "tmp___17");
  int tmp___18 ;
    klee_make_symbolic(&tmp___18, sizeof(int), "tmp___18");
  int tmp___19 ;
    klee_make_symbolic(&tmp___19, sizeof(int), "tmp___19");
  int tmp___20 ;
    klee_make_symbolic(&tmp___20, sizeof(int), "tmp___20");
  int tmp___21 ;
    klee_make_symbolic(&tmp___21, sizeof(int), "tmp___21");
  int tmp___22 ;
    klee_make_symbolic(&tmp___22, sizeof(int), "tmp___22");
  int tmp___23 ;
    klee_make_symbolic(&tmp___23, sizeof(int), "tmp___23");
  int tmp___24 ;
    klee_make_symbolic(&tmp___24, sizeof(int), "tmp___24");
  int tmp___25 ;
    klee_make_symbolic(&tmp___25, sizeof(int), "tmp___25");
  int tmp___26 ;
    klee_make_symbolic(&tmp___26, sizeof(int), "tmp___26");

  {
  __mptr = (struct device  const  *)dev;
  shost = (struct Scsi_Host *)__mptr + 0xfffffffffffff6c0UL;
  im_port = (struct bfad_im_port_s *)shost->hostdata[0];
  bfad = im_port->bfad;
  nports = 0;
  bfa_ioc_get_adapter_model(& bfad->bfa.ioc, (char *)(& model));
  nports = (int )(((bfad->bfa.ioc.attr)->adapter_prop & 65280U) >> 8);
  tmp___25 = strcmp((char const   *)(& model), "Brocade-425");
  if (tmp___25 == 0) {
    snprintf((char *)(& model_descr), 128UL, "Brocade 4Gbps PCIe dual port FC HBA");
  } else {
    tmp___24 = strcmp((char const   *)(& model), "Brocade-825");
    if (tmp___24 == 0) {
      snprintf((char *)(& model_descr), 128UL, "Brocade 8Gbps PCIe dual port FC HBA");
    } else {
      tmp___23 = strcmp((char const   *)(& model), "Brocade-42B");
      if (tmp___23 == 0) {
        snprintf((char *)(& model_descr), 128UL, "Brocade 4Gbps PCIe dual port FC HBA for HP");
      } else {
        tmp___22 = strcmp((char const   *)(& model), "Brocade-82B");
        if (tmp___22 == 0) {
          snprintf((char *)(& model_descr), 128UL, "Brocade 8Gbps PCIe dual port FC HBA for HP");
        } else {
          tmp___21 = strcmp((char const   *)(& model), "Brocade-1010");
          if (tmp___21 == 0) {
            snprintf((char *)(& model_descr), 128UL, "Brocade 10Gbps single port CNA");
          } else {
            tmp___20 = strcmp((char const   *)(& model), "Brocade-1020");
            if (tmp___20 == 0) {
              snprintf((char *)(& model_descr), 128UL, "Brocade 10Gbps dual port CNA");
            } else {
              tmp___19 = strcmp((char const   *)(& model), "Brocade-1007");
              if (tmp___19 == 0) {
                snprintf((char *)(& model_descr), 128UL, "Brocade 10Gbps CNA for IBM Blade Center");
              } else {
                tmp___18 = strcmp((char const   *)(& model), "Brocade-415");
                if (tmp___18 == 0) {
                  snprintf((char *)(& model_descr), 128UL, "Brocade 4Gbps PCIe single port FC HBA");
                } else {
                  tmp___17 = strcmp((char const   *)(& model), "Brocade-815");
                  if (tmp___17 == 0) {
                    snprintf((char *)(& model_descr), 128UL, "Brocade 8Gbps PCIe single port FC HBA");
                  } else {
                    tmp___16 = strcmp((char const   *)(& model), "Brocade-41B");
                    if (tmp___16 == 0) {
                      snprintf((char *)(& model_descr), 128UL, "Brocade 4Gbps PCIe single port FC HBA for HP");
                    } else {
                      tmp___15 = strcmp((char const   *)(& model), "Brocade-81B");
                      if (tmp___15 == 0) {
                        snprintf((char *)(& model_descr), 128UL, "Brocade 8Gbps PCIe single port FC HBA for HP");
                      } else {
                        tmp___14 = strcmp((char const   *)(& model), "Brocade-804");
                        if (tmp___14 == 0) {
                          snprintf((char *)(& model_descr), 128UL, "Brocade 8Gbps FC HBA for HP Bladesystem C-class");
                        } else {
                          tmp___13 = strcmp((char const   *)(& model), "Brocade-1741");
                          if (tmp___13 == 0) {
                            snprintf((char *)(& model_descr), 128UL, "Brocade 10Gbps CNA for Dell M-Series Blade Servers");
                          } else {
                            tmp___12 = strstr((char const   *)(& model), "Brocade-1860");
                            if ((unsigned long )tmp___12 != (unsigned long )((char *)0)) {
                              if (nports == 1) {
                                tmp___5 = bfa_ioc_get_type(& bfad->bfa.ioc);
                                if ((unsigned int )tmp___5 == 2U) {
                                  snprintf((char *)(& model_descr), 128UL, "Brocade 10Gbps single port CNA");
                                } else {
                                  tmp___6 = bfa_ioc_get_type(& bfad->bfa.ioc);
                                  if ((unsigned int )tmp___6 == 3U) {
                                    snprintf((char *)(& model_descr), 128UL, "Brocade 10Gbps single port CNA");
                                  } else {
                                    goto _L___1;
                                  }
                                }
                              } else
                              _L___1: /* CIL Label */ 
                              if (nports == 1) {
                                tmp___3 = bfa_ioc_get_type(& bfad->bfa.ioc);
                                if ((unsigned int )tmp___3 != 2U) {
                                  tmp___4 = bfa_ioc_get_type(& bfad->bfa.ioc);
                                  if ((unsigned int )tmp___4 != 3U) {
                                    snprintf((char *)(& model_descr), 128UL, "Brocade 16Gbps PCIe single port FC HBA");
                                  } else {
                                    goto _L___0;
                                  }
                                } else {
                                  goto _L___0;
                                }
                              } else
                              _L___0: /* CIL Label */ 
                              if (nports == 2) {
                                tmp___1 = bfa_ioc_get_type(& bfad->bfa.ioc);
                                if ((unsigned int )tmp___1 == 2U) {
                                  snprintf((char *)(& model_descr), 128UL, "Brocade 10Gbps dual port CNA");
                                } else {
                                  tmp___2 = bfa_ioc_get_type(& bfad->bfa.ioc);
                                  if ((unsigned int )tmp___2 == 3U) {
                                    snprintf((char *)(& model_descr), 128UL, "Brocade 10Gbps dual port CNA");
                                  } else {
                                    goto _L;
                                  }
                                }
                              } else
                              _L: /* CIL Label */ 
                              if (nports == 2) {
                                tmp = bfa_ioc_get_type(& bfad->bfa.ioc);
                                if ((unsigned int )tmp != 2U) {
                                  tmp___0 = bfa_ioc_get_type(& bfad->bfa.ioc);
                                  if ((unsigned int )tmp___0 != 3U) {
                                    snprintf((char *)(& model_descr), 128UL, "Brocade 16Gbps PCIe dual port FC HBA");
                                  } else {

                                  }
                                } else {

                                }
                              } else {

                              }
                            } else {
                              tmp___11 = strcmp((char const   *)(& model), "Brocade-1867");
                              if (tmp___11 == 0) {
                                if (nports == 1) {
                                  tmp___9 = bfa_ioc_get_type(& bfad->bfa.ioc);
                                  if ((unsigned int )tmp___9 != 2U) {
                                    tmp___10 = bfa_ioc_get_type(& bfad->bfa.ioc);
                                    if ((unsigned int )tmp___10 != 3U) {
                                      snprintf((char *)(& model_descr), 128UL, "Brocade 16Gbps PCIe single port FC HBA for IBM");
                                    } else {
                                      goto _L___2;
                                    }
                                  } else {
                                    goto _L___2;
                                  }
                                } else
                                _L___2: /* CIL Label */ 
                                if (nports == 2) {
                                  tmp___7 = bfa_ioc_get_type(& bfad->bfa.ioc);
                                  if ((unsigned int )tmp___7 != 2U) {
                                    tmp___8 = bfa_ioc_get_type(& bfad->bfa.ioc);
                                    if ((unsigned int )tmp___8 != 3U) {
                                      snprintf((char *)(& model_descr), 128UL, "Brocade 16Gbps PCIe dual port FC HBA for IBM");
                                    } else {

                                    }
                                  } else {

                                  }
                                } else {

                                }
                              } else {
                                snprintf((char *)(& model_descr), 128UL, "Invalid Model");
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  tmp___26 = snprintf(buf, 4096UL, "%s\n", (char *)(& model_descr));
  return ((ssize_t )tmp___26);
}
}
static ssize_t bfad_im_node_name_show(struct device *dev , struct device_attribute *attr ,
                                      char *buf ) 
{ 
  struct Scsi_Host *shost ;
  struct device  const  *__mptr ;
  struct bfad_im_port_s *im_port ;
  struct bfad_port_s *port ;
  u64 nwwn ;
  __u64 tmp ;
  int tmp___0 ;

  {
  __mptr = (struct device  const  *)dev;
  shost = (struct Scsi_Host *)__mptr + 0xfffffffffffff6c0UL;
  im_port = (struct bfad_im_port_s *)shost->hostdata[0];
  port = im_port->port;
  nwwn = (port->fcs_port)->port_cfg.nwwn;
  tmp = __fswab64(nwwn);
  tmp___0 = snprintf(buf, 4096UL, "0x%llx\n", tmp);
  return ((ssize_t )tmp___0);
}
}
static ssize_t bfad_im_symbolic_name_show(struct device *dev , struct device_attribute *attr ,
                                          char *buf ) 
{ 
  struct Scsi_Host *shost ;
  struct device  const  *__mptr ;
  struct bfad_im_port_s *im_port ;
  struct bfad_s *bfad ;
  struct bfa_lport_attr_s port_attr ;
  char symname[128U] ;
  int tmp ;

  {
  __mptr = (struct device  const  *)dev;
  shost = (struct Scsi_Host *)__mptr + 0xfffffffffffff6c0UL;
  im_port = (struct bfad_im_port_s *)shost->hostdata[0];
  bfad = im_port->bfad;
  bfa_fcs_lport_get_attr(& bfad->bfa_fcs.fabric.bport, & port_attr);
  strncpy((char *)(& symname), (char const   *)(& port_attr.port_cfg.sym_name.symname),
          128UL);
  tmp = snprintf(buf, 4096UL, "%s\n", (char *)(& symname));
  return ((ssize_t )tmp);
}
}
static ssize_t bfad_im_hw_version_show(struct device *dev , struct device_attribute *attr ,
                                       char *buf ) 
{ 
  struct Scsi_Host *shost ;
  struct device  const  *__mptr ;
  struct bfad_im_port_s *im_port ;
  struct bfad_s *bfad ;
  char hw_ver[64U] ;
  int tmp ;

  {
  __mptr = (struct device  const  *)dev;
  shost = (struct Scsi_Host *)__mptr + 0xfffffffffffff6c0UL;
  im_port = (struct bfad_im_port_s *)shost->hostdata[0];
  bfad = im_port->bfad;
  bfa_ioc_get_pci_chip_rev(& bfad->bfa.ioc, (char *)(& hw_ver));
  tmp = snprintf(buf, 4096UL, "%s\n", (char *)(& hw_ver));
  return ((ssize_t )tmp);
}
}
static ssize_t bfad_im_drv_version_show(struct device *dev , struct device_attribute *attr ,
                                        char *buf ) 
{ 
  int tmp ;

  {
  tmp = snprintf(buf, 4096UL, "%s\n", (char *)"3.2.23.0");
  return ((ssize_t )tmp);
}
}
static ssize_t bfad_im_optionrom_version_show(struct device *dev , struct device_attribute *attr ,
                                              char *buf ) 
{ 
  struct Scsi_Host *shost ;
  struct device  const  *__mptr ;
  struct bfad_im_port_s *im_port ;
  struct bfad_s *bfad ;
  char optrom_ver[64U] ;
  int tmp ;

  {
  __mptr = (struct device  const  *)dev;
  shost = (struct Scsi_Host *)__mptr + 0xfffffffffffff6c0UL;
  im_port = (struct bfad_im_port_s *)shost->hostdata[0];
  bfad = im_port->bfad;
  bfa_ioc_get_adapter_optrom_ver(& bfad->bfa.ioc, (char *)(& optrom_ver));
  tmp = snprintf(buf, 4096UL, "%s\n", (char *)(& optrom_ver));
  return ((ssize_t )tmp);
}
}
static ssize_t bfad_im_fw_version_show(struct device *dev , struct device_attribute *attr ,
                                       char *buf ) 
{ 
  struct Scsi_Host *shost ;
  struct device  const  *__mptr ;
  struct bfad_im_port_s *im_port ;
  struct bfad_s *bfad ;
  char fw_ver[64U] ;
  int tmp ;

  {
  __mptr = (struct device  const  *)dev;
  shost = (struct Scsi_Host *)__mptr + 0xfffffffffffff6c0UL;
  im_port = (struct bfad_im_port_s *)shost->hostdata[0];
  bfad = im_port->bfad;
  bfa_ioc_get_adapter_fw_ver(& bfad->bfa.ioc, (char *)(& fw_ver));
  tmp = snprintf(buf, 4096UL, "%s\n", (char *)(& fw_ver));
  return ((ssize_t )tmp);
}
}
static ssize_t bfad_im_num_of_ports_show(struct device *dev , struct device_attribute *attr ,
                                         char *buf ) 
{ 
  struct Scsi_Host *shost ;
  struct device  const  *__mptr ;
  struct bfad_im_port_s *im_port ;
  struct bfad_s *bfad ;
  int tmp ;

  {
  __mptr = (struct device  const  *)dev;
  shost = (struct Scsi_Host *)__mptr + 0xfffffffffffff6c0UL;
  im_port = (struct bfad_im_port_s *)shost->hostdata[0];
  bfad = im_port->bfad;
  tmp = snprintf(buf, 4096UL, "%d\n", ((bfad->bfa.ioc.attr)->adapter_prop & 65280U) >> 8);
  return ((ssize_t )tmp);
}
}
static ssize_t bfad_im_drv_name_show(struct device *dev , struct device_attribute *attr ,
                                     char *buf ) 
{ 
  int tmp ;

  {
  tmp = snprintf(buf, 4096UL, "%s\n", (char *)"bfa");
  return ((ssize_t )tmp);
}
}
static ssize_t bfad_im_num_of_discovered_ports_show(struct device *dev , struct device_attribute *attr ,
                                                    char *buf ) 
{ 
  struct Scsi_Host *shost ;
  struct device  const  *__mptr ;
  struct bfad_im_port_s *im_port ;
  struct bfad_port_s *port ;
  struct bfad_s *bfad ;
  int nrports ;
    klee_make_symbolic(&nrports, sizeof(int), "nrports");
  struct bfa_rport_qualifier_s *rports ;
  unsigned long flags ;
  void *tmp ;
  int tmp___0 ;
  raw_spinlock_t *tmp___1 ;
  int tmp___2 ;

  {
  __mptr = (struct device  const  *)dev;
  shost = (struct Scsi_Host *)__mptr + 0xfffffffffffff6c0UL;
  im_port = (struct bfad_im_port_s *)shost->hostdata[0];
  port = im_port->port;
  bfad = im_port->bfad;
  nrports = 2048;
  rports = (struct bfa_rport_qualifier_s *)0;
  tmp = kzalloc((unsigned long )nrports * 16UL, 32U);
  rports = (struct bfa_rport_qualifier_s *)tmp;
  if ((unsigned long )rports == (unsigned long )((struct bfa_rport_qualifier_s *)0)) {
    tmp___0 = snprintf(buf, 4096UL, "Failed\n");
    return ((ssize_t )tmp___0);
  } else {

  }
  tmp___1 = spinlock_check(& bfad->bfad_lock);
  flags = _raw_spin_lock_irqsave(tmp___1);
  bfa_fcs_lport_get_rport_quals(port->fcs_port, rports, & nrports);
  spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  kfree((void const   *)rports);
  tmp___2 = snprintf(buf, 4096UL, "%d\n", nrports);
  return ((ssize_t )tmp___2);
}
}
static struct device_attribute dev_attr_serial_number  =    {{"serial_number", 292U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0},
                                           {(char)0}, {(char)0}, {(char)0}, {(char)0}}}},
    & bfad_im_serial_num_show, (ssize_t (*)(struct device * , struct device_attribute * ,
                                            char const   * , size_t  ))0};
static struct device_attribute dev_attr_model  =    {{"model", 292U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0}, {(char)0},
                                   {(char)0}, {(char)0}, {(char)0}}}}, & bfad_im_model_show,
    (ssize_t (*)(struct device * , struct device_attribute * , char const   * , size_t  ))0};
static struct device_attribute dev_attr_model_description  =    {{"model_description", 292U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0},
                                               {(char)0}, {(char)0}, {(char)0}, {(char)0}}}},
    & bfad_im_model_desc_show, (ssize_t (*)(struct device * , struct device_attribute * ,
                                            char const   * , size_t  ))0};
static struct device_attribute dev_attr_node_name  =    {{"node_name", 292U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0},
                                       {(char)0}, {(char)0}, {(char)0}, {(char)0}}}},
    & bfad_im_node_name_show, (ssize_t (*)(struct device * , struct device_attribute * ,
                                           char const   * , size_t  ))0};
static struct device_attribute dev_attr_symbolic_name  =    {{"symbolic_name", 292U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0},
                                           {(char)0}, {(char)0}, {(char)0}, {(char)0}}}},
    & bfad_im_symbolic_name_show, (ssize_t (*)(struct device * , struct device_attribute * ,
                                               char const   * , size_t  ))0};
static struct device_attribute dev_attr_hardware_version  =    {{"hardware_version", 292U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0},
                                              {(char)0}, {(char)0}, {(char)0}, {(char)0}}}},
    & bfad_im_hw_version_show, (ssize_t (*)(struct device * , struct device_attribute * ,
                                            char const   * , size_t  ))0};
static struct device_attribute dev_attr_driver_version  =    {{"driver_version", 292U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0},
                                            {(char)0}, {(char)0}, {(char)0}, {(char)0}}}},
    & bfad_im_drv_version_show, (ssize_t (*)(struct device * , struct device_attribute * ,
                                             char const   * , size_t  ))0};
static struct device_attribute dev_attr_option_rom_version  =    {{"option_rom_version", 292U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0},
                                                {(char)0}, {(char)0}, {(char)0}, {(char)0}}}},
    & bfad_im_optionrom_version_show, (ssize_t (*)(struct device * , struct device_attribute * ,
                                                   char const   * , size_t  ))0};
static struct device_attribute dev_attr_firmware_version  =    {{"firmware_version", 292U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0},
                                              {(char)0}, {(char)0}, {(char)0}, {(char)0}}}},
    & bfad_im_fw_version_show, (ssize_t (*)(struct device * , struct device_attribute * ,
                                            char const   * , size_t  ))0};
static struct device_attribute dev_attr_number_of_ports  =    {{"number_of_ports", 292U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0},
                                             {(char)0}, {(char)0}, {(char)0}, {(char)0}}}},
    & bfad_im_num_of_ports_show, (ssize_t (*)(struct device * , struct device_attribute * ,
                                              char const   * , size_t  ))0};
static struct device_attribute dev_attr_driver_name  =    {{"driver_name", 292U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0}, {(char)0},
                                         {(char)0}, {(char)0}, {(char)0}, {(char)0}}}},
    & bfad_im_drv_name_show, (ssize_t (*)(struct device * , struct device_attribute * ,
                                          char const   * , size_t  ))0};
static struct device_attribute dev_attr_number_of_discovered_ports  =    {{"number_of_discovered_ports", 292U, (_Bool)0, 0, {{{(char)0}, {(char)0}, {(char)0},
                                                        {(char)0}, {(char)0}, {(char)0},
                                                        {(char)0}, {(char)0}}}}, & bfad_im_num_of_discovered_ports_show,
    (ssize_t (*)(struct device * , struct device_attribute * , char const   * , size_t  ))0};
struct device_attribute *bfad_im_host_attrs[13U]  = 
  {      & dev_attr_serial_number,      & dev_attr_model,      & dev_attr_model_description,      & dev_attr_node_name, 
        & dev_attr_symbolic_name,      & dev_attr_hardware_version,      & dev_attr_driver_version,      & dev_attr_option_rom_version, 
        & dev_attr_firmware_version,      & dev_attr_number_of_ports,      & dev_attr_driver_name,      & dev_attr_number_of_discovered_ports, 
        (struct device_attribute *)0};
struct device_attribute *bfad_im_vport_attrs[13U]  = 
  {      & dev_attr_serial_number,      & dev_attr_model,      & dev_attr_model_description,      & dev_attr_node_name, 
        & dev_attr_symbolic_name,      & dev_attr_hardware_version,      & dev_attr_driver_version,      & dev_attr_option_rom_version, 
        & dev_attr_firmware_version,      & dev_attr_number_of_ports,      & dev_attr_driver_name,      & dev_attr_number_of_discovered_ports, 
        (struct device_attribute *)0};
void ldv_initialize_fc_function_template_33(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
  tmp = ldv_init_zalloc(3816UL);
  bfad_im_vport_fc_function_template_group0 = (struct Scsi_Host *)tmp;
  tmp___0 = ldv_init_zalloc(1504UL);
  bfad_im_vport_fc_function_template_group1 = (struct scsi_target *)tmp___0;
  return;
}
}
void ldv_initialize_fc_function_template_34(void) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
  tmp = ldv_init_zalloc(3816UL);
  bfad_im_fc_function_template_group0 = (struct Scsi_Host *)tmp;
  tmp___0 = ldv_init_zalloc(1504UL);
  bfad_im_fc_function_template_group2 = (struct scsi_target *)tmp___0;
  tmp___1 = ldv_init_zalloc(1648UL);
  bfad_im_fc_function_template_group1 = (struct fc_vport *)tmp___1;
  tmp___2 = ldv_init_zalloc(184UL);
  bfad_im_fc_function_template_group3 = (struct fc_bsg_job *)tmp___2;
  return;
}
}
void ldv_main_exported_27(void) 
{ 
  char *ldvarg36 ;
  void *tmp ;
  struct device *ldvarg35 ;
  void *tmp___0 ;
  struct device_attribute *ldvarg37 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
  tmp = ldv_init_zalloc(1UL);
  ldvarg36 = (char *)tmp;
  tmp___0 = ldv_init_zalloc(1416UL);
  ldvarg35 = (struct device *)tmp___0;
  tmp___1 = ldv_init_zalloc(48UL);
  ldvarg37 = (struct device_attribute *)tmp___1;
  tmp___2 = __VERIFIER_nondet_int();
  switch (tmp___2) {
  case 0: ;
  if (ldv_state_variable_27 == 1) {
    bfad_im_hw_version_show(ldvarg35, ldvarg37, ldvarg36);
    ldv_state_variable_27 = 1;
  } else {

  }
  goto ldv_48796;
  default: 
  ldv_stop();
  }
  ldv_48796: ;
  return;
}
}
void ldv_main_exported_25(void) 
{ 
  struct device *ldvarg38 ;
  void *tmp ;
  struct device_attribute *ldvarg40 ;
  void *tmp___0 ;
  char *ldvarg39 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
  tmp = ldv_init_zalloc(1416UL);
  ldvarg38 = (struct device *)tmp;
  tmp___0 = ldv_init_zalloc(48UL);
  ldvarg40 = (struct device_attribute *)tmp___0;
  tmp___1 = ldv_init_zalloc(1UL);
  ldvarg39 = (char *)tmp___1;
  tmp___2 = __VERIFIER_nondet_int();
  switch (tmp___2) {
  case 0: ;
  if (ldv_state_variable_25 == 1) {
    bfad_im_optionrom_version_show(ldvarg38, ldvarg40, ldvarg39);
    ldv_state_variable_25 = 1;
  } else {

  }
  goto ldv_48805;
  default: 
  ldv_stop();
  }
  ldv_48805: ;
  return;
}
}
void ldv_main_exported_33(void) 
{ 
  struct fc_rport *ldvarg0 ;
  void *tmp ;
  u32 ldvarg1 ;
  int tmp___0 ;

  {
  tmp = ldv_init_zalloc(2208UL);
  ldvarg0 = (struct fc_rport *)tmp;
  ldv_memset((void *)(& ldvarg1), 0, 4UL);
  tmp___0 = __VERIFIER_nondet_int();
  switch (tmp___0) {
  case 0: ;
  if (ldv_state_variable_33 == 1) {
    bfad_im_get_host_speed(bfad_im_vport_fc_function_template_group0);
    ldv_state_variable_33 = 1;
  } else {

  }
  goto ldv_48813;
  case 1: ;
  if (ldv_state_variable_33 == 1) {
    bfad_im_set_rport_loss_tmo(ldvarg0, ldvarg1);
    ldv_state_variable_33 = 1;
  } else {

  }
  goto ldv_48813;
  case 2: ;
  if (ldv_state_variable_33 == 1) {
    bfad_im_get_starget_port_id(bfad_im_vport_fc_function_template_group1);
    ldv_state_variable_33 = 1;
  } else {

  }
  goto ldv_48813;
  case 3: ;
  if (ldv_state_variable_33 == 1) {
    bfad_im_get_stats(bfad_im_vport_fc_function_template_group0);
    ldv_state_variable_33 = 1;
  } else {

  }
  goto ldv_48813;
  case 4: ;
  if (ldv_state_variable_33 == 1) {
    bfad_im_get_host_port_type(bfad_im_vport_fc_function_template_group0);
    ldv_state_variable_33 = 1;
  } else {

  }
  goto ldv_48813;
  case 5: ;
  if (ldv_state_variable_33 == 1) {
    bfad_im_get_starget_port_name(bfad_im_vport_fc_function_template_group1);
    ldv_state_variable_33 = 1;
  } else {

  }
  goto ldv_48813;
  case 6: ;
  if (ldv_state_variable_33 == 1) {
    bfad_im_reset_stats(bfad_im_vport_fc_function_template_group0);
    ldv_state_variable_33 = 1;
  } else {

  }
  goto ldv_48813;
  case 7: ;
  if (ldv_state_variable_33 == 1) {
    bfad_im_get_host_active_fc4s(bfad_im_vport_fc_function_template_group0);
    ldv_state_variable_33 = 1;
  } else {

  }
  goto ldv_48813;
  case 8: ;
  if (ldv_state_variable_33 == 1) {
    bfad_im_get_host_port_state(bfad_im_vport_fc_function_template_group0);
    ldv_state_variable_33 = 1;
  } else {

  }
  goto ldv_48813;
  case 9: ;
  if (ldv_state_variable_33 == 1) {
    bfad_im_get_host_fabric_name(bfad_im_vport_fc_function_template_group0);
    ldv_state_variable_33 = 1;
  } else {

  }
  goto ldv_48813;
  case 10: ;
  if (ldv_state_variable_33 == 1) {
    bfad_im_get_host_port_id(bfad_im_vport_fc_function_template_group0);
    ldv_state_variable_33 = 1;
  } else {

  }
  goto ldv_48813;
  case 11: ;
  if (ldv_state_variable_33 == 1) {
    bfad_im_get_starget_node_name(bfad_im_vport_fc_function_template_group1);
    ldv_state_variable_33 = 1;
  } else {

  }
  goto ldv_48813;
  default: 
  ldv_stop();
  }
  ldv_48813: ;
  return;
}
}
void ldv_main_exported_32(void) 
{ 
  struct device *ldvarg2 ;
  void *tmp ;
  char *ldvarg3 ;
  void *tmp___0 ;
  struct device_attribute *ldvarg4 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
  tmp = ldv_init_zalloc(1416UL);
  ldvarg2 = (struct device *)tmp;
  tmp___0 = ldv_init_zalloc(1UL);
  ldvarg3 = (char *)tmp___0;
  tmp___1 = ldv_init_zalloc(48UL);
  ldvarg4 = (struct device_attribute *)tmp___1;
  tmp___2 = __VERIFIER_nondet_int();
  switch (tmp___2) {
  case 0: ;
  if (ldv_state_variable_32 == 1) {
    bfad_im_serial_num_show(ldvarg2, ldvarg4, ldvarg3);
    ldv_state_variable_32 = 1;
  } else {

  }
  goto ldv_48833;
  default: 
  ldv_stop();
  }
  ldv_48833: ;
  return;
}
}
void ldv_main_exported_28(void) 
{ 
  char *ldvarg42 ;
  void *tmp ;
  struct device_attribute *ldvarg43 ;
  void *tmp___0 ;
  struct device *ldvarg41 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
  tmp = ldv_init_zalloc(1UL);
  ldvarg42 = (char *)tmp;
  tmp___0 = ldv_init_zalloc(48UL);
  ldvarg43 = (struct device_attribute *)tmp___0;
  tmp___1 = ldv_init_zalloc(1416UL);
  ldvarg41 = (struct device *)tmp___1;
  tmp___2 = __VERIFIER_nondet_int();
  switch (tmp___2) {
  case 0: ;
  if (ldv_state_variable_28 == 1) {
    bfad_im_symbolic_name_show(ldvarg41, ldvarg43, ldvarg42);
    ldv_state_variable_28 = 1;
  } else {

  }
  goto ldv_48842;
  default: 
  ldv_stop();
  }
  ldv_48842: ;
  return;
}
}
void ldv_main_exported_21(void) 
{ 
  char *ldvarg6 ;
  void *tmp ;
  struct device *ldvarg5 ;
  void *tmp___0 ;
  struct device_attribute *ldvarg7 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
  tmp = ldv_init_zalloc(1UL);
  ldvarg6 = (char *)tmp;
  tmp___0 = ldv_init_zalloc(1416UL);
  ldvarg5 = (struct device *)tmp___0;
  tmp___1 = ldv_init_zalloc(48UL);
  ldvarg7 = (struct device_attribute *)tmp___1;
  tmp___2 = __VERIFIER_nondet_int();
  switch (tmp___2) {
  case 0: ;
  if (ldv_state_variable_21 == 1) {
    bfad_im_num_of_discovered_ports_show(ldvarg5, ldvarg7, ldvarg6);
    ldv_state_variable_21 = 1;
  } else {

  }
  goto ldv_48851;
  default: 
  ldv_stop();
  }
  ldv_48851: ;
  return;
}
}
void ldv_main_exported_26(void) 
{ 
  char *ldvarg12 ;
  void *tmp ;
  struct device_attribute *ldvarg13 ;
  void *tmp___0 ;
  struct device *ldvarg11 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
  tmp = ldv_init_zalloc(1UL);
  ldvarg12 = (char *)tmp;
  tmp___0 = ldv_init_zalloc(48UL);
  ldvarg13 = (struct device_attribute *)tmp___0;
  tmp___1 = ldv_init_zalloc(1416UL);
  ldvarg11 = (struct device *)tmp___1;
  tmp___2 = __VERIFIER_nondet_int();
  switch (tmp___2) {
  case 0: ;
  if (ldv_state_variable_26 == 1) {
    bfad_im_drv_version_show(ldvarg11, ldvarg13, ldvarg12);
    ldv_state_variable_26 = 1;
  } else {

  }
  goto ldv_48860;
  default: 
  ldv_stop();
  }
  ldv_48860: ;
  return;
}
}
void ldv_main_exported_22(void) 
{ 
  struct device *ldvarg64 ;
  void *tmp ;
  struct device_attribute *ldvarg66 ;
  void *tmp___0 ;
  char *ldvarg65 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
  tmp = ldv_init_zalloc(1416UL);
  ldvarg64 = (struct device *)tmp;
  tmp___0 = ldv_init_zalloc(48UL);
  ldvarg66 = (struct device_attribute *)tmp___0;
  tmp___1 = ldv_init_zalloc(1UL);
  ldvarg65 = (char *)tmp___1;
  tmp___2 = __VERIFIER_nondet_int();
  switch (tmp___2) {
  case 0: ;
  if (ldv_state_variable_22 == 1) {
    bfad_im_drv_name_show(ldvarg64, ldvarg66, ldvarg65);
    ldv_state_variable_22 = 1;
  } else {

  }
  goto ldv_48869;
  default: 
  ldv_stop();
  }
  ldv_48869: ;
  return;
}
}
void ldv_main_exported_34(void) 
{ 
  bool ldvarg90 ;
  bool ldvarg89 ;
  u32 ldvarg92 ;
  struct fc_rport *ldvarg91 ;
  void *tmp ;
  int tmp___0 ;

  {
  tmp = ldv_init_zalloc(2208UL);
  ldvarg91 = (struct fc_rport *)tmp;
  ldv_memset((void *)(& ldvarg90), 0, 1UL);
  ldv_memset((void *)(& ldvarg89), 0, 1UL);
  ldv_memset((void *)(& ldvarg92), 0, 4UL);
  tmp___0 = __VERIFIER_nondet_int();
  switch (tmp___0) {
  case 0: ;
  if (ldv_state_variable_34 == 1) {
    bfad_im_get_host_speed(bfad_im_fc_function_template_group0);
    ldv_state_variable_34 = 1;
  } else {

  }
  goto ldv_48879;
  case 1: ;
  if (ldv_state_variable_34 == 1) {
    bfad_im_issue_fc_host_lip(bfad_im_fc_function_template_group0);
    ldv_state_variable_34 = 1;
  } else {

  }
  goto ldv_48879;
  case 2: ;
  if (ldv_state_variable_34 == 1) {
    bfad_im_set_rport_loss_tmo(ldvarg91, ldvarg92);
    ldv_state_variable_34 = 1;
  } else {

  }
  goto ldv_48879;
  case 3: ;
  if (ldv_state_variable_34 == 1) {
    bfad_im_get_starget_port_id(bfad_im_fc_function_template_group2);
    ldv_state_variable_34 = 1;
  } else {

  }
  goto ldv_48879;
  case 4: ;
  if (ldv_state_variable_34 == 1) {
    bfad_im_vport_set_symbolic_name(bfad_im_fc_function_template_group1);
    ldv_state_variable_34 = 1;
  } else {

  }
  goto ldv_48879;
  case 5: ;
  if (ldv_state_variable_34 == 1) {
    bfad_im_get_stats(bfad_im_fc_function_template_group0);
    ldv_state_variable_34 = 1;
  } else {

  }
  goto ldv_48879;
  case 6: ;
  if (ldv_state_variable_34 == 1) {
    bfad_im_get_host_port_type(bfad_im_fc_function_template_group0);
    ldv_state_variable_34 = 1;
  } else {

  }
  goto ldv_48879;
  case 7: ;
  if (ldv_state_variable_34 == 1) {
    bfad_im_get_starget_port_name(bfad_im_fc_function_template_group2);
    ldv_state_variable_34 = 1;
  } else {

  }
  goto ldv_48879;
  case 8: ;
  if (ldv_state_variable_34 == 1) {
    bfad_im_bsg_timeout(bfad_im_fc_function_template_group3);
    ldv_state_variable_34 = 1;
  } else {

  }
  goto ldv_48879;
  case 9: ;
  if (ldv_state_variable_34 == 1) {
    bfad_im_reset_stats(bfad_im_fc_function_template_group0);
    ldv_state_variable_34 = 1;
  } else {

  }
  goto ldv_48879;
  case 10: ;
  if (ldv_state_variable_34 == 1) {
    bfad_im_get_host_active_fc4s(bfad_im_fc_function_template_group0);
    ldv_state_variable_34 = 1;
  } else {

  }
  goto ldv_48879;
  case 11: ;
  if (ldv_state_variable_34 == 1) {
    bfad_im_vport_delete(bfad_im_fc_function_template_group1);
    ldv_state_variable_34 = 1;
  } else {

  }
  goto ldv_48879;
  case 12: ;
  if (ldv_state_variable_34 == 1) {
    bfad_im_bsg_request(bfad_im_fc_function_template_group3);
    ldv_state_variable_34 = 1;
  } else {

  }
  goto ldv_48879;
  case 13: ;
  if (ldv_state_variable_34 == 1) {
    bfad_im_vport_create(bfad_im_fc_function_template_group1, (int )ldvarg90);
    ldv_state_variable_34 = 1;
  } else {

  }
  goto ldv_48879;
  case 14: ;
  if (ldv_state_variable_34 == 1) {
    bfad_im_vport_disable(bfad_im_fc_function_template_group1, (int )ldvarg89);
    ldv_state_variable_34 = 1;
  } else {

  }
  goto ldv_48879;
  case 15: ;
  if (ldv_state_variable_34 == 1) {
    bfad_im_get_host_port_state(bfad_im_fc_function_template_group0);
    ldv_state_variable_34 = 1;
  } else {

  }
  goto ldv_48879;
  case 16: ;
  if (ldv_state_variable_34 == 1) {
    bfad_im_get_host_fabric_name(bfad_im_fc_function_template_group0);
    ldv_state_variable_34 = 1;
  } else {

  }
  goto ldv_48879;
  case 17: ;
  if (ldv_state_variable_34 == 1) {
    bfad_im_get_host_port_id(bfad_im_fc_function_template_group0);
    ldv_state_variable_34 = 1;
  } else {

  }
  goto ldv_48879;
  case 18: ;
  if (ldv_state_variable_34 == 1) {
    bfad_im_get_starget_node_name(bfad_im_fc_function_template_group2);
    ldv_state_variable_34 = 1;
  } else {

  }
  goto ldv_48879;
  default: 
  ldv_stop();
  }
  ldv_48879: ;
  return;
}
}
void ldv_main_exported_30(void) 
{ 
  char *ldvarg28 ;
  void *tmp ;
  struct device_attribute *ldvarg29 ;
  void *tmp___0 ;
  struct device *ldvarg27 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
  tmp = ldv_init_zalloc(1UL);
  ldvarg28 = (char *)tmp;
  tmp___0 = ldv_init_zalloc(48UL);
  ldvarg29 = (struct device_attribute *)tmp___0;
  tmp___1 = ldv_init_zalloc(1416UL);
  ldvarg27 = (struct device *)tmp___1;
  tmp___2 = __VERIFIER_nondet_int();
  switch (tmp___2) {
  case 0: ;
  if (ldv_state_variable_30 == 1) {
    bfad_im_model_desc_show(ldvarg27, ldvarg29, ldvarg28);
    ldv_state_variable_30 = 1;
  } else {

  }
  goto ldv_48906;
  default: 
  ldv_stop();
  }
  ldv_48906: ;
  return;
}
}
void ldv_main_exported_24(void) 
{ 
  struct device *ldvarg52 ;
  void *tmp ;
  char *ldvarg53 ;
  void *tmp___0 ;
  struct device_attribute *ldvarg54 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
  tmp = ldv_init_zalloc(1416UL);
  ldvarg52 = (struct device *)tmp;
  tmp___0 = ldv_init_zalloc(1UL);
  ldvarg53 = (char *)tmp___0;
  tmp___1 = ldv_init_zalloc(48UL);
  ldvarg54 = (struct device_attribute *)tmp___1;
  tmp___2 = __VERIFIER_nondet_int();
  switch (tmp___2) {
  case 0: ;
  if (ldv_state_variable_24 == 1) {
    bfad_im_fw_version_show(ldvarg52, ldvarg54, ldvarg53);
    ldv_state_variable_24 = 1;
  } else {

  }
  goto ldv_48915;
  default: 
  ldv_stop();
  }
  ldv_48915: ;
  return;
}
}
void ldv_main_exported_23(void) 
{ 
  struct device_attribute *ldvarg72 ;
  void *tmp ;
  char *ldvarg71 ;
  void *tmp___0 ;
  struct device *ldvarg70 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
  tmp = ldv_init_zalloc(48UL);
  ldvarg72 = (struct device_attribute *)tmp;
  tmp___0 = ldv_init_zalloc(1UL);
  ldvarg71 = (char *)tmp___0;
  tmp___1 = ldv_init_zalloc(1416UL);
  ldvarg70 = (struct device *)tmp___1;
  tmp___2 = __VERIFIER_nondet_int();
  switch (tmp___2) {
  case 0: ;
  if (ldv_state_variable_23 == 1) {
    bfad_im_num_of_ports_show(ldvarg70, ldvarg72, ldvarg71);
    ldv_state_variable_23 = 1;
  } else {

  }
  goto ldv_48924;
  default: 
  ldv_stop();
  }
  ldv_48924: ;
  return;
}
}
void ldv_main_exported_31(void) 
{ 
  char *ldvarg59 ;
  void *tmp ;
  struct device_attribute *ldvarg60 ;
  void *tmp___0 ;
  struct device *ldvarg58 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
  tmp = ldv_init_zalloc(1UL);
  ldvarg59 = (char *)tmp;
  tmp___0 = ldv_init_zalloc(48UL);
  ldvarg60 = (struct device_attribute *)tmp___0;
  tmp___1 = ldv_init_zalloc(1416UL);
  ldvarg58 = (struct device *)tmp___1;
  tmp___2 = __VERIFIER_nondet_int();
  switch (tmp___2) {
  case 0: ;
  if (ldv_state_variable_31 == 1) {
    bfad_im_model_show(ldvarg58, ldvarg60, ldvarg59);
    ldv_state_variable_31 = 1;
  } else {

  }
  goto ldv_48933;
  default: 
  ldv_stop();
  }
  ldv_48933: ;
  return;
}
}
void ldv_main_exported_29(void) 
{ 
  struct device_attribute *ldvarg75 ;
  void *tmp ;
  char *ldvarg74 ;
  void *tmp___0 ;
  struct device *ldvarg73 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
  tmp = ldv_init_zalloc(48UL);
  ldvarg75 = (struct device_attribute *)tmp;
  tmp___0 = ldv_init_zalloc(1UL);
  ldvarg74 = (char *)tmp___0;
  tmp___1 = ldv_init_zalloc(1416UL);
  ldvarg73 = (struct device *)tmp___1;
  tmp___2 = __VERIFIER_nondet_int();
  switch (tmp___2) {
  case 0: ;
  if (ldv_state_variable_29 == 1) {
    bfad_im_node_name_show(ldvarg73, ldvarg75, ldvarg74);
    ldv_state_variable_29 = 1;
  } else {

  }
  goto ldv_48942;
  default: 
  ldv_stop();
  }
  ldv_48942: ;
  return;
}
}
bool ldv_queue_work_on_135(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_3(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_delayed_work_on_136(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_3(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_work_on_137(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_3(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
void ldv_flush_workqueue_138(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
  flush_workqueue(ldv_func_arg1);
  call_and_disable_all_3(2);
  return;
}
}
bool ldv_queue_delayed_work_on_139(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_3(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
void ldv_mutex_lock_140(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_lock_lock(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_141(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_unlock_lock(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_142(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
int ldv_mutex_trylock_143(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
  tmp = mutex_trylock(ldv_func_arg1);
  ldv_func_res = tmp;
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
  return (tmp___0);
  return (ldv_func_res);
}
}
void ldv_mutex_unlock_144(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_145(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_unlock_i_mutex_of_inode(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_146(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_lock_i_mutex_of_inode(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
int ldv_scsi_add_host_with_dma_147(struct Scsi_Host *shost , struct device *dev ,
                                   struct device *dma_dev ) 
{ 
  ldv_func_ret_type___4 ldv_func_res ;
  int tmp ;

  {
  tmp = scsi_add_host_with_dma(shost, dev, dma_dev);
  ldv_func_res = tmp;
  if (ldv_func_res == 0) {
    ldv_state_variable_35 = 1;
    ldv_initialize_scsi_host_template_35();
  } else {

  }
  return (ldv_func_res);
}
}
extern int sscanf(char const   * , char const   *  , ...) ;
long ldv_ptr_err(void const   *ptr ) ;
extern void *memdup_user(void const   * , size_t  ) ;
__inline static long PTR_ERR(void const   *ptr ) ;
__inline static bool IS_ERR(void const   *ptr ) ;
int ldv_mutex_trylock_175(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_170(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_173(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_176(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_171(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_172(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_174(struct mutex *ldv_func_arg1 ) ;
bool ldv_queue_work_on_165(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_work_on_167(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_delayed_work_on_166(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
bool ldv_queue_delayed_work_on_169(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
void ldv_flush_workqueue_168(struct workqueue_struct *ldv_func_arg1 ) ;
__inline static unsigned int readl(void const volatile   *addr ) 
{ 
  unsigned int ret ;

  {
  __asm__  volatile   ("movl %1,%0": "=r" (ret): "m" (*((unsigned int volatile   *)addr)): "memory");
  return (ret);
}
}
__inline static void writel(unsigned int val , void volatile   *addr ) 
{ 


  {
  __asm__  volatile   ("movl %0,%1": : "r" (val), "m" (*((unsigned int volatile   *)addr)): "memory");
  return;
}
}
extern loff_t fixed_size_llseek(struct file * , loff_t  , int  , loff_t  ) ;
extern ssize_t simple_read_from_buffer(void * , size_t  , loff_t * , void const   * ,
                                       size_t  ) ;
int ldv_scsi_add_host_with_dma_177(struct Scsi_Host *shost , struct device *dev ,
                                   struct device *dma_dev ) ;
enum bfa_status bfa_ioc_debug_fwsave(struct bfa_ioc_s *ioc , void *trcdata , int *trclen ) ;
enum bfa_status bfa_ioc_debug_fwtrc(struct bfa_ioc_s *ioc , void *trcdata , int *trclen ) ;
static int bfad_debugfs_open_drvtrc(struct inode *inode , struct file *file ) 
{ 
  struct bfad_port_s *port ;
  struct bfad_s *bfad ;
  struct bfad_debug_info *debug ;
  void *tmp ;

  {
  port = (struct bfad_port_s *)inode->i_private;
  bfad = port->bfad;
  tmp = kzalloc(24UL, 208U);
  debug = (struct bfad_debug_info *)tmp;
  if ((unsigned long )debug == (unsigned long )((struct bfad_debug_info *)0)) {
    return (-12);
  } else {

  }
  debug->debug_buffer = (char *)bfad->trcmod;
  debug->buffer_len = 65568;
  file->private_data = (void *)debug;
  return (0);
}
}
static int bfad_debugfs_open_fwtrc(struct inode *inode , struct file *file ) 
{ 
  struct bfad_port_s *port ;
  struct bfad_s *bfad ;
  struct bfad_debug_info *fw_debug ;
  unsigned long flags ;
  int rc ;
  void *tmp ;
  void *tmp___0 ;
  raw_spinlock_t *tmp___1 ;
  enum bfa_status tmp___2 ;

  {
  port = (struct bfad_port_s *)inode->i_private;
  bfad = port->bfad;
  tmp = kzalloc(24UL, 208U);
  fw_debug = (struct bfad_debug_info *)tmp;
  if ((unsigned long )fw_debug == (unsigned long )((struct bfad_debug_info *)0)) {
    return (-12);
  } else {

  }
  fw_debug->buffer_len = 65568;
  tmp___0 = vmalloc((unsigned long )fw_debug->buffer_len);
  fw_debug->debug_buffer = (char *)tmp___0;
  if ((unsigned long )fw_debug->debug_buffer == (unsigned long )((char *)0)) {
    kfree((void const   *)fw_debug);
    printk("\016bfad[%d]: Failed to allocate fwtrc buffer\n", bfad->inst_no);
    return (-12);
  } else {

  }
  memset((void *)fw_debug->debug_buffer, 0, (size_t )fw_debug->buffer_len);
  tmp___1 = spinlock_check(& bfad->bfad_lock);
  flags = _raw_spin_lock_irqsave(tmp___1);
  tmp___2 = bfa_ioc_debug_fwtrc(& bfad->bfa.ioc, (void *)fw_debug->debug_buffer, & fw_debug->buffer_len);
  rc = (int )tmp___2;
  spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  if (rc != 0) {
    vfree((void const   *)fw_debug->debug_buffer);
    fw_debug->debug_buffer = (char *)0;
    kfree((void const   *)fw_debug);
    printk("\016bfad[%d]: Failed to collect fwtrc\n", bfad->inst_no);
    return (-12);
  } else {

  }
  file->private_data = (void *)fw_debug;
  return (0);
}
}
static int bfad_debugfs_open_fwsave(struct inode *inode , struct file *file ) 
{ 
  struct bfad_port_s *port ;
  struct bfad_s *bfad ;
  struct bfad_debug_info *fw_debug ;
  unsigned long flags ;
  int rc ;
  void *tmp ;
  void *tmp___0 ;
  raw_spinlock_t *tmp___1 ;
  enum bfa_status tmp___2 ;

  {
  port = (struct bfad_port_s *)inode->i_private;
  bfad = port->bfad;
  tmp = kzalloc(24UL, 208U);
  fw_debug = (struct bfad_debug_info *)tmp;
  if ((unsigned long )fw_debug == (unsigned long )((struct bfad_debug_info *)0)) {
    return (-12);
  } else {

  }
  fw_debug->buffer_len = 65568;
  tmp___0 = vmalloc((unsigned long )fw_debug->buffer_len);
  fw_debug->debug_buffer = (char *)tmp___0;
  if ((unsigned long )fw_debug->debug_buffer == (unsigned long )((char *)0)) {
    kfree((void const   *)fw_debug);
    printk("\016bfad[%d]: Failed to allocate fwsave buffer\n", bfad->inst_no);
    return (-12);
  } else {

  }
  memset((void *)fw_debug->debug_buffer, 0, (size_t )fw_debug->buffer_len);
  tmp___1 = spinlock_check(& bfad->bfad_lock);
  flags = _raw_spin_lock_irqsave(tmp___1);
  tmp___2 = bfa_ioc_debug_fwsave(& bfad->bfa.ioc, (void *)fw_debug->debug_buffer,
                                 & fw_debug->buffer_len);
  rc = (int )tmp___2;
  spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  if (rc != 0) {
    vfree((void const   *)fw_debug->debug_buffer);
    fw_debug->debug_buffer = (char *)0;
    kfree((void const   *)fw_debug);
    printk("\016bfad[%d]: Failed to collect fwsave\n", bfad->inst_no);
    return (-12);
  } else {

  }
  file->private_data = (void *)fw_debug;
  return (0);
}
}
static int bfad_debugfs_open_reg(struct inode *inode , struct file *file ) 
{ 
  struct bfad_debug_info *reg_debug ;
  void *tmp ;

  {
  tmp = kzalloc(24UL, 208U);
  reg_debug = (struct bfad_debug_info *)tmp;
  if ((unsigned long )reg_debug == (unsigned long )((struct bfad_debug_info *)0)) {
    return (-12);
  } else {

  }
  reg_debug->i_private = inode->i_private;
  file->private_data = (void *)reg_debug;
  return (0);
}
}
static loff_t bfad_debugfs_lseek(struct file *file , loff_t offset , int orig ) 
{ 
  struct bfad_debug_info *debug ;
  loff_t tmp ;

  {
  debug = (struct bfad_debug_info *)file->private_data;
  tmp = fixed_size_llseek(file, offset, orig, (loff_t )debug->buffer_len);
  return (tmp);
}
}
static ssize_t bfad_debugfs_read(struct file *file , char *buf , size_t nbytes , loff_t *pos ) 
{ 
  struct bfad_debug_info *debug ;
  ssize_t tmp ;

  {
  debug = (struct bfad_debug_info *)file->private_data;
  if ((unsigned long )debug == (unsigned long )((struct bfad_debug_info *)0) || (unsigned long )debug->debug_buffer == (unsigned long )((char *)0)) {
    return (0L);
  } else {

  }
  tmp = simple_read_from_buffer((void *)buf, nbytes, pos, (void const   *)debug->debug_buffer,
                                (size_t )debug->buffer_len);
  return (tmp);
}
}
static enum bfa_status bfad_reg_offset_check(struct bfa_s *bfa , u32 offset , u32 len ) 
{ 
  u8 area ;

  {
  area = (unsigned int )((u8 )(offset >> 15)) & 7U;
  if ((unsigned int )area == 0U) {
    if ((len << 2) + offset > 32768U) {
      return (2);
    } else {

    }
  } else
  if ((unsigned int )area == 1U) {
    if ((len << 2) + offset > 65536U) {
      return (2);
    } else {

    }
  } else
  if ((len << 2) + offset > (((unsigned int )bfa->ioc.pcidev.device_id == 20U || (unsigned int )bfa->ioc.pcidev.device_id == 33U) || ((unsigned int )bfa->ioc.pcidev.device_id == 34U || (unsigned int )bfa->ioc.pcidev.device_id == 35U) ? 262143U : 131071U)) {
    return (2);
  } else {

  }
  return (0);
}
}
static ssize_t bfad_debugfs_read_regrd(struct file *file , char *buf , size_t nbytes ,
                                       loff_t *pos ) 
{ 
  struct bfad_debug_info *regrd_debug ;
  struct bfad_port_s *port ;
  struct bfad_s *bfad ;
  ssize_t rc ;

  {
  regrd_debug = (struct bfad_debug_info *)file->private_data;
  port = (struct bfad_port_s *)regrd_debug->i_private;
  bfad = port->bfad;
  if ((unsigned long )bfad->regdata == (unsigned long )((char *)0)) {
    return (0L);
  } else {

  }
  rc = simple_read_from_buffer((void *)buf, nbytes, pos, (void const   *)bfad->regdata,
                               (size_t )bfad->reglen);
  if ((unsigned long long )*pos + (unsigned long long )nbytes >= (unsigned long long )bfad->reglen) {
    kfree((void const   *)bfad->regdata);
    bfad->regdata = (char *)0;
    bfad->reglen = 0U;
  } else {

  }
  return (rc);
}
}
static ssize_t bfad_debugfs_write_regrd(struct file *file , char const   *buf , size_t nbytes ,
                                        loff_t *ppos ) 
{ 
  struct bfad_debug_info *regrd_debug ;
  struct bfad_port_s *port ;
  struct bfad_s *bfad ;
  struct bfa_s *bfa ;
  struct bfa_ioc_s *ioc ;
  int addr ;
    klee_make_symbolic(&addr, sizeof(int), "addr");
  int len ;
  int rc ;
  int i ;
  u32 *regbuf ;
  void *rb ;
  void *reg_addr ;
  unsigned long flags ;
  void *kern_buf ;
  long tmp ;
  bool tmp___0 ;
  void *tmp___1 ;
  enum bfa_status tmp___2 ;
  raw_spinlock_t *tmp___3 ;

  {
  regrd_debug = (struct bfad_debug_info *)file->private_data;
  port = (struct bfad_port_s *)regrd_debug->i_private;
  bfad = port->bfad;
  bfa = & bfad->bfa;
  ioc = & bfa->ioc;
  kern_buf = memdup_user((void const   *)buf, nbytes);
  tmp___0 = IS_ERR((void const   *)kern_buf);
  if ((int )tmp___0) {
    tmp = PTR_ERR((void const   *)kern_buf);
    return (tmp);
  } else {

  }
  rc = sscanf((char const   *)kern_buf, "%x:%x", & addr, & len);
  if (rc <= 1) {
    printk("\016bfad[%d]: %s failed to read user buf\n", bfad->inst_no, "bfad_debugfs_write_regrd");
    kfree((void const   *)kern_buf);
    return (-22L);
  } else {

  }
  kfree((void const   *)kern_buf);
  kfree((void const   *)bfad->regdata);
  bfad->regdata = (char *)0;
  bfad->reglen = 0U;
  tmp___1 = kzalloc((size_t )(len << 2), 208U);
  bfad->regdata = (char *)tmp___1;
  if ((unsigned long )bfad->regdata == (unsigned long )((char *)0)) {
    printk("\016bfad[%d]: Failed to allocate regrd buffer\n", bfad->inst_no);
    return (-12L);
  } else {

  }
  bfad->reglen = (u32 )(len << 2);
  rb = ioc->pcidev.pci_bar_kva;
  addr = (int )((((unsigned int )ioc->pcidev.device_id == 20U || (unsigned int )ioc->pcidev.device_id == 33U) || ((unsigned int )ioc->pcidev.device_id == 34U || (unsigned int )ioc->pcidev.device_id == 35U) ? 262143U : 131071U) & (unsigned int )addr);
  tmp___2 = bfad_reg_offset_check(bfa, (u32 )addr, (u32 )len);
  rc = (int )tmp___2;
  if (rc != 0) {
    printk("\016bfad[%d]: Failed reg offset check\n", bfad->inst_no);
    kfree((void const   *)bfad->regdata);
    bfad->regdata = (char *)0;
    bfad->reglen = 0U;
    return (-22L);
  } else {

  }
  reg_addr = rb + (unsigned long )addr;
  regbuf = (u32 *)bfad->regdata;
  tmp___3 = spinlock_check(& bfad->bfad_lock);
  flags = _raw_spin_lock_irqsave(tmp___3);
  i = 0;
  goto ldv_48498;
  ldv_48497: 
  *regbuf = readl((void const volatile   *)reg_addr);
  regbuf = regbuf + 1;
  reg_addr = reg_addr + 4UL;
  i = i + 1;
  ldv_48498: ;
  if (i < len) {
    goto ldv_48497;
  } else {

  }
  spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  return ((ssize_t )nbytes);
}
}
static ssize_t bfad_debugfs_write_regwr(struct file *file , char const   *buf , size_t nbytes ,
                                        loff_t *ppos ) 
{ 
  struct bfad_debug_info *debug ;
  struct bfad_port_s *port ;
  struct bfad_s *bfad ;
  struct bfa_s *bfa ;
  struct bfa_ioc_s *ioc ;
  int addr ;
  int val ;
    klee_make_symbolic(&val, sizeof(int), "val");
  int rc ;
  void *reg_addr ;
  unsigned long flags ;
  void *kern_buf ;
  long tmp ;
  bool tmp___0 ;
  enum bfa_status tmp___1 ;
  raw_spinlock_t *tmp___2 ;

  {
  debug = (struct bfad_debug_info *)file->private_data;
  port = (struct bfad_port_s *)debug->i_private;
  bfad = port->bfad;
  bfa = & bfad->bfa;
  ioc = & bfa->ioc;
  kern_buf = memdup_user((void const   *)buf, nbytes);
  tmp___0 = IS_ERR((void const   *)kern_buf);
  if ((int )tmp___0) {
    tmp = PTR_ERR((void const   *)kern_buf);
    return (tmp);
  } else {

  }
  rc = sscanf((char const   *)kern_buf, "%x:%x", & addr, & val);
  if (rc <= 1) {
    printk("\016bfad[%d]: %s failed to read user buf\n", bfad->inst_no, "bfad_debugfs_write_regwr");
    kfree((void const   *)kern_buf);
    return (-22L);
  } else {

  }
  kfree((void const   *)kern_buf);
  addr = (int )((((unsigned int )ioc->pcidev.device_id == 20U || (unsigned int )ioc->pcidev.device_id == 33U) || ((unsigned int )ioc->pcidev.device_id == 34U || (unsigned int )ioc->pcidev.device_id == 35U) ? 262143U : 131071U) & (unsigned int )addr);
  tmp___1 = bfad_reg_offset_check(bfa, (u32 )addr, 1U);
  rc = (int )tmp___1;
  if (rc != 0) {
    printk("\016bfad[%d]: Failed reg offset check\n", bfad->inst_no);
    return (-22L);
  } else {

  }
  reg_addr = ioc->pcidev.pci_bar_kva + (unsigned long )addr;
  tmp___2 = spinlock_check(& bfad->bfad_lock);
  flags = _raw_spin_lock_irqsave(tmp___2);
  writel((unsigned int )val, (void volatile   *)reg_addr);
  spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  return ((ssize_t )nbytes);
}
}
static int bfad_debugfs_release(struct inode *inode , struct file *file ) 
{ 
  struct bfad_debug_info *debug ;

  {
  debug = (struct bfad_debug_info *)file->private_data;
  if ((unsigned long )debug == (unsigned long )((struct bfad_debug_info *)0)) {
    return (0);
  } else {

  }
  file->private_data = (void *)0;
  kfree((void const   *)debug);
  return (0);
}
}
static int bfad_debugfs_release_fwtrc(struct inode *inode , struct file *file ) 
{ 
  struct bfad_debug_info *fw_debug ;

  {
  fw_debug = (struct bfad_debug_info *)file->private_data;
  if ((unsigned long )fw_debug == (unsigned long )((struct bfad_debug_info *)0)) {
    return (0);
  } else {

  }
  if ((unsigned long )fw_debug->debug_buffer != (unsigned long )((char *)0)) {
    vfree((void const   *)fw_debug->debug_buffer);
  } else {

  }
  file->private_data = (void *)0;
  kfree((void const   *)fw_debug);
  return (0);
}
}
int ldv_retval_0  ;
    klee_make_symbolic(&ldv_retval_0, sizeof(int), "ldv_retval_0");
int ldv_retval_6  ;
    klee_make_symbolic(&ldv_retval_6, sizeof(int), "ldv_retval_6");
int ldv_retval_1  ;
    klee_make_symbolic(&ldv_retval_1, sizeof(int), "ldv_retval_1");
int ldv_retval_3  ;
    klee_make_symbolic(&ldv_retval_3, sizeof(int), "ldv_retval_3");
int ldv_retval_2  ;
    klee_make_symbolic(&ldv_retval_2, sizeof(int), "ldv_retval_2");
void ldv_file_operations_20(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
  tmp = ldv_init_zalloc(1000UL);
  bfad_debugfs_op_drvtrc_group1 = (struct inode *)tmp;
  tmp___0 = ldv_init_zalloc(504UL);
  bfad_debugfs_op_drvtrc_group2 = (struct file *)tmp___0;
  return;
}
}
void ldv_file_operations_19(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
  tmp = ldv_init_zalloc(1000UL);
  bfad_debugfs_op_fwtrc_group1 = (struct inode *)tmp;
  tmp___0 = ldv_init_zalloc(504UL);
  bfad_debugfs_op_fwtrc_group2 = (struct file *)tmp___0;
  return;
}
}
void ldv_file_operations_16(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
  tmp = ldv_init_zalloc(1000UL);
  bfad_debugfs_op_regwr_group1 = (struct inode *)tmp;
  tmp___0 = ldv_init_zalloc(504UL);
  bfad_debugfs_op_regwr_group2 = (struct file *)tmp___0;
  return;
}
}
void ldv_file_operations_17(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
  tmp = ldv_init_zalloc(1000UL);
  bfad_debugfs_op_regrd_group1 = (struct inode *)tmp;
  tmp___0 = ldv_init_zalloc(504UL);
  bfad_debugfs_op_regrd_group2 = (struct file *)tmp___0;
  return;
}
}
void ldv_file_operations_18(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
  tmp = ldv_init_zalloc(1000UL);
  bfad_debugfs_op_fwsave_group1 = (struct inode *)tmp;
  tmp___0 = ldv_init_zalloc(504UL);
  bfad_debugfs_op_fwsave_group2 = (struct file *)tmp___0;
  return;
}
}
void ldv_main_exported_18(void) 
{ 
  int ldvarg22 ;
    klee_make_symbolic(&ldvarg22, sizeof(int), "ldvarg22");
  loff_t ldvarg23 ;
  size_t ldvarg25 ;
  char *ldvarg26 ;
  void *tmp ;
  loff_t *ldvarg24 ;
  void *tmp___0 ;
  int tmp___1 ;

  {
  tmp = ldv_init_zalloc(1UL);
  ldvarg26 = (char *)tmp;
  tmp___0 = ldv_init_zalloc(8UL);
  ldvarg24 = (loff_t *)tmp___0;
  ldv_memset((void *)(& ldvarg22), 0, 4UL);
  ldv_memset((void *)(& ldvarg23), 0, 8UL);
  ldv_memset((void *)(& ldvarg25), 0, 8UL);
  tmp___1 = __VERIFIER_nondet_int();
  switch (tmp___1) {
  case 0: ;
  if (ldv_state_variable_18 == 1) {
    ldv_retval_1 = bfad_debugfs_open_fwsave(bfad_debugfs_op_fwsave_group1, bfad_debugfs_op_fwsave_group2);
    if (ldv_retval_1 == 0) {
      ldv_state_variable_18 = 2;
      ref_cnt = ref_cnt + 1;
    } else {

    }
  } else {

  }
  goto ldv_48595;
  case 1: ;
  if (ldv_state_variable_18 == 2) {
    bfad_debugfs_release_fwtrc(bfad_debugfs_op_fwsave_group1, bfad_debugfs_op_fwsave_group2);
    ldv_state_variable_18 = 1;
    ref_cnt = ref_cnt - 1;
  } else {

  }
  goto ldv_48595;
  case 2: ;
  if (ldv_state_variable_18 == 2) {
    bfad_debugfs_read(bfad_debugfs_op_fwsave_group2, ldvarg26, ldvarg25, ldvarg24);
    ldv_state_variable_18 = 2;
  } else {

  }
  goto ldv_48595;
  case 3: ;
  if (ldv_state_variable_18 == 2) {
    bfad_debugfs_lseek(bfad_debugfs_op_fwsave_group2, ldvarg23, ldvarg22);
    ldv_state_variable_18 = 2;
  } else {

  }
  goto ldv_48595;
  default: 
  ldv_stop();
  }
  ldv_48595: ;
  return;
}
}
void ldv_main_exported_19(void) 
{ 
  loff_t *ldvarg96 ;
  void *tmp ;
  int ldvarg94 ;
    klee_make_symbolic(&ldvarg94, sizeof(int), "ldvarg94");
  size_t ldvarg97 ;
  loff_t ldvarg95 ;
  char *ldvarg98 ;
  void *tmp___0 ;
  int tmp___1 ;

  {
  tmp = ldv_init_zalloc(8UL);
  ldvarg96 = (loff_t *)tmp;
  tmp___0 = ldv_init_zalloc(1UL);
  ldvarg98 = (char *)tmp___0;
  ldv_memset((void *)(& ldvarg94), 0, 4UL);
  ldv_memset((void *)(& ldvarg97), 0, 8UL);
  ldv_memset((void *)(& ldvarg95), 0, 8UL);
  tmp___1 = __VERIFIER_nondet_int();
  switch (tmp___1) {
  case 0: ;
  if (ldv_state_variable_19 == 1) {
    ldv_retval_6 = bfad_debugfs_open_fwtrc(bfad_debugfs_op_fwtrc_group1, bfad_debugfs_op_fwtrc_group2);
    if (ldv_retval_6 == 0) {
      ldv_state_variable_19 = 2;
      ref_cnt = ref_cnt + 1;
    } else {

    }
  } else {

  }
  goto ldv_48609;
  case 1: ;
  if (ldv_state_variable_19 == 2) {
    bfad_debugfs_release_fwtrc(bfad_debugfs_op_fwtrc_group1, bfad_debugfs_op_fwtrc_group2);
    ldv_state_variable_19 = 1;
    ref_cnt = ref_cnt - 1;
  } else {

  }
  goto ldv_48609;
  case 2: ;
  if (ldv_state_variable_19 == 2) {
    bfad_debugfs_read(bfad_debugfs_op_fwtrc_group2, ldvarg98, ldvarg97, ldvarg96);
    ldv_state_variable_19 = 2;
  } else {

  }
  goto ldv_48609;
  case 3: ;
  if (ldv_state_variable_19 == 2) {
    bfad_debugfs_lseek(bfad_debugfs_op_fwtrc_group2, ldvarg95, ldvarg94);
    ldv_state_variable_19 = 2;
  } else {

  }
  goto ldv_48609;
  default: 
  ldv_stop();
  }
  ldv_48609: ;
  return;
}
}
void ldv_main_exported_16(void) 
{ 
  int ldvarg30 ;
    klee_make_symbolic(&ldvarg30, sizeof(int), "ldvarg30");
  size_t ldvarg33 ;
  char *ldvarg34 ;
  void *tmp ;
  loff_t ldvarg31 ;
  loff_t *ldvarg32 ;
  void *tmp___0 ;
  int tmp___1 ;

  {
  tmp = ldv_init_zalloc(1UL);
  ldvarg34 = (char *)tmp;
  tmp___0 = ldv_init_zalloc(8UL);
  ldvarg32 = (loff_t *)tmp___0;
  ldv_memset((void *)(& ldvarg30), 0, 4UL);
  ldv_memset((void *)(& ldvarg33), 0, 8UL);
  ldv_memset((void *)(& ldvarg31), 0, 8UL);
  tmp___1 = __VERIFIER_nondet_int();
  switch (tmp___1) {
  case 0: ;
  if (ldv_state_variable_16 == 1) {
    ldv_retval_2 = bfad_debugfs_open_reg(bfad_debugfs_op_regwr_group1, bfad_debugfs_op_regwr_group2);
    if (ldv_retval_2 == 0) {
      ldv_state_variable_16 = 2;
      ref_cnt = ref_cnt + 1;
    } else {

    }
  } else {

  }
  goto ldv_48623;
  case 1: ;
  if (ldv_state_variable_16 == 2) {
    bfad_debugfs_release(bfad_debugfs_op_regwr_group1, bfad_debugfs_op_regwr_group2);
    ldv_state_variable_16 = 1;
    ref_cnt = ref_cnt - 1;
  } else {

  }
  goto ldv_48623;
  case 2: ;
  if (ldv_state_variable_16 == 1) {
    bfad_debugfs_write_regwr(bfad_debugfs_op_regwr_group2, (char const   *)ldvarg34,
                             ldvarg33, ldvarg32);
    ldv_state_variable_16 = 1;
  } else {

  }
  if (ldv_state_variable_16 == 2) {
    bfad_debugfs_write_regwr(bfad_debugfs_op_regwr_group2, (char const   *)ldvarg34,
                             ldvarg33, ldvarg32);
    ldv_state_variable_16 = 2;
  } else {

  }
  goto ldv_48623;
  case 3: ;
  if (ldv_state_variable_16 == 2) {
    bfad_debugfs_lseek(bfad_debugfs_op_regwr_group2, ldvarg31, ldvarg30);
    ldv_state_variable_16 = 2;
  } else {

  }
  goto ldv_48623;
  default: 
  ldv_stop();
  }
  ldv_48623: ;
  return;
}
}
void ldv_main_exported_17(void) 
{ 
  loff_t *ldvarg19 ;
  void *tmp ;
  size_t ldvarg17 ;
  int ldvarg14 ;
    klee_make_symbolic(&ldvarg14, sizeof(int), "ldvarg14");
  char *ldvarg21 ;
  void *tmp___0 ;
  loff_t ldvarg15 ;
  loff_t *ldvarg16 ;
  void *tmp___1 ;
  size_t ldvarg20 ;
  char *ldvarg18 ;
  void *tmp___2 ;
  int tmp___3 ;

  {
  tmp = ldv_init_zalloc(8UL);
  ldvarg19 = (loff_t *)tmp;
  tmp___0 = ldv_init_zalloc(1UL);
  ldvarg21 = (char *)tmp___0;
  tmp___1 = ldv_init_zalloc(8UL);
  ldvarg16 = (loff_t *)tmp___1;
  tmp___2 = ldv_init_zalloc(1UL);
  ldvarg18 = (char *)tmp___2;
  ldv_memset((void *)(& ldvarg17), 0, 8UL);
  ldv_memset((void *)(& ldvarg14), 0, 4UL);
  ldv_memset((void *)(& ldvarg15), 0, 8UL);
  ldv_memset((void *)(& ldvarg20), 0, 8UL);
  tmp___3 = __VERIFIER_nondet_int();
  switch (tmp___3) {
  case 0: ;
  if (ldv_state_variable_17 == 1) {
    ldv_retval_0 = bfad_debugfs_open_reg(bfad_debugfs_op_regrd_group1, bfad_debugfs_op_regrd_group2);
    if (ldv_retval_0 == 0) {
      ldv_state_variable_17 = 2;
      ref_cnt = ref_cnt + 1;
    } else {

    }
  } else {

  }
  goto ldv_48640;
  case 1: ;
  if (ldv_state_variable_17 == 2) {
    bfad_debugfs_release(bfad_debugfs_op_regrd_group1, bfad_debugfs_op_regrd_group2);
    ldv_state_variable_17 = 1;
    ref_cnt = ref_cnt - 1;
  } else {

  }
  goto ldv_48640;
  case 2: ;
  if (ldv_state_variable_17 == 1) {
    bfad_debugfs_write_regrd(bfad_debugfs_op_regrd_group2, (char const   *)ldvarg21,
                             ldvarg20, ldvarg19);
    ldv_state_variable_17 = 1;
  } else {

  }
  if (ldv_state_variable_17 == 2) {
    bfad_debugfs_write_regrd(bfad_debugfs_op_regrd_group2, (char const   *)ldvarg21,
                             ldvarg20, ldvarg19);
    ldv_state_variable_17 = 2;
  } else {

  }
  goto ldv_48640;
  case 3: ;
  if (ldv_state_variable_17 == 2) {
    bfad_debugfs_read_regrd(bfad_debugfs_op_regrd_group2, ldvarg18, ldvarg17, ldvarg16);
    ldv_state_variable_17 = 2;
  } else {

  }
  goto ldv_48640;
  case 4: ;
  if (ldv_state_variable_17 == 2) {
    bfad_debugfs_lseek(bfad_debugfs_op_regrd_group2, ldvarg15, ldvarg14);
    ldv_state_variable_17 = 2;
  } else {

  }
  goto ldv_48640;
  default: 
  ldv_stop();
  }
  ldv_48640: ;
  return;
}
}
void ldv_main_exported_20(void) 
{ 
  loff_t *ldvarg46 ;
  void *tmp ;
  size_t ldvarg47 ;
  int ldvarg44 ;
    klee_make_symbolic(&ldvarg44, sizeof(int), "ldvarg44");
  loff_t ldvarg45 ;
  char *ldvarg48 ;
  void *tmp___0 ;
  int tmp___1 ;

  {
  tmp = ldv_init_zalloc(8UL);
  ldvarg46 = (loff_t *)tmp;
  tmp___0 = ldv_init_zalloc(1UL);
  ldvarg48 = (char *)tmp___0;
  ldv_memset((void *)(& ldvarg47), 0, 8UL);
  ldv_memset((void *)(& ldvarg44), 0, 4UL);
  ldv_memset((void *)(& ldvarg45), 0, 8UL);
  tmp___1 = __VERIFIER_nondet_int();
  switch (tmp___1) {
  case 0: ;
  if (ldv_state_variable_20 == 1) {
    ldv_retval_3 = bfad_debugfs_open_drvtrc(bfad_debugfs_op_drvtrc_group1, bfad_debugfs_op_drvtrc_group2);
    if (ldv_retval_3 == 0) {
      ldv_state_variable_20 = 2;
      ref_cnt = ref_cnt + 1;
    } else {

    }
  } else {

  }
  goto ldv_48655;
  case 1: ;
  if (ldv_state_variable_20 == 2) {
    bfad_debugfs_release(bfad_debugfs_op_drvtrc_group1, bfad_debugfs_op_drvtrc_group2);
    ldv_state_variable_20 = 1;
    ref_cnt = ref_cnt - 1;
  } else {

  }
  goto ldv_48655;
  case 2: ;
  if (ldv_state_variable_20 == 2) {
    bfad_debugfs_read(bfad_debugfs_op_drvtrc_group2, ldvarg48, ldvarg47, ldvarg46);
    ldv_state_variable_20 = 2;
  } else {

  }
  goto ldv_48655;
  case 3: ;
  if (ldv_state_variable_20 == 2) {
    bfad_debugfs_lseek(bfad_debugfs_op_drvtrc_group2, ldvarg45, ldvarg44);
    ldv_state_variable_20 = 2;
  } else {

  }
  goto ldv_48655;
  default: 
  ldv_stop();
  }
  ldv_48655: ;
  return;
}
}
__inline static long PTR_ERR(void const   *ptr ) 
{ 
  long tmp ;

  {
  tmp = ldv_ptr_err(ptr);
  return (tmp);
}
}
bool ldv_queue_work_on_165(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_3(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_delayed_work_on_166(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_3(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_work_on_167(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_3(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
void ldv_flush_workqueue_168(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
  flush_workqueue(ldv_func_arg1);
  call_and_disable_all_3(2);
  return;
}
}
bool ldv_queue_delayed_work_on_169(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_3(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
void ldv_mutex_unlock_170(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_unlock_i_mutex_of_inode(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_171(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_lock_i_mutex_of_inode(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_172(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_lock_lock(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_173(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_unlock_lock(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_174(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
int ldv_mutex_trylock_175(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
  tmp = mutex_trylock(ldv_func_arg1);
  ldv_func_res = tmp;
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
  return (tmp___0);
  return (ldv_func_res);
}
}
void ldv_mutex_unlock_176(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
int ldv_scsi_add_host_with_dma_177(struct Scsi_Host *shost , struct device *dev ,
                                   struct device *dma_dev ) 
{ 
  ldv_func_ret_type___4 ldv_func_res ;
  int tmp ;

  {
  tmp = scsi_add_host_with_dma(shost, dev, dma_dev);
  ldv_func_res = tmp;
  if (ldv_func_res == 0) {
    ldv_state_variable_35 = 1;
    ldv_initialize_scsi_host_template_35();
  } else {

  }
  return (ldv_func_res);
}
}
__inline static long ldv__builtin_expect(long exp , long c ) ;
__inline static __u32 __arch_swab32(__u32 val ) 
{ 


  {
  __asm__  ("bswapl %0": "=r" (val): "0" (val));
  return (val);
}
}
__inline static __u16 __fswab16(__u16 val ) 
{ 


  {
  return ((__u16 )((int )((short )((int )val << 8)) | (int )((short )((int )val >> 8))));
}
}
__inline static __u32 __fswab32(__u32 val ) 
{ 
  __u32 tmp ;

  {
  tmp = __arch_swab32(val);
  return (tmp);
}
}
extern void __might_fault(char const   * , int  ) ;
int ldv_mutex_trylock_203(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_201(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_204(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_205(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_209(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_210(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_212(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_213(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_200(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_202(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_206(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_208(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_211(struct mutex *ldv_func_arg1 ) ;
bool ldv_queue_work_on_195(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_work_on_197(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_delayed_work_on_196(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
bool ldv_queue_delayed_work_on_199(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
void ldv_flush_workqueue_198(struct workqueue_struct *ldv_func_arg1 ) ;
extern unsigned long _copy_from_user(void * , void const   * , unsigned int  ) ;
extern unsigned long _copy_to_user(void * , void const   * , unsigned int  ) ;
extern void __copy_from_user_overflow(void) ;
extern void __copy_to_user_overflow(void) ;
__inline static unsigned long copy_from_user(void *to , void const   *from , unsigned long n ) 
{ 
  int sz ;
    klee_make_symbolic(&sz, sizeof(int), "sz");
  unsigned long tmp ;
  long tmp___0 ;

  {
  tmp = __builtin_object_size((void const   *)to, 0);
  sz = (int )tmp;
  __might_fault("./arch/x86/include/asm/uaccess.h", 697);
  tmp___0 = ldv__builtin_expect((long )(sz < 0 || (unsigned long )sz >= n), 1L);
  if (tmp___0 != 0L) {
    n = _copy_from_user(to, from, (unsigned int )n);
  } else {
    __copy_from_user_overflow();
  }
  return (n);
}
}
__inline static unsigned long copy_to_user(void *to , void const   *from , unsigned long n ) 
{ 
  int sz ;
  unsigned long tmp ;
  long tmp___0 ;

  {
  tmp = __builtin_object_size(from, 0);
  sz = (int )tmp;
  __might_fault("./arch/x86/include/asm/uaccess.h", 732);
  tmp___0 = ldv__builtin_expect((long )(sz < 0 || (unsigned long )sz >= n), 1L);
  if (tmp___0 != 0L) {
    n = _copy_to_user(to, from, (unsigned int )n);
  } else {
    __copy_to_user_overflow();
  }
  return (n);
}
}
extern size_t sg_copy_from_buffer(struct scatterlist * , unsigned int  , void const   * ,
                                  size_t  ) ;
extern size_t sg_copy_to_buffer(struct scatterlist * , unsigned int  , void * , size_t  ) ;
__inline static void *dma_zalloc_coherent(struct device *dev , size_t size , dma_addr_t *dma_handle ,
                                          gfp_t flag ) 
{ 
  void *ret ;
  void *tmp ;

  {
  tmp = dma_alloc_attrs(dev, size, dma_handle, flag | 32768U, (struct dma_attrs *)0);
  ret = tmp;
  return (ret);
}
}
extern void blk_queue_max_segments(struct request_queue * , unsigned short  ) ;
int ldv_scsi_add_host_with_dma_207(struct Scsi_Host *shost , struct device *dev ,
                                   struct device *dma_dev ) ;
extern void scsi_device_put(struct scsi_device * ) ;
extern struct scsi_device *scsi_device_lookup(struct Scsi_Host * , uint  , uint  ,
                                              u64  ) ;
__inline static void bfa_trc_stop(struct bfa_trc_mod_s *trcm ) 
{ 


  {
  trcm->stopped = 1U;
  return;
}
}
enum bfa_status bfa_sfp_show(struct bfa_sfp_s *sfp , struct sfp_mem_s *sfpmem , void (*cbfn)(void * ,
                                                                                             enum bfa_status  ) ,
                             void *cbarg ) ;
enum bfa_status bfa_sfp_media(struct bfa_sfp_s *sfp , enum bfa_defs_sfp_media_e *media ,
                              void (*cbfn)(void * , enum bfa_status  ) , void *cbarg ) ;
enum bfa_status bfa_sfp_speed(struct bfa_sfp_s *sfp , enum bfa_port_speed portspeed ,
                              void (*cbfn)(void * , enum bfa_status  ) , void *cbarg ) ;
enum bfa_status bfa_flash_get_attr(struct bfa_flash_s *flash , struct bfa_flash_attr_s *attr ,
                                   void (*cbfn)(void * , enum bfa_status  ) , void *cbarg ) ;
enum bfa_status bfa_flash_erase_part(struct bfa_flash_s *flash , enum bfa_flash_part_type type ,
                                     u8 instance , void (*cbfn)(void * , enum bfa_status  ) ,
                                     void *cbarg ) ;
enum bfa_status bfa_flash_update_part(struct bfa_flash_s *flash , enum bfa_flash_part_type type ,
                                      u8 instance , void *buf , u32 len , u32 offset ,
                                      void (*cbfn)(void * , enum bfa_status  ) , void *cbarg ) ;
enum bfa_status bfa_flash_read_part(struct bfa_flash_s *flash , enum bfa_flash_part_type type ,
                                    u8 instance , void *buf , u32 len , u32 offset ,
                                    void (*cbfn)(void * , enum bfa_status  ) , void *cbarg ) ;
enum bfa_status bfa_diag_tsensor_query(struct bfa_diag_s *diag , struct bfa_diag_results_tempsensor_s *result ,
                                       void (*cbfn)(void * , enum bfa_status  ) ,
                                       void *cbarg ) ;
enum bfa_status bfa_diag_fwping(struct bfa_diag_s *diag , u32 cnt , u32 data , struct bfa_diag_results_fwping *result ,
                                void (*cbfn)(void * , enum bfa_status  ) , void *cbarg ) ;
enum bfa_status bfa_diag_memtest(struct bfa_diag_s *diag , struct bfa_diag_memtest_s *memtest ,
                                 u32 pattern , struct bfa_diag_memtest_result *result ,
                                 void (*cbfn)(void * , enum bfa_status  ) , void *cbarg ) ;
enum bfa_status bfa_diag_ledtest(struct bfa_diag_s *diag , struct bfa_diag_ledtest_s *ledtest ) ;
enum bfa_status bfa_diag_beacon_port(struct bfa_diag_s *diag , enum bfa_boolean beacon ,
                                     enum bfa_boolean link_e2e_beacon , unsigned int sec ) ;
enum bfa_status bfa_phy_get_attr(struct bfa_phy_s *phy , u8 instance , struct bfa_phy_attr_s *attr ,
                                 void (*cbfn)(void * , enum bfa_status  ) , void *cbarg ) ;
enum bfa_status bfa_phy_get_stats(struct bfa_phy_s *phy , u8 instance , struct bfa_phy_stats_s *stats ,
                                  void (*cbfn)(void * , enum bfa_status  ) , void *cbarg ) ;
enum bfa_status bfa_phy_update(struct bfa_phy_s *phy , u8 instance , void *buf , u32 len ,
                               u32 offset , void (*cbfn)(void * , enum bfa_status  ) ,
                               void *cbarg ) ;
enum bfa_status bfa_phy_read(struct bfa_phy_s *phy , u8 instance , void *buf , u32 len ,
                             u32 offset , void (*cbfn)(void * , enum bfa_status  ) ,
                             void *cbarg ) ;
enum bfa_status bfa_fruvpd_update(struct bfa_fru_s *fru , void *buf , u32 len , u32 offset ,
                                  void (*cbfn)(void * , enum bfa_status  ) , void *cbarg ,
                                  u8 trfr_cmpl ) ;
enum bfa_status bfa_fruvpd_read(struct bfa_fru_s *fru , void *buf , u32 len , u32 offset ,
                                void (*cbfn)(void * , enum bfa_status  ) , void *cbarg ) ;
enum bfa_status bfa_fruvpd_get_max_size(struct bfa_fru_s *fru , u32 *max_size ) ;
enum bfa_status bfa_tfru_write(struct bfa_fru_s *fru , void *buf , u32 len , u32 offset ,
                               void (*cbfn)(void * , enum bfa_status  ) , void *cbarg ) ;
enum bfa_status bfa_tfru_read(struct bfa_fru_s *fru , void *buf , u32 len , u32 offset ,
                              void (*cbfn)(void * , enum bfa_status  ) , void *cbarg ) ;
enum bfa_boolean bfa_ioc_is_disabled(struct bfa_ioc_s *ioc ) ;
enum bfa_status bfa_ioc_debug_fwcore(struct bfa_ioc_s *ioc , void *buf , u32 *offset ,
                                     int *buflen ) ;
enum bfa_status bfa_ioc_fwsig_invalidate(struct bfa_ioc_s *ioc ) ;
enum bfa_status bfa_ioc_fw_stats_get(struct bfa_ioc_s *ioc , void *stats ) ;
enum bfa_status bfa_ioc_fw_stats_clear(struct bfa_ioc_s *ioc ) ;
enum bfa_status bfa_ablk_query(struct bfa_ablk_s *ablk , struct bfa_ablk_cfg_s *ablk_cfg ,
                               void (*cbfn)(void * , enum bfa_status  ) , void *cbarg ) ;
enum bfa_status bfa_ablk_adapter_config(struct bfa_ablk_s *ablk , enum bfa_mode_s mode ,
                                        int max_pf , int max_vf , void (*cbfn)(void * ,
                                                                               enum bfa_status  ) ,
                                        void *cbarg ) ;
enum bfa_status bfa_ablk_port_config(struct bfa_ablk_s *ablk , int port , enum bfa_mode_s mode ,
                                     int max_pf , int max_vf , void (*cbfn)(void * ,
                                                                            enum bfa_status  ) ,
                                     void *cbarg ) ;
enum bfa_status bfa_ablk_pf_create(struct bfa_ablk_s *ablk , u16 *pcifn , u8 port ,
                                   enum bfi_pcifn_class personality , u16 bw_min ,
                                   u16 bw_max , void (*cbfn)(void * , enum bfa_status  ) ,
                                   void *cbarg ) ;
enum bfa_status bfa_ablk_pf_delete(struct bfa_ablk_s *ablk , int pcifn , void (*cbfn)(void * ,
                                                                                      enum bfa_status  ) ,
                                   void *cbarg ) ;
enum bfa_status bfa_ablk_pf_update(struct bfa_ablk_s *ablk , int pcifn , u16 bw_min ,
                                   u16 bw_max , void (*cbfn)(void * , enum bfa_status  ) ,
                                   void *cbarg ) ;
enum bfa_status bfa_ablk_optrom_en(struct bfa_ablk_s *ablk , void (*cbfn)(void * ,
                                                                          enum bfa_status  ) ,
                                   void *cbarg ) ;
enum bfa_status bfa_ablk_optrom_dis(struct bfa_ablk_s *ablk , void (*cbfn)(void * ,
                                                                           enum bfa_status  ) ,
                                    void *cbarg ) ;
struct mac_s bfa_ioc_get_mac(struct bfa_ioc_s *ioc ) ;
struct mac_s bfa_ioc_get_mfg_mac(struct bfa_ioc_s *ioc ) ;
void bfa_iocfc_get_attr(struct bfa_s *bfa , struct bfa_iocfc_attr_s *attr ) ;
enum bfa_status bfa_iocfc_israttr_set(struct bfa_s *bfa , struct bfa_iocfc_intr_attr_s *attr ) ;
void bfa_iocfc_enable(struct bfa_s *bfa ) ;
void bfa_iocfc_disable(struct bfa_s *bfa ) ;
enum bfa_status bfa_fcport_enable(struct bfa_s *bfa ) ;
enum bfa_status bfa_fcport_disable(struct bfa_s *bfa ) ;
enum bfa_status bfa_fcport_cfg_speed(struct bfa_s *bfa , enum bfa_port_speed speed ) ;
enum bfa_status bfa_fcport_cfg_topology(struct bfa_s *bfa , enum bfa_port_topology topology ) ;
enum bfa_status bfa_fcport_cfg_hardalpa(struct bfa_s *bfa , u8 alpa ) ;
enum bfa_status bfa_fcport_clr_hardalpa(struct bfa_s *bfa ) ;
enum bfa_status bfa_fcport_cfg_maxfrsize(struct bfa_s *bfa , u16 maxfrsize ) ;
enum bfa_boolean bfa_fcport_is_disabled(struct bfa_s *bfa ) ;
enum bfa_boolean bfa_fcport_is_dport(struct bfa_s *bfa ) ;
enum bfa_status bfa_fcport_set_qos_bw(struct bfa_s *bfa , struct bfa_qos_bw_s *qos_bw ) ;
enum bfa_status bfa_fcport_get_stats(struct bfa_s *bfa , struct bfa_cb_pending_q_s *cb ) ;
enum bfa_status bfa_fcport_clear_stats(struct bfa_s *bfa , struct bfa_cb_pending_q_s *cb ) ;
enum bfa_status bfa_fcport_cfg_bbcr(struct bfa_s *bfa , enum bfa_boolean on_off ,
                                    u8 bb_scn ) ;
enum bfa_status bfa_fcport_get_bbcr_attr(struct bfa_s *bfa , struct bfa_bbcr_attr_s *bbcr_attr ) ;
void bfa_rport_speed(struct bfa_rport_s *rport , enum bfa_port_speed speed ) ;
struct bfa_fcxp_s *bfa_fcxp_req_rsp_alloc(void *caller , struct bfa_s *bfa , int nreq_sgles ,
                                          int nrsp_sgles , u64 (*req_sga_cbfn)(void * ,
                                                                               int  ) ,
                                          u32 (*req_sglen_cbfn)(void * , int  ) ,
                                          u64 (*rsp_sga_cbfn)(void * , int  ) , u32 (*rsp_sglen_cbfn)(void * ,
                                                                                                      int  ) ,
                                          enum bfa_boolean req ) ;
void bfa_fcxp_send(struct bfa_fcxp_s *fcxp , struct bfa_rport_s *rport , u16 vf_id ,
                   u8 lp_tag , enum bfa_boolean cts , enum fc_cos cos , u32 reqlen ,
                   struct fchs_s *fchs , void (*cbfn)(void * , struct bfa_fcxp_s * ,
                                                      void * , enum bfa_status  ,
                                                      u32  , u32  , struct fchs_s * ) ,
                   void *cbarg , u32 rsp_maxlen , u8 rsp_timeout ) ;
u32 bfa_lps_get_base_pid(struct bfa_s *bfa ) ;
u8 bfa_lps_get_tag_from_pid(struct bfa_s *bfa , u32 pid ) ;
enum bfa_status bfa_faa_query(struct bfa_s *bfa , struct bfa_faa_attr_s *attr , void (*cbfn)(void * ,
                                                                                             enum bfa_status  ) ,
                              void *cbarg ) ;
enum bfa_status bfa_fcdiag_loopback(struct bfa_s *bfa , enum bfa_port_opmode opmode ,
                                    enum bfa_port_speed speed , u32 lpcnt , u32 pat ,
                                    struct bfa_diag_loopback_result_s *result , void (*cbfn)(void * ,
                                                                                             enum bfa_status  ) ,
                                    void *cbarg ) ;
enum bfa_status bfa_fcdiag_queuetest(struct bfa_s *bfa , u32 force , u32 queue , struct bfa_diag_qtest_result_s *result ,
                                     void (*cbfn)(void * , enum bfa_status  ) , void *cbarg ) ;
enum bfa_status bfa_fcdiag_lb_is_running(struct bfa_s *bfa ) ;
enum bfa_status bfa_dport_enable(struct bfa_s *bfa , u32 lpcnt , u32 pat , void (*cbfn)(void * ,
                                                                                        enum bfa_status  ) ,
                                 void *cbarg ) ;
enum bfa_status bfa_dport_disable(struct bfa_s *bfa , void (*cbfn)(void * , enum bfa_status  ) ,
                                  void *cbarg ) ;
enum bfa_status bfa_dport_start(struct bfa_s *bfa , u32 lpcnt , u32 pat , void (*cbfn)(void * ,
                                                                                       enum bfa_status  ) ,
                                void *cbarg ) ;
enum bfa_status bfa_dport_show(struct bfa_s *bfa , struct bfa_diag_dport_result_s *result ) ;
void bfa_fcpim_path_tov_set(struct bfa_s *bfa , u16 path_tov ) ;
enum bfa_status bfa_fcpim_port_iostats(struct bfa_s *bfa , struct bfa_itnim_iostats_s *stats ,
                                       u8 lp_tag ) ;
void bfa_fcpim_add_stats(struct bfa_itnim_iostats_s *lstats , struct bfa_itnim_iostats_s *rstats ) ;
enum bfa_status bfa_fcpim_profile_on(struct bfa_s *bfa , u32 time ) ;
enum bfa_status bfa_fcpim_profile_off(struct bfa_s *bfa ) ;
void bfa_itnim_clear_stats(struct bfa_itnim_s *itnim ) ;
enum bfa_status bfa_itnim_get_ioprofile(struct bfa_itnim_s *itnim , struct bfa_itnim_ioprofile_s *ioprofile ) ;
enum bfa_status bfa_fcpim_lunmask_update(struct bfa_s *bfa , u32 update ) ;
enum bfa_status bfa_fcpim_lunmask_query(struct bfa_s *bfa , void *buf ) ;
enum bfa_status bfa_fcpim_lunmask_delete(struct bfa_s *bfa , u16 vf_id , wwn_t *pwwn ,
                                         wwn_t rpwwn , struct scsi_lun lun ) ;
enum bfa_status bfa_fcpim_lunmask_add(struct bfa_s *bfa , u16 vf_id , wwn_t *pwwn ,
                                      wwn_t rpwwn , struct scsi_lun lun ) ;
enum bfa_status bfa_fcpim_lunmask_clear(struct bfa_s *bfa ) ;
enum bfa_status bfa_fcpim_throttle_set(struct bfa_s *bfa , u16 value ) ;
enum bfa_status bfa_fcpim_throttle_get(struct bfa_s *bfa , void *buf ) ;
enum bfa_status bfa_cee_get_attr(struct bfa_cee_s *cee , struct bfa_cee_attr_s *attr ,
                                 void (*cbfn)(void * , enum bfa_status  ) , void *cbarg ) ;
enum bfa_status bfa_cee_get_stats(struct bfa_cee_s *cee , struct bfa_cee_stats_s *stats ,
                                  void (*cbfn)(void * , enum bfa_status  ) , void *cbarg ) ;
enum bfa_status bfa_cee_reset_stats(struct bfa_cee_s *cee , void (*cbfn)(void * ,
                                                                         enum bfa_status  ) ,
                                    void *cbarg ) ;
enum bfa_boolean bfa_fcs_lport_is_online(struct bfa_fcs_lport_s *port ) ;
struct bfa_fcs_lport_s *bfa_fcs_lookup_port(struct bfa_fcs_s *fcs , u16 vf_id , wwn_t lpwwn ) ;
void bfa_fcs_lport_get_stats(struct bfa_fcs_lport_s *fcs_port , struct bfa_lport_stats_s *port_stats ) ;
void bfa_fcs_lport_clear_stats(struct bfa_fcs_lport_s *fcs_port ) ;
struct bfa_fcs_rport_s *bfa_fcs_lport_get_rport_by_pwwn(struct bfa_fcs_lport_s *port ,
                                                        wwn_t pwwn ) ;
struct bfa_fcs_rport_s *bfa_fcs_lport_get_rport_by_qualifier(struct bfa_fcs_lport_s *port ,
                                                             wwn_t pwwn , u32 pid ) ;
void bfa_fcs_vport_get_attr(struct bfa_fcs_vport_s *vport , struct bfa_vport_attr_s *attr ) ;
__inline static struct bfa_rport_s *bfa_fcs_rport_get_halrport(struct bfa_fcs_rport_s *rport ) 
{ 


  {
  return (rport->bfa_rport);
}
}
void bfa_fcs_rport_get_attr(struct bfa_fcs_rport_s *rport , struct bfa_rport_attr_s *rport_attr ) ;
struct bfa_fcs_rport_s *bfa_fcs_rport_lookup(struct bfa_fcs_lport_s *port , wwn_t rpwwn ) ;
struct bfa_fcs_itnim_s *bfa_fcs_itnim_lookup(struct bfa_fcs_lport_s *port , wwn_t rpwwn ) ;
enum bfa_status bfa_fcs_itnim_attr_get(struct bfa_fcs_lport_s *port , wwn_t rpwwn ,
                                       struct bfa_itnim_attr_s *attr ) ;
enum bfa_status bfa_fcs_itnim_stats_get(struct bfa_fcs_lport_s *port , wwn_t rpwwn ,
                                        struct bfa_itnim_stats_s *stats ) ;
enum bfa_status bfa_fcs_itnim_stats_clear(struct bfa_fcs_lport_s *port , wwn_t rpwwn ) ;
struct bfa_fcs_fabric_s *bfa_fcs_vf_lookup(struct bfa_fcs_s *fcs , u16 vf_id ) ;
void bfa_fcs_vf_get_ports(struct bfa_fcs_fabric_s *vf , wwn_t *lpwwn , int *nlports ) ;
static int __trc_fileno___1  =    3075;
int bfad_iocmd_ioc_enable(struct bfad_s *bfad , void *cmd ) 
{ 
  struct bfa_bsg_gen_s *iocmd ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;
  enum bfa_boolean tmp___0 ;

  {
  iocmd = (struct bfa_bsg_gen_s *)cmd;
  tmp = spinlock_check(& bfad->bfad_lock);
  flags = _raw_spin_lock_irqsave(tmp);
  tmp___0 = bfa_ioc_is_disabled(& bfad->bfa.ioc);
  if ((unsigned int )tmp___0 == 0U) {
    spin_unlock_irqrestore(& bfad->bfad_lock, flags);
    iocmd->status = 0;
    return (0);
  } else {

  }
  init_completion(& bfad->enable_comp);
  bfa_iocfc_enable(& bfad->bfa);
  iocmd->status = 0;
  spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  wait_for_completion(& bfad->enable_comp);
  return (0);
}
}
int bfad_iocmd_ioc_disable(struct bfad_s *bfad , void *cmd ) 
{ 
  struct bfa_bsg_gen_s *iocmd ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;
  enum bfa_boolean tmp___0 ;

  {
  iocmd = (struct bfa_bsg_gen_s *)cmd;
  tmp = spinlock_check(& bfad->bfad_lock);
  flags = _raw_spin_lock_irqsave(tmp);
  tmp___0 = bfa_ioc_is_disabled(& bfad->bfa.ioc);
  if ((unsigned int )tmp___0 != 0U) {
    spin_unlock_irqrestore(& bfad->bfad_lock, flags);
    iocmd->status = 0;
    return (0);
  } else {

  }
  if ((unsigned int )bfad->disable_active != 0U) {
    spin_unlock_irqrestore(& bfad->bfad_lock, flags);
    return (-16);
  } else {

  }
  bfad->disable_active = 1;
  init_completion(& bfad->disable_comp);
  bfa_iocfc_disable(& bfad->bfa);
  spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  wait_for_completion(& bfad->disable_comp);
  bfad->disable_active = 0;
  iocmd->status = 0;
  return (0);
}
}
static int bfad_iocmd_ioc_get_info(struct bfad_s *bfad , void *cmd ) 
{ 
  int i ;
  struct bfa_bsg_ioc_info_s *iocmd ;
  struct bfad_im_port_s *im_port ;
  struct bfa_port_attr_s pattr ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;

  {
  iocmd = (struct bfa_bsg_ioc_info_s *)cmd;
  tmp = spinlock_check(& bfad->bfad_lock);
  flags = _raw_spin_lock_irqsave(tmp);
  bfa_fcport_get_attr(& bfad->bfa, & pattr);
  iocmd->nwwn = pattr.nwwn;
  iocmd->pwwn = pattr.pwwn;
  iocmd->ioc_type = bfa_ioc_get_type(& bfad->bfa.ioc);
  iocmd->mac = bfa_ioc_get_mac(& bfad->bfa.ioc);
  iocmd->factory_mac = bfa_ioc_get_mfg_mac(& bfad->bfa.ioc);
  bfa_ioc_get_adapter_serial_num(& bfad->bfa.ioc, (char *)(& iocmd->serialnum));
  iocmd->factorynwwn = pattr.factorynwwn;
  iocmd->factorypwwn = pattr.factorypwwn;
  iocmd->bfad_num = (u16 )bfad->inst_no;
  im_port = bfad->pport.im_port;
  iocmd->host = (im_port->shost)->host_no;
  spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  strcpy((char *)(& iocmd->name), (char const   *)(& bfad->adapter_name));
  strcpy((char *)(& iocmd->port_name), (char const   *)(& bfad->port_name));
  strcpy((char *)(& iocmd->hwpath), bfad->pci_name);
  strcpy((char *)(& iocmd->adapter_hwpath), bfad->pci_name);
  i = 0;
  goto ldv_48959;
  ldv_48958: 
  i = i + 1;
  ldv_48959: ;
  if ((int )((signed char )iocmd->adapter_hwpath[i]) != 58 && i <= 31) {
    goto ldv_48958;
  } else {

  }

  goto ldv_48962;
  ldv_48961: ;
  ldv_48962: 
  i = i + 1;
  if ((int )((signed char )iocmd->adapter_hwpath[i]) != 58 && i <= 31) {
    goto ldv_48961;
  } else {

  }
  iocmd->adapter_hwpath[i] = 0;
  iocmd->status = 0;
  return (0);
}
}
static int bfad_iocmd_ioc_get_attr(struct bfad_s *bfad , void *cmd ) 
{ 
  struct bfa_bsg_ioc_attr_s *iocmd ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;

  {
  iocmd = (struct bfa_bsg_ioc_attr_s *)cmd;
  tmp = spinlock_check(& bfad->bfad_lock);
  flags = _raw_spin_lock_irqsave(tmp);
  bfa_ioc_get_attr(& bfad->bfa.ioc, & iocmd->ioc_attr);
  spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  strcpy((char *)(& iocmd->ioc_attr.driver_attr.driver), "bfa");
  strncpy((char *)(& iocmd->ioc_attr.driver_attr.driver_ver), "3.2.23.0", 64UL);
  strcpy((char *)(& iocmd->ioc_attr.driver_attr.fw_ver), (char const   *)(& iocmd->ioc_attr.adapter_attr.fw_ver));
  strcpy((char *)(& iocmd->ioc_attr.driver_attr.bios_ver), (char const   *)(& iocmd->ioc_attr.adapter_attr.optrom_ver));
  memcpy((void *)(& bfad->pci_attr.chip_rev), (void const   *)(& iocmd->ioc_attr.pci_attr.chip_rev),
           8UL);
  memcpy((void *)(& iocmd->ioc_attr.pci_attr), (void const   *)(& bfad->pci_attr),
           24UL);
  iocmd->status = 0;
  return (0);
}
}
int bfad_iocmd_ioc_get_stats(struct bfad_s *bfad , void *cmd ) 
{ 
  struct bfa_bsg_ioc_stats_s *iocmd ;

  {
  iocmd = (struct bfa_bsg_ioc_stats_s *)cmd;
  iocmd->ioc_stats.drv_stats = bfad->bfa.ioc.stats;
  iocmd->status = 0;
  return (0);
}
}
int bfad_iocmd_ioc_get_fwstats(struct bfad_s *bfad , void *cmd , unsigned int payload_len ) 
{ 
  struct bfa_bsg_ioc_fwstats_s *iocmd ;
  void *iocmd_bufptr ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;

  {
  iocmd = (struct bfa_bsg_ioc_fwstats_s *)cmd;
  if (payload_len != 960U) {
    iocmd->status = 70;
    goto out;
  } else {

  }
  iocmd_bufptr = (void *)iocmd + 24U;
  tmp = spinlock_check(& bfad->bfad_lock);
  flags = _raw_spin_lock_irqsave(tmp);
  iocmd->status = bfa_ioc_fw_stats_get(& bfad->bfa.ioc, iocmd_bufptr);
  spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  if ((unsigned int )iocmd->status != 0U) {
    __bfa_trc(bfad->trcmod, __trc_fileno___1, 178, (unsigned long long )iocmd->status);
    goto out;
  } else {

  }
  out: 
  __bfa_trc(bfad->trcmod, __trc_fileno___1, 182, 26214ULL);
  return (0);
}
}
int bfad_iocmd_ioc_reset_stats(struct bfad_s *bfad , void *cmd , unsigned int v_cmd ) 
{ 
  struct bfa_bsg_gen_s *iocmd ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;

  {
  iocmd = (struct bfa_bsg_gen_s *)cmd;
  if (v_cmd == 7U) {
    memset((void *)(& bfad->bfa.ioc.stats), 0, 48UL);
    iocmd->status = 0;
  } else
  if (v_cmd == 8U) {
    tmp = spinlock_check(& bfad->bfad_lock);
    flags = _raw_spin_lock_irqsave(tmp);
    iocmd->status = bfa_ioc_fw_stats_clear(& bfad->bfa.ioc);
    spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  } else {

  }
  return (0);
}
}
int bfad_iocmd_ioc_set_name(struct bfad_s *bfad , void *cmd , unsigned int v_cmd ) 
{ 
  struct bfa_bsg_ioc_name_s *iocmd ;

  {
  iocmd = (struct bfa_bsg_ioc_name_s *)cmd;
  if (v_cmd == 9U) {
    strcpy((char *)(& bfad->adapter_name), (char const   *)(& iocmd->name));
  } else
  if (v_cmd == 10U) {
    strcpy((char *)(& bfad->port_name), (char const   *)(& iocmd->name));
  } else {

  }
  iocmd->status = 0;
  return (0);
}
}
int bfad_iocmd_iocfc_get_attr(struct bfad_s *bfad , void *cmd ) 
{ 
  struct bfa_bsg_iocfc_attr_s *iocmd ;

  {
  iocmd = (struct bfa_bsg_iocfc_attr_s *)cmd;
  iocmd->status = 0;
  bfa_iocfc_get_attr(& bfad->bfa, & iocmd->iocfc_attr);
  return (0);
}
}
int bfad_iocmd_ioc_fw_sig_inv(struct bfad_s *bfad , void *cmd ) 
{ 
  struct bfa_bsg_gen_s *iocmd ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;

  {
  iocmd = (struct bfa_bsg_gen_s *)cmd;
  tmp = spinlock_check(& bfad->bfad_lock);
  flags = _raw_spin_lock_irqsave(tmp);
  iocmd->status = bfa_ioc_fwsig_invalidate(& bfad->bfa.ioc);
  spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  return (0);
}
}
int bfad_iocmd_iocfc_set_intr(struct bfad_s *bfad , void *cmd ) 
{ 
  struct bfa_bsg_iocfc_intr_s *iocmd ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;

  {
  iocmd = (struct bfa_bsg_iocfc_intr_s *)cmd;
  tmp = spinlock_check(& bfad->bfad_lock);
  flags = _raw_spin_lock_irqsave(tmp);
  iocmd->status = bfa_iocfc_israttr_set(& bfad->bfa, & iocmd->attr);
  spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  return (0);
}
}
int bfad_iocmd_port_enable(struct bfad_s *bfad , void *cmd ) 
{ 
  struct bfa_bsg_gen_s *iocmd ;
  struct bfad_hal_comp fcomp ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;

  {
  iocmd = (struct bfa_bsg_gen_s *)cmd;
  init_completion(& fcomp.comp);
  tmp = spinlock_check(& bfad->bfad_lock);
  flags = _raw_spin_lock_irqsave(tmp);
  iocmd->status = bfa_port_enable(& bfad->bfa.modules.port, & bfad_hcb_comp, (void *)(& fcomp));
  spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  if ((unsigned int )iocmd->status != 0U) {
    __bfa_trc(bfad->trcmod, __trc_fileno___1, 267, (unsigned long long )iocmd->status);
    return (0);
  } else {

  }
  wait_for_completion(& fcomp.comp);
  iocmd->status = fcomp.status;
  return (0);
}
}
int bfad_iocmd_port_disable(struct bfad_s *bfad , void *cmd ) 
{ 
  struct bfa_bsg_gen_s *iocmd ;
  struct bfad_hal_comp fcomp ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;

  {
  iocmd = (struct bfa_bsg_gen_s *)cmd;
  init_completion(& fcomp.comp);
  tmp = spinlock_check(& bfad->bfad_lock);
  flags = _raw_spin_lock_irqsave(tmp);
  iocmd->status = bfa_port_disable(& bfad->bfa.modules.port, & bfad_hcb_comp, (void *)(& fcomp));
  spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  if ((unsigned int )iocmd->status != 0U) {
    __bfa_trc(bfad->trcmod, __trc_fileno___1, 289, (unsigned long long )iocmd->status);
    return (0);
  } else {

  }
  wait_for_completion(& fcomp.comp);
  iocmd->status = fcomp.status;
  return (0);
}
}
static int bfad_iocmd_port_get_attr(struct bfad_s *bfad , void *cmd ) 
{ 
  struct bfa_bsg_port_attr_s *iocmd ;
  struct bfa_lport_attr_s port_attr ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;

  {
  iocmd = (struct bfa_bsg_port_attr_s *)cmd;
  tmp = spinlock_check(& bfad->bfad_lock);
  flags = _raw_spin_lock_irqsave(tmp);
  bfa_fcport_get_attr(& bfad->bfa, & iocmd->attr);
  bfa_fcs_lport_get_attr(& bfad->bfa_fcs.fabric.bport, & port_attr);
  spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  if ((unsigned int )iocmd->attr.topology != 0U) {
    iocmd->attr.pid = port_attr.pid;
  } else {
    iocmd->attr.pid = 0U;
  }
  iocmd->attr.port_type = port_attr.port_type;
  iocmd->attr.loopback = port_attr.loopback;
  iocmd->attr.authfail = (u32 )port_attr.authfail;
  strncpy((char *)(& iocmd->attr.port_symname.symname), (char const   *)(& port_attr.port_cfg.sym_name.symname),
          128UL);
  iocmd->status = 0;
  return (0);
}
}
int bfad_iocmd_port_get_stats(struct bfad_s *bfad , void *cmd , unsigned int payload_len ) 
{ 
  struct bfa_bsg_port_stats_s *iocmd ;
  struct bfad_hal_comp fcomp ;
  void *iocmd_bufptr ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;

  {
  iocmd = (struct bfa_bsg_port_stats_s *)cmd;
  if (payload_len != 360U) {
    iocmd->status = 70;
    return (0);
  } else {

  }
  iocmd_bufptr = (void *)iocmd + 24U;
  init_completion(& fcomp.comp);
  tmp = spinlock_check(& bfad->bfad_lock);
  flags = _raw_spin_lock_irqsave(tmp);
  iocmd->status = bfa_port_get_stats(& bfad->bfa.modules.port, (union bfa_port_stats_u *)iocmd_bufptr,
                                     & bfad_hcb_comp, (void *)(& fcomp));
  spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  if ((unsigned int )iocmd->status != 0U) {
    __bfa_trc(bfad->trcmod, __trc_fileno___1, 349, (unsigned long long )iocmd->status);
    goto out;
  } else {

  }
  wait_for_completion(& fcomp.comp);
  iocmd->status = fcomp.status;
  out: ;
  return (0);
}
}
int bfad_iocmd_port_reset_stats(struct bfad_s *bfad , void *cmd ) 
{ 
  struct bfa_bsg_gen_s *iocmd ;
  struct bfad_hal_comp fcomp ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;

  {
  iocmd = (struct bfa_bsg_gen_s *)cmd;
  init_completion(& fcomp.comp);
  tmp = spinlock_check(& bfad->bfad_lock);
  flags = _raw_spin_lock_irqsave(tmp);
  iocmd->status = bfa_port_clear_stats(& bfad->bfa.modules.port, & bfad_hcb_comp,
                                       (void *)(& fcomp));
  spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  if ((unsigned int )iocmd->status != 0U) {
    __bfa_trc(bfad->trcmod, __trc_fileno___1, 372, (unsigned long long )iocmd->status);
    return (0);
  } else {

  }
  wait_for_completion(& fcomp.comp);
  iocmd->status = fcomp.status;
  return (0);
}
}
int bfad_iocmd_set_port_cfg(struct bfad_s *bfad , void *iocmd , unsigned int v_cmd ) 
{ 
  struct bfa_bsg_port_cfg_s *cmd ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;

  {
  cmd = (struct bfa_bsg_port_cfg_s *)iocmd;
  tmp = spinlock_check(& bfad->bfad_lock);
  flags = _raw_spin_lock_irqsave(tmp);
  if (v_cmd == 19U) {
    cmd->status = bfa_fcport_cfg_topology(& bfad->bfa, (enum bfa_port_topology )cmd->param);
  } else
  if (v_cmd == 20U) {
    cmd->status = bfa_fcport_cfg_speed(& bfad->bfa, (enum bfa_port_speed )cmd->param);
  } else
  if (v_cmd == 21U) {
    cmd->status = bfa_fcport_cfg_hardalpa(& bfad->bfa, (int )((u8 )cmd->param));
  } else
  if (v_cmd == 23U) {
    cmd->status = bfa_fcport_clr_hardalpa(& bfad->bfa);
  } else {

  }
  spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  return (0);
}
}
int bfad_iocmd_port_cfg_maxfrsize(struct bfad_s *bfad , void *cmd ) 
{ 
  struct bfa_bsg_port_cfg_maxfrsize_s *iocmd ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;

  {
  iocmd = (struct bfa_bsg_port_cfg_maxfrsize_s *)cmd;
  tmp = spinlock_check(& bfad->bfad_lock);
  flags = _raw_spin_lock_irqsave(tmp);
  iocmd->status = bfa_fcport_cfg_maxfrsize(& bfad->bfa, (int )iocmd->maxfrsize);
  spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  return (0);
}
}
int bfad_iocmd_port_cfg_bbcr(struct bfad_s *bfad , unsigned int cmd , void *pcmd ) 
{ 
  struct bfa_bsg_bbcr_enable_s *iocmd ;
  unsigned long flags ;
  int rc ;
  raw_spinlock_t *tmp ;
  enum bfa_status tmp___0 ;
  enum bfa_status tmp___1 ;

  {
  iocmd = (struct bfa_bsg_bbcr_enable_s *)pcmd;
  tmp = spinlock_check(& bfad->bfad_lock);
  flags = _raw_spin_lock_irqsave(tmp);
  if (cmd == 24U) {
    tmp___0 = bfa_fcport_cfg_bbcr(& bfad->bfa, 1, (int )iocmd->bb_scn);
    rc = (int )tmp___0;
  } else
  if (cmd == 25U) {
    tmp___1 = bfa_fcport_cfg_bbcr(& bfad->bfa, 0, 0);
    rc = (int )tmp___1;
  } else {
    spin_unlock_irqrestore(& bfad->bfad_lock, flags);
    return (-22);
  }
  spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  iocmd->status = (enum bfa_status )rc;
  return (0);
}
}
int bfad_iocmd_port_get_bbcr_attr(struct bfad_s *bfad , void *pcmd ) 
{ 
  struct bfa_bsg_bbcr_attr_s *iocmd ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;

  {
  iocmd = (struct bfa_bsg_bbcr_attr_s *)pcmd;
  tmp = spinlock_check(& bfad->bfad_lock);
  flags = _raw_spin_lock_irqsave(tmp);
  iocmd->status = bfa_fcport_get_bbcr_attr(& bfad->bfa, & iocmd->attr);
  spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  return (0);
}
}
static int bfad_iocmd_lport_get_attr(struct bfad_s *bfad , void *cmd ) 
{ 
  struct bfa_fcs_lport_s *fcs_port ;
  struct bfa_bsg_lport_attr_s *iocmd ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;

  {
  iocmd = (struct bfa_bsg_lport_attr_s *)cmd;
  tmp = spinlock_check(& bfad->bfad_lock);
  flags = _raw_spin_lock_irqsave(tmp);
  fcs_port = bfa_fcs_lookup_port(& bfad->bfa_fcs, (int )iocmd->vf_id, iocmd->pwwn);
  if ((unsigned long )fcs_port == (unsigned long )((struct bfa_fcs_lport_s *)0)) {
    spin_unlock_irqrestore(& bfad->bfad_lock, flags);
    iocmd->status = 18;
    goto out;
  } else {

  }
  bfa_fcs_lport_get_attr(fcs_port, & iocmd->port_attr);
  spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  iocmd->status = 0;
  out: ;
  return (0);
}
}
int bfad_iocmd_lport_get_stats(struct bfad_s *bfad , void *cmd ) 
{ 
  struct bfa_fcs_lport_s *fcs_port ;
  struct bfa_bsg_lport_stats_s *iocmd ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;

  {
  iocmd = (struct bfa_bsg_lport_stats_s *)cmd;
  tmp = spinlock_check(& bfad->bfad_lock);
  flags = _raw_spin_lock_irqsave(tmp);
  fcs_port = bfa_fcs_lookup_port(& bfad->bfa_fcs, (int )iocmd->vf_id, iocmd->pwwn);
  if ((unsigned long )fcs_port == (unsigned long )((struct bfa_fcs_lport_s *)0)) {
    spin_unlock_irqrestore(& bfad->bfad_lock, flags);
    iocmd->status = 18;
    goto out;
  } else {

  }
  bfa_fcs_lport_get_stats(fcs_port, & iocmd->port_stats);
  spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  iocmd->status = 0;
  out: ;
  return (0);
}
}
int bfad_iocmd_lport_reset_stats(struct bfad_s *bfad , void *cmd ) 
{ 
  struct bfa_fcs_lport_s *fcs_port ;
  struct bfa_bsg_reset_stats_s *iocmd ;
  struct bfa_fcpim_s *fcpim ;
  struct list_head *qe ;
  struct list_head *qen ;
  struct bfa_itnim_s *itnim ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;

  {
  iocmd = (struct bfa_bsg_reset_stats_s *)cmd;
  fcpim = & bfad->bfa.modules.fcp_mod.fcpim;
  tmp = spinlock_check(& bfad->bfad_lock);
  flags = _raw_spin_lock_irqsave(tmp);
  fcs_port = bfa_fcs_lookup_port(& bfad->bfa_fcs, (int )iocmd->vf_id, iocmd->vpwwn);
  if ((unsigned long )fcs_port == (unsigned long )((struct bfa_fcs_lport_s *)0)) {
    spin_unlock_irqrestore(& bfad->bfad_lock, flags);
    iocmd->status = 18;
    goto out;
  } else {

  }
  bfa_fcs_lport_clear_stats(fcs_port);
  qe = fcpim->itnim_q.next;
  qen = qe->next;
  goto ldv_49160;
  ldv_49159: 
  itnim = (struct bfa_itnim_s *)qe;
  if ((int )(itnim->rport)->rport_info.lp_tag != (int )fcs_port->lp_tag) {
    goto ldv_49158;
  } else {

  }
  bfa_itnim_clear_stats(itnim);
  ldv_49158: 
  qe = qen;
  qen = qe->next;
  ldv_49160: ;
  if ((unsigned long )(& fcpim->itnim_q) != (unsigned long )qe) {
    goto ldv_49159;
  } else {

  }
  spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  iocmd->status = 0;
  out: ;
  return (0);
}
}
int bfad_iocmd_lport_get_iostats(struct bfad_s *bfad , void *cmd ) 
{ 
  struct bfa_fcs_lport_s *fcs_port ;
  struct bfa_bsg_lport_iostats_s *iocmd ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;

  {
  iocmd = (struct bfa_bsg_lport_iostats_s *)cmd;
  tmp = spinlock_check(& bfad->bfad_lock);
  flags = _raw_spin_lock_irqsave(tmp);
  fcs_port = bfa_fcs_lookup_port(& bfad->bfa_fcs, (int )iocmd->vf_id, iocmd->pwwn);
  if ((unsigned long )fcs_port == (unsigned long )((struct bfa_fcs_lport_s *)0)) {
    spin_unlock_irqrestore(& bfad->bfad_lock, flags);
    iocmd->status = 18;
    goto out;
  } else {

  }
  bfa_fcpim_port_iostats(& bfad->bfa, & iocmd->iostats, (int )fcs_port->lp_tag);
  spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  iocmd->status = 0;
  out: ;
  return (0);
}
}
int bfad_iocmd_lport_get_rports(struct bfad_s *bfad , void *cmd , unsigned int payload_len ) 
{ 
  struct bfa_bsg_lport_get_rports_s *iocmd ;
  struct bfa_fcs_lport_s *fcs_port ;
  unsigned long flags ;
  void *iocmd_bufptr ;
  raw_spinlock_t *tmp ;

  {
  iocmd = (struct bfa_bsg_lport_get_rports_s *)cmd;
  if (iocmd->nrports == 0U) {
    return (-22);
  } else {

  }
  if ((unsigned long )payload_len != ((unsigned long )iocmd->nrports + 2UL) * 16UL) {
    iocmd->status = 70;
    return (0);
  } else {

  }
  iocmd_bufptr = (void *)iocmd + 32U;
  tmp = spinlock_check(& bfad->bfad_lock);
  flags = _raw_spin_lock_irqsave(tmp);
  fcs_port = bfa_fcs_lookup_port(& bfad->bfa_fcs, (int )iocmd->vf_id, iocmd->pwwn);
  if ((unsigned long )fcs_port == (unsigned long )((struct bfa_fcs_lport_s *)0)) {
    spin_unlock_irqrestore(& bfad->bfad_lock, flags);
    __bfa_trc(bfad->trcmod, __trc_fileno___1, 586, 0ULL);
    iocmd->status = 18;
    goto out;
  } else {

  }
  bfa_fcs_lport_get_rport_quals(fcs_port, (struct bfa_rport_qualifier_s *)iocmd_bufptr,
                                (int *)(& iocmd->nrports));
  spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  iocmd->status = 0;
  out: ;
  return (0);
}
}
int bfad_iocmd_rport_get_attr(struct bfad_s *bfad , void *cmd ) 
{ 
  struct bfa_bsg_rport_attr_s *iocmd ;
  struct bfa_fcs_lport_s *fcs_port ;
  struct bfa_fcs_rport_s *fcs_rport ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;

  {
  iocmd = (struct bfa_bsg_rport_attr_s *)cmd;
  tmp = spinlock_check(& bfad->bfad_lock);
  flags = _raw_spin_lock_irqsave(tmp);
  fcs_port = bfa_fcs_lookup_port(& bfad->bfa_fcs, (int )iocmd->vf_id, iocmd->pwwn);
  if ((unsigned long )fcs_port == (unsigned long )((struct bfa_fcs_lport_s *)0)) {
    __bfa_trc(bfad->trcmod, __trc_fileno___1, 612, 0ULL);
    spin_unlock_irqrestore(& bfad->bfad_lock, flags);
    iocmd->status = 18;
    goto out;
  } else {

  }
  if (iocmd->pid != 0U) {
    fcs_rport = bfa_fcs_lport_get_rport_by_qualifier(fcs_port, iocmd->rpwwn, iocmd->pid);
  } else {
    fcs_rport = bfa_fcs_rport_lookup(fcs_port, iocmd->rpwwn);
  }
  if ((unsigned long )fcs_rport == (unsigned long )((struct bfa_fcs_rport_s *)0)) {
    __bfa_trc(bfad->trcmod, __trc_fileno___1, 624, 0ULL);
    spin_unlock_irqrestore(& bfad->bfad_lock, flags);
    iocmd->status = 19;
    goto out;
  } else {

  }
  bfa_fcs_rport_get_attr(fcs_rport, & iocmd->attr);
  spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  iocmd->status = 0;
  out: ;
  return (0);
}
}
static int bfad_iocmd_rport_get_addr(struct bfad_s *bfad , void *cmd ) 
{ 
  struct bfa_bsg_rport_scsi_addr_s *iocmd ;
  struct bfa_fcs_lport_s *fcs_port ;
  struct bfa_fcs_itnim_s *fcs_itnim ;
  struct bfad_itnim_s *drv_itnim ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;

  {
  iocmd = (struct bfa_bsg_rport_scsi_addr_s *)cmd;
  tmp = spinlock_check(& bfad->bfad_lock);
  flags = _raw_spin_lock_irqsave(tmp);
  fcs_port = bfa_fcs_lookup_port(& bfad->bfa_fcs, (int )iocmd->vf_id, iocmd->pwwn);
  if ((unsigned long )fcs_port == (unsigned long )((struct bfa_fcs_lport_s *)0)) {
    __bfa_trc(bfad->trcmod, __trc_fileno___1, 651, 0ULL);
    spin_unlock_irqrestore(& bfad->bfad_lock, flags);
    iocmd->status = 18;
    goto out;
  } else {

  }
  fcs_itnim = bfa_fcs_itnim_lookup(fcs_port, iocmd->rpwwn);
  if ((unsigned long )fcs_itnim == (unsigned long )((struct bfa_fcs_itnim_s *)0)) {
    __bfa_trc(bfad->trcmod, __trc_fileno___1, 659, 0ULL);
    spin_unlock_irqrestore(& bfad->bfad_lock, flags);
    iocmd->status = 19;
    goto out;
  } else {

  }
  drv_itnim = fcs_itnim->itnim_drv;
  if ((unsigned long )drv_itnim != (unsigned long )((struct bfad_itnim_s *)0) && (unsigned long )drv_itnim->im_port != (unsigned long )((struct bfad_im_port_s *)0)) {
    iocmd->host = ((drv_itnim->im_port)->shost)->host_no;
  } else {
    __bfa_trc(bfad->trcmod, __trc_fileno___1, 670, 0ULL);
    spin_unlock_irqrestore(& bfad->bfad_lock, flags);
    iocmd->status = 19;
    goto out;
  }
  iocmd->target = (u32 )drv_itnim->scsi_tgt_id;
  spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  iocmd->bus = 0U;
  iocmd->lun = 0U;
  iocmd->status = 0;
  out: ;
  return (0);
}
}
int bfad_iocmd_rport_get_stats(struct bfad_s *bfad , void *cmd ) 
{ 
  struct bfa_bsg_rport_stats_s *iocmd ;
  struct bfa_fcs_lport_s *fcs_port ;
  struct bfa_fcs_rport_s *fcs_rport ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;
  struct bfa_rport_s *tmp___0 ;
  struct bfa_rport_s *tmp___1 ;

  {
  iocmd = (struct bfa_bsg_rport_stats_s *)cmd;
  tmp = spinlock_check(& bfad->bfad_lock);
  flags = _raw_spin_lock_irqsave(tmp);
  fcs_port = bfa_fcs_lookup_port(& bfad->bfa_fcs, (int )iocmd->vf_id, iocmd->pwwn);
  if ((unsigned long )fcs_port == (unsigned long )((struct bfa_fcs_lport_s *)0)) {
    __bfa_trc(bfad->trcmod, __trc_fileno___1, 699, 0ULL);
    spin_unlock_irqrestore(& bfad->bfad_lock, flags);
    iocmd->status = 18;
    goto out;
  } else {

  }
  fcs_rport = bfa_fcs_rport_lookup(fcs_port, iocmd->rpwwn);
  if ((unsigned long )fcs_rport == (unsigned long )((struct bfa_fcs_rport_s *)0)) {
    __bfa_trc(bfad->trcmod, __trc_fileno___1, 707, 0ULL);
    spin_unlock_irqrestore(& bfad->bfad_lock, flags);
    iocmd->status = 19;
    goto out;
  } else {

  }
  memcpy((void *)(& iocmd->stats), (void const   *)(& fcs_rport->stats), 264UL);
  tmp___1 = bfa_fcs_rport_get_halrport(fcs_rport);
  if ((unsigned long )tmp___1 != (unsigned long )((struct bfa_rport_s *)0)) {
    tmp___0 = bfa_fcs_rport_get_halrport(fcs_rport);
    memcpy((void *)(& iocmd->stats.hal_stats), (void const   *)(& tmp___0->stats),
             152UL);
  } else {

  }
  spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  iocmd->status = 0;
  out: ;
  return (0);
}
}
int bfad_iocmd_rport_clr_stats(struct bfad_s *bfad , void *cmd ) 
{ 
  struct bfa_bsg_rport_reset_stats_s *iocmd ;
  struct bfa_fcs_lport_s *fcs_port ;
  struct bfa_fcs_rport_s *fcs_rport ;
  struct bfa_rport_s *rport ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;

  {
  iocmd = (struct bfa_bsg_rport_reset_stats_s *)cmd;
  tmp = spinlock_check(& bfad->bfad_lock);
  flags = _raw_spin_lock_irqsave(tmp);
  fcs_port = bfa_fcs_lookup_port(& bfad->bfa_fcs, (int )iocmd->vf_id, iocmd->pwwn);
  if ((unsigned long )fcs_port == (unsigned long )((struct bfa_fcs_lport_s *)0)) {
    spin_unlock_irqrestore(& bfad->bfad_lock, flags);
    iocmd->status = 18;
    goto out;
  } else {

  }
  fcs_rport = bfa_fcs_rport_lookup(fcs_port, iocmd->rpwwn);
  if ((unsigned long )fcs_rport == (unsigned long )((struct bfa_fcs_rport_s *)0)) {
    spin_unlock_irqrestore(& bfad->bfad_lock, flags);
    iocmd->status = 19;
    goto out;
  } else {

  }
  memset((void *)(& fcs_rport->stats), 0, 264UL);
  rport = bfa_fcs_rport_get_halrport(fcs_rport);
  if ((unsigned long )rport != (unsigned long )((struct bfa_rport_s *)0)) {
    memset((void *)(& rport->stats), 0, 152UL);
  } else {

  }
  spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  iocmd->status = 0;
  out: ;
  return (0);
}
}
int bfad_iocmd_rport_set_speed(struct bfad_s *bfad , void *cmd ) 
{ 
  struct bfa_bsg_rport_set_speed_s *iocmd ;
  struct bfa_fcs_lport_s *fcs_port ;
  struct bfa_fcs_rport_s *fcs_rport ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;

  {
  iocmd = (struct bfa_bsg_rport_set_speed_s *)cmd;
  tmp = spinlock_check(& bfad->bfad_lock);
  flags = _raw_spin_lock_irqsave(tmp);
  fcs_port = bfa_fcs_lookup_port(& bfad->bfa_fcs, (int )iocmd->vf_id, iocmd->pwwn);
  if ((unsigned long )fcs_port == (unsigned long )((struct bfa_fcs_lport_s *)0)) {
    spin_unlock_irqrestore(& bfad->bfad_lock, flags);
    iocmd->status = 18;
    goto out;
  } else {

  }
  fcs_rport = bfa_fcs_rport_lookup(fcs_port, iocmd->rpwwn);
  if ((unsigned long )fcs_rport == (unsigned long )((struct bfa_fcs_rport_s *)0)) {
    spin_unlock_irqrestore(& bfad->bfad_lock, flags);
    iocmd->status = 19;
    goto out;
  } else {

  }
  fcs_rport->rpf.assigned_speed = iocmd->speed;
  if ((unsigned int )fcs_rport->rpf.rpsc_speed == 0U) {
    if ((unsigned long )fcs_rport->bfa_rport != (unsigned long )((struct bfa_rport_s *)0)) {
      bfa_rport_speed(fcs_rport->bfa_rport, iocmd->speed);
    } else {

    }
  } else {

  }
  spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  iocmd->status = 0;
  out: ;
  return (0);
}
}
int bfad_iocmd_vport_get_attr(struct bfad_s *bfad , void *cmd ) 
{ 
  struct bfa_fcs_vport_s *fcs_vport ;
  struct bfa_bsg_vport_attr_s *iocmd ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;

  {
  iocmd = (struct bfa_bsg_vport_attr_s *)cmd;
  tmp = spinlock_check(& bfad->bfad_lock);
  flags = _raw_spin_lock_irqsave(tmp);
  fcs_vport = bfa_fcs_vport_lookup(& bfad->bfa_fcs, (int )iocmd->vf_id, iocmd->vpwwn);
  if ((unsigned long )fcs_vport == (unsigned long )((struct bfa_fcs_vport_s *)0)) {
    spin_unlock_irqrestore(& bfad->bfad_lock, flags);
    iocmd->status = 30;
    goto out;
  } else {

  }
  bfa_fcs_vport_get_attr(fcs_vport, & iocmd->vport_attr);
  spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  iocmd->status = 0;
  out: ;
  return (0);
}
}
int bfad_iocmd_vport_get_stats(struct bfad_s *bfad , void *cmd ) 
{ 
  struct bfa_fcs_vport_s *fcs_vport ;
  struct bfa_bsg_vport_stats_s *iocmd ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;

  {
  iocmd = (struct bfa_bsg_vport_stats_s *)cmd;
  tmp = spinlock_check(& bfad->bfad_lock);
  flags = _raw_spin_lock_irqsave(tmp);
  fcs_vport = bfa_fcs_vport_lookup(& bfad->bfa_fcs, (int )iocmd->vf_id, iocmd->vpwwn);
  if ((unsigned long )fcs_vport == (unsigned long )((struct bfa_fcs_vport_s *)0)) {
    spin_unlock_irqrestore(& bfad->bfad_lock, flags);
    iocmd->status = 30;
    goto out;
  } else {

  }
  memcpy((void *)(& iocmd->vport_stats), (void const   *)(& fcs_vport->vport_stats),
           328UL);
  memcpy((void *)(& iocmd->vport_stats.port_stats), (void const   *)(& fcs_vport->lport.stats),
           248UL);
  spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  iocmd->status = 0;
  out: ;
  return (0);
}
}
int bfad_iocmd_vport_clr_stats(struct bfad_s *bfad , void *cmd ) 
{ 
  struct bfa_fcs_vport_s *fcs_vport ;
  struct bfa_bsg_reset_stats_s *iocmd ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;

  {
  iocmd = (struct bfa_bsg_reset_stats_s *)cmd;
  tmp = spinlock_check(& bfad->bfad_lock);
  flags = _raw_spin_lock_irqsave(tmp);
  fcs_vport = bfa_fcs_vport_lookup(& bfad->bfa_fcs, (int )iocmd->vf_id, iocmd->vpwwn);
  if ((unsigned long )fcs_vport == (unsigned long )((struct bfa_fcs_vport_s *)0)) {
    spin_unlock_irqrestore(& bfad->bfad_lock, flags);
    iocmd->status = 30;
    goto out;
  } else {

  }
  memset((void *)(& fcs_vport->vport_stats), 0, 328UL);
  memset((void *)(& fcs_vport->lport.stats), 0, 248UL);
  spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  iocmd->status = 0;
  out: ;
  return (0);
}
}
static int bfad_iocmd_fabric_get_lports(struct bfad_s *bfad , void *cmd , unsigned int payload_len ) 
{ 
  struct bfa_bsg_fabric_get_lports_s *iocmd ;
  struct bfa_fcs_fabric_s *fcs_vf ;
  uint32_t nports ;
  unsigned long flags ;
  void *iocmd_bufptr ;
  raw_spinlock_t *tmp ;

  {
  iocmd = (struct bfa_bsg_fabric_get_lports_s *)cmd;
  nports = iocmd->nports;
  if (nports == 0U) {
    iocmd->status = 2;
    goto out;
  } else {

  }
  if ((unsigned long )payload_len != ((unsigned long )iocmd->nports + 3UL) * 8UL) {
    iocmd->status = 70;
    goto out;
  } else {

  }
  iocmd_bufptr = (void *)iocmd + 24U;
  tmp = spinlock_check(& bfad->bfad_lock);
  flags = _raw_spin_lock_irqsave(tmp);
  fcs_vf = bfa_fcs_vf_lookup(& bfad->bfa_fcs, (int )iocmd->vf_id);
  if ((unsigned long )fcs_vf == (unsigned long )((struct bfa_fcs_fabric_s *)0)) {
    spin_unlock_irqrestore(& bfad->bfad_lock, flags);
    iocmd->status = 11;
    goto out;
  } else {

  }
  bfa_fcs_vf_get_ports(fcs_vf, (wwn_t *)iocmd_bufptr, (int *)(& nports));
  spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  iocmd->nports = nports;
  iocmd->status = 0;
  out: ;
  return (0);
}
}
int bfad_iocmd_qos_set_bw(struct bfad_s *bfad , void *pcmd ) 
{ 
  struct bfa_bsg_qos_bw_s *iocmd ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;

  {
  iocmd = (struct bfa_bsg_qos_bw_s *)pcmd;
  tmp = spinlock_check(& bfad->bfad_lock);
  flags = _raw_spin_lock_irqsave(tmp);
  iocmd->status = bfa_fcport_set_qos_bw(& bfad->bfa, & iocmd->qos_bw);
  spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  return (0);
}
}
int bfad_iocmd_ratelim(struct bfad_s *bfad , unsigned int cmd , void *pcmd ) 
{ 
  struct bfa_bsg_gen_s *iocmd ;
  struct bfa_fcport_s *fcport ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;

  {
  iocmd = (struct bfa_bsg_gen_s *)pcmd;
  fcport = & bfad->bfa.modules.fcport;
  tmp = spinlock_check(& bfad->bfad_lock);
  flags = _raw_spin_lock_irqsave(tmp);
  if ((unsigned int )fcport->cfg.topology == 2U && (unsigned int )fcport->topology == 2U) {
    iocmd->status = 230;
  } else {
    if (cmd == 41U) {
      fcport->cfg.ratelimit = 1U;
    } else
    if (cmd == 42U) {
      fcport->cfg.ratelimit = 0U;
    } else {

    }
    if ((unsigned int )fcport->cfg.trl_def_speed == 0U) {
      fcport->cfg.trl_def_speed = 1U;
    } else {

    }
    iocmd->status = 0;
  }
  spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  return (0);
}
}
int bfad_iocmd_ratelim_speed(struct bfad_s *bfad , unsigned int cmd , void *pcmd ) 
{ 
  struct bfa_bsg_trl_speed_s *iocmd ;
  struct bfa_fcport_s *fcport ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;

  {
  iocmd = (struct bfa_bsg_trl_speed_s *)pcmd;
  fcport = & bfad->bfa.modules.fcport;
  tmp = spinlock_check(& bfad->bfad_lock);
  flags = _raw_spin_lock_irqsave(tmp);
  if ((unsigned int )iocmd->speed == 15U || (unsigned int )iocmd->speed > (unsigned int )fcport->speed_sup) {
    iocmd->status = 23;
    spin_unlock_irqrestore(& bfad->bfad_lock, flags);
    return (0);
  } else {

  }
  if ((unsigned int )fcport->cfg.topology == 2U && (unsigned int )fcport->topology == 2U) {
    iocmd->status = 230;
  } else {
    fcport->cfg.trl_def_speed = (u8 )iocmd->speed;
    iocmd->status = 0;
  }
  spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  return (0);
}
}
int bfad_iocmd_cfg_fcpim(struct bfad_s *bfad , void *cmd ) 
{ 
  struct bfa_bsg_fcpim_s *iocmd ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;

  {
  iocmd = (struct bfa_bsg_fcpim_s *)cmd;
  tmp = spinlock_check(& bfad->bfad_lock);
  flags = _raw_spin_lock_irqsave(tmp);
  bfa_fcpim_path_tov_set(& bfad->bfa, (int )iocmd->param);
  spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  iocmd->status = 0;
  return (0);
}
}
int bfad_iocmd_fcpim_get_modstats(struct bfad_s *bfad , void *cmd ) 
{ 
  struct bfa_bsg_fcpim_modstats_s *iocmd ;
  struct bfa_fcpim_s *fcpim ;
  struct list_head *qe ;
  struct list_head *qen ;
  struct bfa_itnim_s *itnim ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;

  {
  iocmd = (struct bfa_bsg_fcpim_modstats_s *)cmd;
  fcpim = & bfad->bfa.modules.fcp_mod.fcpim;
  tmp = spinlock_check(& bfad->bfad_lock);
  flags = _raw_spin_lock_irqsave(tmp);
  memset((void *)(& iocmd->modstats), 0, 216UL);
  qe = fcpim->itnim_q.next;
  qen = qe->next;
  goto ldv_49349;
  ldv_49348: 
  itnim = (struct bfa_itnim_s *)qe;
  bfa_fcpim_add_stats(& iocmd->modstats, & itnim->stats);
  qe = qen;
  qen = qe->next;
  ldv_49349: ;
  if ((unsigned long )(& fcpim->itnim_q) != (unsigned long )qe) {
    goto ldv_49348;
  } else {

  }
  spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  iocmd->status = 0;
  return (0);
}
}
int bfad_iocmd_fcpim_clr_modstats(struct bfad_s *bfad , void *cmd ) 
{ 
  struct bfa_bsg_fcpim_modstatsclr_s *iocmd ;
  struct bfa_fcpim_s *fcpim ;
  struct list_head *qe ;
  struct list_head *qen ;
  struct bfa_itnim_s *itnim ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;

  {
  iocmd = (struct bfa_bsg_fcpim_modstatsclr_s *)cmd;
  fcpim = & bfad->bfa.modules.fcp_mod.fcpim;
  tmp = spinlock_check(& bfad->bfad_lock);
  flags = _raw_spin_lock_irqsave(tmp);
  qe = fcpim->itnim_q.next;
  qen = qe->next;
  goto ldv_49365;
  ldv_49364: 
  itnim = (struct bfa_itnim_s *)qe;
  bfa_itnim_clear_stats(itnim);
  qe = qen;
  qen = qe->next;
  ldv_49365: ;
  if ((unsigned long )(& fcpim->itnim_q) != (unsigned long )qe) {
    goto ldv_49364;
  } else {

  }
  memset((void *)(& fcpim->del_itn_stats), 0, 32UL);
  spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  iocmd->status = 0;
  return (0);
}
}
int bfad_iocmd_fcpim_get_del_itn_stats(struct bfad_s *bfad , void *cmd ) 
{ 
  struct bfa_bsg_fcpim_del_itn_stats_s *iocmd ;
  struct bfa_fcpim_s *fcpim ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;

  {
  iocmd = (struct bfa_bsg_fcpim_del_itn_stats_s *)cmd;
  fcpim = & bfad->bfa.modules.fcp_mod.fcpim;
  tmp = spinlock_check(& bfad->bfad_lock);
  flags = _raw_spin_lock_irqsave(tmp);
  memcpy((void *)(& iocmd->modstats), (void const   *)(& fcpim->del_itn_stats),
           32UL);
  spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  iocmd->status = 0;
  return (0);
}
}
static int bfad_iocmd_itnim_get_attr(struct bfad_s *bfad , void *cmd ) 
{ 
  struct bfa_bsg_itnim_attr_s *iocmd ;
  struct bfa_fcs_lport_s *fcs_port ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;

  {
  iocmd = (struct bfa_bsg_itnim_attr_s *)cmd;
  tmp = spinlock_check(& bfad->bfad_lock);
  flags = _raw_spin_lock_irqsave(tmp);
  fcs_port = bfa_fcs_lookup_port(& bfad->bfa_fcs, (int )iocmd->vf_id, iocmd->lpwwn);
  if ((unsigned long )fcs_port == (unsigned long )((struct bfa_fcs_lport_s *)0)) {
    iocmd->status = 18;
  } else {
    iocmd->status = bfa_fcs_itnim_attr_get(fcs_port, iocmd->rpwwn, & iocmd->attr);
  }
  spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  return (0);
}
}
static int bfad_iocmd_itnim_get_iostats(struct bfad_s *bfad , void *cmd ) 
{ 
  struct bfa_bsg_itnim_iostats_s *iocmd ;
  struct bfa_fcs_lport_s *fcs_port ;
  struct bfa_fcs_itnim_s *itnim ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;
  struct bfa_itnim_s *tmp___0 ;
  struct bfa_itnim_s *tmp___1 ;

  {
  iocmd = (struct bfa_bsg_itnim_iostats_s *)cmd;
  tmp = spinlock_check(& bfad->bfad_lock);
  flags = _raw_spin_lock_irqsave(tmp);
  fcs_port = bfa_fcs_lookup_port(& bfad->bfa_fcs, (int )iocmd->vf_id, iocmd->lpwwn);
  if ((unsigned long )fcs_port == (unsigned long )((struct bfa_fcs_lport_s *)0)) {
    iocmd->status = 18;
    __bfa_trc(bfad->trcmod, __trc_fileno___1, 1095, 0ULL);
  } else {
    itnim = bfa_fcs_itnim_lookup(fcs_port, iocmd->rpwwn);
    if ((unsigned long )itnim == (unsigned long )((struct bfa_fcs_itnim_s *)0)) {
      iocmd->status = 19;
    } else {
      iocmd->status = 0;
      tmp___1 = bfa_fcs_itnim_get_halitn(itnim);
      if ((unsigned long )tmp___1 != (unsigned long )((struct bfa_itnim_s *)0)) {
        tmp___0 = bfa_fcs_itnim_get_halitn(itnim);
        memcpy((void *)(& iocmd->iostats), (void const   *)(& tmp___0->stats), 216UL);
      } else {

      }
    }
  }
  spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  return (0);
}
}
static int bfad_iocmd_itnim_reset_stats(struct bfad_s *bfad , void *cmd ) 
{ 
  struct bfa_bsg_rport_reset_stats_s *iocmd ;
  struct bfa_fcs_lport_s *fcs_port ;
  struct bfa_fcs_itnim_s *itnim ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;
  struct bfa_itnim_s *tmp___0 ;

  {
  iocmd = (struct bfa_bsg_rport_reset_stats_s *)cmd;
  tmp = spinlock_check(& bfad->bfad_lock);
  flags = _raw_spin_lock_irqsave(tmp);
  fcs_port = bfa_fcs_lookup_port(& bfad->bfa_fcs, (int )iocmd->vf_id, iocmd->pwwn);
  if ((unsigned long )fcs_port == (unsigned long )((struct bfa_fcs_lport_s *)0)) {
    iocmd->status = 18;
  } else {
    itnim = bfa_fcs_itnim_lookup(fcs_port, iocmd->rpwwn);
    if ((unsigned long )itnim == (unsigned long )((struct bfa_fcs_itnim_s *)0)) {
      iocmd->status = 19;
    } else {
      iocmd->status = 0;
      bfa_fcs_itnim_stats_clear(fcs_port, iocmd->rpwwn);
      tmp___0 = bfa_fcs_itnim_get_halitn(itnim);
      bfa_itnim_clear_stats(tmp___0);
    }
  }
  spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  return (0);
}
}
static int bfad_iocmd_itnim_get_itnstats(struct bfad_s *bfad , void *cmd ) 
{ 
  struct bfa_bsg_itnim_itnstats_s *iocmd ;
  struct bfa_fcs_lport_s *fcs_port ;
  struct bfa_fcs_itnim_s *itnim ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;

  {
  iocmd = (struct bfa_bsg_itnim_itnstats_s *)cmd;
  tmp = spinlock_check(& bfad->bfad_lock);
  flags = _raw_spin_lock_irqsave(tmp);
  fcs_port = bfa_fcs_lookup_port(& bfad->bfa_fcs, (int )iocmd->vf_id, iocmd->lpwwn);
  if ((unsigned long )fcs_port == (unsigned long )((struct bfa_fcs_lport_s *)0)) {
    iocmd->status = 18;
    __bfa_trc(bfad->trcmod, __trc_fileno___1, 1155, 0ULL);
  } else {
    itnim = bfa_fcs_itnim_lookup(fcs_port, iocmd->rpwwn);
    if ((unsigned long )itnim == (unsigned long )((struct bfa_fcs_itnim_s *)0)) {
      iocmd->status = 19;
    } else {
      iocmd->status = 0;
      bfa_fcs_itnim_stats_get(fcs_port, iocmd->rpwwn, & iocmd->itnstats);
    }
  }
  spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  return (0);
}
}
int bfad_iocmd_fcport_enable(struct bfad_s *bfad , void *cmd ) 
{ 
  struct bfa_bsg_gen_s *iocmd ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;

  {
  iocmd = (struct bfa_bsg_gen_s *)cmd;
  tmp = spinlock_check(& bfad->bfad_lock);
  flags = _raw_spin_lock_irqsave(tmp);
  iocmd->status = bfa_fcport_enable(& bfad->bfa);
  spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  return (0);
}
}
int bfad_iocmd_fcport_disable(struct bfad_s *bfad , void *cmd ) 
{ 
  struct bfa_bsg_gen_s *iocmd ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;

  {
  iocmd = (struct bfa_bsg_gen_s *)cmd;
  tmp = spinlock_check(& bfad->bfad_lock);
  flags = _raw_spin_lock_irqsave(tmp);
  iocmd->status = bfa_fcport_disable(& bfad->bfa);
  spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  return (0);
}
}
int bfad_iocmd_ioc_get_pcifn_cfg(struct bfad_s *bfad , void *cmd ) 
{ 
  struct bfa_bsg_pcifn_cfg_s *iocmd ;
  struct bfad_hal_comp fcomp ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;

  {
  iocmd = (struct bfa_bsg_pcifn_cfg_s *)cmd;
  init_completion(& fcomp.comp);
  tmp = spinlock_check(& bfad->bfad_lock);
  flags = _raw_spin_lock_irqsave(tmp);
  iocmd->status = bfa_ablk_query(& bfad->bfa.modules.ablk, & iocmd->pcifn_cfg, & bfad_hcb_comp,
                                 (void *)(& fcomp));
  spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  if ((unsigned int )iocmd->status != 0U) {
    goto out;
  } else {

  }
  wait_for_completion(& fcomp.comp);
  iocmd->status = fcomp.status;
  out: ;
  return (0);
}
}
int bfad_iocmd_pcifn_create(struct bfad_s *bfad , void *cmd ) 
{ 
  struct bfa_bsg_pcifn_s *iocmd ;
  struct bfad_hal_comp fcomp ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;

  {
  iocmd = (struct bfa_bsg_pcifn_s *)cmd;
  init_completion(& fcomp.comp);
  tmp = spinlock_check(& bfad->bfad_lock);
  flags = _raw_spin_lock_irqsave(tmp);
  iocmd->status = bfa_ablk_pf_create(& bfad->bfa.modules.ablk, & iocmd->pcifn_id,
                                     (int )iocmd->port, iocmd->pcifn_class, (int )iocmd->bw_min,
                                     (int )iocmd->bw_max, & bfad_hcb_comp, (void *)(& fcomp));
  spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  if ((unsigned int )iocmd->status != 0U) {
    goto out;
  } else {

  }
  wait_for_completion(& fcomp.comp);
  iocmd->status = fcomp.status;
  out: ;
  return (0);
}
}
int bfad_iocmd_pcifn_delete(struct bfad_s *bfad , void *cmd ) 
{ 
  struct bfa_bsg_pcifn_s *iocmd ;
  struct bfad_hal_comp fcomp ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;

  {
  iocmd = (struct bfa_bsg_pcifn_s *)cmd;
  init_completion(& fcomp.comp);
  tmp = spinlock_check(& bfad->bfad_lock);
  flags = _raw_spin_lock_irqsave(tmp);
  iocmd->status = bfa_ablk_pf_delete(& bfad->bfa.modules.ablk, (int )iocmd->pcifn_id,
                                     & bfad_hcb_comp, (void *)(& fcomp));
  spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  if ((unsigned int )iocmd->status != 0U) {
    goto out;
  } else {

  }
  wait_for_completion(& fcomp.comp);
  iocmd->status = fcomp.status;
  out: ;
  return (0);
}
}
int bfad_iocmd_pcifn_bw(struct bfad_s *bfad , void *cmd ) 
{ 
  struct bfa_bsg_pcifn_s *iocmd ;
  struct bfad_hal_comp fcomp ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;

  {
  iocmd = (struct bfa_bsg_pcifn_s *)cmd;
  init_completion(& fcomp.comp);
  tmp = spinlock_check(& bfad->bfad_lock);
  flags = _raw_spin_lock_irqsave(tmp);
  iocmd->status = bfa_ablk_pf_update(& bfad->bfa.modules.ablk, (int )iocmd->pcifn_id,
                                     (int )iocmd->bw_min, (int )iocmd->bw_max, & bfad_hcb_comp,
                                     (void *)(& fcomp));
  spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  __bfa_trc(bfad->trcmod, __trc_fileno___1, 1276, (unsigned long long )iocmd->status);
  if ((unsigned int )iocmd->status != 0U) {
    goto out;
  } else {

  }
  wait_for_completion(& fcomp.comp);
  iocmd->status = fcomp.status;
  __bfa_trc(bfad->trcmod, __trc_fileno___1, 1282, (unsigned long long )iocmd->status);
  out: ;
  return (0);
}
}
int bfad_iocmd_adapter_cfg_mode(struct bfad_s *bfad , void *cmd ) 
{ 
  struct bfa_bsg_adapter_cfg_mode_s *iocmd ;
  struct bfad_hal_comp fcomp ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;

  {
  iocmd = (struct bfa_bsg_adapter_cfg_mode_s *)cmd;
  flags = 0UL;
  init_completion(& fcomp.comp);
  tmp = spinlock_check(& bfad->bfad_lock);
  flags = _raw_spin_lock_irqsave(tmp);
  iocmd->status = bfa_ablk_adapter_config(& bfad->bfa.modules.ablk, iocmd->cfg.mode,
                                          (int )iocmd->cfg.max_pf, (int )iocmd->cfg.max_vf,
                                          & bfad_hcb_comp, (void *)(& fcomp));
  spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  if ((unsigned int )iocmd->status != 0U) {
    goto out;
  } else {

  }
  wait_for_completion(& fcomp.comp);
  iocmd->status = fcomp.status;
  out: ;
  return (0);
}
}
int bfad_iocmd_port_cfg_mode(struct bfad_s *bfad , void *cmd ) 
{ 
  struct bfa_bsg_port_cfg_mode_s *iocmd ;
  struct bfad_hal_comp fcomp ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;

  {
  iocmd = (struct bfa_bsg_port_cfg_mode_s *)cmd;
  flags = 0UL;
  init_completion(& fcomp.comp);
  tmp = spinlock_check(& bfad->bfad_lock);
  flags = _raw_spin_lock_irqsave(tmp);
  iocmd->status = bfa_ablk_port_config(& bfad->bfa.modules.ablk, (int )iocmd->instance,
                                       iocmd->cfg.mode, (int )iocmd->cfg.max_pf, (int )iocmd->cfg.max_vf,
                                       & bfad_hcb_comp, (void *)(& fcomp));
  spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  if ((unsigned int )iocmd->status != 0U) {
    goto out;
  } else {

  }
  wait_for_completion(& fcomp.comp);
  iocmd->status = fcomp.status;
  out: ;
  return (0);
}
}
int bfad_iocmd_ablk_optrom(struct bfad_s *bfad , unsigned int cmd , void *pcmd ) 
{ 
  struct bfa_bsg_gen_s *iocmd ;
  struct bfad_hal_comp fcomp ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;

  {
  iocmd = (struct bfa_bsg_gen_s *)pcmd;
  init_completion(& fcomp.comp);
  tmp = spinlock_check(& bfad->bfad_lock);
  flags = _raw_spin_lock_irqsave(tmp);
  if (cmd == 60U) {
    iocmd->status = bfa_ablk_optrom_en(& bfad->bfa.modules.ablk, & bfad_hcb_comp,
                                       (void *)(& fcomp));
  } else {
    iocmd->status = bfa_ablk_optrom_dis(& bfad->bfa.modules.ablk, & bfad_hcb_comp,
                                        (void *)(& fcomp));
  }
  spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  if ((unsigned int )iocmd->status != 0U) {
    goto out;
  } else {

  }
  wait_for_completion(& fcomp.comp);
  iocmd->status = fcomp.status;
  out: ;
  return (0);
}
}
int bfad_iocmd_faa_query(struct bfad_s *bfad , void *cmd ) 
{ 
  struct bfa_bsg_faa_attr_s *iocmd ;
  struct bfad_hal_comp fcomp ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;

  {
  iocmd = (struct bfa_bsg_faa_attr_s *)cmd;
  init_completion(& fcomp.comp);
  iocmd->status = 0;
  tmp = spinlock_check(& bfad->bfad_lock);
  flags = _raw_spin_lock_irqsave(tmp);
  iocmd->status = bfa_faa_query(& bfad->bfa, & iocmd->faa_attr, & bfad_hcb_comp, (void *)(& fcomp));
  spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  if ((unsigned int )iocmd->status != 0U) {
    goto out;
  } else {

  }
  wait_for_completion(& fcomp.comp);
  iocmd->status = fcomp.status;
  out: ;
  return (0);
}
}
int bfad_iocmd_cee_attr(struct bfad_s *bfad , void *cmd , unsigned int payload_len ) 
{ 
  struct bfa_bsg_cee_attr_s *iocmd ;
  void *iocmd_bufptr ;
  struct bfad_hal_comp cee_comp ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;

  {
  iocmd = (struct bfa_bsg_cee_attr_s *)cmd;
  if (payload_len != 856U) {
    iocmd->status = 70;
    return (0);
  } else {

  }
  iocmd_bufptr = (void *)iocmd + 24U;
  cee_comp.status = 0;
  init_completion(& cee_comp.comp);
  ldv_mutex_lock_208(& bfad_mutex);
  tmp = spinlock_check(& bfad->bfad_lock);
  flags = _raw_spin_lock_irqsave(tmp);
  iocmd->status = bfa_cee_get_attr(& bfad->bfa.modules.cee, (struct bfa_cee_attr_s *)iocmd_bufptr,
                                   & bfad_hcb_comp, (void *)(& cee_comp));
  spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  if ((unsigned int )iocmd->status != 0U) {
    ldv_mutex_unlock_209(& bfad_mutex);
    __bfa_trc(bfad->trcmod, __trc_fileno___1, 1410, 21845ULL);
    goto out;
  } else {

  }
  wait_for_completion(& cee_comp.comp);
  ldv_mutex_unlock_210(& bfad_mutex);
  out: ;
  return (0);
}
}
int bfad_iocmd_cee_get_stats(struct bfad_s *bfad , void *cmd , unsigned int payload_len ) 
{ 
  struct bfa_bsg_cee_stats_s *iocmd ;
  void *iocmd_bufptr ;
  struct bfad_hal_comp cee_comp ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;

  {
  iocmd = (struct bfa_bsg_cee_stats_s *)cmd;
  if (payload_len != 96U) {
    iocmd->status = 70;
    return (0);
  } else {

  }
  iocmd_bufptr = (void *)iocmd + 24U;
  cee_comp.status = 0;
  init_completion(& cee_comp.comp);
  ldv_mutex_lock_211(& bfad_mutex);
  tmp = spinlock_check(& bfad->bfad_lock);
  flags = _raw_spin_lock_irqsave(tmp);
  iocmd->status = bfa_cee_get_stats(& bfad->bfa.modules.cee, (struct bfa_cee_stats_s *)iocmd_bufptr,
                                    & bfad_hcb_comp, (void *)(& cee_comp));
  spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  if ((unsigned int )iocmd->status != 0U) {
    ldv_mutex_unlock_212(& bfad_mutex);
    __bfa_trc(bfad->trcmod, __trc_fileno___1, 1447, 21845ULL);
    goto out;
  } else {

  }
  wait_for_completion(& cee_comp.comp);
  ldv_mutex_unlock_213(& bfad_mutex);
  out: ;
  return (0);
}
}
int bfad_iocmd_cee_reset_stats(struct bfad_s *bfad , void *cmd ) 
{ 
  struct bfa_bsg_gen_s *iocmd ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;

  {
  iocmd = (struct bfa_bsg_gen_s *)cmd;
  tmp = spinlock_check(& bfad->bfad_lock);
  flags = _raw_spin_lock_irqsave(tmp);
  iocmd->status = bfa_cee_reset_stats(& bfad->bfa.modules.cee, (void (*)(void * ,
                                                                         enum bfa_status  ))0,
                                      (void *)0);
  spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  if ((unsigned int )iocmd->status != 0U) {
    __bfa_trc(bfad->trcmod, __trc_fileno___1, 1466, 21845ULL);
  } else {

  }
  return (0);
}
}
int bfad_iocmd_sfp_media(struct bfad_s *bfad , void *cmd ) 
{ 
  struct bfa_bsg_sfp_media_s *iocmd ;
  struct bfad_hal_comp fcomp ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;

  {
  iocmd = (struct bfa_bsg_sfp_media_s *)cmd;
  init_completion(& fcomp.comp);
  tmp = spinlock_check(& bfad->bfad_lock);
  flags = _raw_spin_lock_irqsave(tmp);
  iocmd->status = bfa_sfp_media(& bfad->bfa.modules.sfp, & iocmd->media, & bfad_hcb_comp,
                                (void *)(& fcomp));
  spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  __bfa_trc(bfad->trcmod, __trc_fileno___1, 1482, (unsigned long long )iocmd->status);
  if ((unsigned int )iocmd->status != 159U) {
    goto out;
  } else {

  }
  wait_for_completion(& fcomp.comp);
  iocmd->status = fcomp.status;
  out: ;
  return (0);
}
}
int bfad_iocmd_sfp_speed(struct bfad_s *bfad , void *cmd ) 
{ 
  struct bfa_bsg_sfp_speed_s *iocmd ;
  struct bfad_hal_comp fcomp ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;

  {
  iocmd = (struct bfa_bsg_sfp_speed_s *)cmd;
  init_completion(& fcomp.comp);
  tmp = spinlock_check(& bfad->bfad_lock);
  flags = _raw_spin_lock_irqsave(tmp);
  iocmd->status = bfa_sfp_speed(& bfad->bfa.modules.sfp, iocmd->speed, & bfad_hcb_comp,
                                (void *)(& fcomp));
  spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  __bfa_trc(bfad->trcmod, __trc_fileno___1, 1504, (unsigned long long )iocmd->status);
  if ((unsigned int )iocmd->status != 159U) {
    goto out;
  } else {

  }
  wait_for_completion(& fcomp.comp);
  iocmd->status = fcomp.status;
  out: ;
  return (0);
}
}
int bfad_iocmd_flash_get_attr(struct bfad_s *bfad , void *cmd ) 
{ 
  struct bfa_bsg_flash_attr_s *iocmd ;
  struct bfad_hal_comp fcomp ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;

  {
  iocmd = (struct bfa_bsg_flash_attr_s *)cmd;
  init_completion(& fcomp.comp);
  tmp = spinlock_check(& bfad->bfad_lock);
  flags = _raw_spin_lock_irqsave(tmp);
  iocmd->status = bfa_flash_get_attr(& bfad->bfa.modules.flash, & iocmd->attr, & bfad_hcb_comp,
                                     (void *)(& fcomp));
  spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  if ((unsigned int )iocmd->status != 0U) {
    goto out;
  } else {

  }
  wait_for_completion(& fcomp.comp);
  iocmd->status = fcomp.status;
  out: ;
  return (0);
}
}
int bfad_iocmd_flash_erase_part(struct bfad_s *bfad , void *cmd ) 
{ 
  struct bfa_bsg_flash_s *iocmd ;
  struct bfad_hal_comp fcomp ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;

  {
  iocmd = (struct bfa_bsg_flash_s *)cmd;
  init_completion(& fcomp.comp);
  tmp = spinlock_check(& bfad->bfad_lock);
  flags = _raw_spin_lock_irqsave(tmp);
  iocmd->status = bfa_flash_erase_part(& bfad->bfa.modules.flash, iocmd->type, (int )iocmd->instance,
                                       & bfad_hcb_comp, (void *)(& fcomp));
  spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  if ((unsigned int )iocmd->status != 0U) {
    goto out;
  } else {

  }
  wait_for_completion(& fcomp.comp);
  iocmd->status = fcomp.status;
  out: ;
  return (0);
}
}
int bfad_iocmd_flash_update_part(struct bfad_s *bfad , void *cmd , unsigned int payload_len ) 
{ 
  struct bfa_bsg_flash_s *iocmd ;
  void *iocmd_bufptr ;
  struct bfad_hal_comp fcomp ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;

  {
  iocmd = (struct bfa_bsg_flash_s *)cmd;
  if ((unsigned long )payload_len != (unsigned long )iocmd->bufsz + 24UL) {
    iocmd->status = 70;
    return (0);
  } else {

  }
  iocmd_bufptr = (void *)iocmd + 24U;
  init_completion(& fcomp.comp);
  tmp = spinlock_check(& bfad->bfad_lock);
  flags = _raw_spin_lock_irqsave(tmp);
  iocmd->status = bfa_flash_update_part(& bfad->bfa.modules.flash, iocmd->type, (int )iocmd->instance,
                                        iocmd_bufptr, (u32 )iocmd->bufsz, 0U, & bfad_hcb_comp,
                                        (void *)(& fcomp));
  spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  if ((unsigned int )iocmd->status != 0U) {
    goto out;
  } else {

  }
  wait_for_completion(& fcomp.comp);
  iocmd->status = fcomp.status;
  out: ;
  return (0);
}
}
int bfad_iocmd_flash_read_part(struct bfad_s *bfad , void *cmd , unsigned int payload_len ) 
{ 
  struct bfa_bsg_flash_s *iocmd ;
  struct bfad_hal_comp fcomp ;
  void *iocmd_bufptr ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;

  {
  iocmd = (struct bfa_bsg_flash_s *)cmd;
  if ((unsigned long )payload_len != (unsigned long )iocmd->bufsz + 24UL) {
    iocmd->status = 70;
    return (0);
  } else {

  }
  iocmd_bufptr = (void *)iocmd + 24U;
  init_completion(& fcomp.comp);
  tmp = spinlock_check(& bfad->bfad_lock);
  flags = _raw_spin_lock_irqsave(tmp);
  iocmd->status = bfa_flash_read_part(& bfad->bfa.modules.flash, iocmd->type, (int )iocmd->instance,
                                      iocmd_bufptr, (u32 )iocmd->bufsz, 0U, & bfad_hcb_comp,
                                      (void *)(& fcomp));
  spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  if ((unsigned int )iocmd->status != 0U) {
    goto out;
  } else {

  }
  wait_for_completion(& fcomp.comp);
  iocmd->status = fcomp.status;
  out: ;
  return (0);
}
}
int bfad_iocmd_diag_temp(struct bfad_s *bfad , void *cmd ) 
{ 
  struct bfa_bsg_diag_get_temp_s *iocmd ;
  struct bfad_hal_comp fcomp ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;

  {
  iocmd = (struct bfa_bsg_diag_get_temp_s *)cmd;
  init_completion(& fcomp.comp);
  tmp = spinlock_check(& bfad->bfad_lock);
  flags = _raw_spin_lock_irqsave(tmp);
  iocmd->status = bfa_diag_tsensor_query(& bfad->bfa.modules.diag_mod, & iocmd->result,
                                         & bfad_hcb_comp, (void *)(& fcomp));
  spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  __bfa_trc(bfad->trcmod, __trc_fileno___1, 1631, (unsigned long long )iocmd->status);
  if ((unsigned int )iocmd->status != 0U) {
    goto out;
  } else {

  }
  wait_for_completion(& fcomp.comp);
  iocmd->status = fcomp.status;
  out: ;
  return (0);
}
}
int bfad_iocmd_diag_memtest(struct bfad_s *bfad , void *cmd ) 
{ 
  struct bfa_bsg_diag_memtest_s *iocmd ;
  struct bfad_hal_comp fcomp ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;

  {
  iocmd = (struct bfa_bsg_diag_memtest_s *)cmd;
  init_completion(& fcomp.comp);
  tmp = spinlock_check(& bfad->bfad_lock);
  flags = _raw_spin_lock_irqsave(tmp);
  iocmd->status = bfa_diag_memtest(& bfad->bfa.modules.diag_mod, & iocmd->memtest,
                                   iocmd->pat, & iocmd->result, & bfad_hcb_comp, (void *)(& fcomp));
  spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  __bfa_trc(bfad->trcmod, __trc_fileno___1, 1654, (unsigned long long )iocmd->status);
  if ((unsigned int )iocmd->status != 0U) {
    goto out;
  } else {

  }
  wait_for_completion(& fcomp.comp);
  iocmd->status = fcomp.status;
  out: ;
  return (0);
}
}
int bfad_iocmd_diag_loopback(struct bfad_s *bfad , void *cmd ) 
{ 
  struct bfa_bsg_diag_loopback_s *iocmd ;
  struct bfad_hal_comp fcomp ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;

  {
  iocmd = (struct bfa_bsg_diag_loopback_s *)cmd;
  init_completion(& fcomp.comp);
  tmp = spinlock_check(& bfad->bfad_lock);
  flags = _raw_spin_lock_irqsave(tmp);
  iocmd->status = bfa_fcdiag_loopback(& bfad->bfa, iocmd->opmode, iocmd->speed, iocmd->lpcnt,
                                      iocmd->pat, & iocmd->result, & bfad_hcb_comp,
                                      (void *)(& fcomp));
  spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  __bfa_trc(bfad->trcmod, __trc_fileno___1, 1677, (unsigned long long )iocmd->status);
  if ((unsigned int )iocmd->status != 0U) {
    goto out;
  } else {

  }
  wait_for_completion(& fcomp.comp);
  iocmd->status = fcomp.status;
  out: ;
  return (0);
}
}
int bfad_iocmd_diag_fwping(struct bfad_s *bfad , void *cmd ) 
{ 
  struct bfa_bsg_diag_fwping_s *iocmd ;
  struct bfad_hal_comp fcomp ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;

  {
  iocmd = (struct bfa_bsg_diag_fwping_s *)cmd;
  init_completion(& fcomp.comp);
  tmp = spinlock_check(& bfad->bfad_lock);
  flags = _raw_spin_lock_irqsave(tmp);
  iocmd->status = bfa_diag_fwping(& bfad->bfa.modules.diag_mod, iocmd->cnt, iocmd->pattern,
                                  & iocmd->result, & bfad_hcb_comp, (void *)(& fcomp));
  spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  __bfa_trc(bfad->trcmod, __trc_fileno___1, 1700, (unsigned long long )iocmd->status);
  if ((unsigned int )iocmd->status != 0U) {
    goto out;
  } else {

  }
  __bfa_trc(bfad->trcmod, __trc_fileno___1, 1703, 489329ULL);
  wait_for_completion(& fcomp.comp);
  iocmd->status = fcomp.status;
  out: ;
  return (0);
}
}
int bfad_iocmd_diag_queuetest(struct bfad_s *bfad , void *cmd ) 
{ 
  struct bfa_bsg_diag_qtest_s *iocmd ;
  struct bfad_hal_comp fcomp ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;

  {
  iocmd = (struct bfa_bsg_diag_qtest_s *)cmd;
  init_completion(& fcomp.comp);
  tmp = spinlock_check(& bfad->bfad_lock);
  flags = _raw_spin_lock_irqsave(tmp);
  iocmd->status = bfa_fcdiag_queuetest(& bfad->bfa, iocmd->force, iocmd->queue, & iocmd->result,
                                       & bfad_hcb_comp, (void *)(& fcomp));
  spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  if ((unsigned int )iocmd->status != 0U) {
    goto out;
  } else {

  }
  wait_for_completion(& fcomp.comp);
  iocmd->status = fcomp.status;
  out: ;
  return (0);
}
}
int bfad_iocmd_diag_sfp(struct bfad_s *bfad , void *cmd ) 
{ 
  struct bfa_bsg_sfp_show_s *iocmd ;
  struct bfad_hal_comp fcomp ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;

  {
  iocmd = (struct bfa_bsg_sfp_show_s *)cmd;
  init_completion(& fcomp.comp);
  tmp = spinlock_check(& bfad->bfad_lock);
  flags = _raw_spin_lock_irqsave(tmp);
  iocmd->status = bfa_sfp_show(& bfad->bfa.modules.sfp, & iocmd->sfp, & bfad_hcb_comp,
                               (void *)(& fcomp));
  spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  __bfa_trc(bfad->trcmod, __trc_fileno___1, 1744, (unsigned long long )iocmd->status);
  if ((unsigned int )iocmd->status != 0U) {
    goto out;
  } else {

  }
  wait_for_completion(& fcomp.comp);
  iocmd->status = fcomp.status;
  __bfa_trc(bfad->trcmod, __trc_fileno___1, 1749, (unsigned long long )iocmd->status);
  out: ;
  return (0);
}
}
int bfad_iocmd_diag_led(struct bfad_s *bfad , void *cmd ) 
{ 
  struct bfa_bsg_diag_led_s *iocmd ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;

  {
  iocmd = (struct bfa_bsg_diag_led_s *)cmd;
  tmp = spinlock_check(& bfad->bfad_lock);
  flags = _raw_spin_lock_irqsave(tmp);
  iocmd->status = bfa_diag_ledtest(& bfad->bfa.modules.diag_mod, & iocmd->ledtest);
  spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  return (0);
}
}
int bfad_iocmd_diag_beacon_lport(struct bfad_s *bfad , void *cmd ) 
{ 
  struct bfa_bsg_diag_beacon_s *iocmd ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;

  {
  iocmd = (struct bfa_bsg_diag_beacon_s *)cmd;
  tmp = spinlock_check(& bfad->bfad_lock);
  flags = _raw_spin_lock_irqsave(tmp);
  iocmd->status = bfa_diag_beacon_port(& bfad->bfa.modules.diag_mod, iocmd->beacon,
                                       iocmd->link_e2e_beacon, iocmd->second);
  spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  return (0);
}
}
int bfad_iocmd_diag_lb_stat(struct bfad_s *bfad , void *cmd ) 
{ 
  struct bfa_bsg_diag_lb_stat_s *iocmd ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;

  {
  iocmd = (struct bfa_bsg_diag_lb_stat_s *)cmd;
  tmp = spinlock_check(& bfad->bfad_lock);
  flags = _raw_spin_lock_irqsave(tmp);
  iocmd->status = bfa_fcdiag_lb_is_running(& bfad->bfa);
  spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  __bfa_trc(bfad->trcmod, __trc_fileno___1, 1792, (unsigned long long )iocmd->status);
  return (0);
}
}
int bfad_iocmd_diag_dport_enable(struct bfad_s *bfad , void *pcmd ) 
{ 
  struct bfa_bsg_dport_enable_s *iocmd ;
  unsigned long flags ;
  struct bfad_hal_comp fcomp ;
  raw_spinlock_t *tmp ;

  {
  iocmd = (struct bfa_bsg_dport_enable_s *)pcmd;
  init_completion(& fcomp.comp);
  tmp = spinlock_check(& bfad->bfad_lock);
  flags = _raw_spin_lock_irqsave(tmp);
  iocmd->status = bfa_dport_enable(& bfad->bfa, (u32 )iocmd->lpcnt, (u32 )iocmd->pat,
                                   & bfad_hcb_comp, (void *)(& fcomp));
  spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  if ((unsigned int )iocmd->status != 0U) {
    __bfa_trc(bfad->trcmod, __trc_fileno___1, 1811, (unsigned long long )iocmd->status);
  } else {
    wait_for_completion(& fcomp.comp);
    iocmd->status = fcomp.status;
  }
  return (0);
}
}
int bfad_iocmd_diag_dport_disable(struct bfad_s *bfad , void *pcmd ) 
{ 
  struct bfa_bsg_gen_s *iocmd ;
  unsigned long flags ;
  struct bfad_hal_comp fcomp ;
  raw_spinlock_t *tmp ;

  {
  iocmd = (struct bfa_bsg_gen_s *)pcmd;
  init_completion(& fcomp.comp);
  tmp = spinlock_check(& bfad->bfad_lock);
  flags = _raw_spin_lock_irqsave(tmp);
  iocmd->status = bfa_dport_disable(& bfad->bfa, & bfad_hcb_comp, (void *)(& fcomp));
  spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  if ((unsigned int )iocmd->status != 0U) {
    __bfa_trc(bfad->trcmod, __trc_fileno___1, 1831, (unsigned long long )iocmd->status);
  } else {
    wait_for_completion(& fcomp.comp);
    iocmd->status = fcomp.status;
  }
  return (0);
}
}
int bfad_iocmd_diag_dport_start(struct bfad_s *bfad , void *pcmd ) 
{ 
  struct bfa_bsg_dport_enable_s *iocmd ;
  unsigned long flags ;
  struct bfad_hal_comp fcomp ;
  raw_spinlock_t *tmp ;

  {
  iocmd = (struct bfa_bsg_dport_enable_s *)pcmd;
  init_completion(& fcomp.comp);
  tmp = spinlock_check(& bfad->bfad_lock);
  flags = _raw_spin_lock_irqsave(tmp);
  iocmd->status = bfa_dport_start(& bfad->bfa, (u32 )iocmd->lpcnt, (u32 )iocmd->pat,
                                  & bfad_hcb_comp, (void *)(& fcomp));
  spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  if ((unsigned int )iocmd->status != 0U) {
    __bfa_trc(bfad->trcmod, __trc_fileno___1, 1855, (unsigned long long )iocmd->status);
  } else {
    wait_for_completion(& fcomp.comp);
    iocmd->status = fcomp.status;
  }
  return (0);
}
}
int bfad_iocmd_diag_dport_show(struct bfad_s *bfad , void *pcmd ) 
{ 
  struct bfa_bsg_diag_dport_show_s *iocmd ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;

  {
  iocmd = (struct bfa_bsg_diag_dport_show_s *)pcmd;
  tmp = spinlock_check(& bfad->bfad_lock);
  flags = _raw_spin_lock_irqsave(tmp);
  iocmd->status = bfa_dport_show(& bfad->bfa, & iocmd->result);
  spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  return (0);
}
}
int bfad_iocmd_phy_get_attr(struct bfad_s *bfad , void *cmd ) 
{ 
  struct bfa_bsg_phy_attr_s *iocmd ;
  struct bfad_hal_comp fcomp ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;

  {
  iocmd = (struct bfa_bsg_phy_attr_s *)cmd;
  init_completion(& fcomp.comp);
  tmp = spinlock_check(& bfad->bfad_lock);
  flags = _raw_spin_lock_irqsave(tmp);
  iocmd->status = bfa_phy_get_attr(& bfad->bfa.modules.phy, (int )((u8 )iocmd->instance),
                                   & iocmd->attr, & bfad_hcb_comp, (void *)(& fcomp));
  spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  if ((unsigned int )iocmd->status != 0U) {
    goto out;
  } else {

  }
  wait_for_completion(& fcomp.comp);
  iocmd->status = fcomp.status;
  out: ;
  return (0);
}
}
int bfad_iocmd_phy_get_stats(struct bfad_s *bfad , void *cmd ) 
{ 
  struct bfa_bsg_phy_stats_s *iocmd ;
  struct bfad_hal_comp fcomp ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;

  {
  iocmd = (struct bfa_bsg_phy_stats_s *)cmd;
  init_completion(& fcomp.comp);
  tmp = spinlock_check(& bfad->bfad_lock);
  flags = _raw_spin_lock_irqsave(tmp);
  iocmd->status = bfa_phy_get_stats(& bfad->bfa.modules.phy, (int )((u8 )iocmd->instance),
                                    & iocmd->stats, & bfad_hcb_comp, (void *)(& fcomp));
  spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  if ((unsigned int )iocmd->status != 0U) {
    goto out;
  } else {

  }
  wait_for_completion(& fcomp.comp);
  iocmd->status = fcomp.status;
  out: ;
  return (0);
}
}
int bfad_iocmd_phy_read(struct bfad_s *bfad , void *cmd , unsigned int payload_len ) 
{ 
  struct bfa_bsg_phy_s *iocmd ;
  struct bfad_hal_comp fcomp ;
  void *iocmd_bufptr ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;

  {
  iocmd = (struct bfa_bsg_phy_s *)cmd;
  if ((unsigned long long )payload_len != iocmd->bufsz + 24ULL) {
    iocmd->status = 70;
    return (0);
  } else {

  }
  iocmd_bufptr = (void *)iocmd + 24U;
  init_completion(& fcomp.comp);
  tmp = spinlock_check(& bfad->bfad_lock);
  flags = _raw_spin_lock_irqsave(tmp);
  iocmd->status = bfa_phy_read(& bfad->bfa.modules.phy, (int )((u8 )iocmd->instance),
                               iocmd_bufptr, (u32 )iocmd->bufsz, 0U, & bfad_hcb_comp,
                               (void *)(& fcomp));
  spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  if ((unsigned int )iocmd->status != 0U) {
    goto out;
  } else {

  }
  wait_for_completion(& fcomp.comp);
  iocmd->status = fcomp.status;
  if ((unsigned int )iocmd->status != 0U) {

  } else {

  }
  out: ;
  return (0);
}
}
int bfad_iocmd_vhba_query(struct bfad_s *bfad , void *cmd ) 
{ 
  struct bfa_bsg_vhba_attr_s *iocmd ;
  struct bfa_vhba_attr_s *attr ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;

  {
  iocmd = (struct bfa_bsg_vhba_attr_s *)cmd;
  attr = & iocmd->attr;
  tmp = spinlock_check(& bfad->bfad_lock);
  flags = _raw_spin_lock_irqsave(tmp);
  attr->pwwn = (bfad->bfa.ioc.attr)->pwwn;
  attr->nwwn = (bfad->bfa.ioc.attr)->nwwn;
  attr->plog_enabled = (enum bfa_boolean )(bfad->bfa.plog)->plog_enabled;
  attr->io_profile = bfad->bfa.modules.fcp_mod.fcpim.io_profile;
  attr->path_tov = bfa_fcpim_path_tov_get(& bfad->bfa);
  iocmd->status = 0;
  spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  return (0);
}
}
int bfad_iocmd_phy_update(struct bfad_s *bfad , void *cmd , unsigned int payload_len ) 
{ 
  struct bfa_bsg_phy_s *iocmd ;
  void *iocmd_bufptr ;
  struct bfad_hal_comp fcomp ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;

  {
  iocmd = (struct bfa_bsg_phy_s *)cmd;
  if ((unsigned long long )payload_len != iocmd->bufsz + 24ULL) {
    iocmd->status = 70;
    return (0);
  } else {

  }
  iocmd_bufptr = (void *)iocmd + 24U;
  init_completion(& fcomp.comp);
  tmp = spinlock_check(& bfad->bfad_lock);
  flags = _raw_spin_lock_irqsave(tmp);
  iocmd->status = bfa_phy_update(& bfad->bfa.modules.phy, (int )((u8 )iocmd->instance),
                                 iocmd_bufptr, (u32 )iocmd->bufsz, 0U, & bfad_hcb_comp,
                                 (void *)(& fcomp));
  spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  if ((unsigned int )iocmd->status != 0U) {
    goto out;
  } else {

  }
  wait_for_completion(& fcomp.comp);
  iocmd->status = fcomp.status;
  out: ;
  return (0);
}
}
int bfad_iocmd_porglog_get(struct bfad_s *bfad , void *cmd ) 
{ 
  struct bfa_bsg_debug_s *iocmd ;
  void *iocmd_bufptr ;

  {
  iocmd = (struct bfa_bsg_debug_s *)cmd;
  if (iocmd->bufsz <= 12311U) {
    __bfa_trc(bfad->trcmod, __trc_fileno___1, 2009, 12312ULL);
    iocmd->status = 2;
    goto out;
  } else {

  }
  iocmd->status = 0;
  iocmd_bufptr = (void *)iocmd + 32U;
  memcpy(iocmd_bufptr, (void const   *)(& bfad->plog_buf), 12312UL);
  out: ;
  return (0);
}
}
int bfad_iocmd_debug_fw_core(struct bfad_s *bfad , void *cmd , unsigned int payload_len ) 
{ 
  struct bfa_bsg_debug_s *iocmd ;
  void *iocmd_bufptr ;
  unsigned long flags ;
  u32 offset ;
  raw_spinlock_t *tmp ;

  {
  iocmd = (struct bfa_bsg_debug_s *)cmd;
  if (payload_len != 16416U) {
    iocmd->status = 70;
    return (0);
  } else {

  }
  if ((iocmd->bufsz <= 16383U || (int )iocmd->bufsz & 1) || (iocmd->offset & 3ULL) != 0ULL) {
    __bfa_trc(bfad->trcmod, __trc_fileno___1, 2040, 16384ULL);
    iocmd->status = 2;
    goto out;
  } else {

  }
  iocmd_bufptr = (void *)iocmd + 32U;
  tmp = spinlock_check(& bfad->bfad_lock);
  flags = _raw_spin_lock_irqsave(tmp);
  offset = (u32 )iocmd->offset;
  iocmd->status = bfa_ioc_debug_fwcore(& bfad->bfa.ioc, iocmd_bufptr, & offset, (int *)(& iocmd->bufsz));
  iocmd->offset = (u64 )offset;
  spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  out: ;
  return (0);
}
}
int bfad_iocmd_debug_ctl(struct bfad_s *bfad , void *cmd , unsigned int v_cmd ) 
{ 
  struct bfa_bsg_gen_s *iocmd ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;
  u16 tmp___0 ;

  {
  iocmd = (struct bfa_bsg_gen_s *)cmd;
  if (v_cmd == 88U) {
    tmp = spinlock_check(& bfad->bfad_lock);
    flags = _raw_spin_lock_irqsave(tmp);
    bfad->bfa.ioc.dbg_fwsave_once = 1;
    spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  } else
  if (v_cmd == 89U) {
    tmp___0 = 0U;
    bfad->plog_buf.tail = tmp___0;
    bfad->plog_buf.head = tmp___0;
  } else
  if (v_cmd == 90U) {
    bfa_trc_init(bfad->trcmod);
  } else
  if (v_cmd == 91U) {
    bfa_trc_stop(bfad->trcmod);
  } else {

  }
  iocmd->status = 0;
  return (0);
}
}
int bfad_iocmd_porglog_ctl(struct bfad_s *bfad , void *cmd ) 
{ 
  struct bfa_bsg_portlogctl_s *iocmd ;

  {
  iocmd = (struct bfa_bsg_portlogctl_s *)cmd;
  if ((unsigned int )iocmd->ctl == 1U) {
    bfad->plog_buf.plog_enabled = 1U;
  } else {
    bfad->plog_buf.plog_enabled = 0U;
  }
  iocmd->status = 0;
  return (0);
}
}
int bfad_iocmd_fcpim_cfg_profile(struct bfad_s *bfad , void *cmd , unsigned int v_cmd ) 
{ 
  struct bfa_bsg_fcpim_profile_s *iocmd ;
  struct timeval tv ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;

  {
  iocmd = (struct bfa_bsg_fcpim_profile_s *)cmd;
  do_gettimeofday(& tv);
  tmp = spinlock_check(& bfad->bfad_lock);
  flags = _raw_spin_lock_irqsave(tmp);
  if (v_cmd == 93U) {
    iocmd->status = bfa_fcpim_profile_on(& bfad->bfa, (u32 )tv.tv_sec);
  } else
  if (v_cmd == 94U) {
    iocmd->status = bfa_fcpim_profile_off(& bfad->bfa);
  } else {

  }
  spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  return (0);
}
}
static int bfad_iocmd_itnim_get_ioprofile(struct bfad_s *bfad , void *cmd ) 
{ 
  struct bfa_bsg_itnim_ioprofile_s *iocmd ;
  struct bfa_fcs_lport_s *fcs_port ;
  struct bfa_fcs_itnim_s *itnim ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;
  struct bfa_itnim_s *tmp___0 ;

  {
  iocmd = (struct bfa_bsg_itnim_ioprofile_s *)cmd;
  tmp = spinlock_check(& bfad->bfad_lock);
  flags = _raw_spin_lock_irqsave(tmp);
  fcs_port = bfa_fcs_lookup_port(& bfad->bfa_fcs, (int )iocmd->vf_id, iocmd->lpwwn);
  if ((unsigned long )fcs_port == (unsigned long )((struct bfa_fcs_lport_s *)0)) {
    iocmd->status = 18;
  } else {
    itnim = bfa_fcs_itnim_lookup(fcs_port, iocmd->rpwwn);
    if ((unsigned long )itnim == (unsigned long )((struct bfa_fcs_itnim_s *)0)) {
      iocmd->status = 19;
    } else {
      tmp___0 = bfa_fcs_itnim_get_halitn(itnim);
      iocmd->status = bfa_itnim_get_ioprofile(tmp___0, & iocmd->ioprofile);
    }
  }
  spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  return (0);
}
}
int bfad_iocmd_fcport_get_stats(struct bfad_s *bfad , void *cmd ) 
{ 
  struct bfa_bsg_fcport_stats_s *iocmd ;
  struct bfad_hal_comp fcomp ;
  unsigned long flags ;
  struct bfa_cb_pending_q_s cb_qe ;
  raw_spinlock_t *tmp ;

  {
  iocmd = (struct bfa_bsg_fcport_stats_s *)cmd;
  init_completion(& fcomp.comp);
  cb_qe.hcb_qe.qe.next = (struct list_head *)0;
  cb_qe.hcb_qe.qe.prev = (struct list_head *)0;
  cb_qe.hcb_qe.cbfn = (void (*)(void * , enum bfa_boolean  ))(& bfad_hcb_comp);
  cb_qe.hcb_qe.cbarg = (void *)(& fcomp);
  cb_qe.hcb_qe.pre_rmv = 1;
  cb_qe.data = (void *)(& iocmd->stats);
  tmp = spinlock_check(& bfad->bfad_lock);
  flags = _raw_spin_lock_irqsave(tmp);
  iocmd->status = bfa_fcport_get_stats(& bfad->bfa, & cb_qe);
  spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  if ((unsigned int )iocmd->status != 0U) {
    __bfa_trc(bfad->trcmod, __trc_fileno___1, 2153, (unsigned long long )iocmd->status);
    goto out;
  } else {

  }
  wait_for_completion(& fcomp.comp);
  iocmd->status = fcomp.status;
  out: ;
  return (0);
}
}
int bfad_iocmd_fcport_reset_stats(struct bfad_s *bfad , void *cmd ) 
{ 
  struct bfa_bsg_gen_s *iocmd ;
  struct bfad_hal_comp fcomp ;
  unsigned long flags ;
  struct bfa_cb_pending_q_s cb_qe ;
  raw_spinlock_t *tmp ;

  {
  iocmd = (struct bfa_bsg_gen_s *)cmd;
  init_completion(& fcomp.comp);
  cb_qe.hcb_qe.qe.next = (struct list_head *)0;
  cb_qe.hcb_qe.qe.prev = (struct list_head *)0;
  cb_qe.hcb_qe.cbfn = (void (*)(void * , enum bfa_boolean  ))(& bfad_hcb_comp);
  cb_qe.hcb_qe.cbarg = (void *)(& fcomp);
  cb_qe.hcb_qe.pre_rmv = 1;
  cb_qe.data = (void *)0;
  tmp = spinlock_check(& bfad->bfad_lock);
  flags = _raw_spin_lock_irqsave(tmp);
  iocmd->status = bfa_fcport_clear_stats(& bfad->bfa, & cb_qe);
  spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  if ((unsigned int )iocmd->status != 0U) {
    __bfa_trc(bfad->trcmod, __trc_fileno___1, 2177, (unsigned long long )iocmd->status);
    goto out;
  } else {

  }
  wait_for_completion(& fcomp.comp);
  iocmd->status = fcomp.status;
  out: ;
  return (0);
}
}
int bfad_iocmd_boot_cfg(struct bfad_s *bfad , void *cmd ) 
{ 
  struct bfa_bsg_boot_s *iocmd ;
  struct bfad_hal_comp fcomp ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;

  {
  iocmd = (struct bfa_bsg_boot_s *)cmd;
  init_completion(& fcomp.comp);
  tmp = spinlock_check(& bfad->bfad_lock);
  flags = _raw_spin_lock_irqsave(tmp);
  iocmd->status = bfa_flash_update_part(& bfad->bfa.modules.flash, 5, (int )bfad->bfa.ioc.port_id,
                                        (void *)(& iocmd->cfg), 144U, 0U, & bfad_hcb_comp,
                                        (void *)(& fcomp));
  spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  if ((unsigned int )iocmd->status != 0U) {
    goto out;
  } else {

  }
  wait_for_completion(& fcomp.comp);
  iocmd->status = fcomp.status;
  out: ;
  return (0);
}
}
int bfad_iocmd_boot_query(struct bfad_s *bfad , void *cmd ) 
{ 
  struct bfa_bsg_boot_s *iocmd ;
  struct bfad_hal_comp fcomp ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;

  {
  iocmd = (struct bfa_bsg_boot_s *)cmd;
  init_completion(& fcomp.comp);
  tmp = spinlock_check(& bfad->bfad_lock);
  flags = _raw_spin_lock_irqsave(tmp);
  iocmd->status = bfa_flash_read_part(& bfad->bfa.modules.flash, 5, (int )bfad->bfa.ioc.port_id,
                                      (void *)(& iocmd->cfg), 144U, 0U, & bfad_hcb_comp,
                                      (void *)(& fcomp));
  spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  if ((unsigned int )iocmd->status != 0U) {
    goto out;
  } else {

  }
  wait_for_completion(& fcomp.comp);
  iocmd->status = fcomp.status;
  out: ;
  return (0);
}
}
int bfad_iocmd_preboot_query(struct bfad_s *bfad , void *cmd ) 
{ 
  struct bfa_bsg_preboot_s *iocmd ;
  struct bfi_iocfc_cfgrsp_s *cfgrsp ;
  struct bfa_boot_pbc_s *pbcfg ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;

  {
  iocmd = (struct bfa_bsg_preboot_s *)cmd;
  cfgrsp = bfad->bfa.iocfc.cfgrsp;
  pbcfg = & iocmd->cfg;
  tmp = spinlock_check(& bfad->bfad_lock);
  flags = _raw_spin_lock_irqsave(tmp);
  pbcfg->enable = cfgrsp->pbc_cfg.boot_enabled;
  pbcfg->nbluns = (u32 )cfgrsp->pbc_cfg.nbluns;
  pbcfg->speed = cfgrsp->pbc_cfg.port_speed;
  memcpy((void *)(& pbcfg->pblun), (void const   *)(& cfgrsp->pbc_cfg.blun), 128UL);
  iocmd->status = 0;
  spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  return (0);
}
}
int bfad_iocmd_ethboot_cfg(struct bfad_s *bfad , void *cmd ) 
{ 
  struct bfa_bsg_ethboot_s *iocmd ;
  struct bfad_hal_comp fcomp ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;

  {
  iocmd = (struct bfa_bsg_ethboot_s *)cmd;
  init_completion(& fcomp.comp);
  tmp = spinlock_check(& bfad->bfad_lock);
  flags = _raw_spin_lock_irqsave(tmp);
  iocmd->status = bfa_flash_update_part(& bfad->bfa.modules.flash, 13, (int )bfad->bfa.ioc.port_id,
                                        (void *)(& iocmd->cfg), 8U, 0U, & bfad_hcb_comp,
                                        (void *)(& fcomp));
  spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  if ((unsigned int )iocmd->status != 0U) {
    goto out;
  } else {

  }
  wait_for_completion(& fcomp.comp);
  iocmd->status = fcomp.status;
  out: ;
  return (0);
}
}
int bfad_iocmd_ethboot_query(struct bfad_s *bfad , void *cmd ) 
{ 
  struct bfa_bsg_ethboot_s *iocmd ;
  struct bfad_hal_comp fcomp ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;

  {
  iocmd = (struct bfa_bsg_ethboot_s *)cmd;
  init_completion(& fcomp.comp);
  tmp = spinlock_check(& bfad->bfad_lock);
  flags = _raw_spin_lock_irqsave(tmp);
  iocmd->status = bfa_flash_read_part(& bfad->bfa.modules.flash, 13, (int )bfad->bfa.ioc.port_id,
                                      (void *)(& iocmd->cfg), 8U, 0U, & bfad_hcb_comp,
                                      (void *)(& fcomp));
  spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  if ((unsigned int )iocmd->status != 0U) {
    goto out;
  } else {

  }
  wait_for_completion(& fcomp.comp);
  iocmd->status = fcomp.status;
  out: ;
  return (0);
}
}
int bfad_iocmd_cfg_trunk(struct bfad_s *bfad , void *cmd , unsigned int v_cmd ) 
{ 
  struct bfa_bsg_gen_s *iocmd ;
  struct bfa_fcport_s *fcport ;
  struct bfa_fcport_trunk_s *trunk ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;
  enum bfa_boolean tmp___0 ;
  enum bfa_boolean tmp___1 ;

  {
  iocmd = (struct bfa_bsg_gen_s *)cmd;
  fcport = & bfad->bfa.modules.fcport;
  trunk = & fcport->trunk;
  tmp = spinlock_check(& bfad->bfad_lock);
  flags = _raw_spin_lock_irqsave(tmp);
  tmp___0 = bfa_fcport_is_dport(& bfad->bfa);
  if ((unsigned int )tmp___0 != 0U) {
    spin_unlock_irqrestore(& bfad->bfad_lock, flags);
    return (245);
  } else {

  }
  if ((unsigned int )fcport->cfg.topology == 2U || (unsigned int )fcport->topology == 2U) {
    iocmd->status = 230;
  } else {
    if (v_cmd == 103U) {
      trunk->attr.state = 2;
      bfa_fcport_disable(& bfad->bfa);
      fcport->cfg.trunked = 1U;
    } else
    if (v_cmd == 104U) {
      trunk->attr.state = 0;
      bfa_fcport_disable(& bfad->bfa);
      fcport->cfg.trunked = 0U;
    } else {

    }
    tmp___1 = bfa_fcport_is_disabled(& bfad->bfa);
    if ((unsigned int )tmp___1 == 0U) {
      bfa_fcport_enable(& bfad->bfa);
    } else {

    }
    iocmd->status = 0;
  }
  spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  return (0);
}
}
int bfad_iocmd_trunk_get_attr(struct bfad_s *bfad , void *cmd ) 
{ 
  struct bfa_bsg_trunk_attr_s *iocmd ;
  struct bfa_fcport_s *fcport ;
  struct bfa_fcport_trunk_s *trunk ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;

  {
  iocmd = (struct bfa_bsg_trunk_attr_s *)cmd;
  fcport = & bfad->bfa.modules.fcport;
  trunk = & fcport->trunk;
  tmp = spinlock_check(& bfad->bfad_lock);
  flags = _raw_spin_lock_irqsave(tmp);
  if ((unsigned int )fcport->cfg.topology == 2U || (unsigned int )fcport->topology == 2U) {
    iocmd->status = 230;
  } else {
    memcpy((void *)(& iocmd->attr), (void const   *)(& trunk->attr), 64UL);
    iocmd->attr.port_id = bfa_lps_get_base_pid(& bfad->bfa);
    iocmd->status = 0;
  }
  spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  return (0);
}
}
int bfad_iocmd_qos(struct bfad_s *bfad , void *cmd , unsigned int v_cmd ) 
{ 
  struct bfa_bsg_gen_s *iocmd ;
  struct bfa_fcport_s *fcport ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;
  enum bfa_ioc_type_e tmp___0 ;

  {
  iocmd = (struct bfa_bsg_gen_s *)cmd;
  fcport = & bfad->bfa.modules.fcport;
  tmp = spinlock_check(& bfad->bfad_lock);
  flags = _raw_spin_lock_irqsave(tmp);
  tmp___0 = bfa_ioc_get_type(& bfad->bfa.ioc);
  if ((unsigned int )tmp___0 == 1U) {
    if ((unsigned int )fcport->cfg.topology == 2U && (unsigned int )fcport->topology == 2U) {
      iocmd->status = 230;
    } else
    if (v_cmd == 106U) {
      fcport->cfg.qos_enabled = 1U;
    } else
    if (v_cmd == 107U) {
      fcport->cfg.qos_enabled = 0U;
      fcport->cfg.qos_bw.high = 60U;
      fcport->cfg.qos_bw.med = 30U;
      fcport->cfg.qos_bw.low = 10U;
    } else {

    }
  } else {

  }
  spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  return (0);
}
}
int bfad_iocmd_qos_get_attr(struct bfad_s *bfad , void *cmd ) 
{ 
  struct bfa_bsg_qos_attr_s *iocmd ;
  struct bfa_fcport_s *fcport ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;
  __u32 tmp___0 ;

  {
  iocmd = (struct bfa_bsg_qos_attr_s *)cmd;
  fcport = & bfad->bfa.modules.fcport;
  tmp = spinlock_check(& bfad->bfad_lock);
  flags = _raw_spin_lock_irqsave(tmp);
  if ((unsigned int )fcport->cfg.topology == 2U && (unsigned int )fcport->topology == 2U) {
    iocmd->status = 230;
  } else {
    iocmd->attr.state = fcport->qos_attr.state;
    tmp___0 = __fswab32(fcport->qos_attr.total_bb_cr);
    iocmd->attr.total_bb_cr = tmp___0;
    iocmd->attr.qos_bw.high = fcport->cfg.qos_bw.high;
    iocmd->attr.qos_bw.med = fcport->cfg.qos_bw.med;
    iocmd->attr.qos_bw.low = fcport->cfg.qos_bw.low;
    iocmd->attr.qos_bw_op = fcport->qos_attr.qos_bw_op;
    iocmd->status = 0;
  }
  spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  return (0);
}
}
int bfad_iocmd_qos_get_vc_attr(struct bfad_s *bfad , void *cmd ) 
{ 
  struct bfa_bsg_qos_vc_attr_s *iocmd ;
  struct bfa_fcport_s *fcport ;
  struct bfa_qos_vc_attr_s *bfa_vc_attr ;
  unsigned long flags ;
  u32 i ;
  raw_spinlock_t *tmp ;
  __u16 tmp___0 ;
  __u16 tmp___1 ;
  __u32 tmp___2 ;

  {
  iocmd = (struct bfa_bsg_qos_vc_attr_s *)cmd;
  fcport = & bfad->bfa.modules.fcport;
  bfa_vc_attr = & fcport->qos_vc_attr;
  i = 0U;
  tmp = spinlock_check(& bfad->bfad_lock);
  flags = _raw_spin_lock_irqsave(tmp);
  tmp___0 = __fswab16((int )bfa_vc_attr->total_vc_count);
  iocmd->attr.total_vc_count = tmp___0;
  tmp___1 = __fswab16((int )bfa_vc_attr->shared_credit);
  iocmd->attr.shared_credit = tmp___1;
  tmp___2 = __fswab32(bfa_vc_attr->elp_opmode_flags);
  iocmd->attr.elp_opmode_flags = tmp___2;
  goto ldv_50015;
  ldv_50014: 
  iocmd->attr.vc_info[i].vc_credit = bfa_vc_attr->vc_info[i].vc_credit;
  iocmd->attr.vc_info[i].borrow_credit = bfa_vc_attr->vc_info[i].borrow_credit;
  iocmd->attr.vc_info[i].priority = bfa_vc_attr->vc_info[i].priority;
  i = i + 1U;
  ldv_50015: ;
  if ((u32 )iocmd->attr.total_vc_count > i) {
    goto ldv_50014;
  } else {

  }
  spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  iocmd->status = 0;
  return (0);
}
}
int bfad_iocmd_qos_get_stats(struct bfad_s *bfad , void *cmd ) 
{ 
  struct bfa_bsg_fcport_stats_s *iocmd ;
  struct bfad_hal_comp fcomp ;
  unsigned long flags ;
  struct bfa_cb_pending_q_s cb_qe ;
  struct bfa_fcport_s *fcport ;
  raw_spinlock_t *tmp ;
  int __ret_warn_on ;
  long tmp___0 ;

  {
  iocmd = (struct bfa_bsg_fcport_stats_s *)cmd;
  fcport = & bfad->bfa.modules.fcport;
  init_completion(& fcomp.comp);
  cb_qe.hcb_qe.qe.next = (struct list_head *)0;
  cb_qe.hcb_qe.qe.prev = (struct list_head *)0;
  cb_qe.hcb_qe.cbfn = (void (*)(void * , enum bfa_boolean  ))(& bfad_hcb_comp);
  cb_qe.hcb_qe.cbarg = (void *)(& fcomp);
  cb_qe.hcb_qe.pre_rmv = 1;
  cb_qe.data = (void *)(& iocmd->stats);
  tmp = spinlock_check(& bfad->bfad_lock);
  flags = _raw_spin_lock_irqsave(tmp);
  __ret_warn_on = (unsigned int )bfad->bfa.ioc.fcmode == 0U;
  tmp___0 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp___0 != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfad_bsg.c",
                       2459);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if ((unsigned int )fcport->cfg.topology == 2U && (unsigned int )fcport->topology == 2U) {
    iocmd->status = 230;
  } else {
    iocmd->status = bfa_fcport_get_stats(& bfad->bfa, & cb_qe);
  }
  spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  if ((unsigned int )iocmd->status != 0U) {
    __bfa_trc(bfad->trcmod, __trc_fileno___1, 2467, (unsigned long long )iocmd->status);
    goto out;
  } else {

  }
  wait_for_completion(& fcomp.comp);
  iocmd->status = fcomp.status;
  out: ;
  return (0);
}
}
int bfad_iocmd_qos_reset_stats(struct bfad_s *bfad , void *cmd ) 
{ 
  struct bfa_bsg_gen_s *iocmd ;
  struct bfad_hal_comp fcomp ;
  unsigned long flags ;
  struct bfa_cb_pending_q_s cb_qe ;
  struct bfa_fcport_s *fcport ;
  raw_spinlock_t *tmp ;
  int __ret_warn_on ;
  long tmp___0 ;

  {
  iocmd = (struct bfa_bsg_gen_s *)cmd;
  fcport = & bfad->bfa.modules.fcport;
  init_completion(& fcomp.comp);
  cb_qe.hcb_qe.qe.next = (struct list_head *)0;
  cb_qe.hcb_qe.qe.prev = (struct list_head *)0;
  cb_qe.hcb_qe.cbfn = (void (*)(void * , enum bfa_boolean  ))(& bfad_hcb_comp);
  cb_qe.hcb_qe.cbarg = (void *)(& fcomp);
  cb_qe.hcb_qe.pre_rmv = 1;
  cb_qe.data = (void *)0;
  tmp = spinlock_check(& bfad->bfad_lock);
  flags = _raw_spin_lock_irqsave(tmp);
  __ret_warn_on = (unsigned int )bfad->bfa.ioc.fcmode == 0U;
  tmp___0 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp___0 != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfad_bsg.c",
                       2490);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if ((unsigned int )fcport->cfg.topology == 2U && (unsigned int )fcport->topology == 2U) {
    iocmd->status = 230;
  } else {
    iocmd->status = bfa_fcport_clear_stats(& bfad->bfa, & cb_qe);
  }
  spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  if ((unsigned int )iocmd->status != 0U) {
    __bfa_trc(bfad->trcmod, __trc_fileno___1, 2498, (unsigned long long )iocmd->status);
    goto out;
  } else {

  }
  wait_for_completion(& fcomp.comp);
  iocmd->status = fcomp.status;
  out: ;
  return (0);
}
}
int bfad_iocmd_vf_get_stats(struct bfad_s *bfad , void *cmd ) 
{ 
  struct bfa_bsg_vf_stats_s *iocmd ;
  struct bfa_fcs_fabric_s *fcs_vf ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;

  {
  iocmd = (struct bfa_bsg_vf_stats_s *)cmd;
  tmp = spinlock_check(& bfad->bfad_lock);
  flags = _raw_spin_lock_irqsave(tmp);
  fcs_vf = bfa_fcs_vf_lookup(& bfad->bfa_fcs, (int )iocmd->vf_id);
  if ((unsigned long )fcs_vf == (unsigned long )((struct bfa_fcs_fabric_s *)0)) {
    spin_unlock_irqrestore(& bfad->bfad_lock, flags);
    iocmd->status = 11;
    goto out;
  } else {

  }
  memcpy((void *)(& iocmd->stats), (void const   *)(& fcs_vf->stats), 48UL);
  spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  iocmd->status = 0;
  out: ;
  return (0);
}
}
int bfad_iocmd_vf_clr_stats(struct bfad_s *bfad , void *cmd ) 
{ 
  struct bfa_bsg_vf_reset_stats_s *iocmd ;
  struct bfa_fcs_fabric_s *fcs_vf ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;

  {
  iocmd = (struct bfa_bsg_vf_reset_stats_s *)cmd;
  tmp = spinlock_check(& bfad->bfad_lock);
  flags = _raw_spin_lock_irqsave(tmp);
  fcs_vf = bfa_fcs_vf_lookup(& bfad->bfa_fcs, (int )iocmd->vf_id);
  if ((unsigned long )fcs_vf == (unsigned long )((struct bfa_fcs_fabric_s *)0)) {
    spin_unlock_irqrestore(& bfad->bfad_lock, flags);
    iocmd->status = 11;
    goto out;
  } else {

  }
  memset((void *)(& fcs_vf->stats), 0, 48UL);
  spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  iocmd->status = 0;
  out: ;
  return (0);
}
}
static void bfad_iocmd_lunmask_reset_lunscan_mode(struct bfad_s *bfad , int lunmask_cfg ) 
{ 
  struct bfad_im_port_s *pport_im ;
  struct bfad_vport_s *vport ;
  struct scsi_device *__sdev ;
  struct bfad_itnim_s *__itnim ;
  u32 scan_flags ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  struct list_head  const  *__mptr___1 ;
  struct scsi_device *__sdev___0 ;
  struct bfad_itnim_s *__itnim___0 ;
  u32 scan_flags___0 ;
  struct list_head  const  *__mptr___2 ;
  struct list_head  const  *__mptr___3 ;
  struct list_head  const  *__mptr___4 ;

  {
  pport_im = bfad->pport.im_port;
  vport = (struct bfad_vport_s *)0;
  __sdev = (struct scsi_device *)0;
  __itnim = (struct bfad_itnim_s *)0;
  scan_flags = 262208U;
  __mptr = (struct list_head  const  *)pport_im->itnim_mapped_list.next;
  __itnim = (struct bfad_itnim_s *)__mptr;
  goto ldv_50083;
  ldv_50082: 
  __sdev = scsi_device_lookup(pport_im->shost, (uint )__itnim->channel, (uint )__itnim->scsi_tgt_id,
                              0ULL);
  if ((unsigned long )__sdev != (unsigned long )((struct scsi_device *)0)) {
    if (lunmask_cfg == 1) {
      __sdev->sdev_bflags = __sdev->sdev_bflags | scan_flags;
    } else {
      __sdev->sdev_bflags = __sdev->sdev_bflags & ~ scan_flags;
    }
    scsi_device_put(__sdev);
  } else {

  }
  __mptr___0 = (struct list_head  const  *)__itnim->list_entry.next;
  __itnim = (struct bfad_itnim_s *)__mptr___0;
  ldv_50083: ;
  if ((unsigned long )(& __itnim->list_entry) != (unsigned long )(& pport_im->itnim_mapped_list)) {
    goto ldv_50082;
  } else {

  }
  __mptr___1 = (struct list_head  const  *)bfad->vport_list.next;
  vport = (struct bfad_vport_s *)__mptr___1 + 0xfffffffffffff888UL;
  goto ldv_50100;
  ldv_50099: 
  __sdev___0 = (struct scsi_device *)0;
  __itnim___0 = (struct bfad_itnim_s *)0;
  scan_flags___0 = 262208U;
  __mptr___2 = (struct list_head  const  *)(vport->drv_port.im_port)->itnim_mapped_list.next;
  __itnim___0 = (struct bfad_itnim_s *)__mptr___2;
  goto ldv_50097;
  ldv_50096: 
  __sdev___0 = scsi_device_lookup((vport->drv_port.im_port)->shost, (uint )__itnim___0->channel,
                                  (uint )__itnim___0->scsi_tgt_id, 0ULL);
  if ((unsigned long )__sdev___0 != (unsigned long )((struct scsi_device *)0)) {
    if (lunmask_cfg == 1) {
      __sdev___0->sdev_bflags = __sdev___0->sdev_bflags | scan_flags___0;
    } else {
      __sdev___0->sdev_bflags = __sdev___0->sdev_bflags & ~ scan_flags___0;
    }
    scsi_device_put(__sdev___0);
  } else {

  }
  __mptr___3 = (struct list_head  const  *)__itnim___0->list_entry.next;
  __itnim___0 = (struct bfad_itnim_s *)__mptr___3;
  ldv_50097: ;
  if ((unsigned long )(& __itnim___0->list_entry) != (unsigned long )(& (vport->drv_port.im_port)->itnim_mapped_list)) {
    goto ldv_50096;
  } else {

  }
  __mptr___4 = (struct list_head  const  *)vport->list_entry.next;
  vport = (struct bfad_vport_s *)__mptr___4 + 0xfffffffffffff888UL;
  ldv_50100: ;
  if ((unsigned long )(& vport->list_entry) != (unsigned long )(& bfad->vport_list)) {
    goto ldv_50099;
  } else {

  }

  return;
}
}
int bfad_iocmd_lunmask(struct bfad_s *bfad , void *pcmd , unsigned int v_cmd ) 
{ 
  struct bfa_bsg_gen_s *iocmd ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;

  {
  iocmd = (struct bfa_bsg_gen_s *)pcmd;
  tmp = spinlock_check(& bfad->bfad_lock);
  flags = _raw_spin_lock_irqsave(tmp);
  if (v_cmd == 114U) {
    iocmd->status = bfa_fcpim_lunmask_update(& bfad->bfa, 1U);
    if ((unsigned int )iocmd->status == 0U) {
      bfad_iocmd_lunmask_reset_lunscan_mode(bfad, 1);
    } else {

    }
  } else
  if (v_cmd == 115U) {
    iocmd->status = bfa_fcpim_lunmask_update(& bfad->bfa, 0U);
    if ((unsigned int )iocmd->status == 0U) {
      bfad_iocmd_lunmask_reset_lunscan_mode(bfad, 0);
    } else {

    }
  } else
  if (v_cmd == 116U) {
    iocmd->status = bfa_fcpim_lunmask_clear(& bfad->bfa);
  } else {

  }
  spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  return (0);
}
}
int bfad_iocmd_fcpim_lunmask_query(struct bfad_s *bfad , void *cmd ) 
{ 
  struct bfa_bsg_fcpim_lunmask_query_s *iocmd ;
  struct bfa_lunmask_cfg_s *lun_mask ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;

  {
  iocmd = (struct bfa_bsg_fcpim_lunmask_query_s *)cmd;
  lun_mask = & iocmd->lun_mask;
  tmp = spinlock_check(& bfad->bfad_lock);
  flags = _raw_spin_lock_irqsave(tmp);
  iocmd->status = bfa_fcpim_lunmask_query(& bfad->bfa, (void *)lun_mask);
  spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  return (0);
}
}
int bfad_iocmd_fcpim_cfg_lunmask(struct bfad_s *bfad , void *cmd , unsigned int v_cmd ) 
{ 
  struct bfa_bsg_fcpim_lunmask_s *iocmd ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;

  {
  iocmd = (struct bfa_bsg_fcpim_lunmask_s *)cmd;
  tmp = spinlock_check(& bfad->bfad_lock);
  flags = _raw_spin_lock_irqsave(tmp);
  if (v_cmd == 118U) {
    iocmd->status = bfa_fcpim_lunmask_add(& bfad->bfa, (int )iocmd->vf_id, & iocmd->pwwn,
                                          iocmd->rpwwn, iocmd->lun);
  } else
  if (v_cmd == 119U) {
    iocmd->status = bfa_fcpim_lunmask_delete(& bfad->bfa, (int )iocmd->vf_id, & iocmd->pwwn,
                                             iocmd->rpwwn, iocmd->lun);
  } else {

  }
  spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  return (0);
}
}
int bfad_iocmd_fcpim_throttle_query(struct bfad_s *bfad , void *cmd ) 
{ 
  struct bfa_bsg_fcpim_throttle_s *iocmd ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;

  {
  iocmd = (struct bfa_bsg_fcpim_throttle_s *)cmd;
  tmp = spinlock_check(& bfad->bfad_lock);
  flags = _raw_spin_lock_irqsave(tmp);
  iocmd->status = bfa_fcpim_throttle_get(& bfad->bfa, (void *)(& iocmd->throttle));
  spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  return (0);
}
}
int bfad_iocmd_fcpim_throttle_set(struct bfad_s *bfad , void *cmd ) 
{ 
  struct bfa_bsg_fcpim_throttle_s *iocmd ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;

  {
  iocmd = (struct bfa_bsg_fcpim_throttle_s *)cmd;
  tmp = spinlock_check(& bfad->bfad_lock);
  flags = _raw_spin_lock_irqsave(tmp);
  iocmd->status = bfa_fcpim_throttle_set(& bfad->bfa, (int )iocmd->throttle.cfg_value);
  spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  return (0);
}
}
int bfad_iocmd_tfru_read(struct bfad_s *bfad , void *cmd ) 
{ 
  struct bfa_bsg_tfru_s *iocmd ;
  struct bfad_hal_comp fcomp ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;

  {
  iocmd = (struct bfa_bsg_tfru_s *)cmd;
  flags = 0UL;
  init_completion(& fcomp.comp);
  tmp = spinlock_check(& bfad->bfad_lock);
  flags = _raw_spin_lock_irqsave(tmp);
  iocmd->status = bfa_tfru_read(& bfad->bfa.modules.fru, (void *)(& iocmd->data),
                                iocmd->len, iocmd->offset, & bfad_hcb_comp, (void *)(& fcomp));
  spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  if ((unsigned int )iocmd->status == 0U) {
    wait_for_completion(& fcomp.comp);
    iocmd->status = fcomp.status;
  } else {

  }
  return (0);
}
}
int bfad_iocmd_tfru_write(struct bfad_s *bfad , void *cmd ) 
{ 
  struct bfa_bsg_tfru_s *iocmd ;
  struct bfad_hal_comp fcomp ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;

  {
  iocmd = (struct bfa_bsg_tfru_s *)cmd;
  flags = 0UL;
  init_completion(& fcomp.comp);
  tmp = spinlock_check(& bfad->bfad_lock);
  flags = _raw_spin_lock_irqsave(tmp);
  iocmd->status = bfa_tfru_write(& bfad->bfa.modules.fru, (void *)(& iocmd->data),
                                 iocmd->len, iocmd->offset, & bfad_hcb_comp, (void *)(& fcomp));
  spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  if ((unsigned int )iocmd->status == 0U) {
    wait_for_completion(& fcomp.comp);
    iocmd->status = fcomp.status;
  } else {

  }
  return (0);
}
}
int bfad_iocmd_fruvpd_read(struct bfad_s *bfad , void *cmd ) 
{ 
  struct bfa_bsg_fruvpd_s *iocmd ;
  struct bfad_hal_comp fcomp ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;

  {
  iocmd = (struct bfa_bsg_fruvpd_s *)cmd;
  flags = 0UL;
  init_completion(& fcomp.comp);
  tmp = spinlock_check(& bfad->bfad_lock);
  flags = _raw_spin_lock_irqsave(tmp);
  iocmd->status = bfa_fruvpd_read(& bfad->bfa.modules.fru, (void *)(& iocmd->data),
                                  iocmd->len, iocmd->offset, & bfad_hcb_comp, (void *)(& fcomp));
  spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  if ((unsigned int )iocmd->status == 0U) {
    wait_for_completion(& fcomp.comp);
    iocmd->status = fcomp.status;
  } else {

  }
  return (0);
}
}
int bfad_iocmd_fruvpd_update(struct bfad_s *bfad , void *cmd ) 
{ 
  struct bfa_bsg_fruvpd_s *iocmd ;
  struct bfad_hal_comp fcomp ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;

  {
  iocmd = (struct bfa_bsg_fruvpd_s *)cmd;
  flags = 0UL;
  init_completion(& fcomp.comp);
  tmp = spinlock_check(& bfad->bfad_lock);
  flags = _raw_spin_lock_irqsave(tmp);
  iocmd->status = bfa_fruvpd_update(& bfad->bfa.modules.fru, (void *)(& iocmd->data),
                                    iocmd->len, iocmd->offset, & bfad_hcb_comp, (void *)(& fcomp),
                                    (int )iocmd->trfr_cmpl);
  spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  if ((unsigned int )iocmd->status == 0U) {
    wait_for_completion(& fcomp.comp);
    iocmd->status = fcomp.status;
  } else {

  }
  return (0);
}
}
int bfad_iocmd_fruvpd_get_max_size(struct bfad_s *bfad , void *cmd ) 
{ 
  struct bfa_bsg_fruvpd_max_size_s *iocmd ;
  unsigned long flags ;
  raw_spinlock_t *tmp ;

  {
  iocmd = (struct bfa_bsg_fruvpd_max_size_s *)cmd;
  flags = 0UL;
  tmp = spinlock_check(& bfad->bfad_lock);
  flags = _raw_spin_lock_irqsave(tmp);
  iocmd->status = bfa_fruvpd_get_max_size(& bfad->bfa.modules.fru, & iocmd->max_size);
  spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  return (0);
}
}
static int bfad_iocmd_handler(struct bfad_s *bfad , unsigned int cmd , void *iocmd ,
                              unsigned int payload_len ) 
{ 
  int rc ;

  {
  rc = -22;
  switch (cmd) {
  case 1U: 
  rc = bfad_iocmd_ioc_enable(bfad, iocmd);
  goto ldv_50207;
  case 2U: 
  rc = bfad_iocmd_ioc_disable(bfad, iocmd);
  goto ldv_50207;
  case 4U: 
  rc = bfad_iocmd_ioc_get_info(bfad, iocmd);
  goto ldv_50207;
  case 3U: 
  rc = bfad_iocmd_ioc_get_attr(bfad, iocmd);
  goto ldv_50207;
  case 5U: 
  rc = bfad_iocmd_ioc_get_stats(bfad, iocmd);
  goto ldv_50207;
  case 6U: 
  rc = bfad_iocmd_ioc_get_fwstats(bfad, iocmd, payload_len);
  goto ldv_50207;
  case 7U: ;
  case 8U: 
  rc = bfad_iocmd_ioc_reset_stats(bfad, iocmd, cmd);
  goto ldv_50207;
  case 9U: ;
  case 10U: 
  rc = bfad_iocmd_ioc_set_name(bfad, iocmd, cmd);
  goto ldv_50207;
  case 12U: 
  rc = bfad_iocmd_iocfc_get_attr(bfad, iocmd);
  goto ldv_50207;
  case 13U: 
  rc = bfad_iocmd_iocfc_set_intr(bfad, iocmd);
  goto ldv_50207;
  case 14U: 
  rc = bfad_iocmd_port_enable(bfad, iocmd);
  goto ldv_50207;
  case 15U: 
  rc = bfad_iocmd_port_disable(bfad, iocmd);
  goto ldv_50207;
  case 16U: 
  rc = bfad_iocmd_port_get_attr(bfad, iocmd);
  goto ldv_50207;
  case 17U: 
  rc = bfad_iocmd_port_get_stats(bfad, iocmd, payload_len);
  goto ldv_50207;
  case 18U: 
  rc = bfad_iocmd_port_reset_stats(bfad, iocmd);
  goto ldv_50207;
  case 19U: ;
  case 20U: ;
  case 21U: ;
  case 23U: 
  rc = bfad_iocmd_set_port_cfg(bfad, iocmd, cmd);
  goto ldv_50207;
  case 22U: 
  rc = bfad_iocmd_port_cfg_maxfrsize(bfad, iocmd);
  goto ldv_50207;
  case 24U: ;
  case 25U: 
  rc = bfad_iocmd_port_cfg_bbcr(bfad, cmd, iocmd);
  goto ldv_50207;
  case 26U: 
  rc = bfad_iocmd_port_get_bbcr_attr(bfad, iocmd);
  goto ldv_50207;
  case 27U: 
  rc = bfad_iocmd_lport_get_attr(bfad, iocmd);
  goto ldv_50207;
  case 29U: 
  rc = bfad_iocmd_lport_get_stats(bfad, iocmd);
  goto ldv_50207;
  case 30U: 
  rc = bfad_iocmd_lport_reset_stats(bfad, iocmd);
  goto ldv_50207;
  case 31U: 
  rc = bfad_iocmd_lport_get_iostats(bfad, iocmd);
  goto ldv_50207;
  case 28U: 
  rc = bfad_iocmd_lport_get_rports(bfad, iocmd, payload_len);
  goto ldv_50207;
  case 32U: 
  rc = bfad_iocmd_rport_get_attr(bfad, iocmd);
  goto ldv_50207;
  case 33U: 
  rc = bfad_iocmd_rport_get_addr(bfad, iocmd);
  goto ldv_50207;
  case 34U: 
  rc = bfad_iocmd_rport_get_stats(bfad, iocmd);
  goto ldv_50207;
  case 35U: 
  rc = bfad_iocmd_rport_clr_stats(bfad, iocmd);
  goto ldv_50207;
  case 36U: 
  rc = bfad_iocmd_rport_set_speed(bfad, iocmd);
  goto ldv_50207;
  case 37U: 
  rc = bfad_iocmd_vport_get_attr(bfad, iocmd);
  goto ldv_50207;
  case 38U: 
  rc = bfad_iocmd_vport_get_stats(bfad, iocmd);
  goto ldv_50207;
  case 39U: 
  rc = bfad_iocmd_vport_clr_stats(bfad, iocmd);
  goto ldv_50207;
  case 40U: 
  rc = bfad_iocmd_fabric_get_lports(bfad, iocmd, payload_len);
  goto ldv_50207;
  case 41U: ;
  case 42U: 
  rc = bfad_iocmd_ratelim(bfad, cmd, iocmd);
  goto ldv_50207;
  case 43U: 
  rc = bfad_iocmd_ratelim_speed(bfad, cmd, iocmd);
  goto ldv_50207;
  case 44U: 
  rc = bfad_iocmd_cfg_fcpim(bfad, iocmd);
  goto ldv_50207;
  case 45U: 
  rc = bfad_iocmd_fcpim_get_modstats(bfad, iocmd);
  goto ldv_50207;
  case 46U: 
  rc = bfad_iocmd_fcpim_clr_modstats(bfad, iocmd);
  goto ldv_50207;
  case 47U: 
  rc = bfad_iocmd_fcpim_get_del_itn_stats(bfad, iocmd);
  goto ldv_50207;
  case 48U: 
  rc = bfad_iocmd_itnim_get_attr(bfad, iocmd);
  goto ldv_50207;
  case 49U: 
  rc = bfad_iocmd_itnim_get_iostats(bfad, iocmd);
  goto ldv_50207;
  case 50U: 
  rc = bfad_iocmd_itnim_reset_stats(bfad, iocmd);
  goto ldv_50207;
  case 51U: 
  rc = bfad_iocmd_itnim_get_itnstats(bfad, iocmd);
  goto ldv_50207;
  case 53U: 
  rc = bfad_iocmd_fcport_enable(bfad, iocmd);
  goto ldv_50207;
  case 54U: 
  rc = bfad_iocmd_fcport_disable(bfad, iocmd);
  goto ldv_50207;
  case 52U: 
  rc = bfad_iocmd_ioc_get_pcifn_cfg(bfad, iocmd);
  goto ldv_50207;
  case 11U: 
  rc = bfad_iocmd_ioc_fw_sig_inv(bfad, iocmd);
  goto ldv_50207;
  case 55U: 
  rc = bfad_iocmd_pcifn_create(bfad, iocmd);
  goto ldv_50207;
  case 56U: 
  rc = bfad_iocmd_pcifn_delete(bfad, iocmd);
  goto ldv_50207;
  case 57U: 
  rc = bfad_iocmd_pcifn_bw(bfad, iocmd);
  goto ldv_50207;
  case 58U: 
  rc = bfad_iocmd_adapter_cfg_mode(bfad, iocmd);
  goto ldv_50207;
  case 59U: 
  rc = bfad_iocmd_port_cfg_mode(bfad, iocmd);
  goto ldv_50207;
  case 60U: ;
  case 61U: 
  rc = bfad_iocmd_ablk_optrom(bfad, cmd, iocmd);
  goto ldv_50207;
  case 62U: 
  rc = bfad_iocmd_faa_query(bfad, iocmd);
  goto ldv_50207;
  case 63U: 
  rc = bfad_iocmd_cee_attr(bfad, iocmd, payload_len);
  goto ldv_50207;
  case 64U: 
  rc = bfad_iocmd_cee_get_stats(bfad, iocmd, payload_len);
  goto ldv_50207;
  case 65U: 
  rc = bfad_iocmd_cee_reset_stats(bfad, iocmd);
  goto ldv_50207;
  case 66U: 
  rc = bfad_iocmd_sfp_media(bfad, iocmd);
  goto ldv_50207;
  case 67U: 
  rc = bfad_iocmd_sfp_speed(bfad, iocmd);
  goto ldv_50207;
  case 68U: 
  rc = bfad_iocmd_flash_get_attr(bfad, iocmd);
  goto ldv_50207;
  case 69U: 
  rc = bfad_iocmd_flash_erase_part(bfad, iocmd);
  goto ldv_50207;
  case 70U: 
  rc = bfad_iocmd_flash_update_part(bfad, iocmd, payload_len);
  goto ldv_50207;
  case 71U: 
  rc = bfad_iocmd_flash_read_part(bfad, iocmd, payload_len);
  goto ldv_50207;
  case 72U: 
  rc = bfad_iocmd_diag_temp(bfad, iocmd);
  goto ldv_50207;
  case 73U: 
  rc = bfad_iocmd_diag_memtest(bfad, iocmd);
  goto ldv_50207;
  case 74U: 
  rc = bfad_iocmd_diag_loopback(bfad, iocmd);
  goto ldv_50207;
  case 75U: 
  rc = bfad_iocmd_diag_fwping(bfad, iocmd);
  goto ldv_50207;
  case 76U: 
  rc = bfad_iocmd_diag_queuetest(bfad, iocmd);
  goto ldv_50207;
  case 77U: 
  rc = bfad_iocmd_diag_sfp(bfad, iocmd);
  goto ldv_50207;
  case 78U: 
  rc = bfad_iocmd_diag_led(bfad, iocmd);
  goto ldv_50207;
  case 79U: 
  rc = bfad_iocmd_diag_beacon_lport(bfad, iocmd);
  goto ldv_50207;
  case 80U: 
  rc = bfad_iocmd_diag_lb_stat(bfad, iocmd);
  goto ldv_50207;
  case 120U: 
  rc = bfad_iocmd_diag_dport_enable(bfad, iocmd);
  goto ldv_50207;
  case 121U: 
  rc = bfad_iocmd_diag_dport_disable(bfad, iocmd);
  goto ldv_50207;
  case 130U: 
  rc = bfad_iocmd_diag_dport_show(bfad, iocmd);
  goto ldv_50207;
  case 131U: 
  rc = bfad_iocmd_diag_dport_start(bfad, iocmd);
  goto ldv_50207;
  case 81U: 
  rc = bfad_iocmd_phy_get_attr(bfad, iocmd);
  goto ldv_50207;
  case 82U: 
  rc = bfad_iocmd_phy_get_stats(bfad, iocmd);
  goto ldv_50207;
  case 83U: 
  rc = bfad_iocmd_phy_update(bfad, iocmd, payload_len);
  goto ldv_50207;
  case 84U: 
  rc = bfad_iocmd_phy_read(bfad, iocmd, payload_len);
  goto ldv_50207;
  case 85U: 
  rc = bfad_iocmd_vhba_query(bfad, iocmd);
  goto ldv_50207;
  case 86U: 
  rc = bfad_iocmd_porglog_get(bfad, iocmd);
  goto ldv_50207;
  case 87U: 
  rc = bfad_iocmd_debug_fw_core(bfad, iocmd, payload_len);
  goto ldv_50207;
  case 88U: ;
  case 89U: ;
  case 90U: ;
  case 91U: 
  rc = bfad_iocmd_debug_ctl(bfad, iocmd, cmd);
  goto ldv_50207;
  case 92U: 
  rc = bfad_iocmd_porglog_ctl(bfad, iocmd);
  goto ldv_50207;
  case 93U: ;
  case 94U: 
  rc = bfad_iocmd_fcpim_cfg_profile(bfad, iocmd, cmd);
  goto ldv_50207;
  case 95U: 
  rc = bfad_iocmd_itnim_get_ioprofile(bfad, iocmd);
  goto ldv_50207;
  case 96U: 
  rc = bfad_iocmd_fcport_get_stats(bfad, iocmd);
  goto ldv_50207;
  case 97U: 
  rc = bfad_iocmd_fcport_reset_stats(bfad, iocmd);
  goto ldv_50207;
  case 98U: 
  rc = bfad_iocmd_boot_cfg(bfad, iocmd);
  goto ldv_50207;
  case 99U: 
  rc = bfad_iocmd_boot_query(bfad, iocmd);
  goto ldv_50207;
  case 100U: 
  rc = bfad_iocmd_preboot_query(bfad, iocmd);
  goto ldv_50207;
  case 101U: 
  rc = bfad_iocmd_ethboot_cfg(bfad, iocmd);
  goto ldv_50207;
  case 102U: 
  rc = bfad_iocmd_ethboot_query(bfad, iocmd);
  goto ldv_50207;
  case 103U: ;
  case 104U: 
  rc = bfad_iocmd_cfg_trunk(bfad, iocmd, cmd);
  goto ldv_50207;
  case 105U: 
  rc = bfad_iocmd_trunk_get_attr(bfad, iocmd);
  goto ldv_50207;
  case 106U: ;
  case 107U: 
  rc = bfad_iocmd_qos(bfad, iocmd, cmd);
  goto ldv_50207;
  case 108U: 
  rc = bfad_iocmd_qos_get_attr(bfad, iocmd);
  goto ldv_50207;
  case 109U: 
  rc = bfad_iocmd_qos_get_vc_attr(bfad, iocmd);
  goto ldv_50207;
  case 110U: 
  rc = bfad_iocmd_qos_get_stats(bfad, iocmd);
  goto ldv_50207;
  case 111U: 
  rc = bfad_iocmd_qos_reset_stats(bfad, iocmd);
  goto ldv_50207;
  case 122U: 
  rc = bfad_iocmd_qos_set_bw(bfad, iocmd);
  goto ldv_50207;
  case 112U: 
  rc = bfad_iocmd_vf_get_stats(bfad, iocmd);
  goto ldv_50207;
  case 113U: 
  rc = bfad_iocmd_vf_clr_stats(bfad, iocmd);
  goto ldv_50207;
  case 114U: ;
  case 115U: ;
  case 116U: 
  rc = bfad_iocmd_lunmask(bfad, iocmd, cmd);
  goto ldv_50207;
  case 117U: 
  rc = bfad_iocmd_fcpim_lunmask_query(bfad, iocmd);
  goto ldv_50207;
  case 118U: ;
  case 119U: 
  rc = bfad_iocmd_fcpim_cfg_lunmask(bfad, iocmd, cmd);
  goto ldv_50207;
  case 123U: 
  rc = bfad_iocmd_fcpim_throttle_query(bfad, iocmd);
  goto ldv_50207;
  case 124U: 
  rc = bfad_iocmd_fcpim_throttle_set(bfad, iocmd);
  goto ldv_50207;
  case 125U: 
  rc = bfad_iocmd_tfru_read(bfad, iocmd);
  goto ldv_50207;
  case 126U: 
  rc = bfad_iocmd_tfru_write(bfad, iocmd);
  goto ldv_50207;
  case 127U: 
  rc = bfad_iocmd_fruvpd_read(bfad, iocmd);
  goto ldv_50207;
  case 128U: 
  rc = bfad_iocmd_fruvpd_update(bfad, iocmd);
  goto ldv_50207;
  case 129U: 
  rc = bfad_iocmd_fruvpd_get_max_size(bfad, iocmd);
  goto ldv_50207;
  default: 
  rc = -22;
  goto ldv_50207;
  }
  ldv_50207: ;
  return (rc);
}
}
static int bfad_im_bsg_vendor_request(struct fc_bsg_job *job ) 
{ 
  uint32_t vendor_cmd ;
  struct bfad_im_port_s *im_port ;
  struct bfad_s *bfad ;
  struct request_queue *request_q ;
  void *payload_kbuf ;
  int rc ;

  {
  vendor_cmd = (job->request)->rqst_data.h_vendor.vendor_cmd[0];
  im_port = (struct bfad_im_port_s *)(job->shost)->hostdata[0];
  bfad = im_port->bfad;
  request_q = (job->req)->q;
  rc = -22;
  blk_queue_max_segments(request_q, 256);
  payload_kbuf = kzalloc((size_t )job->request_payload.payload_len, 208U);
  if ((unsigned long )payload_kbuf == (unsigned long )((void *)0)) {
    rc = -12;
    goto out;
  } else {

  }
  sg_copy_to_buffer(job->request_payload.sg_list, (unsigned int )job->request_payload.sg_cnt,
                    payload_kbuf, (size_t )job->request_payload.payload_len);
  rc = bfad_iocmd_handler(bfad, vendor_cmd, payload_kbuf, job->request_payload.payload_len);
  if (rc != 0) {
    goto error;
  } else {

  }
  sg_copy_from_buffer(job->reply_payload.sg_list, (unsigned int )job->reply_payload.sg_cnt,
                      (void const   *)payload_kbuf, (size_t )job->reply_payload.payload_len);
  kfree((void const   *)payload_kbuf);
  job->reply_len = job->reply_payload.payload_len;
  (job->reply)->reply_payload_rcv_len = job->reply_payload.payload_len;
  (job->reply)->result = (uint32_t )rc;
  (*(job->job_done))(job);
  return (rc);
  error: 
  kfree((void const   *)payload_kbuf);
  out: 
  (job->reply)->result = (uint32_t )rc;
  job->reply_len = 4U;
  (job->reply)->reply_payload_rcv_len = 0U;
  return (rc);
}
}
u64 bfad_fcxp_get_req_sgaddr_cb(void *bfad_fcxp , int sgeid ) 
{ 
  struct bfad_fcxp *drv_fcxp ;
  struct bfa_sge_s *sge ;
  u64 addr ;

  {
  drv_fcxp = (struct bfad_fcxp *)bfad_fcxp;
  sge = drv_fcxp->req_sge + (unsigned long )sgeid;
  addr = (unsigned long long )sge->sg_addr;
  return (addr);
}
}
u32 bfad_fcxp_get_req_sglen_cb(void *bfad_fcxp , int sgeid ) 
{ 
  struct bfad_fcxp *drv_fcxp ;
  struct bfa_sge_s *sge ;

  {
  drv_fcxp = (struct bfad_fcxp *)bfad_fcxp;
  sge = drv_fcxp->req_sge + (unsigned long )sgeid;
  return (sge->sg_len);
}
}
u64 bfad_fcxp_get_rsp_sgaddr_cb(void *bfad_fcxp , int sgeid ) 
{ 
  struct bfad_fcxp *drv_fcxp ;
  struct bfa_sge_s *sge ;
  u64 addr ;

  {
  drv_fcxp = (struct bfad_fcxp *)bfad_fcxp;
  sge = drv_fcxp->rsp_sge + (unsigned long )sgeid;
  addr = (unsigned long long )sge->sg_addr;
  return (addr);
}
}
u32 bfad_fcxp_get_rsp_sglen_cb(void *bfad_fcxp , int sgeid ) 
{ 
  struct bfad_fcxp *drv_fcxp ;
  struct bfa_sge_s *sge ;

  {
  drv_fcxp = (struct bfad_fcxp *)bfad_fcxp;
  sge = drv_fcxp->rsp_sge + (unsigned long )sgeid;
  return (sge->sg_len);
}
}
void bfad_send_fcpt_cb(void *bfad_fcxp , struct bfa_fcxp_s *fcxp , void *cbarg , enum bfa_status req_status ,
                       u32 rsp_len , u32 resid_len , struct fchs_s *rsp_fchs ) 
{ 
  struct bfad_fcxp *drv_fcxp ;

  {
  drv_fcxp = (struct bfad_fcxp *)bfad_fcxp;
  drv_fcxp->req_status = req_status;
  drv_fcxp->rsp_len = (u16 )rsp_len;
  drv_fcxp->bfa_fcxp = (void *)0;
  complete(& drv_fcxp->comp);
  return;
}
}
struct bfad_buf_info *bfad_fcxp_map_sg(struct bfad_s *bfad , void *payload_kbuf ,
                                       uint32_t payload_len , uint32_t *num_sgles ) 
{ 
  struct bfad_buf_info *buf_base ;
  struct bfad_buf_info *buf_info ;
  struct bfa_sge_s *sg_table ;
  int sge_num ;
    klee_make_symbolic(&sge_num, sizeof(int), "sge_num");
  void *tmp ;

  {
  sge_num = 1;
  tmp = kzalloc((unsigned long )sge_num * 40UL, 208U);
  buf_base = (struct bfad_buf_info *)tmp;
  if ((unsigned long )buf_base == (unsigned long )((struct bfad_buf_info *)0)) {
    return ((struct bfad_buf_info *)0);
  } else {

  }
  sg_table = (struct bfa_sge_s *)buf_base + (unsigned long )sge_num * 24UL;
  buf_info = buf_base;
  buf_info->size = payload_len;
  buf_info->virt = dma_zalloc_coherent(& (bfad->pcidev)->dev, (size_t )buf_info->size,
                                       & buf_info->phys, 208U);
  if ((unsigned long )buf_info->virt == (unsigned long )((void *)0)) {
    goto out_free_mem;
  } else {

  }
  memcpy(buf_info->virt, (void const   *)payload_kbuf, (size_t )buf_info->size);
  sg_table->sg_len = buf_info->size;
  sg_table->sg_addr = (void *)buf_info->phys;
  *num_sgles = (uint32_t )sge_num;
  return (buf_base);
  out_free_mem: 
  kfree((void const   *)buf_base);
  return ((struct bfad_buf_info *)0);
}
}
void bfad_fcxp_free_mem(struct bfad_s *bfad , struct bfad_buf_info *buf_base , uint32_t num_sgles ) 
{ 
  int i ;
  struct bfad_buf_info *buf_info ;

  {
  buf_info = buf_base;
  if ((unsigned long )buf_base != (unsigned long )((struct bfad_buf_info *)0)) {
    i = 0;
    goto ldv_50405;
    ldv_50404: ;
    if ((unsigned long )buf_info->virt != (unsigned long )((void *)0)) {
      dma_free_attrs(& (bfad->pcidev)->dev, (size_t )buf_info->size, buf_info->virt,
                     buf_info->phys, (struct dma_attrs *)0);
    } else {

    }
    buf_info = buf_info + 1;
    i = i + 1;
    ldv_50405: ;
    if ((uint32_t )i < num_sgles) {
      goto ldv_50404;
    } else {

    }
    kfree((void const   *)buf_base);
  } else {

  }
  return;
}
}
int bfad_fcxp_bsg_send(struct fc_bsg_job *job , struct bfad_fcxp *drv_fcxp , struct bfa_bsg_fcpt_s *bsg_fcpt ) 
{ 
  struct bfa_fcxp_s *hal_fcxp ;
  struct bfad_s *bfad ;
  unsigned long flags ;
  uint8_t lp_tag ;
  raw_spinlock_t *tmp ;

  {
  bfad = (drv_fcxp->port)->bfad;
  tmp = spinlock_check(& bfad->bfad_lock);
  flags = _raw_spin_lock_irqsave(tmp);
  hal_fcxp = bfa_fcxp_req_rsp_alloc((void *)drv_fcxp, & bfad->bfa, (int )drv_fcxp->num_req_sgles,
                                    (int )drv_fcxp->num_rsp_sgles, & bfad_fcxp_get_req_sgaddr_cb,
                                    & bfad_fcxp_get_req_sglen_cb, & bfad_fcxp_get_rsp_sgaddr_cb,
                                    & bfad_fcxp_get_rsp_sglen_cb, 1);
  if ((unsigned long )hal_fcxp == (unsigned long )((struct bfa_fcxp_s *)0)) {
    __bfa_trc(bfad->trcmod, __trc_fileno___1, 3333, 0ULL);
    spin_unlock_irqrestore(& bfad->bfad_lock, flags);
    return (3);
  } else {

  }
  drv_fcxp->bfa_fcxp = (void *)hal_fcxp;
  lp_tag = bfa_lps_get_tag_from_pid(& bfad->bfa, bsg_fcpt->fchs.s_id);
  bfa_fcxp_send(hal_fcxp, drv_fcxp->bfa_rport, (int )bsg_fcpt->vf_id, (int )lp_tag,
                (enum bfa_boolean )bsg_fcpt->cts, bsg_fcpt->cos, job->request_payload.payload_len,
                & bsg_fcpt->fchs, & bfad_send_fcpt_cb, (void *)bfad, job->reply_payload.payload_len,
                (int )((u8 )bsg_fcpt->tsecs));
  spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  return (0);
}
}
int bfad_im_bsg_els_ct_request(struct fc_bsg_job *job ) 
{ 
  struct bfa_bsg_data *bsg_data ;
  struct bfad_im_port_s *im_port ;
  struct bfad_s *bfad ;
  struct bfa_bsg_fcpt_s *bsg_fcpt ;
  struct bfad_fcxp *drv_fcxp ;
  struct bfa_fcs_lport_s *fcs_port ;
  struct bfa_fcs_rport_s *fcs_rport ;
  uint32_t command_type ;
  unsigned long flags ;
  struct bfad_buf_info *rsp_buf_info ;
  void *req_kbuf ;
  void *rsp_kbuf ;
  int rc ;
  void *tmp ;
  unsigned long tmp___0 ;
  void *tmp___1 ;
  raw_spinlock_t *tmp___2 ;
  enum bfa_boolean tmp___3 ;
  struct bfad_buf_info *tmp___4 ;
  struct bfad_buf_info *tmp___5 ;
  unsigned long tmp___6 ;

  {
  im_port = (struct bfad_im_port_s *)(job->shost)->hostdata[0];
  bfad = im_port->bfad;
  command_type = (job->request)->msgcode;
  req_kbuf = (void *)0;
  rsp_kbuf = (void *)0;
  rc = -22;
  job->reply_len = 4U;
  (job->reply)->reply_payload_rcv_len = 0U;
  bsg_data = (struct bfa_bsg_data *)job->request + 20U;
  if ((unsigned long )bsg_data == (unsigned long )((struct bfa_bsg_data *)0)) {
    goto out;
  } else {

  }
  tmp = kzalloc((size_t )bsg_data->payload_len, 208U);
  bsg_fcpt = (struct bfa_bsg_fcpt_s *)tmp;
  if ((unsigned long )bsg_fcpt == (unsigned long )((struct bfa_bsg_fcpt_s *)0)) {
    rc = -12;
    goto out;
  } else {

  }
  tmp___0 = copy_from_user((void *)bsg_fcpt, (void const   *)bsg_data->payload, (unsigned long )bsg_data->payload_len);
  if (tmp___0 != 0UL) {
    kfree((void const   *)bsg_fcpt);
    rc = -5;
    goto out;
  } else {

  }
  tmp___1 = kzalloc(216UL, 208U);
  drv_fcxp = (struct bfad_fcxp *)tmp___1;
  if ((unsigned long )drv_fcxp == (unsigned long )((struct bfad_fcxp *)0)) {
    kfree((void const   *)bsg_fcpt);
    rc = -12;
    goto out;
  } else {

  }
  tmp___2 = spinlock_check(& bfad->bfad_lock);
  flags = _raw_spin_lock_irqsave(tmp___2);
  fcs_port = bfa_fcs_lookup_port(& bfad->bfa_fcs, (int )bsg_fcpt->vf_id, bsg_fcpt->lpwwn);
  if ((unsigned long )fcs_port == (unsigned long )((struct bfa_fcs_lport_s *)0)) {
    bsg_fcpt->status = 18;
    spin_unlock_irqrestore(& bfad->bfad_lock, flags);
    goto out_free_mem;
  } else {

  }
  tmp___3 = bfa_fcs_lport_is_online(fcs_port);
  if ((unsigned int )tmp___3 == 0U) {
    bsg_fcpt->status = 34;
    spin_unlock_irqrestore(& bfad->bfad_lock, flags);
    goto out_free_mem;
  } else {

  }
  drv_fcxp->port = fcs_port->bfad_port;
  if ((unsigned long )(drv_fcxp->port)->bfad == (unsigned long )((struct bfad_s *)0)) {
    (drv_fcxp->port)->bfad = bfad;
  } else {

  }
  if (command_type == 2147483651U || command_type == 2147483652U) {
    drv_fcxp->bfa_rport = (struct bfa_rport_s *)0;
  } else
  if (command_type == 1073741825U || command_type == 1073741826U) {
    fcs_rport = bfa_fcs_lport_get_rport_by_pwwn(fcs_port, bsg_fcpt->dpwwn);
    if ((unsigned long )fcs_rport == (unsigned long )((struct bfa_fcs_rport_s *)0)) {
      bsg_fcpt->status = 19;
      spin_unlock_irqrestore(& bfad->bfad_lock, flags);
      goto out_free_mem;
    } else {

    }
    drv_fcxp->bfa_rport = fcs_rport->bfa_rport;
  } else {
    spin_unlock_irqrestore(& bfad->bfad_lock, flags);
    goto out_free_mem;
  }
  spin_unlock_irqrestore(& bfad->bfad_lock, flags);
  req_kbuf = kzalloc((size_t )job->request_payload.payload_len, 208U);
  if ((unsigned long )req_kbuf == (unsigned long )((void *)0)) {
    printk("\016bfa %s: fcpt request buffer alloc failed\n", bfad->pci_name);
    rc = -12;
    goto out_free_mem;
  } else {

  }
  rsp_kbuf = kzalloc((size_t )job->reply_payload.payload_len, 208U);
  if ((unsigned long )rsp_kbuf == (unsigned long )((void *)0)) {
    printk("\016bfa %s: fcpt response buffer alloc failed\n", bfad->pci_name);
    rc = -12;
    goto out_free_mem;
  } else {

  }
  sg_copy_to_buffer(job->request_payload.sg_list, (unsigned int )job->request_payload.sg_cnt,
                    req_kbuf, (size_t )job->request_payload.payload_len);
  tmp___4 = bfad_fcxp_map_sg(bfad, req_kbuf, job->request_payload.payload_len, & drv_fcxp->num_req_sgles);
  drv_fcxp->reqbuf_info = (void *)tmp___4;
  if ((unsigned long )drv_fcxp->reqbuf_info == (unsigned long )((void *)0)) {
    printk("\016bfa %s: fcpt request fcxp_map_sg failed\n", bfad->pci_name);
    rc = -12;
    goto out_free_mem;
  } else {

  }
  drv_fcxp->req_sge = (struct bfa_sge_s *)drv_fcxp->reqbuf_info + (unsigned long )drv_fcxp->num_req_sgles * 24UL;
  tmp___5 = bfad_fcxp_map_sg(bfad, rsp_kbuf, job->reply_payload.payload_len, & drv_fcxp->num_rsp_sgles);
  drv_fcxp->rspbuf_info = (void *)tmp___5;
  if ((unsigned long )drv_fcxp->rspbuf_info == (unsigned long )((void *)0)) {
    printk("\016bfa %s: fcpt response fcxp_map_sg failed\n", bfad->pci_name);
    rc = -12;
    goto out_free_mem;
  } else {

  }
  rsp_buf_info = (struct bfad_buf_info *)drv_fcxp->rspbuf_info;
  drv_fcxp->rsp_sge = (struct bfa_sge_s *)drv_fcxp->rspbuf_info + (unsigned long )drv_fcxp->num_rsp_sgles * 24UL;
  init_completion(& drv_fcxp->comp);
  rc = bfad_fcxp_bsg_send(job, drv_fcxp, bsg_fcpt);
  if (rc == 0) {
    wait_for_completion(& drv_fcxp->comp);
    bsg_fcpt->status = drv_fcxp->req_status;
  } else {
    bsg_fcpt->status = (enum bfa_status )rc;
    goto out_free_mem;
  }
  if ((unsigned int )drv_fcxp->req_status == 0U) {
    job->reply_len = (unsigned int )drv_fcxp->rsp_len;
    (job->reply)->reply_payload_rcv_len = (uint32_t )drv_fcxp->rsp_len;
    (job->reply)->reply_data.ctels_reply.status = 0U;
  } else {
    (job->reply)->reply_payload_rcv_len = 8U;
    job->reply_len = 4U;
    (job->reply)->reply_data.ctels_reply.status = 1U;
  }
  sg_copy_from_buffer(job->reply_payload.sg_list, (unsigned int )job->reply_payload.sg_cnt,
                      (void const   *)rsp_buf_info->virt, (size_t )job->reply_payload.payload_len);
  out_free_mem: 
  bfad_fcxp_free_mem(bfad, (struct bfad_buf_info *)drv_fcxp->rspbuf_info, drv_fcxp->num_rsp_sgles);
  bfad_fcxp_free_mem(bfad, (struct bfad_buf_info *)drv_fcxp->reqbuf_info, drv_fcxp->num_req_sgles);
  kfree((void const   *)req_kbuf);
  kfree((void const   *)rsp_kbuf);
  tmp___6 = copy_to_user((void *)bsg_data->payload, (void const   *)bsg_fcpt, (unsigned long )bsg_data->payload_len);
  if (tmp___6 != 0UL) {
    rc = -5;
  } else {

  }
  kfree((void const   *)bsg_fcpt);
  kfree((void const   *)drv_fcxp);
  out: 
  (job->reply)->result = (uint32_t )rc;
  if (rc == 0) {
    (*(job->job_done))(job);
  } else {

  }
  return (rc);
}
}
int bfad_im_bsg_request(struct fc_bsg_job *job ) 
{ 
  uint32_t rc ;
  int tmp ;
  int tmp___0 ;

  {
  rc = 0U;
  switch ((job->request)->msgcode) {
  case 2147483903U: 
  tmp = bfad_im_bsg_vendor_request(job);
  rc = (uint32_t )tmp;
  goto ldv_50445;
  case 2147483651U: ;
  case 1073741825U: ;
  case 2147483652U: ;
  case 1073741826U: 
  tmp___0 = bfad_im_bsg_els_ct_request(job);
  rc = (uint32_t )tmp___0;
  goto ldv_50445;
  default: 
  rc = 4294967274U;
  (job->reply)->result = rc;
  (job->reply)->reply_payload_rcv_len = 0U;
  goto ldv_50445;
  }
  ldv_50445: ;
  return ((int )rc);
}
}
int bfad_im_bsg_timeout(struct fc_bsg_job *job ) 
{ 


  {
  return (-11);
}
}
bool ldv_queue_work_on_195(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_3(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_delayed_work_on_196(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_3(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_work_on_197(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_3(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
void ldv_flush_workqueue_198(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
  flush_workqueue(ldv_func_arg1);
  call_and_disable_all_3(2);
  return;
}
}
bool ldv_queue_delayed_work_on_199(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_3(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
void ldv_mutex_lock_200(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_lock_lock(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_201(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_unlock_lock(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_202(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
int ldv_mutex_trylock_203(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
  tmp = mutex_trylock(ldv_func_arg1);
  ldv_func_res = tmp;
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
  return (tmp___0);
  return (ldv_func_res);
}
}
void ldv_mutex_unlock_204(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_205(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_unlock_i_mutex_of_inode(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_206(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_lock_i_mutex_of_inode(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
int ldv_scsi_add_host_with_dma_207(struct Scsi_Host *shost , struct device *dev ,
                                   struct device *dma_dev ) 
{ 
  ldv_func_ret_type___4 ldv_func_res ;
  int tmp ;

  {
  tmp = scsi_add_host_with_dma(shost, dev, dma_dev);
  ldv_func_res = tmp;
  if (ldv_func_res == 0) {
    ldv_state_variable_35 = 1;
    ldv_initialize_scsi_host_template_35();
  } else {

  }
  return (ldv_func_res);
}
}
void ldv_mutex_lock_208(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_lock_bfad_mutex(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_209(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_unlock_bfad_mutex(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_210(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_unlock_bfad_mutex(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_211(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_lock_bfad_mutex(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_212(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_unlock_bfad_mutex(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_213(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_unlock_bfad_mutex(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
__inline static long ldv__builtin_expect(long exp , long c ) ;
int ldv_mutex_trylock_245(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_243(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_246(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_247(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_242(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_244(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_248(struct mutex *ldv_func_arg1 ) ;
bool ldv_queue_work_on_237(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_work_on_239(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_delayed_work_on_238(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
bool ldv_queue_delayed_work_on_241(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
void ldv_flush_workqueue_240(struct workqueue_struct *ldv_func_arg1 ) ;
__inline static bool queue_work___0(struct workqueue_struct *wq , struct work_struct *work ) 
{ 
  bool tmp ;

  {
  tmp = ldv_queue_work_on_237(8192, wq, work);
  return (tmp);
}
}
extern void __const_udelay(unsigned long  ) ;
int ldv_scsi_add_host_with_dma_249(struct Scsi_Host *shost , struct device *dev ,
                                   struct device *dma_dev ) ;
__inline static int bfa_q_is_on_q_func(struct list_head *q , struct list_head *qe ) 
{ 
  struct list_head *tqe ;

  {
  tqe = q->next;
  goto ldv_40791;
  ldv_40790: ;
  if ((unsigned long )tqe == (unsigned long )qe) {
    return (1);
  } else {

  }
  tqe = tqe->next;
  if ((unsigned long )tqe == (unsigned long )((struct list_head *)0)) {
    goto ldv_40789;
  } else {

  }
  ldv_40791: ;
  if ((unsigned long )tqe != (unsigned long )q) {
    goto ldv_40790;
  } else {

  }
  ldv_40789: ;
  return (0);
}
}
__inline static int bfa_sm_to_state(struct bfa_sm_table_s *smt , void (*sm)(void * ,
                                                                            int  ) ) 
{ 
  int i ;

  {
  i = 0;
  goto ldv_40808;
  ldv_40807: 
  i = i + 1;
  ldv_40808: ;
  if ((unsigned long )(smt + (unsigned long )i)->sm != (unsigned long )((void (*)(void * ,
                                                                                  int  ))0) && (unsigned long )(smt + (unsigned long )i)->sm != (unsigned long )sm) {
    goto ldv_40807;
  } else {

  }

  return ((smt + (unsigned long )i)->state);
}
}
void bfa_timer_begin(struct bfa_timer_mod_s *mod , struct bfa_timer_s *timer , void (*timercb)(void * ) ,
                     void *arg , unsigned int timeout ) ;
void bfa_timer_stop(struct bfa_timer_s *timer ) ;
__inline static void __bfa_dma_be_addr_set(union bfi_addr_u *dma_addr , u64 pa ) 
{ 
  __u32 tmp ;
  __u32 tmp___0 ;

  {
  tmp = __fswab32((__u32 )pa);
  dma_addr->a32.addr_lo = tmp;
  tmp___0 = __fswab32((__u32 )(pa >> 32));
  dma_addr->a32.addr_hi = tmp___0;
  return;
}
}
__inline static void __bfa_alen_set(struct bfi_alen_s *alen , u32 len , u64 pa ) 
{ 
  __u32 tmp ;

  {
  tmp = __fswab32(len);
  alen->al_len = tmp;
  __bfa_dma_be_addr_set(& alen->al_addr, pa);
  return;
}
}
u32 bfa_sfp_meminfo(void) ;
void bfa_sfp_attach(struct bfa_sfp_s *sfp , struct bfa_ioc_s *ioc , void *dev , struct bfa_trc_mod_s *trcmod ) ;
void bfa_sfp_memclaim(struct bfa_sfp_s *sfp , u8 *dm_kva , u64 dm_pa ) ;
void bfa_sfp_intr(void *sfparg , struct bfi_mbmsg_s *msg ) ;
u32 bfa_flash_meminfo(enum bfa_boolean mincfg ) ;
void bfa_flash_attach(struct bfa_flash_s *flash , struct bfa_ioc_s *ioc , void *dev ,
                      struct bfa_trc_mod_s *trcmod , enum bfa_boolean mincfg ) ;
void bfa_flash_memclaim(struct bfa_flash_s *flash , u8 *dm_kva , u64 dm_pa , enum bfa_boolean mincfg ) ;
enum bfa_status bfa_flash_raw_read(void *pci_bar , u32 offset , char *buf , u32 len ) ;
u32 bfa_diag_meminfo(void) ;
void bfa_diag_memclaim(struct bfa_diag_s *diag , u8 *dm_kva , u64 dm_pa ) ;
void bfa_diag_attach(struct bfa_diag_s *diag , struct bfa_ioc_s *ioc , void *dev ,
                     void (*cbfn_beacon)(void * , enum bfa_boolean  , enum bfa_boolean  ) ,
                     struct bfa_trc_mod_s *trcmod ) ;
enum bfa_boolean bfa_phy_busy(struct bfa_ioc_s *ioc ) ;
u32 bfa_phy_meminfo(enum bfa_boolean mincfg ) ;
void bfa_phy_attach(struct bfa_phy_s *phy , struct bfa_ioc_s *ioc , void *dev , struct bfa_trc_mod_s *trcmod ,
                    enum bfa_boolean mincfg ) ;
void bfa_phy_memclaim(struct bfa_phy_s *phy , u8 *dm_kva , u64 dm_pa , enum bfa_boolean mincfg ) ;
void bfa_phy_intr(void *phyarg , struct bfi_mbmsg_s *msg ) ;
u32 bfa_fru_meminfo(enum bfa_boolean mincfg ) ;
void bfa_fru_attach(struct bfa_fru_s *fru , struct bfa_ioc_s *ioc , void *dev , struct bfa_trc_mod_s *trcmod ,
                    enum bfa_boolean mincfg ) ;
void bfa_fru_memclaim(struct bfa_fru_s *fru , u8 *dm_kva , u64 dm_pa , enum bfa_boolean mincfg ) ;
void bfa_fru_intr(void *fruarg , struct bfi_mbmsg_s *msg ) ;
void bfa_dconf_modinit(struct bfa_s *bfa ) ;
void bfa_dconf_modexit(struct bfa_s *bfa ) ;
enum bfa_status bfa_dconf_update(struct bfa_s *bfa ) ;
void bfa_ioc_mbox_queue(struct bfa_ioc_s *ioc , struct bfa_mbox_cmd_s *cmd ) ;
void bfa_ioc_mbox_register(struct bfa_ioc_s *ioc , bfa_ioc_mbox_mcfunc_t (**mcfuncs)(void * ,
                                                                                     struct bfi_mbmsg_s * ) ) ;
void bfa_ioc_mbox_isr(struct bfa_ioc_s *ioc ) ;
void bfa_ioc_mbox_send(struct bfa_ioc_s *ioc , void *ioc_msg , int len ) ;
enum bfa_boolean bfa_ioc_msgget(struct bfa_ioc_s *ioc , void *mbmsg ) ;
void bfa_ioc_mbox_regisr(struct bfa_ioc_s *ioc , enum bfi_mclass mc , void (*cbfn)(void * ,
                                                                                   struct bfi_mbmsg_s * ) ,
                         void *cbarg ) ;
enum bfa_status bfa_ioc_pll_init(struct bfa_ioc_s *ioc ) ;
void bfa_ioc_set_cb_hwif(struct bfa_ioc_s *ioc ) ;
void bfa_ioc_set_ct_hwif(struct bfa_ioc_s *ioc ) ;
void bfa_ioc_set_ct2_hwif(struct bfa_ioc_s *ioc ) ;
void bfa_ioc_ct2_poweron(struct bfa_ioc_s *ioc ) ;
void bfa_ioc_attach(struct bfa_ioc_s *ioc , void *bfa , struct bfa_ioc_cbfn_s *cbfn ,
                    struct bfa_timer_mod_s *timer_mod ) ;
void bfa_ioc_auto_recover(enum bfa_boolean auto_recover ) ;
void bfa_ioc_detach(struct bfa_ioc_s *ioc ) ;
void bfa_ioc_pci_init(struct bfa_ioc_s *ioc , struct bfa_pcidev_s *pcidev , enum bfi_pcifn_class clscode ) ;
void bfa_ioc_mem_claim(struct bfa_ioc_s *ioc , u8 *dm_kva , u64 dm_pa ) ;
void bfa_ioc_enable(struct bfa_ioc_s *ioc ) ;
void bfa_ioc_disable(struct bfa_ioc_s *ioc ) ;
enum bfa_status bfa_ioc_boot(struct bfa_ioc_s *ioc , u32 boot_type , u32 boot_env ) ;
void bfa_ioc_isr(struct bfa_ioc_s *ioc , struct bfi_mbmsg_s *m ) ;
void bfa_ioc_error_isr(struct bfa_ioc_s *ioc ) ;
enum bfa_boolean bfa_ioc_is_operational(struct bfa_ioc_s *ioc ) ;
enum bfa_boolean bfa_ioc_is_initialized(struct bfa_ioc_s *ioc ) ;
enum bfa_boolean bfa_ioc_fw_mismatch(struct bfa_ioc_s *ioc ) ;
enum bfa_boolean bfa_ioc_adapter_is_disabled(struct bfa_ioc_s *ioc ) ;
void bfa_ioc_reset_fwstate(struct bfa_ioc_s *ioc ) ;
void bfa_ioc_get_adapter_manufacturer(struct bfa_ioc_s *ioc , char *manufacturer ) ;
enum bfa_ioc_state bfa_ioc_get_state(struct bfa_ioc_s *ioc ) ;
void bfa_ioc_get_adapter_attr(struct bfa_ioc_s *ioc , struct bfa_adapter_attr_s *ad_attr ) ;
void bfa_ioc_debug_memclaim(struct bfa_ioc_s *ioc , void *dbg_fwsave ) ;
enum bfa_boolean bfa_ioc_sem_get(void *sem_reg ) ;
void bfa_ioc_fwver_get(struct bfa_ioc_s *ioc , struct bfi_ioc_image_hdr_s *fwhdr ) ;
enum bfa_boolean bfa_ioc_fwver_cmp(struct bfa_ioc_s *ioc , struct bfi_ioc_image_hdr_s *smem_fwhdr ) ;
void bfa_ioc_aen_post(struct bfa_ioc_s *ioc , enum bfa_ioc_aen_event event ) ;
u32 bfa_ablk_meminfo(void) ;
void bfa_ablk_memclaim(struct bfa_ablk_s *ablk , u8 *dma_kva , u64 dma_pa ) ;
void bfa_ablk_attach(struct bfa_ablk_s *ablk , struct bfa_ioc_s *ioc ) ;
enum bfa_status bfa_ioc_flash_img_get_chnk(struct bfa_ioc_s *ioc , u32 off , u32 *fwimg ) ;
__inline static u32 *bfi_image_cb_get_chunk(u32 off ) 
{ 


  {
  return (bfi_image_cb + (unsigned long )off);
}
}
__inline static u32 *bfi_image_ct_get_chunk(u32 off ) 
{ 


  {
  return (bfi_image_ct + (unsigned long )off);
}
}
__inline static u32 *bfi_image_ct2_get_chunk(u32 off ) 
{ 


  {
  return (bfi_image_ct2 + (unsigned long )off);
}
}
__inline static u32 *bfa_cb_image_get_chunk(enum bfi_asic_gen asic_gen , u32 off ) 
{ 
  u32 *tmp ;
  u32 *tmp___0 ;
  u32 *tmp___1 ;

  {
  switch ((unsigned int )asic_gen) {
  case 1U: 
  tmp = bfi_image_cb_get_chunk(off);
  return (tmp);
  case 2U: 
  tmp___0 = bfi_image_ct_get_chunk(off);
  return (tmp___0);
  case 3U: 
  tmp___1 = bfi_image_ct2_get_chunk(off);
  return (tmp___1);
  default: ;
  return ((u32 *)0U);
  }
}
}
__inline static u32 bfa_cb_image_get_size(enum bfi_asic_gen asic_gen ) 
{ 


  {
  switch ((unsigned int )asic_gen) {
  case 1U: ;
  return (bfi_image_cb_size);
  case 2U: ;
  return (bfi_image_ct_size);
  case 3U: ;
  return (bfi_image_ct2_size);
  default: ;
  return (0U);
  }
}
}
struct bfa_module_s hal_mod_dconf ;
static int __trc_fileno___2  =    4098;
enum bfa_boolean bfa_auto_recover  =    1;
static void bfa_ioc_hw_sem_get(struct bfa_ioc_s *ioc ) ;
static void bfa_ioc_hwinit(struct bfa_ioc_s *ioc , enum bfa_boolean force ) ;
static void bfa_ioc_timeout(void *ioc_arg ) ;
static void bfa_ioc_poll_fwinit(struct bfa_ioc_s *ioc ) ;
static void bfa_ioc_send_enable(struct bfa_ioc_s *ioc ) ;
static void bfa_ioc_send_disable(struct bfa_ioc_s *ioc ) ;
static void bfa_ioc_send_getattr(struct bfa_ioc_s *ioc ) ;
static void bfa_ioc_hb_monitor(struct bfa_ioc_s *ioc ) ;
static void bfa_ioc_mbox_poll(struct bfa_ioc_s *ioc ) ;
static void bfa_ioc_mbox_flush(struct bfa_ioc_s *ioc ) ;
static void bfa_ioc_recover(struct bfa_ioc_s *ioc ) ;
static void bfa_ioc_event_notify(struct bfa_ioc_s *ioc , enum bfa_ioc_event_e event ) ;
static void bfa_ioc_disable_comp(struct bfa_ioc_s *ioc ) ;
static void bfa_ioc_lpu_stop(struct bfa_ioc_s *ioc ) ;
static void bfa_ioc_fail_notify(struct bfa_ioc_s *ioc ) ;
static void bfa_ioc_pf_fwmismatch(struct bfa_ioc_s *ioc ) ;
static enum bfi_ioc_img_ver_cmp_e bfa_ioc_fw_ver_patch_cmp(struct bfi_ioc_image_hdr_s *base_fwhdr ,
                                                           struct bfi_ioc_image_hdr_s *fwhdr_to_cmp ) ;
static enum bfi_ioc_img_ver_cmp_e bfa_ioc_flash_fwver_cmp(struct bfa_ioc_s *ioc ,
                                                          struct bfi_ioc_image_hdr_s *base_fwhdr ) ;
static void bfa_ioc_sm_uninit(struct bfa_ioc_s *ioc , enum ioc_event event ) ;
static void bfa_ioc_sm_uninit_entry(struct bfa_ioc_s *ioc ) ;
static void bfa_ioc_sm_reset(struct bfa_ioc_s *ioc , enum ioc_event event ) ;
static void bfa_ioc_sm_reset_entry(struct bfa_ioc_s *ioc ) ;
static void bfa_ioc_sm_enabling(struct bfa_ioc_s *ioc , enum ioc_event event ) ;
static void bfa_ioc_sm_enabling_entry(struct bfa_ioc_s *ioc ) ;
static void bfa_ioc_sm_getattr(struct bfa_ioc_s *ioc , enum ioc_event event ) ;
static void bfa_ioc_sm_getattr_entry(struct bfa_ioc_s *ioc ) ;
static void bfa_ioc_sm_op(struct bfa_ioc_s *ioc , enum ioc_event event ) ;
static void bfa_ioc_sm_op_entry(struct bfa_ioc_s *ioc ) ;
static void bfa_ioc_sm_fail_retry(struct bfa_ioc_s *ioc , enum ioc_event event ) ;
static void bfa_ioc_sm_fail_retry_entry(struct bfa_ioc_s *ioc ) ;
static void bfa_ioc_sm_fail(struct bfa_ioc_s *ioc , enum ioc_event event ) ;
static void bfa_ioc_sm_fail_entry(struct bfa_ioc_s *ioc ) ;
static void bfa_ioc_sm_disabling(struct bfa_ioc_s *ioc , enum ioc_event event ) ;
static void bfa_ioc_sm_disabling_entry(struct bfa_ioc_s *ioc ) ;
static void bfa_ioc_sm_disabled(struct bfa_ioc_s *ioc , enum ioc_event event ) ;
static void bfa_ioc_sm_disabled_entry(struct bfa_ioc_s *ioc ) ;
static void bfa_ioc_sm_hwfail(struct bfa_ioc_s *ioc , enum ioc_event event ) ;
static void bfa_ioc_sm_hwfail_entry(struct bfa_ioc_s *ioc ) ;
static struct bfa_sm_table_s ioc_sm_table[10U]  = 
  {      {(void (*)(void * , int  ))(& bfa_ioc_sm_uninit), 1, 0}, 
        {(void (*)(void * , int  ))(& bfa_ioc_sm_reset), 2, 0}, 
        {(void (*)(void * , int  ))(& bfa_ioc_sm_enabling), 12, 0}, 
        {(void (*)(void * , int  ))(& bfa_ioc_sm_getattr), 5, 0}, 
        {(void (*)(void * , int  ))(& bfa_ioc_sm_op), 6, 0}, 
        {(void (*)(void * , int  ))(& bfa_ioc_sm_fail_retry), 7, 0}, 
        {(void (*)(void * , int  ))(& bfa_ioc_sm_fail), 8, 0}, 
        {(void (*)(void * , int  ))(& bfa_ioc_sm_disabling), 9, 0}, 
        {(void (*)(void * , int  ))(& bfa_ioc_sm_disabled), 10, 0}, 
        {(void (*)(void * , int  ))(& bfa_ioc_sm_hwfail), 13, 0}};
static void bfa_iocpf_timeout(void *ioc_arg ) ;
static void bfa_iocpf_sem_timeout(void *ioc_arg ) ;
static void bfa_iocpf_poll_timeout(void *ioc_arg ) ;
static void bfa_iocpf_sm_reset(struct bfa_iocpf_s *iocpf , enum iocpf_event event ) ;
static void bfa_iocpf_sm_reset_entry(struct bfa_iocpf_s *iocpf ) ;
static void bfa_iocpf_sm_fwcheck(struct bfa_iocpf_s *iocpf , enum iocpf_event event ) ;
static void bfa_iocpf_sm_fwcheck_entry(struct bfa_iocpf_s *iocpf ) ;
static void bfa_iocpf_sm_mismatch(struct bfa_iocpf_s *iocpf , enum iocpf_event event ) ;
static void bfa_iocpf_sm_mismatch_entry(struct bfa_iocpf_s *iocpf ) ;
static void bfa_iocpf_sm_semwait(struct bfa_iocpf_s *iocpf , enum iocpf_event event ) ;
static void bfa_iocpf_sm_semwait_entry(struct bfa_iocpf_s *iocpf ) ;
static void bfa_iocpf_sm_hwinit(struct bfa_iocpf_s *iocpf , enum iocpf_event event ) ;
static void bfa_iocpf_sm_hwinit_entry(struct bfa_iocpf_s *iocpf ) ;
static void bfa_iocpf_sm_enabling(struct bfa_iocpf_s *iocpf , enum iocpf_event event ) ;
static void bfa_iocpf_sm_enabling_entry(struct bfa_iocpf_s *iocpf ) ;
static void bfa_iocpf_sm_ready(struct bfa_iocpf_s *iocpf , enum iocpf_event event ) ;
static void bfa_iocpf_sm_ready_entry(struct bfa_iocpf_s *iocpf ) ;
static void bfa_iocpf_sm_initfail_sync(struct bfa_iocpf_s *iocpf , enum iocpf_event event ) ;
static void bfa_iocpf_sm_initfail_sync_entry(struct bfa_iocpf_s *iocpf ) ;
static void bfa_iocpf_sm_initfail(struct bfa_iocpf_s *iocpf , enum iocpf_event event ) ;
static void bfa_iocpf_sm_initfail_entry(struct bfa_iocpf_s *iocpf ) ;
static void bfa_iocpf_sm_fail_sync(struct bfa_iocpf_s *iocpf , enum iocpf_event event ) ;
static void bfa_iocpf_sm_fail_sync_entry(struct bfa_iocpf_s *iocpf ) ;
static void bfa_iocpf_sm_fail(struct bfa_iocpf_s *iocpf , enum iocpf_event event ) ;
static void bfa_iocpf_sm_fail_entry(struct bfa_iocpf_s *iocpf ) ;
static void bfa_iocpf_sm_disabling(struct bfa_iocpf_s *iocpf , enum iocpf_event event ) ;
static void bfa_iocpf_sm_disabling_entry(struct bfa_iocpf_s *iocpf ) ;
static void bfa_iocpf_sm_disabling_sync(struct bfa_iocpf_s *iocpf , enum iocpf_event event ) ;
static void bfa_iocpf_sm_disabling_sync_entry(struct bfa_iocpf_s *iocpf ) ;
static void bfa_iocpf_sm_disabled(struct bfa_iocpf_s *iocpf , enum iocpf_event event ) ;
static void bfa_iocpf_sm_disabled_entry(struct bfa_iocpf_s *iocpf ) ;
static struct bfa_sm_table_s iocpf_sm_table[14U]  = 
  {      {(void (*)(void * , int  ))(& bfa_iocpf_sm_reset), 1, 0}, 
        {(void (*)(void * , int  ))(& bfa_iocpf_sm_fwcheck), 9, 0}, 
        {(void (*)(void * , int  ))(& bfa_iocpf_sm_mismatch), 9, 0}, 
        {(void (*)(void * , int  ))(& bfa_iocpf_sm_semwait), 2, 0}, 
        {(void (*)(void * , int  ))(& bfa_iocpf_sm_hwinit), 3, 0}, 
        {(void (*)(void * , int  ))(& bfa_iocpf_sm_enabling), 3, 0}, 
        {(void (*)(void * , int  ))(& bfa_iocpf_sm_ready), 4, 0}, 
        {(void (*)(void * , int  ))(& bfa_iocpf_sm_initfail_sync), 5, 0}, 
        {(void (*)(void * , int  ))(& bfa_iocpf_sm_initfail), 5, 0}, 
        {(void (*)(void * , int  ))(& bfa_iocpf_sm_fail_sync), 6, 0}, 
        {(void (*)(void * , int  ))(& bfa_iocpf_sm_fail), 6, 0}, 
        {(void (*)(void * , int  ))(& bfa_iocpf_sm_disabling), 7, 0}, 
        {(void (*)(void * , int  ))(& bfa_iocpf_sm_disabling_sync), 7, 0}, 
        {(void (*)(void * , int  ))(& bfa_iocpf_sm_disabled), 8, 0}};
static void bfa_ioc_sm_uninit_entry(struct bfa_ioc_s *ioc ) 
{ 


  {
  return;
}
}
static void bfa_ioc_sm_uninit(struct bfa_ioc_s *ioc , enum ioc_event event ) 
{ 


  {
  __bfa_trc(ioc->trcmod, __trc_fileno___2, 274, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 1U: 
  ioc->fsm = (void (*)(void * , int  ))(& bfa_ioc_sm_reset);
  bfa_ioc_sm_reset_entry(ioc);
  goto ldv_48497;
  default: 
  __bfa_trc(ioc->trcmod, __trc_fileno___2, 282, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_ioc.c",
         282, (unsigned int )event);
  }
  ldv_48497: ;
  return;
}
}
static void bfa_ioc_sm_reset_entry(struct bfa_ioc_s *ioc ) 
{ 


  {
  ioc->iocpf.fsm = (void (*)(void * , int  ))(& bfa_iocpf_sm_reset);
  bfa_iocpf_sm_reset_entry(& ioc->iocpf);
  return;
}
}
static void bfa_ioc_sm_reset(struct bfa_ioc_s *ioc , enum ioc_event event ) 
{ 


  {
  __bfa_trc(ioc->trcmod, __trc_fileno___2, 300, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 2U: 
  ioc->fsm = (void (*)(void * , int  ))(& bfa_ioc_sm_enabling);
  bfa_ioc_sm_enabling_entry(ioc);
  goto ldv_48507;
  case 3U: 
  bfa_ioc_disable_comp(ioc);
  goto ldv_48507;
  case 4U: 
  ioc->fsm = (void (*)(void * , int  ))(& bfa_ioc_sm_uninit);
  bfa_ioc_sm_uninit_entry(ioc);
  goto ldv_48507;
  default: 
  __bfa_trc(ioc->trcmod, __trc_fileno___2, 316, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_ioc.c",
         316, (unsigned int )event);
  }
  ldv_48507: ;
  return;
}
}
static void bfa_ioc_sm_enabling_entry(struct bfa_ioc_s *ioc ) 
{ 


  {
  (*(ioc->iocpf.fsm))((void *)(& ioc->iocpf), 1);
  return;
}
}
static void bfa_ioc_sm_enabling(struct bfa_ioc_s *ioc , enum ioc_event event ) 
{ 


  {
  __bfa_trc(ioc->trcmod, __trc_fileno___2, 334, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 5U: 
  ioc->fsm = (void (*)(void * , int  ))(& bfa_ioc_sm_getattr);
  bfa_ioc_sm_getattr_entry(ioc);
  goto ldv_48519;
  case 8U: ;
  case 10U: 
  (*((ioc->cbfn)->enable_cbfn))((void *)ioc->bfa, 56);
  ioc->fsm = (void (*)(void * , int  ))(& bfa_ioc_sm_fail);
  bfa_ioc_sm_fail_entry(ioc);
  if ((unsigned int )event != 8U) {
    (*(ioc->iocpf.fsm))((void *)(& ioc->iocpf), 8);
  } else {

  }
  goto ldv_48519;
  case 12U: 
  (*((ioc->cbfn)->enable_cbfn))((void *)ioc->bfa, 56);
  ioc->fsm = (void (*)(void * , int  ))(& bfa_ioc_sm_hwfail);
  bfa_ioc_sm_hwfail_entry(ioc);
  goto ldv_48519;
  case 3U: 
  ioc->fsm = (void (*)(void * , int  ))(& bfa_ioc_sm_disabling);
  bfa_ioc_sm_disabling_entry(ioc);
  goto ldv_48519;
  case 4U: 
  ioc->fsm = (void (*)(void * , int  ))(& bfa_ioc_sm_uninit);
  bfa_ioc_sm_uninit_entry(ioc);
  (*(ioc->iocpf.fsm))((void *)(& ioc->iocpf), 3);
  goto ldv_48519;
  case 2U: ;
  goto ldv_48519;
  default: 
  __bfa_trc(ioc->trcmod, __trc_fileno___2, 368, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_ioc.c",
         368, (unsigned int )event);
  }
  ldv_48519: ;
  return;
}
}
static void bfa_ioc_sm_getattr_entry(struct bfa_ioc_s *ioc ) 
{ 


  {
  bfa_timer_begin(ioc->timer_mod, & ioc->ioc_timer, & bfa_ioc_timeout, (void *)ioc,
                  3000U);
  bfa_ioc_send_getattr(ioc);
  return;
}
}
static void bfa_ioc_sm_getattr(struct bfa_ioc_s *ioc , enum ioc_event event ) 
{ 


  {
  __bfa_trc(ioc->trcmod, __trc_fileno___2, 386, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 6U: 
  bfa_timer_stop(& ioc->ioc_timer);
  ioc->fsm = (void (*)(void * , int  ))(& bfa_ioc_sm_op);
  bfa_ioc_sm_op_entry(ioc);
  goto ldv_48535;
  case 8U: ;
  case 10U: 
  bfa_timer_stop(& ioc->ioc_timer);
  case 11U: 
  (*((ioc->cbfn)->enable_cbfn))((void *)ioc->bfa, 56);
  ioc->fsm = (void (*)(void * , int  ))(& bfa_ioc_sm_fail);
  bfa_ioc_sm_fail_entry(ioc);
  if ((unsigned int )event != 8U) {
    (*(ioc->iocpf.fsm))((void *)(& ioc->iocpf), 9);
  } else {

  }
  goto ldv_48535;
  case 3U: 
  bfa_timer_stop(& ioc->ioc_timer);
  ioc->fsm = (void (*)(void * , int  ))(& bfa_ioc_sm_disabling);
  bfa_ioc_sm_disabling_entry(ioc);
  goto ldv_48535;
  case 2U: ;
  goto ldv_48535;
  default: 
  __bfa_trc(ioc->trcmod, __trc_fileno___2, 414, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_ioc.c",
         414, (unsigned int )event);
  }
  ldv_48535: ;
  return;
}
}
static void bfa_ioc_sm_op_entry(struct bfa_ioc_s *ioc ) 
{ 
  struct bfad_s *bfad ;

  {
  bfad = (struct bfad_s *)(ioc->bfa)->bfad;
  (*((ioc->cbfn)->enable_cbfn))((void *)ioc->bfa, 0);
  bfa_ioc_event_notify(ioc, 1);
  bfa_ioc_hb_monitor(ioc);
  if (bfa_log_level == 4 || (int )((signed char )*("\016" + 1)) <= 52) {
    dev_printk("\016", (struct device  const  *)(& (bfad->pcidev)->dev), "IOC enabled\n");
  } else {

  }
  bfa_ioc_aen_post(ioc, 3);
  return;
}
}
static void bfa_ioc_sm_op(struct bfa_ioc_s *ioc , enum ioc_event event ) 
{ 


  {
  __bfa_trc(ioc->trcmod, __trc_fileno___2, 433, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 2U: ;
  goto ldv_48551;
  case 3U: 
  bfa_timer_stop(& ioc->hb_timer);
  ioc->fsm = (void (*)(void * , int  ))(& bfa_ioc_sm_disabling);
  bfa_ioc_sm_disabling_entry(ioc);
  goto ldv_48551;
  case 8U: ;
  case 10U: 
  bfa_timer_stop(& ioc->hb_timer);
  case 9U: ;
  if ((unsigned int )ioc->iocpf.auto_recover != 0U) {
    ioc->fsm = (void (*)(void * , int  ))(& bfa_ioc_sm_fail_retry);
    bfa_ioc_sm_fail_retry_entry(ioc);
  } else {
    ioc->fsm = (void (*)(void * , int  ))(& bfa_ioc_sm_fail);
    bfa_ioc_sm_fail_entry(ioc);
  }
  bfa_ioc_fail_notify(ioc);
  if ((unsigned int )event != 8U) {
    (*(ioc->iocpf.fsm))((void *)(& ioc->iocpf), 7);
  } else {

  }
  goto ldv_48551;
  default: 
  __bfa_trc(ioc->trcmod, __trc_fileno___2, 461, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_ioc.c",
         461, (unsigned int )event);
  }
  ldv_48551: ;
  return;
}
}
static void bfa_ioc_sm_disabling_entry(struct bfa_ioc_s *ioc ) 
{ 
  struct bfad_s *bfad ;

  {
  bfad = (struct bfad_s *)(ioc->bfa)->bfad;
  (*(ioc->iocpf.fsm))((void *)(& ioc->iocpf), 2);
  if (bfa_log_level == 4 || (int )((signed char )*("\016" + 1)) <= 52) {
    dev_printk("\016", (struct device  const  *)(& (bfad->pcidev)->dev), "IOC disabled\n");
  } else {

  }
  bfa_ioc_aen_post(ioc, 4);
  return;
}
}
static void bfa_ioc_sm_disabling(struct bfa_ioc_s *ioc , enum ioc_event event ) 
{ 


  {
  __bfa_trc(ioc->trcmod, __trc_fileno___2, 481, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 7U: 
  ioc->fsm = (void (*)(void * , int  ))(& bfa_ioc_sm_disabled);
  bfa_ioc_sm_disabled_entry(ioc);
  goto ldv_48566;
  case 10U: 
  (*(ioc->iocpf.fsm))((void *)(& ioc->iocpf), 7);
  goto ldv_48566;
  case 12U: 
  ioc->fsm = (void (*)(void * , int  ))(& bfa_ioc_sm_hwfail);
  bfa_ioc_sm_hwfail_entry(ioc);
  bfa_ioc_disable_comp(ioc);
  goto ldv_48566;
  default: 
  __bfa_trc(ioc->trcmod, __trc_fileno___2, 503, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_ioc.c",
         503, (unsigned int )event);
  }
  ldv_48566: ;
  return;
}
}
static void bfa_ioc_sm_disabled_entry(struct bfa_ioc_s *ioc ) 
{ 


  {
  bfa_ioc_disable_comp(ioc);
  return;
}
}
static void bfa_ioc_sm_disabled(struct bfa_ioc_s *ioc , enum ioc_event event ) 
{ 


  {
  __bfa_trc(ioc->trcmod, __trc_fileno___2, 519, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 2U: 
  ioc->fsm = (void (*)(void * , int  ))(& bfa_ioc_sm_enabling);
  bfa_ioc_sm_enabling_entry(ioc);
  goto ldv_48578;
  case 3U: 
  (*((ioc->cbfn)->disable_cbfn))((void *)ioc->bfa);
  goto ldv_48578;
  case 4U: 
  ioc->fsm = (void (*)(void * , int  ))(& bfa_ioc_sm_uninit);
  bfa_ioc_sm_uninit_entry(ioc);
  (*(ioc->iocpf.fsm))((void *)(& ioc->iocpf), 3);
  goto ldv_48578;
  default: 
  __bfa_trc(ioc->trcmod, __trc_fileno___2, 536, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_ioc.c",
         536, (unsigned int )event);
  }
  ldv_48578: ;
  return;
}
}
static void bfa_ioc_sm_fail_retry_entry(struct bfa_ioc_s *ioc ) 
{ 


  {
  __bfa_trc(ioc->trcmod, __trc_fileno___2, 544, 0ULL);
  return;
}
}
static void bfa_ioc_sm_fail_retry(struct bfa_ioc_s *ioc , enum ioc_event event ) 
{ 


  {
  __bfa_trc(ioc->trcmod, __trc_fileno___2, 553, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 5U: 
  ioc->fsm = (void (*)(void * , int  ))(& bfa_ioc_sm_getattr);
  bfa_ioc_sm_getattr_entry(ioc);
  goto ldv_48590;
  case 8U: ;
  case 10U: 
  (*((ioc->cbfn)->enable_cbfn))((void *)ioc->bfa, 56);
  ioc->fsm = (void (*)(void * , int  ))(& bfa_ioc_sm_fail);
  bfa_ioc_sm_fail_entry(ioc);
  if ((unsigned int )event != 8U) {
    (*(ioc->iocpf.fsm))((void *)(& ioc->iocpf), 8);
  } else {

  }
  goto ldv_48590;
  case 12U: 
  (*((ioc->cbfn)->enable_cbfn))((void *)ioc->bfa, 56);
  ioc->fsm = (void (*)(void * , int  ))(& bfa_ioc_sm_hwfail);
  bfa_ioc_sm_hwfail_entry(ioc);
  goto ldv_48590;
  case 2U: ;
  goto ldv_48590;
  case 3U: 
  ioc->fsm = (void (*)(void * , int  ))(& bfa_ioc_sm_disabling);
  bfa_ioc_sm_disabling_entry(ioc);
  goto ldv_48590;
  case 4U: 
  ioc->fsm = (void (*)(void * , int  ))(& bfa_ioc_sm_uninit);
  bfa_ioc_sm_uninit_entry(ioc);
  (*(ioc->iocpf.fsm))((void *)(& ioc->iocpf), 3);
  goto ldv_48590;
  default: 
  __bfa_trc(ioc->trcmod, __trc_fileno___2, 589, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_ioc.c",
         589, (unsigned int )event);
  }
  ldv_48590: ;
  return;
}
}
static void bfa_ioc_sm_fail_entry(struct bfa_ioc_s *ioc ) 
{ 


  {
  __bfa_trc(ioc->trcmod, __trc_fileno___2, 597, 0ULL);
  return;
}
}
static void bfa_ioc_sm_fail(struct bfa_ioc_s *ioc , enum ioc_event event ) 
{ 


  {
  __bfa_trc(ioc->trcmod, __trc_fileno___2, 606, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 2U: 
  (*((ioc->cbfn)->enable_cbfn))((void *)ioc->bfa, 56);
  goto ldv_48606;
  case 3U: 
  ioc->fsm = (void (*)(void * , int  ))(& bfa_ioc_sm_disabling);
  bfa_ioc_sm_disabling_entry(ioc);
  goto ldv_48606;
  case 4U: 
  ioc->fsm = (void (*)(void * , int  ))(& bfa_ioc_sm_uninit);
  bfa_ioc_sm_uninit_entry(ioc);
  (*(ioc->iocpf.fsm))((void *)(& ioc->iocpf), 3);
  goto ldv_48606;
  case 10U: ;
  case 12U: ;
  goto ldv_48606;
  default: 
  __bfa_trc(ioc->trcmod, __trc_fileno___2, 630, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_ioc.c",
         630, (unsigned int )event);
  }
  ldv_48606: ;
  return;
}
}
static void bfa_ioc_sm_hwfail_entry(struct bfa_ioc_s *ioc ) 
{ 


  {
  __bfa_trc(ioc->trcmod, __trc_fileno___2, 637, 0ULL);
  return;
}
}
static void bfa_ioc_sm_hwfail(struct bfa_ioc_s *ioc , enum ioc_event event ) 
{ 


  {
  __bfa_trc(ioc->trcmod, __trc_fileno___2, 643, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 2U: 
  (*((ioc->cbfn)->enable_cbfn))((void *)ioc->bfa, 56);
  goto ldv_48620;
  case 3U: 
  (*((ioc->cbfn)->disable_cbfn))((void *)ioc->bfa);
  goto ldv_48620;
  case 4U: 
  ioc->fsm = (void (*)(void * , int  ))(& bfa_ioc_sm_uninit);
  bfa_ioc_sm_uninit_entry(ioc);
  goto ldv_48620;
  case 10U: ;
  goto ldv_48620;
  default: 
  __bfa_trc(ioc->trcmod, __trc_fileno___2, 663, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_ioc.c",
         663, (unsigned int )event);
  }
  ldv_48620: ;
  return;
}
}
static void bfa_iocpf_sm_reset_entry(struct bfa_iocpf_s *iocpf ) 
{ 


  {
  iocpf->fw_mismatch_notified = 0;
  iocpf->auto_recover = bfa_auto_recover;
  return;
}
}
static void bfa_iocpf_sm_reset(struct bfa_iocpf_s *iocpf , enum iocpf_event event ) 
{ 
  struct bfa_ioc_s *ioc ;

  {
  ioc = iocpf->ioc;
  __bfa_trc(ioc->trcmod, __trc_fileno___2, 689, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 1U: 
  iocpf->fsm = (void (*)(void * , int  ))(& bfa_iocpf_sm_fwcheck);
  bfa_iocpf_sm_fwcheck_entry(iocpf);
  goto ldv_48634;
  case 3U: ;
  goto ldv_48634;
  default: 
  __bfa_trc(ioc->trcmod, __trc_fileno___2, 700, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_ioc.c",
         700, (unsigned int )event);
  }
  ldv_48634: ;
  return;
}
}
static void bfa_iocpf_sm_fwcheck_entry(struct bfa_iocpf_s *iocpf ) 
{ 
  struct bfi_ioc_image_hdr_s fwhdr ;
  u32 r32 ;
  u32 fwstate ;
  u32 pgnum ;
  u32 pgoff ;
  u32 loff ;
  int i ;
  enum bfi_ioc_state tmp ;
  __u32 tmp___0 ;
  __u32 tmp___1 ;

  {
  loff = 0U;
  r32 = readl((void const volatile   *)(iocpf->ioc)->ioc_regs.ioc_init_sem_reg);
  goto ldv_48648;
  ldv_48647: 
  __const_udelay(85900UL);
  r32 = readl((void const volatile   *)(iocpf->ioc)->ioc_regs.ioc_init_sem_reg);
  ldv_48648: ;
  if ((int )r32 & 1) {
    goto ldv_48647;
  } else {

  }
  tmp = (*(((iocpf->ioc)->ioc_hwif)->ioc_get_fwstate))(iocpf->ioc);
  fwstate = (u32 )tmp;
  if (fwstate == 0U) {
    writel(1U, (void volatile   *)(iocpf->ioc)->ioc_regs.ioc_init_sem_reg);
    goto sem_get;
  } else {

  }
  bfa_ioc_fwver_get(iocpf->ioc, & fwhdr);
  tmp___0 = __fswab32(fwhdr.exec);
  if (tmp___0 == 0U) {
    writel(1U, (void volatile   *)(iocpf->ioc)->ioc_regs.ioc_init_sem_reg);
    goto sem_get;
  } else {

  }
  pgnum = (iocpf->ioc)->ioc_regs.smem_pg0 + (loff >> 15);
  pgoff = loff & 32767U;
  writel(pgnum, (void volatile   *)(iocpf->ioc)->ioc_regs.host_page_num_fn);
  i = 0;
  goto ldv_48652;
  ldv_48651: 
  writel(0U, (void volatile   *)(iocpf->ioc)->ioc_regs.smem_page_start + (unsigned long )loff);
  loff = loff + 4U;
  i = i + 1;
  ldv_48652: ;
  if ((unsigned int )i <= 11U) {
    goto ldv_48651;
  } else {

  }
  __bfa_trc((iocpf->ioc)->trcmod, __trc_fileno___2, 749, (unsigned long long )fwstate);
  tmp___1 = __fswab32(fwhdr.exec);
  __bfa_trc((iocpf->ioc)->trcmod, __trc_fileno___2, 750, (unsigned long long )tmp___1);
  (*(((iocpf->ioc)->ioc_hwif)->ioc_set_fwstate))(iocpf->ioc, 0);
  (*(((iocpf->ioc)->ioc_hwif)->ioc_set_alt_fwstate))(iocpf->ioc, 0);
  (*(((iocpf->ioc)->ioc_hwif)->ioc_ownership_reset))(iocpf->ioc);
  writel(1U, (void volatile   *)(iocpf->ioc)->ioc_regs.ioc_init_sem_reg);
  sem_get: 
  bfa_ioc_hw_sem_get(iocpf->ioc);
  return;
}
}
static void bfa_iocpf_sm_fwcheck(struct bfa_iocpf_s *iocpf , enum iocpf_event event ) 
{ 
  struct bfa_ioc_s *ioc ;
  enum bfa_boolean tmp ;
  enum bfa_boolean tmp___0 ;

  {
  ioc = iocpf->ioc;
  __bfa_trc(ioc->trcmod, __trc_fileno___2, 776, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 10U: 
  tmp___0 = (*((ioc->ioc_hwif)->ioc_firmware_lock))(ioc);
  if ((unsigned int )tmp___0 != 0U) {
    tmp = (*((ioc->ioc_hwif)->ioc_sync_start))(ioc);
    if ((unsigned int )tmp != 0U) {
      (*((ioc->ioc_hwif)->ioc_sync_join))(ioc);
      iocpf->fsm = (void (*)(void * , int  ))(& bfa_iocpf_sm_hwinit);
      bfa_iocpf_sm_hwinit_entry(iocpf);
    } else {
      (*((ioc->ioc_hwif)->ioc_firmware_unlock))(ioc);
      writel(1U, (void volatile   *)ioc->ioc_regs.ioc_sem_reg);
      bfa_timer_begin(ioc->timer_mod, & ioc->sem_timer, & bfa_iocpf_sem_timeout, (void *)ioc,
                      500U);
    }
  } else {
    writel(1U, (void volatile   *)ioc->ioc_regs.ioc_sem_reg);
    iocpf->fsm = (void (*)(void * , int  ))(& bfa_iocpf_sm_mismatch);
    bfa_iocpf_sm_mismatch_entry(iocpf);
  }
  goto ldv_48660;
  case 12U: 
  iocpf->fsm = (void (*)(void * , int  ))(& bfa_iocpf_sm_fail);
  bfa_iocpf_sm_fail_entry(iocpf);
  (*(ioc->fsm))((void *)ioc, 12);
  goto ldv_48660;
  case 2U: 
  bfa_timer_stop(& ioc->sem_timer);
  iocpf->fsm = (void (*)(void * , int  ))(& bfa_iocpf_sm_reset);
  bfa_iocpf_sm_reset_entry(iocpf);
  (*(ioc->fsm))((void *)ioc, 7);
  goto ldv_48660;
  case 3U: 
  bfa_timer_stop(& ioc->sem_timer);
  iocpf->fsm = (void (*)(void * , int  ))(& bfa_iocpf_sm_reset);
  bfa_iocpf_sm_reset_entry(iocpf);
  goto ldv_48660;
  default: 
  __bfa_trc(ioc->trcmod, __trc_fileno___2, 812, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_ioc.c",
         812, (unsigned int )event);
  }
  ldv_48660: ;
  return;
}
}
static void bfa_iocpf_sm_mismatch_entry(struct bfa_iocpf_s *iocpf ) 
{ 


  {
  if ((unsigned int )iocpf->fw_mismatch_notified == 0U) {
    bfa_ioc_pf_fwmismatch(iocpf->ioc);
  } else {

  }
  iocpf->fw_mismatch_notified = 1;
  bfa_timer_begin((iocpf->ioc)->timer_mod, & (iocpf->ioc)->ioc_timer, & bfa_iocpf_timeout,
                  (void *)iocpf->ioc, 3000U);
  return;
}
}
static void bfa_iocpf_sm_mismatch(struct bfa_iocpf_s *iocpf , enum iocpf_event event ) 
{ 
  struct bfa_ioc_s *ioc ;

  {
  ioc = iocpf->ioc;
  __bfa_trc(ioc->trcmod, __trc_fileno___2, 840, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 11U: 
  iocpf->fsm = (void (*)(void * , int  ))(& bfa_iocpf_sm_fwcheck);
  bfa_iocpf_sm_fwcheck_entry(iocpf);
  goto ldv_48674;
  case 2U: 
  bfa_timer_stop(& ioc->ioc_timer);
  iocpf->fsm = (void (*)(void * , int  ))(& bfa_iocpf_sm_reset);
  bfa_iocpf_sm_reset_entry(iocpf);
  (*(ioc->fsm))((void *)ioc, 7);
  goto ldv_48674;
  case 3U: 
  bfa_timer_stop(& ioc->ioc_timer);
  iocpf->fsm = (void (*)(void * , int  ))(& bfa_iocpf_sm_reset);
  bfa_iocpf_sm_reset_entry(iocpf);
  goto ldv_48674;
  default: 
  __bfa_trc(ioc->trcmod, __trc_fileno___2, 859, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_ioc.c",
         859, (unsigned int )event);
  }
  ldv_48674: ;
  return;
}
}
static void bfa_iocpf_sm_semwait_entry(struct bfa_iocpf_s *iocpf ) 
{ 


  {
  bfa_ioc_hw_sem_get(iocpf->ioc);
  return;
}
}
static void bfa_iocpf_sm_semwait(struct bfa_iocpf_s *iocpf , enum iocpf_event event ) 
{ 
  struct bfa_ioc_s *ioc ;
  enum bfa_boolean tmp ;

  {
  ioc = iocpf->ioc;
  __bfa_trc(ioc->trcmod, __trc_fileno___2, 880, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 10U: 
  tmp = (*((ioc->ioc_hwif)->ioc_sync_complete))(ioc);
  if ((unsigned int )tmp != 0U) {
    (*((ioc->ioc_hwif)->ioc_sync_join))(ioc);
    iocpf->fsm = (void (*)(void * , int  ))(& bfa_iocpf_sm_hwinit);
    bfa_iocpf_sm_hwinit_entry(iocpf);
  } else {
    writel(1U, (void volatile   *)ioc->ioc_regs.ioc_sem_reg);
    bfa_timer_begin(ioc->timer_mod, & ioc->sem_timer, & bfa_iocpf_sem_timeout, (void *)ioc,
                    500U);
  }
  goto ldv_48687;
  case 12U: 
  iocpf->fsm = (void (*)(void * , int  ))(& bfa_iocpf_sm_fail);
  bfa_iocpf_sm_fail_entry(iocpf);
  (*(ioc->fsm))((void *)ioc, 12);
  goto ldv_48687;
  case 2U: 
  bfa_timer_stop(& ioc->sem_timer);
  iocpf->fsm = (void (*)(void * , int  ))(& bfa_iocpf_sm_disabling_sync);
  bfa_iocpf_sm_disabling_sync_entry(iocpf);
  goto ldv_48687;
  default: 
  __bfa_trc(ioc->trcmod, __trc_fileno___2, 904, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_ioc.c",
         904, (unsigned int )event);
  }
  ldv_48687: ;
  return;
}
}
static void bfa_iocpf_sm_hwinit_entry(struct bfa_iocpf_s *iocpf ) 
{ 


  {
  iocpf->poll_time = 0U;
  bfa_ioc_hwinit(iocpf->ioc, 0);
  return;
}
}
static void bfa_iocpf_sm_hwinit(struct bfa_iocpf_s *iocpf , enum iocpf_event event ) 
{ 
  struct bfa_ioc_s *ioc ;

  {
  ioc = iocpf->ioc;
  __bfa_trc(ioc->trcmod, __trc_fileno___2, 924, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 4U: 
  iocpf->fsm = (void (*)(void * , int  ))(& bfa_iocpf_sm_enabling);
  bfa_iocpf_sm_enabling_entry(iocpf);
  goto ldv_48700;
  case 11U: 
  writel(1U, (void volatile   *)ioc->ioc_regs.ioc_sem_reg);
  (*(ioc->fsm))((void *)ioc, 8);
  iocpf->fsm = (void (*)(void * , int  ))(& bfa_iocpf_sm_initfail_sync);
  bfa_iocpf_sm_initfail_sync_entry(iocpf);
  goto ldv_48700;
  case 2U: 
  bfa_timer_stop(& ioc->ioc_timer);
  (*((ioc->ioc_hwif)->ioc_sync_leave))(ioc);
  writel(1U, (void volatile   *)ioc->ioc_regs.ioc_sem_reg);
  iocpf->fsm = (void (*)(void * , int  ))(& bfa_iocpf_sm_disabled);
  bfa_iocpf_sm_disabled_entry(iocpf);
  goto ldv_48700;
  default: 
  __bfa_trc(ioc->trcmod, __trc_fileno___2, 945, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_ioc.c",
         945, (unsigned int )event);
  }
  ldv_48700: ;
  return;
}
}
static void bfa_iocpf_sm_enabling_entry(struct bfa_iocpf_s *iocpf ) 
{ 


  {
  bfa_timer_begin((iocpf->ioc)->timer_mod, & (iocpf->ioc)->ioc_timer, & bfa_iocpf_timeout,
                  (void *)iocpf->ioc, 3000U);
  (*(((iocpf->ioc)->cbfn)->reset_cbfn))((void *)(iocpf->ioc)->bfa);
  bfa_ioc_send_enable(iocpf->ioc);
  return;
}
}
static void bfa_iocpf_sm_enabling(struct bfa_iocpf_s *iocpf , enum iocpf_event event ) 
{ 
  struct bfa_ioc_s *ioc ;

  {
  ioc = iocpf->ioc;
  __bfa_trc(ioc->trcmod, __trc_fileno___2, 969, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 5U: 
  bfa_timer_stop(& ioc->ioc_timer);
  writel(1U, (void volatile   *)ioc->ioc_regs.ioc_sem_reg);
  iocpf->fsm = (void (*)(void * , int  ))(& bfa_iocpf_sm_ready);
  bfa_iocpf_sm_ready_entry(iocpf);
  goto ldv_48713;
  case 8U: 
  bfa_timer_stop(& ioc->ioc_timer);
  case 11U: 
  writel(1U, (void volatile   *)ioc->ioc_regs.ioc_sem_reg);
  if ((unsigned int )event == 11U) {
    (*(ioc->fsm))((void *)ioc, 8);
  } else {

  }
  iocpf->fsm = (void (*)(void * , int  ))(& bfa_iocpf_sm_initfail_sync);
  bfa_iocpf_sm_initfail_sync_entry(iocpf);
  goto ldv_48713;
  case 2U: 
  bfa_timer_stop(& ioc->ioc_timer);
  writel(1U, (void volatile   *)ioc->ioc_regs.ioc_sem_reg);
  iocpf->fsm = (void (*)(void * , int  ))(& bfa_iocpf_sm_disabling);
  bfa_iocpf_sm_disabling_entry(iocpf);
  goto ldv_48713;
  default: 
  __bfa_trc(ioc->trcmod, __trc_fileno___2, 998, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_ioc.c",
         998, (unsigned int )event);
  }
  ldv_48713: ;
  return;
}
}
static void bfa_iocpf_sm_ready_entry(struct bfa_iocpf_s *iocpf ) 
{ 


  {
  (*((iocpf->ioc)->fsm))((void *)iocpf->ioc, 5);
  return;
}
}
static void bfa_iocpf_sm_ready(struct bfa_iocpf_s *iocpf , enum iocpf_event event ) 
{ 
  struct bfa_ioc_s *ioc ;

  {
  ioc = iocpf->ioc;
  __bfa_trc(ioc->trcmod, __trc_fileno___2, 1013, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 2U: 
  iocpf->fsm = (void (*)(void * , int  ))(& bfa_iocpf_sm_disabling);
  bfa_iocpf_sm_disabling_entry(iocpf);
  goto ldv_48727;
  case 9U: 
  iocpf->fsm = (void (*)(void * , int  ))(& bfa_iocpf_sm_initfail_sync);
  bfa_iocpf_sm_initfail_sync_entry(iocpf);
  goto ldv_48727;
  case 7U: 
  iocpf->fsm = (void (*)(void * , int  ))(& bfa_iocpf_sm_fail_sync);
  bfa_iocpf_sm_fail_sync_entry(iocpf);
  goto ldv_48727;
  default: 
  __bfa_trc(ioc->trcmod, __trc_fileno___2, 1029, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_ioc.c",
         1029, (unsigned int )event);
  }
  ldv_48727: ;
  return;
}
}
static void bfa_iocpf_sm_disabling_entry(struct bfa_iocpf_s *iocpf ) 
{ 


  {
  bfa_timer_begin((iocpf->ioc)->timer_mod, & (iocpf->ioc)->ioc_timer, & bfa_iocpf_timeout,
                  (void *)iocpf->ioc, 3000U);
  bfa_ioc_send_disable(iocpf->ioc);
  return;
}
}
static void bfa_iocpf_sm_disabling(struct bfa_iocpf_s *iocpf , enum iocpf_event event ) 
{ 
  struct bfa_ioc_s *ioc ;

  {
  ioc = iocpf->ioc;
  __bfa_trc(ioc->trcmod, __trc_fileno___2, 1048, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 6U: 
  bfa_timer_stop(& ioc->ioc_timer);
  iocpf->fsm = (void (*)(void * , int  ))(& bfa_iocpf_sm_disabling_sync);
  bfa_iocpf_sm_disabling_sync_entry(iocpf);
  goto ldv_48740;
  case 7U: 
  bfa_timer_stop(& ioc->ioc_timer);
  case 11U: 
  (*((ioc->ioc_hwif)->ioc_set_fwstate))(ioc, 8);
  iocpf->fsm = (void (*)(void * , int  ))(& bfa_iocpf_sm_disabling_sync);
  bfa_iocpf_sm_disabling_sync_entry(iocpf);
  goto ldv_48740;
  case 5U: ;
  goto ldv_48740;
  default: 
  __bfa_trc(ioc->trcmod, __trc_fileno___2, 1071, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_ioc.c",
         1071, (unsigned int )event);
  }
  ldv_48740: ;
  return;
}
}
static void bfa_iocpf_sm_disabling_sync_entry(struct bfa_iocpf_s *iocpf ) 
{ 


  {
  bfa_ioc_hw_sem_get(iocpf->ioc);
  return;
}
}
static void bfa_iocpf_sm_disabling_sync(struct bfa_iocpf_s *iocpf , enum iocpf_event event ) 
{ 
  struct bfa_ioc_s *ioc ;

  {
  ioc = iocpf->ioc;
  __bfa_trc(ioc->trcmod, __trc_fileno___2, 1089, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 10U: 
  (*((ioc->ioc_hwif)->ioc_sync_leave))(ioc);
  writel(1U, (void volatile   *)ioc->ioc_regs.ioc_sem_reg);
  iocpf->fsm = (void (*)(void * , int  ))(& bfa_iocpf_sm_disabled);
  bfa_iocpf_sm_disabled_entry(iocpf);
  goto ldv_48754;
  case 12U: 
  iocpf->fsm = (void (*)(void * , int  ))(& bfa_iocpf_sm_fail);
  bfa_iocpf_sm_fail_entry(iocpf);
  (*(ioc->fsm))((void *)ioc, 12);
  goto ldv_48754;
  case 7U: ;
  goto ldv_48754;
  default: 
  __bfa_trc(ioc->trcmod, __trc_fileno___2, 1107, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_ioc.c",
         1107, (unsigned int )event);
  }
  ldv_48754: ;
  return;
}
}
static void bfa_iocpf_sm_disabled_entry(struct bfa_iocpf_s *iocpf ) 
{ 


  {
  bfa_ioc_mbox_flush(iocpf->ioc);
  (*((iocpf->ioc)->fsm))((void *)iocpf->ioc, 7);
  return;
}
}
static void bfa_iocpf_sm_disabled(struct bfa_iocpf_s *iocpf , enum iocpf_event event ) 
{ 
  struct bfa_ioc_s *ioc ;

  {
  ioc = iocpf->ioc;
  __bfa_trc(ioc->trcmod, __trc_fileno___2, 1126, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 1U: 
  iocpf->fsm = (void (*)(void * , int  ))(& bfa_iocpf_sm_semwait);
  bfa_iocpf_sm_semwait_entry(iocpf);
  goto ldv_48767;
  case 3U: 
  (*((ioc->ioc_hwif)->ioc_firmware_unlock))(ioc);
  iocpf->fsm = (void (*)(void * , int  ))(& bfa_iocpf_sm_reset);
  bfa_iocpf_sm_reset_entry(iocpf);
  goto ldv_48767;
  default: 
  __bfa_trc(ioc->trcmod, __trc_fileno___2, 1139, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_ioc.c",
         1139, (unsigned int )event);
  }
  ldv_48767: ;
  return;
}
}
static void bfa_iocpf_sm_initfail_sync_entry(struct bfa_iocpf_s *iocpf ) 
{ 


  {
  bfa_ioc_debug_save_ftrc(iocpf->ioc);
  bfa_ioc_hw_sem_get(iocpf->ioc);
  return;
}
}
static void bfa_iocpf_sm_initfail_sync(struct bfa_iocpf_s *iocpf , enum iocpf_event event ) 
{ 
  struct bfa_ioc_s *ioc ;

  {
  ioc = iocpf->ioc;
  __bfa_trc(ioc->trcmod, __trc_fileno___2, 1158, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 10U: 
  (*((ioc->ioc_hwif)->ioc_notify_fail))(ioc);
  (*((ioc->ioc_hwif)->ioc_sync_leave))(ioc);
  (*((ioc->ioc_hwif)->ioc_set_fwstate))(ioc, 8);
  writel(1U, (void volatile   *)ioc->ioc_regs.ioc_sem_reg);
  iocpf->fsm = (void (*)(void * , int  ))(& bfa_iocpf_sm_initfail);
  bfa_iocpf_sm_initfail_entry(iocpf);
  goto ldv_48779;
  case 12U: 
  iocpf->fsm = (void (*)(void * , int  ))(& bfa_iocpf_sm_fail);
  bfa_iocpf_sm_fail_entry(iocpf);
  (*(ioc->fsm))((void *)ioc, 12);
  goto ldv_48779;
  case 2U: 
  bfa_timer_stop(& ioc->sem_timer);
  iocpf->fsm = (void (*)(void * , int  ))(& bfa_iocpf_sm_disabling_sync);
  bfa_iocpf_sm_disabling_sync_entry(iocpf);
  goto ldv_48779;
  case 3U: 
  bfa_timer_stop(& ioc->sem_timer);
  (*((ioc->ioc_hwif)->ioc_firmware_unlock))(ioc);
  iocpf->fsm = (void (*)(void * , int  ))(& bfa_iocpf_sm_reset);
  bfa_iocpf_sm_reset_entry(iocpf);
  goto ldv_48779;
  case 7U: ;
  goto ldv_48779;
  default: 
  __bfa_trc(ioc->trcmod, __trc_fileno___2, 1189, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_ioc.c",
         1189, (unsigned int )event);
  }
  ldv_48779: ;
  return;
}
}
static void bfa_iocpf_sm_initfail_entry(struct bfa_iocpf_s *iocpf ) 
{ 


  {
  __bfa_trc((iocpf->ioc)->trcmod, __trc_fileno___2, 1196, 0ULL);
  return;
}
}
static void bfa_iocpf_sm_initfail(struct bfa_iocpf_s *iocpf , enum iocpf_event event ) 
{ 
  struct bfa_ioc_s *ioc ;

  {
  ioc = iocpf->ioc;
  __bfa_trc(ioc->trcmod, __trc_fileno___2, 1207, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 2U: 
  iocpf->fsm = (void (*)(void * , int  ))(& bfa_iocpf_sm_disabled);
  bfa_iocpf_sm_disabled_entry(iocpf);
  goto ldv_48794;
  case 3U: 
  (*((ioc->ioc_hwif)->ioc_firmware_unlock))(ioc);
  iocpf->fsm = (void (*)(void * , int  ))(& bfa_iocpf_sm_reset);
  bfa_iocpf_sm_reset_entry(iocpf);
  goto ldv_48794;
  default: 
  __bfa_trc(ioc->trcmod, __trc_fileno___2, 1220, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_ioc.c",
         1220, (unsigned int )event);
  }
  ldv_48794: ;
  return;
}
}
static void bfa_iocpf_sm_fail_sync_entry(struct bfa_iocpf_s *iocpf ) 
{ 


  {
  bfa_ioc_lpu_stop(iocpf->ioc);
  bfa_ioc_mbox_flush(iocpf->ioc);
  bfa_ioc_hw_sem_get(iocpf->ioc);
  return;
}
}
static void bfa_iocpf_sm_fail_sync(struct bfa_iocpf_s *iocpf , enum iocpf_event event ) 
{ 
  struct bfa_ioc_s *ioc ;
  enum bfa_boolean tmp ;

  {
  ioc = iocpf->ioc;
  __bfa_trc(ioc->trcmod, __trc_fileno___2, 1245, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 10U: 
  (*((ioc->ioc_hwif)->ioc_sync_ack))(ioc);
  (*((ioc->ioc_hwif)->ioc_notify_fail))(ioc);
  if ((unsigned int )iocpf->auto_recover == 0U) {
    (*((ioc->ioc_hwif)->ioc_sync_leave))(ioc);
    (*((ioc->ioc_hwif)->ioc_set_fwstate))(ioc, 8);
    writel(1U, (void volatile   *)ioc->ioc_regs.ioc_sem_reg);
    iocpf->fsm = (void (*)(void * , int  ))(& bfa_iocpf_sm_fail);
    bfa_iocpf_sm_fail_entry(iocpf);
  } else {
    tmp = (*((ioc->ioc_hwif)->ioc_sync_complete))(ioc);
    if ((unsigned int )tmp != 0U) {
      iocpf->fsm = (void (*)(void * , int  ))(& bfa_iocpf_sm_hwinit);
      bfa_iocpf_sm_hwinit_entry(iocpf);
    } else {
      writel(1U, (void volatile   *)ioc->ioc_regs.ioc_sem_reg);
      iocpf->fsm = (void (*)(void * , int  ))(& bfa_iocpf_sm_semwait);
      bfa_iocpf_sm_semwait_entry(iocpf);
    }
  }
  goto ldv_48806;
  case 12U: 
  iocpf->fsm = (void (*)(void * , int  ))(& bfa_iocpf_sm_fail);
  bfa_iocpf_sm_fail_entry(iocpf);
  (*(ioc->fsm))((void *)ioc, 12);
  goto ldv_48806;
  case 2U: 
  bfa_timer_stop(& ioc->sem_timer);
  iocpf->fsm = (void (*)(void * , int  ))(& bfa_iocpf_sm_disabling_sync);
  bfa_iocpf_sm_disabling_sync_entry(iocpf);
  goto ldv_48806;
  case 7U: ;
  goto ldv_48806;
  default: 
  __bfa_trc(ioc->trcmod, __trc_fileno___2, 1280, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_ioc.c",
         1280, (unsigned int )event);
  }
  ldv_48806: ;
  return;
}
}
static void bfa_iocpf_sm_fail_entry(struct bfa_iocpf_s *iocpf ) 
{ 


  {
  __bfa_trc((iocpf->ioc)->trcmod, __trc_fileno___2, 1287, 0ULL);
  return;
}
}
static void bfa_iocpf_sm_fail(struct bfa_iocpf_s *iocpf , enum iocpf_event event ) 
{ 
  struct bfa_ioc_s *ioc ;

  {
  ioc = iocpf->ioc;
  __bfa_trc(ioc->trcmod, __trc_fileno___2, 1298, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 2U: 
  iocpf->fsm = (void (*)(void * , int  ))(& bfa_iocpf_sm_disabled);
  bfa_iocpf_sm_disabled_entry(iocpf);
  goto ldv_48820;
  default: 
  __bfa_trc(ioc->trcmod, __trc_fileno___2, 1306, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_ioc.c",
         1306, (unsigned int )event);
  }
  ldv_48820: ;
  return;
}
}
static void bfa_ioc_event_notify(struct bfa_ioc_s *ioc , enum bfa_ioc_event_e event ) 
{ 
  struct bfa_ioc_notify_s *notify ;
  struct list_head *qe ;

  {
  qe = ioc->notify_q.next;
  goto ldv_48829;
  ldv_48828: 
  notify = (struct bfa_ioc_notify_s *)qe;
  (*(notify->cbfn))(notify->cbarg, event);
  qe = qe->next;
  ldv_48829: ;
  if ((unsigned long )(& ioc->notify_q) != (unsigned long )qe) {
    goto ldv_48828;
  } else {

  }

  return;
}
}
static void bfa_ioc_disable_comp(struct bfa_ioc_s *ioc ) 
{ 


  {
  (*((ioc->cbfn)->disable_cbfn))((void *)ioc->bfa);
  bfa_ioc_event_notify(ioc, 2);
  return;
}
}
enum bfa_boolean bfa_ioc_sem_get(void *sem_reg ) 
{ 
  u32 r32 ;
  int cnt ;
    klee_make_symbolic(&cnt, sizeof(int), "cnt");

  {
  cnt = 0;
  r32 = readl((void const volatile   *)sem_reg);
  goto ldv_48840;
  ldv_48839: 
  cnt = cnt + 1;
  __const_udelay(8590UL);
  r32 = readl((void const volatile   *)sem_reg);
  ldv_48840: ;
  if ((int )r32 & 1 && cnt <= 2999) {
    goto ldv_48839;
  } else {

  }

  if ((r32 & 1U) == 0U) {
    return (1);
  } else {

  }
  return (0);
}
}
static void bfa_ioc_hw_sem_get(struct bfa_ioc_s *ioc ) 
{ 
  u32 r32 ;
  int __ret_warn_on ;
  long tmp ;

  {
  r32 = readl((void const volatile   *)ioc->ioc_regs.ioc_sem_reg);
  if (r32 == 4294967295U) {
    __ret_warn_on = r32 == 4294967295U;
    tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
    if (tmp != 0L) {
      warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_ioc.c",
                         1368);
    } else {

    }
    ldv__builtin_expect(__ret_warn_on != 0, 0L);
    (*(ioc->iocpf.fsm))((void *)(& ioc->iocpf), 12);
    return;
  } else {

  }
  if ((r32 & 1U) == 0U) {
    (*(ioc->iocpf.fsm))((void *)(& ioc->iocpf), 10);
    return;
  } else {

  }
  bfa_timer_begin(ioc->timer_mod, & ioc->sem_timer, & bfa_iocpf_sem_timeout, (void *)ioc,
                  500U);
  return;
}
}
static void bfa_ioc_lmem_init(struct bfa_ioc_s *ioc ) 
{ 
  u32 pss_ctl ;
  int i ;
  int __ret_warn_on ;
  long tmp ;

  {
  pss_ctl = readl((void const volatile   *)ioc->ioc_regs.pss_ctl_reg);
  pss_ctl = pss_ctl & 4294966783U;
  pss_ctl = pss_ctl | 256U;
  pss_ctl = pss_ctl | 196608U;
  writel(pss_ctl, (void volatile   *)ioc->ioc_regs.pss_ctl_reg);
  i = 0;
  ldv_48853: 
  pss_ctl = readl((void const volatile   *)ioc->ioc_regs.pss_ctl_reg);
  i = i + 1;
  if ((pss_ctl & 4096U) == 0U && i <= 9999) {
    goto ldv_48853;
  } else {

  }
  __ret_warn_on = (pss_ctl & 4096U) == 0U;
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_ioc.c",
                       1413);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  __bfa_trc(ioc->trcmod, __trc_fileno___2, 1414, (unsigned long long )pss_ctl);
  pss_ctl = pss_ctl & 4294962943U;
  writel(pss_ctl, (void volatile   *)ioc->ioc_regs.pss_ctl_reg);
  return;
}
}
static void bfa_ioc_lpu_start(struct bfa_ioc_s *ioc ) 
{ 
  u32 pss_ctl ;

  {
  pss_ctl = readl((void const volatile   *)ioc->ioc_regs.pss_ctl_reg);
  pss_ctl = pss_ctl & 4294967294U;
  writel(pss_ctl, (void volatile   *)ioc->ioc_regs.pss_ctl_reg);
  return;
}
}
static void bfa_ioc_lpu_stop(struct bfa_ioc_s *ioc ) 
{ 
  u32 pss_ctl ;

  {
  pss_ctl = readl((void const volatile   *)ioc->ioc_regs.pss_ctl_reg);
  pss_ctl = pss_ctl | 3U;
  writel(pss_ctl, (void volatile   *)ioc->ioc_regs.pss_ctl_reg);
  return;
}
}
void bfa_ioc_fwver_get(struct bfa_ioc_s *ioc , struct bfi_ioc_image_hdr_s *fwhdr ) 
{ 
  u32 pgnum ;
  u32 pgoff ;
  u32 loff ;
  int i ;
  u32 *fwsig ;
  unsigned int tmp ;
  __u32 tmp___0 ;

  {
  loff = 0U;
  fwsig = (u32 *)fwhdr;
  pgnum = ioc->ioc_regs.smem_pg0 + (loff >> 15);
  pgoff = loff & 32767U;
  writel(pgnum, (void volatile   *)ioc->ioc_regs.host_page_num_fn);
  i = 0;
  goto ldv_48875;
  ldv_48874: 
  tmp = readl((void const volatile   *)ioc->ioc_regs.smem_page_start + (unsigned long )loff);
  tmp___0 = __fswab32(tmp);
  *(fwsig + (unsigned long )i) = tmp___0;
  loff = loff + 4U;
  i = i + 1;
  ldv_48875: ;
  if ((unsigned int )i <= 11U) {
    goto ldv_48874;
  } else {

  }

  return;
}
}
enum bfa_boolean bfa_ioc_fwver_cmp(struct bfa_ioc_s *ioc , struct bfi_ioc_image_hdr_s *smem_fwhdr ) 
{ 
  struct bfi_ioc_image_hdr_s *drv_fwhdr ;
  enum bfi_ioc_img_ver_cmp_e smem_flash_cmp ;
  enum bfi_ioc_img_ver_cmp_e drv_smem_cmp ;
  u32 *tmp ;

  {
  tmp = bfa_cb_image_get_chunk(ioc->asic_gen, 0U);
  drv_fwhdr = (struct bfi_ioc_image_hdr_s *)tmp;
  drv_smem_cmp = bfa_ioc_fw_ver_patch_cmp(drv_fwhdr, smem_fwhdr);
  if ((unsigned int )drv_smem_cmp == 0U || (unsigned int )drv_smem_cmp == 1U) {
    return (0);
  } else {

  }
  smem_flash_cmp = bfa_ioc_flash_fwver_cmp(ioc, smem_fwhdr);
  if ((unsigned int )smem_flash_cmp == 3U) {
    return (0);
  } else
  if ((unsigned int )smem_flash_cmp == 2U) {
    return (1);
  } else {
    return ((unsigned int )drv_smem_cmp == 2U);
  }
}
}
static enum bfa_boolean bfa_ioc_fwver_valid(struct bfa_ioc_s *ioc , u32 boot_env ) 
{ 
  struct bfi_ioc_image_hdr_s fwhdr ;
  __u32 tmp ;
  enum bfa_boolean tmp___0 ;

  {
  bfa_ioc_fwver_get(ioc, & fwhdr);
  tmp = __fswab32(fwhdr.bootenv);
  if (tmp != boot_env) {
    __bfa_trc(ioc->trcmod, __trc_fileno___2, 1522, (unsigned long long )fwhdr.bootenv);
    __bfa_trc(ioc->trcmod, __trc_fileno___2, 1523, (unsigned long long )boot_env);
    return (0);
  } else {

  }
  tmp___0 = bfa_ioc_fwver_cmp(ioc, & fwhdr);
  return (tmp___0);
}
}
static enum bfa_boolean bfa_ioc_fwver_md5_check(struct bfi_ioc_image_hdr_s *fwhdr_1 ,
                                                struct bfi_ioc_image_hdr_s *fwhdr_2 ) 
{ 
  int i ;

  {
  i = 0;
  goto ldv_48895;
  ldv_48894: ;
  if (fwhdr_1->md5sum[i] != fwhdr_2->md5sum[i]) {
    return (0);
  } else {

  }
  i = i + 1;
  ldv_48895: ;
  if (i <= 3) {
    goto ldv_48894;
  } else {

  }

  return (1);
}
}
static enum bfa_boolean bfa_ioc_fw_ver_compatible(struct bfi_ioc_image_hdr_s *drv_fwhdr ,
                                                  struct bfi_ioc_image_hdr_s *fwhdr_to_cmp ) 
{ 
  enum bfa_boolean tmp ;

  {
  if (drv_fwhdr->signature != fwhdr_to_cmp->signature) {
    return (0);
  } else {

  }
  if ((int )drv_fwhdr->fwver.major != (int )fwhdr_to_cmp->fwver.major) {
    return (0);
  } else {

  }
  if ((int )drv_fwhdr->fwver.minor != (int )fwhdr_to_cmp->fwver.minor) {
    return (0);
  } else {

  }
  if ((int )drv_fwhdr->fwver.maint != (int )fwhdr_to_cmp->fwver.maint) {
    return (0);
  } else {

  }
  if (((int )drv_fwhdr->fwver.patch == (int )fwhdr_to_cmp->fwver.patch && (int )drv_fwhdr->fwver.phase == (int )fwhdr_to_cmp->fwver.phase) && (int )drv_fwhdr->fwver.build == (int )fwhdr_to_cmp->fwver.build) {
    tmp = bfa_ioc_fwver_md5_check(drv_fwhdr, fwhdr_to_cmp);
    return (tmp);
  } else {

  }
  return (1);
}
}
static enum bfa_boolean bfa_ioc_flash_fwver_valid(struct bfi_ioc_image_hdr_s *flash_fwhdr ) 
{ 


  {
  if ((unsigned int )flash_fwhdr->fwver.major == 0U || (unsigned int )flash_fwhdr->fwver.major == 255U) {
    return (0);
  } else {

  }
  return (1);
}
}
static enum bfa_boolean fwhdr_is_ga(struct bfi_ioc_image_hdr_s *fwhdr ) 
{ 


  {
  if ((unsigned int )fwhdr->fwver.phase == 0U && (unsigned int )fwhdr->fwver.build == 0U) {
    return (1);
  } else {

  }
  return (0);
}
}
static enum bfi_ioc_img_ver_cmp_e bfa_ioc_fw_ver_patch_cmp(struct bfi_ioc_image_hdr_s *base_fwhdr ,
                                                           struct bfi_ioc_image_hdr_s *fwhdr_to_cmp ) 
{ 
  enum bfa_boolean tmp ;
  enum bfa_boolean tmp___0 ;
  enum bfa_boolean tmp___1 ;
  enum bfa_boolean tmp___2 ;

  {
  tmp = bfa_ioc_fw_ver_compatible(base_fwhdr, fwhdr_to_cmp);
  if ((unsigned int )tmp == 0U) {
    return (0);
  } else {

  }
  if ((int )fwhdr_to_cmp->fwver.patch > (int )base_fwhdr->fwver.patch) {
    return (3);
  } else
  if ((int )fwhdr_to_cmp->fwver.patch < (int )base_fwhdr->fwver.patch) {
    return (1);
  } else {

  }
  tmp___2 = fwhdr_is_ga(base_fwhdr);
  if ((unsigned int )tmp___2 == 1U) {
    tmp___0 = fwhdr_is_ga(fwhdr_to_cmp);
    if ((unsigned int )tmp___0 != 0U) {
      return (2);
    } else {
      return (1);
    }
  } else {
    tmp___1 = fwhdr_is_ga(fwhdr_to_cmp);
    if ((unsigned int )tmp___1 != 0U) {
      return (3);
    } else {

    }
  }
  if ((int )fwhdr_to_cmp->fwver.phase > (int )base_fwhdr->fwver.phase) {
    return (3);
  } else
  if ((int )fwhdr_to_cmp->fwver.phase < (int )base_fwhdr->fwver.phase) {
    return (1);
  } else {

  }
  if ((int )fwhdr_to_cmp->fwver.build > (int )base_fwhdr->fwver.build) {
    return (3);
  } else
  if ((int )fwhdr_to_cmp->fwver.build < (int )base_fwhdr->fwver.build) {
    return (1);
  } else {

  }
  return (2);
}
}
enum bfa_status bfa_ioc_flash_img_get_chnk(struct bfa_ioc_s *ioc , u32 off , u32 *fwimg ) 
{ 
  enum bfa_status tmp ;

  {
  tmp = bfa_flash_raw_read(ioc->pcidev.pci_bar_kva, (u32 )((unsigned long )off + 262144UL) * 4U,
                           (char *)fwimg, 256U);
  return (tmp);
}
}
static enum bfi_ioc_img_ver_cmp_e bfa_ioc_flash_fwver_cmp(struct bfa_ioc_s *ioc ,
                                                          struct bfi_ioc_image_hdr_s *base_fwhdr ) 
{ 
  struct bfi_ioc_image_hdr_s *flash_fwhdr ;
  enum bfa_status status ;
  u32 fwimg[64U] ;
  enum bfi_ioc_img_ver_cmp_e tmp ;
  enum bfa_boolean tmp___0 ;

  {
  status = bfa_ioc_flash_img_get_chnk(ioc, 0U, (u32 *)(& fwimg));
  if ((unsigned int )status != 0U) {
    return (0);
  } else {

  }
  flash_fwhdr = (struct bfi_ioc_image_hdr_s *)(& fwimg);
  tmp___0 = bfa_ioc_flash_fwver_valid(flash_fwhdr);
  if ((unsigned int )tmp___0 == 1U) {
    tmp = bfa_ioc_fw_ver_patch_cmp(base_fwhdr, flash_fwhdr);
    return (tmp);
  } else {
    return (0);
  }
}
}
enum bfa_status bfa_ioc_fwsig_invalidate(struct bfa_ioc_s *ioc ) 
{ 
  u32 pgnum ;
  u32 pgoff ;
  u32 loff ;
  enum bfi_ioc_state ioc_fwstate ;

  {
  loff = 0U;
  ioc_fwstate = (*((ioc->ioc_hwif)->ioc_get_fwstate))(ioc);
  if ((((((unsigned int )ioc_fwstate != 0U && (unsigned int )ioc_fwstate != 1U) && (unsigned int )ioc_fwstate != 2U) && (unsigned int )ioc_fwstate != 6U) && (unsigned int )ioc_fwstate != 8U) && (unsigned int )ioc_fwstate != 7U) {
    return (60);
  } else {

  }
  pgnum = ioc->ioc_regs.smem_pg0 + (loff >> 15);
  pgoff = loff & 32767U;
  writel(pgnum, (void volatile   *)ioc->ioc_regs.host_page_num_fn);
  writel(2917051870U, (void volatile   *)ioc->ioc_regs.smem_page_start + (unsigned long )loff);
  return (0);
}
}
static void bfa_ioc_msgflush(struct bfa_ioc_s *ioc ) 
{ 
  u32 r32 ;

  {
  r32 = readl((void const volatile   *)ioc->ioc_regs.lpu_mbox_cmd);
  if (r32 != 0U) {
    writel(1U, (void volatile   *)ioc->ioc_regs.lpu_mbox_cmd);
  } else {

  }
  return;
}
}
static void bfa_ioc_hwinit(struct bfa_ioc_s *ioc , enum bfa_boolean force ) 
{ 
  enum bfi_ioc_state ioc_fwstate ;
  enum bfa_boolean fwvalid ;
  u32 boot_type ;
  u32 boot_env ;
  enum bfa_boolean tmp ;
  enum bfa_status tmp___0 ;
  enum bfa_status tmp___1 ;

  {
  ioc_fwstate = (*((ioc->ioc_hwif)->ioc_get_fwstate))(ioc);
  if ((unsigned int )force != 0U) {
    ioc_fwstate = 0;
  } else {

  }
  __bfa_trc(ioc->trcmod, __trc_fileno___2, 1718, (unsigned long long )ioc_fwstate);
  boot_type = 0U;
  boot_env = 0U;
  if ((unsigned int )ioc_fwstate != 0U) {
    tmp = bfa_ioc_fwver_valid(ioc, boot_env);
    fwvalid = tmp;
  } else {
    fwvalid = 0;
  }
  if ((unsigned int )fwvalid == 0U) {
    tmp___0 = bfa_ioc_boot(ioc, boot_type, boot_env);
    if ((unsigned int )tmp___0 == 0U) {
      bfa_ioc_poll_fwinit(ioc);
    } else {

    }
    return;
  } else {

  }
  if ((unsigned int )ioc_fwstate == 1U) {
    bfa_ioc_poll_fwinit(ioc);
    return;
  } else {

  }
  if ((unsigned int )ioc_fwstate == 6U || (unsigned int )ioc_fwstate == 4U) {
    bfa_ioc_msgflush(ioc);
    (*(ioc->iocpf.fsm))((void *)(& ioc->iocpf), 4);
    return;
  } else {

  }
  tmp___1 = bfa_ioc_boot(ioc, boot_type, boot_env);
  if ((unsigned int )tmp___1 == 0U) {
    bfa_ioc_poll_fwinit(ioc);
  } else {

  }
  return;
}
}
static void bfa_ioc_timeout(void *ioc_arg ) 
{ 
  struct bfa_ioc_s *ioc ;

  {
  ioc = (struct bfa_ioc_s *)ioc_arg;
  __bfa_trc(ioc->trcmod, __trc_fileno___2, 1775, 0ULL);
  (*(ioc->fsm))((void *)ioc, 11);
  return;
}
}
void bfa_ioc_mbox_send(struct bfa_ioc_s *ioc , void *ioc_msg , int len ) 
{ 
  u32 *msgp ;
  u32 i ;
  int __ret_warn_on ;
  long tmp ;

  {
  msgp = (u32 *)ioc_msg;
  __bfa_trc(ioc->trcmod, __trc_fileno___2, 1785, (unsigned long long )*msgp);
  __bfa_trc(ioc->trcmod, __trc_fileno___2, 1786, (unsigned long long )len);
  __ret_warn_on = len > 32;
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_ioc.c",
                       1788);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  i = 0U;
  goto ldv_48956;
  ldv_48955: 
  writel(*(msgp + (unsigned long )i), (void volatile   *)(ioc->ioc_regs.hfn_mbox + (unsigned long )i * 4UL));
  i = i + 1U;
  ldv_48956: ;
  if ((unsigned long )i < (unsigned long )len / 4UL) {
    goto ldv_48955;
  } else {

  }

  goto ldv_48959;
  ldv_48958: 
  writel(0U, (void volatile   *)(ioc->ioc_regs.hfn_mbox + (unsigned long )i * 4UL));
  i = i + 1U;
  ldv_48959: ;
  if (i <= 7U) {
    goto ldv_48958;
  } else {

  }
  writel(1U, (void volatile   *)ioc->ioc_regs.hfn_mbox_cmd);
  readl((void const volatile   *)ioc->ioc_regs.hfn_mbox_cmd);
  return;
}
}
static void bfa_ioc_send_enable(struct bfa_ioc_s *ioc ) 
{ 
  struct bfi_ioc_ctrl_req_s enable_req ;
  struct timeval tv ;
  __u16 tmp ;
  __u32 tmp___0 ;

  {
  enable_req.mh.msg_class = 1U;
  enable_req.mh.msg_id = 1U;
  enable_req.mh.mtag.h2i.fn_lpu = ioc->port_id;
  tmp = __fswab16((int )((__u16 )ioc->clscode));
  enable_req.clscode = tmp;
  do_gettimeofday(& tv);
  tmp___0 = __fswab32((unsigned int )tv.tv_sec);
  enable_req.tv_sec = tmp___0;
  bfa_ioc_mbox_send(ioc, (void *)(& enable_req), 12);
  return;
}
}
static void bfa_ioc_send_disable(struct bfa_ioc_s *ioc ) 
{ 
  struct bfi_ioc_ctrl_req_s disable_req ;

  {
  disable_req.mh.msg_class = 1U;
  disable_req.mh.msg_id = 2U;
  disable_req.mh.mtag.h2i.fn_lpu = ioc->port_id;
  bfa_ioc_mbox_send(ioc, (void *)(& disable_req), 12);
  return;
}
}
static void bfa_ioc_send_getattr(struct bfa_ioc_s *ioc ) 
{ 
  struct bfi_ioc_getattr_req_s attr_req ;

  {
  attr_req.mh.msg_class = 1U;
  attr_req.mh.msg_id = 3U;
  attr_req.mh.mtag.h2i.fn_lpu = ioc->port_id;
  __bfa_dma_be_addr_set(& attr_req.attr_addr, ioc->attr_dma.pa);
  bfa_ioc_mbox_send(ioc, (void *)(& attr_req), 12);
  return;
}
}
static void bfa_ioc_hb_check(void *cbarg ) 
{ 
  struct bfa_ioc_s *ioc ;
  u32 hb_count ;

  {
  ioc = (struct bfa_ioc_s *)cbarg;
  hb_count = readl((void const volatile   *)ioc->ioc_regs.heartbeat);
  if (ioc->hb_count == hb_count) {
    bfa_ioc_recover(ioc);
    return;
  } else {
    ioc->hb_count = hb_count;
  }
  bfa_ioc_mbox_poll(ioc);
  bfa_timer_begin(ioc->timer_mod, & ioc->hb_timer, & bfa_ioc_hb_check, (void *)ioc,
                  500U);
  return;
}
}
static void bfa_ioc_hb_monitor(struct bfa_ioc_s *ioc ) 
{ 


  {
  ioc->hb_count = readl((void const volatile   *)ioc->ioc_regs.heartbeat);
  bfa_timer_begin(ioc->timer_mod, & ioc->hb_timer, & bfa_ioc_hb_check, (void *)ioc,
                  500U);
  return;
}
}
static enum bfa_status bfa_ioc_download_fw(struct bfa_ioc_s *ioc , u32 boot_type ,
                                           u32 boot_env ) 
{ 
  u32 *fwimg ;
  u32 pgnum ;
  u32 pgoff ;
  u32 loff ;
  u32 chunkno ;
  u32 i ;
  u32 asicmode ;
  u32 fwimg_size ;
  u32 fwimg_buf[64U] ;
  enum bfa_status status ;
  __u32 tmp ;
  __u32 tmp___0 ;
  __u32 tmp___1 ;
  __u32 tmp___2 ;
  __u32 tmp___3 ;
  __u32 tmp___4 ;
  __u32 tmp___5 ;

  {
  loff = 0U;
  chunkno = 0U;
  if (boot_env == 0U && boot_type == 1U) {
    fwimg_size = 262144U;
    status = bfa_ioc_flash_img_get_chnk(ioc, chunkno * 64U, (u32 *)(& fwimg_buf));
    if ((unsigned int )status != 0U) {
      return (status);
    } else {

    }
    fwimg = (u32 *)(& fwimg_buf);
  } else {
    fwimg_size = bfa_cb_image_get_size(ioc->asic_gen);
    fwimg = bfa_cb_image_get_chunk(ioc->asic_gen, chunkno * 64U);
  }
  __bfa_trc(ioc->trcmod, __trc_fileno___2, 1900, (unsigned long long )fwimg_size);
  pgnum = ioc->ioc_regs.smem_pg0 + (loff >> 15);
  pgoff = loff & 32767U;
  writel(pgnum, (void volatile   *)ioc->ioc_regs.host_page_num_fn);
  i = 0U;
  goto ldv_48998;
  ldv_48997: ;
  if (i / 64U != chunkno) {
    chunkno = i / 64U;
    if (boot_env == 0U && boot_type == 1U) {
      status = bfa_ioc_flash_img_get_chnk(ioc, chunkno * 64U, (u32 *)(& fwimg_buf));
      if ((unsigned int )status != 0U) {
        return (status);
      } else {

      }
      fwimg = (u32 *)(& fwimg_buf);
    } else {
      fwimg = bfa_cb_image_get_chunk(ioc->asic_gen, chunkno * 64U);
    }
  } else {

  }
  tmp = __fswab32(*(fwimg + ((unsigned long )i & 63UL)));
  writel(tmp, (void volatile   *)ioc->ioc_regs.smem_page_start + (unsigned long )loff);
  loff = loff + 4U;
  loff = loff & 32767U;
  if (loff == 0U) {
    pgnum = pgnum + 1U;
    writel(pgnum, (void volatile   *)ioc->ioc_regs.host_page_num_fn);
  } else {

  }
  i = i + 1U;
  ldv_48998: ;
  if (i < fwimg_size) {
    goto ldv_48997;
  } else {

  }
  writel(ioc->ioc_regs.smem_pg0, (void volatile   *)ioc->ioc_regs.host_page_num_fn);
  if (boot_env == 0U && boot_type == 1U) {
    boot_type = 0U;
  } else {

  }
  asicmode = ((((unsigned int )ioc->asic_gen << 24) | ((unsigned int )ioc->asic_mode << 16)) | ((unsigned int )ioc->port0_mode << 8)) | (unsigned int )ioc->port1_mode;
  tmp___0 = __fswab32(asicmode);
  tmp___1 = __fswab32(tmp___0);
  writel(tmp___1, (void volatile   *)ioc->ioc_regs.smem_page_start + 4U);
  tmp___2 = __fswab32(boot_type);
  tmp___3 = __fswab32(tmp___2);
  writel(tmp___3, (void volatile   *)ioc->ioc_regs.smem_page_start + 8U);
  tmp___4 = __fswab32(boot_env);
  tmp___5 = __fswab32(tmp___4);
  writel(tmp___5, (void volatile   *)ioc->ioc_regs.smem_page_start + 12U);
  return (0);
}
}
static void bfa_ioc_getattr_reply(struct bfa_ioc_s *ioc ) 
{ 
  struct bfi_ioc_attr_s *attr ;
  __u32 tmp ;
  __u32 tmp___0 ;
  __u16 tmp___1 ;
  __u16 tmp___2 ;

  {
  attr = ioc->attr;
  tmp = __fswab32(attr->adapter_prop);
  attr->adapter_prop = tmp;
  tmp___0 = __fswab32(attr->card_type);
  attr->card_type = tmp___0;
  tmp___1 = __fswab16((int )attr->maxfrsize);
  attr->maxfrsize = tmp___1;
  ioc->fcmode = (unsigned int )attr->port_mode == 1U;
  tmp___2 = __fswab16((int )attr->mfg_year);
  attr->mfg_year = tmp___2;
  (*(ioc->fsm))((void *)ioc, 6);
  return;
}
}
static void bfa_ioc_mbox_attach(struct bfa_ioc_s *ioc ) 
{ 
  struct bfa_ioc_mbox_mod_s *mod ;
  int mc ;
    klee_make_symbolic(&mc, sizeof(int), "mc");

  {
  mod = & ioc->mbox_mod;
  INIT_LIST_HEAD(& mod->cmd_q);
  mc = 0;
  goto ldv_49010;
  ldv_49009: 
  mod->mbhdlr[mc].cbfn = (void (*)(void * , struct bfi_mbmsg_s * ))0;
  mod->mbhdlr[mc].cbarg = (void *)ioc->bfa;
  mc = mc + 1;
  ldv_49010: ;
  if (mc <= 34) {
    goto ldv_49009;
  } else {

  }

  return;
}
}
static void bfa_ioc_mbox_poll(struct bfa_ioc_s *ioc ) 
{ 
  struct bfa_ioc_mbox_mod_s *mod ;
  struct bfa_mbox_cmd_s *cmd ;
  u32 stat ;
  int tmp ;
  int tmp___0 ;

  {
  mod = & ioc->mbox_mod;
  tmp = list_empty((struct list_head  const  *)(& mod->cmd_q));
  if (tmp != 0) {
    return;
  } else {

  }
  stat = readl((void const volatile   *)ioc->ioc_regs.hfn_mbox_cmd);
  if (stat != 0U) {
    return;
  } else {

  }
  tmp___0 = list_empty((struct list_head  const  *)(& mod->cmd_q));
  if (tmp___0 == 0) {
    *((struct list_head **)(& cmd)) = mod->cmd_q.next;
    ((*((struct list_head **)(& cmd)))->next)->prev = & mod->cmd_q;
    mod->cmd_q.next = (*((struct list_head **)(& cmd)))->next;
  } else {
    *((struct list_head **)(& cmd)) = (struct list_head *)0;
  }
  bfa_ioc_mbox_send(ioc, (void *)(& cmd->msg), 32);
  return;
}
}
static void bfa_ioc_mbox_flush(struct bfa_ioc_s *ioc ) 
{ 
  struct bfa_ioc_mbox_mod_s *mod ;
  struct bfa_mbox_cmd_s *cmd ;
  int tmp ;
  int tmp___0 ;

  {
  mod = & ioc->mbox_mod;
  goto ldv_49024;
  ldv_49023: 
  tmp = list_empty((struct list_head  const  *)(& mod->cmd_q));
  if (tmp == 0) {
    *((struct list_head **)(& cmd)) = mod->cmd_q.next;
    ((*((struct list_head **)(& cmd)))->next)->prev = & mod->cmd_q;
    mod->cmd_q.next = (*((struct list_head **)(& cmd)))->next;
  } else {
    *((struct list_head **)(& cmd)) = (struct list_head *)0;
  }
  ldv_49024: 
  tmp___0 = list_empty((struct list_head  const  *)(& mod->cmd_q));
  if (tmp___0 == 0) {
    goto ldv_49023;
  } else {

  }

  return;
}
}
static enum bfa_status bfa_ioc_smem_read(struct bfa_ioc_s *ioc , void *tbuf , u32 soff ,
                                         u32 sz ) 
{ 
  u32 pgnum ;
  u32 loff ;
  __be32 r32 ;
  int i ;
  int len ;
  u32 *buf ;
  enum bfa_boolean tmp ;
  unsigned int tmp___0 ;
  __u32 tmp___1 ;
  __u32 tmp___2 ;

  {
  buf = (u32 *)tbuf;
  pgnum = ioc->ioc_regs.smem_pg0 + (soff >> 15);
  loff = soff & 32767U;
  __bfa_trc(ioc->trcmod, __trc_fileno___2, 2063, (unsigned long long )pgnum);
  __bfa_trc(ioc->trcmod, __trc_fileno___2, 2064, (unsigned long long )loff);
  __bfa_trc(ioc->trcmod, __trc_fileno___2, 2065, (unsigned long long )sz);
  tmp = bfa_ioc_sem_get(ioc->ioc_regs.ioc_init_sem_reg);
  if ((unsigned int )tmp == 0U) {
    __bfa_trc(ioc->trcmod, __trc_fileno___2, 2071, 0ULL);
    return (1);
  } else {

  }
  writel(pgnum, (void volatile   *)ioc->ioc_regs.host_page_num_fn);
  len = (int )(sz / 4U);
  __bfa_trc(ioc->trcmod, __trc_fileno___2, 2078, (unsigned long long )len);
  i = 0;
  goto ldv_49039;
  ldv_49038: 
  tmp___0 = readl((void const volatile   *)ioc->ioc_regs.smem_page_start + (unsigned long )loff);
  tmp___1 = __fswab32(tmp___0);
  r32 = tmp___1;
  tmp___2 = __fswab32(r32);
  *(buf + (unsigned long )i) = tmp___2;
  loff = loff + 4U;
  loff = loff & 32767U;
  if (loff == 0U) {
    pgnum = pgnum + 1U;
    writel(pgnum, (void volatile   *)ioc->ioc_regs.host_page_num_fn);
  } else {

  }
  i = i + 1;
  ldv_49039: ;
  if (i < len) {
    goto ldv_49038;
  } else {

  }
  writel(ioc->ioc_regs.smem_pg0, (void volatile   *)ioc->ioc_regs.host_page_num_fn);
  readl((void const volatile   *)ioc->ioc_regs.ioc_init_sem_reg);
  writel(1U, (void volatile   *)ioc->ioc_regs.ioc_init_sem_reg);
  __bfa_trc(ioc->trcmod, __trc_fileno___2, 2101, (unsigned long long )pgnum);
  return (0);
}
}
static enum bfa_status bfa_ioc_smem_clr(struct bfa_ioc_s *ioc , u32 soff , u32 sz ) 
{ 
  int i ;
  int len ;
  u32 pgnum ;
  u32 loff ;
  enum bfa_boolean tmp ;

  {
  pgnum = ioc->ioc_regs.smem_pg0 + (soff >> 15);
  loff = soff & 32767U;
  __bfa_trc(ioc->trcmod, __trc_fileno___2, 2120, (unsigned long long )pgnum);
  __bfa_trc(ioc->trcmod, __trc_fileno___2, 2121, (unsigned long long )loff);
  __bfa_trc(ioc->trcmod, __trc_fileno___2, 2122, (unsigned long long )sz);
  tmp = bfa_ioc_sem_get(ioc->ioc_regs.ioc_init_sem_reg);
  if ((unsigned int )tmp == 0U) {
    __bfa_trc(ioc->trcmod, __trc_fileno___2, 2128, 0ULL);
    return (1);
  } else {

  }
  writel(pgnum, (void volatile   *)ioc->ioc_regs.host_page_num_fn);
  len = (int )(sz / 4U);
  __bfa_trc(ioc->trcmod, __trc_fileno___2, 2135, (unsigned long long )len);
  i = 0;
  goto ldv_49051;
  ldv_49050: 
  writel(0U, (void volatile   *)ioc->ioc_regs.smem_page_start + (unsigned long )loff);
  loff = loff + 4U;
  loff = loff & 32767U;
  if (loff == 0U) {
    pgnum = pgnum + 1U;
    writel(pgnum, (void volatile   *)ioc->ioc_regs.host_page_num_fn);
  } else {

  }
  i = i + 1;
  ldv_49051: ;
  if (i < len) {
    goto ldv_49050;
  } else {

  }
  writel(ioc->ioc_regs.smem_pg0, (void volatile   *)ioc->ioc_regs.host_page_num_fn);
  readl((void const volatile   *)ioc->ioc_regs.ioc_init_sem_reg);
  writel(1U, (void volatile   *)ioc->ioc_regs.ioc_init_sem_reg);
  __bfa_trc(ioc->trcmod, __trc_fileno___2, 2157, (unsigned long long )pgnum);
  return (0);
}
}
static void bfa_ioc_fail_notify(struct bfa_ioc_s *ioc ) 
{ 
  struct bfad_s *bfad ;

  {
  bfad = (struct bfad_s *)(ioc->bfa)->bfad;
  (*((ioc->cbfn)->hbfail_cbfn))((void *)ioc->bfa);
  bfa_ioc_event_notify(ioc, 3);
  bfa_ioc_debug_save_ftrc(ioc);
  if (bfa_log_level == 4 || (int )((signed char )*("\n" + 1)) <= 52) {
    dev_printk("\n", (struct device  const  *)(& (bfad->pcidev)->dev), "Heart Beat of IOC has failed\n");
  } else {

  }
  bfa_ioc_aen_post(ioc, 2);
  return;
}
}
static void bfa_ioc_pf_fwmismatch(struct bfa_ioc_s *ioc ) 
{ 
  struct bfad_s *bfad ;

  {
  bfad = (struct bfad_s *)(ioc->bfa)->bfad;
  (*((ioc->cbfn)->enable_cbfn))((void *)ioc->bfa, 56);
  if (bfa_log_level == 4 || (int )((signed char )*("\f" + 1)) <= 52) {
    dev_printk("\f", (struct device  const  *)(& (bfad->pcidev)->dev), "Running firmware version is incompatible with the driver version\n");
  } else {

  }
  bfa_ioc_aen_post(ioc, 5);
  return;
}
}
enum bfa_status bfa_ioc_pll_init(struct bfa_ioc_s *ioc ) 
{ 


  {
  bfa_ioc_sem_get(ioc->ioc_regs.ioc_init_sem_reg);
  (*((ioc->ioc_hwif)->ioc_pll_init))(ioc->pcidev.pci_bar_kva, ioc->asic_mode);
  ioc->pllinit = 1;
  bfa_ioc_lmem_init(ioc);
  readl((void const volatile   *)ioc->ioc_regs.ioc_init_sem_reg);
  writel(1U, (void volatile   *)ioc->ioc_regs.ioc_init_sem_reg);
  return (0);
}
}
enum bfa_status bfa_ioc_boot(struct bfa_ioc_s *ioc , u32 boot_type , u32 boot_env ) 
{ 
  struct bfi_ioc_image_hdr_s *drv_fwhdr ;
  enum bfa_status status ;
  enum bfa_status tmp ;
  u32 *tmp___0 ;
  enum bfi_ioc_img_ver_cmp_e tmp___1 ;
  int __ret_warn_on ;
  long tmp___2 ;

  {
  ioc->stats.ioc_boots = ioc->stats.ioc_boots + 1U;
  tmp = bfa_ioc_pll_init(ioc);
  if ((unsigned int )tmp != 0U) {
    return (1);
  } else {

  }
  if (boot_env == 0U && boot_type == 0U) {
    tmp___0 = bfa_cb_image_get_chunk(ioc->asic_gen, 0U);
    drv_fwhdr = (struct bfi_ioc_image_hdr_s *)tmp___0;
    tmp___1 = bfa_ioc_flash_fwver_cmp(ioc, drv_fwhdr);
    if ((unsigned int )tmp___1 == 3U) {
      boot_type = 1U;
    } else {

    }
  } else {

  }
  if (boot_type == 2U) {
    (*((ioc->ioc_hwif)->ioc_set_fwstate))(ioc, 9);
    (*((ioc->ioc_hwif)->ioc_set_alt_fwstate))(ioc, 9);
  } else {
    (*((ioc->ioc_hwif)->ioc_set_fwstate))(ioc, 1);
    (*((ioc->ioc_hwif)->ioc_set_alt_fwstate))(ioc, 1);
  }
  bfa_ioc_msgflush(ioc);
  status = bfa_ioc_download_fw(ioc, boot_type, boot_env);
  if ((unsigned int )status == 0U) {
    bfa_ioc_lpu_start(ioc);
  } else {
    __ret_warn_on = boot_type == 2U;
    tmp___2 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
    if (tmp___2 != 0L) {
      warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_ioc.c",
                         2266);
    } else {

    }
    ldv__builtin_expect(__ret_warn_on != 0, 0L);
    bfa_iocpf_timeout((void *)ioc);
  }
  return (status);
}
}
void bfa_ioc_auto_recover(enum bfa_boolean auto_recover ) 
{ 


  {
  bfa_auto_recover = auto_recover;
  return;
}
}
enum bfa_boolean bfa_ioc_is_operational(struct bfa_ioc_s *ioc ) 
{ 


  {
  return ((unsigned long )ioc->fsm == (unsigned long )((void (*)(void * , int  ))(& bfa_ioc_sm_op)));
}
}
enum bfa_boolean bfa_ioc_is_initialized(struct bfa_ioc_s *ioc ) 
{ 
  u32 r32 ;
  enum bfi_ioc_state tmp ;

  {
  tmp = (*((ioc->ioc_hwif)->ioc_get_fwstate))(ioc);
  r32 = tmp;
  return ((enum bfa_boolean )((r32 != 0U && r32 != 1U) && r32 != 9U));
}
}
enum bfa_boolean bfa_ioc_msgget(struct bfa_ioc_s *ioc , void *mbmsg ) 
{ 
  __be32 *msgp ;
  u32 r32 ;
  int i ;
  __u32 tmp ;

  {
  msgp = (__be32 *)mbmsg;
  r32 = readl((void const volatile   *)ioc->ioc_regs.lpu_mbox_cmd);
  if ((r32 & 1U) == 0U) {
    return (0);
  } else {

  }
  i = 0;
  goto ldv_49091;
  ldv_49090: 
  r32 = readl((void const volatile   *)(ioc->ioc_regs.lpu_mbox + (unsigned long )i * 4UL));
  tmp = __fswab32(r32);
  *(msgp + (unsigned long )i) = tmp;
  i = i + 1;
  ldv_49091: ;
  if ((unsigned int )i <= 7U) {
    goto ldv_49090;
  } else {

  }
  writel(1U, (void volatile   *)ioc->ioc_regs.lpu_mbox_cmd);
  readl((void const volatile   *)ioc->ioc_regs.lpu_mbox_cmd);
  return (1);
}
}
void bfa_ioc_isr(struct bfa_ioc_s *ioc , struct bfi_mbmsg_s *m ) 
{ 
  union bfi_ioc_i2h_msg_u *msg ;
  struct bfa_iocpf_s *iocpf ;
  u8 tmp ;
  int __ret_warn_on ;
  long tmp___0 ;

  {
  iocpf = & ioc->iocpf;
  msg = (union bfi_ioc_i2h_msg_u *)m;
  ioc->stats.ioc_isrs = ioc->stats.ioc_isrs + 1U;
  switch ((int )msg->mh.msg_id) {
  case 132: ;
  goto ldv_49100;
  case 129: 
  tmp = msg->fw_event.port_mode;
  ioc->port_mode_cfg = tmp;
  ioc->port_mode = (enum bfa_mode_s )tmp;
  ioc->ad_cap_bm = msg->fw_event.cap_bm;
  (*(iocpf->fsm))((void *)iocpf, 5);
  goto ldv_49100;
  case 130: 
  (*(iocpf->fsm))((void *)iocpf, 6);
  goto ldv_49100;
  case 131: 
  bfa_ioc_getattr_reply(ioc);
  goto ldv_49100;
  default: 
  __bfa_trc(ioc->trcmod, __trc_fileno___2, 2359, (unsigned long long )msg->mh.msg_id);
  __ret_warn_on = 1;
  tmp___0 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp___0 != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_ioc.c",
                       2360);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  }
  ldv_49100: ;
  return;
}
}
void bfa_ioc_attach(struct bfa_ioc_s *ioc , void *bfa , struct bfa_ioc_cbfn_s *cbfn ,
                    struct bfa_timer_mod_s *timer_mod ) 
{ 


  {
  ioc->bfa = (struct bfa_s *)bfa;
  ioc->cbfn = cbfn;
  ioc->timer_mod = timer_mod;
  ioc->fcmode = 0;
  ioc->pllinit = 0;
  ioc->dbg_fwsave_once = 1;
  ioc->iocpf.ioc = ioc;
  bfa_ioc_mbox_attach(ioc);
  INIT_LIST_HEAD(& ioc->notify_q);
  ioc->fsm = (void (*)(void * , int  ))(& bfa_ioc_sm_uninit);
  bfa_ioc_sm_uninit_entry(ioc);
  (*(ioc->fsm))((void *)ioc, 1);
  return;
}
}
void bfa_ioc_detach(struct bfa_ioc_s *ioc ) 
{ 


  {
  (*(ioc->fsm))((void *)ioc, 4);
  INIT_LIST_HEAD(& ioc->notify_q);
  return;
}
}
void bfa_ioc_pci_init(struct bfa_ioc_s *ioc , struct bfa_pcidev_s *pcidev , enum bfi_pcifn_class clscode ) 
{ 
  enum bfi_port_mode tmp ;
  enum bfi_port_mode tmp___0 ;
  enum bfi_port_mode tmp___1 ;
  int __ret_warn_on ;
  long tmp___2 ;
  int __ret_warn_on___0 ;
    klee_make_symbolic(&__ret_warn_on___0, sizeof(int), "__ret_warn_on___0");
  long tmp___3 ;

  {
  ioc->clscode = clscode;
  ioc->pcidev = *pcidev;
  tmp = 1;
  ioc->port1_mode = tmp;
  ioc->port0_mode = tmp;
  ioc->asic_mode = 1;
  switch ((int )pcidev->device_id) {
  case 23: ;
  case 19: 
  ioc->asic_gen = 1;
  ioc->fcmode = 1;
  ioc->port_mode_cfg = 1U;
  ioc->port_mode = 1;
  ioc->ad_cap_bm = 1U;
  goto ldv_49123;
  case 20: 
  ioc->asic_gen = 2;
  tmp___0 = 2;
  ioc->port1_mode = tmp___0;
  ioc->port0_mode = tmp___0;
  ioc->asic_mode = 3;
  ioc->port_mode_cfg = 2U;
  ioc->port_mode = 2;
  ioc->ad_cap_bm = 2U;
  goto ldv_49123;
  case 33: 
  ioc->asic_gen = 2;
  ioc->fcmode = 1;
  ioc->port_mode_cfg = 1U;
  ioc->port_mode = 1;
  ioc->ad_cap_bm = 1U;
  goto ldv_49123;
  case 34: ;
  case 35: 
  ioc->asic_gen = 3;
  if ((unsigned int )clscode == 3076U && (unsigned int )pcidev->ssid == 36U) {
    ioc->asic_mode = 2;
    ioc->fcmode = 1;
    ioc->port_mode_cfg = 1U;
    ioc->port_mode = 1;
    ioc->ad_cap_bm = 1U;
  } else {
    tmp___1 = 2;
    ioc->port1_mode = tmp___1;
    ioc->port0_mode = tmp___1;
    ioc->asic_mode = 3;
    if ((unsigned int )pcidev->ssid == 34U) {
      ioc->port_mode_cfg = 2U;
      ioc->port_mode = 2;
      ioc->ad_cap_bm = 2U;
    } else {
      ioc->port_mode_cfg = 3U;
      ioc->port_mode = 3;
      ioc->ad_cap_bm = 4U;
    }
  }
  goto ldv_49123;
  default: 
  __ret_warn_on = 1;
  tmp___2 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp___2 != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_ioc.c",
                       2466);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  }
  ldv_49123: ;
  if ((unsigned int )ioc->asic_gen == 1U) {
    bfa_ioc_set_cb_hwif(ioc);
  } else
  if ((unsigned int )ioc->asic_gen == 2U) {
    bfa_ioc_set_ct_hwif(ioc);
  } else {
    __ret_warn_on___0 = (unsigned int )ioc->asic_gen != 3U;
    tmp___3 = ldv__builtin_expect(__ret_warn_on___0 != 0, 0L);
    if (tmp___3 != 0L) {
      warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_ioc.c",
                         2477);
    } else {

    }
    ldv__builtin_expect(__ret_warn_on___0 != 0, 0L);
    bfa_ioc_set_ct2_hwif(ioc);
    bfa_ioc_ct2_poweron(ioc);
  }
  (*((ioc->ioc_hwif)->ioc_map_port))(ioc);
  (*((ioc->ioc_hwif)->ioc_reg_init))(ioc);
  return;
}
}
void bfa_ioc_mem_claim(struct bfa_ioc_s *ioc , u8 *dm_kva , u64 dm_pa ) 
{ 


  {
  ioc->attr_dma.kva = (void *)dm_kva;
  ioc->attr_dma.pa = dm_pa;
  ioc->attr = (struct bfi_ioc_attr_s *)dm_kva;
  return;
}
}
void bfa_ioc_enable(struct bfa_ioc_s *ioc ) 
{ 


  {
  ioc->stats.ioc_enables = ioc->stats.ioc_enables + 1U;
  ioc->dbg_fwsave_once = 1;
  (*(ioc->fsm))((void *)ioc, 2);
  return;
}
}
void bfa_ioc_disable(struct bfa_ioc_s *ioc ) 
{ 


  {
  ioc->stats.ioc_disables = ioc->stats.ioc_disables + 1U;
  (*(ioc->fsm))((void *)ioc, 3);
  return;
}
}
void bfa_ioc_suspend(struct bfa_ioc_s *ioc ) 
{ 


  {
  ioc->dbg_fwsave_once = 1;
  (*(ioc->fsm))((void *)ioc, 10);
  return;
}
}
void bfa_ioc_debug_memclaim(struct bfa_ioc_s *ioc , void *dbg_fwsave ) 
{ 


  {
  ioc->dbg_fwsave = dbg_fwsave;
  ioc->dbg_fwsave_len = 4128;
  return;
}
}
void bfa_ioc_mbox_register(struct bfa_ioc_s *ioc , bfa_ioc_mbox_mcfunc_t (**mcfuncs)(void * ,
                                                                                     struct bfi_mbmsg_s * ) ) 
{ 
  struct bfa_ioc_mbox_mod_s *mod ;
  int mc ;

  {
  mod = & ioc->mbox_mod;
  mc = 0;
  goto ldv_49158;
  ldv_49157: 
  mod->mbhdlr[mc].cbfn = *(mcfuncs + (unsigned long )mc);
  mc = mc + 1;
  ldv_49158: ;
  if (mc <= 34) {
    goto ldv_49157;
  } else {

  }

  return;
}
}
void bfa_ioc_mbox_regisr(struct bfa_ioc_s *ioc , enum bfi_mclass mc , void (*cbfn)(void * ,
                                                                                   struct bfi_mbmsg_s * ) ,
                         void *cbarg ) 
{ 
  struct bfa_ioc_mbox_mod_s *mod ;

  {
  mod = & ioc->mbox_mod;
  mod->mbhdlr[(unsigned int )mc].cbfn = cbfn;
  mod->mbhdlr[(unsigned int )mc].cbarg = cbarg;
  return;
}
}
void bfa_ioc_mbox_queue(struct bfa_ioc_s *ioc , struct bfa_mbox_cmd_s *cmd ) 
{ 
  struct bfa_ioc_mbox_mod_s *mod ;
  u32 stat ;
  int tmp ;

  {
  mod = & ioc->mbox_mod;
  tmp = list_empty((struct list_head  const  *)(& mod->cmd_q));
  if (tmp == 0) {
    list_add_tail(& cmd->qe, & mod->cmd_q);
    return;
  } else {

  }
  stat = readl((void const volatile   *)ioc->ioc_regs.hfn_mbox_cmd);
  if (stat != 0U) {
    list_add_tail(& cmd->qe, & mod->cmd_q);
    return;
  } else {

  }
  bfa_ioc_mbox_send(ioc, (void *)(& cmd->msg), 32);
  return;
}
}
void bfa_ioc_mbox_isr(struct bfa_ioc_s *ioc ) 
{ 
  struct bfa_ioc_mbox_mod_s *mod ;
  struct bfi_mbmsg_s m ;
  int mc ;
  enum bfa_boolean tmp ;

  {
  mod = & ioc->mbox_mod;
  tmp = bfa_ioc_msgget(ioc, (void *)(& m));
  if ((unsigned int )tmp != 0U) {
    mc = (int )m.mh.msg_class;
    if (mc == 1) {
      bfa_ioc_isr(ioc, & m);
      return;
    } else {

    }
    if (mc > 34 || (unsigned long )mod->mbhdlr[mc].cbfn == (unsigned long )((void (*)(void * ,
                                                                                      struct bfi_mbmsg_s * ))0)) {
      return;
    } else {

    }
    (*(mod->mbhdlr[mc].cbfn))(mod->mbhdlr[mc].cbarg, & m);
  } else {

  }
  if ((unsigned long )(ioc->ioc_hwif)->ioc_lpu_read_stat != (unsigned long )((enum bfa_boolean (*)(struct bfa_ioc_s * ))0)) {
    (*((ioc->ioc_hwif)->ioc_lpu_read_stat))(ioc);
  } else {

  }
  bfa_ioc_mbox_poll(ioc);
  return;
}
}
void bfa_ioc_error_isr(struct bfa_ioc_s *ioc ) 
{ 


  {
  ioc->stats.ioc_hbfails = ioc->stats.ioc_hbfails + 1U;
  ioc->stats.hb_count = ioc->hb_count;
  (*(ioc->fsm))((void *)ioc, 10);
  return;
}
}
enum bfa_boolean bfa_ioc_is_disabled(struct bfa_ioc_s *ioc ) 
{ 


  {
  return ((enum bfa_boolean )((unsigned long )ioc->fsm == (unsigned long )((void (*)(void * ,
                                                                                     int  ))(& bfa_ioc_sm_disabling)) || (unsigned long )ioc->fsm == (unsigned long )((void (*)(void * ,
                                                                                                                                                                                int  ))(& bfa_ioc_sm_disabled))));
}
}
enum bfa_boolean bfa_ioc_fw_mismatch(struct bfa_ioc_s *ioc ) 
{ 


  {
  return ((enum bfa_boolean )(((unsigned long )ioc->fsm == (unsigned long )((void (*)(void * ,
                                                                                      int  ))(& bfa_ioc_sm_reset)) || (unsigned long )ioc->iocpf.fsm == (unsigned long )((void (*)(void * ,
                                                                                                                                                                                   int  ))(& bfa_iocpf_sm_fwcheck))) || (unsigned long )ioc->iocpf.fsm == (unsigned long )((void (*)(void * ,
                                                                                                                                                                                                                                                                                     int  ))(& bfa_iocpf_sm_mismatch))));
}
}
enum bfa_boolean bfa_ioc_adapter_is_disabled(struct bfa_ioc_s *ioc ) 
{ 
  u32 ioc_state ;
  enum bfi_ioc_state tmp ;
  enum bfi_ioc_state tmp___0 ;

  {
  if ((unsigned long )ioc->fsm != (unsigned long )((void (*)(void * , int  ))(& bfa_ioc_sm_disabled))) {
    return (0);
  } else {

  }
  tmp = (*((ioc->ioc_hwif)->ioc_get_fwstate))(ioc);
  ioc_state = (u32 )tmp;
  if (((((ioc_state != 0U && ioc_state != 1U) && ioc_state != 2U) && ioc_state != 6U) && ioc_state != 8U) && ioc_state != 7U) {
    return (0);
  } else {

  }
  if ((unsigned int )ioc->pcidev.device_id != 23U) {
    tmp___0 = (*((ioc->ioc_hwif)->ioc_get_fwstate))(ioc);
    ioc_state = (u32 )tmp___0;
    if (((((ioc_state != 0U && ioc_state != 1U) && ioc_state != 2U) && ioc_state != 6U) && ioc_state != 8U) && ioc_state != 7U) {
      return (0);
    } else {

    }
  } else {

  }
  return (1);
}
}
void bfa_ioc_reset_fwstate(struct bfa_ioc_s *ioc ) 
{ 


  {
  (*((ioc->ioc_hwif)->ioc_set_fwstate))(ioc, 0);
  (*((ioc->ioc_hwif)->ioc_set_alt_fwstate))(ioc, 0);
  return;
}
}
void bfa_ioc_get_adapter_attr(struct bfa_ioc_s *ioc , struct bfa_adapter_attr_s *ad_attr ) 
{ 
  struct bfi_ioc_attr_s *ioc_attr ;
  enum bfa_ioc_type_e tmp___1 ;
  enum bfa_ioc_type_e tmp___2 ;
  enum bfa_ioc_type_e tmp___3 ;
  enum bfa_ioc_type_e tmp___4 ;
  int tmp___5 ;
  enum bfa_ioc_type_e tmp___6 ;
  enum bfa_ioc_type_e tmp___7 ;
  int tmp___8 ;
    klee_make_symbolic(&tmp___8, sizeof(int), "tmp___8");

  {
  ioc_attr = ioc->attr;
  bfa_ioc_get_adapter_serial_num(ioc, (char *)(& ad_attr->serial_num));
  bfa_ioc_get_adapter_fw_ver(ioc, (char *)(& ad_attr->fw_ver));
  bfa_ioc_get_adapter_optrom_ver(ioc, (char *)(& ad_attr->optrom_ver));
  bfa_ioc_get_adapter_manufacturer(ioc, (char *)(& ad_attr->manufacturer));
  memcpy((void *)(& ad_attr->vpd), (void const   *)(& ioc_attr->vpd), 520UL);
  ad_attr->nports = (u8 )(((ioc->attr)->adapter_prop & 65280U) >> 8);
  tmp___1 = bfa_ioc_get_type(ioc);
  if ((unsigned int )tmp___1 != 2U) {
    tmp___2 = bfa_ioc_get_type(ioc);
    if ((unsigned int )tmp___2 != 3U) {
      ad_attr->max_speed = (u8 )(ioc->attr)->adapter_prop;
    } else {
      ad_attr->max_speed = 10U;
    }
  } else {
    ad_attr->max_speed = 10U;
  }
  bfa_ioc_get_adapter_model(ioc, (char *)(& ad_attr->model));
  bfa_ioc_get_adapter_model(ioc, (char *)(& ad_attr->model_descr));
  ad_attr->card_type = ioc_attr->card_type;
  ad_attr->is_mezz = (u8 )((((((ioc_attr->card_type == 804U || ioc_attr->card_type == 1007U) || ioc_attr->card_type == 807U) || ioc_attr->card_type == 902U) || ioc_attr->card_type == 1741U) || ioc_attr->card_type == 1867U) || ioc_attr->card_type == 1869U);
  if ((ioc_attr->adapter_prop & 7340032U) != 0U) {
    ad_attr->prototype = 1U;
  } else {
    ad_attr->prototype = 0U;
  }
  ad_attr->pwwn = (ioc->attr)->pwwn;
  ad_attr->mac = bfa_ioc_get_mac(ioc);
  ad_attr->pcie_gen = ioc_attr->pcie_gen;
  ad_attr->pcie_lanes = ioc_attr->pcie_lanes;
  ad_attr->pcie_lanes_orig = ioc_attr->pcie_lanes_orig;
  ad_attr->asic_rev = ioc_attr->asic_rev;
  bfa_ioc_get_pci_chip_rev(ioc, (char *)(& ad_attr->hw_ver));
  tmp___3 = bfa_ioc_get_type(ioc);
  if ((unsigned int )tmp___3 == 2U) {
    tmp___5 = 1;
  } else {
    tmp___4 = bfa_ioc_get_type(ioc);
    if ((unsigned int )tmp___4 == 3U) {
      tmp___5 = 1;
    } else {
      tmp___5 = 0;
    }
  }
  ad_attr->cna_capable = (u8 )tmp___5;
  if ((unsigned int )ad_attr->nports > 1U) {
    tmp___6 = bfa_ioc_get_type(ioc);
    if ((unsigned int )tmp___6 != 2U) {
      tmp___7 = bfa_ioc_get_type(ioc);
      if ((unsigned int )tmp___7 != 3U) {
        if ((unsigned int )ad_attr->is_mezz == 0U) {
          tmp___8 = 1;
        } else {
          tmp___8 = 0;
        }
      } else {
        tmp___8 = 0;
      }
    } else {
      tmp___8 = 0;
    }
  } else {
    tmp___8 = 0;
  }
  ad_attr->trunk_capable = (u8 )tmp___8;
  ad_attr->mfg_day = ioc_attr->mfg_day;
  ad_attr->mfg_month = ioc_attr->mfg_month;
  ad_attr->mfg_year = ioc_attr->mfg_year;
  memcpy((void *)(& ad_attr->uuid), (void const   *)(& ioc_attr->uuid), 16UL);
  return;
}
}
enum bfa_ioc_type_e bfa_ioc_get_type(struct bfa_ioc_s *ioc ) 
{ 
  int __ret_warn_on ;
  long tmp ;

  {
  if ((unsigned int )ioc->clscode == 512U) {
    return (3);
  } else {

  }
  __ret_warn_on = (unsigned int )ioc->clscode != 3076U;
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_ioc.c",
                       2756);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  return ((unsigned int )(ioc->attr)->port_mode == 1U ? 1 : 2);
}
}
void bfa_ioc_get_adapter_serial_num(struct bfa_ioc_s *ioc , char *serial_num ) 
{ 


  {
  memset((void *)serial_num, 0, 12UL);
  memcpy((void *)serial_num, (void const   *)(& (ioc->attr)->brcd_serialnum), 12UL);
  return;
}
}
void bfa_ioc_get_adapter_fw_ver(struct bfa_ioc_s *ioc , char *fw_ver ) 
{ 


  {
  memset((void *)fw_ver, 0, 64UL);
  memcpy((void *)fw_ver, (void const   *)(& (ioc->attr)->fw_version), 64UL);
  return;
}
}
void bfa_ioc_get_pci_chip_rev(struct bfa_ioc_s *ioc , char *chip_rev ) 
{ 
  int __ret_warn_on ;
  long tmp ;

  {
  __ret_warn_on = (unsigned long )chip_rev == (unsigned long )((char *)0);
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_ioc.c",
                       2781);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  memset((void *)chip_rev, 0, 8UL);
  *chip_rev = 82;
  *(chip_rev + 1UL) = 101;
  *(chip_rev + 2UL) = 118;
  *(chip_rev + 3UL) = 45;
  *(chip_rev + 4UL) = (ioc->attr)->asic_rev;
  *(chip_rev + 5UL) = 0;
  return;
}
}
void bfa_ioc_get_adapter_optrom_ver(struct bfa_ioc_s *ioc , char *optrom_ver ) 
{ 


  {
  memset((void *)optrom_ver, 0, 64UL);
  memcpy((void *)optrom_ver, (void const   *)(& (ioc->attr)->optrom_version), 64UL);
  return;
}
}
void bfa_ioc_get_adapter_manufacturer(struct bfa_ioc_s *ioc , char *manufacturer ) 
{ 


  {
  memset((void *)manufacturer, 0, 8UL);
  memcpy((void *)manufacturer, (void const   *)"Brocade", 8UL);
  return;
}
}
void bfa_ioc_get_adapter_model(struct bfa_ioc_s *ioc , char *model ) 
{ 
  struct bfi_ioc_attr_s *ioc_attr ;
  u8 nports ;
  int __ret_warn_on ;
  long tmp ;

  {
  nports = (u8 )(((ioc->attr)->adapter_prop & 65280U) >> 8);
  __ret_warn_on = (unsigned long )model == (unsigned long )((char *)0);
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_ioc.c",
                       2814);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  memset((void *)model, 0, 16UL);
  ioc_attr = ioc->attr;
  if (((unsigned int )ioc->pcidev.device_id == 34U || (unsigned int )ioc->pcidev.device_id == 35U) && ((((((ioc_attr->card_type != 804U && ioc_attr->card_type != 1007U) && ioc_attr->card_type != 807U) && ioc_attr->card_type != 902U) && ioc_attr->card_type != 1741U) && ioc_attr->card_type != 1867U) && ioc_attr->card_type != 1869U)) {
    snprintf(model, 16UL, "%s-%u-%u%s", (char *)"Brocade", ioc_attr->card_type, (int )nports,
             (char *)"p");
  } else {
    snprintf(model, 16UL, "%s-%u", (char *)"Brocade", ioc_attr->card_type);
  }
  return;
}
}
enum bfa_ioc_state bfa_ioc_get_state(struct bfa_ioc_s *ioc ) 
{ 
  enum bfa_iocpf_state iocpf_st ;
  enum bfa_ioc_state ioc_st ;
  int tmp ;
  int tmp___0 ;

  {
  tmp = bfa_sm_to_state((struct bfa_sm_table_s *)(& ioc_sm_table), ioc->fsm);
  ioc_st = (enum bfa_ioc_state )tmp;
  if (((unsigned int )ioc_st == 12U || (unsigned int )ioc_st == 8U) || (unsigned int )ioc_st == 7U) {
    tmp___0 = bfa_sm_to_state((struct bfa_sm_table_s *)(& iocpf_sm_table), ioc->iocpf.fsm);
    iocpf_st = (enum bfa_iocpf_state )tmp___0;
    switch ((unsigned int )iocpf_st) {
    case 2U: 
    ioc_st = 3;
    goto ldv_49241;
    case 3U: 
    ioc_st = 4;
    goto ldv_49241;
    case 9U: 
    ioc_st = 11;
    goto ldv_49241;
    case 6U: 
    ioc_st = 8;
    goto ldv_49241;
    case 5U: 
    ioc_st = 7;
    goto ldv_49241;
    default: ;
    goto ldv_49241;
    }
    ldv_49241: ;
  } else {

  }
  return (ioc_st);
}
}
void bfa_ioc_get_attr(struct bfa_ioc_s *ioc , struct bfa_ioc_attr_s *ioc_attr ) 
{ 


  {
  memset((void *)ioc_attr, 0, 1624UL);
  ioc_attr->state = bfa_ioc_get_state(ioc);
  ioc_attr->port_id = ioc->port_id;
  ioc_attr->port_mode = (u8 )ioc->port_mode;
  ioc_attr->port_mode_cfg = ioc->port_mode_cfg;
  ioc_attr->cap_bm = ioc->ad_cap_bm;
  ioc_attr->ioc_type = bfa_ioc_get_type(ioc);
  bfa_ioc_get_adapter_attr(ioc, & ioc_attr->adapter_attr);
  ioc_attr->pci_attr.device_id = ioc->pcidev.device_id;
  ioc_attr->pci_attr.pcifn = (u32 )ioc->pcidev.pci_func;
  ioc_attr->def_fn = (int )ioc->pcidev.pci_func == (int )ioc->port_id;
  bfa_ioc_get_pci_chip_rev(ioc, (char *)(& ioc_attr->pci_attr.chip_rev));
  return;
}
}
struct mac_s bfa_ioc_get_mac(struct bfa_ioc_s *ioc ) 
{ 
  enum bfa_ioc_type_e tmp ;

  {
  tmp = bfa_ioc_get_type(ioc);
  if ((unsigned int )tmp == 2U) {
    return ((ioc->attr)->fcoe_mac);
  } else {
    return ((ioc->attr)->mac);
  }
}
}
struct mac_s bfa_ioc_get_mfg_mac(struct bfa_ioc_s *ioc ) 
{ 
  struct mac_s m ;
  u32 t ;

  {
  m = (ioc->attr)->mfg_mac;
  if ((((((((ioc->attr)->card_type == 825U || (ioc->attr)->card_type == 815U) || (ioc->attr)->card_type == 425U) || (ioc->attr)->card_type == 415U) || (ioc->attr)->card_type == 1020U) || (ioc->attr)->card_type == 1010U) || (ioc->attr)->card_type == 804U) || (ioc->attr)->card_type == 1007U) {
    m.mac[5] = (int )m.mac[5] + (int )ioc->pcidev.pci_func;
  } else {
    t = (((unsigned int )*((u8 *)(& m.mac) + 3UL) << 16) | ((unsigned int )*((u8 *)(& m.mac) + 4U) << 8)) | (unsigned int )*((u8 *)(& m.mac) + 5U);
    t = (u32 )ioc->pcidev.pci_func + t;
    *((u8 *)(& m.mac) + 3UL) = (u8 )(t >> 16);
    *((u8 *)(& m.mac) + 4U) = (u8 )(t >> 8);
    *((u8 *)(& m.mac) + 5U) = (u8 )t;
  }
  return (m);
}
}
void bfa_ioc_aen_post(struct bfa_ioc_s *ioc , enum bfa_ioc_aen_event event ) 
{ 
  struct bfad_s *bfad ;
  struct bfa_aen_entry_s *aen_entry ;
  enum bfa_ioc_type_e ioc_type ;
  unsigned long _flags ;
    klee_make_symbolic(&_flags, sizeof(long), "_flags");
  raw_spinlock_t *tmp ;
  int tmp___0 ;
  int __ret_warn_on ;
  long tmp___1 ;

  {
  bfad = (struct bfad_s *)(ioc->bfa)->bfad;
  tmp = spinlock_check(& bfad->bfad_aen_spinlock);
  _flags = _raw_spin_lock_irqsave(tmp);
  tmp___0 = list_empty((struct list_head  const  *)(& bfad->free_aen_q));
  if (tmp___0 == 0) {
    *((struct list_head **)(& aen_entry)) = bfad->free_aen_q.next;
    ((*((struct list_head **)(& aen_entry)))->next)->prev = & bfad->free_aen_q;
    bfad->free_aen_q.next = (*((struct list_head **)(& aen_entry)))->next;
  } else {
    *((struct list_head **)(& aen_entry)) = (struct list_head *)0;
  }
  if ((unsigned long )aen_entry != (unsigned long )((struct bfa_aen_entry_s *)0)) {
    list_add_tail(& aen_entry->qe, & bfad->active_aen_q);
  } else {

  }
  spin_unlock_irqrestore(& bfad->bfad_aen_spinlock, _flags);
  if ((unsigned long )aen_entry == (unsigned long )((struct bfa_aen_entry_s *)0)) {
    return;
  } else {

  }
  ioc_type = bfa_ioc_get_type(ioc);
  switch ((unsigned int )ioc_type) {
  case 1U: 
  aen_entry->aen_data.ioc.pwwn = (ioc->attr)->pwwn;
  goto ldv_49271;
  case 2U: 
  aen_entry->aen_data.ioc.pwwn = (ioc->attr)->pwwn;
  aen_entry->aen_data.ioc.mac = bfa_ioc_get_mac(ioc);
  goto ldv_49271;
  case 3U: 
  aen_entry->aen_data.ioc.mac = bfa_ioc_get_mac(ioc);
  goto ldv_49271;
  default: 
  __ret_warn_on = (unsigned int )ioc_type != 1U;
  tmp___1 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp___1 != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_ioc.c",
                       2943);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  goto ldv_49271;
  }
  ldv_49271: 
  aen_entry->aen_data.ioc.ioc_type = (u16 )ioc_type;
  do_gettimeofday(& aen_entry->aen_tv);
  aen_entry->bfad_num = bfad->inst_no;
  ioc->ioc_aen_seq = ioc->ioc_aen_seq + 1;
  aen_entry->seq_num = (u32 )ioc->ioc_aen_seq;
  aen_entry->aen_category = 9;
  aen_entry->aen_type = (u32 )event;
  if ((bfad->bfad_flags & 512U) != 0U) {
    queue_work___0((bfad->im)->drv_workq, & (bfad->im)->aen_im_notify_work);
  } else {

  }
  return;
}
}
enum bfa_status bfa_ioc_debug_fwsave(struct bfa_ioc_s *ioc , void *trcdata , int *trclen ) 
{ 
  int tlen ;
    klee_make_symbolic(&tlen, sizeof(int), "tlen");

  {
  if (ioc->dbg_fwsave_len == 0) {
    return (78);
  } else {

  }
  tlen = *trclen;
  if (ioc->dbg_fwsave_len < tlen) {
    tlen = ioc->dbg_fwsave_len;
  } else {

  }
  memcpy(trcdata, (void const   *)ioc->dbg_fwsave, (size_t )tlen);
  *trclen = tlen;
  return (0);
}
}
enum bfa_status bfa_ioc_debug_fwtrc(struct bfa_ioc_s *ioc , void *trcdata , int *trclen ) 
{ 
  u32 loff ;
  int tlen ;
  enum bfa_status status ;

  {
  loff = (u32 )ioc->port_id * 4128U + 19200U;
  __bfa_trc(ioc->trcmod, __trc_fileno___2, 2984, (unsigned long long )*trclen);
  tlen = *trclen;
  if ((unsigned int )tlen > 4128U) {
    tlen = 4128;
  } else {

  }
  status = bfa_ioc_smem_read(ioc, trcdata, loff, (u32 )tlen);
  *trclen = tlen;
  return (status);
}
}
static void bfa_ioc_send_fwsync(struct bfa_ioc_s *ioc ) 
{ 
  struct bfa_mbox_cmd_s cmd ;
  struct bfi_ioc_ctrl_req_s *req ;
  __u16 tmp ;

  {
  req = (struct bfi_ioc_ctrl_req_s *)(& cmd.msg);
  req->mh.msg_class = 1U;
  req->mh.msg_id = 4U;
  req->mh.mtag.h2i.fn_lpu = ioc->port_id;
  tmp = __fswab16((int )((__u16 )ioc->clscode));
  req->clscode = tmp;
  bfa_ioc_mbox_queue(ioc, & cmd);
  return;
}
}
static void bfa_ioc_fwsync(struct bfa_ioc_s *ioc ) 
{ 
  u32 fwsync_iter ;
  int tmp ;
  unsigned int tmp___0 ;

  {
  fwsync_iter = 1000U;
  bfa_ioc_send_fwsync(ioc);
  goto ldv_49301;
  ldv_49300: 
  fwsync_iter = fwsync_iter - 1U;
  ldv_49301: 
  tmp = list_empty((struct list_head  const  *)(& ioc->mbox_mod.cmd_q));
  if (tmp == 0) {
    goto _L;
  } else {
    tmp___0 = readl((void const volatile   *)ioc->ioc_regs.hfn_mbox_cmd);
    if (tmp___0 != 0U) {
      _L: /* CIL Label */ 
      if (fwsync_iter != 0U) {
        goto ldv_49300;
      } else {
        goto ldv_49302;
      }
    } else {
      goto ldv_49302;
    }
  }
  ldv_49302: ;
  return;
}
}
enum bfa_status bfa_ioc_debug_fwcore(struct bfa_ioc_s *ioc , void *buf , u32 *offset ,
                                     int *buflen ) 
{ 
  u32 loff ;
  int dlen ;
    klee_make_symbolic(&dlen, sizeof(int), "dlen");
  enum bfa_status status ;
  u32 smem_len ;

  {
  smem_len = (unsigned int )ioc->asic_gen == 1U ? 2097152U : 2621440U;
  if (*offset >= smem_len) {
    *buflen = 0;
    *offset = 0U;
    return (2);
  } else {

  }
  loff = *offset;
  dlen = *buflen;
  if (loff == 0U) {
    bfa_ioc_fwsync(ioc);
  } else {

  }
  if (loff + (u32 )dlen >= smem_len) {
    dlen = (int )(smem_len - loff);
  } else {

  }
  status = bfa_ioc_smem_read(ioc, buf, loff, (u32 )dlen);
  if ((unsigned int )status != 0U) {
    *buflen = 0;
    *offset = 0U;
    return (status);
  } else {

  }
  *offset = *offset + (u32 )dlen;
  if (*offset >= smem_len) {
    *offset = 0U;
  } else {

  }
  *buflen = dlen;
  return (status);
}
}
enum bfa_status bfa_ioc_fw_stats_get(struct bfa_ioc_s *ioc , void *stats ) 
{ 
  u32 loff ;
  int tlen ;
  enum bfa_status status ;

  {
  loff = (u32 )((int )ioc->port_id * 4096 + 27456);
  if ((unsigned int )ioc->stats_busy != 0U) {
    __bfa_trc(ioc->trcmod, __trc_fileno___2, 3088, (unsigned long long )ioc->stats_busy);
    return (13);
  } else {

  }
  ioc->stats_busy = 1;
  tlen = 936;
  status = bfa_ioc_smem_read(ioc, stats, loff, (u32 )tlen);
  ioc->stats_busy = 0;
  return (status);
}
}
enum bfa_status bfa_ioc_fw_stats_clear(struct bfa_ioc_s *ioc ) 
{ 
  u32 loff ;
  int tlen ;
  enum bfa_status status ;

  {
  loff = (u32 )((int )ioc->port_id * 4096 + 27456);
  if ((unsigned int )ioc->stats_busy != 0U) {
    __bfa_trc(ioc->trcmod, __trc_fileno___2, 3109, (unsigned long long )ioc->stats_busy);
    return (13);
  } else {

  }
  ioc->stats_busy = 1;
  tlen = 936;
  status = bfa_ioc_smem_clr(ioc, loff, (u32 )tlen);
  ioc->stats_busy = 0;
  return (status);
}
}
void bfa_ioc_debug_save_ftrc(struct bfa_ioc_s *ioc ) 
{ 
  int tlen ;

  {
  if ((unsigned int )ioc->dbg_fwsave_once != 0U) {
    ioc->dbg_fwsave_once = 0;
    if (ioc->dbg_fwsave_len != 0) {
      tlen = ioc->dbg_fwsave_len;
      bfa_ioc_debug_fwtrc(ioc, ioc->dbg_fwsave, & tlen);
    } else {

    }
  } else {

  }
  return;
}
}
static void bfa_ioc_recover(struct bfa_ioc_s *ioc ) 
{ 


  {
  ioc->stats.ioc_hbfails = ioc->stats.ioc_hbfails + 1U;
  ioc->stats.hb_count = ioc->hb_count;
  (*(ioc->fsm))((void *)ioc, 9);
  return;
}
}
static void bfa_iocpf_timeout(void *ioc_arg ) 
{ 
  struct bfa_ioc_s *ioc ;

  {
  ioc = (struct bfa_ioc_s *)ioc_arg;
  __bfa_trc(ioc->trcmod, __trc_fileno___2, 3157, 0ULL);
  (*(ioc->iocpf.fsm))((void *)(& ioc->iocpf), 11);
  return;
}
}
static void bfa_iocpf_sem_timeout(void *ioc_arg ) 
{ 
  struct bfa_ioc_s *ioc ;

  {
  ioc = (struct bfa_ioc_s *)ioc_arg;
  bfa_ioc_hw_sem_get(ioc);
  return;
}
}
static void bfa_ioc_poll_fwinit(struct bfa_ioc_s *ioc ) 
{ 
  u32 fwstate ;
  enum bfi_ioc_state tmp ;

  {
  tmp = (*((ioc->ioc_hwif)->ioc_get_fwstate))(ioc);
  fwstate = tmp;
  __bfa_trc(ioc->trcmod, __trc_fileno___2, 3174, (unsigned long long )fwstate);
  if (fwstate == 6U) {
    (*(ioc->iocpf.fsm))((void *)(& ioc->iocpf), 4);
    return;
  } else {

  }
  if (ioc->iocpf.poll_time > 8999U) {
    bfa_iocpf_timeout((void *)ioc);
  } else {
    ioc->iocpf.poll_time = ioc->iocpf.poll_time + 200U;
    bfa_timer_begin(ioc->timer_mod, & ioc->ioc_timer, & bfa_iocpf_poll_timeout, (void *)ioc,
                    200U);
  }
  return;
}
}
static void bfa_iocpf_poll_timeout(void *ioc_arg ) 
{ 
  struct bfa_ioc_s *ioc ;

  {
  ioc = (struct bfa_ioc_s *)ioc_arg;
  bfa_ioc_poll_fwinit(ioc);
  return;
}
}
void bfa_timer_beat(struct bfa_timer_mod_s *mod ) 
{ 
  struct list_head *qh ;
  struct list_head *qe ;
  struct list_head *qe_next ;
  struct bfa_timer_s *elem ;
  struct list_head timedout_q ;
  int tmp ;
  int tmp___0 ;

  {
  qh = & mod->timer_q;
  INIT_LIST_HEAD(& timedout_q);
  qe = qh->next;
  goto ldv_49358;
  ldv_49357: 
  qe_next = qe->next;
  elem = (struct bfa_timer_s *)qe;
  if (elem->timeout <= 200) {
    elem->timeout = 0;
    list_del(& elem->qe);
    list_add_tail(& elem->qe, & timedout_q);
  } else {
    elem->timeout = elem->timeout + -200;
  }
  qe = qe_next;
  ldv_49358: ;
  if ((unsigned long )qe != (unsigned long )qh) {
    goto ldv_49357;
  } else {

  }

  goto ldv_49361;
  ldv_49360: 
  tmp = list_empty((struct list_head  const  *)(& timedout_q));
  if (tmp == 0) {
    *((struct list_head **)(& elem)) = timedout_q.next;
    ((*((struct list_head **)(& elem)))->next)->prev = & timedout_q;
    timedout_q.next = (*((struct list_head **)(& elem)))->next;
  } else {
    *((struct list_head **)(& elem)) = (struct list_head *)0;
  }
  (*(elem->timercb))(elem->arg);
  ldv_49361: 
  tmp___0 = list_empty((struct list_head  const  *)(& timedout_q));
  if (tmp___0 == 0) {
    goto ldv_49360;
  } else {

  }

  return;
}
}
void bfa_timer_begin(struct bfa_timer_mod_s *mod , struct bfa_timer_s *timer , void (*timercb)(void * ) ,
                     void *arg , unsigned int timeout ) 
{ 
  int __ret_warn_on ;
  long tmp ;
  int __ret_warn_on___0 ;
  int tmp___0 ;
  long tmp___1 ;

  {
  __ret_warn_on = (unsigned long )timercb == (unsigned long )((void (*)(void * ))0);
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_ioc.c",
                       3244);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  tmp___0 = bfa_q_is_on_q_func(& mod->timer_q, (struct list_head *)timer);
  __ret_warn_on___0 = tmp___0 != 0;
  tmp___1 = ldv__builtin_expect(__ret_warn_on___0 != 0, 0L);
  if (tmp___1 != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_ioc.c",
                       3245);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on___0 != 0, 0L);
  timer->timeout = (int )timeout;
  timer->timercb = timercb;
  timer->arg = arg;
  list_add_tail(& timer->qe, & mod->timer_q);
  return;
}
}
void bfa_timer_stop(struct bfa_timer_s *timer ) 
{ 
  int __ret_warn_on ;
  int tmp ;
  long tmp___0 ;

  {
  tmp = list_empty((struct list_head  const  *)(& timer->qe));
  __ret_warn_on = tmp != 0;
  tmp___0 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp___0 != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_ioc.c",
                       3260);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  list_del(& timer->qe);
  return;
}
}
static void bfa_ablk_config_swap(struct bfa_ablk_cfg_s *cfg ) 
{ 
  struct bfa_ablk_cfg_inst_s *cfg_inst ;
  int i ;
  int j ;
  u16 be16 ;
  __u16 tmp ;
  __u16 tmp___0 ;
  __u16 tmp___1 ;
  __u16 tmp___2 ;
  __u16 tmp___3 ;

  {
  i = 0;
  goto ldv_49391;
  ldv_49390: 
  cfg_inst = (struct bfa_ablk_cfg_inst_s *)(& cfg->inst) + (unsigned long )i;
  j = 0;
  goto ldv_49388;
  ldv_49387: 
  be16 = cfg_inst->pf_cfg[j].pers;
  tmp = __fswab16((int )be16);
  cfg_inst->pf_cfg[j].pers = tmp;
  be16 = cfg_inst->pf_cfg[j].num_qpairs;
  tmp___0 = __fswab16((int )be16);
  cfg_inst->pf_cfg[j].num_qpairs = tmp___0;
  be16 = cfg_inst->pf_cfg[j].num_vectors;
  tmp___1 = __fswab16((int )be16);
  cfg_inst->pf_cfg[j].num_vectors = tmp___1;
  be16 = cfg_inst->pf_cfg[j].bw_min;
  tmp___2 = __fswab16((int )be16);
  cfg_inst->pf_cfg[j].bw_min = tmp___2;
  be16 = cfg_inst->pf_cfg[j].bw_max;
  tmp___3 = __fswab16((int )be16);
  cfg_inst->pf_cfg[j].bw_max = tmp___3;
  j = j + 1;
  ldv_49388: ;
  if (j <= 15) {
    goto ldv_49387;
  } else {

  }
  i = i + 1;
  ldv_49391: ;
  if (i <= 1) {
    goto ldv_49390;
  } else {

  }

  return;
}
}
static void bfa_ablk_isr(void *cbarg , struct bfi_mbmsg_s *msg ) 
{ 
  struct bfa_ablk_s *ablk ;
  struct bfi_ablk_i2h_rsp_s *rsp ;
  void (*cbfn)(void * , enum bfa_status  ) ;
  int __ret_warn_on ;
  long tmp ;
  int __ret_warn_on___0 ;
  long tmp___0 ;

  {
  ablk = (struct bfa_ablk_s *)cbarg;
  rsp = (struct bfi_ablk_i2h_rsp_s *)msg;
  __ret_warn_on = (unsigned int )msg->mh.msg_class != 7U;
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_ioc.c",
                       3299);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  __bfa_trc((ablk->ioc)->trcmod, __trc_fileno___2, 3300, (unsigned long long )msg->mh.msg_id);
  switch ((int )msg->mh.msg_id) {
  case 129: ;
  if ((unsigned int )rsp->status == 0U) {
    memcpy((void *)ablk->cfg, (void const   *)ablk->dma_addr.kva, 560UL);
    bfa_ablk_config_swap(ablk->cfg);
    ablk->cfg = (struct bfa_ablk_cfg_s *)0;
  } else {

  }
  goto ldv_49403;
  case 130: ;
  case 131: 
  (ablk->ioc)->port_mode_cfg = rsp->port_mode;
  case 133: ;
  case 134: ;
  case 135: ;
  case 136: ;
  goto ldv_49403;
  case 132: 
  *(ablk->pcifn) = (u16 )rsp->pcifn;
  ablk->pcifn = (u16 *)0U;
  goto ldv_49403;
  default: 
  __ret_warn_on___0 = 1;
  tmp___0 = ldv__builtin_expect(__ret_warn_on___0 != 0, 0L);
  if (tmp___0 != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_ioc.c",
                       3330);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on___0 != 0, 0L);
  }
  ldv_49403: 
  ablk->busy = 0;
  if ((unsigned long )ablk->cbfn != (unsigned long )((void (*)(void * , enum bfa_status  ))0)) {
    cbfn = ablk->cbfn;
    ablk->cbfn = (void (*)(void * , enum bfa_status  ))0;
    (*cbfn)(ablk->cbarg, (enum bfa_status )rsp->status);
  } else {

  }
  return;
}
}
static void bfa_ablk_notify(void *cbarg , enum bfa_ioc_event_e event ) 
{ 
  struct bfa_ablk_s *ablk ;
  int __ret_warn_on ;
  long tmp ;
  int __ret_warn_on___0 ;
  long tmp___0 ;

  {
  ablk = (struct bfa_ablk_s *)cbarg;
  __bfa_trc((ablk->ioc)->trcmod, __trc_fileno___2, 3346, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 1U: 
  __ret_warn_on = (unsigned int )ablk->busy != 0U;
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_ioc.c",
                       3350);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  goto ldv_49422;
  case 2U: ;
  case 3U: 
  ablk->pcifn = (u16 *)0U;
  if ((unsigned int )ablk->busy != 0U) {
    if ((unsigned long )ablk->cbfn != (unsigned long )((void (*)(void * , enum bfa_status  ))0)) {
      (*(ablk->cbfn))(ablk->cbarg, 1);
    } else {

    }
    ablk->cbfn = (void (*)(void * , enum bfa_status  ))0;
    ablk->busy = 0;
  } else {

  }
  goto ldv_49422;
  default: 
  __ret_warn_on___0 = 1;
  tmp___0 = ldv__builtin_expect(__ret_warn_on___0 != 0, 0L);
  if (tmp___0 != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_ioc.c",
                       3366);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on___0 != 0, 0L);
  goto ldv_49422;
  }
  ldv_49422: ;
  return;
}
}
u32 bfa_ablk_meminfo(void) 
{ 


  {
  return (768U);
}
}
void bfa_ablk_memclaim(struct bfa_ablk_s *ablk , u8 *dma_kva , u64 dma_pa ) 
{ 


  {
  ablk->dma_addr.kva = (void *)dma_kva;
  ablk->dma_addr.pa = dma_pa;
  return;
}
}
void bfa_ablk_attach(struct bfa_ablk_s *ablk , struct bfa_ioc_s *ioc ) 
{ 


  {
  ablk->ioc = ioc;
  bfa_ioc_mbox_regisr(ablk->ioc, 7, & bfa_ablk_isr, (void *)ablk);
  ((struct list_head *)(& ablk->ioc_notify))->next = (struct list_head *)0;
  ((struct list_head *)(& ablk->ioc_notify))->prev = (struct list_head *)0;
  ablk->ioc_notify.cbfn = & bfa_ablk_notify;
  ablk->ioc_notify.cbarg = (void *)ablk;
  list_add_tail(& ablk->ioc_notify.qe, & (ablk->ioc)->notify_q);
  return;
}
}
enum bfa_status bfa_ablk_query(struct bfa_ablk_s *ablk , struct bfa_ablk_cfg_s *ablk_cfg ,
                               void (*cbfn)(void * , enum bfa_status  ) , void *cbarg ) 
{ 
  struct bfi_ablk_h2i_query_s *m ;
  int __ret_warn_on ;
  long tmp ;
  enum bfa_boolean tmp___0 ;

  {
  __ret_warn_on = (unsigned long )ablk_cfg == (unsigned long )((struct bfa_ablk_cfg_s *)0);
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_ioc.c",
                       3401);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  tmp___0 = bfa_ioc_is_operational(ablk->ioc);
  if ((unsigned int )tmp___0 == 0U) {
    __bfa_trc((ablk->ioc)->trcmod, __trc_fileno___2, 3404, 56ULL);
    return (56);
  } else {

  }
  if ((unsigned int )ablk->busy != 0U) {
    __bfa_trc((ablk->ioc)->trcmod, __trc_fileno___2, 3409, 13ULL);
    return (13);
  } else {

  }
  ablk->cfg = ablk_cfg;
  ablk->cbfn = cbfn;
  ablk->cbarg = cbarg;
  ablk->busy = 1;
  m = (struct bfi_ablk_h2i_query_s *)(& ablk->mb.msg);
  m->mh.msg_class = 7U;
  m->mh.msg_id = 1U;
  m->mh.mtag.h2i.fn_lpu = (ablk->ioc)->port_id;
  __bfa_dma_be_addr_set(& m->addr, ablk->dma_addr.pa);
  bfa_ioc_mbox_queue(ablk->ioc, & ablk->mb);
  return (0);
}
}
enum bfa_status bfa_ablk_pf_create(struct bfa_ablk_s *ablk , u16 *pcifn , u8 port ,
                                   enum bfi_pcifn_class personality , u16 bw_min ,
                                   u16 bw_max , void (*cbfn)(void * , enum bfa_status  ) ,
                                   void *cbarg ) 
{ 
  struct bfi_ablk_h2i_pf_req_s *m ;
  enum bfa_boolean tmp ;
  __u16 tmp___0 ;
  __u16 tmp___1 ;
  __u16 tmp___2 ;

  {
  tmp = bfa_ioc_is_operational(ablk->ioc);
  if ((unsigned int )tmp == 0U) {
    __bfa_trc((ablk->ioc)->trcmod, __trc_fileno___2, 3436, 56ULL);
    return (56);
  } else {

  }
  if ((unsigned int )ablk->busy != 0U) {
    __bfa_trc((ablk->ioc)->trcmod, __trc_fileno___2, 3441, 13ULL);
    return (13);
  } else {

  }
  ablk->pcifn = pcifn;
  ablk->cbfn = cbfn;
  ablk->cbarg = cbarg;
  ablk->busy = 1;
  m = (struct bfi_ablk_h2i_pf_req_s *)(& ablk->mb.msg);
  m->mh.msg_class = 7U;
  m->mh.msg_id = 4U;
  m->mh.mtag.h2i.fn_lpu = (ablk->ioc)->port_id;
  tmp___0 = __fswab16((int )((unsigned short )personality));
  m->pers = tmp___0;
  tmp___1 = __fswab16((int )bw_min);
  m->bw_min = tmp___1;
  tmp___2 = __fswab16((int )bw_max);
  m->bw_max = tmp___2;
  m->port = port;
  bfa_ioc_mbox_queue(ablk->ioc, & ablk->mb);
  return (0);
}
}
enum bfa_status bfa_ablk_pf_delete(struct bfa_ablk_s *ablk , int pcifn , void (*cbfn)(void * ,
                                                                                      enum bfa_status  ) ,
                                   void *cbarg ) 
{ 
  struct bfi_ablk_h2i_pf_req_s *m ;
  enum bfa_boolean tmp ;

  {
  tmp = bfa_ioc_is_operational(ablk->ioc);
  if ((unsigned int )tmp == 0U) {
    __bfa_trc((ablk->ioc)->trcmod, __trc_fileno___2, 3469, 56ULL);
    return (56);
  } else {

  }
  if ((unsigned int )ablk->busy != 0U) {
    __bfa_trc((ablk->ioc)->trcmod, __trc_fileno___2, 3474, 13ULL);
    return (13);
  } else {

  }
  ablk->cbfn = cbfn;
  ablk->cbarg = cbarg;
  ablk->busy = 1;
  m = (struct bfi_ablk_h2i_pf_req_s *)(& ablk->mb.msg);
  m->mh.msg_class = 7U;
  m->mh.msg_id = 5U;
  m->mh.mtag.h2i.fn_lpu = (ablk->ioc)->port_id;
  m->pcifn = (unsigned char )pcifn;
  bfa_ioc_mbox_queue(ablk->ioc, & ablk->mb);
  return (0);
}
}
enum bfa_status bfa_ablk_adapter_config(struct bfa_ablk_s *ablk , enum bfa_mode_s mode ,
                                        int max_pf , int max_vf , void (*cbfn)(void * ,
                                                                               enum bfa_status  ) ,
                                        void *cbarg ) 
{ 
  struct bfi_ablk_h2i_cfg_req_s *m ;
  enum bfa_boolean tmp ;

  {
  tmp = bfa_ioc_is_operational(ablk->ioc);
  if ((unsigned int )tmp == 0U) {
    __bfa_trc((ablk->ioc)->trcmod, __trc_fileno___2, 3498, 56ULL);
    return (56);
  } else {

  }
  if ((unsigned int )ablk->busy != 0U) {
    __bfa_trc((ablk->ioc)->trcmod, __trc_fileno___2, 3503, 13ULL);
    return (13);
  } else {

  }
  ablk->cbfn = cbfn;
  ablk->cbarg = cbarg;
  ablk->busy = 1;
  m = (struct bfi_ablk_h2i_cfg_req_s *)(& ablk->mb.msg);
  m->mh.msg_class = 7U;
  m->mh.msg_id = 2U;
  m->mh.mtag.h2i.fn_lpu = (ablk->ioc)->port_id;
  m->mode = (unsigned char )mode;
  m->max_pf = (unsigned char )max_pf;
  m->max_vf = (unsigned char )max_vf;
  bfa_ioc_mbox_queue(ablk->ioc, & ablk->mb);
  return (0);
}
}
enum bfa_status bfa_ablk_port_config(struct bfa_ablk_s *ablk , int port , enum bfa_mode_s mode ,
                                     int max_pf , int max_vf , void (*cbfn)(void * ,
                                                                            enum bfa_status  ) ,
                                     void *cbarg ) 
{ 
  struct bfi_ablk_h2i_cfg_req_s *m ;
  enum bfa_boolean tmp ;

  {
  tmp = bfa_ioc_is_operational(ablk->ioc);
  if ((unsigned int )tmp == 0U) {
    __bfa_trc((ablk->ioc)->trcmod, __trc_fileno___2, 3529, 56ULL);
    return (56);
  } else {

  }
  if ((unsigned int )ablk->busy != 0U) {
    __bfa_trc((ablk->ioc)->trcmod, __trc_fileno___2, 3534, 13ULL);
    return (13);
  } else {

  }
  ablk->cbfn = cbfn;
  ablk->cbarg = cbarg;
  ablk->busy = 1;
  m = (struct bfi_ablk_h2i_cfg_req_s *)(& ablk->mb.msg);
  m->mh.msg_class = 7U;
  m->mh.msg_id = 3U;
  m->mh.mtag.h2i.fn_lpu = (ablk->ioc)->port_id;
  m->port = (unsigned char )port;
  m->mode = (unsigned char )mode;
  m->max_pf = (unsigned char )max_pf;
  m->max_vf = (unsigned char )max_vf;
  bfa_ioc_mbox_queue(ablk->ioc, & ablk->mb);
  return (0);
}
}
enum bfa_status bfa_ablk_pf_update(struct bfa_ablk_s *ablk , int pcifn , u16 bw_min ,
                                   u16 bw_max , void (*cbfn)(void * , enum bfa_status  ) ,
                                   void *cbarg ) 
{ 
  struct bfi_ablk_h2i_pf_req_s *m ;
  enum bfa_boolean tmp ;
  __u16 tmp___0 ;
  __u16 tmp___1 ;

  {
  tmp = bfa_ioc_is_operational(ablk->ioc);
  if ((unsigned int )tmp == 0U) {
    __bfa_trc((ablk->ioc)->trcmod, __trc_fileno___2, 3561, 56ULL);
    return (56);
  } else {

  }
  if ((unsigned int )ablk->busy != 0U) {
    __bfa_trc((ablk->ioc)->trcmod, __trc_fileno___2, 3566, 13ULL);
    return (13);
  } else {

  }
  ablk->cbfn = cbfn;
  ablk->cbarg = cbarg;
  ablk->busy = 1;
  m = (struct bfi_ablk_h2i_pf_req_s *)(& ablk->mb.msg);
  m->mh.msg_class = 7U;
  m->mh.msg_id = 6U;
  m->mh.mtag.h2i.fn_lpu = (ablk->ioc)->port_id;
  m->pcifn = (unsigned char )pcifn;
  tmp___0 = __fswab16((int )bw_min);
  m->bw_min = tmp___0;
  tmp___1 = __fswab16((int )bw_max);
  m->bw_max = tmp___1;
  bfa_ioc_mbox_queue(ablk->ioc, & ablk->mb);
  return (0);
}
}
enum bfa_status bfa_ablk_optrom_en(struct bfa_ablk_s *ablk , void (*cbfn)(void * ,
                                                                          enum bfa_status  ) ,
                                   void *cbarg ) 
{ 
  struct bfi_ablk_h2i_optrom_s *m ;
  enum bfa_boolean tmp ;

  {
  tmp = bfa_ioc_is_operational(ablk->ioc);
  if ((unsigned int )tmp == 0U) {
    __bfa_trc((ablk->ioc)->trcmod, __trc_fileno___2, 3591, 56ULL);
    return (56);
  } else {

  }
  if ((unsigned int )ablk->busy != 0U) {
    __bfa_trc((ablk->ioc)->trcmod, __trc_fileno___2, 3596, 13ULL);
    return (13);
  } else {

  }
  ablk->cbfn = cbfn;
  ablk->cbarg = cbarg;
  ablk->busy = 1;
  m = (struct bfi_ablk_h2i_optrom_s *)(& ablk->mb.msg);
  m->mh.msg_class = 7U;
  m->mh.msg_id = 7U;
  m->mh.mtag.h2i.fn_lpu = (ablk->ioc)->port_id;
  bfa_ioc_mbox_queue(ablk->ioc, & ablk->mb);
  return (0);
}
}
enum bfa_status bfa_ablk_optrom_dis(struct bfa_ablk_s *ablk , void (*cbfn)(void * ,
                                                                           enum bfa_status  ) ,
                                    void *cbarg ) 
{ 
  struct bfi_ablk_h2i_optrom_s *m ;
  enum bfa_boolean tmp ;

  {
  tmp = bfa_ioc_is_operational(ablk->ioc);
  if ((unsigned int )tmp == 0U) {
    __bfa_trc((ablk->ioc)->trcmod, __trc_fileno___2, 3618, 56ULL);
    return (56);
  } else {

  }
  if ((unsigned int )ablk->busy != 0U) {
    __bfa_trc((ablk->ioc)->trcmod, __trc_fileno___2, 3623, 13ULL);
    return (13);
  } else {

  }
  ablk->cbfn = cbfn;
  ablk->cbarg = cbarg;
  ablk->busy = 1;
  m = (struct bfi_ablk_h2i_optrom_s *)(& ablk->mb.msg);
  m->mh.msg_class = 7U;
  m->mh.msg_id = 8U;
  m->mh.mtag.h2i.fn_lpu = (ablk->ioc)->port_id;
  bfa_ioc_mbox_queue(ablk->ioc, & ablk->mb);
  return (0);
}
}
static void bfa_sfp_getdata_send(struct bfa_sfp_s *sfp ) ;
static void bfa_sfp_media_get(struct bfa_sfp_s *sfp ) ;
static enum bfa_status bfa_sfp_speed_valid(struct bfa_sfp_s *sfp , enum bfa_port_speed portspeed ) ;
static void bfa_cb_sfp_show(struct bfa_sfp_s *sfp ) 
{ 


  {
  __bfa_trc(sfp->trcmod, __trc_fileno___2, 3652, (unsigned long long )sfp->lock);
  if ((unsigned long )sfp->cbfn != (unsigned long )((void (*)(void * , enum bfa_status  ))0)) {
    (*(sfp->cbfn))(sfp->cbarg, (enum bfa_status )sfp->status);
  } else {

  }
  sfp->lock = 0U;
  sfp->cbfn = (void (*)(void * , enum bfa_status  ))0;
  return;
}
}
static void bfa_cb_sfp_state_query(struct bfa_sfp_s *sfp ) 
{ 
  enum bfa_status tmp ;

  {
  __bfa_trc(sfp->trcmod, __trc_fileno___2, 3662, (unsigned long long )sfp->portspeed);
  if ((unsigned long )sfp->media != (unsigned long )((enum bfa_defs_sfp_media_e *)0)) {
    bfa_sfp_media_get(sfp);
    if ((unsigned long )sfp->state_query_cbfn != (unsigned long )((void (*)(void * ,
                                                                            enum bfa_status  ))0)) {
      (*(sfp->state_query_cbfn))(sfp->state_query_cbarg, (enum bfa_status )sfp->status);
    } else {

    }
    sfp->media = (enum bfa_defs_sfp_media_e *)0;
  } else {

  }
  if ((unsigned int )sfp->portspeed != 0U) {
    tmp = bfa_sfp_speed_valid(sfp, sfp->portspeed);
    sfp->status = (u32 )tmp;
    if ((unsigned long )sfp->state_query_cbfn != (unsigned long )((void (*)(void * ,
                                                                            enum bfa_status  ))0)) {
      (*(sfp->state_query_cbfn))(sfp->state_query_cbarg, (enum bfa_status )sfp->status);
    } else {

    }
    sfp->portspeed = 0;
  } else {

  }
  sfp->state_query_lock = 0U;
  sfp->state_query_cbfn = (void (*)(void * , enum bfa_status  ))0;
  return;
}
}
static void bfa_sfp_notify(void *sfp_arg , enum bfa_ioc_event_e event ) 
{ 
  struct bfa_sfp_s *sfp ;

  {
  sfp = (struct bfa_sfp_s *)sfp_arg;
  __bfa_trc(sfp->trcmod, __trc_fileno___2, 3691, (unsigned long long )event);
  __bfa_trc(sfp->trcmod, __trc_fileno___2, 3692, (unsigned long long )sfp->lock);
  __bfa_trc(sfp->trcmod, __trc_fileno___2, 3693, (unsigned long long )sfp->state_query_lock);
  switch ((unsigned int )event) {
  case 2U: ;
  case 3U: ;
  if ((unsigned int )sfp->lock != 0U) {
    sfp->status = 56U;
    bfa_cb_sfp_show(sfp);
  } else {

  }
  if ((unsigned int )sfp->state_query_lock != 0U) {
    sfp->status = 56U;
    bfa_cb_sfp_state_query(sfp);
  } else {

  }
  goto ldv_49527;
  default: ;
  goto ldv_49527;
  }
  ldv_49527: ;
  return;
}
}
static void bfa_sfp_scn_aen_post(struct bfa_sfp_s *sfp , struct bfi_sfp_scn_s *rsp ) 
{ 
  struct bfad_s *bfad ;
  struct bfa_aen_entry_s *aen_entry ;
  enum bfa_port_aen_event aen_evt ;
  unsigned long _flags ;
  raw_spinlock_t *tmp ;
  int tmp___0 ;
  enum bfa_ioc_type_e tmp___1 ;
  int __ret_warn_on ;
  long tmp___2 ;

  {
  bfad = (struct bfad_s *)((sfp->ioc)->bfa)->bfad;
  aen_evt = 0;
  __bfa_trc(sfp->trcmod, __trc_fileno___2, 3725, (((unsigned long long )rsp->pomlvl << 16) | ((unsigned long long )rsp->sfpid << 8)) | (unsigned long long )rsp->event);
  tmp = spinlock_check(& bfad->bfad_aen_spinlock);
  _flags = _raw_spin_lock_irqsave(tmp);
  tmp___0 = list_empty((struct list_head  const  *)(& bfad->free_aen_q));
  if (tmp___0 == 0) {
    *((struct list_head **)(& aen_entry)) = bfad->free_aen_q.next;
    ((*((struct list_head **)(& aen_entry)))->next)->prev = & bfad->free_aen_q;
    bfad->free_aen_q.next = (*((struct list_head **)(& aen_entry)))->next;
  } else {
    *((struct list_head **)(& aen_entry)) = (struct list_head *)0;
  }
  if ((unsigned long )aen_entry != (unsigned long )((struct bfa_aen_entry_s *)0)) {
    list_add_tail(& aen_entry->qe, & bfad->active_aen_q);
  } else {

  }
  spin_unlock_irqrestore(& bfad->bfad_aen_spinlock, _flags);
  if ((unsigned long )aen_entry == (unsigned long )((struct bfa_aen_entry_s *)0)) {
    return;
  } else {

  }
  tmp___1 = bfa_ioc_get_type(sfp->ioc);
  aen_entry->aen_data.port.ioc_type = (u16 )tmp___1;
  aen_entry->aen_data.port.pwwn = ((sfp->ioc)->attr)->pwwn;
  aen_entry->aen_data.port.mac = bfa_ioc_get_mac(sfp->ioc);
  switch ((int )rsp->event) {
  case 1: 
  aen_evt = 4;
  goto ldv_49541;
  case 0: 
  aen_evt = 5;
  goto ldv_49541;
  case 3: 
  aen_evt = 14;
  goto ldv_49541;
  case 4: 
  aen_evt = 15;
  goto ldv_49541;
  case 2: 
  aen_evt = 6;
  aen_entry->aen_data.port.level = (u16 )rsp->pomlvl;
  goto ldv_49541;
  default: 
  __bfa_trc(sfp->trcmod, __trc_fileno___2, 3753, (unsigned long long )rsp->event);
  __ret_warn_on = 1;
  tmp___2 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp___2 != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_ioc.c",
                       3754);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  }
  ldv_49541: 
  do_gettimeofday(& aen_entry->aen_tv);
  aen_entry->bfad_num = bfad->inst_no;
  (sfp->ioc)->ioc_aen_seq = (sfp->ioc)->ioc_aen_seq + 1;
  aen_entry->seq_num = (u32 )(sfp->ioc)->ioc_aen_seq;
  aen_entry->aen_category = 2;
  aen_entry->aen_type = (u32 )aen_evt;
  if ((bfad->bfad_flags & 512U) != 0U) {
    queue_work___0((bfad->im)->drv_workq, & (bfad->im)->aen_im_notify_work);
  } else {

  }
  return;
}
}
static void bfa_sfp_getdata_send(struct bfa_sfp_s *sfp ) 
{ 
  struct bfi_sfp_req_s *req ;

  {
  req = (struct bfi_sfp_req_s *)(& sfp->mbcmd.msg);
  __bfa_trc(sfp->trcmod, __trc_fileno___2, 3770, (unsigned long long )req->memtype);
  req->mh.msg_class = 22U;
  req->mh.msg_id = 1U;
  req->mh.mtag.h2i.fn_lpu = (sfp->ioc)->port_id;
  bfa_ioc_mbox_queue(sfp->ioc, & sfp->mbcmd);
  return;
}
}
static void bfa_sfp_getdata(struct bfa_sfp_s *sfp , enum bfi_sfp_mem_e memtype ) 
{ 
  struct bfi_sfp_req_s *req ;
  int __ret_warn_on ;
  long tmp ;

  {
  req = (struct bfi_sfp_req_s *)(& sfp->mbcmd.msg);
  __ret_warn_on = (unsigned int )sfp->lock != 0U;
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_ioc.c",
                       3788);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  __bfa_trc(sfp->trcmod, __trc_fileno___2, 3789, (unsigned long long )sfp->state);
  sfp->lock = 1U;
  sfp->memtype = memtype;
  req->memtype = (u8 )memtype;
  __bfa_alen_set(& req->alen, 248U, sfp->dbuf_pa);
  bfa_sfp_getdata_send(sfp);
  return;
}
}
static void bfa_sfp_scn(struct bfa_sfp_s *sfp , struct bfi_mbmsg_s *msg ) 
{ 
  struct bfi_sfp_scn_s *rsp ;
  int __ret_warn_on ;
  long tmp ;

  {
  rsp = (struct bfi_sfp_scn_s *)msg;
  switch ((int )rsp->event) {
  case 1: 
  sfp->state = 2U;
  sfp->data_valid = 0U;
  bfa_sfp_scn_aen_post(sfp, rsp);
  goto ldv_49566;
  case 0: 
  sfp->state = 1U;
  sfp->data_valid = 0U;
  bfa_sfp_scn_aen_post(sfp, rsp);
  goto ldv_49566;
  case 3: 
  sfp->state = 5U;
  sfp->data_valid = 0U;
  bfa_sfp_scn_aen_post(sfp, rsp);
  goto ldv_49566;
  case 4: 
  sfp->state = 4U;
  bfa_sfp_scn_aen_post(sfp, rsp);
  if ((unsigned int )sfp->lock == 0U) {
    bfa_sfp_getdata(sfp, 1);
  } else {

  }
  goto ldv_49566;
  case 2: 
  bfa_sfp_scn_aen_post(sfp, rsp);
  goto ldv_49566;
  case 5: 
  sfp->state = 3U;
  if ((unsigned int )sfp->lock == 0U) {
    bfa_sfp_getdata(sfp, 1);
  } else {

  }
  goto ldv_49566;
  default: 
  __bfa_trc(sfp->trcmod, __trc_fileno___2, 3840, (unsigned long long )rsp->event);
  __ret_warn_on = 1;
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_ioc.c",
                       3841);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  }
  ldv_49566: ;
  return;
}
}
static void bfa_sfp_show_comp(struct bfa_sfp_s *sfp , struct bfi_mbmsg_s *msg ) 
{ 
  struct bfi_sfp_rsp_s *rsp ;
  u32 size ;
  u8 *des ;

  {
  rsp = (struct bfi_sfp_rsp_s *)msg;
  if ((unsigned int )sfp->lock == 0U) {
    __bfa_trc(sfp->trcmod, __trc_fileno___2, 3857, (unsigned long long )sfp->lock);
    return;
  } else {

  }
  __bfa_trc(sfp->trcmod, __trc_fileno___2, 3861, (unsigned long long )rsp->status);
  if ((unsigned int )rsp->status == 0U) {
    sfp->data_valid = 1U;
    if ((unsigned int )sfp->state == 3U) {
      sfp->status = 0U;
    } else
    if ((unsigned int )sfp->state == 4U) {
      sfp->status = 10U;
    } else {
      __bfa_trc(sfp->trcmod, __trc_fileno___2, 3869, (unsigned long long )sfp->state);
    }
  } else {
    sfp->data_valid = 0U;
    sfp->status = (u32 )rsp->status;
  }
  __bfa_trc(sfp->trcmod, __trc_fileno___2, 3876, (unsigned long long )sfp->memtype);
  if ((unsigned int )sfp->memtype == 2U) {
    __bfa_trc(sfp->trcmod, __trc_fileno___2, 3878, (unsigned long long )sfp->data_valid);
    if ((unsigned int )sfp->data_valid != 0U) {
      size = 248U;
      des = (u8 *)(& sfp->sfpmem);
      memcpy((void *)des, (void const   *)sfp->dbuf_kva, (size_t )size);
    } else {

    }
    bfa_cb_sfp_show(sfp);
  } else {
    sfp->lock = 0U;
  }
  __bfa_trc(sfp->trcmod, __trc_fileno___2, 3891, (unsigned long long )sfp->state_query_lock);
  if ((unsigned int )sfp->state_query_lock != 0U) {
    sfp->state = rsp->state;
    bfa_cb_sfp_state_query(sfp);
  } else {

  }
  return;
}
}
static void bfa_sfp_state_query(struct bfa_sfp_s *sfp ) 
{ 
  struct bfi_sfp_req_s *req ;
  int __ret_warn_on ;
  long tmp ;
  int __ret_warn_on___0 ;
  long tmp___0 ;

  {
  req = (struct bfi_sfp_req_s *)(& sfp->mbcmd.msg);
  __ret_warn_on = (unsigned int )sfp->state != 0U;
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_ioc.c",
                       3908);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  __ret_warn_on___0 = (unsigned int )sfp->state_query_lock != 0U;
  tmp___0 = ldv__builtin_expect(__ret_warn_on___0 != 0, 0L);
  if (tmp___0 != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_ioc.c",
                       3909);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on___0 != 0, 0L);
  __bfa_trc(sfp->trcmod, __trc_fileno___2, 3910, (unsigned long long )sfp->state);
  sfp->state_query_lock = 1U;
  req->memtype = 0U;
  if ((unsigned int )sfp->lock == 0U) {
    bfa_sfp_getdata(sfp, 1);
  } else {

  }
  return;
}
}
static void bfa_sfp_media_get(struct bfa_sfp_s *sfp ) 
{ 
  enum bfa_defs_sfp_media_e *media ;
  union sfp_xcvr_e10g_code_u e10g ;
  struct sfp_mem_s *sfpmem ;
  u16 xmtr_tech ;

  {
  media = sfp->media;
  *media = 0;
  if ((unsigned int )sfp->state == 4U) {
    *media = 5;
  } else
  if ((unsigned int )sfp->state == 3U) {
    sfpmem = (struct sfp_mem_s *)sfp->dbuf_kva;
    xmtr_tech = (u16 )((int )((short )(((int )sfpmem->srlid_base.xcvr[4] & 3) << 7)) | (int )((short )((int )sfpmem->srlid_base.xcvr[5] >> 1)));
    e10g.b = sfpmem->srlid_base.xcvr[0];
    __bfa_trc(sfp->trcmod, __trc_fileno___2, 3935, (unsigned long long )e10g.b);
    __bfa_trc(sfp->trcmod, __trc_fileno___2, 3936, (unsigned long long )xmtr_tech);
    if (((int )xmtr_tech & 1 || ((int )xmtr_tech & 2) != 0) || ((int )xmtr_tech & 4) != 0) {
      *media = 1;
    } else
    if (((int )xmtr_tech & 64) != 0 || ((int )xmtr_tech & 128) != 0) {
      *media = 4;
    } else
    if (((int )xmtr_tech & 8) != 0 || ((int )xmtr_tech & 256) != 0) {
      *media = 2;
    } else
    if ((((int )xmtr_tech & 16) != 0 || ((int )xmtr_tech & 32) != 0) || ((int )xmtr_tech & 512) != 0) {
      *media = 3;
    } else
    if ((unsigned int )*((unsigned char *)(& e10g) + 0UL) != 0U) {
      *media = 3;
    } else
    if ((unsigned int )*((unsigned char *)(& e10g) + 0UL) != 0U && (unsigned int )*((unsigned char *)(& e10g) + 0UL) != 0U) {
      *media = 2;
    } else
    if ((unsigned int )*((unsigned char *)(& e10g) + 0UL) != 0U) {
      *media = 0;
    } else {
      __bfa_trc(sfp->trcmod, __trc_fileno___2, 3960, 0ULL);
    }
  } else {
    __bfa_trc(sfp->trcmod, __trc_fileno___2, 3962, (unsigned long long )sfp->state);
  }
  return;
}
}
static enum bfa_status bfa_sfp_speed_valid(struct bfa_sfp_s *sfp , enum bfa_port_speed portspeed ) 
{ 
  struct sfp_mem_s *sfpmem ;
  struct sfp_xcvr_s *xcvr ;
  union sfp_xcvr_fc3_code_u fc3 ;
  union sfp_xcvr_e10g_code_u e10g ;

  {
  sfpmem = (struct sfp_mem_s *)sfp->dbuf_kva;
  xcvr = (struct sfp_xcvr_s *)(& sfpmem->srlid_base.xcvr);
  fc3 = xcvr->fc3;
  e10g = xcvr->e10g;
  if ((unsigned int )portspeed == 10U) {
    if ((unsigned int )*((unsigned char *)(& e10g) + 0UL) != 0U || (unsigned int )*((unsigned char *)(& e10g) + 0UL) != 0U) {
      return (0);
    } else {
      __bfa_trc(sfp->trcmod, __trc_fileno___2, 3977, (unsigned long long )e10g.b);
      return (23);
    }
  } else {

  }
  if (((((((unsigned int )portspeed & 16U) != 0U && (unsigned int )*((unsigned char *)(& fc3) + 0UL) != 0U) || (((unsigned int )portspeed & 8U) != 0U && (unsigned int )*((unsigned char *)(& fc3) + 0UL) != 0U)) || (((unsigned int )portspeed & 4U) != 0U && (unsigned int )*((unsigned char *)(& fc3) + 0UL) != 0U)) || (((unsigned int )portspeed & 2U) != 0U && (unsigned int )*((unsigned char *)(& fc3) + 0UL) != 0U)) || ((int )portspeed & 1 && (unsigned int )*((unsigned char *)(& fc3) + 0UL) != 0U)) {
    return (0);
  } else {
    __bfa_trc(sfp->trcmod, __trc_fileno___2, 3988, (unsigned long long )portspeed);
    __bfa_trc(sfp->trcmod, __trc_fileno___2, 3989, (unsigned long long )fc3.b);
    __bfa_trc(sfp->trcmod, __trc_fileno___2, 3990, (unsigned long long )e10g.b);
    return (23);
  }
}
}
void bfa_sfp_intr(void *sfparg , struct bfi_mbmsg_s *msg ) 
{ 
  struct bfa_sfp_s *sfp ;
  int __ret_warn_on ;
  long tmp ;

  {
  sfp = (struct bfa_sfp_s *)sfparg;
  switch ((int )msg->mh.msg_id) {
  case 129: 
  bfa_sfp_show_comp(sfp, msg);
  goto ldv_49611;
  case 130: 
  bfa_sfp_scn(sfp, msg);
  goto ldv_49611;
  default: 
  __bfa_trc(sfp->trcmod, __trc_fileno___2, 4013, (unsigned long long )msg->mh.msg_id);
  __ret_warn_on = 1;
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_ioc.c",
                       4014);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  }
  ldv_49611: ;
  return;
}
}
u32 bfa_sfp_meminfo(void) 
{ 


  {
  return (256U);
}
}
void bfa_sfp_attach(struct bfa_sfp_s *sfp , struct bfa_ioc_s *ioc , void *dev , struct bfa_trc_mod_s *trcmod ) 
{ 


  {
  sfp->dev = dev;
  sfp->ioc = ioc;
  sfp->trcmod = trcmod;
  sfp->cbfn = (void (*)(void * , enum bfa_status  ))0;
  sfp->cbarg = (void *)0;
  sfp->sfpmem = (struct sfp_mem_s *)0;
  sfp->lock = 0U;
  sfp->data_valid = 0U;
  sfp->state = 0U;
  sfp->state_query_lock = 0U;
  sfp->state_query_cbfn = (void (*)(void * , enum bfa_status  ))0;
  sfp->state_query_cbarg = (void *)0;
  sfp->media = (enum bfa_defs_sfp_media_e *)0;
  sfp->portspeed = 0;
  sfp->is_elb = 0U;
  bfa_ioc_mbox_regisr(sfp->ioc, 22, & bfa_sfp_intr, (void *)sfp);
  ((struct list_head *)(& sfp->ioc_notify))->next = (struct list_head *)0;
  ((struct list_head *)(& sfp->ioc_notify))->prev = (struct list_head *)0;
  sfp->ioc_notify.cbfn = & bfa_sfp_notify;
  sfp->ioc_notify.cbarg = (void *)sfp;
  list_add_tail(& sfp->ioc_notify.qe, & (sfp->ioc)->notify_q);
  return;
}
}
void bfa_sfp_memclaim(struct bfa_sfp_s *sfp , u8 *dm_kva , u64 dm_pa ) 
{ 


  {
  sfp->dbuf_kva = dm_kva;
  sfp->dbuf_pa = dm_pa;
  memset((void *)sfp->dbuf_kva, 0, 248UL);
  dm_kva = dm_kva + 256UL;
  dm_pa = dm_pa + 256ULL;
  return;
}
}
enum bfa_status bfa_sfp_show(struct bfa_sfp_s *sfp , struct sfp_mem_s *sfpmem , void (*cbfn)(void * ,
                                                                                             enum bfa_status  ) ,
                             void *cbarg ) 
{ 
  enum bfa_boolean tmp ;

  {
  tmp = bfa_ioc_is_operational(sfp->ioc);
  if ((unsigned int )tmp == 0U) {
    __bfa_trc(sfp->trcmod, __trc_fileno___2, 4085, 0ULL);
    return (61);
  } else {

  }
  if ((unsigned int )sfp->lock != 0U) {
    __bfa_trc(sfp->trcmod, __trc_fileno___2, 4090, 0ULL);
    return (13);
  } else {

  }
  sfp->cbfn = cbfn;
  sfp->cbarg = cbarg;
  sfp->sfpmem = sfpmem;
  bfa_sfp_getdata(sfp, 2);
  return (0);
}
}
enum bfa_status bfa_sfp_media(struct bfa_sfp_s *sfp , enum bfa_defs_sfp_media_e *media ,
                              void (*cbfn)(void * , enum bfa_status  ) , void *cbarg ) 
{ 
  enum bfa_boolean tmp ;

  {
  tmp = bfa_ioc_is_operational(sfp->ioc);
  if ((unsigned int )tmp == 0U) {
    __bfa_trc(sfp->trcmod, __trc_fileno___2, 4115, 0ULL);
    return (61);
  } else {

  }
  sfp->media = media;
  if ((unsigned int )sfp->state == 0U) {
    if ((unsigned int )sfp->state_query_lock != 0U) {
      __bfa_trc(sfp->trcmod, __trc_fileno___2, 4122, 0ULL);
      return (13);
    } else {
      sfp->state_query_cbfn = cbfn;
      sfp->state_query_cbarg = cbarg;
      bfa_sfp_state_query(sfp);
      return (159);
    }
  } else {

  }
  bfa_sfp_media_get(sfp);
  return (0);
}
}
enum bfa_status bfa_sfp_speed(struct bfa_sfp_s *sfp , enum bfa_port_speed portspeed ,
                              void (*cbfn)(void * , enum bfa_status  ) , void *cbarg ) 
{ 
  int __ret_warn_on ;
  long tmp ;
  enum bfa_boolean tmp___0 ;
  enum bfa_status tmp___1 ;

  {
  __ret_warn_on = (unsigned int )portspeed == 0U;
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_ioc.c",
                       4147);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  tmp___0 = bfa_ioc_is_operational(sfp->ioc);
  if ((unsigned int )tmp___0 == 0U) {
    return (61);
  } else {

  }
  if ((((((((sfp->ioc)->attr)->card_type == 804U || ((sfp->ioc)->attr)->card_type == 1007U) || ((sfp->ioc)->attr)->card_type == 807U) || ((sfp->ioc)->attr)->card_type == 902U) || ((sfp->ioc)->attr)->card_type == 1741U) || ((sfp->ioc)->attr)->card_type == 1867U) || ((sfp->ioc)->attr)->card_type == 1869U) {
    return (0);
  } else {

  }
  sfp->portspeed = portspeed;
  if ((unsigned int )sfp->state == 0U) {
    if ((unsigned int )sfp->state_query_lock != 0U) {
      __bfa_trc(sfp->trcmod, __trc_fileno___2, 4160, 0ULL);
      return (13);
    } else {
      sfp->state_query_cbfn = cbfn;
      sfp->state_query_cbarg = cbarg;
      bfa_sfp_state_query(sfp);
      return (159);
    }
  } else {

  }
  if ((unsigned int )sfp->state == 1U || (unsigned int )sfp->state == 5U) {
    __bfa_trc(sfp->trcmod, __trc_fileno___2, 4172, (unsigned long long )sfp->state);
    return (89);
  } else {

  }
  if ((unsigned int )sfp->state == 2U) {
    __bfa_trc(sfp->trcmod, __trc_fileno___2, 4177, (unsigned long long )sfp->state);
    return (13);
  } else {

  }
  if ((unsigned int )sfp->is_elb != 0U) {
    return (0);
  } else {

  }
  tmp___1 = bfa_sfp_speed_valid(sfp, portspeed);
  return (tmp___1);
}
}
static void bfa_flash_aen_audit_post(struct bfa_ioc_s *ioc , enum bfa_audit_aen_event event ,
                                     int inst , int type ) 
{ 
  struct bfad_s *bfad ;
  struct bfa_aen_entry_s *aen_entry ;
  unsigned long _flags ;
  raw_spinlock_t *tmp ;
  int tmp___0 ;

  {
  bfad = (struct bfad_s *)(ioc->bfa)->bfad;
  tmp = spinlock_check(& bfad->bfad_aen_spinlock);
  _flags = _raw_spin_lock_irqsave(tmp);
  tmp___0 = list_empty((struct list_head  const  *)(& bfad->free_aen_q));
  if (tmp___0 == 0) {
    *((struct list_head **)(& aen_entry)) = bfad->free_aen_q.next;
    ((*((struct list_head **)(& aen_entry)))->next)->prev = & bfad->free_aen_q;
    bfad->free_aen_q.next = (*((struct list_head **)(& aen_entry)))->next;
  } else {
    *((struct list_head **)(& aen_entry)) = (struct list_head *)0;
  }
  if ((unsigned long )aen_entry != (unsigned long )((struct bfa_aen_entry_s *)0)) {
    list_add_tail(& aen_entry->qe, & bfad->active_aen_q);
  } else {

  }
  spin_unlock_irqrestore(& bfad->bfad_aen_spinlock, _flags);
  if ((unsigned long )aen_entry == (unsigned long )((struct bfa_aen_entry_s *)0)) {
    return;
  } else {

  }
  aen_entry->aen_data.audit.pwwn = (ioc->attr)->pwwn;
  aen_entry->aen_data.audit.partition_inst = inst;
  aen_entry->aen_data.audit.partition_type = type;
  do_gettimeofday(& aen_entry->aen_tv);
  aen_entry->bfad_num = bfad->inst_no;
  ioc->ioc_aen_seq = ioc->ioc_aen_seq + 1;
  aen_entry->seq_num = (u32 )ioc->ioc_aen_seq;
  aen_entry->aen_category = 8;
  aen_entry->aen_type = (u32 )event;
  if ((bfad->bfad_flags & 512U) != 0U) {
    queue_work___0((bfad->im)->drv_workq, & (bfad->im)->aen_im_notify_work);
  } else {

  }
  return;
}
}
static void bfa_flash_cb(struct bfa_flash_s *flash ) 
{ 


  {
  flash->op_busy = 0U;
  if ((unsigned long )flash->cbfn != (unsigned long )((void (*)(void * , enum bfa_status  ))0)) {
    (*(flash->cbfn))(flash->cbarg, flash->status);
  } else {

  }
  return;
}
}
static void bfa_flash_notify(void *cbarg , enum bfa_ioc_event_e event ) 
{ 
  struct bfa_flash_s *flash ;

  {
  flash = (struct bfa_flash_s *)cbarg;
  __bfa_trc(flash->trcmod, __trc_fileno___2, 4234, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 2U: ;
  case 3U: ;
  if (flash->op_busy != 0U) {
    flash->status = 56;
    (*(flash->cbfn))(flash->cbarg, flash->status);
    flash->op_busy = 0U;
  } else {

  }
  goto ldv_49672;
  default: ;
  goto ldv_49672;
  }
  ldv_49672: ;
  return;
}
}
static void bfa_flash_query_send(void *cbarg ) 
{ 
  struct bfa_flash_s *flash ;
  struct bfi_flash_query_req_s *msg ;

  {
  flash = (struct bfa_flash_s *)cbarg;
  msg = (struct bfi_flash_query_req_s *)(& flash->mb.msg);
  msg->mh.msg_class = 3U;
  msg->mh.msg_id = 1U;
  msg->mh.mtag.h2i.fn_lpu = (flash->ioc)->port_id;
  __bfa_alen_set(& msg->alen, 1032U, flash->dbuf_pa);
  bfa_ioc_mbox_queue(flash->ioc, & flash->mb);
  return;
}
}
static void bfa_flash_write_send(struct bfa_flash_s *flash ) 
{ 
  struct bfi_flash_write_req_s *msg ;
  u32 len ;
  __u32 tmp ;
  __u32 tmp___0 ;
  __u32 tmp___1 ;

  {
  msg = (struct bfi_flash_write_req_s *)(& flash->mb.msg);
  tmp = __fswab32(flash->type);
  msg->type = tmp;
  msg->instance = flash->instance;
  tmp___0 = __fswab32(flash->addr_off + flash->offset);
  msg->offset = tmp___0;
  len = 67584U < flash->residue ? 67584U : flash->residue;
  tmp___1 = __fswab32(len);
  msg->length = tmp___1;
  msg->last = flash->residue == len;
  msg->mh.msg_class = 3U;
  msg->mh.msg_id = 3U;
  msg->mh.mtag.h2i.fn_lpu = (flash->ioc)->port_id;
  __bfa_alen_set(& msg->alen, len, flash->dbuf_pa);
  memcpy((void *)flash->dbuf_kva, (void const   *)flash->ubuf + (unsigned long )flash->offset,
           (size_t )len);
  bfa_ioc_mbox_queue(flash->ioc, & flash->mb);
  flash->residue = flash->residue - len;
  flash->offset = flash->offset + len;
  return;
}
}
static void bfa_flash_read_send(void *cbarg ) 
{ 
  struct bfa_flash_s *flash ;
  struct bfi_flash_read_req_s *msg ;
  u32 len ;
  __u32 tmp ;
  __u32 tmp___0 ;
  __u32 tmp___1 ;

  {
  flash = (struct bfa_flash_s *)cbarg;
  msg = (struct bfi_flash_read_req_s *)(& flash->mb.msg);
  tmp = __fswab32(flash->type);
  msg->type = tmp;
  msg->instance = flash->instance;
  tmp___0 = __fswab32(flash->addr_off + flash->offset);
  msg->offset = tmp___0;
  len = 67584U < flash->residue ? 67584U : flash->residue;
  tmp___1 = __fswab32(len);
  msg->length = tmp___1;
  msg->mh.msg_class = 3U;
  msg->mh.msg_id = 4U;
  msg->mh.mtag.h2i.fn_lpu = (flash->ioc)->port_id;
  __bfa_alen_set(& msg->alen, len, flash->dbuf_pa);
  bfa_ioc_mbox_queue(flash->ioc, & flash->mb);
  return;
}
}
static void bfa_flash_erase_send(void *cbarg ) 
{ 
  struct bfa_flash_s *flash ;
  struct bfi_flash_erase_req_s *msg ;
  __u32 tmp ;

  {
  flash = (struct bfa_flash_s *)cbarg;
  msg = (struct bfi_flash_erase_req_s *)(& flash->mb.msg);
  tmp = __fswab32(flash->type);
  msg->type = tmp;
  msg->instance = flash->instance;
  msg->mh.msg_class = 3U;
  msg->mh.msg_id = 2U;
  msg->mh.mtag.h2i.fn_lpu = (flash->ioc)->port_id;
  bfa_ioc_mbox_queue(flash->ioc, & flash->mb);
  return;
}
}
static void bfa_flash_intr(void *flasharg , struct bfi_mbmsg_s *msg ) 
{ 
  struct bfa_flash_s *flash ;
  u32 status ;
  union __anonunion_m_304 m ;
  __u32 tmp ;
  u32 i ;
  struct bfa_flash_attr_s *attr ;
  struct bfa_flash_attr_s *f ;
  __u32 tmp___0 ;
  __u32 tmp___1 ;
  __u32 tmp___2 ;
  __u32 tmp___3 ;
  __u32 tmp___4 ;
  __u32 tmp___5 ;
  __u32 tmp___6 ;
  __u32 tmp___7 ;
  __u32 tmp___8 ;
  __u32 tmp___9 ;
  __u32 tmp___10 ;
  u32 len ;
  __u32 tmp___11 ;
  __u32 tmp___12 ;
  u32 param ;
  __u32 tmp___13 ;
  int __ret_warn_on ;
  long tmp___14 ;

  {
  flash = (struct bfa_flash_s *)flasharg;
  m.msg = msg;
  __bfa_trc(flash->trcmod, __trc_fileno___2, 4367, (unsigned long long )msg->mh.msg_id);
  if (flash->op_busy == 0U && (unsigned int )msg->mh.msg_id != 255U) {
    __bfa_trc(flash->trcmod, __trc_fileno___2, 4371, 39321ULL);
    return;
  } else {

  }
  switch ((int )msg->mh.msg_id) {
  case 129: 
  tmp = __fswab32((m.query)->status);
  status = tmp;
  __bfa_trc(flash->trcmod, __trc_fileno___2, 4378, (unsigned long long )status);
  if (status == 0U) {
    attr = (struct bfa_flash_attr_s *)flash->ubuf;
    f = (struct bfa_flash_attr_s *)flash->dbuf_kva;
    tmp___0 = __fswab32(f->status);
    attr->status = tmp___0;
    tmp___1 = __fswab32(f->npart);
    attr->npart = tmp___1;
    __bfa_trc(flash->trcmod, __trc_fileno___2, 4387, (unsigned long long )attr->status);
    __bfa_trc(flash->trcmod, __trc_fileno___2, 4388, (unsigned long long )attr->npart);
    i = 0U;
    goto ldv_49714;
    ldv_49713: 
    tmp___2 = __fswab32(f->part[i].part_type);
    attr->part[i].part_type = tmp___2;
    tmp___3 = __fswab32(f->part[i].part_instance);
    attr->part[i].part_instance = tmp___3;
    tmp___4 = __fswab32(f->part[i].part_off);
    attr->part[i].part_off = tmp___4;
    tmp___5 = __fswab32(f->part[i].part_size);
    attr->part[i].part_size = tmp___5;
    tmp___6 = __fswab32(f->part[i].part_len);
    attr->part[i].part_len = tmp___6;
    tmp___7 = __fswab32(f->part[i].part_status);
    attr->part[i].part_status = tmp___7;
    i = i + 1U;
    ldv_49714: ;
    if (attr->npart > i) {
      goto ldv_49713;
    } else {

    }

  } else {

  }
  flash->status = (enum bfa_status )status;
  bfa_flash_cb(flash);
  goto ldv_49716;
  case 130: 
  tmp___8 = __fswab32((m.erase)->status);
  status = tmp___8;
  __bfa_trc(flash->trcmod, __trc_fileno___2, 4409, (unsigned long long )status);
  flash->status = (enum bfa_status )status;
  bfa_flash_cb(flash);
  goto ldv_49716;
  case 131: 
  tmp___9 = __fswab32((m.write)->status);
  status = tmp___9;
  __bfa_trc(flash->trcmod, __trc_fileno___2, 4415, (unsigned long long )status);
  if (status != 0U || flash->residue == 0U) {
    flash->status = (enum bfa_status )status;
    bfa_flash_cb(flash);
  } else {
    __bfa_trc(flash->trcmod, __trc_fileno___2, 4420, (unsigned long long )flash->offset);
    bfa_flash_write_send(flash);
  }
  goto ldv_49716;
  case 132: 
  tmp___10 = __fswab32((m.read)->status);
  status = tmp___10;
  __bfa_trc(flash->trcmod, __trc_fileno___2, 4426, (unsigned long long )status);
  if (status != 0U) {
    flash->status = (enum bfa_status )status;
    bfa_flash_cb(flash);
  } else {
    tmp___11 = __fswab32((m.read)->length);
    len = tmp___11;
    __bfa_trc(flash->trcmod, __trc_fileno___2, 4432, (unsigned long long )flash->offset);
    __bfa_trc(flash->trcmod, __trc_fileno___2, 4433, (unsigned long long )len);
    memcpy((void *)flash->ubuf + (unsigned long )flash->offset, (void const   *)flash->dbuf_kva,
             (size_t )len);
    flash->residue = flash->residue - len;
    flash->offset = flash->offset + len;
    if (flash->residue == 0U) {
      flash->status = (enum bfa_status )status;
      bfa_flash_cb(flash);
    } else {
      bfa_flash_read_send((void *)flash);
    }
  }
  goto ldv_49716;
  case 133: ;
  goto ldv_49716;
  case 255: 
  tmp___12 = __fswab32((unsigned int )(m.event)->status);
  status = tmp___12;
  __bfa_trc(flash->trcmod, __trc_fileno___2, 4449, (unsigned long long )status);
  if (status == 156U) {
    bfa_ioc_aen_post(flash->ioc, 6);
  } else
  if (status == 158U) {
    tmp___13 = __fswab32((m.event)->param);
    param = tmp___13;
    __bfa_trc(flash->trcmod, __trc_fileno___2, 4455, (unsigned long long )param);
    bfa_ioc_aen_post(flash->ioc, 7);
  } else {

  }
  goto ldv_49716;
  default: 
  __ret_warn_on = 1;
  tmp___14 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp___14 != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_ioc.c",
                       4462);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  }
  ldv_49716: ;
  return;
}
}
u32 bfa_flash_meminfo(enum bfa_boolean mincfg ) 
{ 


  {
  if ((unsigned int )mincfg != 0U) {
    return (0U);
  } else {

  }
  return (67584U);
}
}
void bfa_flash_attach(struct bfa_flash_s *flash , struct bfa_ioc_s *ioc , void *dev ,
                      struct bfa_trc_mod_s *trcmod , enum bfa_boolean mincfg ) 
{ 


  {
  flash->ioc = ioc;
  flash->trcmod = trcmod;
  flash->cbfn = (void (*)(void * , enum bfa_status  ))0;
  flash->cbarg = (void *)0;
  flash->op_busy = 0U;
  bfa_ioc_mbox_regisr(flash->ioc, 3, & bfa_flash_intr, (void *)flash);
  ((struct list_head *)(& flash->ioc_notify))->next = (struct list_head *)0;
  ((struct list_head *)(& flash->ioc_notify))->prev = (struct list_head *)0;
  flash->ioc_notify.cbfn = & bfa_flash_notify;
  flash->ioc_notify.cbarg = (void *)flash;
  list_add_tail(& flash->ioc_notify.qe, & (flash->ioc)->notify_q);
  if ((unsigned int )mincfg != 0U) {
    flash->dbuf_kva = (u8 *)0U;
    flash->dbuf_pa = 0ULL;
  } else {

  }
  return;
}
}
void bfa_flash_memclaim(struct bfa_flash_s *flash , u8 *dm_kva , u64 dm_pa , enum bfa_boolean mincfg ) 
{ 


  {
  if ((unsigned int )mincfg != 0U) {
    return;
  } else {

  }
  flash->dbuf_kva = dm_kva;
  flash->dbuf_pa = dm_pa;
  memset((void *)flash->dbuf_kva, 0, 67584UL);
  dm_kva = dm_kva + 67584UL;
  dm_pa = dm_pa + 67584ULL;
  return;
}
}
enum bfa_status bfa_flash_get_attr(struct bfa_flash_s *flash , struct bfa_flash_attr_s *attr ,
                                   void (*cbfn)(void * , enum bfa_status  ) , void *cbarg ) 
{ 
  enum bfa_boolean tmp ;

  {
  __bfa_trc(flash->trcmod, __trc_fileno___2, 4547, 1ULL);
  tmp = bfa_ioc_is_operational(flash->ioc);
  if ((unsigned int )tmp == 0U) {
    return (61);
  } else {

  }
  if (flash->op_busy != 0U) {
    __bfa_trc(flash->trcmod, __trc_fileno___2, 4553, (unsigned long long )flash->op_busy);
    return (13);
  } else {

  }
  flash->op_busy = 1U;
  flash->cbfn = cbfn;
  flash->cbarg = cbarg;
  flash->ubuf = (u8 *)attr;
  bfa_flash_query_send((void *)flash);
  return (0);
}
}
enum bfa_status bfa_flash_erase_part(struct bfa_flash_s *flash , enum bfa_flash_part_type type ,
                                     u8 instance , void (*cbfn)(void * , enum bfa_status  ) ,
                                     void *cbarg ) 
{ 
  enum bfa_boolean tmp ;

  {
  __bfa_trc(flash->trcmod, __trc_fileno___2, 4581, 2ULL);
  __bfa_trc(flash->trcmod, __trc_fileno___2, 4582, (unsigned long long )type);
  __bfa_trc(flash->trcmod, __trc_fileno___2, 4583, (unsigned long long )instance);
  tmp = bfa_ioc_is_operational(flash->ioc);
  if ((unsigned int )tmp == 0U) {
    return (61);
  } else {

  }
  if (flash->op_busy != 0U) {
    __bfa_trc(flash->trcmod, __trc_fileno___2, 4589, (unsigned long long )flash->op_busy);
    return (13);
  } else {

  }
  flash->op_busy = 1U;
  flash->cbfn = cbfn;
  flash->cbarg = cbarg;
  flash->type = (u32 )type;
  flash->instance = instance;
  bfa_flash_erase_send((void *)flash);
  bfa_flash_aen_audit_post(flash->ioc, 3, (int )instance, (int )type);
  return (0);
}
}
enum bfa_status bfa_flash_update_part(struct bfa_flash_s *flash , enum bfa_flash_part_type type ,
                                      u8 instance , void *buf , u32 len , u32 offset ,
                                      void (*cbfn)(void * , enum bfa_status  ) , void *cbarg ) 
{ 
  enum bfa_boolean tmp ;

  {
  __bfa_trc(flash->trcmod, __trc_fileno___2, 4624, 3ULL);
  __bfa_trc(flash->trcmod, __trc_fileno___2, 4625, (unsigned long long )type);
  __bfa_trc(flash->trcmod, __trc_fileno___2, 4626, (unsigned long long )instance);
  __bfa_trc(flash->trcmod, __trc_fileno___2, 4627, (unsigned long long )len);
  __bfa_trc(flash->trcmod, __trc_fileno___2, 4628, (unsigned long long )offset);
  tmp = bfa_ioc_is_operational(flash->ioc);
  if ((unsigned int )tmp == 0U) {
    return (61);
  } else {

  }
  if ((len == 0U || (len & 3U) != 0U) || (offset & 16383U) != 0U) {
    return (17);
  } else {

  }
  if ((unsigned int )type == 7U) {
    return (2);
  } else {

  }
  if (flash->op_busy != 0U) {
    __bfa_trc(flash->trcmod, __trc_fileno___2, 4644, (unsigned long long )flash->op_busy);
    return (13);
  } else {

  }
  flash->op_busy = 1U;
  flash->cbfn = cbfn;
  flash->cbarg = cbarg;
  flash->type = (u32 )type;
  flash->instance = instance;
  flash->residue = len;
  flash->offset = 0U;
  flash->addr_off = offset;
  flash->ubuf = (u8 *)buf;
  bfa_flash_write_send(flash);
  return (0);
}
}
enum bfa_status bfa_flash_read_part(struct bfa_flash_s *flash , enum bfa_flash_part_type type ,
                                    u8 instance , void *buf , u32 len , u32 offset ,
                                    void (*cbfn)(void * , enum bfa_status  ) , void *cbarg ) 
{ 
  enum bfa_boolean tmp ;

  {
  __bfa_trc(flash->trcmod, __trc_fileno___2, 4681, 4ULL);
  __bfa_trc(flash->trcmod, __trc_fileno___2, 4682, (unsigned long long )type);
  __bfa_trc(flash->trcmod, __trc_fileno___2, 4683, (unsigned long long )instance);
  __bfa_trc(flash->trcmod, __trc_fileno___2, 4684, (unsigned long long )len);
  __bfa_trc(flash->trcmod, __trc_fileno___2, 4685, (unsigned long long )offset);
  tmp = bfa_ioc_is_operational(flash->ioc);
  if ((unsigned int )tmp == 0U) {
    return (61);
  } else {

  }
  if ((len == 0U || (len & 3U) != 0U) || (offset & 16383U) != 0U) {
    return (17);
  } else {

  }
  if (flash->op_busy != 0U) {
    __bfa_trc(flash->trcmod, __trc_fileno___2, 4698, (unsigned long long )flash->op_busy);
    return (13);
  } else {

  }
  flash->op_busy = 1U;
  flash->cbfn = cbfn;
  flash->cbarg = cbarg;
  flash->type = (u32 )type;
  flash->instance = instance;
  flash->residue = len;
  flash->offset = 0U;
  flash->addr_off = offset;
  flash->ubuf = (u8 *)buf;
  bfa_flash_read_send((void *)flash);
  return (0);
}
}
static void bfa_diag_notify(void *diag_arg , enum bfa_ioc_event_e event ) 
{ 
  struct bfa_diag_s *diag ;

  {
  diag = (struct bfa_diag_s *)diag_arg;
  __bfa_trc(diag->trcmod, __trc_fileno___2, 4729, (unsigned long long )event);
  __bfa_trc(diag->trcmod, __trc_fileno___2, 4730, (unsigned long long )diag->block);
  __bfa_trc(diag->trcmod, __trc_fileno___2, 4731, (unsigned long long )diag->fwping.lock);
  __bfa_trc(diag->trcmod, __trc_fileno___2, 4732, (unsigned long long )diag->tsensor.lock);
  switch ((unsigned int )event) {
  case 2U: ;
  case 3U: ;
  if ((unsigned int )diag->fwping.lock != 0U) {
    diag->fwping.status = 56U;
    (*(diag->fwping.cbfn))(diag->fwping.cbarg, (enum bfa_status )diag->fwping.status);
    diag->fwping.lock = 0U;
  } else {

  }
  if ((unsigned int )diag->tsensor.lock != 0U) {
    diag->tsensor.status = 56U;
    (*(diag->tsensor.cbfn))(diag->tsensor.cbarg, (enum bfa_status )diag->tsensor.status);
    diag->tsensor.lock = 0U;
  } else {

  }
  if ((unsigned int )diag->block != 0U) {
    if ((unsigned int )diag->timer_active != 0U) {
      bfa_timer_stop(& diag->timer);
      diag->timer_active = 0U;
    } else {

    }
    diag->status = 56U;
    (*(diag->cbfn))(diag->cbarg, (enum bfa_status )diag->status);
    diag->block = 0U;
  } else {

  }
  goto ldv_49783;
  default: ;
  goto ldv_49783;
  }
  ldv_49783: ;
  return;
}
}
static void bfa_diag_memtest_done(void *cbarg ) 
{ 
  struct bfa_diag_s *diag ;
  struct bfa_ioc_s *ioc ;
  struct bfa_diag_memtest_result *res ;
  u32 loff ;
  u32 pgnum ;
  u32 pgoff ;
  u32 i ;
  unsigned int tmp ;
  __u32 tmp___0 ;
  __u32 tmp___1 ;
  __u32 tmp___2 ;
  __u32 tmp___3 ;
  __u32 tmp___4 ;
  __u32 tmp___5 ;
  __u32 tmp___6 ;
  __u32 tmp___7 ;

  {
  diag = (struct bfa_diag_s *)cbarg;
  ioc = diag->ioc;
  res = (struct bfa_diag_memtest_result *)diag->result;
  loff = 2304U;
  pgnum = ioc->ioc_regs.smem_pg0 + (loff >> 15);
  pgoff = loff & 32767U;
  writel(pgnum, (void volatile   *)ioc->ioc_regs.host_page_num_fn);
  i = 0U;
  goto ldv_49796;
  ldv_49795: 
  tmp = readl((void const volatile   *)ioc->ioc_regs.smem_page_start + (unsigned long )loff);
  tmp___0 = __fswab32(tmp);
  *((u32 *)res + (unsigned long )i) = tmp___0;
  loff = loff + 4U;
  i = i + 1U;
  ldv_49796: ;
  if (i <= 7U) {
    goto ldv_49795;
  } else {

  }
  bfa_ioc_reset_fwstate(ioc);
  tmp___1 = __fswab32(res->status);
  res->status = tmp___1;
  __bfa_trc(diag->trcmod, __trc_fileno___2, 4794, (unsigned long long )res->status);
  if (res->status == 2694947491U) {
    diag->status = 0U;
  } else {
    diag->status = 90U;
    tmp___2 = __fswab32(res->addr);
    res->addr = tmp___2;
    tmp___3 = __fswab32(res->exp);
    res->exp = tmp___3;
    tmp___4 = __fswab32(res->act);
    res->act = tmp___4;
    tmp___5 = __fswab32(res->err_status);
    res->err_status = tmp___5;
    tmp___6 = __fswab32(res->err_status1);
    res->err_status1 = tmp___6;
    tmp___7 = __fswab32(res->err_addr);
    res->err_addr = tmp___7;
    __bfa_trc(diag->trcmod, __trc_fileno___2, 4806, (unsigned long long )res->addr);
    __bfa_trc(diag->trcmod, __trc_fileno___2, 4807, (unsigned long long )res->exp);
    __bfa_trc(diag->trcmod, __trc_fileno___2, 4808, (unsigned long long )res->act);
    __bfa_trc(diag->trcmod, __trc_fileno___2, 4809, (unsigned long long )res->err_status);
    __bfa_trc(diag->trcmod, __trc_fileno___2, 4810, (unsigned long long )res->err_status1);
    __bfa_trc(diag->trcmod, __trc_fileno___2, 4811, (unsigned long long )res->err_addr);
  }
  diag->timer_active = 0U;
  (*(diag->cbfn))(diag->cbarg, (enum bfa_status )diag->status);
  diag->block = 0U;
  return;
}
}
static void diag_fwping_send(struct bfa_diag_s *diag ) 
{ 
  struct bfi_diag_fwping_req_s *fwping_req ;
  u32 i ;
  __u32 tmp ;

  {
  __bfa_trc(diag->trcmod, __trc_fileno___2, 4831, diag->fwping.dbuf_pa);
  i = 0U;
  goto ldv_49804;
  ldv_49803: 
  *((u32 *)diag->fwping.dbuf_kva + (unsigned long )i) = diag->fwping.data;
  i = i + 1U;
  ldv_49804: ;
  if (i <= 511U) {
    goto ldv_49803;
  } else {

  }
  fwping_req = (struct bfi_diag_fwping_req_s *)(& diag->fwping.mbcmd.msg);
  __bfa_alen_set(& fwping_req->alen, 2048U, diag->fwping.dbuf_pa);
  tmp = __fswab32(diag->fwping.count);
  fwping_req->count = tmp;
  fwping_req->data = diag->fwping.data;
  fwping_req->mh.msg_class = 2U;
  fwping_req->mh.msg_id = 3U;
  fwping_req->mh.mtag.h2i.fn_lpu = (diag->ioc)->port_id;
  bfa_ioc_mbox_queue(diag->ioc, & diag->fwping.mbcmd);
  return;
}
}
static void diag_fwping_comp(struct bfa_diag_s *diag , struct bfi_diag_fwping_rsp_s *diag_rsp ) 
{ 
  u32 rsp_data ;
  u8 rsp_dma_status ;
  u32 i ;
  u32 pat ;

  {
  rsp_data = diag_rsp->data;
  rsp_dma_status = diag_rsp->dma_status;
  __bfa_trc(diag->trcmod, __trc_fileno___2, 4863, (unsigned long long )rsp_data);
  __bfa_trc(diag->trcmod, __trc_fileno___2, 4864, (unsigned long long )rsp_dma_status);
  if ((unsigned int )rsp_dma_status == 0U) {
    pat = (int )diag->fwping.count & 1 ? ~ diag->fwping.data : diag->fwping.data;
    if (diag->fwping.data != rsp_data) {
      __bfa_trc(diag->trcmod, __trc_fileno___2, 4872, (unsigned long long )rsp_data);
      (diag->fwping.result)->dmastatus = 12U;
      diag->fwping.status = 12U;
      (*(diag->fwping.cbfn))(diag->fwping.cbarg, (enum bfa_status )diag->fwping.status);
      diag->fwping.lock = 0U;
      return;
    } else {

    }
    i = 0U;
    goto ldv_49815;
    ldv_49814: ;
    if (*((u32 *)diag->fwping.dbuf_kva + (unsigned long )i) != pat) {
      __bfa_trc(diag->trcmod, __trc_fileno___2, 4884, (unsigned long long )i);
      __bfa_trc(diag->trcmod, __trc_fileno___2, 4885, (unsigned long long )pat);
      __bfa_trc(diag->trcmod, __trc_fileno___2, 4887, (unsigned long long )*((u32 *)diag->fwping.dbuf_kva + (unsigned long )i));
      (diag->fwping.result)->dmastatus = 12U;
      diag->fwping.status = 12U;
      (*(diag->fwping.cbfn))(diag->fwping.cbarg, (enum bfa_status )diag->fwping.status);
      diag->fwping.lock = 0U;
      return;
    } else {

    }
    i = i + 1U;
    ldv_49815: ;
    if (i <= 511U) {
      goto ldv_49814;
    } else {

    }
    (diag->fwping.result)->dmastatus = 0U;
    diag->fwping.status = 0U;
    (*(diag->fwping.cbfn))(diag->fwping.cbarg, (enum bfa_status )diag->fwping.status);
    diag->fwping.lock = 0U;
  } else {
    diag->fwping.status = 16U;
    (*(diag->fwping.cbfn))(diag->fwping.cbarg, (enum bfa_status )diag->fwping.status);
    diag->fwping.lock = 0U;
  }
  return;
}
}
static void diag_tempsensor_send(struct bfa_diag_s *diag ) 
{ 
  struct bfi_diag_ts_req_s *msg ;

  {
  msg = (struct bfi_diag_ts_req_s *)(& diag->tsensor.mbcmd.msg);
  __bfa_trc(diag->trcmod, __trc_fileno___2, 4918, (unsigned long long )msg->temp);
  msg->mh.msg_class = 2U;
  msg->mh.msg_id = 4U;
  msg->mh.mtag.h2i.fn_lpu = (diag->ioc)->port_id;
  bfa_ioc_mbox_queue(diag->ioc, & diag->tsensor.mbcmd);
  return;
}
}
static void diag_tempsensor_comp(struct bfa_diag_s *diag , struct bfi_diag_ts_req_s *rsp ) 
{ 
  __u16 tmp ;
  __u16 tmp___0 ;

  {
  if ((unsigned int )diag->tsensor.lock == 0U) {
    __bfa_trc(diag->trcmod, __trc_fileno___2, 4931, (unsigned long long )diag->tsensor.lock);
    return;
  } else {

  }
  tmp = __fswab16((int )rsp->temp);
  (diag->tsensor.temp)->temp = tmp;
  (diag->tsensor.temp)->ts_junc = rsp->ts_junc;
  (diag->tsensor.temp)->ts_brd = rsp->ts_brd;
  if ((unsigned int )rsp->ts_brd != 0U) {
    (diag->tsensor.temp)->status = (u32 )rsp->status;
    if ((unsigned int )rsp->status == 0U) {
      tmp___0 = __fswab16((int )rsp->brd_temp);
      (diag->tsensor.temp)->brd_temp = tmp___0;
    } else {
      (diag->tsensor.temp)->brd_temp = 0U;
    }
  } else {

  }
  __bfa_trc(diag->trcmod, __trc_fileno___2, 4953, (unsigned long long )rsp->status);
  __bfa_trc(diag->trcmod, __trc_fileno___2, 4954, (unsigned long long )rsp->ts_junc);
  __bfa_trc(diag->trcmod, __trc_fileno___2, 4955, (unsigned long long )rsp->temp);
  __bfa_trc(diag->trcmod, __trc_fileno___2, 4956, (unsigned long long )rsp->ts_brd);
  __bfa_trc(diag->trcmod, __trc_fileno___2, 4957, (unsigned long long )rsp->brd_temp);
  diag->tsensor.status = 0U;
  (*(diag->tsensor.cbfn))(diag->tsensor.cbarg, (enum bfa_status )diag->tsensor.status);
  diag->tsensor.lock = 0U;
  return;
}
}
static void diag_ledtest_send(struct bfa_diag_s *diag , struct bfa_diag_ledtest_s *ledtest ) 
{ 
  struct bfi_diag_ledtest_req_s *msg ;
  __u16 tmp ;

  {
  msg = (struct bfi_diag_ledtest_req_s *)(& diag->ledtest.mbcmd.msg);
  msg->mh.msg_class = 2U;
  msg->mh.msg_id = 5U;
  msg->mh.mtag.h2i.fn_lpu = (diag->ioc)->port_id;
  if ((unsigned int )ledtest->freq != 0U) {
    ledtest->freq = (u16 )(500 / (int )ledtest->freq);
  } else {

  }
  if ((unsigned int )ledtest->freq == 0U) {
    ledtest->freq = 1U;
  } else {

  }
  __bfa_trc(diag->trcmod, __trc_fileno___2, 4988, (unsigned long long )ledtest->freq);
  msg->cmd = (unsigned char )ledtest->cmd;
  msg->color = (unsigned char )ledtest->color;
  msg->portid = (diag->ioc)->port_id;
  msg->led = ledtest->led;
  tmp = __fswab16((int )ledtest->freq);
  msg->freq = tmp;
  bfa_ioc_mbox_queue(diag->ioc, & diag->ledtest.mbcmd);
  return;
}
}
static void diag_ledtest_comp(struct bfa_diag_s *diag , struct bfi_diag_ledtest_rsp_s *msg ) 
{ 


  {
  __bfa_trc(diag->trcmod, __trc_fileno___2, 5003, (unsigned long long )diag->ledtest.lock);
  diag->ledtest.lock = 0;
  return;
}
}
static void diag_portbeacon_send(struct bfa_diag_s *diag , enum bfa_boolean beacon ,
                                 u32 sec ) 
{ 
  struct bfi_diag_portbeacon_req_s *msg ;
  __u32 tmp ;

  {
  msg = (struct bfi_diag_portbeacon_req_s *)(& diag->beacon.mbcmd.msg);
  msg->mh.msg_class = 2U;
  msg->mh.msg_id = 1U;
  msg->mh.mtag.h2i.fn_lpu = (diag->ioc)->port_id;
  msg->beacon = (u8 )beacon;
  tmp = __fswab32(sec);
  msg->period = tmp;
  bfa_ioc_mbox_queue(diag->ioc, & diag->beacon.mbcmd);
  return;
}
}
static void diag_portbeacon_comp(struct bfa_diag_s *diag ) 
{ 


  {
  __bfa_trc(diag->trcmod, __trc_fileno___2, 5029, (unsigned long long )diag->beacon.state);
  diag->beacon.state = 0;
  if ((unsigned long )diag->cbfn_beacon != (unsigned long )((void (*)(void * , enum bfa_boolean  ,
                                                                      enum bfa_boolean  ))0)) {
    (*(diag->cbfn_beacon))(diag->dev, 0, diag->beacon.link_e2e);
  } else {

  }
  return;
}
}
void bfa_diag_intr(void *diagarg , struct bfi_mbmsg_s *msg ) 
{ 
  struct bfa_diag_s *diag ;
  int __ret_warn_on ;
  long tmp ;

  {
  diag = (struct bfa_diag_s *)diagarg;
  switch ((int )msg->mh.msg_id) {
  case 129: 
  diag_portbeacon_comp(diag);
  goto ldv_49849;
  case 131: 
  diag_fwping_comp(diag, (struct bfi_diag_fwping_rsp_s *)msg);
  goto ldv_49849;
  case 132: 
  diag_tempsensor_comp(diag, (struct bfi_diag_ts_req_s *)msg);
  goto ldv_49849;
  case 133: 
  diag_ledtest_comp(diag, (struct bfi_diag_ledtest_rsp_s *)msg);
  goto ldv_49849;
  default: 
  __bfa_trc(diag->trcmod, __trc_fileno___2, 5057, (unsigned long long )msg->mh.msg_id);
  __ret_warn_on = 1;
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_ioc.c",
                       5058);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  }
  ldv_49849: ;
  return;
}
}
enum bfa_status bfa_diag_memtest(struct bfa_diag_s *diag , struct bfa_diag_memtest_s *memtest ,
                                 u32 pattern , struct bfa_diag_memtest_result *result ,
                                 void (*cbfn)(void * , enum bfa_status  ) , void *cbarg ) 
{ 
  u32 memtest_tov ;
  enum bfa_boolean tmp ;

  {
  __bfa_trc(diag->trcmod, __trc_fileno___2, 5081, (unsigned long long )pattern);
  tmp = bfa_ioc_adapter_is_disabled(diag->ioc);
  if ((unsigned int )tmp == 0U) {
    return (60);
  } else {

  }
  if ((unsigned int )diag->block != 0U) {
    __bfa_trc(diag->trcmod, __trc_fileno___2, 5088, (unsigned long long )diag->block);
    return (13);
  } else {
    diag->block = 1U;
  }
  diag->result = (void *)result;
  diag->cbfn = cbfn;
  diag->cbarg = cbarg;
  bfa_ioc_boot(diag->ioc, 2U, 0U);
  memtest_tov = (unsigned int )(diag->ioc)->asic_gen == 3U ? 270000U : 50000U;
  bfa_timer_begin((diag->ioc)->timer_mod, & diag->timer, & bfa_diag_memtest_done,
                  (void *)diag, memtest_tov);
  diag->timer_active = 1U;
  return (0);
}
}
enum bfa_status bfa_diag_fwping(struct bfa_diag_s *diag , u32 cnt , u32 data , struct bfa_diag_results_fwping *result ,
                                void (*cbfn)(void * , enum bfa_status  ) , void *cbarg ) 
{ 
  enum bfa_boolean tmp ;

  {
  __bfa_trc(diag->trcmod, __trc_fileno___2, 5125, (unsigned long long )cnt);
  __bfa_trc(diag->trcmod, __trc_fileno___2, 5126, (unsigned long long )data);
  tmp = bfa_ioc_is_operational(diag->ioc);
  if ((unsigned int )tmp == 0U) {
    return (61);
  } else {

  }
  if (((unsigned int )(diag->ioc)->pcidev.device_id == 34U || (unsigned int )(diag->ioc)->pcidev.device_id == 35U) && (unsigned int )(diag->ioc)->clscode == 512U) {
    return (26);
  } else {

  }
  if ((unsigned int )diag->block != 0U || (unsigned int )diag->fwping.lock != 0U) {
    __bfa_trc(diag->trcmod, __trc_fileno___2, 5137, (unsigned long long )diag->block);
    __bfa_trc(diag->trcmod, __trc_fileno___2, 5138, (unsigned long long )diag->fwping.lock);
    return (13);
  } else {

  }
  diag->fwping.lock = 1U;
  diag->fwping.cbfn = cbfn;
  diag->fwping.cbarg = cbarg;
  diag->fwping.result = result;
  diag->fwping.data = data;
  diag->fwping.count = cnt;
  (diag->fwping.result)->data = 0U;
  (diag->fwping.result)->status = 0U;
  diag_fwping_send(diag);
  return (0);
}
}
enum bfa_status bfa_diag_tsensor_query(struct bfa_diag_s *diag , struct bfa_diag_results_tempsensor_s *result ,
                                       void (*cbfn)(void * , enum bfa_status  ) ,
                                       void *cbarg ) 
{ 
  enum bfa_boolean tmp ;

  {
  if ((unsigned int )diag->block != 0U || (unsigned int )diag->tsensor.lock != 0U) {
    __bfa_trc(diag->trcmod, __trc_fileno___2, 5176, (unsigned long long )diag->block);
    __bfa_trc(diag->trcmod, __trc_fileno___2, 5177, (unsigned long long )diag->tsensor.lock);
    return (13);
  } else {

  }
  tmp = bfa_ioc_is_operational(diag->ioc);
  if ((unsigned int )tmp == 0U) {
    return (61);
  } else {

  }
  diag->tsensor.lock = 1U;
  diag->tsensor.temp = result;
  diag->tsensor.cbfn = cbfn;
  diag->tsensor.cbarg = cbarg;
  diag->tsensor.status = 0U;
  diag_tempsensor_send(diag);
  return (0);
}
}
enum bfa_status bfa_diag_ledtest(struct bfa_diag_s *diag , struct bfa_diag_ledtest_s *ledtest ) 
{ 
  enum bfa_boolean tmp ;

  {
  __bfa_trc(diag->trcmod, __trc_fileno___2, 5208, (unsigned long long )ledtest->cmd);
  tmp = bfa_ioc_is_operational(diag->ioc);
  if ((unsigned int )tmp == 0U) {
    return (61);
  } else {

  }
  if ((unsigned int )diag->beacon.state != 0U) {
    return (72);
  } else {

  }
  if ((unsigned int )diag->ledtest.lock != 0U) {
    return (109);
  } else {

  }
  diag->ledtest.lock = 1;
  diag_ledtest_send(diag, ledtest);
  return (0);
}
}
enum bfa_status bfa_diag_beacon_port(struct bfa_diag_s *diag , enum bfa_boolean beacon ,
                                     enum bfa_boolean link_e2e_beacon , unsigned int sec ) 
{ 
  enum bfa_boolean tmp ;

  {
  __bfa_trc(diag->trcmod, __trc_fileno___2, 5240, (unsigned long long )beacon);
  __bfa_trc(diag->trcmod, __trc_fileno___2, 5241, (unsigned long long )link_e2e_beacon);
  __bfa_trc(diag->trcmod, __trc_fileno___2, 5242, (unsigned long long )sec);
  tmp = bfa_ioc_is_operational(diag->ioc);
  if ((unsigned int )tmp == 0U) {
    return (61);
  } else {

  }
  if ((unsigned int )diag->ledtest.lock != 0U) {
    return (109);
  } else {

  }
  if ((unsigned int )diag->beacon.state != 0U && (unsigned int )beacon != 0U) {
    return (72);
  } else {

  }
  diag->beacon.state = beacon;
  diag->beacon.link_e2e = link_e2e_beacon;
  if ((unsigned long )diag->cbfn_beacon != (unsigned long )((void (*)(void * , enum bfa_boolean  ,
                                                                      enum bfa_boolean  ))0)) {
    (*(diag->cbfn_beacon))(diag->dev, beacon, link_e2e_beacon);
  } else {

  }
  diag_portbeacon_send(diag, beacon, sec);
  return (0);
}
}
u32 bfa_diag_meminfo(void) 
{ 


  {
  return (2048U);
}
}
void bfa_diag_attach(struct bfa_diag_s *diag , struct bfa_ioc_s *ioc , void *dev ,
                     void (*cbfn_beacon)(void * , enum bfa_boolean  , enum bfa_boolean  ) ,
                     struct bfa_trc_mod_s *trcmod ) 
{ 


  {
  diag->dev = dev;
  diag->ioc = ioc;
  diag->trcmod = trcmod;
  diag->block = 0U;
  diag->cbfn = (void (*)(void * , enum bfa_status  ))0;
  diag->cbarg = (void *)0;
  diag->result = (void *)0;
  diag->cbfn_beacon = cbfn_beacon;
  bfa_ioc_mbox_regisr(diag->ioc, 2, & bfa_diag_intr, (void *)diag);
  ((struct list_head *)(& diag->ioc_notify))->next = (struct list_head *)0;
  ((struct list_head *)(& diag->ioc_notify))->prev = (struct list_head *)0;
  diag->ioc_notify.cbfn = & bfa_diag_notify;
  diag->ioc_notify.cbarg = (void *)diag;
  list_add_tail(& diag->ioc_notify.qe, & (diag->ioc)->notify_q);
  return;
}
}
void bfa_diag_memclaim(struct bfa_diag_s *diag , u8 *dm_kva , u64 dm_pa ) 
{ 


  {
  diag->fwping.dbuf_kva = dm_kva;
  diag->fwping.dbuf_pa = dm_pa;
  memset((void *)diag->fwping.dbuf_kva, 0, 2048UL);
  return;
}
}
static void bfa_phy_ntoh32(u32 *obuf , u32 *ibuf , int sz ) 
{ 
  int i ;
  int m ;
    klee_make_symbolic(&m, sizeof(int), "m");
  __u32 tmp ;

  {
  m = sz >> 2;
  i = 0;
  goto ldv_49912;
  ldv_49911: 
  tmp = __fswab32(*(ibuf + (unsigned long )i));
  *(obuf + (unsigned long )i) = tmp;
  i = i + 1;
  ldv_49912: ;
  if (i < m) {
    goto ldv_49911;
  } else {

  }

  return;
}
}
static enum bfa_boolean bfa_phy_present(struct bfa_phy_s *phy ) 
{ 


  {
  return (((phy->ioc)->attr)->card_type == 1741U);
}
}
static void bfa_phy_notify(void *cbarg , enum bfa_ioc_event_e event ) 
{ 
  struct bfa_phy_s *phy ;

  {
  phy = (struct bfa_phy_s *)cbarg;
  __bfa_trc(phy->trcmod, __trc_fileno___2, 5330, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 2U: ;
  case 3U: ;
  if ((unsigned int )phy->op_busy != 0U) {
    phy->status = 56;
    (*(phy->cbfn))(phy->cbarg, phy->status);
    phy->op_busy = 0U;
  } else {

  }
  goto ldv_49924;
  default: ;
  goto ldv_49924;
  }
  ldv_49924: ;
  return;
}
}
static void bfa_phy_query_send(void *cbarg ) 
{ 
  struct bfa_phy_s *phy ;
  struct bfi_phy_query_req_s *msg ;

  {
  phy = (struct bfa_phy_s *)cbarg;
  msg = (struct bfi_phy_query_req_s *)(& phy->mb.msg);
  msg->instance = phy->instance;
  msg->mh.msg_class = 25U;
  msg->mh.msg_id = 1U;
  msg->mh.mtag.h2i.fn_lpu = (phy->ioc)->port_id;
  __bfa_alen_set(& msg->alen, 28U, phy->dbuf_pa);
  bfa_ioc_mbox_queue(phy->ioc, & phy->mb);
  return;
}
}
static void bfa_phy_write_send(void *cbarg ) 
{ 
  struct bfa_phy_s *phy ;
  struct bfi_phy_write_req_s *msg ;
  u32 len ;
  u16 *buf ;
  u16 *dbuf ;
  int i ;
  int sz ;
  __u32 tmp ;
  __u32 tmp___0 ;
  __u16 tmp___1 ;

  {
  phy = (struct bfa_phy_s *)cbarg;
  msg = (struct bfi_phy_write_req_s *)(& phy->mb.msg);
  msg->instance = phy->instance;
  tmp = __fswab32(phy->addr_off + phy->offset);
  msg->offset = tmp;
  len = 8192U < phy->residue ? 8192U : phy->residue;
  tmp___0 = __fswab32(len);
  msg->length = tmp___0;
  msg->last = phy->residue == len;
  msg->mh.msg_class = 25U;
  msg->mh.msg_id = 3U;
  msg->mh.mtag.h2i.fn_lpu = (phy->ioc)->port_id;
  __bfa_alen_set(& msg->alen, len, phy->dbuf_pa);
  buf = (u16 *)phy->ubuf + (unsigned long )phy->offset;
  dbuf = (u16 *)phy->dbuf_kva;
  sz = (int )(len >> 1);
  i = 0;
  goto ldv_49942;
  ldv_49941: 
  tmp___1 = __fswab16((int )*(dbuf + (unsigned long )i));
  *(buf + (unsigned long )i) = tmp___1;
  i = i + 1;
  ldv_49942: ;
  if (i < sz) {
    goto ldv_49941;
  } else {

  }
  bfa_ioc_mbox_queue(phy->ioc, & phy->mb);
  phy->residue = phy->residue - len;
  phy->offset = phy->offset + len;
  return;
}
}
static void bfa_phy_read_send(void *cbarg ) 
{ 
  struct bfa_phy_s *phy ;
  struct bfi_phy_read_req_s *msg ;
  u32 len ;
  __u32 tmp ;
  __u32 tmp___0 ;

  {
  phy = (struct bfa_phy_s *)cbarg;
  msg = (struct bfi_phy_read_req_s *)(& phy->mb.msg);
  msg->instance = phy->instance;
  tmp = __fswab32(phy->addr_off + phy->offset);
  msg->offset = tmp;
  len = 8192U < phy->residue ? 8192U : phy->residue;
  tmp___0 = __fswab32(len);
  msg->length = tmp___0;
  msg->mh.msg_class = 25U;
  msg->mh.msg_id = 4U;
  msg->mh.mtag.h2i.fn_lpu = (phy->ioc)->port_id;
  __bfa_alen_set(& msg->alen, len, phy->dbuf_pa);
  bfa_ioc_mbox_queue(phy->ioc, & phy->mb);
  return;
}
}
static void bfa_phy_stats_send(void *cbarg ) 
{ 
  struct bfa_phy_s *phy ;
  struct bfi_phy_stats_req_s *msg ;

  {
  phy = (struct bfa_phy_s *)cbarg;
  msg = (struct bfi_phy_stats_req_s *)(& phy->mb.msg);
  msg->instance = phy->instance;
  msg->mh.msg_class = 25U;
  msg->mh.msg_id = 2U;
  msg->mh.mtag.h2i.fn_lpu = (phy->ioc)->port_id;
  __bfa_alen_set(& msg->alen, 32U, phy->dbuf_pa);
  bfa_ioc_mbox_queue(phy->ioc, & phy->mb);
  return;
}
}
u32 bfa_phy_meminfo(enum bfa_boolean mincfg ) 
{ 


  {
  if ((unsigned int )mincfg != 0U) {
    return (0U);
  } else {

  }
  return (8192U);
}
}
void bfa_phy_attach(struct bfa_phy_s *phy , struct bfa_ioc_s *ioc , void *dev , struct bfa_trc_mod_s *trcmod ,
                    enum bfa_boolean mincfg ) 
{ 


  {
  phy->ioc = ioc;
  phy->trcmod = trcmod;
  phy->cbfn = (void (*)(void * , enum bfa_status  ))0;
  phy->cbarg = (void *)0;
  phy->op_busy = 0U;
  bfa_ioc_mbox_regisr(phy->ioc, 25, & bfa_phy_intr, (void *)phy);
  ((struct list_head *)(& phy->ioc_notify))->next = (struct list_head *)0;
  ((struct list_head *)(& phy->ioc_notify))->prev = (struct list_head *)0;
  phy->ioc_notify.cbfn = & bfa_phy_notify;
  phy->ioc_notify.cbarg = (void *)phy;
  list_add_tail(& phy->ioc_notify.qe, & (phy->ioc)->notify_q);
  if ((unsigned int )mincfg != 0U) {
    phy->dbuf_kva = (u8 *)0U;
    phy->dbuf_pa = 0ULL;
  } else {

  }
  return;
}
}
void bfa_phy_memclaim(struct bfa_phy_s *phy , u8 *dm_kva , u64 dm_pa , enum bfa_boolean mincfg ) 
{ 


  {
  if ((unsigned int )mincfg != 0U) {
    return;
  } else {

  }
  phy->dbuf_kva = dm_kva;
  phy->dbuf_pa = dm_pa;
  memset((void *)phy->dbuf_kva, 0, 8192UL);
  dm_kva = dm_kva + 8192UL;
  dm_pa = dm_pa + 8192ULL;
  return;
}
}
enum bfa_boolean bfa_phy_busy(struct bfa_ioc_s *ioc ) 
{ 
  void *rb ;
  unsigned int tmp ;

  {
  rb = ioc->pcidev.pci_bar_kva;
  tmp = readl((void const volatile   *)rb + 100472U);
  return ((enum bfa_boolean )tmp);
}
}
enum bfa_status bfa_phy_get_attr(struct bfa_phy_s *phy , u8 instance , struct bfa_phy_attr_s *attr ,
                                 void (*cbfn)(void * , enum bfa_status  ) , void *cbarg ) 
{ 
  enum bfa_boolean tmp ;
  enum bfa_boolean tmp___0 ;
  enum bfa_boolean tmp___1 ;

  {
  __bfa_trc(phy->trcmod, __trc_fileno___2, 5540, 1ULL);
  __bfa_trc(phy->trcmod, __trc_fileno___2, 5541, (unsigned long long )instance);
  tmp = bfa_phy_present(phy);
  if ((unsigned int )tmp == 0U) {
    return (183);
  } else {

  }
  tmp___0 = bfa_ioc_is_operational(phy->ioc);
  if ((unsigned int )tmp___0 == 0U) {
    return (61);
  } else {

  }
  if ((unsigned int )phy->op_busy != 0U) {
    __bfa_trc(phy->trcmod, __trc_fileno___2, 5550, (unsigned long long )phy->op_busy);
    return (13);
  } else {
    tmp___1 = bfa_phy_busy(phy->ioc);
    if ((unsigned int )tmp___1 != 0U) {
      __bfa_trc(phy->trcmod, __trc_fileno___2, 5550, (unsigned long long )phy->op_busy);
      return (13);
    } else {

    }
  }
  phy->op_busy = 1U;
  phy->cbfn = cbfn;
  phy->cbarg = cbarg;
  phy->instance = instance;
  phy->ubuf = (u8 *)attr;
  bfa_phy_query_send((void *)phy);
  return (0);
}
}
enum bfa_status bfa_phy_get_stats(struct bfa_phy_s *phy , u8 instance , struct bfa_phy_stats_s *stats ,
                                  void (*cbfn)(void * , enum bfa_status  ) , void *cbarg ) 
{ 
  enum bfa_boolean tmp ;
  enum bfa_boolean tmp___0 ;
  enum bfa_boolean tmp___1 ;

  {
  __bfa_trc(phy->trcmod, __trc_fileno___2, 5580, 2ULL);
  __bfa_trc(phy->trcmod, __trc_fileno___2, 5581, (unsigned long long )instance);
  tmp = bfa_phy_present(phy);
  if ((unsigned int )tmp == 0U) {
    return (183);
  } else {

  }
  tmp___0 = bfa_ioc_is_operational(phy->ioc);
  if ((unsigned int )tmp___0 == 0U) {
    return (61);
  } else {

  }
  if ((unsigned int )phy->op_busy != 0U) {
    __bfa_trc(phy->trcmod, __trc_fileno___2, 5590, (unsigned long long )phy->op_busy);
    return (13);
  } else {
    tmp___1 = bfa_phy_busy(phy->ioc);
    if ((unsigned int )tmp___1 != 0U) {
      __bfa_trc(phy->trcmod, __trc_fileno___2, 5590, (unsigned long long )phy->op_busy);
      return (13);
    } else {

    }
  }
  phy->op_busy = 1U;
  phy->cbfn = cbfn;
  phy->cbarg = cbarg;
  phy->instance = instance;
  phy->ubuf = (u8 *)stats;
  bfa_phy_stats_send((void *)phy);
  return (0);
}
}
enum bfa_status bfa_phy_update(struct bfa_phy_s *phy , u8 instance , void *buf , u32 len ,
                               u32 offset , void (*cbfn)(void * , enum bfa_status  ) ,
                               void *cbarg ) 
{ 
  enum bfa_boolean tmp ;
  enum bfa_boolean tmp___0 ;
  enum bfa_boolean tmp___1 ;

  {
  __bfa_trc(phy->trcmod, __trc_fileno___2, 5622, 3ULL);
  __bfa_trc(phy->trcmod, __trc_fileno___2, 5623, (unsigned long long )instance);
  __bfa_trc(phy->trcmod, __trc_fileno___2, 5624, (unsigned long long )len);
  __bfa_trc(phy->trcmod, __trc_fileno___2, 5625, (unsigned long long )offset);
  tmp = bfa_phy_present(phy);
  if ((unsigned int )tmp == 0U) {
    return (183);
  } else {

  }
  tmp___0 = bfa_ioc_is_operational(phy->ioc);
  if ((unsigned int )tmp___0 == 0U) {
    return (61);
  } else {

  }
  if (len == 0U || (len & 3U) != 0U) {
    return (1);
  } else {

  }
  if ((unsigned int )phy->op_busy != 0U) {
    __bfa_trc(phy->trcmod, __trc_fileno___2, 5638, (unsigned long long )phy->op_busy);
    return (13);
  } else {
    tmp___1 = bfa_phy_busy(phy->ioc);
    if ((unsigned int )tmp___1 != 0U) {
      __bfa_trc(phy->trcmod, __trc_fileno___2, 5638, (unsigned long long )phy->op_busy);
      return (13);
    } else {

    }
  }
  phy->op_busy = 1U;
  phy->cbfn = cbfn;
  phy->cbarg = cbarg;
  phy->instance = instance;
  phy->residue = len;
  phy->offset = 0U;
  phy->addr_off = offset;
  phy->ubuf = (u8 *)buf;
  bfa_phy_write_send((void *)phy);
  return (0);
}
}
enum bfa_status bfa_phy_read(struct bfa_phy_s *phy , u8 instance , void *buf , u32 len ,
                             u32 offset , void (*cbfn)(void * , enum bfa_status  ) ,
                             void *cbarg ) 
{ 
  enum bfa_boolean tmp ;
  enum bfa_boolean tmp___0 ;
  enum bfa_boolean tmp___1 ;

  {
  __bfa_trc(phy->trcmod, __trc_fileno___2, 5673, 4ULL);
  __bfa_trc(phy->trcmod, __trc_fileno___2, 5674, (unsigned long long )instance);
  __bfa_trc(phy->trcmod, __trc_fileno___2, 5675, (unsigned long long )len);
  __bfa_trc(phy->trcmod, __trc_fileno___2, 5676, (unsigned long long )offset);
  tmp = bfa_phy_present(phy);
  if ((unsigned int )tmp == 0U) {
    return (183);
  } else {

  }
  tmp___0 = bfa_ioc_is_operational(phy->ioc);
  if ((unsigned int )tmp___0 == 0U) {
    return (61);
  } else {

  }
  if (len == 0U || (len & 3U) != 0U) {
    return (1);
  } else {

  }
  if ((unsigned int )phy->op_busy != 0U) {
    __bfa_trc(phy->trcmod, __trc_fileno___2, 5689, (unsigned long long )phy->op_busy);
    return (13);
  } else {
    tmp___1 = bfa_phy_busy(phy->ioc);
    if ((unsigned int )tmp___1 != 0U) {
      __bfa_trc(phy->trcmod, __trc_fileno___2, 5689, (unsigned long long )phy->op_busy);
      return (13);
    } else {

    }
  }
  phy->op_busy = 1U;
  phy->cbfn = cbfn;
  phy->cbarg = cbarg;
  phy->instance = instance;
  phy->residue = len;
  phy->offset = 0U;
  phy->addr_off = offset;
  phy->ubuf = (u8 *)buf;
  bfa_phy_read_send((void *)phy);
  return (0);
}
}
void bfa_phy_intr(void *phyarg , struct bfi_mbmsg_s *msg ) 
{ 
  struct bfa_phy_s *phy ;
  u32 status ;
  union __anonunion_m_306 m ;
  __u32 tmp ;
  struct bfa_phy_attr_s *attr ;
  __u32 tmp___0 ;
  struct bfa_phy_stats_s *stats ;
  __u32 tmp___1 ;
  __u32 tmp___2 ;
  u32 len ;
  __u32 tmp___3 ;
  u16 *buf ;
  u16 *dbuf ;
  int i ;
  int sz ;
  __u16 tmp___4 ;
  int __ret_warn_on ;
  long tmp___5 ;

  {
  phy = (struct bfa_phy_s *)phyarg;
  m.msg = msg;
  __bfa_trc(phy->trcmod, __trc_fileno___2, 5727, (unsigned long long )msg->mh.msg_id);
  if ((unsigned int )phy->op_busy == 0U) {
    __bfa_trc(phy->trcmod, __trc_fileno___2, 5731, 39321ULL);
    return;
  } else {

  }
  switch ((int )msg->mh.msg_id) {
  case 129: 
  tmp = __fswab32((m.query)->status);
  status = tmp;
  __bfa_trc(phy->trcmod, __trc_fileno___2, 5738, (unsigned long long )status);
  if (status == 0U) {
    attr = (struct bfa_phy_attr_s *)phy->ubuf;
    bfa_phy_ntoh32((u32 *)attr, (u32 *)phy->dbuf_kva, 28);
    __bfa_trc(phy->trcmod, __trc_fileno___2, 5745, (unsigned long long )attr->status);
    __bfa_trc(phy->trcmod, __trc_fileno___2, 5746, (unsigned long long )attr->length);
  } else {

  }
  phy->status = (enum bfa_status )status;
  phy->op_busy = 0U;
  if ((unsigned long )phy->cbfn != (unsigned long )((void (*)(void * , enum bfa_status  ))0)) {
    (*(phy->cbfn))(phy->cbarg, phy->status);
  } else {

  }
  goto ldv_50022;
  case 130: 
  tmp___0 = __fswab32((m.stats)->status);
  status = tmp___0;
  __bfa_trc(phy->trcmod, __trc_fileno___2, 5756, (unsigned long long )status);
  if (status == 0U) {
    stats = (struct bfa_phy_stats_s *)phy->ubuf;
    bfa_phy_ntoh32((u32 *)stats, (u32 *)phy->dbuf_kva, 32);
    __bfa_trc(phy->trcmod, __trc_fileno___2, 5763, (unsigned long long )stats->status);
  } else {

  }
  phy->status = (enum bfa_status )status;
  phy->op_busy = 0U;
  if ((unsigned long )phy->cbfn != (unsigned long )((void (*)(void * , enum bfa_status  ))0)) {
    (*(phy->cbfn))(phy->cbarg, phy->status);
  } else {

  }
  goto ldv_50022;
  case 131: 
  tmp___1 = __fswab32((m.write)->status);
  status = tmp___1;
  __bfa_trc(phy->trcmod, __trc_fileno___2, 5773, (unsigned long long )status);
  if (status != 0U || phy->residue == 0U) {
    phy->status = (enum bfa_status )status;
    phy->op_busy = 0U;
    if ((unsigned long )phy->cbfn != (unsigned long )((void (*)(void * , enum bfa_status  ))0)) {
      (*(phy->cbfn))(phy->cbarg, phy->status);
    } else {

    }
  } else {
    __bfa_trc(phy->trcmod, __trc_fileno___2, 5781, (unsigned long long )phy->offset);
    bfa_phy_write_send((void *)phy);
  }
  goto ldv_50022;
  case 132: 
  tmp___2 = __fswab32((m.read)->status);
  status = tmp___2;
  __bfa_trc(phy->trcmod, __trc_fileno___2, 5787, (unsigned long long )status);
  if (status != 0U) {
    phy->status = (enum bfa_status )status;
    phy->op_busy = 0U;
    if ((unsigned long )phy->cbfn != (unsigned long )((void (*)(void * , enum bfa_status  ))0)) {
      (*(phy->cbfn))(phy->cbarg, phy->status);
    } else {

    }
  } else {
    tmp___3 = __fswab32((m.read)->length);
    len = tmp___3;
    buf = (u16 *)phy->ubuf + (unsigned long )phy->offset;
    dbuf = (u16 *)phy->dbuf_kva;
    sz = (int )(len >> 1);
    __bfa_trc(phy->trcmod, __trc_fileno___2, 5800, (unsigned long long )phy->offset);
    __bfa_trc(phy->trcmod, __trc_fileno___2, 5801, (unsigned long long )len);
    i = 0;
    goto ldv_50033;
    ldv_50032: 
    tmp___4 = __fswab16((int )*(dbuf + (unsigned long )i));
    *(buf + (unsigned long )i) = tmp___4;
    i = i + 1;
    ldv_50033: ;
    if (i < sz) {
      goto ldv_50032;
    } else {

    }
    phy->residue = phy->residue - len;
    phy->offset = phy->offset + len;
    if (phy->residue == 0U) {
      phy->status = (enum bfa_status )status;
      phy->op_busy = 0U;
      if ((unsigned long )phy->cbfn != (unsigned long )((void (*)(void * , enum bfa_status  ))0)) {
        (*(phy->cbfn))(phy->cbarg, phy->status);
      } else {

      }
    } else {
      bfa_phy_read_send((void *)phy);
    }
  }
  goto ldv_50022;
  default: 
  __ret_warn_on = 1;
  tmp___5 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp___5 != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_ioc.c",
                       5819);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  }
  ldv_50022: ;
  return;
}
}
static void bfa_dconf_meminfo(struct bfa_iocfc_cfg_s *cfg , struct bfa_meminfo_s *meminfo ,
                              struct bfa_s *bfa ) ;
static void bfa_dconf_attach(struct bfa_s *bfa , void *bfad , struct bfa_iocfc_cfg_s *cfg ,
                             struct bfa_pcidev_s *pcidev ) ;
static void bfa_dconf_detach(struct bfa_s *bfa ) ;
static void bfa_dconf_start(struct bfa_s *bfa ) ;
static void bfa_dconf_stop(struct bfa_s *bfa ) ;
static void bfa_dconf_iocdisable(struct bfa_s *bfa ) ;
struct bfa_module_s hal_mod_dconf  =    {& bfa_dconf_meminfo, & bfa_dconf_attach, & bfa_dconf_detach, & bfa_dconf_start,
    & bfa_dconf_stop, & bfa_dconf_iocdisable};
static void bfa_dconf_sm_uninit(struct bfa_dconf_mod_s *dconf , enum bfa_dconf_event event ) ;
static void bfa_dconf_sm_flash_read(struct bfa_dconf_mod_s *dconf , enum bfa_dconf_event event ) ;
static void bfa_dconf_sm_ready(struct bfa_dconf_mod_s *dconf , enum bfa_dconf_event event ) ;
static void bfa_dconf_sm_dirty(struct bfa_dconf_mod_s *dconf , enum bfa_dconf_event event ) ;
static void bfa_dconf_sm_sync(struct bfa_dconf_mod_s *dconf , enum bfa_dconf_event event ) ;
static void bfa_dconf_sm_final_sync(struct bfa_dconf_mod_s *dconf , enum bfa_dconf_event event ) ;
static void bfa_dconf_sm_iocdown_dirty(struct bfa_dconf_mod_s *dconf , enum bfa_dconf_event event ) ;
static void bfa_dconf_cbfn(void *arg , enum bfa_status status ) ;
static void bfa_dconf_timer(void *cbarg ) ;
static enum bfa_status bfa_dconf_flash_write(struct bfa_dconf_mod_s *dconf ) ;
static void bfa_dconf_init_cb(void *arg , enum bfa_status status ) ;
static void bfa_dconf_sm_uninit(struct bfa_dconf_mod_s *dconf , enum bfa_dconf_event event ) 
{ 
  enum bfa_status bfa_status ;

  {
  __bfa_trc((dconf->bfa)->trcmod, __trc_fileno___2, 5869, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 1U: ;
  if ((unsigned int )dconf->min_cfg != 0U) {
    __bfa_trc((dconf->bfa)->trcmod, __trc_fileno___2, 5874, (unsigned long long )dconf->min_cfg);
    (*((dconf->bfa)->iocfc.fsm))((void *)(& (dconf->bfa)->iocfc), 9);
    return;
  } else {

  }
  dconf->sm = (void (*)(void * , int  ))(& bfa_dconf_sm_flash_read);
  bfa_timer_begin(& (dconf->bfa)->timer_mod, & dconf->timer, & bfa_dconf_timer, (void *)dconf,
                  10000U);
  bfa_status = bfa_flash_read_part(& (dconf->bfa)->modules.flash, 4, (int )dconf->instance,
                                   (void *)dconf->dconf, 536U, 0U, & bfa_dconf_init_cb,
                                   (void *)dconf->bfa);
  if ((unsigned int )bfa_status != 0U) {
    bfa_timer_stop(& dconf->timer);
    bfa_dconf_init_cb((void *)dconf->bfa, 1);
    dconf->sm = (void (*)(void * , int  ))(& bfa_dconf_sm_uninit);
    return;
  } else {

  }
  goto ldv_50101;
  case 5U: 
  (*((dconf->bfa)->iocfc.fsm))((void *)(& (dconf->bfa)->iocfc), 9);
  case 6U: ;
  case 3U: ;
  case 2U: ;
  goto ldv_50101;
  default: 
  __bfa_trc((dconf->bfa)->trcmod, __trc_fileno___2, 5901, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_ioc.c",
         5901, (unsigned int )event);
  }
  ldv_50101: ;
  return;
}
}
static void bfa_dconf_sm_flash_read(struct bfa_dconf_mod_s *dconf , enum bfa_dconf_event event ) 
{ 


  {
  __bfa_trc((dconf->bfa)->trcmod, __trc_fileno___2, 5912, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 2U: 
  bfa_timer_stop(& dconf->timer);
  dconf->sm = (void (*)(void * , int  ))(& bfa_dconf_sm_ready);
  goto ldv_50112;
  case 4U: 
  dconf->sm = (void (*)(void * , int  ))(& bfa_dconf_sm_ready);
  bfa_ioc_suspend(& (dconf->bfa)->ioc);
  goto ldv_50112;
  case 5U: 
  bfa_timer_stop(& dconf->timer);
  dconf->sm = (void (*)(void * , int  ))(& bfa_dconf_sm_uninit);
  (*((dconf->bfa)->iocfc.fsm))((void *)(& (dconf->bfa)->iocfc), 9);
  goto ldv_50112;
  case 6U: 
  bfa_timer_stop(& dconf->timer);
  dconf->sm = (void (*)(void * , int  ))(& bfa_dconf_sm_uninit);
  goto ldv_50112;
  default: 
  __bfa_trc((dconf->bfa)->trcmod, __trc_fileno___2, 5933, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_ioc.c",
         5933, (unsigned int )event);
  }
  ldv_50112: ;
  return;
}
}
static void bfa_dconf_sm_ready(struct bfa_dconf_mod_s *dconf , enum bfa_dconf_event event ) 
{ 


  {
  __bfa_trc((dconf->bfa)->trcmod, __trc_fileno___2, 5943, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 3U: 
  bfa_timer_begin(& (dconf->bfa)->timer_mod, & dconf->timer, & bfa_dconf_timer, (void *)dconf,
                  5000U);
  dconf->sm = (void (*)(void * , int  ))(& bfa_dconf_sm_dirty);
  goto ldv_50122;
  case 5U: 
  dconf->sm = (void (*)(void * , int  ))(& bfa_dconf_sm_uninit);
  (*((dconf->bfa)->iocfc.fsm))((void *)(& (dconf->bfa)->iocfc), 9);
  goto ldv_50122;
  case 1U: ;
  case 6U: ;
  goto ldv_50122;
  default: 
  __bfa_trc((dconf->bfa)->trcmod, __trc_fileno___2, 5959, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_ioc.c",
         5959, (unsigned int )event);
  }
  ldv_50122: ;
  return;
}
}
static void bfa_dconf_sm_dirty(struct bfa_dconf_mod_s *dconf , enum bfa_dconf_event event ) 
{ 


  {
  __bfa_trc((dconf->bfa)->trcmod, __trc_fileno___2, 5970, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 4U: 
  dconf->sm = (void (*)(void * , int  ))(& bfa_dconf_sm_sync);
  bfa_dconf_flash_write(dconf);
  goto ldv_50132;
  case 3U: 
  bfa_timer_stop(& dconf->timer);
  bfa_timer_begin(& (dconf->bfa)->timer_mod, & dconf->timer, & bfa_dconf_timer, (void *)dconf,
                  5000U);
  goto ldv_50132;
  case 5U: 
  bfa_timer_stop(& dconf->timer);
  bfa_timer_begin(& (dconf->bfa)->timer_mod, & dconf->timer, & bfa_dconf_timer, (void *)dconf,
                  5000U);
  dconf->sm = (void (*)(void * , int  ))(& bfa_dconf_sm_final_sync);
  bfa_dconf_flash_write(dconf);
  goto ldv_50132;
  case 2U: ;
  goto ldv_50132;
  case 6U: 
  bfa_timer_stop(& dconf->timer);
  dconf->sm = (void (*)(void * , int  ))(& bfa_dconf_sm_iocdown_dirty);
  goto ldv_50132;
  default: 
  __bfa_trc((dconf->bfa)->trcmod, __trc_fileno___2, 5996, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_ioc.c",
         5996, (unsigned int )event);
  }
  ldv_50132: ;
  return;
}
}
static void bfa_dconf_sm_final_sync(struct bfa_dconf_mod_s *dconf , enum bfa_dconf_event event ) 
{ 


  {
  __bfa_trc((dconf->bfa)->trcmod, __trc_fileno___2, 6007, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 6U: ;
  case 2U: 
  bfa_timer_stop(& dconf->timer);
  case 4U: 
  dconf->sm = (void (*)(void * , int  ))(& bfa_dconf_sm_uninit);
  (*((dconf->bfa)->iocfc.fsm))((void *)(& (dconf->bfa)->iocfc), 9);
  goto ldv_50145;
  default: 
  __bfa_trc((dconf->bfa)->trcmod, __trc_fileno___2, 6018, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_ioc.c",
         6018, (unsigned int )event);
  }
  ldv_50145: ;
  return;
}
}
static void bfa_dconf_sm_sync(struct bfa_dconf_mod_s *dconf , enum bfa_dconf_event event ) 
{ 


  {
  __bfa_trc((dconf->bfa)->trcmod, __trc_fileno___2, 6025, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 2U: 
  dconf->sm = (void (*)(void * , int  ))(& bfa_dconf_sm_ready);
  goto ldv_50152;
  case 3U: 
  bfa_timer_begin(& (dconf->bfa)->timer_mod, & dconf->timer, & bfa_dconf_timer, (void *)dconf,
                  5000U);
  dconf->sm = (void (*)(void * , int  ))(& bfa_dconf_sm_dirty);
  goto ldv_50152;
  case 5U: 
  bfa_timer_begin(& (dconf->bfa)->timer_mod, & dconf->timer, & bfa_dconf_timer, (void *)dconf,
                  5000U);
  dconf->sm = (void (*)(void * , int  ))(& bfa_dconf_sm_final_sync);
  goto ldv_50152;
  case 6U: 
  dconf->sm = (void (*)(void * , int  ))(& bfa_dconf_sm_iocdown_dirty);
  goto ldv_50152;
  default: 
  __bfa_trc((dconf->bfa)->trcmod, __trc_fileno___2, 6045, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_ioc.c",
         6045, (unsigned int )event);
  }
  ldv_50152: ;
  return;
}
}
static void bfa_dconf_sm_iocdown_dirty(struct bfa_dconf_mod_s *dconf , enum bfa_dconf_event event ) 
{ 


  {
  __bfa_trc((dconf->bfa)->trcmod, __trc_fileno___2, 6053, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 1U: 
  bfa_timer_begin(& (dconf->bfa)->timer_mod, & dconf->timer, & bfa_dconf_timer, (void *)dconf,
                  5000U);
  dconf->sm = (void (*)(void * , int  ))(& bfa_dconf_sm_dirty);
  goto ldv_50162;
  case 5U: 
  dconf->sm = (void (*)(void * , int  ))(& bfa_dconf_sm_uninit);
  (*((dconf->bfa)->iocfc.fsm))((void *)(& (dconf->bfa)->iocfc), 9);
  goto ldv_50162;
  case 6U: ;
  goto ldv_50162;
  default: 
  __bfa_trc((dconf->bfa)->trcmod, __trc_fileno___2, 6068, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_ioc.c",
         6068, (unsigned int )event);
  }
  ldv_50162: ;
  return;
}
}
static void bfa_dconf_meminfo(struct bfa_iocfc_cfg_s *cfg , struct bfa_meminfo_s *meminfo ,
                              struct bfa_s *bfa ) 
{ 
  struct bfa_mem_kva_s *dconf_kva ;

  {
  dconf_kva = & bfa->modules.dconf_mod.kva_seg;
  if ((unsigned int )cfg->drvcfg.min_cfg != 0U) {
    dconf_kva->mem_len = 8U;
    list_add_tail(& dconf_kva->qe, & meminfo->kva_info.qe);
  } else {
    dconf_kva->mem_len = 536U;
    list_add_tail(& dconf_kva->qe, & meminfo->kva_info.qe);
  }
  return;
}
}
static void bfa_dconf_attach(struct bfa_s *bfa , void *bfad , struct bfa_iocfc_cfg_s *cfg ,
                             struct bfa_pcidev_s *pcidev ) 
{ 
  struct bfa_dconf_mod_s *dconf ;

  {
  dconf = & bfa->modules.dconf_mod;
  dconf->bfad = bfad;
  dconf->bfa = bfa;
  dconf->instance = bfa->ioc.port_id;
  __bfa_trc(bfa->trcmod, __trc_fileno___2, 6098, (unsigned long long )dconf->instance);
  dconf->dconf = (struct bfa_dconf_s *)dconf->kva_seg.kva_curp;
  if ((unsigned int )cfg->drvcfg.min_cfg != 0U) {
    dconf->kva_seg.kva_curp = dconf->kva_seg.kva_curp + 8UL;
    dconf->min_cfg = 1;
  } else {
    dconf->min_cfg = 0;
    dconf->kva_seg.kva_curp = dconf->kva_seg.kva_curp + 536UL;
  }
  bfa->modules.dconf_mod.read_data_valid = 0;
  dconf->sm = (void (*)(void * , int  ))(& bfa_dconf_sm_uninit);
  return;
}
}
static void bfa_dconf_init_cb(void *arg , enum bfa_status status ) 
{ 
  struct bfa_s *bfa ;
  struct bfa_dconf_mod_s *dconf ;

  {
  bfa = (struct bfa_s *)arg;
  dconf = & bfa->modules.dconf_mod;
  if ((unsigned int )status == 0U) {
    bfa->modules.dconf_mod.read_data_valid = 1;
    if ((dconf->dconf)->hdr.signature != 2882382797U) {
      (dconf->dconf)->hdr.signature = 2882382797U;
    } else {

    }
    if ((dconf->dconf)->hdr.version != 1U) {
      (dconf->dconf)->hdr.version = 1U;
    } else {

    }
  } else {

  }
  (*(dconf->sm))((void *)dconf, 2);
  (*(bfa->iocfc.fsm))((void *)(& bfa->iocfc), 9);
  return;
}
}
void bfa_dconf_modinit(struct bfa_s *bfa ) 
{ 
  struct bfa_dconf_mod_s *dconf ;

  {
  dconf = & bfa->modules.dconf_mod;
  (*(dconf->sm))((void *)dconf, 1);
  return;
}
}
static void bfa_dconf_start(struct bfa_s *bfa ) 
{ 


  {
  return;
}
}
static void bfa_dconf_stop(struct bfa_s *bfa ) 
{ 


  {
  return;
}
}
static void bfa_dconf_timer(void *cbarg ) 
{ 
  struct bfa_dconf_mod_s *dconf ;

  {
  dconf = (struct bfa_dconf_mod_s *)cbarg;
  (*(dconf->sm))((void *)dconf, 4);
  return;
}
}
static void bfa_dconf_iocdisable(struct bfa_s *bfa ) 
{ 
  struct bfa_dconf_mod_s *dconf ;

  {
  dconf = & bfa->modules.dconf_mod;
  (*(dconf->sm))((void *)dconf, 6);
  return;
}
}
static void bfa_dconf_detach(struct bfa_s *bfa ) 
{ 


  {
  return;
}
}
static enum bfa_status bfa_dconf_flash_write(struct bfa_dconf_mod_s *dconf ) 
{ 
  enum bfa_status bfa_status ;
  int __ret_warn_on ;
  long tmp ;

  {
  __bfa_trc((dconf->bfa)->trcmod, __trc_fileno___2, 6167, 0ULL);
  bfa_status = bfa_flash_update_part(& (dconf->bfa)->modules.flash, 4, (int )dconf->instance,
                                     (void *)dconf->dconf, 536U, 0U, & bfa_dconf_cbfn,
                                     (void *)dconf);
  if ((unsigned int )bfa_status != 0U) {
    __ret_warn_on = (unsigned int )bfa_status != 0U;
    tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
    if (tmp != 0L) {
      warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_ioc.c",
                         6174);
    } else {

    }
    ldv__builtin_expect(__ret_warn_on != 0, 0L);
  } else {

  }
  __bfa_trc((dconf->bfa)->trcmod, __trc_fileno___2, 6175, (unsigned long long )bfa_status);
  return (bfa_status);
}
}
enum bfa_status bfa_dconf_update(struct bfa_s *bfa ) 
{ 
  struct bfa_dconf_mod_s *dconf ;

  {
  dconf = & bfa->modules.dconf_mod;
  __bfa_trc((dconf->bfa)->trcmod, __trc_fileno___2, 6184, 0ULL);
  if ((unsigned long )dconf->sm == (unsigned long )((void (*)(void * , int  ))(& bfa_dconf_sm_iocdown_dirty))) {
    return (1);
  } else {

  }
  if ((unsigned int )dconf->min_cfg != 0U) {
    __bfa_trc((dconf->bfa)->trcmod, __trc_fileno___2, 6189, (unsigned long long )dconf->min_cfg);
    return (1);
  } else {

  }
  (*(dconf->sm))((void *)dconf, 3);
  return (0);
}
}
static void bfa_dconf_cbfn(void *arg , enum bfa_status status ) 
{ 
  struct bfa_dconf_mod_s *dconf ;
  int __ret_warn_on ;
  long tmp ;

  {
  dconf = (struct bfa_dconf_mod_s *)arg;
  __ret_warn_on = (unsigned int )status != 0U;
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_ioc.c",
                       6201);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  (*(dconf->sm))((void *)dconf, 2);
  return;
}
}
void bfa_dconf_modexit(struct bfa_s *bfa ) 
{ 
  struct bfa_dconf_mod_s *dconf ;

  {
  dconf = & bfa->modules.dconf_mod;
  (*(dconf->sm))((void *)dconf, 5);
  return;
}
}
static void bfa_fru_notify(void *cbarg , enum bfa_ioc_event_e event ) 
{ 
  struct bfa_fru_s *fru ;

  {
  fru = (struct bfa_fru_s *)cbarg;
  __bfa_trc(fru->trcmod, __trc_fileno___2, 6225, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 2U: ;
  case 3U: ;
  if ((unsigned int )fru->op_busy != 0U) {
    fru->status = 56;
    (*(fru->cbfn))(fru->cbarg, fru->status);
    fru->op_busy = 0U;
  } else {

  }
  goto ldv_50234;
  default: ;
  goto ldv_50234;
  }
  ldv_50234: ;
  return;
}
}
static void bfa_fru_write_send(void *cbarg , enum bfi_fru_h2i_msgs msg_type ) 
{ 
  struct bfa_fru_s *fru ;
  struct bfi_fru_write_req_s *msg ;
  u32 len ;
  __u32 tmp ;
  __u32 tmp___0 ;

  {
  fru = (struct bfa_fru_s *)cbarg;
  msg = (struct bfi_fru_write_req_s *)(& fru->mb.msg);
  tmp = __fswab32(fru->addr_off + fru->offset);
  msg->offset = tmp;
  len = 8192U < fru->residue ? 8192U : fru->residue;
  tmp___0 = __fswab32(len);
  msg->length = tmp___0;
  msg->last = fru->residue == len;
  msg->trfr_cmpl = fru->residue == len ? fru->trfr_cmpl : 0U;
  msg->mh.msg_class = 34U;
  msg->mh.msg_id = (u8 )msg_type;
  msg->mh.mtag.h2i.fn_lpu = (fru->ioc)->port_id;
  __bfa_alen_set(& msg->alen, len, fru->dbuf_pa);
  memcpy((void *)fru->dbuf_kva, (void const   *)fru->ubuf + (unsigned long )fru->offset,
           (size_t )len);
  bfa_ioc_mbox_queue(fru->ioc, & fru->mb);
  fru->residue = fru->residue - len;
  fru->offset = fru->offset + len;
  return;
}
}
static void bfa_fru_read_send(void *cbarg , enum bfi_fru_h2i_msgs msg_type ) 
{ 
  struct bfa_fru_s *fru ;
  struct bfi_fru_read_req_s *msg ;
  u32 len ;
  __u32 tmp ;
  __u32 tmp___0 ;

  {
  fru = (struct bfa_fru_s *)cbarg;
  msg = (struct bfi_fru_read_req_s *)(& fru->mb.msg);
  tmp = __fswab32(fru->addr_off + fru->offset);
  msg->offset = tmp;
  len = 8192U < fru->residue ? 8192U : fru->residue;
  tmp___0 = __fswab32(len);
  msg->length = tmp___0;
  msg->mh.msg_class = 34U;
  msg->mh.msg_id = (u8 )msg_type;
  msg->mh.mtag.h2i.fn_lpu = (fru->ioc)->port_id;
  __bfa_alen_set(& msg->alen, len, fru->dbuf_pa);
  bfa_ioc_mbox_queue(fru->ioc, & fru->mb);
  return;
}
}
u32 bfa_fru_meminfo(enum bfa_boolean mincfg ) 
{ 


  {
  if ((unsigned int )mincfg != 0U) {
    return (0U);
  } else {

  }
  return (8192U);
}
}
void bfa_fru_attach(struct bfa_fru_s *fru , struct bfa_ioc_s *ioc , void *dev , struct bfa_trc_mod_s *trcmod ,
                    enum bfa_boolean mincfg ) 
{ 


  {
  fru->ioc = ioc;
  fru->trcmod = trcmod;
  fru->cbfn = (void (*)(void * , enum bfa_status  ))0;
  fru->cbarg = (void *)0;
  fru->op_busy = 0U;
  bfa_ioc_mbox_regisr(fru->ioc, 34, & bfa_fru_intr, (void *)fru);
  ((struct list_head *)(& fru->ioc_notify))->next = (struct list_head *)0;
  ((struct list_head *)(& fru->ioc_notify))->prev = (struct list_head *)0;
  fru->ioc_notify.cbfn = & bfa_fru_notify;
  fru->ioc_notify.cbarg = (void *)fru;
  list_add_tail(& fru->ioc_notify.qe, & (fru->ioc)->notify_q);
  if ((unsigned int )mincfg != 0U) {
    fru->dbuf_kva = (u8 *)0U;
    fru->dbuf_pa = 0ULL;
  } else {

  }
  return;
}
}
void bfa_fru_memclaim(struct bfa_fru_s *fru , u8 *dm_kva , u64 dm_pa , enum bfa_boolean mincfg ) 
{ 


  {
  if ((unsigned int )mincfg != 0U) {
    return;
  } else {

  }
  fru->dbuf_kva = dm_kva;
  fru->dbuf_pa = dm_pa;
  memset((void *)fru->dbuf_kva, 0, 8192UL);
  dm_kva = dm_kva + 8192UL;
  dm_pa = dm_pa + 8192ULL;
  return;
}
}
enum bfa_status bfa_fruvpd_update(struct bfa_fru_s *fru , void *buf , u32 len , u32 offset ,
                                  void (*cbfn)(void * , enum bfa_status  ) , void *cbarg ,
                                  u8 trfr_cmpl ) 
{ 
  enum bfa_boolean tmp ;

  {
  __bfa_trc(fru->trcmod, __trc_fileno___2, 6382, 1ULL);
  __bfa_trc(fru->trcmod, __trc_fileno___2, 6383, (unsigned long long )len);
  __bfa_trc(fru->trcmod, __trc_fileno___2, 6384, (unsigned long long )offset);
  if ((unsigned int )(fru->ioc)->asic_gen != 3U && ((fru->ioc)->attr)->card_type != 1869U) {
    return (240);
  } else {

  }
  if (((fru->ioc)->attr)->card_type != 1867U) {
    return (26);
  } else {

  }
  tmp = bfa_ioc_is_operational(fru->ioc);
  if ((unsigned int )tmp == 0U) {
    return (61);
  } else {

  }
  if ((unsigned int )fru->op_busy != 0U) {
    __bfa_trc(fru->trcmod, __trc_fileno___2, 6397, (unsigned long long )fru->op_busy);
    return (13);
  } else {

  }
  fru->op_busy = 1U;
  fru->cbfn = cbfn;
  fru->cbarg = cbarg;
  fru->residue = len;
  fru->offset = 0U;
  fru->addr_off = offset;
  fru->ubuf = (u8 *)buf;
  fru->trfr_cmpl = trfr_cmpl;
  bfa_fru_write_send((void *)fru, 1);
  return (0);
}
}
enum bfa_status bfa_fruvpd_read(struct bfa_fru_s *fru , void *buf , u32 len , u32 offset ,
                                void (*cbfn)(void * , enum bfa_status  ) , void *cbarg ) 
{ 
  enum bfa_boolean tmp ;

  {
  __bfa_trc(fru->trcmod, __trc_fileno___2, 6432, 2ULL);
  __bfa_trc(fru->trcmod, __trc_fileno___2, 6433, (unsigned long long )len);
  __bfa_trc(fru->trcmod, __trc_fileno___2, 6434, (unsigned long long )offset);
  if ((unsigned int )(fru->ioc)->asic_gen != 3U) {
    return (240);
  } else {

  }
  if (((fru->ioc)->attr)->card_type != 1867U && ((fru->ioc)->attr)->card_type != 1869U) {
    return (26);
  } else {

  }
  tmp = bfa_ioc_is_operational(fru->ioc);
  if ((unsigned int )tmp == 0U) {
    return (61);
  } else {

  }
  if ((unsigned int )fru->op_busy != 0U) {
    __bfa_trc(fru->trcmod, __trc_fileno___2, 6447, (unsigned long long )fru->op_busy);
    return (13);
  } else {

  }
  fru->op_busy = 1U;
  fru->cbfn = cbfn;
  fru->cbarg = cbarg;
  fru->residue = len;
  fru->offset = 0U;
  fru->addr_off = offset;
  fru->ubuf = (u8 *)buf;
  bfa_fru_read_send((void *)fru, 2);
  return (0);
}
}
enum bfa_status bfa_fruvpd_get_max_size(struct bfa_fru_s *fru , u32 *max_size ) 
{ 
  enum bfa_boolean tmp ;

  {
  if ((unsigned int )(fru->ioc)->asic_gen != 3U) {
    return (240);
  } else {

  }
  tmp = bfa_ioc_is_operational(fru->ioc);
  if ((unsigned int )tmp == 0U) {
    return (61);
  } else {

  }
  if (((fru->ioc)->attr)->card_type == 1867U || ((fru->ioc)->attr)->card_type == 1869U) {
    *max_size = 65536U;
  } else {
    return (26);
  }
  return (0);
}
}
enum bfa_status bfa_tfru_write(struct bfa_fru_s *fru , void *buf , u32 len , u32 offset ,
                               void (*cbfn)(void * , enum bfa_status  ) , void *cbarg ) 
{ 
  enum bfa_boolean tmp ;

  {
  __bfa_trc(fru->trcmod, __trc_fileno___2, 6504, 3ULL);
  __bfa_trc(fru->trcmod, __trc_fileno___2, 6505, (unsigned long long )len);
  __bfa_trc(fru->trcmod, __trc_fileno___2, 6506, (unsigned long long )offset);
  __bfa_trc(fru->trcmod, __trc_fileno___2, 6507, (unsigned long long )*((u8 *)buf));
  if ((unsigned int )(fru->ioc)->asic_gen != 3U) {
    return (240);
  } else {

  }
  tmp = bfa_ioc_is_operational(fru->ioc);
  if ((unsigned int )tmp == 0U) {
    return (61);
  } else {

  }
  if ((unsigned int )fru->op_busy != 0U) {
    __bfa_trc(fru->trcmod, __trc_fileno___2, 6516, (unsigned long long )fru->op_busy);
    return (13);
  } else {

  }
  fru->op_busy = 1U;
  fru->cbfn = cbfn;
  fru->cbarg = cbarg;
  fru->residue = len;
  fru->offset = 0U;
  fru->addr_off = offset;
  fru->ubuf = (u8 *)buf;
  bfa_fru_write_send((void *)fru, 3);
  return (0);
}
}
enum bfa_status bfa_tfru_read(struct bfa_fru_s *fru , void *buf , u32 len , u32 offset ,
                              void (*cbfn)(void * , enum bfa_status  ) , void *cbarg ) 
{ 
  enum bfa_boolean tmp ;

  {
  __bfa_trc(fru->trcmod, __trc_fileno___2, 6550, 4ULL);
  __bfa_trc(fru->trcmod, __trc_fileno___2, 6551, (unsigned long long )len);
  __bfa_trc(fru->trcmod, __trc_fileno___2, 6552, (unsigned long long )offset);
  if ((unsigned int )(fru->ioc)->asic_gen != 3U) {
    return (240);
  } else {

  }
  tmp = bfa_ioc_is_operational(fru->ioc);
  if ((unsigned int )tmp == 0U) {
    return (61);
  } else {

  }
  if ((unsigned int )fru->op_busy != 0U) {
    __bfa_trc(fru->trcmod, __trc_fileno___2, 6561, (unsigned long long )fru->op_busy);
    return (13);
  } else {

  }
  fru->op_busy = 1U;
  fru->cbfn = cbfn;
  fru->cbarg = cbarg;
  fru->residue = len;
  fru->offset = 0U;
  fru->addr_off = offset;
  fru->ubuf = (u8 *)buf;
  bfa_fru_read_send((void *)fru, 4);
  return (0);
}
}
void bfa_fru_intr(void *fruarg , struct bfi_mbmsg_s *msg ) 
{ 
  struct bfa_fru_s *fru ;
  struct bfi_fru_rsp_s *rsp ;
  u32 status ;
  __u32 tmp ;
  __u32 tmp___0 ;
  u32 len ;
  __u32 tmp___1 ;
  int __ret_warn_on ;
  long tmp___2 ;

  {
  fru = (struct bfa_fru_s *)fruarg;
  rsp = (struct bfi_fru_rsp_s *)msg;
  __bfa_trc(fru->trcmod, __trc_fileno___2, 6591, (unsigned long long )msg->mh.msg_id);
  if ((unsigned int )fru->op_busy == 0U) {
    __bfa_trc(fru->trcmod, __trc_fileno___2, 6597, 39321ULL);
    return;
  } else {

  }
  switch ((int )msg->mh.msg_id) {
  case 129: ;
  case 131: 
  tmp = __fswab32(rsp->status);
  status = tmp;
  __bfa_trc(fru->trcmod, __trc_fileno___2, 6605, (unsigned long long )status);
  if (status != 0U || fru->residue == 0U) {
    fru->status = (enum bfa_status )status;
    fru->op_busy = 0U;
    if ((unsigned long )fru->cbfn != (unsigned long )((void (*)(void * , enum bfa_status  ))0)) {
      (*(fru->cbfn))(fru->cbarg, fru->status);
    } else {

    }
  } else {
    __bfa_trc(fru->trcmod, __trc_fileno___2, 6613, (unsigned long long )fru->offset);
    if ((unsigned int )msg->mh.msg_id == 129U) {
      bfa_fru_write_send((void *)fru, 1);
    } else {
      bfa_fru_write_send((void *)fru, 3);
    }
  }
  goto ldv_50312;
  case 130: ;
  case 132: 
  tmp___0 = __fswab32(rsp->status);
  status = tmp___0;
  __bfa_trc(fru->trcmod, __trc_fileno___2, 6625, (unsigned long long )status);
  if (status != 0U) {
    fru->status = (enum bfa_status )status;
    fru->op_busy = 0U;
    if ((unsigned long )fru->cbfn != (unsigned long )((void (*)(void * , enum bfa_status  ))0)) {
      (*(fru->cbfn))(fru->cbarg, fru->status);
    } else {

    }
  } else {
    tmp___1 = __fswab32(rsp->length);
    len = tmp___1;
    __bfa_trc(fru->trcmod, __trc_fileno___2, 6635, (unsigned long long )fru->offset);
    __bfa_trc(fru->trcmod, __trc_fileno___2, 6636, (unsigned long long )len);
    memcpy((void *)fru->ubuf + (unsigned long )fru->offset, (void const   *)fru->dbuf_kva,
             (size_t )len);
    fru->residue = fru->residue - len;
    fru->offset = fru->offset + len;
    if (fru->residue == 0U) {
      fru->status = (enum bfa_status )status;
      fru->op_busy = 0U;
      if ((unsigned long )fru->cbfn != (unsigned long )((void (*)(void * , enum bfa_status  ))0)) {
        (*(fru->cbfn))(fru->cbarg, fru->status);
      } else {

      }
    } else
    if ((unsigned int )msg->mh.msg_id == 130U) {
      bfa_fru_read_send((void *)fru, 2);
    } else {
      bfa_fru_read_send((void *)fru, 4);
    }
  }
  goto ldv_50312;
  default: 
  __ret_warn_on = 1;
  tmp___2 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp___2 != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_ioc.c",
                       6658);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  }
  ldv_50312: ;
  return;
}
}
static void bfa_flash_set_cmd(void *pci_bar , u8 wr_cnt , u8 rd_cnt , u8 ad_cnt ,
                              u8 op ) 
{ 
  union bfa_flash_cmd_reg_u cmd ;

  {
  cmd.i = 0U;
  cmd.r.act = 1U;
  cmd.r.write_cnt = (unsigned short )wr_cnt;
  cmd.r.read_cnt = (unsigned short )rd_cnt;
  cmd.r.addr_cnt = ad_cnt;
  cmd.r.cmd = op;
  writel(cmd.i, (void volatile   *)pci_bar + 118784U);
  return;
}
}
static void bfa_flash_set_addr(void *pci_bar , u32 address ) 
{ 
  union bfa_flash_addr_reg_u addr ;

  {
  addr.r.addr = address & 16777215U;
  addr.r.dummy = 0U;
  writel(addr.i, (void volatile   *)pci_bar + 118788U);
  return;
}
}
static int bfa_flash_cmd_act_check(void *pci_bar ) 
{ 
  union bfa_flash_cmd_reg_u cmd ;

  {
  cmd.i = readl((void const volatile   *)pci_bar + 118784U);
  if ((unsigned int )*((unsigned char *)(& cmd) + 3UL) != 0U) {
    return (-5);
  } else {

  }
  return (0);
}
}
static u32 bfa_flash_fifo_flush(void *pci_bar ) 
{ 
  u32 i ;
  u32 t ;
  union bfa_flash_dev_status_reg_u dev_status ;

  {
  dev_status.i = readl((void const volatile   *)pci_bar + 118804U);
  if ((unsigned int )*((unsigned short *)(& dev_status) + 0UL) == 0U) {
    return (0U);
  } else {

  }
  i = 0U;
  goto ldv_50383;
  ldv_50382: 
  t = readl((void const volatile   *)pci_bar + 118800U);
  i = i + 1U;
  ldv_50383: ;
  if ((u32 )dev_status.r.fifo_cnt > i) {
    goto ldv_50382;
  } else {

  }
  i = 0U;
  goto ldv_50387;
  ldv_50386: 
  dev_status.i = readl((void const volatile   *)pci_bar + 118804U);
  if ((unsigned int )*((unsigned short *)(& dev_status) + 0UL) == 0U) {
    goto ldv_50385;
  } else {

  }
  i = i + 1U;
  ldv_50387: ;
  if (i <= 9999U) {
    goto ldv_50386;
  } else {

  }
  ldv_50385: ;
  if ((unsigned int )*((unsigned short *)(& dev_status) + 0UL) != 0U) {
    return (4294967290U);
  } else {

  }
  return (0U);
}
}
static u32 bfa_flash_status_read(void *pci_bar ) 
{ 
  union bfa_flash_dev_status_reg_u dev_status ;
  int status ;
  u32 ret_status ;
  int i ;
  u32 tmp ;
  u32 tmp___0 ;

  {
  tmp = bfa_flash_fifo_flush(pci_bar);
  status = (int )tmp;
  if (status < 0) {
    return ((u32 )status);
  } else {

  }
  bfa_flash_set_cmd(pci_bar, 0, 4, 0, 5);
  i = 0;
  goto ldv_50397;
  ldv_50396: 
  status = bfa_flash_cmd_act_check(pci_bar);
  if (status == 0) {
    goto ldv_50395;
  } else {

  }
  i = i + 1;
  ldv_50397: ;
  if (i <= 9999) {
    goto ldv_50396;
  } else {

  }
  ldv_50395: ;
  if (status != 0) {
    return ((u32 )status);
  } else {

  }
  dev_status.i = readl((void const volatile   *)pci_bar + 118804U);
  if ((unsigned int )*((unsigned short *)(& dev_status) + 0UL) == 0U) {
    return (4294967292U);
  } else {

  }
  ret_status = readl((void const volatile   *)pci_bar + 118800U);
  ret_status = ret_status >> 24;
  tmp___0 = bfa_flash_fifo_flush(pci_bar);
  status = (int )tmp___0;
  if (status < 0) {
    return ((u32 )status);
  } else {

  }
  return (ret_status);
}
}
static u32 bfa_flash_read_start(void *pci_bar , u32 offset , u32 len , char *buf ) 
{ 
  int status ;
  u32 tmp ;
  u32 tmp___0 ;

  {
  if ((len == 0U || len > 128U) || (len & 3U) != 0U) {
    return (4294967287U);
  } else {

  }
  tmp = bfa_flash_status_read(pci_bar);
  status = (int )tmp;
  if (status == -4) {
    tmp___0 = bfa_flash_status_read(pci_bar);
    status = (int )tmp___0;
  } else {

  }
  if (status < 0) {
    return ((u32 )status);
  } else {

  }
  if (status & 1) {
    return (4294967289U);
  } else {

  }
  bfa_flash_set_addr(pci_bar, offset);
  bfa_flash_set_cmd(pci_bar, 0, (int )((unsigned char )len), 4, 11);
  return (0U);
}
}
static u32 bfa_flash_read_check(void *pci_bar ) 
{ 
  int tmp ;

  {
  tmp = bfa_flash_cmd_act_check(pci_bar);
  if (tmp != 0) {
    return (1U);
  } else {

  }
  return (0U);
}
}
static void bfa_flash_read_end(void *pci_bar , u32 len , char *buf ) 
{ 
  u32 i ;
  u32 w ;
  unsigned int tmp ;
  __u32 tmp___0 ;

  {
  i = 0U;
  goto ldv_50416;
  ldv_50415: 
  tmp = readl((void const volatile   *)pci_bar + 118800U);
  w = tmp;
  tmp___0 = __fswab32(w);
  *((u32 *)buf + (unsigned long )i) = tmp___0;
  i = i + 4U;
  ldv_50416: ;
  if (i < len) {
    goto ldv_50415;
  } else {

  }
  bfa_flash_fifo_flush(pci_bar);
  return;
}
}
static int bfa_raw_sem_get(void *bar ) 
{ 
  int locked ;
    klee_make_symbolic(&locked, sizeof(int), "locked");
  unsigned int tmp ;

  {
  tmp = readl((void const volatile   *)bar + 100384U);
  locked = (int )tmp;
  return (locked == 0);
}
}
enum bfa_status bfa_flash_sem_get(void *bar ) 
{ 
  u32 n ;
  unsigned long __ms ;
    klee_make_symbolic(&__ms, sizeof(long), "__ms");
  unsigned long tmp ;
  int tmp___0 ;

  {
  n = 500U;
  goto ldv_50431;
  ldv_50430: 
  n = n - 1U;
  if (n == 0U) {
    return (9);
  } else {

  }
  __ms = 10UL;
  goto ldv_50428;
  ldv_50427: 
  __const_udelay(4295000UL);
  ldv_50428: 
  tmp = __ms;
  __ms = __ms - 1UL;
  if (tmp != 0UL) {
    goto ldv_50427;
  } else {

  }

  ldv_50431: 
  tmp___0 = bfa_raw_sem_get(bar);
  if (tmp___0 == 0) {
    goto ldv_50430;
  } else {

  }

  return (0);
}
}
void bfa_flash_sem_put(void *bar ) 
{ 


  {
  writel(0U, (void volatile   *)bar + 100384U);
  return;
}
}
enum bfa_status bfa_flash_raw_read(void *pci_bar , u32 offset , char *buf , u32 len ) 
{ 
  u32 n ;
  int status ;
  u32 off ;
  u32 l ;
  u32 s ;
  u32 residue ;
  u32 fifo_sz ;
  enum bfa_status tmp ;
  u32 tmp___0 ;
  u32 tmp___1 ;

  {
  residue = len;
  off = 0U;
  fifo_sz = 128U;
  tmp = bfa_flash_sem_get(pci_bar);
  status = (int )tmp;
  if (status != 0) {
    return ((enum bfa_status )status);
  } else {

  }
  goto ldv_50453;
  ldv_50452: 
  s = offset + off;
  n = s / fifo_sz;
  l = (n + 1U) * fifo_sz - s;
  if (l > residue) {
    l = residue;
  } else {

  }
  tmp___0 = bfa_flash_read_start(pci_bar, offset + off, l, buf + (unsigned long )off);
  status = (int )tmp___0;
  if (status < 0) {
    bfa_flash_sem_put(pci_bar);
    return (1);
  } else {

  }
  n = 1000000U;
  goto ldv_50450;
  ldv_50449: 
  n = n - 1U;
  if (n == 0U) {
    bfa_flash_sem_put(pci_bar);
    return (1);
  } else {

  }
  ldv_50450: 
  tmp___1 = bfa_flash_read_check(pci_bar);
  if (tmp___1 != 0U) {
    goto ldv_50449;
  } else {

  }
  bfa_flash_read_end(pci_bar, l, buf + (unsigned long )off);
  residue = residue - l;
  off = off + l;
  ldv_50453: ;
  if (residue != 0U) {
    goto ldv_50452;
  } else {

  }
  bfa_flash_sem_put(pci_bar);
  return (0);
}
}
void ldv_initialize_bfa_module_s_15(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
  tmp = ldv_init_zalloc(56UL);
  hal_mod_dconf_group0 = (struct bfa_iocfc_cfg_s *)tmp;
  tmp___0 = ldv_init_zalloc(9688UL);
  hal_mod_dconf_group1 = (struct bfa_s *)tmp___0;
  return;
}
}
void ldv_main_exported_15(void) 
{ 
  void *ldvarg83 ;
  void *tmp ;
  struct bfa_pcidev_s *ldvarg82 ;
  void *tmp___0 ;
  struct bfa_meminfo_s *ldvarg84 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
  tmp = ldv_init_zalloc(1UL);
  ldvarg83 = tmp;
  tmp___0 = ldv_init_zalloc(24UL);
  ldvarg82 = (struct bfa_pcidev_s *)tmp___0;
  tmp___1 = ldv_init_zalloc(96UL);
  ldvarg84 = (struct bfa_meminfo_s *)tmp___1;
  tmp___2 = __VERIFIER_nondet_int();
  switch (tmp___2) {
  case 0: ;
  if (ldv_state_variable_15 == 1) {
    bfa_dconf_start(hal_mod_dconf_group1);
    ldv_state_variable_15 = 1;
  } else {

  }
  goto ldv_50465;
  case 1: ;
  if (ldv_state_variable_15 == 1) {
    bfa_dconf_iocdisable(hal_mod_dconf_group1);
    ldv_state_variable_15 = 1;
  } else {

  }
  goto ldv_50465;
  case 2: ;
  if (ldv_state_variable_15 == 1) {
    bfa_dconf_meminfo(hal_mod_dconf_group0, ldvarg84, hal_mod_dconf_group1);
    ldv_state_variable_15 = 1;
  } else {

  }
  goto ldv_50465;
  case 3: ;
  if (ldv_state_variable_15 == 1) {
    bfa_dconf_stop(hal_mod_dconf_group1);
    ldv_state_variable_15 = 1;
  } else {

  }
  goto ldv_50465;
  case 4: ;
  if (ldv_state_variable_15 == 1) {
    bfa_dconf_attach(hal_mod_dconf_group1, ldvarg83, hal_mod_dconf_group0, ldvarg82);
    ldv_state_variable_15 = 1;
  } else {

  }
  goto ldv_50465;
  case 5: ;
  if (ldv_state_variable_15 == 1) {
    bfa_dconf_detach(hal_mod_dconf_group1);
    ldv_state_variable_15 = 1;
  } else {

  }
  goto ldv_50465;
  default: 
  ldv_stop();
  }
  ldv_50465: ;
  return;
}
}
bool ldv_queue_work_on_237(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_3(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_delayed_work_on_238(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_3(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_work_on_239(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_3(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
void ldv_flush_workqueue_240(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
  flush_workqueue(ldv_func_arg1);
  call_and_disable_all_3(2);
  return;
}
}
bool ldv_queue_delayed_work_on_241(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_3(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
void ldv_mutex_lock_242(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_lock_lock(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_243(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_unlock_lock(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_244(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
int ldv_mutex_trylock_245(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
  tmp = mutex_trylock(ldv_func_arg1);
  ldv_func_res = tmp;
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
  return (tmp___0);
  return (ldv_func_res);
}
}
void ldv_mutex_unlock_246(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_247(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_unlock_i_mutex_of_inode(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_248(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_lock_i_mutex_of_inode(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
int ldv_scsi_add_host_with_dma_249(struct Scsi_Host *shost , struct device *dev ,
                                   struct device *dma_dev ) 
{ 
  ldv_func_ret_type___4 ldv_func_res ;
  int tmp ;

  {
  tmp = scsi_add_host_with_dma(shost, dev, dma_dev);
  ldv_func_res = tmp;
  if (ldv_func_res == 0) {
    ldv_state_variable_35 = 1;
    ldv_initialize_scsi_host_template_35();
  } else {

  }
  return (ldv_func_res);
}
}
int ldv_mutex_trylock_275(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_273(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_276(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_277(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_272(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_274(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_278(struct mutex *ldv_func_arg1 ) ;
bool ldv_queue_work_on_267(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_work_on_269(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_delayed_work_on_268(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
bool ldv_queue_delayed_work_on_271(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
void ldv_flush_workqueue_270(struct workqueue_struct *ldv_func_arg1 ) ;
int ldv_scsi_add_host_with_dma_279(struct Scsi_Host *shost , struct device *dev ,
                                   struct device *dma_dev ) ;
enum bfa_status bfa_ioc_cb_pll_init(void *rb , enum bfi_asic_mode fcmode ) ;
static int __trc_fileno___3  =    4099;
static enum bfa_boolean bfa_ioc_cb_firmware_lock(struct bfa_ioc_s *ioc ) ;
static void bfa_ioc_cb_firmware_unlock(struct bfa_ioc_s *ioc ) ;
static void bfa_ioc_cb_reg_init(struct bfa_ioc_s *ioc ) ;
static void bfa_ioc_cb_map_port(struct bfa_ioc_s *ioc ) ;
static void bfa_ioc_cb_isr_mode_set(struct bfa_ioc_s *ioc , enum bfa_boolean msix ) ;
static void bfa_ioc_cb_notify_fail(struct bfa_ioc_s *ioc ) ;
static void bfa_ioc_cb_ownership_reset(struct bfa_ioc_s *ioc ) ;
static enum bfa_boolean bfa_ioc_cb_sync_start(struct bfa_ioc_s *ioc ) ;
static void bfa_ioc_cb_sync_join(struct bfa_ioc_s *ioc ) ;
static void bfa_ioc_cb_sync_leave(struct bfa_ioc_s *ioc ) ;
static void bfa_ioc_cb_sync_ack(struct bfa_ioc_s *ioc ) ;
static enum bfa_boolean bfa_ioc_cb_sync_complete(struct bfa_ioc_s *ioc ) ;
static void bfa_ioc_cb_set_cur_ioc_fwstate(struct bfa_ioc_s *ioc , enum bfi_ioc_state fwstate ) ;
static enum bfi_ioc_state bfa_ioc_cb_get_cur_ioc_fwstate(struct bfa_ioc_s *ioc ) ;
static void bfa_ioc_cb_set_alt_ioc_fwstate(struct bfa_ioc_s *ioc , enum bfi_ioc_state fwstate ) ;
static enum bfi_ioc_state bfa_ioc_cb_get_alt_ioc_fwstate(struct bfa_ioc_s *ioc ) ;
static struct bfa_ioc_hwif_s hwif_cb  ;
void bfa_ioc_set_cb_hwif(struct bfa_ioc_s *ioc ) 
{ 


  {
  hwif_cb.ioc_pll_init = & bfa_ioc_cb_pll_init;
  hwif_cb.ioc_firmware_lock = & bfa_ioc_cb_firmware_lock;
  hwif_cb.ioc_firmware_unlock = & bfa_ioc_cb_firmware_unlock;
  hwif_cb.ioc_reg_init = & bfa_ioc_cb_reg_init;
  hwif_cb.ioc_map_port = & bfa_ioc_cb_map_port;
  hwif_cb.ioc_isr_mode_set = & bfa_ioc_cb_isr_mode_set;
  hwif_cb.ioc_notify_fail = & bfa_ioc_cb_notify_fail;
  hwif_cb.ioc_ownership_reset = & bfa_ioc_cb_ownership_reset;
  hwif_cb.ioc_sync_start = & bfa_ioc_cb_sync_start;
  hwif_cb.ioc_sync_join = & bfa_ioc_cb_sync_join;
  hwif_cb.ioc_sync_leave = & bfa_ioc_cb_sync_leave;
  hwif_cb.ioc_sync_ack = & bfa_ioc_cb_sync_ack;
  hwif_cb.ioc_sync_complete = & bfa_ioc_cb_sync_complete;
  hwif_cb.ioc_set_fwstate = & bfa_ioc_cb_set_cur_ioc_fwstate;
  hwif_cb.ioc_get_fwstate = & bfa_ioc_cb_get_cur_ioc_fwstate;
  hwif_cb.ioc_set_alt_fwstate = & bfa_ioc_cb_set_alt_ioc_fwstate;
  hwif_cb.ioc_get_alt_fwstate = & bfa_ioc_cb_get_alt_ioc_fwstate;
  ioc->ioc_hwif = & hwif_cb;
  return;
}
}
static enum bfa_boolean bfa_ioc_cb_firmware_lock(struct bfa_ioc_s *ioc ) 
{ 
  enum bfi_ioc_state alt_fwstate ;
  enum bfi_ioc_state cur_fwstate ;
  struct bfi_ioc_image_hdr_s fwhdr ;
  enum bfa_boolean tmp ;

  {
  cur_fwstate = bfa_ioc_cb_get_cur_ioc_fwstate(ioc);
  __bfa_trc(ioc->trcmod, __trc_fileno___3, 88, (unsigned long long )cur_fwstate);
  alt_fwstate = bfa_ioc_cb_get_alt_ioc_fwstate(ioc);
  __bfa_trc(ioc->trcmod, __trc_fileno___3, 90, (unsigned long long )alt_fwstate);
  if ((unsigned int )cur_fwstate == 0U) {
    return (1);
  } else {

  }
  bfa_ioc_fwver_get(ioc, & fwhdr);
  tmp = bfa_ioc_fwver_cmp(ioc, & fwhdr);
  if ((unsigned int )tmp == 0U && (unsigned int )alt_fwstate != 6U) {
    __bfa_trc(ioc->trcmod, __trc_fileno___3, 103, (unsigned long long )alt_fwstate);
    return (0);
  } else {

  }
  return (1);
}
}
static void bfa_ioc_cb_firmware_unlock(struct bfa_ioc_s *ioc ) 
{ 


  {
  return;
}
}
static void bfa_ioc_cb_notify_fail(struct bfa_ioc_s *ioc ) 
{ 


  {
  writel(4294967295U, (void volatile   *)ioc->ioc_regs.err_set);
  readl((void const volatile   *)ioc->ioc_regs.err_set);
  return;
}
}
static struct __anonstruct_iocreg_fnreg_303 iocreg_fnreg[2U]  = {      {102912U, 103040U, 81928U}, 
        {103008U, 103136U, 82184U}};
static struct __anonstruct_iocreg_mbcmd_304 iocreg_mbcmd[2U]  = {      {102400U, 102408U}, 
        {102420U, 102428U}};
static void bfa_ioc_cb_reg_init(struct bfa_ioc_s *ioc ) 
{ 
  void *rb ;
  int pcifn ;
    klee_make_symbolic(&pcifn, sizeof(int), "pcifn");

  {
  pcifn = (int )ioc->pcidev.pci_func;
  rb = ioc->pcidev.pci_bar_kva;
  ioc->ioc_regs.hfn_mbox = rb + (unsigned long )iocreg_fnreg[pcifn].hfn_mbox;
  ioc->ioc_regs.lpu_mbox = rb + (unsigned long )iocreg_fnreg[pcifn].lpu_mbox;
  ioc->ioc_regs.host_page_num_fn = rb + (unsigned long )iocreg_fnreg[pcifn].hfn_pgn;
  if ((unsigned int )ioc->port_id == 0U) {
    ioc->ioc_regs.heartbeat = rb + 82496UL;
    ioc->ioc_regs.ioc_fwstate = rb + 82500UL;
    ioc->ioc_regs.alt_ioc_fwstate = rb + 82508UL;
  } else {
    ioc->ioc_regs.heartbeat = rb + 82504UL;
    ioc->ioc_regs.ioc_fwstate = rb + 82508UL;
    ioc->ioc_regs.alt_ioc_fwstate = rb + 82500UL;
  }
  ioc->ioc_regs.hfn_mbox_cmd = rb + (unsigned long )iocreg_mbcmd[pcifn].hfn;
  ioc->ioc_regs.lpu_mbox_cmd = rb + (unsigned long )iocreg_mbcmd[pcifn].lpu;
  ioc->ioc_regs.pss_ctl_reg = rb + 100352UL;
  ioc->ioc_regs.pss_err_status_reg = rb + 100368UL;
  ioc->ioc_regs.app_pll_fast_ctl_reg = rb + 82436UL;
  ioc->ioc_regs.app_pll_slow_ctl_reg = rb + 82440UL;
  ioc->ioc_regs.ioc_sem_reg = rb + 82480UL;
  ioc->ioc_regs.ioc_init_sem_reg = rb + 82488UL;
  ioc->ioc_regs.smem_page_start = rb + 32768UL;
  ioc->ioc_regs.smem_pg0 = 64U;
  ioc->ioc_regs.err_set = rb + 100376UL;
  return;
}
}
static void bfa_ioc_cb_map_port(struct bfa_ioc_s *ioc ) 
{ 


  {
  ioc->port_id = ioc->pcidev.pci_func;
  __bfa_trc(ioc->trcmod, __trc_fileno___3, 208, (unsigned long long )ioc->port_id);
  return;
}
}
static void bfa_ioc_cb_isr_mode_set(struct bfa_ioc_s *ioc , enum bfa_boolean msix ) 
{ 


  {
  return;
}
}
static enum bfa_boolean bfa_ioc_cb_sync_start(struct bfa_ioc_s *ioc ) 
{ 
  u32 ioc_fwstate ;
  unsigned int tmp ;
  enum bfa_boolean tmp___0 ;

  {
  tmp = readl((void const volatile   *)ioc->ioc_regs.ioc_fwstate);
  ioc_fwstate = tmp;
  if ((ioc_fwstate & 4294901760U) != 0U) {
    writel(0U, (void volatile   *)ioc->ioc_regs.ioc_fwstate);
    writel(0U, (void volatile   *)ioc->ioc_regs.alt_ioc_fwstate);
    return (1);
  } else {

  }
  tmp___0 = bfa_ioc_cb_sync_complete(ioc);
  return (tmp___0);
}
}
static void bfa_ioc_cb_ownership_reset(struct bfa_ioc_s *ioc ) 
{ 


  {
  readl((void const volatile   *)ioc->ioc_regs.ioc_sem_reg);
  writel(1U, (void volatile   *)ioc->ioc_regs.ioc_sem_reg);
  return;
}
}
static void bfa_ioc_cb_sync_join(struct bfa_ioc_s *ioc ) 
{ 
  u32 r32 ;
  unsigned int tmp ;
  u32 join_pos ;

  {
  tmp = readl((void const volatile   *)ioc->ioc_regs.ioc_fwstate);
  r32 = tmp;
  join_pos = 65536U;
  writel(r32 | join_pos, (void volatile   *)ioc->ioc_regs.ioc_fwstate);
  return;
}
}
static void bfa_ioc_cb_sync_leave(struct bfa_ioc_s *ioc ) 
{ 
  u32 r32 ;
  unsigned int tmp ;
  u32 join_pos ;

  {
  tmp = readl((void const volatile   *)ioc->ioc_regs.ioc_fwstate);
  r32 = tmp;
  join_pos = 65536U;
  writel(~ join_pos & r32, (void volatile   *)ioc->ioc_regs.ioc_fwstate);
  return;
}
}
static void bfa_ioc_cb_set_cur_ioc_fwstate(struct bfa_ioc_s *ioc , enum bfi_ioc_state fwstate ) 
{ 
  u32 r32 ;
  unsigned int tmp ;

  {
  tmp = readl((void const volatile   *)ioc->ioc_regs.ioc_fwstate);
  r32 = tmp;
  writel((r32 & 4294901760U) | (unsigned int )fwstate, (void volatile   *)ioc->ioc_regs.ioc_fwstate);
  return;
}
}
static enum bfi_ioc_state bfa_ioc_cb_get_cur_ioc_fwstate(struct bfa_ioc_s *ioc ) 
{ 
  unsigned int tmp ;

  {
  tmp = readl((void const volatile   *)ioc->ioc_regs.ioc_fwstate);
  return ((enum bfi_ioc_state )(tmp & 65535U));
}
}
static void bfa_ioc_cb_set_alt_ioc_fwstate(struct bfa_ioc_s *ioc , enum bfi_ioc_state fwstate ) 
{ 
  u32 r32 ;
  unsigned int tmp ;

  {
  tmp = readl((void const volatile   *)ioc->ioc_regs.alt_ioc_fwstate);
  r32 = tmp;
  writel((r32 & 4294901760U) | (unsigned int )fwstate, (void volatile   *)ioc->ioc_regs.alt_ioc_fwstate);
  return;
}
}
static enum bfi_ioc_state bfa_ioc_cb_get_alt_ioc_fwstate(struct bfa_ioc_s *ioc ) 
{ 
  unsigned int tmp ;

  {
  tmp = readl((void const volatile   *)ioc->ioc_regs.alt_ioc_fwstate);
  return ((enum bfi_ioc_state )(tmp & 65535U));
}
}
static void bfa_ioc_cb_sync_ack(struct bfa_ioc_s *ioc ) 
{ 


  {
  bfa_ioc_cb_set_cur_ioc_fwstate(ioc, 8);
  return;
}
}
static enum bfa_boolean bfa_ioc_cb_sync_complete(struct bfa_ioc_s *ioc ) 
{ 
  u32 fwstate ;
  u32 alt_fwstate ;
  enum bfi_ioc_state tmp ;
  enum bfi_ioc_state tmp___0 ;

  {
  tmp = bfa_ioc_cb_get_cur_ioc_fwstate(ioc);
  fwstate = (u32 )tmp;
  if ((((fwstate == 0U || fwstate == 1U) || fwstate == 6U) || fwstate == 9U) || fwstate == 4U) {
    return (1);
  } else {
    tmp___0 = bfa_ioc_cb_get_alt_ioc_fwstate(ioc);
    alt_fwstate = (u32 )tmp___0;
    if ((((alt_fwstate == 8U || alt_fwstate == 6U) || alt_fwstate == 0U) || alt_fwstate == 1U) || alt_fwstate == 9U) {
      return (1);
    } else {
      return (0);
    }
  }
}
}
enum bfa_status bfa_ioc_cb_pll_init(void *rb , enum bfi_asic_mode fcmode ) 
{ 
  u32 pll_sclk ;
  u32 pll_fclk ;
  u32 join_bits ;
  unsigned int tmp ;
  unsigned int tmp___0 ;

  {
  pll_sclk = 62211U;
  pll_fclk = 62227U;
  tmp = readl((void const volatile   *)rb + 82500U);
  join_bits = tmp & 4294901760U;
  writel(join_bits, (void volatile   *)rb + 82500U);
  tmp___0 = readl((void const volatile   *)rb + 82508U);
  join_bits = tmp___0 & 4294901760U;
  writel(join_bits, (void volatile   *)rb + 82508U);
  writel(4294967295U, (void volatile   *)rb + 81924U);
  writel(4294967295U, (void volatile   *)rb + 82180U);
  writel(4294967295U, (void volatile   *)rb + 81920U);
  writel(4294967295U, (void volatile   *)rb + 82176U);
  writel(4294967295U, (void volatile   *)rb + 81924U);
  writel(4294967295U, (void volatile   *)rb + 82180U);
  writel(65536U, (void volatile   *)rb + 82440U);
  writel(65540U, (void volatile   *)rb + 82440U);
  writel(65536U, (void volatile   *)rb + 82436U);
  writel(65540U, (void volatile   *)rb + 82436U);
  __const_udelay(8590UL);
  writel(65536U, (void volatile   *)rb + 82440U);
  writel(65536U, (void volatile   *)rb + 82436U);
  writel(pll_sclk | 65536U, (void volatile   *)rb + 82440U);
  writel(pll_fclk | 65536U, (void volatile   *)rb + 82436U);
  __const_udelay(8590000UL);
  writel(4294967295U, (void volatile   *)rb + 81920U);
  writel(4294967295U, (void volatile   *)rb + 82176U);
  writel(pll_sclk, (void volatile   *)rb + 82440U);
  writel(pll_fclk, (void volatile   *)rb + 82436U);
  return (0);
}
}
bool ldv_queue_work_on_267(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_3(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_delayed_work_on_268(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_3(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_work_on_269(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_3(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
void ldv_flush_workqueue_270(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
  flush_workqueue(ldv_func_arg1);
  call_and_disable_all_3(2);
  return;
}
}
bool ldv_queue_delayed_work_on_271(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_3(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
void ldv_mutex_lock_272(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_lock_lock(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_273(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_unlock_lock(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_274(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
int ldv_mutex_trylock_275(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
  tmp = mutex_trylock(ldv_func_arg1);
  ldv_func_res = tmp;
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
  return (tmp___0);
  return (ldv_func_res);
}
}
void ldv_mutex_unlock_276(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_277(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_unlock_i_mutex_of_inode(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_278(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_lock_i_mutex_of_inode(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
int ldv_scsi_add_host_with_dma_279(struct Scsi_Host *shost , struct device *dev ,
                                   struct device *dma_dev ) 
{ 
  ldv_func_ret_type___4 ldv_func_res ;
  int tmp ;

  {
  tmp = scsi_add_host_with_dma(shost, dev, dma_dev);
  ldv_func_res = tmp;
  if (ldv_func_res == 0) {
    ldv_state_variable_35 = 1;
    ldv_initialize_scsi_host_template_35();
  } else {

  }
  return (ldv_func_res);
}
}
__inline static long ldv__builtin_expect(long exp , long c ) ;
int ldv_mutex_trylock_305(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_303(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_306(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_307(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_302(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_304(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_308(struct mutex *ldv_func_arg1 ) ;
bool ldv_queue_work_on_297(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_work_on_299(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_delayed_work_on_298(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
bool ldv_queue_delayed_work_on_301(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
void ldv_flush_workqueue_300(struct workqueue_struct *ldv_func_arg1 ) ;
int ldv_scsi_add_host_with_dma_309(struct Scsi_Host *shost , struct device *dev ,
                                   struct device *dma_dev ) ;
enum bfa_status bfa_ioc_ct_pll_init(void *rb , enum bfi_asic_mode mode ) ;
enum bfa_status bfa_ioc_ct2_pll_init(void *rb , enum bfi_asic_mode mode ) ;
static int __trc_fileno___4  =    4100;
static enum bfa_boolean bfa_ioc_ct_firmware_lock(struct bfa_ioc_s *ioc ) ;
static void bfa_ioc_ct_firmware_unlock(struct bfa_ioc_s *ioc ) ;
static void bfa_ioc_ct_notify_fail(struct bfa_ioc_s *ioc ) ;
static void bfa_ioc_ct_ownership_reset(struct bfa_ioc_s *ioc ) ;
static enum bfa_boolean bfa_ioc_ct_sync_start(struct bfa_ioc_s *ioc ) ;
static void bfa_ioc_ct_sync_join(struct bfa_ioc_s *ioc ) ;
static void bfa_ioc_ct_sync_leave(struct bfa_ioc_s *ioc ) ;
static void bfa_ioc_ct_sync_ack(struct bfa_ioc_s *ioc ) ;
static enum bfa_boolean bfa_ioc_ct_sync_complete(struct bfa_ioc_s *ioc ) ;
static void bfa_ioc_ct_set_cur_ioc_fwstate(struct bfa_ioc_s *ioc , enum bfi_ioc_state fwstate ) ;
static enum bfi_ioc_state bfa_ioc_ct_get_cur_ioc_fwstate(struct bfa_ioc_s *ioc ) ;
static void bfa_ioc_ct_set_alt_ioc_fwstate(struct bfa_ioc_s *ioc , enum bfi_ioc_state fwstate ) ;
static enum bfi_ioc_state bfa_ioc_ct_get_alt_ioc_fwstate(struct bfa_ioc_s *ioc ) ;
static struct bfa_ioc_hwif_s hwif_ct  ;
static struct bfa_ioc_hwif_s hwif_ct2  ;
static enum bfa_boolean bfa_ioc_ct_firmware_lock(struct bfa_ioc_s *ioc ) 
{ 
  enum bfi_ioc_state ioc_fwstate ;
  u32 usecnt ;
  struct bfi_ioc_image_hdr_s fwhdr ;
  unsigned int tmp ;
  int __ret_warn_on ;
  long tmp___0 ;
  enum bfa_boolean tmp___1 ;

  {
  bfa_ioc_sem_get(ioc->ioc_regs.ioc_usage_sem_reg);
  usecnt = readl((void const volatile   *)ioc->ioc_regs.ioc_usage_reg);
  if (usecnt == 0U) {
    writel(1U, (void volatile   *)ioc->ioc_regs.ioc_usage_reg);
    readl((void const volatile   *)ioc->ioc_regs.ioc_usage_sem_reg);
    writel(1U, (void volatile   *)ioc->ioc_regs.ioc_usage_sem_reg);
    writel(0U, (void volatile   *)ioc->ioc_regs.ioc_fail_sync);
    __bfa_trc(ioc->trcmod, __trc_fileno___4, 77, (unsigned long long )usecnt);
    return (1);
  } else {

  }
  tmp = readl((void const volatile   *)ioc->ioc_regs.ioc_fwstate);
  ioc_fwstate = (enum bfi_ioc_state )tmp;
  __bfa_trc(ioc->trcmod, __trc_fileno___4, 82, (unsigned long long )ioc_fwstate);
  __ret_warn_on = (unsigned int )ioc_fwstate == 0U;
  tmp___0 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp___0 != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_ioc_ct.c",
                       87);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  bfa_ioc_fwver_get(ioc, & fwhdr);
  tmp___1 = bfa_ioc_fwver_cmp(ioc, & fwhdr);
  if ((unsigned int )tmp___1 == 0U) {
    readl((void const volatile   *)ioc->ioc_regs.ioc_usage_sem_reg);
    writel(1U, (void volatile   *)ioc->ioc_regs.ioc_usage_sem_reg);
    __bfa_trc(ioc->trcmod, __trc_fileno___4, 96, (unsigned long long )usecnt);
    return (0);
  } else {

  }
  usecnt = usecnt + 1U;
  writel(usecnt, (void volatile   *)ioc->ioc_regs.ioc_usage_reg);
  readl((void const volatile   *)ioc->ioc_regs.ioc_usage_sem_reg);
  writel(1U, (void volatile   *)ioc->ioc_regs.ioc_usage_sem_reg);
  __bfa_trc(ioc->trcmod, __trc_fileno___4, 107, (unsigned long long )usecnt);
  return (1);
}
}
static void bfa_ioc_ct_firmware_unlock(struct bfa_ioc_s *ioc ) 
{ 
  u32 usecnt ;
  int __ret_warn_on ;
  long tmp ;

  {
  bfa_ioc_sem_get(ioc->ioc_regs.ioc_usage_sem_reg);
  usecnt = readl((void const volatile   *)ioc->ioc_regs.ioc_usage_reg);
  __ret_warn_on = usecnt == 0U;
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_ioc_ct.c",
                       121);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  usecnt = usecnt - 1U;
  writel(usecnt, (void volatile   *)ioc->ioc_regs.ioc_usage_reg);
  __bfa_trc(ioc->trcmod, __trc_fileno___4, 125, (unsigned long long )usecnt);
  readl((void const volatile   *)ioc->ioc_regs.ioc_usage_sem_reg);
  writel(1U, (void volatile   *)ioc->ioc_regs.ioc_usage_sem_reg);
  return;
}
}
static void bfa_ioc_ct_notify_fail(struct bfa_ioc_s *ioc ) 
{ 
  enum bfa_ioc_type_e tmp ;
  enum bfa_ioc_type_e tmp___0 ;

  {
  tmp = bfa_ioc_get_type(ioc);
  if ((unsigned int )tmp == 2U) {
    writel(1U, (void volatile   *)ioc->ioc_regs.ll_halt);
    writel(1U, (void volatile   *)ioc->ioc_regs.alt_ll_halt);
    readl((void const volatile   *)ioc->ioc_regs.ll_halt);
    readl((void const volatile   *)ioc->ioc_regs.alt_ll_halt);
  } else {
    tmp___0 = bfa_ioc_get_type(ioc);
    if ((unsigned int )tmp___0 == 3U) {
      writel(1U, (void volatile   *)ioc->ioc_regs.ll_halt);
      writel(1U, (void volatile   *)ioc->ioc_regs.alt_ll_halt);
      readl((void const volatile   *)ioc->ioc_regs.ll_halt);
      readl((void const volatile   *)ioc->ioc_regs.alt_ll_halt);
    } else {
      writel(4294967295U, (void volatile   *)ioc->ioc_regs.err_set);
      readl((void const volatile   *)ioc->ioc_regs.err_set);
    }
  }
  return;
}
}
static struct __anonstruct_ct_fnreg_303 ct_fnreg[4U]  = {      {102912U, 103040U, 81928U}, 
        {103008U, 103136U, 82184U}, 
        {103424U, 103552U, 82696U}, 
        {103520U, 103648U, 82952U}};
static struct __anonstruct_ct_p0reg_304 ct_p0reg[4U]  = {      {102400U, 102408U}, 
        {102416U, 102424U}, 
        {102736U, 102744U}, 
        {102752U, 102760U}};
static struct __anonstruct_ct_p1reg_305 ct_p1reg[4U]  = {      {102404U, 102412U}, 
        {102420U, 102428U}, 
        {102740U, 102748U}, 
        {102756U, 102764U}};
static struct __anonstruct_ct2_reg_306 ct2_reg[2U]  = {      {196608U, 196672U, 196888U, 196736U, 196744U, 196752U}, 
        {196640U, 196704U, 196888U, 196740U, 196748U, 196756U}};
static void bfa_ioc_ct_reg_init(struct bfa_ioc_s *ioc ) 
{ 
  void *rb ;
  int pcifn ;

  {
  pcifn = (int )ioc->pcidev.pci_func;
  rb = ioc->pcidev.pci_bar_kva;
  ioc->ioc_regs.hfn_mbox = rb + (unsigned long )ct_fnreg[pcifn].hfn_mbox;
  ioc->ioc_regs.lpu_mbox = rb + (unsigned long )ct_fnreg[pcifn].lpu_mbox;
  ioc->ioc_regs.host_page_num_fn = rb + (unsigned long )ct_fnreg[pcifn].hfn_pgn;
  if ((unsigned int )ioc->port_id == 0U) {
    ioc->ioc_regs.heartbeat = rb + 82496UL;
    ioc->ioc_regs.ioc_fwstate = rb + 82500UL;
    ioc->ioc_regs.alt_ioc_fwstate = rb + 82508UL;
    ioc->ioc_regs.hfn_mbox_cmd = rb + (unsigned long )ct_p0reg[pcifn].hfn;
    ioc->ioc_regs.lpu_mbox_cmd = rb + (unsigned long )ct_p0reg[pcifn].lpu;
    ioc->ioc_regs.ll_halt = rb + 102828UL;
    ioc->ioc_regs.alt_ll_halt = rb + 102844UL;
  } else {
    ioc->ioc_regs.heartbeat = rb + 82504UL;
    ioc->ioc_regs.ioc_fwstate = rb + 82508UL;
    ioc->ioc_regs.alt_ioc_fwstate = rb + 82500UL;
    ioc->ioc_regs.hfn_mbox_cmd = rb + (unsigned long )ct_p1reg[pcifn].hfn;
    ioc->ioc_regs.lpu_mbox_cmd = rb + (unsigned long )ct_p1reg[pcifn].lpu;
    ioc->ioc_regs.ll_halt = rb + 102844UL;
    ioc->ioc_regs.alt_ll_halt = rb + 102828UL;
  }
  ioc->ioc_regs.pss_ctl_reg = rb + 100352UL;
  ioc->ioc_regs.pss_err_status_reg = rb + 100368UL;
  ioc->ioc_regs.app_pll_fast_ctl_reg = rb + 82436UL;
  ioc->ioc_regs.app_pll_slow_ctl_reg = rb + 82440UL;
  ioc->ioc_regs.ioc_sem_reg = rb + 82480UL;
  ioc->ioc_regs.ioc_usage_sem_reg = rb + 82484UL;
  ioc->ioc_regs.ioc_init_sem_reg = rb + 82488UL;
  ioc->ioc_regs.ioc_usage_reg = rb + 83488UL;
  ioc->ioc_regs.ioc_fail_sync = rb + 83492UL;
  ioc->ioc_regs.smem_page_start = rb + 32768UL;
  ioc->ioc_regs.smem_pg0 = 384U;
  ioc->ioc_regs.err_set = rb + 100376UL;
  return;
}
}
static void bfa_ioc_ct2_reg_init(struct bfa_ioc_s *ioc ) 
{ 
  void *rb ;
  int port ;
    klee_make_symbolic(&port, sizeof(int), "port");

  {
  port = (int )ioc->port_id;
  rb = ioc->pcidev.pci_bar_kva;
  ioc->ioc_regs.hfn_mbox = rb + (unsigned long )ct2_reg[port].hfn_mbox;
  ioc->ioc_regs.lpu_mbox = rb + (unsigned long )ct2_reg[port].lpu_mbox;
  ioc->ioc_regs.host_page_num_fn = rb + (unsigned long )ct2_reg[port].hfn_pgn;
  ioc->ioc_regs.hfn_mbox_cmd = rb + (unsigned long )ct2_reg[port].hfn;
  ioc->ioc_regs.lpu_mbox_cmd = rb + (unsigned long )ct2_reg[port].lpu;
  ioc->ioc_regs.lpu_read_stat = rb + (unsigned long )ct2_reg[port].lpu_read;
  if (port == 0) {
    ioc->ioc_regs.heartbeat = rb + 84144UL;
    ioc->ioc_regs.ioc_fwstate = rb + 84148UL;
    ioc->ioc_regs.alt_ioc_fwstate = rb + 84156UL;
    ioc->ioc_regs.ll_halt = rb + 102828UL;
    ioc->ioc_regs.alt_ll_halt = rb + 102844UL;
  } else {
    ioc->ioc_regs.heartbeat = rb + 84152UL;
    ioc->ioc_regs.ioc_fwstate = rb + 84156UL;
    ioc->ioc_regs.alt_ioc_fwstate = rb + 84148UL;
    ioc->ioc_regs.ll_halt = rb + 102844UL;
    ioc->ioc_regs.alt_ll_halt = rb + 102828UL;
  }
  ioc->ioc_regs.pss_ctl_reg = rb + 100352UL;
  ioc->ioc_regs.pss_err_status_reg = rb + 100368UL;
  ioc->ioc_regs.app_pll_fast_ctl_reg = rb + 83976UL;
  ioc->ioc_regs.app_pll_slow_ctl_reg = rb + 83980UL;
  ioc->ioc_regs.ioc_sem_reg = rb + 84208UL;
  ioc->ioc_regs.ioc_usage_sem_reg = rb + 84212UL;
  ioc->ioc_regs.ioc_init_sem_reg = rb + 84216UL;
  ioc->ioc_regs.ioc_usage_reg = rb + 84160UL;
  ioc->ioc_regs.ioc_fail_sync = rb + 84164UL;
  ioc->ioc_regs.smem_page_start = rb + 32768UL;
  ioc->ioc_regs.smem_pg0 = 384U;
  ioc->ioc_regs.err_set = rb + 100376UL;
  return;
}
}
static void bfa_ioc_ct_map_port(struct bfa_ioc_s *ioc ) 
{ 
  void *rb ;
  u32 r32 ;

  {
  rb = ioc->pcidev.pci_bar_kva;
  r32 = readl((void const volatile   *)rb + 83460U);
  r32 = r32 >> (int )ioc->pcidev.pci_func * 8;
  ioc->port_id = (u8 )((r32 & 48U) >> 4);
  __bfa_trc(ioc->trcmod, __trc_fileno___4, 324, (unsigned long long )ioc->pcidev.pci_func);
  __bfa_trc(ioc->trcmod, __trc_fileno___4, 325, (unsigned long long )ioc->port_id);
  return;
}
}
static void bfa_ioc_ct2_map_port(struct bfa_ioc_s *ioc ) 
{ 
  void *rb ;
  u32 r32 ;

  {
  rb = ioc->pcidev.pci_bar_kva;
  r32 = readl((void const volatile   *)rb + 196872U);
  ioc->port_id = (u8 )((r32 & 393216U) >> 17);
  __bfa_trc(ioc->trcmod, __trc_fileno___4, 337, (unsigned long long )ioc->pcidev.pci_func);
  __bfa_trc(ioc->trcmod, __trc_fileno___4, 338, (unsigned long long )ioc->port_id);
  return;
}
}
static void bfa_ioc_ct_isr_mode_set(struct bfa_ioc_s *ioc , enum bfa_boolean msix ) 
{ 
  void *rb ;
  u32 r32 ;
  u32 mode ;

  {
  rb = ioc->pcidev.pci_bar_kva;
  r32 = readl((void const volatile   *)rb + 83460U);
  __bfa_trc(ioc->trcmod, __trc_fileno___4, 351, (unsigned long long )r32);
  mode = (r32 >> (int )ioc->pcidev.pci_func * 8) & 7U;
  if (((unsigned int )msix == 0U && mode != 0U) || ((unsigned int )msix != 0U && mode == 0U)) {
    return;
  } else {

  }
  if ((unsigned int )msix != 0U) {
    mode = 0U;
  } else {
    mode = 1U;
  }
  r32 = (u32 )(~ (7 << (int )ioc->pcidev.pci_func * 8)) & r32;
  r32 = (mode << (int )ioc->pcidev.pci_func * 8) | r32;
  __bfa_trc(ioc->trcmod, __trc_fileno___4, 369, (unsigned long long )r32);
  writel(r32, (void volatile   *)rb + 83460U);
  return;
}
}
enum bfa_boolean bfa_ioc_ct2_lpu_read_stat(struct bfa_ioc_s *ioc ) 
{ 
  u32 r32 ;

  {
  r32 = readl((void const volatile   *)ioc->ioc_regs.lpu_read_stat);
  if (r32 != 0U) {
    writel(1U, (void volatile   *)ioc->ioc_regs.lpu_read_stat);
    return (1);
  } else {

  }
  return (0);
}
}
static void bfa_ioc_ct_ownership_reset(struct bfa_ioc_s *ioc ) 
{ 


  {
  bfa_ioc_sem_get(ioc->ioc_regs.ioc_usage_sem_reg);
  writel(0U, (void volatile   *)ioc->ioc_regs.ioc_usage_reg);
  readl((void const volatile   *)ioc->ioc_regs.ioc_usage_sem_reg);
  writel(1U, (void volatile   *)ioc->ioc_regs.ioc_usage_sem_reg);
  writel(0U, (void volatile   *)ioc->ioc_regs.ioc_fail_sync);
  readl((void const volatile   *)ioc->ioc_regs.ioc_sem_reg);
  writel(1U, (void volatile   *)ioc->ioc_regs.ioc_sem_reg);
  return;
}
}
static enum bfa_boolean bfa_ioc_ct_sync_start(struct bfa_ioc_s *ioc ) 
{ 
  uint32_t r32 ;
  unsigned int tmp ;
  uint32_t sync_reqd ;
  enum bfa_boolean tmp___0 ;

  {
  tmp = readl((void const volatile   *)ioc->ioc_regs.ioc_fail_sync);
  r32 = tmp;
  sync_reqd = r32 >> 16;
  if (((uint32_t )(1 << (int )ioc->pcidev.pci_func) & sync_reqd) != 0U) {
    writel(0U, (void volatile   *)ioc->ioc_regs.ioc_fail_sync);
    writel(1U, (void volatile   *)ioc->ioc_regs.ioc_usage_reg);
    writel(0U, (void volatile   *)ioc->ioc_regs.ioc_fwstate);
    writel(0U, (void volatile   *)ioc->ioc_regs.alt_ioc_fwstate);
    return (1);
  } else {

  }
  tmp___0 = bfa_ioc_ct_sync_complete(ioc);
  return (tmp___0);
}
}
static void bfa_ioc_ct_sync_join(struct bfa_ioc_s *ioc ) 
{ 
  uint32_t r32 ;
  unsigned int tmp ;
  uint32_t sync_pos ;

  {
  tmp = readl((void const volatile   *)ioc->ioc_regs.ioc_fail_sync);
  r32 = tmp;
  sync_pos = (unsigned int )(1 << (int )ioc->pcidev.pci_func) << 16;
  writel(r32 | sync_pos, (void volatile   *)ioc->ioc_regs.ioc_fail_sync);
  return;
}
}
static void bfa_ioc_ct_sync_leave(struct bfa_ioc_s *ioc ) 
{ 
  uint32_t r32 ;
  unsigned int tmp ;
  uint32_t sync_msk ;

  {
  tmp = readl((void const volatile   *)ioc->ioc_regs.ioc_fail_sync);
  r32 = tmp;
  sync_msk = ((unsigned int )(1 << (int )ioc->pcidev.pci_func) << 16) | (unsigned int )(1 << (int )ioc->pcidev.pci_func);
  writel(~ sync_msk & r32, (void volatile   *)ioc->ioc_regs.ioc_fail_sync);
  return;
}
}
static void bfa_ioc_ct_sync_ack(struct bfa_ioc_s *ioc ) 
{ 
  uint32_t r32 ;
  unsigned int tmp ;

  {
  tmp = readl((void const volatile   *)ioc->ioc_regs.ioc_fail_sync);
  r32 = tmp;
  writel((uint32_t )(1 << (int )ioc->pcidev.pci_func) | r32, (void volatile   *)ioc->ioc_regs.ioc_fail_sync);
  return;
}
}
static enum bfa_boolean bfa_ioc_ct_sync_complete(struct bfa_ioc_s *ioc ) 
{ 
  uint32_t r32 ;
  unsigned int tmp ;
  uint32_t sync_reqd ;
  uint32_t sync_ackd ;
  uint32_t tmp_ackd ;

  {
  tmp = readl((void const volatile   *)ioc->ioc_regs.ioc_fail_sync);
  r32 = tmp;
  sync_reqd = r32 >> 16;
  sync_ackd = r32 & 65535U;
  if (sync_ackd == 0U) {
    return (1);
  } else {

  }
  tmp_ackd = sync_ackd;
  if (((uint32_t )(1 << (int )ioc->pcidev.pci_func) & sync_reqd) != 0U && ((uint32_t )(1 << (int )ioc->pcidev.pci_func) & sync_ackd) == 0U) {
    sync_ackd = (uint32_t )(1 << (int )ioc->pcidev.pci_func) | sync_ackd;
  } else {

  }
  if (sync_reqd == sync_ackd) {
    writel(r32 & 4294901760U, (void volatile   *)ioc->ioc_regs.ioc_fail_sync);
    writel(8U, (void volatile   *)ioc->ioc_regs.ioc_fwstate);
    writel(8U, (void volatile   *)ioc->ioc_regs.alt_ioc_fwstate);
    return (1);
  } else {

  }
  if (tmp_ackd != sync_ackd) {
    writel(r32 | sync_ackd, (void volatile   *)ioc->ioc_regs.ioc_fail_sync);
  } else {

  }
  return (0);
}
}
static void bfa_ioc_set_ctx_hwif(struct bfa_ioc_s *ioc , struct bfa_ioc_hwif_s *hwif ) 
{ 


  {
  hwif->ioc_firmware_lock = & bfa_ioc_ct_firmware_lock;
  hwif->ioc_firmware_unlock = & bfa_ioc_ct_firmware_unlock;
  hwif->ioc_notify_fail = & bfa_ioc_ct_notify_fail;
  hwif->ioc_ownership_reset = & bfa_ioc_ct_ownership_reset;
  hwif->ioc_sync_start = & bfa_ioc_ct_sync_start;
  hwif->ioc_sync_join = & bfa_ioc_ct_sync_join;
  hwif->ioc_sync_leave = & bfa_ioc_ct_sync_leave;
  hwif->ioc_sync_ack = & bfa_ioc_ct_sync_ack;
  hwif->ioc_sync_complete = & bfa_ioc_ct_sync_complete;
  hwif->ioc_set_fwstate = & bfa_ioc_ct_set_cur_ioc_fwstate;
  hwif->ioc_get_fwstate = & bfa_ioc_ct_get_cur_ioc_fwstate;
  hwif->ioc_set_alt_fwstate = & bfa_ioc_ct_set_alt_ioc_fwstate;
  hwif->ioc_get_alt_fwstate = & bfa_ioc_ct_get_alt_ioc_fwstate;
  return;
}
}
void bfa_ioc_set_ct_hwif(struct bfa_ioc_s *ioc ) 
{ 


  {
  bfa_ioc_set_ctx_hwif(ioc, & hwif_ct);
  hwif_ct.ioc_pll_init = & bfa_ioc_ct_pll_init;
  hwif_ct.ioc_reg_init = & bfa_ioc_ct_reg_init;
  hwif_ct.ioc_map_port = & bfa_ioc_ct_map_port;
  hwif_ct.ioc_isr_mode_set = & bfa_ioc_ct_isr_mode_set;
  ioc->ioc_hwif = & hwif_ct;
  return;
}
}
void bfa_ioc_set_ct2_hwif(struct bfa_ioc_s *ioc ) 
{ 


  {
  bfa_ioc_set_ctx_hwif(ioc, & hwif_ct2);
  hwif_ct2.ioc_pll_init = & bfa_ioc_ct2_pll_init;
  hwif_ct2.ioc_reg_init = & bfa_ioc_ct2_reg_init;
  hwif_ct2.ioc_map_port = & bfa_ioc_ct2_map_port;
  hwif_ct2.ioc_lpu_read_stat = & bfa_ioc_ct2_lpu_read_stat;
  hwif_ct2.ioc_isr_mode_set = (void (*)(struct bfa_ioc_s * , enum bfa_boolean  ))0;
  ioc->ioc_hwif = & hwif_ct2;
  return;
}
}
void bfa_ioc_ct2_poweron(struct bfa_ioc_s *ioc ) 
{ 
  void *rb ;
  u32 r32 ;

  {
  rb = ioc->pcidev.pci_bar_kva;
  r32 = readl((void const volatile   *)rb + 196924U);
  if ((r32 & 4192256U) != 0U) {
    writel(r32 & 2047U, (void volatile   *)rb + 196920U);
    return;
  } else {

  }
  writel((unsigned int )((int )ioc->pcidev.pci_func * 64 | 129024), (void volatile   *)rb + 196924U);
  writel((unsigned int )((int )ioc->pcidev.pci_func * 64), (void volatile   *)rb + 196920U);
  return;
}
}
enum bfa_status bfa_ioc_ct_pll_init(void *rb , enum bfi_asic_mode mode ) 
{ 
  u32 pll_sclk ;
  u32 pll_fclk ;
  u32 r32 ;
  enum bfa_boolean fcmode ;

  {
  fcmode = (unsigned int )mode == 1U;
  pll_sclk = 29466U;
  pll_fclk = 29466U;
  if ((unsigned int )fcmode != 0U) {
    writel(0U, (void volatile   *)rb + 83468U);
    writel(13U, (void volatile   *)rb + 82568U);
  } else {
    writel(1U, (void volatile   *)rb + 83468U);
    writel(2U, (void volatile   *)rb + 82568U);
  }
  writel(0U, (void volatile   *)rb + 82500U);
  writel(0U, (void volatile   *)rb + 82508U);
  writel(4294967295U, (void volatile   *)rb + 81924U);
  writel(4294967295U, (void volatile   *)rb + 82180U);
  writel(4294967295U, (void volatile   *)rb + 81920U);
  writel(4294967295U, (void volatile   *)rb + 82176U);
  writel(4294967295U, (void volatile   *)rb + 81924U);
  writel(4294967295U, (void volatile   *)rb + 82180U);
  writel(pll_sclk | 65536U, (void volatile   *)rb + 82440U);
  writel(pll_fclk | 65536U, (void volatile   *)rb + 82436U);
  writel(pll_sclk | 65537U, (void volatile   *)rb + 82440U);
  writel(pll_fclk | 65537U, (void volatile   *)rb + 82436U);
  readl((void const volatile   *)rb + 81924U);
  __const_udelay(8590000UL);
  writel(4294967295U, (void volatile   *)rb + 81920U);
  writel(4294967295U, (void volatile   *)rb + 82176U);
  writel(pll_sclk | 1U, (void volatile   *)rb + 82440U);
  writel(pll_fclk | 1U, (void volatile   *)rb + 82436U);
  if ((unsigned int )fcmode == 0U) {
    writel(1U, (void volatile   *)rb + 145436U);
    writel(1U, (void volatile   *)rb + 146460U);
  } else {

  }
  r32 = readl((void const volatile   *)rb + 100352U);
  r32 = r32 & 4294966783U;
  writel(r32, (void volatile   *)rb + 100352U);
  __const_udelay(4295000UL);
  if ((unsigned int )fcmode == 0U) {
    writel(0U, (void volatile   *)rb + 145436U);
    writel(0U, (void volatile   *)rb + 146460U);
  } else {

  }
  writel(4U, (void volatile   *)rb + 82464U);
  __const_udelay(4295000UL);
  r32 = readl((void const volatile   *)rb + 82468U);
  writel(0U, (void volatile   *)rb + 82464U);
  return (0);
}
}
static void bfa_ioc_ct2_sclk_init(void *rb ) 
{ 
  u32 r32 ;

  {
  r32 = readl((void const volatile   *)rb + 83980U);
  r32 = r32 & 4294967292U;
  r32 = r32 | 65548U;
  writel(r32, (void volatile   *)rb + 83980U);
  r32 = readl((void const volatile   *)rb + 83980U);
  r32 = r32 & 2684354559U;
  writel(r32, (void volatile   *)rb + 83980U);
  r32 = readl((void const volatile   *)rb + 84132U);
  writel(r32 | 16384U, (void volatile   *)rb + 84132U);
  r32 = readl((void const volatile   *)rb + 83972U);
  writel(r32 | 16U, (void volatile   *)rb + 83972U);
  r32 = readl((void const volatile   *)rb + 83980U);
  r32 = r32 & 3758096384U;
  writel(r32 | 274821915U, (void volatile   *)rb + 83980U);
  __const_udelay(4295000UL);
  return;
}
}
static void bfa_ioc_ct2_lclk_init(void *rb ) 
{ 
  u32 r32 ;

  {
  r32 = readl((void const volatile   *)rb + 83976U);
  r32 = r32 & 4294967292U;
  r32 = r32 | 65548U;
  writel(r32, (void volatile   *)rb + 83976U);
  r32 = readl((void const volatile   *)rb + 84132U);
  writel(r32, (void volatile   *)rb + 84132U);
  r32 = readl((void const volatile   *)rb + 83976U);
  writel(r32, (void volatile   *)rb + 83976U);
  r32 = readl((void const volatile   *)rb + 83976U);
  r32 = r32 & 3221225472U;
  r32 = r32 | 549548827U;
  writel(r32, (void volatile   *)rb + 83976U);
  __const_udelay(4295000UL);
  return;
}
}
static void bfa_ioc_ct2_mem_init(void *rb ) 
{ 
  u32 r32 ;

  {
  r32 = readl((void const volatile   *)rb + 100352U);
  r32 = r32 & 4294966783U;
  writel(r32, (void volatile   *)rb + 100352U);
  __const_udelay(4295000UL);
  writel(4U, (void volatile   *)rb + 83996U);
  __const_udelay(4295000UL);
  writel(0U, (void volatile   *)rb + 83996U);
  return;
}
}
void bfa_ioc_ct2_mac_reset(void *rb ) 
{ 


  {
  writel(24U, (void volatile   *)rb + 159952U);
  writel(24U, (void volatile   *)rb + 159956U);
  return;
}
}
static void bfa_ioc_ct2_enable_flash(void *rb ) 
{ 
  u32 r32 ;

  {
  r32 = readl((void const volatile   *)rb + 100544U);
  writel(r32 & 4294967294U, (void volatile   *)rb + 100544U);
  r32 = readl((void const volatile   *)rb + 100552U);
  writel(r32 | 1U, (void volatile   *)rb + 100552U);
  return;
}
}
static enum bfa_boolean bfa_ioc_ct2_nfc_halted(void *rb ) 
{ 
  u32 r32 ;

  {
  r32 = readl((void const volatile   *)rb + 160804U);
  if ((r32 & 4096U) != 0U) {
    return (1);
  } else {

  }
  return (0);
}
}
static void bfa_ioc_ct2_nfc_halt(void *rb ) 
{ 
  int i ;
  enum bfa_boolean tmp ;
  int __ret_warn_on ;
  enum bfa_boolean tmp___0 ;
  long tmp___1 ;

  {
  writel(2U, (void volatile   *)rb + 160804U);
  i = 0;
  goto ldv_48354;
  ldv_48353: 
  tmp = bfa_ioc_ct2_nfc_halted(rb);
  if ((unsigned int )tmp != 0U) {
    goto ldv_48352;
  } else {

  }
  __const_udelay(4295000UL);
  i = i + 1;
  ldv_48354: ;
  if (i <= 999) {
    goto ldv_48353;
  } else {

  }
  ldv_48352: 
  tmp___0 = bfa_ioc_ct2_nfc_halted(rb);
  __ret_warn_on = (unsigned int )tmp___0 == 0U;
  tmp___1 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp___1 != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_ioc_ct.c",
                       804);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  return;
}
}
static void bfa_ioc_ct2_nfc_resume(void *rb ) 
{ 
  u32 r32 ;
  int i ;
  int __ret_warn_on ;
  long tmp ;

  {
  writel(2U, (void volatile   *)rb + 160800U);
  i = 0;
  goto ldv_48363;
  ldv_48362: 
  r32 = readl((void const volatile   *)rb + 160804U);
  if ((r32 & 4096U) == 0U) {
    return;
  } else {

  }
  __const_udelay(4295000UL);
  i = i + 1;
  ldv_48363: ;
  if (i <= 999) {
    goto ldv_48362;
  } else {

  }
  __ret_warn_on = 1;
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_ioc_ct.c",
                       820);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  return;
}
}
static void bfa_ioc_ct2_clk_reset(void *rb ) 
{ 
  u32 r32 ;

  {
  bfa_ioc_ct2_sclk_init(rb);
  bfa_ioc_ct2_lclk_init(rb);
  r32 = readl((void const volatile   *)rb + 83980U);
  writel(r32 & 4294901759U, (void volatile   *)rb + 83980U);
  r32 = readl((void const volatile   *)rb + 83976U);
  writel(r32 & 4294901759U, (void volatile   *)rb + 83976U);
  return;
}
}
static void bfa_ioc_ct2_nfc_clk_reset(void *rb ) 
{ 
  u32 r32 ;
  u32 i ;
  int __ret_warn_on ;
  long tmp ;
  int __ret_warn_on___0 ;
  long tmp___0 ;
  int __ret_warn_on___1 ;
    klee_make_symbolic(&__ret_warn_on___1, sizeof(int), "__ret_warn_on___1");
  long tmp___1 ;

  {
  r32 = readl((void const volatile   *)rb + 100352U);
  r32 = r32 | 3U;
  writel(r32, (void volatile   *)rb + 100352U);
  writel(65536U, (void volatile   *)rb + 159880U);
  i = 0U;
  goto ldv_48378;
  ldv_48377: 
  r32 = readl((void const volatile   *)rb + 84020U);
  if ((r32 & 32U) != 0U) {
    goto ldv_48376;
  } else {

  }
  i = i + 1U;
  ldv_48378: ;
  if (i <= 999999U) {
    goto ldv_48377;
  } else {

  }
  ldv_48376: 
  __ret_warn_on = (r32 & 32U) == 0U;
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_ioc_ct.c",
                       861);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  i = 0U;
  goto ldv_48383;
  ldv_48382: 
  r32 = readl((void const volatile   *)rb + 84020U);
  if ((r32 & 32U) == 0U) {
    goto ldv_48381;
  } else {

  }
  i = i + 1U;
  ldv_48383: ;
  if (i <= 999999U) {
    goto ldv_48382;
  } else {

  }
  ldv_48381: 
  __ret_warn_on___0 = (r32 & 32U) != 0U;
  tmp___0 = ldv__builtin_expect(__ret_warn_on___0 != 0, 0L);
  if (tmp___0 != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_ioc_ct.c",
                       869);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on___0 != 0, 0L);
  r32 = readl((void const volatile   *)rb + 159872U);
  __ret_warn_on___1 = (r32 & 65536U) != 0U;
  tmp___1 = ldv__builtin_expect(__ret_warn_on___1 != 0, 0L);
  if (tmp___1 != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_ioc_ct.c",
                       872);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on___1 != 0, 0L);
  return;
}
}
static void bfa_ioc_ct2_wait_till_nfc_running(void *rb ) 
{ 
  u32 r32 ;
  int i ;
  enum bfa_boolean tmp ;
  int __ret_warn_on ;
  long tmp___0 ;

  {
  tmp = bfa_ioc_ct2_nfc_halted(rb);
  if ((unsigned int )tmp != 0U) {
    bfa_ioc_ct2_nfc_resume(rb);
  } else {

  }
  i = 0;
  goto ldv_48394;
  ldv_48393: 
  r32 = readl((void const volatile   *)rb + 160784U);
  if (r32 == 536870913U) {
    return;
  } else {

  }
  __const_udelay(4295000UL);
  i = i + 1;
  ldv_48394: ;
  if (i <= 3999) {
    goto ldv_48393;
  } else {

  }
  r32 = readl((void const volatile   *)rb + 160784U);
  __ret_warn_on = r32 != 536870913U;
  tmp___0 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp___0 != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_ioc_ct.c",
                       891);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  return;
}
}
enum bfa_status bfa_ioc_ct2_pll_init(void *rb , enum bfi_asic_mode mode ) 
{ 
  u32 wgn ;
  u32 r32 ;
  u32 nfc_ver ;

  {
  wgn = readl((void const volatile   *)rb + 84368U);
  if (wgn == 1536U) {
    bfa_ioc_ct2_clk_reset(rb);
    bfa_ioc_ct2_enable_flash(rb);
    bfa_ioc_ct2_mac_reset(rb);
    bfa_ioc_ct2_clk_reset(rb);
    bfa_ioc_ct2_enable_flash(rb);
  } else {
    nfc_ver = readl((void const volatile   *)rb + 161372U);
    if (nfc_ver > 326U && wgn == 3072U) {
      bfa_ioc_ct2_wait_till_nfc_running(rb);
      bfa_ioc_ct2_nfc_clk_reset(rb);
    } else {
      bfa_ioc_ct2_nfc_halt(rb);
      bfa_ioc_ct2_clk_reset(rb);
      bfa_ioc_ct2_mac_reset(rb);
      bfa_ioc_ct2_clk_reset(rb);
    }
  }
  r32 = readl((void const volatile   *)rb + 84132U);
  writel(r32 & 4227858431U, (void volatile   *)rb + 84132U);
  writel(1U, (void volatile   *)rb + 196760U);
  writel(1U, (void volatile   *)rb + 196764U);
  r32 = readl((void const volatile   *)rb + 83476U);
  if ((int )r32 & 1) {
    r32 = readl((void const volatile   *)rb + 196744U);
    if (r32 == 1U) {
      writel(1U, (void volatile   *)rb + 196744U);
      readl((void const volatile   *)rb + 196744U);
    } else {

    }
    r32 = readl((void const volatile   *)rb + 196748U);
    if (r32 == 1U) {
      writel(1U, (void volatile   *)rb + 196748U);
      readl((void const volatile   *)rb + 196748U);
    } else {

    }
  } else {

  }
  bfa_ioc_ct2_mem_init(rb);
  writel(0U, (void volatile   *)rb + 84148U);
  writel(0U, (void volatile   *)rb + 84156U);
  return (0);
}
}
static void bfa_ioc_ct_set_cur_ioc_fwstate(struct bfa_ioc_s *ioc , enum bfi_ioc_state fwstate ) 
{ 


  {
  writel((unsigned int )fwstate, (void volatile   *)ioc->ioc_regs.ioc_fwstate);
  return;
}
}
static enum bfi_ioc_state bfa_ioc_ct_get_cur_ioc_fwstate(struct bfa_ioc_s *ioc ) 
{ 
  unsigned int tmp ;

  {
  tmp = readl((void const volatile   *)ioc->ioc_regs.ioc_fwstate);
  return ((enum bfi_ioc_state )tmp);
}
}
static void bfa_ioc_ct_set_alt_ioc_fwstate(struct bfa_ioc_s *ioc , enum bfi_ioc_state fwstate ) 
{ 


  {
  writel((unsigned int )fwstate, (void volatile   *)ioc->ioc_regs.alt_ioc_fwstate);
  return;
}
}
static enum bfi_ioc_state bfa_ioc_ct_get_alt_ioc_fwstate(struct bfa_ioc_s *ioc ) 
{ 
  unsigned int tmp ;

  {
  tmp = readl((void const volatile   *)ioc->ioc_regs.alt_ioc_fwstate);
  return ((enum bfi_ioc_state )tmp);
}
}
bool ldv_queue_work_on_297(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_3(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_delayed_work_on_298(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_3(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_work_on_299(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_3(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
void ldv_flush_workqueue_300(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
  flush_workqueue(ldv_func_arg1);
  call_and_disable_all_3(2);
  return;
}
}
bool ldv_queue_delayed_work_on_301(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_3(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
void ldv_mutex_lock_302(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_lock_lock(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_303(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_unlock_lock(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_304(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
int ldv_mutex_trylock_305(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
  tmp = mutex_trylock(ldv_func_arg1);
  ldv_func_res = tmp;
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
  return (tmp___0);
  return (ldv_func_res);
}
}
void ldv_mutex_unlock_306(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_307(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_unlock_i_mutex_of_inode(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_308(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_lock_i_mutex_of_inode(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
int ldv_scsi_add_host_with_dma_309(struct Scsi_Host *shost , struct device *dev ,
                                   struct device *dma_dev ) 
{ 
  ldv_func_ret_type___4 ldv_func_res ;
  int tmp ;

  {
  tmp = scsi_add_host_with_dma(shost, dev, dma_dev);
  ldv_func_res = tmp;
  if (ldv_func_res == 0) {
    ldv_state_variable_35 = 1;
    ldv_initialize_scsi_host_template_35();
  } else {

  }
  return (ldv_func_res);
}
}
__inline static long ldv__builtin_expect(long exp , long c ) ;
int ldv_mutex_trylock_335(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_333(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_336(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_337(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_332(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_334(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_338(struct mutex *ldv_func_arg1 ) ;
bool ldv_queue_work_on_327(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_work_on_329(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_delayed_work_on_328(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
bool ldv_queue_delayed_work_on_331(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
void ldv_flush_workqueue_330(struct workqueue_struct *ldv_func_arg1 ) ;
int ldv_scsi_add_host_with_dma_339(struct Scsi_Host *shost , struct device *dev ,
                                   struct device *dma_dev ) ;
void bfa_msix_all(struct bfa_s *bfa , int vec ) ;
void bfa_msix_reqq(struct bfa_s *bfa , int vec ) ;
void bfa_msix_rspq(struct bfa_s *bfa , int vec ) ;
void bfa_msix_lpu_err(struct bfa_s *bfa , int vec ) ;
void bfa_hwcb_reginit(struct bfa_s *bfa ) ;
void bfa_hwcb_rspq_ack(struct bfa_s *bfa , int rspq , u32 ci ) ;
void bfa_hwcb_msix_init(struct bfa_s *bfa , int nvecs ) ;
void bfa_hwcb_msix_ctrl_install(struct bfa_s *bfa ) ;
void bfa_hwcb_msix_queue_install(struct bfa_s *bfa ) ;
void bfa_hwcb_msix_uninstall(struct bfa_s *bfa ) ;
void bfa_hwcb_isr_mode_set(struct bfa_s *bfa , enum bfa_boolean msix ) ;
void bfa_hwcb_msix_getvecs(struct bfa_s *bfa , u32 *msix_vecs_bmap , u32 *num_vecs ,
                           u32 *max_vec_bit ) ;
void bfa_hwcb_msix_get_rme_range(struct bfa_s *bfa , u32 *start , u32 *end ) ;
void bfa_hwcb_reginit(struct bfa_s *bfa ) 
{ 
  struct bfa_iocfc_regs_s *bfa_regs ;
  void *kva ;
  int fn ;
    klee_make_symbolic(&fn, sizeof(int), "fn");

  {
  bfa_regs = & bfa->iocfc.bfa_regs;
  kva = bfa->ioc.pcidev.pci_bar_kva;
  fn = (int )bfa->ioc.pcidev.pci_func;
  if (fn == 0) {
    bfa_regs->intr_status = kva + 81920UL;
    bfa_regs->intr_mask = kva + 81924UL;
  } else {
    bfa_regs->intr_status = kva + 82176UL;
    bfa_regs->intr_mask = kva + 82180UL;
  }
  return;
}
}
static void bfa_hwcb_reqq_ack_msix(struct bfa_s *bfa , int reqq ) 
{ 


  {
  writel(1U << (((int )bfa->ioc.pcidev.pci_func << 2) + reqq), (void volatile   *)bfa->iocfc.bfa_regs.intr_status);
  return;
}
}
static void bfa_hwcb_rspq_ack_msix(struct bfa_s *bfa , int rspq , u32 ci ) 
{ 


  {
  writel(256U << (((int )bfa->ioc.pcidev.pci_func << 2) + rspq), (void volatile   *)bfa->iocfc.bfa_regs.intr_status);
  if (bfa->iocfc.rsp_cq_ci[rspq] == ci) {
    return;
  } else {

  }
  bfa->iocfc.rsp_cq_ci[rspq] = ci;
  writel(ci, (void volatile   *)bfa->iocfc.bfa_regs.rme_q_ci[rspq]);
  __asm__  volatile   ("": : : "memory");
  return;
}
}
void bfa_hwcb_rspq_ack(struct bfa_s *bfa , int rspq , u32 ci ) 
{ 


  {
  if (bfa->iocfc.rsp_cq_ci[rspq] == ci) {
    return;
  } else {

  }
  bfa->iocfc.rsp_cq_ci[rspq] = ci;
  writel(ci, (void volatile   *)bfa->iocfc.bfa_regs.rme_q_ci[rspq]);
  __asm__  volatile   ("": : : "memory");
  return;
}
}
void bfa_hwcb_msix_getvecs(struct bfa_s *bfa , u32 *msix_vecs_bmap , u32 *num_vecs ,
                           u32 *max_vec_bit ) 
{ 


  {
  if ((unsigned int )bfa->ioc.pcidev.pci_func == 0U) {
    *msix_vecs_bmap = 1052431U;
    *max_vec_bit = 1048576U;
  } else {
    *msix_vecs_bmap = 2158832U;
    *max_vec_bit = 2097152U;
  }
  *msix_vecs_bmap = *msix_vecs_bmap | 983040U;
  *num_vecs = 13U;
  return;
}
}
static void bfa_hwcb_msix_dummy(struct bfa_s *bfa , int vec ) 
{ 


  {
  return;
}
}
void bfa_hwcb_msix_init(struct bfa_s *bfa , int nvecs ) 
{ 
  int __ret_warn_on ;
  long tmp ;

  {
  __ret_warn_on = nvecs != 1 && nvecs != 13;
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_hw_cb.c",
                       117);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  bfa->msix.nvecs = nvecs;
  bfa_hwcb_msix_uninstall(bfa);
  return;
}
}
void bfa_hwcb_msix_ctrl_install(struct bfa_s *bfa ) 
{ 
  int i ;

  {
  if (bfa->msix.nvecs == 0) {
    return;
  } else {

  }
  if (bfa->msix.nvecs == 1) {
    i = 0;
    goto ldv_48214;
    ldv_48213: 
    bfa->msix.handler[i] = & bfa_msix_all;
    i = i + 1;
    ldv_48214: ;
    if (i <= 21) {
      goto ldv_48213;
    } else {

    }

    return;
  } else {

  }
  i = 16;
  goto ldv_48217;
  ldv_48216: 
  bfa->msix.handler[i] = & bfa_msix_lpu_err;
  i = i + 1;
  ldv_48217: ;
  if (i <= 21) {
    goto ldv_48216;
  } else {

  }

  return;
}
}
void bfa_hwcb_msix_queue_install(struct bfa_s *bfa ) 
{ 
  int i ;

  {
  if (bfa->msix.nvecs == 0) {
    return;
  } else {

  }
  if (bfa->msix.nvecs == 1) {
    i = 0;
    goto ldv_48224;
    ldv_48223: 
    bfa->msix.handler[i] = & bfa_msix_all;
    i = i + 1;
    ldv_48224: ;
    if (i <= 15) {
      goto ldv_48223;
    } else {

    }

    return;
  } else {

  }
  i = 0;
  goto ldv_48227;
  ldv_48226: 
  bfa->msix.handler[i] = & bfa_msix_reqq;
  i = i + 1;
  ldv_48227: ;
  if (i <= 7) {
    goto ldv_48226;
  } else {

  }
  i = 8;
  goto ldv_48230;
  ldv_48229: 
  bfa->msix.handler[i] = & bfa_msix_rspq;
  i = i + 1;
  ldv_48230: ;
  if (i <= 15) {
    goto ldv_48229;
  } else {

  }

  return;
}
}
void bfa_hwcb_msix_uninstall(struct bfa_s *bfa ) 
{ 
  int i ;

  {
  i = 0;
  goto ldv_48237;
  ldv_48236: 
  bfa->msix.handler[i] = & bfa_hwcb_msix_dummy;
  i = i + 1;
  ldv_48237: ;
  if (i <= 21) {
    goto ldv_48236;
  } else {

  }

  return;
}
}
void bfa_hwcb_isr_mode_set(struct bfa_s *bfa , enum bfa_boolean msix ) 
{ 


  {
  if ((unsigned int )msix != 0U) {
    bfa->iocfc.hwif.hw_reqq_ack = & bfa_hwcb_reqq_ack_msix;
    bfa->iocfc.hwif.hw_rspq_ack = & bfa_hwcb_rspq_ack_msix;
  } else {
    bfa->iocfc.hwif.hw_reqq_ack = (void (*)(struct bfa_s * , int  ))0;
    bfa->iocfc.hwif.hw_rspq_ack = & bfa_hwcb_rspq_ack;
  }
  return;
}
}
void bfa_hwcb_msix_get_rme_range(struct bfa_s *bfa , u32 *start , u32 *end ) 
{ 


  {
  *start = 8U;
  *end = 15U;
  return;
}
}
bool ldv_queue_work_on_327(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_3(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_delayed_work_on_328(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_3(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_work_on_329(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_3(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
void ldv_flush_workqueue_330(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
  flush_workqueue(ldv_func_arg1);
  call_and_disable_all_3(2);
  return;
}
}
bool ldv_queue_delayed_work_on_331(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_3(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
void ldv_mutex_lock_332(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_lock_lock(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_333(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_unlock_lock(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_334(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
int ldv_mutex_trylock_335(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
  tmp = mutex_trylock(ldv_func_arg1);
  ldv_func_res = tmp;
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
  return (tmp___0);
  return (ldv_func_res);
}
}
void ldv_mutex_unlock_336(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_337(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_unlock_i_mutex_of_inode(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_338(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_lock_i_mutex_of_inode(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
int ldv_scsi_add_host_with_dma_339(struct Scsi_Host *shost , struct device *dev ,
                                   struct device *dma_dev ) 
{ 
  ldv_func_ret_type___4 ldv_func_res ;
  int tmp ;

  {
  tmp = scsi_add_host_with_dma(shost, dev, dma_dev);
  ldv_func_res = tmp;
  if (ldv_func_res == 0) {
    ldv_state_variable_35 = 1;
    ldv_initialize_scsi_host_template_35();
  } else {

  }
  return (ldv_func_res);
}
}
__inline static long ldv__builtin_expect(long exp , long c ) ;
int ldv_mutex_trylock_365(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_363(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_366(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_367(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_362(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_364(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_368(struct mutex *ldv_func_arg1 ) ;
bool ldv_queue_work_on_357(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_work_on_359(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_delayed_work_on_358(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
bool ldv_queue_delayed_work_on_361(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
void ldv_flush_workqueue_360(struct workqueue_struct *ldv_func_arg1 ) ;
int ldv_scsi_add_host_with_dma_369(struct Scsi_Host *shost , struct device *dev ,
                                   struct device *dma_dev ) ;
void bfa_hwct_reginit(struct bfa_s *bfa ) ;
void bfa_hwct2_reginit(struct bfa_s *bfa ) ;
void bfa_hwct_reqq_ack(struct bfa_s *bfa , int reqq ) ;
void bfa_hwct_rspq_ack(struct bfa_s *bfa , int rspq , u32 ci ) ;
void bfa_hwct2_rspq_ack(struct bfa_s *bfa , int rspq , u32 ci ) ;
void bfa_hwct_msix_init(struct bfa_s *bfa , int nvecs ) ;
void bfa_hwct_msix_ctrl_install(struct bfa_s *bfa ) ;
void bfa_hwct_msix_queue_install(struct bfa_s *bfa ) ;
void bfa_hwct_msix_uninstall(struct bfa_s *bfa ) ;
void bfa_hwct_isr_mode_set(struct bfa_s *bfa , enum bfa_boolean msix ) ;
void bfa_hwct_msix_getvecs(struct bfa_s *bfa , u32 *msix_vecs_bmap , u32 *num_vecs ,
                           u32 *max_vec_bit ) ;
void bfa_hwct_msix_get_rme_range(struct bfa_s *bfa , u32 *start , u32 *end ) ;
static int __trc_fileno___5  =    1028;
static void bfa_hwct_msix_dummy(struct bfa_s *bfa , int vec ) 
{ 


  {
  return;
}
}
void bfa_hwct_reginit(struct bfa_s *bfa ) 
{ 
  struct bfa_iocfc_regs_s *bfa_regs ;
  void *kva ;
  int fn ;

  {
  bfa_regs = & bfa->iocfc.bfa_regs;
  kva = bfa->ioc.pcidev.pci_bar_kva;
  fn = (int )bfa->ioc.pcidev.pci_func;
  if (fn == 0) {
    bfa_regs->intr_status = kva + 81920UL;
    bfa_regs->intr_mask = kva + 81924UL;
  } else {
    bfa_regs->intr_status = kva + 82176UL;
    bfa_regs->intr_mask = kva + 82180UL;
  }
  return;
}
}
void bfa_hwct2_reginit(struct bfa_s *bfa ) 
{ 
  struct bfa_iocfc_regs_s *bfa_regs ;
  void *kva ;

  {
  bfa_regs = & bfa->iocfc.bfa_regs;
  kva = bfa->ioc.pcidev.pci_bar_kva;
  bfa_regs->intr_status = kva + 196864UL;
  bfa_regs->intr_mask = kva + 196868UL;
  return;
}
}
void bfa_hwct_reqq_ack(struct bfa_s *bfa , int reqq ) 
{ 
  u32 r32 ;

  {
  r32 = readl((void const volatile   *)bfa->iocfc.bfa_regs.cpe_q_ctrl[reqq]);
  writel(r32, (void volatile   *)bfa->iocfc.bfa_regs.cpe_q_ctrl[reqq]);
  return;
}
}
void bfa_hwct_rspq_ack(struct bfa_s *bfa , int rspq , u32 ci ) 
{ 
  u32 r32 ;

  {
  r32 = readl((void const volatile   *)bfa->iocfc.bfa_regs.rme_q_ctrl[rspq]);
  writel(r32, (void volatile   *)bfa->iocfc.bfa_regs.rme_q_ctrl[rspq]);
  bfa->iocfc.rsp_cq_ci[rspq] = ci;
  writel(ci, (void volatile   *)bfa->iocfc.bfa_regs.rme_q_ci[rspq]);
  __asm__  volatile   ("": : : "memory");
  return;
}
}
void bfa_hwct2_rspq_ack(struct bfa_s *bfa , int rspq , u32 ci ) 
{ 


  {
  bfa->iocfc.rsp_cq_ci[rspq] = ci;
  writel(ci, (void volatile   *)bfa->iocfc.bfa_regs.rme_q_ci[rspq]);
  __asm__  volatile   ("": : : "memory");
  return;
}
}
void bfa_hwct_msix_getvecs(struct bfa_s *bfa , u32 *msix_vecs_bmap , u32 *num_vecs ,
                           u32 *max_vec_bit ) 
{ 


  {
  *msix_vecs_bmap = 511U;
  *max_vec_bit = 256U;
  *num_vecs = 9U;
  return;
}
}
void bfa_hwct_msix_init(struct bfa_s *bfa , int nvecs ) 
{ 
  int __ret_warn_on ;
  long tmp ;

  {
  __ret_warn_on = nvecs != 1 && nvecs != 9;
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_hw_ct.c",
                       114);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  __bfa_trc(bfa->trcmod, __trc_fileno___5, 115, (unsigned long long )nvecs);
  bfa->msix.nvecs = nvecs;
  bfa_hwct_msix_uninstall(bfa);
  return;
}
}
void bfa_hwct_msix_ctrl_install(struct bfa_s *bfa ) 
{ 


  {
  if (bfa->msix.nvecs == 0) {
    return;
  } else {

  }
  if (bfa->msix.nvecs == 1) {
    bfa->msix.handler[0] = & bfa_msix_all;
  } else {
    bfa->msix.handler[0] = & bfa_msix_lpu_err;
  }
  return;
}
}
void bfa_hwct_msix_queue_install(struct bfa_s *bfa ) 
{ 
  int i ;

  {
  if (bfa->msix.nvecs == 0) {
    return;
  } else {

  }
  if (bfa->msix.nvecs == 1) {
    i = 1;
    goto ldv_48225;
    ldv_48224: 
    bfa->msix.handler[i] = & bfa_msix_all;
    i = i + 1;
    ldv_48225: ;
    if (i <= 8) {
      goto ldv_48224;
    } else {

    }

    return;
  } else {

  }
  i = 1;
  goto ldv_48228;
  ldv_48227: 
  bfa->msix.handler[i] = & bfa_msix_reqq;
  i = i + 1;
  ldv_48228: ;
  if (i <= 4) {
    goto ldv_48227;
  } else {

  }
  i = 5;
  goto ldv_48231;
  ldv_48230: 
  bfa->msix.handler[i] = & bfa_msix_rspq;
  i = i + 1;
  ldv_48231: ;
  if (i <= 8) {
    goto ldv_48230;
  } else {

  }

  return;
}
}
void bfa_hwct_msix_uninstall(struct bfa_s *bfa ) 
{ 
  int i ;

  {
  i = 0;
  goto ldv_48238;
  ldv_48237: 
  bfa->msix.handler[i] = & bfa_hwct_msix_dummy;
  i = i + 1;
  ldv_48238: ;
  if (i <= 8) {
    goto ldv_48237;
  } else {

  }

  return;
}
}
void bfa_hwct_isr_mode_set(struct bfa_s *bfa , enum bfa_boolean msix ) 
{ 


  {
  __bfa_trc(bfa->trcmod, __trc_fileno___5, 169, 0ULL);
  if ((unsigned long )(bfa->ioc.ioc_hwif)->ioc_isr_mode_set != (unsigned long )((void (*)(struct bfa_ioc_s * ,
                                                                                          enum bfa_boolean  ))0)) {
    (*((bfa->ioc.ioc_hwif)->ioc_isr_mode_set))(& bfa->ioc, msix);
  } else {

  }
  return;
}
}
void bfa_hwct_msix_get_rme_range(struct bfa_s *bfa , u32 *start , u32 *end ) 
{ 


  {
  *start = 5U;
  *end = 8U;
  return;
}
}
bool ldv_queue_work_on_357(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_3(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_delayed_work_on_358(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_3(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_work_on_359(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_3(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
void ldv_flush_workqueue_360(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
  flush_workqueue(ldv_func_arg1);
  call_and_disable_all_3(2);
  return;
}
}
bool ldv_queue_delayed_work_on_361(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_3(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
void ldv_mutex_lock_362(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_lock_lock(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_363(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_unlock_lock(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_364(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
int ldv_mutex_trylock_365(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
  tmp = mutex_trylock(ldv_func_arg1);
  ldv_func_res = tmp;
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
  return (tmp___0);
  return (ldv_func_res);
}
}
void ldv_mutex_unlock_366(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_367(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_unlock_i_mutex_of_inode(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_368(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_lock_i_mutex_of_inode(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
int ldv_scsi_add_host_with_dma_369(struct Scsi_Host *shost , struct device *dev ,
                                   struct device *dma_dev ) 
{ 
  ldv_func_ret_type___4 ldv_func_res ;
  int tmp ;

  {
  tmp = scsi_add_host_with_dma(shost, dev, dma_dev);
  ldv_func_res = tmp;
  if (ldv_func_res == 0) {
    ldv_state_variable_35 = 1;
    ldv_initialize_scsi_host_template_35();
  } else {

  }
  return (ldv_func_res);
}
}
__inline static long ldv__builtin_expect(long exp , long c ) ;
extern char *strncat(char * , char const   * , __kernel_size_t  ) ;
int ldv_mutex_trylock_395(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_393(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_396(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_397(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_392(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_394(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_398(struct mutex *ldv_func_arg1 ) ;
bool ldv_queue_work_on_387(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_work_on_389(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_delayed_work_on_388(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
bool ldv_queue_delayed_work_on_391(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
void ldv_flush_workqueue_390(struct workqueue_struct *ldv_func_arg1 ) ;
__inline static bool queue_work___1(struct workqueue_struct *wq , struct work_struct *work ) 
{ 
  bool tmp ;

  {
  tmp = ldv_queue_work_on_387(8192, wq, work);
  return (tmp);
}
}
int ldv_scsi_add_host_with_dma_399(struct Scsi_Host *shost , struct device *dev ,
                                   struct device *dma_dev ) ;
__inline static void bfa_wc_up(struct bfa_wc_s *wc ) 
{ 


  {
  wc->wc_count = wc->wc_count + 1;
  return;
}
}
__inline static void bfa_wc_down(struct bfa_wc_s *wc ) 
{ 


  {
  wc->wc_count = wc->wc_count - 1;
  if (wc->wc_count == 0) {
    (*(wc->wc_resume))(wc->wc_cbarg);
  } else {

  }
  return;
}
}
__inline static void bfa_wc_init(struct bfa_wc_s *wc , void (*wc_resume)(void * ) ,
                                 void *wc_cbarg ) 
{ 


  {
  wc->wc_resume = wc_resume;
  wc->wc_cbarg = wc_cbarg;
  wc->wc_count = 0;
  bfa_wc_up(wc);
  return;
}
}
__inline static void bfa_wc_wait(struct bfa_wc_s *wc ) 
{ 


  {
  bfa_wc_down(wc);
  return;
}
}
__inline static void wwn2str___1(char *wwn_str , u64 wwn ) 
{ 
  union __anonunion_w_281___0 w ;

  {
  w.wwn = wwn;
  sprintf(wwn_str, "%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x", (int )w.byte[0], (int )w.byte[1],
          (int )w.byte[2], (int )w.byte[3], (int )w.byte[4], (int )w.byte[5], (int )w.byte[6],
          (int )w.byte[7]);
  return;
}
}
int bfa_iocfc_get_pbc_vports(struct bfa_s *bfa , struct bfi_pbc_vport_s *pbc_vport ) ;
enum bfa_port_topology bfa_fcport_get_topology(struct bfa_s *bfa ) ;
u8 bfa_fcport_get_myalpa(struct bfa_s *bfa ) ;
u8 bfa_fcport_get_rx_bbcredit(struct bfa_s *bfa ) ;
void bfa_fcport_event_register(struct bfa_s *bfa , void (*cbfn)(void * , enum bfa_port_linkstate  ) ,
                               void *cbarg ) ;
void bfa_fcport_set_tx_bbcredit(struct bfa_s *bfa , u16 tx_bbcredit ) ;
enum bfa_boolean bfa_fcport_is_linkup(struct bfa_s *bfa ) ;
void *bfa_fcxp_get_reqbuf(struct bfa_fcxp_s *fcxp ) ;
__inline static void *bfa_uf_get_frmbuf(struct bfa_uf_s *uf ) 
{ 


  {
  return ((void *)uf->data_ptr);
}
}
__inline static u16 bfa_uf_get_frmlen(struct bfa_uf_s *uf ) 
{ 


  {
  return (uf->data_len);
}
}
void bfa_uf_recv_register(struct bfa_s *bfa , void (*ufrecv)(void * , struct bfa_uf_s * ) ,
                          void *cbarg ) ;
void bfa_uf_free(struct bfa_uf_s *uf ) ;
struct bfa_lps_s *bfa_lps_alloc(struct bfa_s *bfa ) ;
void bfa_lps_delete(struct bfa_lps_s *lps ) ;
void bfa_lps_flogi(struct bfa_lps_s *lps , void *uarg , u8 alpa , u16 pdusz , wwn_t pwwn ,
                   wwn_t nwwn , enum bfa_boolean auth_en ) ;
void bfa_cb_lps_flogi_comp(void *bfad , void *uarg , enum bfa_status status ) ;
void bfa_cb_lps_flogo_comp(void *bfad , void *uarg ) ;
void bfa_fcs_lport_uf_recv(struct bfa_fcs_lport_s *lport , struct fchs_s *fchs , u16 len ) ;
void bfa_fcs_lport_attach(struct bfa_fcs_lport_s *lport , struct bfa_fcs_s *fcs ,
                          u16 vf_id , struct bfa_fcs_vport_s *vport ) ;
void bfa_fcs_lport_init(struct bfa_fcs_lport_s *lport , struct bfa_lport_cfg_s *port_cfg ) ;
void bfa_fcs_lport_online(struct bfa_fcs_lport_s *port ) ;
void bfa_fcs_lport_offline(struct bfa_fcs_lport_s *port ) ;
void bfa_fcs_lport_delete(struct bfa_fcs_lport_s *port ) ;
void bfa_fcs_lport_stop(struct bfa_fcs_lport_s *port ) ;
void bfa_fcs_vport_online(struct bfa_fcs_vport_s *vport ) ;
void bfa_fcs_vport_offline(struct bfa_fcs_vport_s *vport ) ;
void bfa_fcs_vport_fcs_delete(struct bfa_fcs_vport_s *vport ) ;
void bfa_fcs_vport_fcs_stop(struct bfa_fcs_vport_s *vport ) ;
void bfa_fcs_fabric_attach(struct bfa_fcs_s *fcs ) ;
void bfa_fcs_fabric_modinit(struct bfa_fcs_s *fcs ) ;
void bfa_fcs_fabric_modexit(struct bfa_fcs_s *fcs ) ;
void bfa_fcs_fabric_link_up(struct bfa_fcs_fabric_s *fabric ) ;
void bfa_fcs_fabric_link_down(struct bfa_fcs_fabric_s *fabric ) ;
void bfa_fcs_fabric_addvport(struct bfa_fcs_fabric_s *fabric , struct bfa_fcs_vport_s *vport ) ;
void bfa_fcs_fabric_delvport(struct bfa_fcs_fabric_s *fabric , struct bfa_fcs_vport_s *vport ) ;
struct bfa_fcs_vport_s *bfa_fcs_fabric_vport_lookup(struct bfa_fcs_fabric_s *fabric ,
                                                    wwn_t pwwn ) ;
void bfa_fcs_fabric_uf_recv(struct bfa_fcs_fabric_s *fabric , struct fchs_s *fchs ,
                            u16 len ) ;
void bfa_fcs_fabric_psymb_init(struct bfa_fcs_fabric_s *fabric ) ;
void bfa_fcs_fabric_nsymb_init(struct bfa_fcs_fabric_s *fabric ) ;
void bfa_fcs_fabric_set_fabric_name(struct bfa_fcs_fabric_s *fabric , wwn_t fabric_name ) ;
u16 bfa_fcs_fabric_get_switch_oui(struct bfa_fcs_fabric_s *fabric ) ;
void bfa_fcs_uf_attach(struct bfa_fcs_s *fcs ) ;
void bfa_fcs_port_attach(struct bfa_fcs_s *fcs ) ;
void bfa_fcs_fabric_modstop(struct bfa_fcs_s *fcs ) ;
void bfa_fcs_fabric_sm_online(struct bfa_fcs_fabric_s *fabric , enum bfa_fcs_fabric_event event ) ;
void bfa_fcs_fabric_sm_loopback(struct bfa_fcs_fabric_s *fabric , enum bfa_fcs_fabric_event event ) ;
void bfa_fcs_fabric_sm_auth_failed(struct bfa_fcs_fabric_s *fabric , enum bfa_fcs_fabric_event event ) ;
void fcbuild_init(void) ;
u16 fc_flogi_acc_build(struct fchs_s *fchs , struct fc_logi_s *flogi , u32 s_id ,
                       __be16 ox_id , wwn_t port_name , wwn_t node_name , u16 pdu_size ,
                       u16 local_bb_credits , u8 bb_scn ) ;
static int __trc_fileno___6  =    2049;
static struct bfa_fcs_mod_s fcs_modules[3U]  = {      {& bfa_fcs_port_attach, (void (*)(struct bfa_fcs_s * ))0, (void (*)(struct bfa_fcs_s * ))0}, 
        {& bfa_fcs_uf_attach,
      (void (*)(struct bfa_fcs_s * ))0, (void (*)(struct bfa_fcs_s * ))0}, 
        {& bfa_fcs_fabric_attach, & bfa_fcs_fabric_modinit, & bfa_fcs_fabric_modexit}};
static void bfa_fcs_exit_comp(void *fcs_cbarg ) 
{ 
  struct bfa_fcs_s *fcs ;
  struct bfad_s *bfad ;

  {
  fcs = (struct bfa_fcs_s *)fcs_cbarg;
  bfad = fcs->bfad;
  complete(& bfad->comp);
  return;
}
}
void bfa_fcs_attach(struct bfa_fcs_s *fcs , struct bfa_s *bfa , struct bfad_s *bfad ,
                    enum bfa_boolean min_cfg ) 
{ 
  int i ;
  struct bfa_fcs_mod_s *mod ;

  {
  fcs->bfa = bfa;
  fcs->bfad = bfad;
  fcs->min_cfg = min_cfg;
  fcs->num_rport_logins = 0U;
  bfa->fcs = 1;
  fcbuild_init();
  i = 0;
  goto ldv_48722;
  ldv_48721: 
  mod = (struct bfa_fcs_mod_s *)(& fcs_modules) + (unsigned long )i;
  if ((unsigned long )mod->attach != (unsigned long )((void (*)(struct bfa_fcs_s * ))0)) {
    (*(mod->attach))(fcs);
  } else {

  }
  i = i + 1;
  ldv_48722: ;
  if ((unsigned int )i <= 2U) {
    goto ldv_48721;
  } else {

  }

  return;
}
}
void bfa_fcs_init(struct bfa_fcs_s *fcs ) 
{ 
  int i ;
  struct bfa_fcs_mod_s *mod ;

  {
  i = 0;
  goto ldv_48732;
  ldv_48731: 
  mod = (struct bfa_fcs_mod_s *)(& fcs_modules) + (unsigned long )i;
  if ((unsigned long )mod->modinit != (unsigned long )((void (*)(struct bfa_fcs_s * ))0)) {
    (*(mod->modinit))(fcs);
  } else {

  }
  i = i + 1;
  ldv_48732: ;
  if ((unsigned int )i <= 2U) {
    goto ldv_48731;
  } else {

  }

  return;
}
}
void bfa_fcs_update_cfg(struct bfa_fcs_s *fcs ) 
{ 
  struct bfa_fcs_fabric_s *fabric ;
  struct bfa_lport_cfg_s *port_cfg ;
  struct bfa_ioc_s *ioc ;

  {
  fabric = & fcs->fabric;
  port_cfg = & fabric->bport.port_cfg;
  ioc = & ((fabric->fcs)->bfa)->ioc;
  port_cfg->nwwn = (ioc->attr)->nwwn;
  port_cfg->pwwn = (ioc->attr)->pwwn;
  return;
}
}
void bfa_fcs_stop(struct bfa_fcs_s *fcs ) 
{ 


  {
  bfa_wc_init(& fcs->wc, & bfa_fcs_exit_comp, (void *)fcs);
  bfa_wc_up(& fcs->wc);
  bfa_fcs_fabric_modstop(fcs);
  bfa_wc_wait(& fcs->wc);
  return;
}
}
void bfa_fcs_pbc_vport_init(struct bfa_fcs_s *fcs ) 
{ 
  int i ;
  int npbc_vports ;
    klee_make_symbolic(&npbc_vports, sizeof(int), "npbc_vports");
  struct bfi_pbc_vport_s pbc_vports[16U] ;

  {
  if ((unsigned int )fcs->min_cfg == 0U) {
    npbc_vports = bfa_iocfc_get_pbc_vports(fcs->bfa, (struct bfi_pbc_vport_s *)(& pbc_vports));
    i = 0;
    goto ldv_48750;
    ldv_48749: 
    bfa_fcb_pbc_vport_create((struct bfad_s *)(fcs->bfa)->bfad, pbc_vports[i]);
    i = i + 1;
    ldv_48750: ;
    if (i < npbc_vports) {
      goto ldv_48749;
    } else {

    }

  } else {

  }
  return;
}
}
void bfa_fcs_driver_info_init(struct bfa_fcs_s *fcs , struct bfa_fcs_driver_info_s *driver_info ) 
{ 


  {
  fcs->driver_info = *driver_info;
  bfa_fcs_fabric_psymb_init(& fcs->fabric);
  bfa_fcs_fabric_nsymb_init(& fcs->fabric);
  return;
}
}
void bfa_fcs_exit(struct bfa_fcs_s *fcs ) 
{ 
  struct bfa_fcs_mod_s *mod ;
  int nmods ;
    klee_make_symbolic(&nmods, sizeof(int), "nmods");
  int i ;

  {
  bfa_wc_init(& fcs->wc, & bfa_fcs_exit_comp, (void *)fcs);
  nmods = 3;
  i = 0;
  goto ldv_48765;
  ldv_48764: 
  mod = (struct bfa_fcs_mod_s *)(& fcs_modules) + (unsigned long )i;
  if ((unsigned long )mod->modexit != (unsigned long )((void (*)(struct bfa_fcs_s * ))0)) {
    bfa_wc_up(& fcs->wc);
    (*(mod->modexit))(fcs);
  } else {

  }
  i = i + 1;
  ldv_48765: ;
  if (i < nmods) {
    goto ldv_48764;
  } else {

  }
  bfa_wc_wait(& fcs->wc);
  return;
}
}
static void bfa_fcs_fabric_init(struct bfa_fcs_fabric_s *fabric ) ;
static void bfa_fcs_fabric_login(struct bfa_fcs_fabric_s *fabric ) ;
static void bfa_fcs_fabric_notify_online(struct bfa_fcs_fabric_s *fabric ) ;
static void bfa_fcs_fabric_notify_offline(struct bfa_fcs_fabric_s *fabric ) ;
static void bfa_fcs_fabric_delay(void *cbarg ) ;
static void bfa_fcs_fabric_delete(struct bfa_fcs_fabric_s *fabric ) ;
static void bfa_fcs_fabric_delete_comp(void *cbarg ) ;
static void bfa_fcs_fabric_stop(struct bfa_fcs_fabric_s *fabric ) ;
static void bfa_fcs_fabric_stop_comp(void *cbarg ) ;
static void bfa_fcs_fabric_process_uf(struct bfa_fcs_fabric_s *fabric , struct fchs_s *fchs ,
                                      u16 len ) ;
static void bfa_fcs_fabric_process_flogi(struct bfa_fcs_fabric_s *fabric , struct fchs_s *fchs ,
                                         u16 len ) ;
static void bfa_fcs_fabric_send_flogi_acc(struct bfa_fcs_fabric_s *fabric ) ;
static void bfa_fcs_fabric_flogiacc_comp(void *fcsarg , struct bfa_fcxp_s *fcxp ,
                                         void *cbarg , enum bfa_status status , u32 rsp_len ,
                                         u32 resid_len , struct fchs_s *rspfchs ) ;
static void bfa_fcs_fabric_sm_uninit(struct bfa_fcs_fabric_s *fabric , enum bfa_fcs_fabric_event event ) ;
static void bfa_fcs_fabric_sm_created(struct bfa_fcs_fabric_s *fabric , enum bfa_fcs_fabric_event event ) ;
static void bfa_fcs_fabric_sm_linkdown(struct bfa_fcs_fabric_s *fabric , enum bfa_fcs_fabric_event event ) ;
static void bfa_fcs_fabric_sm_flogi(struct bfa_fcs_fabric_s *fabric , enum bfa_fcs_fabric_event event ) ;
static void bfa_fcs_fabric_sm_flogi_retry(struct bfa_fcs_fabric_s *fabric , enum bfa_fcs_fabric_event event ) ;
static void bfa_fcs_fabric_sm_auth(struct bfa_fcs_fabric_s *fabric , enum bfa_fcs_fabric_event event ) ;
static void bfa_fcs_fabric_sm_nofabric(struct bfa_fcs_fabric_s *fabric , enum bfa_fcs_fabric_event event ) ;
static void bfa_fcs_fabric_sm_evfp(struct bfa_fcs_fabric_s *fabric , enum bfa_fcs_fabric_event event ) ;
static void bfa_fcs_fabric_sm_evfp_done(struct bfa_fcs_fabric_s *fabric , enum bfa_fcs_fabric_event event ) ;
static void bfa_fcs_fabric_sm_isolated(struct bfa_fcs_fabric_s *fabric , enum bfa_fcs_fabric_event event ) ;
static void bfa_fcs_fabric_sm_deleting(struct bfa_fcs_fabric_s *fabric , enum bfa_fcs_fabric_event event ) ;
static void bfa_fcs_fabric_sm_stopping(struct bfa_fcs_fabric_s *fabric , enum bfa_fcs_fabric_event event ) ;
static void bfa_fcs_fabric_sm_cleanup(struct bfa_fcs_fabric_s *fabric , enum bfa_fcs_fabric_event event ) ;
static void bfa_fcs_fabric_sm_uninit(struct bfa_fcs_fabric_s *fabric , enum bfa_fcs_fabric_event event ) 
{ 


  {
  __bfa_trc((fabric->fcs)->trcmod, __trc_fileno___6, 277, fabric->bport.port_cfg.pwwn);
  __bfa_trc((fabric->fcs)->trcmod, __trc_fileno___6, 278, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 1U: 
  fabric->sm = (void (*)(void * , int  ))(& bfa_fcs_fabric_sm_created);
  bfa_fcs_fabric_init(fabric);
  bfa_fcs_lport_init(& fabric->bport, & fabric->bport.port_cfg);
  goto ldv_48847;
  case 4U: ;
  case 3U: ;
  goto ldv_48847;
  default: 
  __bfa_trc((fabric->fcs)->trcmod, __trc_fileno___6, 292, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcs.c",
         292, (unsigned int )event);
  }
  ldv_48847: ;
  return;
}
}
static void bfa_fcs_fabric_sm_created(struct bfa_fcs_fabric_s *fabric , enum bfa_fcs_fabric_event event ) 
{ 
  struct bfa_s *bfa ;
  enum bfa_boolean tmp ;
  u8 tmp___0 ;
  enum bfa_port_topology tmp___1 ;
  enum bfa_port_topology tmp___2 ;

  {
  bfa = (fabric->fcs)->bfa;
  __bfa_trc((fabric->fcs)->trcmod, __trc_fileno___6, 305, fabric->bport.port_cfg.pwwn);
  __bfa_trc((fabric->fcs)->trcmod, __trc_fileno___6, 306, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 16U: 
  tmp = bfa_fcport_is_linkup((fabric->fcs)->bfa);
  if ((unsigned int )tmp == 0U) {
    fabric->sm = (void (*)(void * , int  ))(& bfa_fcs_fabric_sm_linkdown);
    goto ldv_48857;
  } else {

  }
  tmp___2 = bfa_fcport_get_topology(bfa);
  if ((unsigned int )tmp___2 == 2U) {
    fabric->fab_type = 3;
    tmp___0 = bfa_fcport_get_myalpa(bfa);
    fabric->bport.pid = (unsigned int )tmp___0;
    fabric->bport.pid = (unsigned int )(((((int )fabric->bport.pid & 255) << 16) | ((int )fabric->bport.pid & 65280)) | (((int )fabric->bport.pid & 16711680) >> 16));
    fabric->sm = (void (*)(void * , int  ))(& bfa_fcs_fabric_sm_online);
    tmp___1 = bfa_fcport_get_topology((fabric->fcs)->bfa);
    if ((unsigned int )tmp___1 == 5U) {
      if ((unsigned int )fabric->fab_type == 1U) {
        fabric->oper_type = 5;
      } else {
        fabric->oper_type = 21;
      }
    } else {
      fabric->oper_type = 6;
    }
    bfa_fcs_lport_online(& fabric->bport);
  } else {
    fabric->sm = (void (*)(void * , int  ))(& bfa_fcs_fabric_sm_flogi);
    bfa_fcs_fabric_login(fabric);
  }
  goto ldv_48857;
  case 4U: ;
  case 3U: ;
  goto ldv_48857;
  case 2U: 
  fabric->sm = (void (*)(void * , int  ))(& bfa_fcs_fabric_sm_deleting);
  bfa_fcs_fabric_delete(fabric);
  goto ldv_48857;
  default: 
  __bfa_trc((fabric->fcs)->trcmod, __trc_fileno___6, 339, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcs.c",
         339, (unsigned int )event);
  }
  ldv_48857: ;
  return;
}
}
static void bfa_fcs_fabric_sm_linkdown(struct bfa_fcs_fabric_s *fabric , enum bfa_fcs_fabric_event event ) 
{ 
  struct bfa_s *bfa ;
  enum bfa_port_topology tmp ;
  u8 tmp___0 ;
  enum bfa_port_topology tmp___1 ;

  {
  bfa = (fabric->fcs)->bfa;
  __bfa_trc((fabric->fcs)->trcmod, __trc_fileno___6, 353, fabric->bport.port_cfg.pwwn);
  __bfa_trc((fabric->fcs)->trcmod, __trc_fileno___6, 354, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 4U: 
  tmp = bfa_fcport_get_topology(bfa);
  if ((unsigned int )tmp != 2U) {
    fabric->sm = (void (*)(void * , int  ))(& bfa_fcs_fabric_sm_flogi);
    bfa_fcs_fabric_login(fabric);
    goto ldv_48868;
  } else {

  }
  fabric->fab_type = 3;
  tmp___0 = bfa_fcport_get_myalpa(bfa);
  fabric->bport.pid = (unsigned int )tmp___0;
  fabric->bport.pid = (unsigned int )(((((int )fabric->bport.pid & 255) << 16) | ((int )fabric->bport.pid & 65280)) | (((int )fabric->bport.pid & 16711680) >> 16));
  fabric->sm = (void (*)(void * , int  ))(& bfa_fcs_fabric_sm_online);
  tmp___1 = bfa_fcport_get_topology((fabric->fcs)->bfa);
  if ((unsigned int )tmp___1 == 5U) {
    if ((unsigned int )fabric->fab_type == 1U) {
      fabric->oper_type = 5;
    } else {
      fabric->oper_type = 21;
    }
  } else {
    fabric->oper_type = 6;
  }
  bfa_fcs_lport_online(& fabric->bport);
  goto ldv_48868;
  case 6U: ;
  case 15U: ;
  goto ldv_48868;
  case 2U: 
  fabric->sm = (void (*)(void * , int  ))(& bfa_fcs_fabric_sm_deleting);
  bfa_fcs_fabric_delete(fabric);
  goto ldv_48868;
  case 17U: 
  fabric->sm = (void (*)(void * , int  ))(& bfa_fcs_fabric_sm_cleanup);
  bfa_fcs_fabric_stop(fabric);
  goto ldv_48868;
  default: 
  __bfa_trc((fabric->fcs)->trcmod, __trc_fileno___6, 386, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcs.c",
         386, (unsigned int )event);
  }
  ldv_48868: ;
  return;
}
}
static void bfa_fcs_fabric_sm_flogi(struct bfa_fcs_fabric_s *fabric , enum bfa_fcs_fabric_event event ) 
{ 
  enum bfa_port_topology tmp ;

  {
  __bfa_trc((fabric->fcs)->trcmod, __trc_fileno___6, 397, fabric->bport.port_cfg.pwwn);
  __bfa_trc((fabric->fcs)->trcmod, __trc_fileno___6, 398, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 5U: 
  bfa_fcport_set_tx_bbcredit((fabric->fcs)->bfa, (int )fabric->bb_credit);
  fabric->fab_type = 1;
  if ((unsigned int )fabric->auth_reqd != 0U && (unsigned int )fabric->is_auth != 0U) {
    fabric->sm = (void (*)(void * , int  ))(& bfa_fcs_fabric_sm_auth);
    __bfa_trc((fabric->fcs)->trcmod, __trc_fileno___6, 409, (unsigned long long )event);
  } else {
    fabric->sm = (void (*)(void * , int  ))(& bfa_fcs_fabric_sm_online);
    bfa_fcs_fabric_notify_online(fabric);
  }
  goto ldv_48879;
  case 6U: 
  fabric->sm = (void (*)(void * , int  ))(& bfa_fcs_fabric_sm_flogi_retry);
  bfa_timer_begin(& ((fabric->fcs)->bfa)->timer_mod, & fabric->delay_timer, & bfa_fcs_fabric_delay,
                  (void *)fabric, 2000U);
  goto ldv_48879;
  case 15U: 
  fabric->sm = (void (*)(void * , int  ))(& bfa_fcs_fabric_sm_loopback);
  (*((fabric->lps)->sm))((void *)fabric->lps, 6);
  tmp = bfa_fcport_get_topology((fabric->fcs)->bfa);
  if ((unsigned int )tmp == 5U) {
    if ((unsigned int )fabric->fab_type == 1U) {
      fabric->oper_type = 5;
    } else {
      fabric->oper_type = 21;
    }
  } else {
    fabric->oper_type = 6;
  }
  goto ldv_48879;
  case 7U: 
  fabric->fab_type = 2;
  bfa_fcport_set_tx_bbcredit((fabric->fcs)->bfa, (int )fabric->bb_credit);
  bfa_fcs_fabric_notify_online(fabric);
  fabric->sm = (void (*)(void * , int  ))(& bfa_fcs_fabric_sm_nofabric);
  goto ldv_48879;
  case 3U: 
  fabric->sm = (void (*)(void * , int  ))(& bfa_fcs_fabric_sm_linkdown);
  (*((fabric->lps)->sm))((void *)fabric->lps, 6);
  goto ldv_48879;
  case 2U: 
  fabric->sm = (void (*)(void * , int  ))(& bfa_fcs_fabric_sm_deleting);
  (*((fabric->lps)->sm))((void *)fabric->lps, 6);
  bfa_fcs_fabric_delete(fabric);
  goto ldv_48879;
  default: 
  __bfa_trc((fabric->fcs)->trcmod, __trc_fileno___6, 449, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcs.c",
         449, (unsigned int )event);
  }
  ldv_48879: ;
  return;
}
}
static void bfa_fcs_fabric_sm_flogi_retry(struct bfa_fcs_fabric_s *fabric , enum bfa_fcs_fabric_event event ) 
{ 


  {
  __bfa_trc((fabric->fcs)->trcmod, __trc_fileno___6, 458, fabric->bport.port_cfg.pwwn);
  __bfa_trc((fabric->fcs)->trcmod, __trc_fileno___6, 459, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 11U: 
  fabric->sm = (void (*)(void * , int  ))(& bfa_fcs_fabric_sm_flogi);
  bfa_fcs_fabric_login(fabric);
  goto ldv_48891;
  case 3U: 
  fabric->sm = (void (*)(void * , int  ))(& bfa_fcs_fabric_sm_linkdown);
  bfa_timer_stop(& fabric->delay_timer);
  goto ldv_48891;
  case 2U: 
  fabric->sm = (void (*)(void * , int  ))(& bfa_fcs_fabric_sm_deleting);
  bfa_timer_stop(& fabric->delay_timer);
  bfa_fcs_fabric_delete(fabric);
  goto ldv_48891;
  default: 
  __bfa_trc((fabric->fcs)->trcmod, __trc_fileno___6, 479, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcs.c",
         479, (unsigned int )event);
  }
  ldv_48891: ;
  return;
}
}
static void bfa_fcs_fabric_sm_auth(struct bfa_fcs_fabric_s *fabric , enum bfa_fcs_fabric_event event ) 
{ 


  {
  __bfa_trc((fabric->fcs)->trcmod, __trc_fileno___6, 490, fabric->bport.port_cfg.pwwn);
  __bfa_trc((fabric->fcs)->trcmod, __trc_fileno___6, 491, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 12U: 
  fabric->sm = (void (*)(void * , int  ))(& bfa_fcs_fabric_sm_auth_failed);
  (*((fabric->lps)->sm))((void *)fabric->lps, 6);
  goto ldv_48900;
  case 13U: 
  fabric->sm = (void (*)(void * , int  ))(& bfa_fcs_fabric_sm_online);
  bfa_fcs_fabric_notify_online(fabric);
  goto ldv_48900;
  case 8U: 
  fabric->sm = (void (*)(void * , int  ))(& bfa_fcs_fabric_sm_evfp);
  goto ldv_48900;
  case 3U: 
  fabric->sm = (void (*)(void * , int  ))(& bfa_fcs_fabric_sm_linkdown);
  (*((fabric->lps)->sm))((void *)fabric->lps, 6);
  goto ldv_48900;
  case 2U: 
  fabric->sm = (void (*)(void * , int  ))(& bfa_fcs_fabric_sm_deleting);
  bfa_fcs_fabric_delete(fabric);
  goto ldv_48900;
  default: 
  __bfa_trc((fabric->fcs)->trcmod, __trc_fileno___6, 519, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcs.c",
         519, (unsigned int )event);
  }
  ldv_48900: ;
  return;
}
}
void bfa_fcs_fabric_sm_auth_failed(struct bfa_fcs_fabric_s *fabric , enum bfa_fcs_fabric_event event ) 
{ 


  {
  __bfa_trc((fabric->fcs)->trcmod, __trc_fileno___6, 530, fabric->bport.port_cfg.pwwn);
  __bfa_trc((fabric->fcs)->trcmod, __trc_fileno___6, 531, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 3U: 
  fabric->sm = (void (*)(void * , int  ))(& bfa_fcs_fabric_sm_linkdown);
  bfa_fcs_fabric_notify_offline(fabric);
  goto ldv_48911;
  case 2U: 
  fabric->sm = (void (*)(void * , int  ))(& bfa_fcs_fabric_sm_deleting);
  bfa_fcs_fabric_delete(fabric);
  goto ldv_48911;
  default: 
  __bfa_trc((fabric->fcs)->trcmod, __trc_fileno___6, 545, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcs.c",
         545, (unsigned int )event);
  }
  ldv_48911: ;
  return;
}
}
void bfa_fcs_fabric_sm_loopback(struct bfa_fcs_fabric_s *fabric , enum bfa_fcs_fabric_event event ) 
{ 


  {
  __bfa_trc((fabric->fcs)->trcmod, __trc_fileno___6, 556, fabric->bport.port_cfg.pwwn);
  __bfa_trc((fabric->fcs)->trcmod, __trc_fileno___6, 557, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 3U: 
  fabric->sm = (void (*)(void * , int  ))(& bfa_fcs_fabric_sm_linkdown);
  bfa_fcs_fabric_notify_offline(fabric);
  goto ldv_48919;
  case 2U: 
  fabric->sm = (void (*)(void * , int  ))(& bfa_fcs_fabric_sm_deleting);
  bfa_fcs_fabric_delete(fabric);
  goto ldv_48919;
  default: 
  __bfa_trc((fabric->fcs)->trcmod, __trc_fileno___6, 571, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcs.c",
         571, (unsigned int )event);
  }
  ldv_48919: ;
  return;
}
}
static void bfa_fcs_fabric_sm_nofabric(struct bfa_fcs_fabric_s *fabric , enum bfa_fcs_fabric_event event ) 
{ 


  {
  __bfa_trc((fabric->fcs)->trcmod, __trc_fileno___6, 582, fabric->bport.port_cfg.pwwn);
  __bfa_trc((fabric->fcs)->trcmod, __trc_fileno___6, 583, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 3U: 
  fabric->sm = (void (*)(void * , int  ))(& bfa_fcs_fabric_sm_linkdown);
  (*((fabric->lps)->sm))((void *)fabric->lps, 6);
  bfa_fcs_fabric_notify_offline(fabric);
  goto ldv_48927;
  case 2U: 
  fabric->sm = (void (*)(void * , int  ))(& bfa_fcs_fabric_sm_deleting);
  bfa_fcs_fabric_delete(fabric);
  goto ldv_48927;
  case 7U: 
  __bfa_trc((fabric->fcs)->trcmod, __trc_fileno___6, 598, (unsigned long long )fabric->bb_credit);
  bfa_fcport_set_tx_bbcredit((fabric->fcs)->bfa, (int )fabric->bb_credit);
  goto ldv_48927;
  case 6U: ;
  goto ldv_48927;
  default: 
  __bfa_trc((fabric->fcs)->trcmod, __trc_fileno___6, 607, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcs.c",
         607, (unsigned int )event);
  }
  ldv_48927: ;
  return;
}
}
void bfa_fcs_fabric_sm_online(struct bfa_fcs_fabric_s *fabric , enum bfa_fcs_fabric_event event ) 
{ 
  struct bfa_s *bfa ;
  enum bfa_port_topology tmp ;

  {
  bfa = (fabric->fcs)->bfa;
  __bfa_trc((fabric->fcs)->trcmod, __trc_fileno___6, 620, fabric->bport.port_cfg.pwwn);
  __bfa_trc((fabric->fcs)->trcmod, __trc_fileno___6, 621, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 3U: 
  fabric->sm = (void (*)(void * , int  ))(& bfa_fcs_fabric_sm_linkdown);
  tmp = bfa_fcport_get_topology(bfa);
  if ((unsigned int )tmp == 2U) {
    bfa_fcs_lport_offline(& fabric->bport);
  } else {
    (*((fabric->lps)->sm))((void *)fabric->lps, 6);
    bfa_fcs_fabric_notify_offline(fabric);
  }
  goto ldv_48938;
  case 2U: 
  fabric->sm = (void (*)(void * , int  ))(& bfa_fcs_fabric_sm_deleting);
  bfa_fcs_fabric_delete(fabric);
  goto ldv_48938;
  case 17U: 
  fabric->sm = (void (*)(void * , int  ))(& bfa_fcs_fabric_sm_stopping);
  bfa_fcs_fabric_stop(fabric);
  goto ldv_48938;
  case 12U: 
  fabric->sm = (void (*)(void * , int  ))(& bfa_fcs_fabric_sm_auth_failed);
  (*((fabric->lps)->sm))((void *)fabric->lps, 6);
  goto ldv_48938;
  case 13U: ;
  goto ldv_48938;
  default: 
  __bfa_trc((fabric->fcs)->trcmod, __trc_fileno___6, 653, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcs.c",
         653, (unsigned int )event);
  }
  ldv_48938: ;
  return;
}
}
static void bfa_fcs_fabric_sm_evfp(struct bfa_fcs_fabric_s *fabric , enum bfa_fcs_fabric_event event ) 
{ 


  {
  __bfa_trc((fabric->fcs)->trcmod, __trc_fileno___6, 664, fabric->bport.port_cfg.pwwn);
  __bfa_trc((fabric->fcs)->trcmod, __trc_fileno___6, 665, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 5U: 
  fabric->sm = (void (*)(void * , int  ))(& bfa_fcs_fabric_sm_evfp_done);
  goto ldv_48949;
  case 9U: 
  fabric->sm = (void (*)(void * , int  ))(& bfa_fcs_fabric_sm_isolated);
  goto ldv_48949;
  default: 
  __bfa_trc((fabric->fcs)->trcmod, __trc_fileno___6, 677, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcs.c",
         677, (unsigned int )event);
  }
  ldv_48949: ;
  return;
}
}
static void bfa_fcs_fabric_sm_evfp_done(struct bfa_fcs_fabric_s *fabric , enum bfa_fcs_fabric_event event ) 
{ 


  {
  __bfa_trc((fabric->fcs)->trcmod, __trc_fileno___6, 688, fabric->bport.port_cfg.pwwn);
  __bfa_trc((fabric->fcs)->trcmod, __trc_fileno___6, 689, (unsigned long long )event);
  return;
}
}
static void bfa_fcs_fabric_sm_isolated(struct bfa_fcs_fabric_s *fabric , enum bfa_fcs_fabric_event event ) 
{ 
  struct bfad_s *bfad ;
  char pwwn_ptr[32U] ;

  {
  bfad = (fabric->fcs)->bfad;
  __bfa_trc((fabric->fcs)->trcmod, __trc_fileno___6, 702, fabric->bport.port_cfg.pwwn);
  __bfa_trc((fabric->fcs)->trcmod, __trc_fileno___6, 703, (unsigned long long )event);
  wwn2str___1((char *)(& pwwn_ptr), fabric->bport.port_cfg.pwwn);
  if (bfa_log_level == 4 || (int )((signed char )*("\016" + 1)) <= 52) {
    dev_printk("\016", (struct device  const  *)(& (bfad->pcidev)->dev), "Port is isolated due to VF_ID mismatch. PWWN: %s Port VF_ID: %04x switch port VF_ID: %04x.",
               (char *)(& pwwn_ptr), (int )(fabric->fcs)->port_vfid, (int )fabric->event_arg.swp_vfid);
  } else {

  }
  return;
}
}
static void bfa_fcs_fabric_sm_deleting(struct bfa_fcs_fabric_s *fabric , enum bfa_fcs_fabric_event event ) 
{ 


  {
  __bfa_trc((fabric->fcs)->trcmod, __trc_fileno___6, 720, fabric->bport.port_cfg.pwwn);
  __bfa_trc((fabric->fcs)->trcmod, __trc_fileno___6, 721, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 14U: 
  fabric->sm = (void (*)(void * , int  ))(& bfa_fcs_fabric_sm_uninit);
  bfa_wc_down(& (fabric->fcs)->wc);
  goto ldv_48967;
  case 4U: ;
  goto ldv_48967;
  case 3U: 
  bfa_fcs_fabric_notify_offline(fabric);
  goto ldv_48967;
  default: 
  __bfa_trc((fabric->fcs)->trcmod, __trc_fileno___6, 737, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcs.c",
         737, (unsigned int )event);
  }
  ldv_48967: ;
  return;
}
}
static void bfa_fcs_fabric_sm_stopping(struct bfa_fcs_fabric_s *fabric , enum bfa_fcs_fabric_event event ) 
{ 
  struct bfa_s *bfa ;
  enum bfa_port_topology tmp ;
  enum bfa_port_topology tmp___0 ;

  {
  bfa = (fabric->fcs)->bfa;
  __bfa_trc((fabric->fcs)->trcmod, __trc_fileno___6, 750, fabric->bport.port_cfg.pwwn);
  __bfa_trc((fabric->fcs)->trcmod, __trc_fileno___6, 751, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 18U: 
  tmp = bfa_fcport_get_topology(bfa);
  if ((unsigned int )tmp == 2U) {
    fabric->sm = (void (*)(void * , int  ))(& bfa_fcs_fabric_sm_created);
  } else {
    fabric->sm = (void (*)(void * , int  ))(& bfa_fcs_fabric_sm_cleanup);
    (*((fabric->lps)->sm))((void *)fabric->lps, 2);
  }
  goto ldv_48977;
  case 4U: ;
  goto ldv_48977;
  case 3U: 
  tmp___0 = bfa_fcport_get_topology(bfa);
  if ((unsigned int )tmp___0 == 2U) {
    fabric->sm = (void (*)(void * , int  ))(& bfa_fcs_fabric_sm_created);
  } else {
    fabric->sm = (void (*)(void * , int  ))(& bfa_fcs_fabric_sm_cleanup);
  }
  goto ldv_48977;
  default: 
  __bfa_trc((fabric->fcs)->trcmod, __trc_fileno___6, 774, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcs.c",
         774, (unsigned int )event);
  }
  ldv_48977: ;
  return;
}
}
static void bfa_fcs_fabric_sm_cleanup(struct bfa_fcs_fabric_s *fabric , enum bfa_fcs_fabric_event event ) 
{ 


  {
  __bfa_trc((fabric->fcs)->trcmod, __trc_fileno___6, 785, fabric->bport.port_cfg.pwwn);
  __bfa_trc((fabric->fcs)->trcmod, __trc_fileno___6, 786, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 18U: ;
  case 19U: 
  fabric->sm = (void (*)(void * , int  ))(& bfa_fcs_fabric_sm_created);
  bfa_wc_down(& (fabric->fcs)->wc);
  goto ldv_48987;
  case 3U: ;
  goto ldv_48987;
  default: 
  __bfa_trc((fabric->fcs)->trcmod, __trc_fileno___6, 803, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcs.c",
         803, (unsigned int )event);
  }
  ldv_48987: ;
  return;
}
}
static void bfa_fcs_fabric_init(struct bfa_fcs_fabric_s *fabric ) 
{ 
  struct bfa_lport_cfg_s *port_cfg ;

  {
  port_cfg = & fabric->bport.port_cfg;
  port_cfg->roles = 1;
  port_cfg->nwwn = (((fabric->fcs)->bfa)->ioc.attr)->nwwn;
  port_cfg->pwwn = (((fabric->fcs)->bfa)->ioc.attr)->pwwn;
  return;
}
}
void bfa_fcs_fabric_psymb_init(struct bfa_fcs_fabric_s *fabric ) 
{ 
  struct bfa_lport_cfg_s *port_cfg ;
  char model[16U] ;
  unsigned int tmp ;
  struct bfa_fcs_driver_info_s *driver_info ;

  {
  port_cfg = & fabric->bport.port_cfg;
  model[0] = 0;
  tmp = 1U;
  while (1) {
    if (tmp >= 16U) {
      break;
    } else {

    }
    model[tmp] = (char)0;
    tmp = tmp + 1U;
  }
  driver_info = & (fabric->fcs)->driver_info;
  bfa_ioc_get_adapter_model(& ((fabric->fcs)->bfa)->ioc, (char *)(& model));
  strncpy((char *)(& port_cfg->sym_name), (char const   *)(& model), 16UL);
  strncat((char *)(& port_cfg->sym_name), " | ", 4UL);
  strncat((char *)(& port_cfg->sym_name), (char const   *)(& driver_info->version),
          10UL);
  strncat((char *)(& port_cfg->sym_name), " | ", 4UL);
  strncat((char *)(& port_cfg->sym_name), (char const   *)(& driver_info->host_machine_name),
          30UL);
  strncat((char *)(& port_cfg->sym_name), " | ", 4UL);
  if ((unsigned int )driver_info->host_os_patch[0] == 0U) {
    strncat((char *)(& port_cfg->sym_name), (char const   *)(& driver_info->host_os_name),
            64UL);
    strncat((char *)(& port_cfg->sym_name), " | ", 4UL);
  } else {
    strncat((char *)(& port_cfg->sym_name), (char const   *)(& driver_info->host_os_name),
            44UL);
    strncat((char *)(& port_cfg->sym_name), " | ", 4UL);
    strncat((char *)(& port_cfg->sym_name), (char const   *)(& driver_info->host_os_patch),
            16UL);
  }
  port_cfg->sym_name.symname[127] = 0;
  return;
}
}
void bfa_fcs_fabric_nsymb_init(struct bfa_fcs_fabric_s *fabric ) 
{ 
  struct bfa_lport_cfg_s *port_cfg ;
  char model[16U] ;
  unsigned int tmp ;
  struct bfa_fcs_driver_info_s *driver_info ;

  {
  port_cfg = & fabric->bport.port_cfg;
  model[0] = 0;
  tmp = 1U;
  while (1) {
    if (tmp >= 16U) {
      break;
    } else {

    }
    model[tmp] = (char)0;
    tmp = tmp + 1U;
  }
  driver_info = & (fabric->fcs)->driver_info;
  bfa_ioc_get_adapter_model(& ((fabric->fcs)->bfa)->ioc, (char *)(& model));
  strncpy((char *)(& port_cfg->node_sym_name), (char const   *)(& model), 16UL);
  strncat((char *)(& port_cfg->node_sym_name), " | ", 4UL);
  strncat((char *)(& port_cfg->node_sym_name), (char const   *)(& driver_info->version),
          10UL);
  strncat((char *)(& port_cfg->node_sym_name), " | ", 4UL);
  strncat((char *)(& port_cfg->node_sym_name), (char const   *)(& driver_info->host_machine_name),
          30UL);
  strncat((char *)(& port_cfg->node_sym_name), " | ", 4UL);
  port_cfg->node_sym_name.symname[127] = 0;
  return;
}
}
void bfa_cb_lps_flogi_comp(void *bfad , void *uarg , enum bfa_status status ) 
{ 
  struct bfa_fcs_fabric_s *fabric ;

  {
  fabric = (struct bfa_fcs_fabric_s *)uarg;
  __bfa_trc((fabric->fcs)->trcmod, __trc_fileno___6, 928, fabric->bport.port_cfg.pwwn);
  __bfa_trc((fabric->fcs)->trcmod, __trc_fileno___6, 929, (unsigned long long )status);
  switch ((unsigned int )status) {
  case 0U: 
  fabric->stats.flogi_accepts = fabric->stats.flogi_accepts + 1U;
  goto ldv_49013;
  case 134U: 
  fabric->stats.flogi_acc_err = fabric->stats.flogi_acc_err + 1U;
  (*(fabric->sm))((void *)fabric, 6);
  return;
  case 6U: ;
  switch ((unsigned int )(fabric->lps)->ext_status) {
  case 0U: 
  fabric->stats.flogi_acc_err = fabric->stats.flogi_acc_err + 1U;
  goto ldv_49017;
  case 1U: 
  fabric->stats.flogi_unknown_rsp = fabric->stats.flogi_unknown_rsp + 1U;
  goto ldv_49017;
  default: ;
  goto ldv_49017;
  }
  ldv_49017: 
  (*(fabric->sm))((void *)fabric, 6);
  return;
  case 29U: 
  fabric->stats.flogi_rejects = fabric->stats.flogi_rejects + 1U;
  (*(fabric->sm))((void *)fabric, 6);
  return;
  default: 
  fabric->stats.flogi_rsp_err = fabric->stats.flogi_rsp_err + 1U;
  (*(fabric->sm))((void *)fabric, 6);
  return;
  }
  ldv_49013: 
  fabric->bb_credit = (fabric->lps)->pr_bbcred;
  __bfa_trc((fabric->fcs)->trcmod, __trc_fileno___6, 972, (unsigned long long )fabric->bb_credit);
  if ((unsigned int )(fabric->lps)->brcd_switch == 0U) {
    fabric->fabric_name = (fabric->lps)->pr_nwwn;
  } else {

  }
  if ((unsigned int )(fabric->lps)->fport != 0U) {
    fabric->bport.pid = (fabric->lps)->lp_pid;
    fabric->is_npiv = (u8 )(fabric->lps)->npiv_en;
    fabric->is_auth = (u8 )(fabric->lps)->auth_req;
    (*(fabric->sm))((void *)fabric, 5);
  } else {
    fabric->bport.port_topo.pn2n.rem_port_wwn = (fabric->lps)->pr_pwwn;
    fabric->fab_type = 2;
    (*(fabric->sm))((void *)fabric, 7);
  }
  __bfa_trc((fabric->fcs)->trcmod, __trc_fileno___6, 995, (unsigned long long )fabric->bport.pid);
  __bfa_trc((fabric->fcs)->trcmod, __trc_fileno___6, 996, (unsigned long long )fabric->is_npiv);
  __bfa_trc((fabric->fcs)->trcmod, __trc_fileno___6, 997, (unsigned long long )fabric->is_auth);
  return;
}
}
static void bfa_fcs_fabric_login(struct bfa_fcs_fabric_s *fabric ) 
{ 
  struct bfa_s *bfa ;
  struct bfa_lport_cfg_s *pcfg ;
  u8 alpa ;
  u16 tmp ;

  {
  bfa = (fabric->fcs)->bfa;
  pcfg = & fabric->bport.port_cfg;
  alpa = 0U;
  tmp = bfa_fcport_get_maxfrsize(bfa);
  bfa_lps_flogi(fabric->lps, (void *)fabric, (int )alpa, (int )tmp, pcfg->pwwn, pcfg->nwwn,
                fabric->auth_reqd);
  fabric->stats.flogi_sent = fabric->stats.flogi_sent + 1U;
  return;
}
}
static void bfa_fcs_fabric_notify_online(struct bfa_fcs_fabric_s *fabric ) 
{ 
  struct bfa_fcs_vport_s *vport ;
  struct list_head *qe ;
  struct list_head *qen ;
  enum bfa_port_topology tmp ;

  {
  __bfa_trc((fabric->fcs)->trcmod, __trc_fileno___6, 1022, fabric->fabric_name);
  tmp = bfa_fcport_get_topology((fabric->fcs)->bfa);
  if ((unsigned int )tmp == 5U) {
    if ((unsigned int )fabric->fab_type == 1U) {
      fabric->oper_type = 5;
    } else {
      fabric->oper_type = 21;
    }
  } else {
    fabric->oper_type = 6;
  }
  fabric->stats.fabric_onlines = fabric->stats.fabric_onlines + 1U;
  bfa_fcs_lport_online(& fabric->bport);
  qe = fabric->vport_q.next;
  qen = qe->next;
  goto ldv_49035;
  ldv_49034: 
  vport = (struct bfa_fcs_vport_s *)qe;
  bfa_fcs_vport_online(vport);
  qe = qen;
  qen = qe->next;
  ldv_49035: ;
  if ((unsigned long )(& fabric->vport_q) != (unsigned long )qe) {
    goto ldv_49034;
  } else {

  }

  return;
}
}
static void bfa_fcs_fabric_notify_offline(struct bfa_fcs_fabric_s *fabric ) 
{ 
  struct bfa_fcs_vport_s *vport ;
  struct list_head *qe ;
  struct list_head *qen ;

  {
  __bfa_trc((fabric->fcs)->trcmod, __trc_fileno___6, 1044, fabric->fabric_name);
  fabric->stats.fabric_offlines = fabric->stats.fabric_offlines + 1U;
  qe = fabric->vport_q.next;
  qen = qe->next;
  goto ldv_49044;
  ldv_49043: 
  vport = (struct bfa_fcs_vport_s *)qe;
  bfa_fcs_vport_offline(vport);
  qe = qen;
  qen = qe->next;
  ldv_49044: ;
  if ((unsigned long )(& fabric->vport_q) != (unsigned long )qe) {
    goto ldv_49043;
  } else {

  }
  bfa_fcs_lport_offline(& fabric->bport);
  fabric->fabric_name = 0ULL;
  fabric->fabric_ip_addr[0] = 0U;
  return;
}
}
static void bfa_fcs_fabric_delay(void *cbarg ) 
{ 
  struct bfa_fcs_fabric_s *fabric ;

  {
  fabric = (struct bfa_fcs_fabric_s *)cbarg;
  (*(fabric->sm))((void *)fabric, 11);
  return;
}
}
static void bfa_fcs_fabric_stop(struct bfa_fcs_fabric_s *fabric ) 
{ 
  struct bfa_fcs_vport_s *vport ;
  struct list_head *qe ;
  struct list_head *qen ;

  {
  bfa_wc_init(& fabric->stop_wc, & bfa_fcs_fabric_stop_comp, (void *)fabric);
  qe = fabric->vport_q.next;
  qen = qe->next;
  goto ldv_49057;
  ldv_49056: 
  vport = (struct bfa_fcs_vport_s *)qe;
  bfa_wc_up(& fabric->stop_wc);
  bfa_fcs_vport_fcs_stop(vport);
  qe = qen;
  qen = qe->next;
  ldv_49057: ;
  if ((unsigned long )(& fabric->vport_q) != (unsigned long )qe) {
    goto ldv_49056;
  } else {

  }
  bfa_wc_up(& fabric->stop_wc);
  bfa_fcs_lport_stop(& fabric->bport);
  bfa_wc_wait(& fabric->stop_wc);
  return;
}
}
static void bfa_fcs_fabric_delete(struct bfa_fcs_fabric_s *fabric ) 
{ 
  struct bfa_fcs_vport_s *vport ;
  struct list_head *qe ;
  struct list_head *qen ;

  {
  qe = fabric->vport_q.next;
  qen = qe->next;
  goto ldv_49066;
  ldv_49065: 
  vport = (struct bfa_fcs_vport_s *)qe;
  bfa_fcs_vport_fcs_delete(vport);
  qe = qen;
  qen = qe->next;
  ldv_49066: ;
  if ((unsigned long )(& fabric->vport_q) != (unsigned long )qe) {
    goto ldv_49065;
  } else {

  }
  bfa_fcs_lport_delete(& fabric->bport);
  bfa_wc_wait(& fabric->wc);
  return;
}
}
static void bfa_fcs_fabric_delete_comp(void *cbarg ) 
{ 
  struct bfa_fcs_fabric_s *fabric ;

  {
  fabric = (struct bfa_fcs_fabric_s *)cbarg;
  (*(fabric->sm))((void *)fabric, 14);
  return;
}
}
static void bfa_fcs_fabric_stop_comp(void *cbarg ) 
{ 
  struct bfa_fcs_fabric_s *fabric ;

  {
  fabric = (struct bfa_fcs_fabric_s *)cbarg;
  (*(fabric->sm))((void *)fabric, 18);
  return;
}
}
void bfa_fcs_fabric_attach(struct bfa_fcs_s *fcs ) 
{ 
  struct bfa_fcs_fabric_s *fabric ;
  int __ret_warn_on ;
  long tmp ;

  {
  fabric = & fcs->fabric;
  memset((void *)fabric, 0, 1744UL);
  fabric->fcs = fcs;
  INIT_LIST_HEAD(& fabric->vport_q);
  INIT_LIST_HEAD(& fabric->vf_q);
  fabric->lps = bfa_lps_alloc(fcs->bfa);
  __ret_warn_on = (unsigned long )fabric->lps == (unsigned long )((struct bfa_lps_s *)0);
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcs.c",
                       1147);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  bfa_wc_init(& fabric->wc, & bfa_fcs_fabric_delete_comp, (void *)fabric);
  bfa_wc_up(& fabric->wc);
  fabric->sm = (void (*)(void * , int  ))(& bfa_fcs_fabric_sm_uninit);
  bfa_fcs_lport_attach(& fabric->bport, fabric->fcs, 0, (struct bfa_fcs_vport_s *)0);
  return;
}
}
void bfa_fcs_fabric_modinit(struct bfa_fcs_s *fcs ) 
{ 


  {
  (*(fcs->fabric.sm))((void *)(& fcs->fabric), 1);
  __bfa_trc(fcs->trcmod, __trc_fileno___6, 1164, 0ULL);
  return;
}
}
void bfa_fcs_fabric_modexit(struct bfa_fcs_s *fcs ) 
{ 
  struct bfa_fcs_fabric_s *fabric ;

  {
  __bfa_trc(fcs->trcmod, __trc_fileno___6, 1175, 0ULL);
  fabric = & fcs->fabric;
  bfa_lps_delete(fabric->lps);
  (*(fabric->sm))((void *)fabric, 2);
  return;
}
}
void bfa_fcs_fabric_modstop(struct bfa_fcs_s *fcs ) 
{ 
  struct bfa_fcs_fabric_s *fabric ;

  {
  __bfa_trc(fcs->trcmod, __trc_fileno___6, 1193, 0ULL);
  fabric = & fcs->fabric;
  (*(fabric->sm))((void *)fabric, 17);
  return;
}
}
void bfa_fcs_fabric_modstart(struct bfa_fcs_s *fcs ) 
{ 
  struct bfa_fcs_fabric_s *fabric ;

  {
  __bfa_trc(fcs->trcmod, __trc_fileno___6, 1206, 0ULL);
  fabric = & fcs->fabric;
  (*(fabric->sm))((void *)fabric, 16);
  return;
}
}
void bfa_fcs_fabric_link_up(struct bfa_fcs_fabric_s *fabric ) 
{ 


  {
  __bfa_trc((fabric->fcs)->trcmod, __trc_fileno___6, 1218, fabric->bport.port_cfg.pwwn);
  (*(fabric->sm))((void *)fabric, 4);
  return;
}
}
void bfa_fcs_fabric_link_down(struct bfa_fcs_fabric_s *fabric ) 
{ 


  {
  __bfa_trc((fabric->fcs)->trcmod, __trc_fileno___6, 1228, fabric->bport.port_cfg.pwwn);
  (*(fabric->sm))((void *)fabric, 3);
  return;
}
}
void bfa_fcs_fabric_addvport(struct bfa_fcs_fabric_s *fabric , struct bfa_fcs_vport_s *vport ) 
{ 


  {
  __bfa_trc((fabric->fcs)->trcmod, __trc_fileno___6, 1250, (unsigned long long )fabric->vf_id);
  list_add_tail(& vport->qe, & fabric->vport_q);
  fabric->num_vports = (u16 )((int )fabric->num_vports + 1);
  bfa_wc_up(& fabric->wc);
  return;
}
}
void bfa_fcs_fabric_delvport(struct bfa_fcs_fabric_s *fabric , struct bfa_fcs_vport_s *vport ) 
{ 


  {
  list_del(& vport->qe);
  fabric->num_vports = (u16 )((int )fabric->num_vports - 1);
  bfa_wc_down(& fabric->wc);
  return;
}
}
struct bfa_fcs_vport_s *bfa_fcs_fabric_vport_lookup(struct bfa_fcs_fabric_s *fabric ,
                                                    wwn_t pwwn ) 
{ 
  struct bfa_fcs_vport_s *vport ;
  struct list_head *qe ;

  {
  qe = fabric->vport_q.next;
  goto ldv_49118;
  ldv_49117: 
  vport = (struct bfa_fcs_vport_s *)qe;
  if (vport->lport.port_cfg.pwwn == pwwn) {
    return (vport);
  } else {

  }
  qe = qe->next;
  ldv_49118: ;
  if ((unsigned long )(& fabric->vport_q) != (unsigned long )qe) {
    goto ldv_49117;
  } else {

  }

  return ((struct bfa_fcs_vport_s *)0);
}
}
u16 bfa_fcs_fabric_get_switch_oui(struct bfa_fcs_fabric_s *fabric ) 
{ 
  wwn_t fab_nwwn ;
  u8 *tmp ;
  u16 oui ;

  {
  fab_nwwn = (fabric->lps)->pr_nwwn;
  tmp = (u8 *)(& fab_nwwn);
  oui = (u16 )((int )((short )((int )*(tmp + 3UL) << 8)) | (int )((short )*(tmp + 4UL)));
  return (oui);
}
}
void bfa_fcs_fabric_uf_recv(struct bfa_fcs_fabric_s *fabric , struct fchs_s *fchs ,
                            u16 len ) 
{ 
  u32 pid ;
  struct bfa_fcs_vport_s *vport ;
  struct list_head *qe ;
  struct fc_els_cmd_s *els_cmd ;
  struct fc_logi_s *flogi ;

  {
  pid = fchs->d_id;
  els_cmd = (struct fc_els_cmd_s *)fchs + 1U;
  flogi = (struct fc_logi_s *)els_cmd;
  __bfa_trc((fabric->fcs)->trcmod, __trc_fileno___6, 1329, (unsigned long long )len);
  __bfa_trc((fabric->fcs)->trcmod, __trc_fileno___6, 1330, (unsigned long long )pid);
  if ((pid == 16711679U && (unsigned int )els_cmd->els_code == 4U) && flogi->port_name == fabric->bport.port_cfg.pwwn) {
    (*(fabric->sm))((void *)fabric, 15);
    return;
  } else {

  }
  if (fchs->d_id == 16711679U) {
    __bfa_trc((fabric->fcs)->trcmod, __trc_fileno___6, 1348, (unsigned long long )pid);
    bfa_fcs_fabric_process_uf(fabric, fchs, (int )len);
    return;
  } else {

  }
  if (fabric->bport.pid == pid) {
    __bfa_trc((fabric->fcs)->trcmod, __trc_fileno___6, 1357, (unsigned long long )els_cmd->els_code);
    if ((unsigned int )els_cmd->els_code == 144U) {
      __bfa_trc((fabric->fcs)->trcmod, __trc_fileno___6, 1359, (unsigned long long )els_cmd->els_code);
      return;
    } else {

    }
    __bfa_trc((fabric->fcs)->trcmod, __trc_fileno___6, 1363, (unsigned long long )*((u8 *)fchs));
    bfa_fcs_lport_uf_recv(& fabric->bport, fchs, (int )len);
    return;
  } else {

  }
  qe = fabric->vport_q.next;
  goto ldv_49137;
  ldv_49136: 
  vport = (struct bfa_fcs_vport_s *)qe;
  if (vport->lport.pid == pid) {
    bfa_fcs_lport_uf_recv(& vport->lport, fchs, (int )len);
    return;
  } else {

  }
  qe = qe->next;
  ldv_49137: ;
  if ((unsigned long )(& fabric->vport_q) != (unsigned long )qe) {
    goto ldv_49136;
  } else {

  }

  if ((unsigned int )fabric->fab_type != 1U) {
    bfa_fcs_lport_uf_recv(& fabric->bport, fchs, (int )len);
  } else {

  }
  __bfa_trc((fabric->fcs)->trcmod, __trc_fileno___6, 1382, (unsigned long long )fchs->type);
  return;
}
}
static void bfa_fcs_fabric_process_uf(struct bfa_fcs_fabric_s *fabric , struct fchs_s *fchs ,
                                      u16 len ) 
{ 
  struct fc_els_cmd_s *els_cmd ;

  {
  els_cmd = (struct fc_els_cmd_s *)fchs + 1U;
  __bfa_trc((fabric->fcs)->trcmod, __trc_fileno___6, 1394, (unsigned long long )els_cmd->els_code);
  switch ((int )els_cmd->els_code) {
  case 4: 
  bfa_fcs_fabric_process_flogi(fabric, fchs, (int )len);
  goto ldv_49146;
  default: ;
  goto ldv_49146;
  }
  ldv_49146: ;
  return;
}
}
static void bfa_fcs_fabric_process_flogi(struct bfa_fcs_fabric_s *fabric , struct fchs_s *fchs ,
                                         u16 len ) 
{ 
  struct fc_logi_s *flogi ;
  struct bfa_fcs_lport_s *bport ;
  __u16 tmp ;

  {
  flogi = (struct fc_logi_s *)fchs + 1U;
  bport = & fabric->bport;
  __bfa_trc((fabric->fcs)->trcmod, __trc_fileno___6, 1419, (unsigned long long )fchs->s_id);
  fabric->stats.flogi_rcvd = fabric->stats.flogi_rcvd + 1U;
  if ((unsigned int )*((unsigned char *)flogi + 8UL) != 0U) {
    __bfa_trc((fabric->fcs)->trcmod, __trc_fileno___6, 1429, flogi->port_name);
    fabric->stats.flogi_rejected = fabric->stats.flogi_rejected + 1U;
    return;
  } else {

  }
  tmp = __fswab16((int )flogi->csp.bbcred);
  fabric->bb_credit = tmp;
  bport->port_topo.pn2n.rem_port_wwn = flogi->port_name;
  bport->port_topo.pn2n.reply_oxid = fchs->ox_id;
  bfa_fcs_fabric_send_flogi_acc(fabric);
  (*(fabric->sm))((void *)fabric, 7);
  return;
}
}
static void bfa_fcs_fabric_send_flogi_acc(struct bfa_fcs_fabric_s *fabric ) 
{ 
  struct bfa_lport_cfg_s *pcfg ;
  struct bfa_fcs_lport_n2n_s *n2n_port ;
  struct bfa_s *bfa ;
  struct bfa_fcxp_s *fcxp ;
  u16 reqlen ;
  struct fchs_s fchs ;
  u8 tmp ;
  u16 tmp___0 ;
  void *tmp___1 ;

  {
  pcfg = & fabric->bport.port_cfg;
  n2n_port = & fabric->bport.port_topo.pn2n;
  bfa = (fabric->fcs)->bfa;
  fcxp = bfa_fcxp_req_rsp_alloc((void *)0, (fabric->fcs)->bfa, 0, 0, (u64 (*)(void * ,
                                                                              int  ))0,
                                (u32 (*)(void * , int  ))0, (u64 (*)(void * , int  ))0,
                                (u32 (*)(void * , int  ))0, 0);
  if ((unsigned long )fcxp == (unsigned long )((struct bfa_fcxp_s *)0)) {
    return;
  } else {

  }
  tmp = bfa_fcport_get_rx_bbcredit(bfa);
  tmp___0 = bfa_fcport_get_maxfrsize(bfa);
  tmp___1 = bfa_fcxp_get_reqbuf(fcxp);
  reqlen = fc_flogi_acc_build(& fchs, (struct fc_logi_s *)tmp___1, 16711679U, (int )n2n_port->reply_oxid,
                              pcfg->pwwn, pcfg->nwwn, (int )tmp___0, (int )tmp, 0);
  bfa_fcxp_send(fcxp, (struct bfa_rport_s *)0, (int )fabric->vf_id, (int )(fabric->lps)->bfa_tag,
                0, 8, (u32 )reqlen, & fchs, & bfa_fcs_fabric_flogiacc_comp, (void *)fabric,
                2112U, 0);
  return;
}
}
static void bfa_fcs_fabric_flogiacc_comp(void *fcsarg , struct bfa_fcxp_s *fcxp ,
                                         void *cbarg , enum bfa_status status , u32 rsp_len ,
                                         u32 resid_len , struct fchs_s *rspfchs ) 
{ 
  struct bfa_fcs_fabric_s *fabric ;

  {
  fabric = (struct bfa_fcs_fabric_s *)cbarg;
  __bfa_trc((fabric->fcs)->trcmod, __trc_fileno___6, 1485, (unsigned long long )status);
  return;
}
}
static void bfa_fcs_fabric_aen_post(struct bfa_fcs_lport_s *port , enum bfa_port_aen_event event ) 
{ 
  struct bfad_s *bfad ;
  struct bfa_aen_entry_s *aen_entry ;
  unsigned long _flags ;
  raw_spinlock_t *tmp ;
  int tmp___0 ;

  {
  bfad = ((port->fabric)->fcs)->bfad;
  tmp = spinlock_check(& bfad->bfad_aen_spinlock);
  _flags = _raw_spin_lock_irqsave(tmp);
  tmp___0 = list_empty((struct list_head  const  *)(& bfad->free_aen_q));
  if (tmp___0 == 0) {
    *((struct list_head **)(& aen_entry)) = bfad->free_aen_q.next;
    ((*((struct list_head **)(& aen_entry)))->next)->prev = & bfad->free_aen_q;
    bfad->free_aen_q.next = (*((struct list_head **)(& aen_entry)))->next;
  } else {
    *((struct list_head **)(& aen_entry)) = (struct list_head *)0;
  }
  if ((unsigned long )aen_entry != (unsigned long )((struct bfa_aen_entry_s *)0)) {
    list_add_tail(& aen_entry->qe, & bfad->active_aen_q);
  } else {

  }
  spin_unlock_irqrestore(& bfad->bfad_aen_spinlock, _flags);
  if ((unsigned long )aen_entry == (unsigned long )((struct bfa_aen_entry_s *)0)) {
    return;
  } else {

  }
  aen_entry->aen_data.port.pwwn = port->port_cfg.pwwn;
  aen_entry->aen_data.port.fwwn = (port->fabric)->fabric_name;
  do_gettimeofday(& aen_entry->aen_tv);
  aen_entry->bfad_num = bfad->inst_no;
  (port->fcs)->fcs_aen_seq = (port->fcs)->fcs_aen_seq + 1;
  aen_entry->seq_num = (u32 )(port->fcs)->fcs_aen_seq;
  aen_entry->aen_category = 2;
  aen_entry->aen_type = (u32 )event;
  if ((bfad->bfad_flags & 512U) != 0U) {
    queue_work___1((bfad->im)->drv_workq, & (bfad->im)->aen_im_notify_work);
  } else {

  }
  return;
}
}
void bfa_fcs_fabric_set_fabric_name(struct bfa_fcs_fabric_s *fabric , wwn_t fabric_name ) 
{ 
  struct bfad_s *bfad ;
  char pwwn_ptr[32U] ;
  char fwwn_ptr[32U] ;

  {
  bfad = (fabric->fcs)->bfad;
  __bfa_trc((fabric->fcs)->trcmod, __trc_fileno___6, 1526, fabric_name);
  if (fabric->fabric_name == 0ULL) {
    fabric->fabric_name = fabric_name;
  } else {
    fabric->fabric_name = fabric_name;
    wwn2str___1((char *)(& pwwn_ptr), fabric->bport.port_cfg.pwwn);
    wwn2str___1((char *)(& fwwn_ptr), (fabric->bport.fabric)->fabric_name);
    if (bfa_log_level == 4 || (int )((signed char )*("\f" + 1)) <= 52) {
      dev_printk("\f", (struct device  const  *)(& (bfad->pcidev)->dev), "Base port WWN = %s Fabric WWN = %s\n",
                 (char *)(& pwwn_ptr), (char *)(& fwwn_ptr));
    } else {

    }
    bfa_fcs_fabric_aen_post(& fabric->bport, 13);
  }
  return;
}
}
void bfa_cb_lps_flogo_comp(void *bfad , void *uarg ) 
{ 
  struct bfa_fcs_fabric_s *fabric ;

  {
  fabric = (struct bfa_fcs_fabric_s *)uarg;
  (*(fabric->sm))((void *)fabric, 19);
  return;
}
}
struct bfa_fcs_fabric_s *bfa_fcs_vf_lookup(struct bfa_fcs_s *fcs , u16 vf_id ) 
{ 


  {
  __bfa_trc(fcs->trcmod, __trc_fileno___6, 1565, (unsigned long long )vf_id);
  if ((unsigned int )vf_id == 0U) {
    return (& fcs->fabric);
  } else {

  }
  return ((struct bfa_fcs_fabric_s *)0);
}
}
void bfa_fcs_vf_get_ports(struct bfa_fcs_fabric_s *vf , wwn_t *lpwwn , int *nlports ) 
{ 
  struct list_head *qe ;
  struct bfa_fcs_vport_s *vport ;
  int i ;
  struct bfa_fcs_s *fcs ;
  int tmp ;
  int tmp___0 ;

  {
  i = 0;
  if (((unsigned long )vf == (unsigned long )((struct bfa_fcs_fabric_s *)0) || (unsigned long )lpwwn == (unsigned long )((wwn_t *)0ULL)) || *nlports == 0) {
    return;
  } else {

  }
  fcs = vf->fcs;
  __bfa_trc(fcs->trcmod, __trc_fileno___6, 1594, (unsigned long long )vf->vf_id);
  __bfa_trc(fcs->trcmod, __trc_fileno___6, 1595, (unsigned long long )((unsigned int )*nlports));
  tmp = i;
  i = i + 1;
  *(lpwwn + (unsigned long )tmp) = vf->bport.port_cfg.pwwn;
  qe = vf->vport_q.next;
  goto ldv_49211;
  ldv_49210: ;
  if (*nlports <= i) {
    goto ldv_49209;
  } else {

  }
  vport = (struct bfa_fcs_vport_s *)qe;
  tmp___0 = i;
  i = i + 1;
  *(lpwwn + (unsigned long )tmp___0) = vport->lport.port_cfg.pwwn;
  qe = qe->next;
  ldv_49211: ;
  if ((unsigned long )(& vf->vport_q) != (unsigned long )qe) {
    goto ldv_49210;
  } else {

  }
  ldv_49209: 
  __bfa_trc(fcs->trcmod, __trc_fileno___6, 1607, (unsigned long long )i);
  *nlports = i;
  return;
}
}
static void bfa_fcs_port_event_handler(void *cbarg , enum bfa_port_linkstate event ) 
{ 
  struct bfa_fcs_s *fcs ;
  int __ret_warn_on ;
  long tmp ;

  {
  fcs = (struct bfa_fcs_s *)cbarg;
  __bfa_trc(fcs->trcmod, __trc_fileno___6, 1619, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 1U: 
  bfa_fcs_fabric_link_up(& fcs->fabric);
  goto ldv_49218;
  case 2U: 
  bfa_fcs_fabric_link_down(& fcs->fabric);
  goto ldv_49218;
  default: 
  __ret_warn_on = 1;
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcs.c",
                       1631);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  }
  ldv_49218: ;
  return;
}
}
void bfa_fcs_port_attach(struct bfa_fcs_s *fcs ) 
{ 


  {
  bfa_fcport_event_register(fcs->bfa, & bfa_fcs_port_event_handler, (void *)fcs);
  return;
}
}
static void bfa_fcs_uf_recv(void *cbarg , struct bfa_uf_s *uf ) 
{ 
  struct bfa_fcs_s *fcs ;
  struct fchs_s *fchs ;
  void *tmp ;
  u16 len ;
  u16 tmp___0 ;
  struct fc_vft_s *vft ;
  struct bfa_fcs_fabric_s *fabric ;
  void *tmp___1 ;
  int __ret_warn_on ;
  long tmp___2 ;

  {
  fcs = (struct bfa_fcs_s *)cbarg;
  tmp = bfa_uf_get_frmbuf(uf);
  fchs = (struct fchs_s *)tmp;
  tmp___0 = bfa_uf_get_frmlen(uf);
  len = tmp___0;
  if ((unsigned int )*((unsigned char *)fchs + 0UL) == 80U && (unsigned int )*((unsigned char *)fchs + 0UL) == 0U) {
    fcs->stats.uf.tagged = fcs->stats.uf.tagged + 1U;
    tmp___1 = bfa_uf_get_frmbuf(uf);
    vft = (struct fc_vft_s *)tmp___1;
    if ((int )fcs->port_vfid == (int )vft->vf_id) {
      fabric = & fcs->fabric;
    } else {
      fabric = bfa_fcs_vf_lookup(fcs, (int )vft->vf_id);
    }
    if ((unsigned long )fabric == (unsigned long )((struct bfa_fcs_fabric_s *)0)) {
      __ret_warn_on = 1;
      tmp___2 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
      if (tmp___2 != 0L) {
        warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcs.c",
                           1678);
      } else {

      }
      ldv__builtin_expect(__ret_warn_on != 0, 0L);
      fcs->stats.uf.vfid_unknown = fcs->stats.uf.vfid_unknown + 1U;
      bfa_uf_free(uf);
      return;
    } else {

    }
    fchs = (struct fchs_s *)vft + 1U;
    len = (unsigned int )len - 8U;
    __bfa_trc(fcs->trcmod, __trc_fileno___6, 1690, (unsigned long long )vft->vf_id);
  } else {
    fcs->stats.uf.untagged = fcs->stats.uf.untagged + 1U;
    fabric = & fcs->fabric;
  }
  __bfa_trc(fcs->trcmod, __trc_fileno___6, 1696, (unsigned long long )*((u32 *)fchs));
  __bfa_trc(fcs->trcmod, __trc_fileno___6, 1697, (unsigned long long )*((u32 *)fchs + 1UL));
  __bfa_trc(fcs->trcmod, __trc_fileno___6, 1698, (unsigned long long )*((u32 *)fchs + 2UL));
  __bfa_trc(fcs->trcmod, __trc_fileno___6, 1699, (unsigned long long )*((u32 *)fchs + 3UL));
  __bfa_trc(fcs->trcmod, __trc_fileno___6, 1700, (unsigned long long )*((u32 *)fchs + 4UL));
  __bfa_trc(fcs->trcmod, __trc_fileno___6, 1701, (unsigned long long )*((u32 *)fchs + 5UL));
  __bfa_trc(fcs->trcmod, __trc_fileno___6, 1702, (unsigned long long )len);
  bfa_fcs_fabric_uf_recv(fabric, fchs, (int )len);
  bfa_uf_free(uf);
  return;
}
}
void bfa_fcs_uf_attach(struct bfa_fcs_s *fcs ) 
{ 


  {
  bfa_uf_recv_register(fcs->bfa, & bfa_fcs_uf_recv, (void *)fcs);
  return;
}
}
bool ldv_queue_work_on_387(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_3(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_delayed_work_on_388(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_3(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_work_on_389(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_3(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
void ldv_flush_workqueue_390(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
  flush_workqueue(ldv_func_arg1);
  call_and_disable_all_3(2);
  return;
}
}
bool ldv_queue_delayed_work_on_391(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_3(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
void ldv_mutex_lock_392(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_lock_lock(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_393(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_unlock_lock(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_394(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
int ldv_mutex_trylock_395(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
  tmp = mutex_trylock(ldv_func_arg1);
  ldv_func_res = tmp;
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
  return (tmp___0);
  return (ldv_func_res);
}
}
void ldv_mutex_unlock_396(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_397(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_unlock_i_mutex_of_inode(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_398(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_lock_i_mutex_of_inode(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
int ldv_scsi_add_host_with_dma_399(struct Scsi_Host *shost , struct device *dev ,
                                   struct device *dma_dev ) 
{ 
  ldv_func_ret_type___4 ldv_func_res ;
  int tmp ;

  {
  tmp = scsi_add_host_with_dma(shost, dev, dma_dev);
  ldv_func_res = tmp;
  if (ldv_func_res == 0) {
    ldv_state_variable_35 = 1;
    ldv_initialize_scsi_host_template_35();
  } else {

  }
  return (ldv_func_res);
}
}
__inline static long ldv__builtin_expect(long exp , long c ) ;
extern int memcmp(void const   * , void const   * , size_t  ) ;
extern int strncmp(char const   * , char const   * , __kernel_size_t  ) ;
int ldv_mutex_trylock_425(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_423(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_426(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_427(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_422(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_424(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_428(struct mutex *ldv_func_arg1 ) ;
bool ldv_queue_work_on_417(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_work_on_419(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_delayed_work_on_418(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
bool ldv_queue_delayed_work_on_421(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
void ldv_flush_workqueue_420(struct workqueue_struct *ldv_func_arg1 ) ;
__inline static bool queue_work___2(struct workqueue_struct *wq , struct work_struct *work ) 
{ 
  bool tmp ;

  {
  tmp = ldv_queue_work_on_417(8192, wq, work);
  return (tmp);
}
}
int ldv_scsi_add_host_with_dma_429(struct Scsi_Host *shost , struct device *dev ,
                                   struct device *dma_dev ) ;
__inline static void wwn2str___2(char *wwn_str , u64 wwn ) 
{ 
  union __anonunion_w_281___1 w ;

  {
  w.wwn = wwn;
  sprintf(wwn_str, "%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x", (int )w.byte[0], (int )w.byte[1],
          (int )w.byte[2], (int )w.byte[3], (int )w.byte[4], (int )w.byte[5], (int )w.byte[6],
          (int )w.byte[7]);
  return;
}
}
enum bfa_port_speed bfa_fcport_get_ratelim_speed(struct bfa_s *bfa ) ;
enum bfa_boolean bfa_fcport_is_ratelim(struct bfa_s *bfa ) ;
void bfa_fcxp_req_rsp_alloc_wait(struct bfa_s *bfa , struct bfa_fcxp_wqe_s *wqe ,
                                 void (*alloc_cbfn)(void * , struct bfa_fcxp_s * ) ,
                                 void *alloc_cbarg , void *caller , int nreq_sgles ,
                                 int nrsp_sgles , u64 (*req_sga_cbfn)(void * , int  ) ,
                                 u32 (*req_sglen_cbfn)(void * , int  ) , u64 (*rsp_sga_cbfn)(void * ,
                                                                                             int  ) ,
                                 u32 (*rsp_sglen_cbfn)(void * , int  ) , enum bfa_boolean req ) ;
void bfa_fcxp_walloc_cancel(struct bfa_s *bfa , struct bfa_fcxp_wqe_s *wqe ) ;
void bfa_fcxp_discard(struct bfa_fcxp_s *fcxp ) ;
void *bfa_fcxp_get_rspbuf(struct bfa_fcxp_s *fcxp ) ;
u32 bfa_fcxp_get_maxrsp(struct bfa_s *bfa ) ;
void bfa_lps_fdisc(struct bfa_lps_s *lps , void *uarg , u16 pdusz , wwn_t pwwn , wwn_t nwwn ) ;
void bfa_lps_fdisclogo(struct bfa_lps_s *lps ) ;
void bfa_lps_set_n2n_pid(struct bfa_lps_s *lps , unsigned int n2n_pid ) ;
void bfa_cb_lps_fdisc_comp(void *bfad , void *uarg , enum bfa_status status ) ;
void bfa_cb_lps_fdisclogo_comp(void *bfad , void *uarg ) ;
void bfa_cb_lps_cvl_event(void *bfad , void *uarg ) ;
struct bfa_fcs_lport_s *bfa_fcs_get_base_port(struct bfa_fcs_s *fcs ) ;
wwn_t bfa_fcs_lport_get_rport(struct bfa_fcs_lport_s *port , wwn_t wwn , int index ,
                              int nrports , enum bfa_boolean bwwn ) ;
void bfa_fcs_lport_get_info(struct bfa_fcs_lport_s *port , struct bfa_lport_info_s *port_info ) ;
enum bfa_port_speed bfa_fcs_lport_get_rport_max_speed(struct bfa_fcs_lport_s *port ) ;
void bfa_fcs_lport_ms_init(struct bfa_fcs_lport_s *port ) ;
void bfa_fcs_lport_ms_offline(struct bfa_fcs_lport_s *port ) ;
void bfa_fcs_lport_ms_online(struct bfa_fcs_lport_s *port ) ;
void bfa_fcs_lport_ms_fabric_rscn(struct bfa_fcs_lport_s *port ) ;
void bfa_fcs_lport_fdmi_init(struct bfa_fcs_lport_ms_s *ms ) ;
void bfa_fcs_lport_fdmi_offline(struct bfa_fcs_lport_ms_s *ms ) ;
void bfa_fcs_lport_fdmi_online(struct bfa_fcs_lport_ms_s *ms ) ;
struct bfa_fcs_rport_s *bfa_fcs_lport_get_rport_by_pid(struct bfa_fcs_lport_s *port ,
                                                       u32 pid ) ;
struct bfa_fcs_rport_s *bfa_fcs_lport_get_rport_by_old_pid(struct bfa_fcs_lport_s *port ,
                                                           u32 pid ) ;
struct bfa_fcs_rport_s *bfa_fcs_lport_get_rport_by_nwwn(struct bfa_fcs_lport_s *port ,
                                                        wwn_t nwwn ) ;
void bfa_fcs_lport_add_rport(struct bfa_fcs_lport_s *port , struct bfa_fcs_rport_s *rport ) ;
void bfa_fcs_lport_del_rport(struct bfa_fcs_lport_s *port , struct bfa_fcs_rport_s *rport ) ;
void bfa_fcs_lport_ns_init(struct bfa_fcs_lport_s *port ) ;
void bfa_fcs_lport_ns_offline(struct bfa_fcs_lport_s *port ) ;
void bfa_fcs_lport_ns_online(struct bfa_fcs_lport_s *port ) ;
void bfa_fcs_lport_ns_query(struct bfa_fcs_lport_s *port ) ;
void bfa_fcs_lport_ns_util_send_rspn_id(void *cbarg , struct bfa_fcxp_s *fcxp_alloced ) ;
void bfa_fcs_lport_scn_init(struct bfa_fcs_lport_s *port ) ;
void bfa_fcs_lport_scn_offline(struct bfa_fcs_lport_s *port ) ;
void bfa_fcs_lport_fab_scn_online(struct bfa_fcs_lport_s *port ) ;
void bfa_fcs_lport_scn_process_rscn(struct bfa_fcs_lport_s *port , struct fchs_s *fchs ,
                                    u32 len ) ;
void bfa_fcs_lport_lip_scn_online(struct bfa_fcs_lport_s *port ) ;
enum bfa_boolean bfa_fcs_is_pbc_vport(struct bfa_fcs_vport_s *vport ) ;
void bfa_fcs_vport_cleanup(struct bfa_fcs_vport_s *vport ) ;
void bfa_fcs_vport_delete_comp(struct bfa_fcs_vport_s *vport ) ;
void bfa_fcs_vport_stop_comp(struct bfa_fcs_vport_s *vport ) ;
void bfa_fcs_rport_uf_recv(struct bfa_fcs_rport_s *rport , struct fchs_s *fchs , u16 len ) ;
void bfa_fcs_rport_scn(struct bfa_fcs_rport_s *rport ) ;
struct bfa_fcs_rport_s *bfa_fcs_rport_create(struct bfa_fcs_lport_s *port , u32 rpid ) ;
void bfa_fcs_rport_plogi_create(struct bfa_fcs_lport_s *port , struct fchs_s *fchs ,
                                struct fc_logi_s *plogi ) ;
void bfa_fcs_rport_plogi(struct bfa_fcs_rport_s *rport , struct fchs_s *rx_fchs ,
                         struct fc_logi_s *plogi ) ;
int bfa_fcs_rport_get_state(struct bfa_fcs_rport_s *rport ) ;
struct bfa_fcs_rport_s *bfa_fcs_rport_create_by_wwn(struct bfa_fcs_lport_s *port ,
                                                    wwn_t rpwwn ) ;
__inline static u32 fc_get_ctresp_pyld_len(u32 resp_len ) 
{ 


  {
  return (resp_len - 16U);
}
}
u16 fc_plogi_build(struct fchs_s *fchs , void *pld , u32 d_id , u32 s_id , u16 ox_id ,
                   wwn_t port_name , wwn_t node_name , u16 pdu_size , u16 bb_cr ) ;
enum fc_parse_status fc_plogi_parse(struct fchs_s *fchs ) ;
u16 fc_rspnid_build(struct fchs_s *fchs , void *pyld , u32 s_id , u16 ox_id , u8 *name ) ;
u16 fc_rsnn_nn_build(struct fchs_s *fchs , void *pyld , u32 s_id , wwn_t node_name ,
                     u8 *name ) ;
u16 fc_rftid_build(struct fchs_s *fchs , void *pyld , u32 s_id , u16 ox_id , enum bfa_lport_role roles ) ;
u16 fc_rffid_build(struct fchs_s *fchs , void *pyld , u32 s_id , u16 ox_id , u8 fc4_type ,
                   u8 fc4_ftrs ) ;
u16 fc_gs_rjt_build(struct fchs_s *fchs , struct ct_hdr_s *cthdr , u32 d_id , u32 s_id ,
                    u16 ox_id , u8 reason_code , u8 reason_code_expl ) ;
u16 fc_scr_build(struct fchs_s *fchs , struct fc_scr_s *scr , u8 set_br_reg , u32 s_id ,
                 u16 ox_id ) ;
u16 fc_ls_rjt_build(struct fchs_s *fchs , struct fc_ls_rjt_s *ls_rjt , u32 d_id ,
                    u32 s_id , __be16 ox_id , u8 reason_code , u8 reason_code_expl ) ;
u16 fc_ls_acc_build(struct fchs_s *fchs , struct fc_els_cmd_s *els_cmd , u32 d_id ,
                    u32 s_id , __be16 ox_id ) ;
u16 fc_rnid_acc_build(struct fchs_s *fchs , struct fc_rnid_acc_s *rnid_acc , u32 d_id ,
                      u32 s_id , __be16 ox_id , u32 data_format , struct fc_rnid_common_id_data_s *common_id_data ,
                      struct fc_rnid_general_topology_data_s *gen_topo_data ) ;
u16 fc_gid_ft_build(struct fchs_s *fchs , void *pyld , u32 s_id , u8 fc4_type ) ;
u16 fc_rnnid_build(struct fchs_s *fchs , void *pyld , u32 s_id , u32 port_id , wwn_t node_name ) ;
u16 fc_fdmi_reqhdr_build(struct fchs_s *fchs , void *pyld , u32 s_id , u16 cmd_code ) ;
u16 fc_gmal_req_build(struct fchs_s *fchs , void *pyld , u32 s_id , wwn_t wwn ) ;
u16 fc_gfn_req_build(struct fchs_s *fchs , void *pyld , u32 s_id , wwn_t wwn ) ;
void fc_get_fc4type_bitmask(u8 fc4_type , u8 *bit_mask ) ;
u16 fc_ba_acc_build(struct fchs_s *fchs , struct fc_ba_acc_s *ba_acc , u32 d_id ,
                    u32 s_id , __be16 ox_id , u16 rx_id ) ;
static int __trc_fileno___7  =    2050;
static u8 const   loop_alpa_map[128U]  = 
  {      0U,      0U,      1U,      2U, 
        4U,      8U,      15U,      16U, 
        23U,      24U,      27U,      29U, 
        30U,      31U,      35U,      37U, 
        38U,      39U,      41U,      42U, 
        43U,      44U,      45U,      46U, 
        49U,      50U,      51U,      52U, 
        53U,      54U,      57U,      58U, 
        60U,      67U,      69U,      70U, 
        71U,      73U,      74U,      75U, 
        76U,      77U,      78U,      81U, 
        82U,      83U,      84U,      85U, 
        86U,      89U,      90U,      92U, 
        99U,      101U,      102U,      103U, 
        105U,      106U,      107U,      108U, 
        109U,      110U,      113U,      114U, 
        115U,      116U,      117U,      118U, 
        121U,      122U,      124U,      128U, 
        129U,      130U,      132U,      136U, 
        143U,      144U,      151U,      152U, 
        155U,      157U,      158U,      159U, 
        163U,      165U,      166U,      167U, 
        169U,      170U,      171U,      172U, 
        173U,      174U,      177U,      178U, 
        179U,      180U,      181U,      182U, 
        185U,      186U,      188U,      195U, 
        197U,      198U,      199U,      201U, 
        202U,      203U,      204U,      205U, 
        206U,      209U,      210U,      211U, 
        212U,      213U,      214U,      217U, 
        218U,      220U,      224U,      225U, 
        226U,      228U,      232U,      239U};
static void bfa_fcs_lport_send_ls_rjt(struct bfa_fcs_lport_s *port , struct fchs_s *rx_fchs ,
                                      u8 reason_code , u8 reason_code_expl ) ;
static void bfa_fcs_lport_plogi(struct bfa_fcs_lport_s *port , struct fchs_s *rx_fchs ,
                                struct fc_logi_s *plogi ) ;
static void bfa_fcs_lport_online_actions(struct bfa_fcs_lport_s *port ) ;
static void bfa_fcs_lport_offline_actions(struct bfa_fcs_lport_s *port ) ;
static void bfa_fcs_lport_unknown_init(struct bfa_fcs_lport_s *port ) ;
static void bfa_fcs_lport_unknown_online(struct bfa_fcs_lport_s *port ) ;
static void bfa_fcs_lport_unknown_offline(struct bfa_fcs_lport_s *port ) ;
static void bfa_fcs_lport_deleted(struct bfa_fcs_lport_s *port ) ;
static void bfa_fcs_lport_echo(struct bfa_fcs_lport_s *port , struct fchs_s *rx_fchs ,
                               struct fc_echo_s *echo , u16 rx_len ) ;
static void bfa_fcs_lport_rnid(struct bfa_fcs_lport_s *port , struct fchs_s *rx_fchs ,
                               struct fc_rnid_cmd_s *rnid , u16 rx_len ) ;
static void bfa_fs_port_get_gen_topo_data(struct bfa_fcs_lport_s *port , struct fc_rnid_general_topology_data_s *gen_topo_data ) ;
static void bfa_fcs_lport_fab_init(struct bfa_fcs_lport_s *port ) ;
static void bfa_fcs_lport_fab_online(struct bfa_fcs_lport_s *port ) ;
static void bfa_fcs_lport_fab_offline(struct bfa_fcs_lport_s *port ) ;
static void bfa_fcs_lport_n2n_init(struct bfa_fcs_lport_s *port ) ;
static void bfa_fcs_lport_n2n_online(struct bfa_fcs_lport_s *port ) ;
static void bfa_fcs_lport_n2n_offline(struct bfa_fcs_lport_s *port ) ;
static void bfa_fcs_lport_loop_init(struct bfa_fcs_lport_s *port ) ;
static void bfa_fcs_lport_loop_online(struct bfa_fcs_lport_s *port ) ;
static void bfa_fcs_lport_loop_offline(struct bfa_fcs_lport_s *port ) ;
static struct __anonstruct___port_action_303 __port_action[4U]  = {      {& bfa_fcs_lport_unknown_init, & bfa_fcs_lport_unknown_online, & bfa_fcs_lport_unknown_offline}, 
        {& bfa_fcs_lport_fab_init,
      & bfa_fcs_lport_fab_online, & bfa_fcs_lport_fab_offline}, 
        {& bfa_fcs_lport_n2n_init, & bfa_fcs_lport_n2n_online, & bfa_fcs_lport_n2n_offline}, 
        {& bfa_fcs_lport_loop_init,
      & bfa_fcs_lport_loop_online, & bfa_fcs_lport_loop_offline}};
static void bfa_fcs_lport_sm_uninit(struct bfa_fcs_lport_s *port , enum bfa_fcs_lport_event event ) ;
static void bfa_fcs_lport_sm_init(struct bfa_fcs_lport_s *port , enum bfa_fcs_lport_event event ) ;
static void bfa_fcs_lport_sm_online(struct bfa_fcs_lport_s *port , enum bfa_fcs_lport_event event ) ;
static void bfa_fcs_lport_sm_offline(struct bfa_fcs_lport_s *port , enum bfa_fcs_lport_event event ) ;
static void bfa_fcs_lport_sm_deleting(struct bfa_fcs_lport_s *port , enum bfa_fcs_lport_event event ) ;
static void bfa_fcs_lport_sm_stopping(struct bfa_fcs_lport_s *port , enum bfa_fcs_lport_event event ) ;
static void bfa_fcs_lport_sm_uninit(struct bfa_fcs_lport_s *port , enum bfa_fcs_lport_event event ) 
{ 


  {
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 133, port->port_cfg.pwwn);
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 134, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 1U: 
  port->sm = (void (*)(void * , int  ))(& bfa_fcs_lport_sm_init);
  goto ldv_48789;
  default: 
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 142, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcs_lport.c",
         142, (unsigned int )event);
  }
  ldv_48789: ;
  return;
}
}
static void bfa_fcs_lport_sm_init(struct bfa_fcs_lport_s *port , enum bfa_fcs_lport_event event ) 
{ 


  {
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 150, port->port_cfg.pwwn);
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 151, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 2U: 
  port->sm = (void (*)(void * , int  ))(& bfa_fcs_lport_sm_online);
  bfa_fcs_lport_online_actions(port);
  goto ldv_48796;
  case 4U: 
  port->sm = (void (*)(void * , int  ))(& bfa_fcs_lport_sm_uninit);
  bfa_fcs_lport_deleted(port);
  goto ldv_48796;
  case 6U: ;
  if ((unsigned long )port->vport != (unsigned long )((struct bfa_fcs_vport_s *)0)) {
    bfa_fcs_vport_stop_comp(port->vport);
  } else {
    bfa_wc_down(& (port->fabric)->stop_wc);
  }
  goto ldv_48796;
  case 3U: ;
  goto ldv_48796;
  default: 
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 176, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcs_lport.c",
         176, (unsigned int )event);
  }
  ldv_48796: ;
  return;
}
}
static void bfa_fcs_lport_sm_online(struct bfa_fcs_lport_s *port , enum bfa_fcs_lport_event event ) 
{ 
  struct bfa_fcs_rport_s *rport ;
  struct list_head *qe ;
  struct list_head *qen ;

  {
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 188, port->port_cfg.pwwn);
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 189, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 3U: 
  port->sm = (void (*)(void * , int  ))(& bfa_fcs_lport_sm_offline);
  bfa_fcs_lport_offline_actions(port);
  goto ldv_48809;
  case 6U: 
  (*(__port_action[(unsigned int )(port->fabric)->fab_type].offline))(port);
  if ((unsigned int )port->num_rports == 0U) {
    port->sm = (void (*)(void * , int  ))(& bfa_fcs_lport_sm_init);
    if ((unsigned long )port->vport != (unsigned long )((struct bfa_fcs_vport_s *)0)) {
      bfa_fcs_vport_stop_comp(port->vport);
    } else {
      bfa_wc_down(& (port->fabric)->stop_wc);
    }
  } else {
    port->sm = (void (*)(void * , int  ))(& bfa_fcs_lport_sm_stopping);
    qe = port->rport_q.next;
    qen = qe->next;
    goto ldv_48812;
    ldv_48811: 
    rport = (struct bfa_fcs_rport_s *)qe;
    (*(rport->sm))((void *)rport, 7);
    qe = qen;
    qen = qe->next;
    ldv_48812: ;
    if ((unsigned long )(& port->rport_q) != (unsigned long )qe) {
      goto ldv_48811;
    } else {

    }

  }
  goto ldv_48809;
  case 4U: 
  (*(__port_action[(unsigned int )(port->fabric)->fab_type].offline))(port);
  if ((unsigned int )port->num_rports == 0U) {
    port->sm = (void (*)(void * , int  ))(& bfa_fcs_lport_sm_uninit);
    bfa_fcs_lport_deleted(port);
  } else {
    port->sm = (void (*)(void * , int  ))(& bfa_fcs_lport_sm_deleting);
    qe = port->rport_q.next;
    qen = qe->next;
    goto ldv_48816;
    ldv_48815: 
    rport = (struct bfa_fcs_rport_s *)qe;
    (*(rport->sm))((void *)rport, 7);
    qe = qen;
    qen = qe->next;
    ldv_48816: ;
    if ((unsigned long )(& port->rport_q) != (unsigned long )qe) {
      goto ldv_48815;
    } else {

    }

  }
  goto ldv_48809;
  case 5U: ;
  goto ldv_48809;
  default: 
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 236, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcs_lport.c",
         236, (unsigned int )event);
  }
  ldv_48809: ;
  return;
}
}
static void bfa_fcs_lport_sm_offline(struct bfa_fcs_lport_s *port , enum bfa_fcs_lport_event event ) 
{ 
  struct bfa_fcs_rport_s *rport ;
  struct list_head *qe ;
  struct list_head *qen ;

  {
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 248, port->port_cfg.pwwn);
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 249, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 2U: 
  port->sm = (void (*)(void * , int  ))(& bfa_fcs_lport_sm_online);
  bfa_fcs_lport_online_actions(port);
  goto ldv_48828;
  case 6U: ;
  if ((unsigned int )port->num_rports == 0U) {
    port->sm = (void (*)(void * , int  ))(& bfa_fcs_lport_sm_init);
    if ((unsigned long )port->vport != (unsigned long )((struct bfa_fcs_vport_s *)0)) {
      bfa_fcs_vport_stop_comp(port->vport);
    } else {
      bfa_wc_down(& (port->fabric)->stop_wc);
    }
  } else {
    port->sm = (void (*)(void * , int  ))(& bfa_fcs_lport_sm_stopping);
    qe = port->rport_q.next;
    qen = qe->next;
    goto ldv_48831;
    ldv_48830: 
    rport = (struct bfa_fcs_rport_s *)qe;
    (*(rport->sm))((void *)rport, 7);
    qe = qen;
    qen = qe->next;
    ldv_48831: ;
    if ((unsigned long )(& port->rport_q) != (unsigned long )qe) {
      goto ldv_48830;
    } else {

    }

  }
  goto ldv_48828;
  case 4U: ;
  if ((unsigned int )port->num_rports == 0U) {
    port->sm = (void (*)(void * , int  ))(& bfa_fcs_lport_sm_uninit);
    bfa_fcs_lport_deleted(port);
  } else {
    port->sm = (void (*)(void * , int  ))(& bfa_fcs_lport_sm_deleting);
    qe = port->rport_q.next;
    qen = qe->next;
    goto ldv_48835;
    ldv_48834: 
    rport = (struct bfa_fcs_rport_s *)qe;
    (*(rport->sm))((void *)rport, 7);
    qe = qen;
    qen = qe->next;
    ldv_48835: ;
    if ((unsigned long )(& port->rport_q) != (unsigned long )qe) {
      goto ldv_48834;
    } else {

    }

  }
  goto ldv_48828;
  case 5U: ;
  case 3U: ;
  goto ldv_48828;
  default: 
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 292, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcs_lport.c",
         292, (unsigned int )event);
  }
  ldv_48828: ;
  return;
}
}
static void bfa_fcs_lport_sm_stopping(struct bfa_fcs_lport_s *port , enum bfa_fcs_lport_event event ) 
{ 


  {
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 300, port->port_cfg.pwwn);
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 301, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 5U: ;
  if ((unsigned int )port->num_rports == 0U) {
    port->sm = (void (*)(void * , int  ))(& bfa_fcs_lport_sm_init);
    if ((unsigned long )port->vport != (unsigned long )((struct bfa_fcs_vport_s *)0)) {
      bfa_fcs_vport_stop_comp(port->vport);
    } else {
      bfa_wc_down(& (port->fabric)->stop_wc);
    }
  } else {

  }
  goto ldv_48845;
  default: 
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 316, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcs_lport.c",
         316, (unsigned int )event);
  }
  ldv_48845: ;
  return;
}
}
static void bfa_fcs_lport_sm_deleting(struct bfa_fcs_lport_s *port , enum bfa_fcs_lport_event event ) 
{ 


  {
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 325, port->port_cfg.pwwn);
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 326, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 5U: ;
  if ((unsigned int )port->num_rports == 0U) {
    port->sm = (void (*)(void * , int  ))(& bfa_fcs_lport_sm_uninit);
    bfa_fcs_lport_deleted(port);
  } else {

  }
  goto ldv_48852;
  default: 
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 337, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcs_lport.c",
         337, (unsigned int )event);
  }
  ldv_48852: ;
  return;
}
}
static void bfa_fcs_lport_aen_post(struct bfa_fcs_lport_s *port , enum bfa_lport_aen_event event ) 
{ 
  struct bfad_s *bfad ;
  struct bfa_aen_entry_s *aen_entry ;
  unsigned long _flags ;
  raw_spinlock_t *tmp ;
  int tmp___0 ;
  struct bfa_fcs_lport_s *tmp___1 ;

  {
  bfad = ((port->fabric)->fcs)->bfad;
  tmp = spinlock_check(& bfad->bfad_aen_spinlock);
  _flags = _raw_spin_lock_irqsave(tmp);
  tmp___0 = list_empty((struct list_head  const  *)(& bfad->free_aen_q));
  if (tmp___0 == 0) {
    *((struct list_head **)(& aen_entry)) = bfad->free_aen_q.next;
    ((*((struct list_head **)(& aen_entry)))->next)->prev = & bfad->free_aen_q;
    bfad->free_aen_q.next = (*((struct list_head **)(& aen_entry)))->next;
  } else {
    *((struct list_head **)(& aen_entry)) = (struct list_head *)0;
  }
  if ((unsigned long )aen_entry != (unsigned long )((struct bfa_aen_entry_s *)0)) {
    list_add_tail(& aen_entry->qe, & bfad->active_aen_q);
  } else {

  }
  spin_unlock_irqrestore(& bfad->bfad_aen_spinlock, _flags);
  if ((unsigned long )aen_entry == (unsigned long )((struct bfa_aen_entry_s *)0)) {
    return;
  } else {

  }
  aen_entry->aen_data.lport.vf_id = (port->fabric)->vf_id;
  aen_entry->aen_data.lport.roles = (u16 )port->port_cfg.roles;
  tmp___1 = bfa_fcs_get_base_port(port->fcs);
  aen_entry->aen_data.lport.ppwwn = tmp___1->port_cfg.pwwn;
  aen_entry->aen_data.lport.lpwwn = port->port_cfg.pwwn;
  do_gettimeofday(& aen_entry->aen_tv);
  aen_entry->bfad_num = bfad->inst_no;
  (port->fcs)->fcs_aen_seq = (port->fcs)->fcs_aen_seq + 1;
  aen_entry->seq_num = (u32 )(port->fcs)->fcs_aen_seq;
  aen_entry->aen_category = 3;
  aen_entry->aen_type = (u32 )event;
  if ((bfad->bfad_flags & 512U) != 0U) {
    queue_work___2((bfad->im)->drv_workq, & (bfad->im)->aen_im_notify_work);
  } else {

  }
  return;
}
}
static void bfa_fcs_lport_send_ls_rjt(struct bfa_fcs_lport_s *port , struct fchs_s *rx_fchs ,
                                      u8 reason_code , u8 reason_code_expl ) 
{ 
  struct fchs_s fchs ;
  struct bfa_fcxp_s *fcxp ;
  struct bfa_rport_s *bfa_rport ;
  int len ;
  void *tmp ;
  u16 tmp___0 ;

  {
  bfa_rport = (struct bfa_rport_s *)0;
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 382, (unsigned long long )rx_fchs->d_id);
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 383, (unsigned long long )rx_fchs->s_id);
  fcxp = bfa_fcxp_req_rsp_alloc((void *)0, (port->fcs)->bfa, 0, 0, (u64 (*)(void * ,
                                                                            int  ))0,
                                (u32 (*)(void * , int  ))0, (u64 (*)(void * , int  ))0,
                                (u32 (*)(void * , int  ))0, 0);
  if ((unsigned long )fcxp == (unsigned long )((struct bfa_fcxp_s *)0)) {
    return;
  } else {

  }
  tmp = bfa_fcxp_get_reqbuf(fcxp);
  tmp___0 = fc_ls_rjt_build(& fchs, (struct fc_ls_rjt_s *)tmp, rx_fchs->s_id, port->pid,
                            (int )rx_fchs->ox_id, (int )reason_code, (int )reason_code_expl);
  len = (int )tmp___0;
  bfa_fcxp_send(fcxp, bfa_rport, (int )(port->fabric)->vf_id, (int )port->lp_tag,
                0, 8, (u32 )len, & fchs, (void (*)(void * , struct bfa_fcxp_s * ,
                                                   void * , enum bfa_status  , u32  ,
                                                   u32  , struct fchs_s * ))0, (void *)0,
                2112U, 0);
  return;
}
}
static void bfa_fcs_lport_send_fcgs_rjt(struct bfa_fcs_lport_s *port , struct fchs_s *rx_fchs ,
                                        u8 reason_code , u8 reason_code_expl ) 
{ 
  struct fchs_s fchs ;
  struct bfa_fcxp_s *fcxp ;
  struct bfa_rport_s *bfa_rport ;
  int len ;
  struct ct_hdr_s *rx_cthdr ;
  struct ct_hdr_s *ct_hdr ;
  void *tmp ;
  u16 tmp___0 ;

  {
  bfa_rport = (struct bfa_rport_s *)0;
  rx_cthdr = (struct ct_hdr_s *)rx_fchs + 1U;
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 412, (unsigned long long )rx_fchs->d_id);
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 413, (unsigned long long )rx_fchs->s_id);
  fcxp = bfa_fcxp_req_rsp_alloc((void *)0, (port->fcs)->bfa, 0, 0, (u64 (*)(void * ,
                                                                            int  ))0,
                                (u32 (*)(void * , int  ))0, (u64 (*)(void * , int  ))0,
                                (u32 (*)(void * , int  ))0, 0);
  if ((unsigned long )fcxp == (unsigned long )((struct bfa_fcxp_s *)0)) {
    return;
  } else {

  }
  tmp = bfa_fcxp_get_reqbuf(fcxp);
  ct_hdr = (struct ct_hdr_s *)tmp;
  ct_hdr->gs_type = rx_cthdr->gs_type;
  ct_hdr->gs_sub_type = rx_cthdr->gs_sub_type;
  tmp___0 = fc_gs_rjt_build(& fchs, ct_hdr, rx_fchs->s_id, port->pid, (int )rx_fchs->ox_id,
                            (int )reason_code, (int )reason_code_expl);
  len = (int )tmp___0;
  bfa_fcxp_send(fcxp, bfa_rport, (int )(port->fabric)->vf_id, (int )port->lp_tag,
                0, 8, (u32 )len, & fchs, (void (*)(void * , struct bfa_fcxp_s * ,
                                                   void * , enum bfa_status  , u32  ,
                                                   u32  , struct fchs_s * ))0, (void *)0,
                2112U, 0);
  return;
}
}
static void bfa_fcs_lport_plogi(struct bfa_fcs_lport_s *port , struct fchs_s *rx_fchs ,
                                struct fc_logi_s *plogi ) 
{ 
  struct bfa_fcs_rport_s *rport ;
  enum fc_parse_status tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int __ret_warn_on ;
  long tmp___2 ;
  int __ret_warn_on___0 ;
  long tmp___3 ;

  {
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 441, (unsigned long long )rx_fchs->d_id);
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 442, (unsigned long long )rx_fchs->s_id);
  if ((unsigned int )(port->fcs)->min_cfg != 0U) {
    __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 448, (unsigned long long )rx_fchs->s_id);
    return;
  } else {

  }
  tmp = fc_plogi_parse(rx_fchs);
  if ((unsigned int )tmp != 0U) {
    __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 453, (unsigned long long )rx_fchs->s_id);
    bfa_fcs_lport_send_ls_rjt(port, rx_fchs, 7, 1);
    return;
  } else {

  }
  if ((unsigned int )(port->fabric)->fab_type != 1U) {
    tmp___0 = memcmp((void const   *)(& port->port_cfg.pwwn), (void const   *)(& plogi->port_name),
                     8UL);
    if (tmp___0 < 0) {
      if ((((((int )rx_fchs->d_id & 255) << 16) | ((int )rx_fchs->d_id & 65280)) | (((int )rx_fchs->d_id & 16711680) >> 16)) > 16773120) {
        bfa_fcs_lport_send_ls_rjt(port, rx_fchs, 7, 31);
        return;
      } else {

      }
      port->pid = rx_fchs->d_id;
      bfa_lps_set_n2n_pid((port->fabric)->lps, rx_fchs->d_id);
    } else {

    }
  } else {

  }
  rport = bfa_fcs_lport_get_rport_by_pwwn(port, plogi->port_name);
  if ((unsigned long )rport != (unsigned long )((struct bfa_fcs_rport_s *)0)) {
    if ((unsigned int )(port->fabric)->fab_type != 1U) {
      tmp___1 = memcmp((void const   *)(& port->port_cfg.pwwn), (void const   *)(& plogi->port_name),
                       8UL);
      if (tmp___1 < 0) {
        port->pid = rx_fchs->d_id;
        bfa_lps_set_n2n_pid((port->fabric)->lps, rx_fchs->d_id);
        rport->pid = rx_fchs->s_id;
      } else {

      }
    } else {

    }
    bfa_fcs_rport_plogi(rport, rx_fchs, plogi);
    return;
  } else {

  }
  rport = bfa_fcs_lport_get_rport_by_pid(port, rx_fchs->s_id);
  if ((unsigned long )rport == (unsigned long )((struct bfa_fcs_rport_s *)0)) {
    bfa_fcs_rport_plogi_create(port, rx_fchs, plogi);
    return;
  } else {

  }
  if (rport->pwwn != 0ULL) {
    __ret_warn_on = rport->pwwn == plogi->port_name;
    tmp___2 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
    if (tmp___2 != 0L) {
      warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcs_lport.c",
                         519);
    } else {

    }
    ldv__builtin_expect(__ret_warn_on != 0, 0L);
    (*(rport->sm))((void *)rport, 5);
    bfa_fcs_rport_plogi_create(port, rx_fchs, plogi);
    return;
  } else {

  }
  __ret_warn_on___0 = rport->pwwn != 0ULL;
  tmp___3 = ldv__builtin_expect(__ret_warn_on___0 != 0, 0L);
  if (tmp___3 != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcs_lport.c",
                       532);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on___0 != 0, 0L);
  bfa_fcs_rport_plogi(rport, rx_fchs, plogi);
  return;
}
}
static void bfa_fcs_lport_echo(struct bfa_fcs_lport_s *port , struct fchs_s *rx_fchs ,
                               struct fc_echo_s *echo , u16 rx_len ) 
{ 
  struct fchs_s fchs ;
  struct bfa_fcxp_s *fcxp ;
  struct bfa_rport_s *bfa_rport ;
  int len ;
  int pyld_len ;
    klee_make_symbolic(&pyld_len, sizeof(int), "pyld_len");
  void *tmp ;
  u16 tmp___0 ;
  void *tmp___1 ;

  {
  bfa_rport = (struct bfa_rport_s *)0;
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 549, (unsigned long long )rx_fchs->s_id);
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 550, (unsigned long long )rx_fchs->d_id);
  fcxp = bfa_fcxp_req_rsp_alloc((void *)0, (port->fcs)->bfa, 0, 0, (u64 (*)(void * ,
                                                                            int  ))0,
                                (u32 (*)(void * , int  ))0, (u64 (*)(void * , int  ))0,
                                (u32 (*)(void * , int  ))0, 0);
  if ((unsigned long )fcxp == (unsigned long )((struct bfa_fcxp_s *)0)) {
    return;
  } else {

  }
  tmp = bfa_fcxp_get_reqbuf(fcxp);
  tmp___0 = fc_ls_acc_build(& fchs, (struct fc_els_cmd_s *)tmp, rx_fchs->s_id, port->pid,
                            (int )rx_fchs->ox_id);
  len = (int )tmp___0;
  pyld_len = (int )((unsigned int )rx_len - 24U);
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 564, (unsigned long long )rx_len);
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 565, (unsigned long long )pyld_len);
  if (pyld_len > len) {
    tmp___1 = bfa_fcxp_get_reqbuf(fcxp);
    memcpy(tmp___1 + 4U, (void const   *)echo + 1U, (unsigned long )pyld_len - 4UL);
  } else {

  }
  bfa_fcxp_send(fcxp, bfa_rport, (int )(port->fabric)->vf_id, (int )port->lp_tag,
                0, 8, (u32 )pyld_len, & fchs, (void (*)(void * , struct bfa_fcxp_s * ,
                                                        void * , enum bfa_status  ,
                                                        u32  , u32  , struct fchs_s * ))0,
                (void *)0, 2112U, 0);
  return;
}
}
static void bfa_fcs_lport_rnid(struct bfa_fcs_lport_s *port , struct fchs_s *rx_fchs ,
                               struct fc_rnid_cmd_s *rnid , u16 rx_len ) 
{ 
  struct fc_rnid_common_id_data_s common_id_data ;
  struct fc_rnid_general_topology_data_s gen_topo_data ;
  struct fchs_s fchs ;
  struct bfa_fcxp_s *fcxp ;
  struct bfa_rport_s *bfa_rport ;
  u16 len ;
  u32 data_format ;
  void *tmp ;

  {
  bfa_rport = (struct bfa_rport_s *)0;
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 593, (unsigned long long )rx_fchs->s_id);
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 594, (unsigned long long )rx_fchs->d_id);
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 595, (unsigned long long )rx_len);
  fcxp = bfa_fcxp_req_rsp_alloc((void *)0, (port->fcs)->bfa, 0, 0, (u64 (*)(void * ,
                                                                            int  ))0,
                                (u32 (*)(void * , int  ))0, (u64 (*)(void * , int  ))0,
                                (u32 (*)(void * , int  ))0, 0);
  if ((unsigned long )fcxp == (unsigned long )((struct bfa_fcxp_s *)0)) {
    return;
  } else {

  }
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 607, (unsigned long long )rnid->node_id_data_format);
  if ((unsigned int )rnid->node_id_data_format == 223U) {
    data_format = 223U;
    bfa_fs_port_get_gen_topo_data(port, & gen_topo_data);
  } else {
    data_format = 0U;
  }
  common_id_data.port_name = port->port_cfg.pwwn;
  common_id_data.node_name = port->port_cfg.nwwn;
  tmp = bfa_fcxp_get_reqbuf(fcxp);
  len = fc_rnid_acc_build(& fchs, (struct fc_rnid_acc_s *)tmp, rx_fchs->s_id, port->pid,
                          (int )rx_fchs->ox_id, data_format, & common_id_data, & gen_topo_data);
  bfa_fcxp_send(fcxp, bfa_rport, (int )(port->fabric)->vf_id, (int )port->lp_tag,
                0, 8, (u32 )len, & fchs, (void (*)(void * , struct bfa_fcxp_s * ,
                                                   void * , enum bfa_status  , u32  ,
                                                   u32  , struct fchs_s * ))0, (void *)0,
                2112U, 0);
  return;
}
}
static void bfa_fs_port_get_gen_topo_data(struct bfa_fcs_lport_s *port , struct fc_rnid_general_topology_data_s *gen_topo_data ) 
{ 


  {
  memset((void *)gen_topo_data, 0, 52UL);
  gen_topo_data->asso_type = 167772160U;
  gen_topo_data->phy_port_num = 0U;
  gen_topo_data->num_attached_nodes = 16777216U;
  return;
}
}
static void bfa_fcs_lport_online_actions(struct bfa_fcs_lport_s *port ) 
{ 
  struct bfad_s *bfad ;
  char lpwwn_buf[32U] ;

  {
  bfad = (port->fcs)->bfad;
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 655, (unsigned long long )(port->fabric)->oper_type);
  (*(__port_action[(unsigned int )(port->fabric)->fab_type].init))(port);
  (*(__port_action[(unsigned int )(port->fabric)->fab_type].online))(port);
  wwn2str___2((char *)(& lpwwn_buf), port->port_cfg.pwwn);
  if (bfa_log_level == 4 || (int )((signed char )*("\f" + 1)) <= 52) {
    dev_printk("\f", (struct device  const  *)(& (bfad->pcidev)->dev), "Logical port online: WWN = %s Role = %s\n",
               (char *)(& lpwwn_buf), (char *)"Initiator");
  } else {

  }
  bfa_fcs_lport_aen_post(port, 3);
  bfad->bfad_flags = bfad->bfad_flags | 32U;
  return;
}
}
static void bfa_fcs_lport_offline_actions(struct bfa_fcs_lport_s *port ) 
{ 
  struct list_head *qe ;
  struct list_head *qen ;
  struct bfa_fcs_rport_s *rport ;
  struct bfad_s *bfad ;
  char lpwwn_buf[32U] ;

  {
  bfad = (port->fcs)->bfad;
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 677, (unsigned long long )(port->fabric)->oper_type);
  (*(__port_action[(unsigned int )(port->fabric)->fab_type].offline))(port);
  wwn2str___2((char *)(& lpwwn_buf), port->port_cfg.pwwn);
  if ((unsigned long )(port->fabric)->sm == (unsigned long )((void (*)(void * , int  ))(& bfa_fcs_fabric_sm_online))) {
    if (bfa_log_level == 4 || (int )((signed char )*("\f" + 1)) <= 52) {
      dev_printk("\f", (struct device  const  *)(& (bfad->pcidev)->dev), "Logical port lost fabric connectivity: WWN = %s Role = %s\n",
                 (char *)(& lpwwn_buf), (char *)"Initiator");
    } else {

    }
    bfa_fcs_lport_aen_post(port, 5);
  } else {
    if (bfa_log_level == 4 || (int )((signed char )*("\f" + 1)) <= 52) {
      dev_printk("\f", (struct device  const  *)(& (bfad->pcidev)->dev), "Logical port taken offline: WWN = %s Role = %s\n",
                 (char *)(& lpwwn_buf), (char *)"Initiator");
    } else {

    }
    bfa_fcs_lport_aen_post(port, 4);
  }
  qe = port->rport_q.next;
  qen = qe->next;
  goto ldv_48938;
  ldv_48937: 
  rport = (struct bfa_fcs_rport_s *)qe;
  (*(rport->sm))((void *)rport, 5);
  qe = qen;
  qen = qe->next;
  ldv_48938: ;
  if ((unsigned long )(& port->rport_q) != (unsigned long )qe) {
    goto ldv_48937;
  } else {

  }

  return;
}
}
static void bfa_fcs_lport_unknown_init(struct bfa_fcs_lport_s *port ) 
{ 
  int __ret_warn_on ;
  long tmp ;

  {
  __ret_warn_on = 1;
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcs_lport.c",
                       704);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  return;
}
}
static void bfa_fcs_lport_unknown_online(struct bfa_fcs_lport_s *port ) 
{ 
  int __ret_warn_on ;
  long tmp ;

  {
  __ret_warn_on = 1;
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcs_lport.c",
                       710);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  return;
}
}
static void bfa_fcs_lport_unknown_offline(struct bfa_fcs_lport_s *port ) 
{ 
  int __ret_warn_on ;
  long tmp ;

  {
  __ret_warn_on = 1;
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcs_lport.c",
                       716);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  return;
}
}
static void bfa_fcs_lport_abts_acc(struct bfa_fcs_lport_s *port , struct fchs_s *rx_fchs ) 
{ 
  struct fchs_s fchs ;
  struct bfa_fcxp_s *fcxp ;
  int len ;
  void *tmp ;
  u16 tmp___0 ;

  {
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 726, (unsigned long long )rx_fchs->d_id);
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 727, (unsigned long long )rx_fchs->s_id);
  fcxp = bfa_fcxp_req_rsp_alloc((void *)0, (port->fcs)->bfa, 0, 0, (u64 (*)(void * ,
                                                                            int  ))0,
                                (u32 (*)(void * , int  ))0, (u64 (*)(void * , int  ))0,
                                (u32 (*)(void * , int  ))0, 0);
  if ((unsigned long )fcxp == (unsigned long )((struct bfa_fcxp_s *)0)) {
    return;
  } else {

  }
  tmp = bfa_fcxp_get_reqbuf(fcxp);
  tmp___0 = fc_ba_acc_build(& fchs, (struct fc_ba_acc_s *)tmp, rx_fchs->s_id, port->pid,
                            (int )rx_fchs->ox_id, 0);
  len = (int )tmp___0;
  bfa_fcxp_send(fcxp, (struct bfa_rport_s *)0, (int )(port->fabric)->vf_id, (int )port->lp_tag,
                0, 8, (u32 )len, & fchs, (void (*)(void * , struct bfa_fcxp_s * ,
                                                   void * , enum bfa_status  , u32  ,
                                                   u32  , struct fchs_s * ))0, (void *)0,
                2112U, 0);
  return;
}
}
static void bfa_fcs_lport_deleted(struct bfa_fcs_lport_s *port ) 
{ 
  struct bfad_s *bfad ;
  char lpwwn_buf[32U] ;

  {
  bfad = (port->fcs)->bfad;
  wwn2str___2((char *)(& lpwwn_buf), port->port_cfg.pwwn);
  if (bfa_log_level == 4 || (int )((signed char )*("\016" + 1)) <= 52) {
    dev_printk("\016", (struct device  const  *)(& (bfad->pcidev)->dev), "Logical port deleted: WWN = %s Role = %s\n",
               (char *)(& lpwwn_buf), (char *)"Initiator");
  } else {

  }
  bfa_fcs_lport_aen_post(port, 2);
  if ((unsigned long )port->vport != (unsigned long )((struct bfa_fcs_vport_s *)0)) {
    bfa_fcs_vport_delete_comp(port->vport);
  } else {
    bfa_wc_down(& (port->fabric)->wc);
  }
  return;
}
}
void bfa_fcs_lport_uf_recv(struct bfa_fcs_lport_s *lport , struct fchs_s *fchs , u16 len ) 
{ 
  u32 pid ;
  struct bfa_fcs_rport_s *rport ;
  struct fc_els_cmd_s *els_cmd ;
  enum bfa_boolean tmp ;

  {
  pid = fchs->s_id;
  rport = (struct bfa_fcs_rport_s *)0;
  els_cmd = (struct fc_els_cmd_s *)fchs + 1U;
  lport->stats.uf_recvs = lport->stats.uf_recvs + 1U;
  __bfa_trc((lport->fcs)->trcmod, __trc_fileno___7, 773, (unsigned long long )fchs->type);
  tmp = bfa_fcs_lport_is_online(lport);
  if ((unsigned int )tmp == 0U) {
    if ((unsigned int )fchs->type == 1U && (unsigned int )els_cmd->els_code == 3U) {
      bfa_fcs_lport_send_ls_rjt(lport, fchs, 9, 0);
      lport->stats.plogi_rcvd = lport->stats.plogi_rcvd + 1U;
    } else {
      lport->stats.uf_recv_drops = lport->stats.uf_recv_drops + 1U;
    }
    return;
  } else {

  }
  if ((unsigned int )fchs->type == 1U && (unsigned int )els_cmd->els_code == 3U) {
    bfa_fcs_lport_plogi(lport, fchs, (struct fc_logi_s *)els_cmd);
    return;
  } else {

  }
  if ((unsigned int )fchs->type == 1U && (unsigned int )els_cmd->els_code == 16U) {
    bfa_fcs_lport_echo(lport, fchs, (struct fc_echo_s *)els_cmd, (int )len);
    return;
  } else {

  }
  if ((unsigned int )fchs->type == 1U && (unsigned int )els_cmd->els_code == 120U) {
    bfa_fcs_lport_rnid(lport, fchs, (struct fc_rnid_cmd_s *)els_cmd, (int )len);
    return;
  } else {

  }
  if ((unsigned int )fchs->type == 0U) {
    if ((unsigned int )*((unsigned char *)fchs + 0UL) == 128U && (unsigned int )*((unsigned char *)fchs + 0UL) == 1U) {
      bfa_fcs_lport_abts_acc(lport, fchs);
    } else {

    }
    return;
  } else {

  }
  if ((unsigned int )fchs->type == 32U) {
    bfa_fcs_lport_send_fcgs_rjt(lport, fchs, 11, 0);
    return;
  } else {

  }
  rport = bfa_fcs_lport_get_rport_by_pid(lport, pid);
  if ((unsigned long )rport != (unsigned long )((struct bfa_fcs_rport_s *)0)) {
    __bfa_trc((rport->fcs)->trcmod, __trc_fileno___7, 844, (unsigned long long )fchs->s_id);
    __bfa_trc((rport->fcs)->trcmod, __trc_fileno___7, 845, (unsigned long long )fchs->d_id);
    __bfa_trc((rport->fcs)->trcmod, __trc_fileno___7, 846, (unsigned long long )fchs->type);
    bfa_fcs_rport_uf_recv(rport, fchs, (int )len);
    return;
  } else {

  }
  if ((unsigned int )fchs->type != 1U) {
    __bfa_trc((lport->fcs)->trcmod, __trc_fileno___7, 856, (unsigned long long )fchs->s_id);
    __bfa_trc((lport->fcs)->trcmod, __trc_fileno___7, 857, (unsigned long long )fchs->d_id);
    if ((unsigned int )fchs->type != 34U) {
      __bfa_trc((lport->fcs)->trcmod, __trc_fileno___7, 860, (unsigned long long )((unsigned int )fchs->type | 3735879680U));
      printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcs_lport.c",
             860, (int )fchs->type);
    } else {

    }
    return;
  } else {

  }
  __bfa_trc((lport->fcs)->trcmod, __trc_fileno___7, 864, (unsigned long long )els_cmd->els_code);
  if ((unsigned int )els_cmd->els_code == 97U) {
    bfa_fcs_lport_scn_process_rscn(lport, fchs, (u32 )len);
    return;
  } else {

  }
  if ((unsigned int )els_cmd->els_code == 5U) {
    return;
  } else {

  }
  if ((unsigned int )els_cmd->els_code == 32U) {
    return;
  } else {

  }
  bfa_fcs_lport_send_ls_rjt(lport, fchs, 11, 0);
  return;
}
}
struct bfa_fcs_rport_s *bfa_fcs_lport_get_rport_by_pid(struct bfa_fcs_lport_s *port ,
                                                       u32 pid ) 
{ 
  struct bfa_fcs_rport_s *rport ;
  struct list_head *qe ;

  {
  qe = port->rport_q.next;
  goto ldv_48982;
  ldv_48981: 
  rport = (struct bfa_fcs_rport_s *)qe;
  if (rport->pid == pid) {
    return (rport);
  } else {

  }
  qe = qe->next;
  ldv_48982: ;
  if ((unsigned long )(& port->rport_q) != (unsigned long )qe) {
    goto ldv_48981;
  } else {

  }
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 907, (unsigned long long )pid);
  return ((struct bfa_fcs_rport_s *)0);
}
}
struct bfa_fcs_rport_s *bfa_fcs_lport_get_rport_by_old_pid(struct bfa_fcs_lport_s *port ,
                                                           u32 pid ) 
{ 
  struct bfa_fcs_rport_s *rport ;
  struct list_head *qe ;

  {
  qe = port->rport_q.next;
  goto ldv_48991;
  ldv_48990: 
  rport = (struct bfa_fcs_rport_s *)qe;
  if (rport->old_pid == pid) {
    return (rport);
  } else {

  }
  qe = qe->next;
  ldv_48991: ;
  if ((unsigned long )(& port->rport_q) != (unsigned long )qe) {
    goto ldv_48990;
  } else {

  }
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 926, (unsigned long long )pid);
  return ((struct bfa_fcs_rport_s *)0);
}
}
struct bfa_fcs_rport_s *bfa_fcs_lport_get_rport_by_pwwn(struct bfa_fcs_lport_s *port ,
                                                        wwn_t pwwn ) 
{ 
  struct bfa_fcs_rport_s *rport ;
  struct list_head *qe ;
  int tmp ;

  {
  qe = port->rport_q.next;
  goto ldv_49000;
  ldv_48999: 
  rport = (struct bfa_fcs_rport_s *)qe;
  tmp = memcmp((void const   *)(& rport->pwwn), (void const   *)(& pwwn), 8UL);
  if (tmp == 0) {
    return (rport);
  } else {

  }
  qe = qe->next;
  ldv_49000: ;
  if ((unsigned long )(& port->rport_q) != (unsigned long )qe) {
    goto ldv_48999;
  } else {

  }
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 945, pwwn);
  return ((struct bfa_fcs_rport_s *)0);
}
}
struct bfa_fcs_rport_s *bfa_fcs_lport_get_rport_by_nwwn(struct bfa_fcs_lport_s *port ,
                                                        wwn_t nwwn ) 
{ 
  struct bfa_fcs_rport_s *rport ;
  struct list_head *qe ;
  int tmp ;

  {
  qe = port->rport_q.next;
  goto ldv_49009;
  ldv_49008: 
  rport = (struct bfa_fcs_rport_s *)qe;
  tmp = memcmp((void const   *)(& rport->nwwn), (void const   *)(& nwwn), 8UL);
  if (tmp == 0) {
    return (rport);
  } else {

  }
  qe = qe->next;
  ldv_49009: ;
  if ((unsigned long )(& port->rport_q) != (unsigned long )qe) {
    goto ldv_49008;
  } else {

  }
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 964, nwwn);
  return ((struct bfa_fcs_rport_s *)0);
}
}
struct bfa_fcs_rport_s *bfa_fcs_lport_get_rport_by_qualifier(struct bfa_fcs_lport_s *port ,
                                                             wwn_t pwwn , u32 pid ) 
{ 
  struct bfa_fcs_rport_s *rport ;
  struct list_head *qe ;
  int tmp ;

  {
  qe = port->rport_q.next;
  goto ldv_49019;
  ldv_49018: 
  rport = (struct bfa_fcs_rport_s *)qe;
  tmp = memcmp((void const   *)(& rport->pwwn), (void const   *)(& pwwn), 8UL);
  if (tmp == 0 && rport->pid == pid) {
    return (rport);
  } else {

  }
  qe = qe->next;
  ldv_49019: ;
  if ((unsigned long )(& port->rport_q) != (unsigned long )qe) {
    goto ldv_49018;
  } else {

  }
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 984, pwwn);
  return ((struct bfa_fcs_rport_s *)0);
}
}
void bfa_fcs_lport_add_rport(struct bfa_fcs_lport_s *port , struct bfa_fcs_rport_s *rport ) 
{ 


  {
  list_add_tail(& rport->qe, & port->rport_q);
  port->num_rports = (u16 )((int )port->num_rports + 1);
  return;
}
}
void bfa_fcs_lport_del_rport(struct bfa_fcs_lport_s *port , struct bfa_fcs_rport_s *rport ) 
{ 
  int __ret_warn_on ;
  int tmp ;
  long tmp___0 ;

  {
  tmp = bfa_q_is_on_q_func(& port->rport_q, (struct list_head *)rport);
  __ret_warn_on = tmp == 0;
  tmp___0 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp___0 != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcs_lport.c",
                       1008);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  list_del(& rport->qe);
  port->num_rports = (u16 )((int )port->num_rports - 1);
  (*(port->sm))((void *)port, 5);
  return;
}
}
void bfa_fcs_lport_online(struct bfa_fcs_lport_s *port ) 
{ 


  {
  (*(port->sm))((void *)port, 2);
  return;
}
}
void bfa_fcs_lport_offline(struct bfa_fcs_lport_s *port ) 
{ 


  {
  (*(port->sm))((void *)port, 3);
  return;
}
}
void bfa_fcs_lport_stop(struct bfa_fcs_lport_s *port ) 
{ 


  {
  (*(port->sm))((void *)port, 6);
  return;
}
}
void bfa_fcs_lport_delete(struct bfa_fcs_lport_s *port ) 
{ 


  {
  (*(port->sm))((void *)port, 4);
  return;
}
}
enum bfa_boolean bfa_fcs_lport_is_online(struct bfa_fcs_lport_s *port ) 
{ 


  {
  return ((unsigned long )port->sm == (unsigned long )((void (*)(void * , int  ))(& bfa_fcs_lport_sm_online)));
}
}
void bfa_fcs_lport_attach(struct bfa_fcs_lport_s *lport , struct bfa_fcs_s *fcs ,
                          u16 vf_id , struct bfa_fcs_vport_s *vport ) 
{ 


  {
  lport->fcs = fcs;
  lport->fabric = bfa_fcs_vf_lookup(fcs, (int )vf_id);
  lport->vport = vport;
  lport->lp_tag = (unsigned long )vport != (unsigned long )((struct bfa_fcs_vport_s *)0) ? (vport->lps)->bfa_tag : ((lport->fabric)->lps)->bfa_tag;
  INIT_LIST_HEAD(& lport->rport_q);
  lport->num_rports = 0U;
  return;
}
}
void bfa_fcs_lport_init(struct bfa_fcs_lport_s *lport , struct bfa_lport_cfg_s *port_cfg ) 
{ 
  struct bfa_fcs_vport_s *vport ;
  struct bfad_s *bfad ;
  char lpwwn_buf[32U] ;

  {
  vport = lport->vport;
  bfad = (lport->fcs)->bfad;
  lport->port_cfg = *port_cfg;
  lport->bfad_port = bfa_fcb_lport_new((lport->fcs)->bfad, lport, lport->port_cfg.roles,
                                       (lport->fabric)->vf_drv, (unsigned long )vport != (unsigned long )((struct bfa_fcs_vport_s *)0) ? vport->vport_drv : (struct bfad_vport_s *)0);
  wwn2str___2((char *)(& lpwwn_buf), lport->port_cfg.pwwn);
  if (bfa_log_level == 4 || (int )((signed char )*("\016" + 1)) <= 52) {
    dev_printk("\016", (struct device  const  *)(& (bfad->pcidev)->dev), "New logical port created: WWN = %s Role = %s\n",
               (char *)(& lpwwn_buf), (char *)"Initiator");
  } else {

  }
  bfa_fcs_lport_aen_post(lport, 1);
  lport->sm = (void (*)(void * , int  ))(& bfa_fcs_lport_sm_uninit);
  (*(lport->sm))((void *)lport, 1);
  return;
}
}
void bfa_fcs_lport_set_symname(struct bfa_fcs_lport_s *port , char *symname ) 
{ 


  {
  strcpy((char *)(& port->port_cfg.sym_name.symname), (char const   *)symname);
  if ((unsigned long )port->sm == (unsigned long )((void (*)(void * , int  ))(& bfa_fcs_lport_sm_online))) {
    bfa_fcs_lport_ns_util_send_rspn_id((void *)(& port->port_topo.pfab.ns), (struct bfa_fcxp_s *)0);
  } else {

  }
  return;
}
}
void bfa_fcs_lport_get_attr(struct bfa_fcs_lport_s *port , struct bfa_lport_attr_s *port_attr ) 
{ 


  {
  if ((unsigned long )port->sm == (unsigned long )((void (*)(void * , int  ))(& bfa_fcs_lport_sm_online))) {
    port_attr->pid = port->pid;
  } else {
    port_attr->pid = 0U;
  }
  port_attr->port_cfg = port->port_cfg;
  if ((unsigned long )port->fabric != (unsigned long )((struct bfa_fcs_fabric_s *)0)) {
    port_attr->port_type = (port->fabric)->oper_type;
    port_attr->loopback = (unsigned long )(port->fabric)->sm == (unsigned long )((void (*)(void * ,
                                                                                           int  ))(& bfa_fcs_fabric_sm_loopback));
    port_attr->authfail = (unsigned long )(port->fabric)->sm == (unsigned long )((void (*)(void * ,
                                                                                           int  ))(& bfa_fcs_fabric_sm_auth_failed));
    port_attr->fabric_name = (port->fabric)->fabric_name;
    memcpy((void *)(& port_attr->fabric_ip_addr), (void const   *)(& (port->fabric)->fabric_ip_addr),
             16UL);
    if ((unsigned long )port->vport != (unsigned long )((struct bfa_fcs_vport_s *)0)) {
      port_attr->port_type = 22;
      port_attr->fpma_mac = ((port->vport)->lps)->lp_mac;
    } else {
      port_attr->fpma_mac = ((port->fabric)->lps)->lp_mac;
    }
  } else {
    port_attr->port_type = 1;
    port_attr->state = 0;
  }
  return;
}
}
static void bfa_fcs_lport_fab_init(struct bfa_fcs_lport_s *port ) 
{ 


  {
  bfa_fcs_lport_ns_init(port);
  bfa_fcs_lport_scn_init(port);
  bfa_fcs_lport_ms_init(port);
  return;
}
}
static void bfa_fcs_lport_fab_online(struct bfa_fcs_lport_s *port ) 
{ 


  {
  bfa_fcs_lport_ns_online(port);
  bfa_fcs_lport_fab_scn_online(port);
  return;
}
}
static void bfa_fcs_lport_fab_offline(struct bfa_fcs_lport_s *port ) 
{ 


  {
  bfa_fcs_lport_ns_offline(port);
  bfa_fcs_lport_scn_offline(port);
  bfa_fcs_lport_ms_offline(port);
  return;
}
}
static void bfa_fcs_lport_n2n_init(struct bfa_fcs_lport_s *port ) 
{ 


  {
  return;
}
}
static void bfa_fcs_lport_n2n_online(struct bfa_fcs_lport_s *port ) 
{ 
  struct bfa_fcs_lport_n2n_s *n2n_port ;
  struct bfa_lport_cfg_s *pcfg ;
  struct bfa_fcs_rport_s *rport ;
  int __ret_warn_on ;
  long tmp ;
  int tmp___0 ;

  {
  n2n_port = & port->port_topo.pn2n;
  pcfg = & port->port_cfg;
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 1224, pcfg->pwwn);
  tmp___0 = memcmp((void const   *)(& pcfg->pwwn), (void const   *)(& n2n_port->rem_port_wwn),
                   8UL);
  if (tmp___0 > 0) {
    port->pid = 65536U;
    bfa_lps_set_n2n_pid((port->fabric)->lps, 65536U);
    rport = bfa_fcs_lport_get_rport_by_pwwn(port, n2n_port->rem_port_wwn);
    if ((unsigned long )rport != (unsigned long )((struct bfa_fcs_rport_s *)0)) {
      __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 1245, (unsigned long long )rport->pid);
      __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 1246, rport->pwwn);
      rport->pid = 131072U;
      (*(rport->sm))((void *)rport, 1);
      return;
    } else {

    }
    if ((unsigned int )port->num_rports != 0U) {
      rport = bfa_fcs_lport_get_rport_by_pid(port, 0U);
      __ret_warn_on = (unsigned long )rport == (unsigned long )((struct bfa_fcs_rport_s *)0);
      tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
      if (tmp != 0L) {
        warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcs_lport.c",
                           1258);
      } else {

      }
      ldv__builtin_expect(__ret_warn_on != 0, 0L);
      if ((unsigned long )rport != (unsigned long )((struct bfa_fcs_rport_s *)0)) {
        __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 1260, rport->pwwn);
        (*(rport->sm))((void *)rport, 7);
      } else {

      }
    } else {

    }
    bfa_fcs_rport_create(port, 131072U);
  } else {

  }
  return;
}
}
static void bfa_fcs_lport_n2n_offline(struct bfa_fcs_lport_s *port ) 
{ 
  struct bfa_fcs_lport_n2n_s *n2n_port ;

  {
  n2n_port = & port->port_topo.pn2n;
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 1276, (unsigned long long )port->pid);
  port->pid = 0U;
  n2n_port->rem_port_wwn = 0ULL;
  n2n_port->reply_oxid = 0U;
  return;
}
}
void bfa_fcport_get_loop_attr(struct bfa_fcs_lport_s *port ) 
{ 
  int i ;
  int j ;
  int bit ;
    klee_make_symbolic(&bit, sizeof(int), "bit");
  int alpa_bit ;
    klee_make_symbolic(&alpa_bit, sizeof(int), "alpa_bit");
  u8 k ;
  struct bfa_fcport_s *fcport ;

  {
  i = 0;
  j = 0;
  bit = 0;
  alpa_bit = 0;
  k = 0U;
  fcport = & ((port->fcs)->bfa)->modules.fcport;
  port->port_topo.ploop.alpabm_valid = fcport->alpabm_valid;
  port->pid = (unsigned int )fcport->myalpa;
  port->pid = (unsigned int )(((((int )port->pid & 255) << 16) | ((int )port->pid & 65280)) | (((int )port->pid & 16711680) >> 16));
  i = 0;
  goto ldv_49104;
  ldv_49103: 
  j = 0;
  alpa_bit = 0;
  goto ldv_49101;
  ldv_49100: 
  __bfa_trc(((port->fcs)->bfa)->trcmod, __trc_fileno___7, 1295, (unsigned long long )fcport->alpabm.alpa_bm[i]);
  bit = (int )fcport->alpabm.alpa_bm[i] & (1 << (7 - j));
  if (bit != 0) {
    port->port_topo.ploop.alpa_pos_map[(int )k] = loop_alpa_map[i * 8 + alpa_bit];
    k = (u8 )((int )k + 1);
    __bfa_trc(((port->fcs)->bfa)->trcmod, __trc_fileno___7, 1301, (unsigned long long )k);
    __bfa_trc(((port->fcs)->bfa)->trcmod, __trc_fileno___7, 1303, (unsigned long long )port->port_topo.ploop.alpa_pos_map[(int )k]);
  } else {

  }
  j = j + 1;
  alpa_bit = alpa_bit + 1;
  ldv_49101: ;
  if (j <= 7) {
    goto ldv_49100;
  } else {

  }
  i = i + 1;
  ldv_49104: ;
  if (i <= 15) {
    goto ldv_49103;
  } else {

  }
  port->port_topo.ploop.num_alpa = k;
  return;
}
}
static void bfa_fcs_lport_loop_init(struct bfa_fcs_lport_s *port ) 
{ 


  {
  return;
}
}
static void bfa_fcs_lport_loop_online(struct bfa_fcs_lport_s *port ) 
{ 
  u8 num_alpa ;
  u8 alpabm_valid ;
  struct bfa_fcs_rport_s *rport ;
  u8 *alpa_map ;
  int i ;
  u32 pid ;

  {
  num_alpa = 0U;
  alpabm_valid = 0U;
  alpa_map = (u8 *)0U;
  i = 0;
  bfa_fcport_get_loop_attr(port);
  num_alpa = port->port_topo.ploop.num_alpa;
  alpabm_valid = port->port_topo.ploop.alpabm_valid;
  alpa_map = (u8 *)(& port->port_topo.ploop.alpa_pos_map);
  __bfa_trc(((port->fcs)->bfa)->trcmod, __trc_fileno___7, 1336, (unsigned long long )port->pid);
  __bfa_trc(((port->fcs)->bfa)->trcmod, __trc_fileno___7, 1337, (unsigned long long )num_alpa);
  if ((unsigned int )alpabm_valid == 1U) {
    i = 0;
    goto ldv_49119;
    ldv_49118: 
    __bfa_trc(((port->fcs)->bfa)->trcmod, __trc_fileno___7, 1340, (unsigned long long )*(alpa_map + (unsigned long )i));
    if ((int )*(alpa_map + (unsigned long )i) != (((((int )port->pid & 255) << 16) | ((int )port->pid & 65280)) | (((int )port->pid & 16711680) >> 16))) {
      pid = (u32 )*(alpa_map + (unsigned long )i);
      __bfa_trc(((port->fcs)->bfa)->trcmod, __trc_fileno___7, 1343, (unsigned long long )pid);
      rport = bfa_fcs_lport_get_rport_by_pid(port, (((pid & 255U) << 16) | (pid & 65280U)) | ((pid & 16711680U) >> 16));
      if ((unsigned long )rport == (unsigned long )((struct bfa_fcs_rport_s *)0)) {
        rport = bfa_fcs_rport_create(port, (((pid & 255U) << 16) | (pid & 65280U)) | ((pid & 16711680U) >> 16));
      } else {

      }
    } else {

    }
    i = i + 1;
    ldv_49119: ;
    if ((int )num_alpa > i) {
      goto ldv_49118;
    } else {

    }

  } else {
    i = 0;
    goto ldv_49122;
    ldv_49121: ;
    if ((int )*(alpa_map + (unsigned long )i) != (int )port->pid) {
      pid = (u32 )loop_alpa_map[i];
      __bfa_trc(((port->fcs)->bfa)->trcmod, __trc_fileno___7, 1355, (unsigned long long )pid);
      rport = bfa_fcs_lport_get_rport_by_pid(port, (((pid & 255U) << 16) | (pid & 65280U)) | ((pid & 16711680U) >> 16));
      if ((unsigned long )rport == (unsigned long )((struct bfa_fcs_rport_s *)0)) {
        rport = bfa_fcs_rport_create(port, (((pid & 255U) << 16) | (pid & 65280U)) | ((pid & 16711680U) >> 16));
      } else {

      }
    } else {

    }
    i = i + 1;
    ldv_49122: ;
    if (i <= 126) {
      goto ldv_49121;
    } else {

    }

  }
  return;
}
}
static void bfa_fcs_lport_loop_offline(struct bfa_fcs_lport_s *port ) 
{ 


  {
  return;
}
}
static void bfa_fcs_lport_fdmi_send_rhba(void *fdmi_cbarg , struct bfa_fcxp_s *fcxp_alloced ) ;
static void bfa_fcs_lport_fdmi_send_rprt(void *fdmi_cbarg , struct bfa_fcxp_s *fcxp_alloced ) ;
static void bfa_fcs_lport_fdmi_send_rpa(void *fdmi_cbarg , struct bfa_fcxp_s *fcxp_alloced ) ;
static void bfa_fcs_lport_fdmi_rhba_response(void *fcsarg , struct bfa_fcxp_s *fcxp ,
                                             void *cbarg , enum bfa_status req_status ,
                                             u32 rsp_len , u32 resid_len , struct fchs_s *rsp_fchs ) ;
static void bfa_fcs_lport_fdmi_rprt_response(void *fcsarg , struct bfa_fcxp_s *fcxp ,
                                             void *cbarg , enum bfa_status req_status ,
                                             u32 rsp_len , u32 resid_len , struct fchs_s *rsp_fchs ) ;
static void bfa_fcs_lport_fdmi_rpa_response(void *fcsarg , struct bfa_fcxp_s *fcxp ,
                                            void *cbarg , enum bfa_status req_status ,
                                            u32 rsp_len , u32 resid_len , struct fchs_s *rsp_fchs ) ;
static void bfa_fcs_lport_fdmi_timeout(void *arg ) ;
static u16 bfa_fcs_lport_fdmi_build_rhba_pyld(struct bfa_fcs_lport_fdmi_s *fdmi ,
                                              u8 *pyld ) ;
static u16 bfa_fcs_lport_fdmi_build_rprt_pyld(struct bfa_fcs_lport_fdmi_s *fdmi ,
                                              u8 *pyld ) ;
static u16 bfa_fcs_lport_fdmi_build_rpa_pyld(struct bfa_fcs_lport_fdmi_s *fdmi , u8 *pyld ) ;
static u16 bfa_fcs_lport_fdmi_build_portattr_block(struct bfa_fcs_lport_fdmi_s *fdmi ,
                                                   u8 *pyld ) ;
static void bfa_fcs_fdmi_get_hbaattr(struct bfa_fcs_lport_fdmi_s *fdmi , struct bfa_fcs_fdmi_hba_attr_s *hba_attr ) ;
static void bfa_fcs_fdmi_get_portattr(struct bfa_fcs_lport_fdmi_s *fdmi , struct bfa_fcs_fdmi_port_attr_s *port_attr ) ;
u32 bfa_fcs_fdmi_convert_speed(enum bfa_port_speed pport_speed ) ;
static void bfa_fcs_lport_fdmi_sm_offline(struct bfa_fcs_lport_fdmi_s *fdmi , enum port_fdmi_event event ) ;
static void bfa_fcs_lport_fdmi_sm_sending_rhba(struct bfa_fcs_lport_fdmi_s *fdmi ,
                                               enum port_fdmi_event event ) ;
static void bfa_fcs_lport_fdmi_sm_rhba(struct bfa_fcs_lport_fdmi_s *fdmi , enum port_fdmi_event event ) ;
static void bfa_fcs_lport_fdmi_sm_rhba_retry(struct bfa_fcs_lport_fdmi_s *fdmi , enum port_fdmi_event event ) ;
static void bfa_fcs_lport_fdmi_sm_sending_rprt(struct bfa_fcs_lport_fdmi_s *fdmi ,
                                               enum port_fdmi_event event ) ;
static void bfa_fcs_lport_fdmi_sm_rprt(struct bfa_fcs_lport_fdmi_s *fdmi , enum port_fdmi_event event ) ;
static void bfa_fcs_lport_fdmi_sm_rprt_retry(struct bfa_fcs_lport_fdmi_s *fdmi , enum port_fdmi_event event ) ;
static void bfa_fcs_lport_fdmi_sm_sending_rpa(struct bfa_fcs_lport_fdmi_s *fdmi ,
                                              enum port_fdmi_event event ) ;
static void bfa_fcs_lport_fdmi_sm_rpa(struct bfa_fcs_lport_fdmi_s *fdmi , enum port_fdmi_event event ) ;
static void bfa_fcs_lport_fdmi_sm_rpa_retry(struct bfa_fcs_lport_fdmi_s *fdmi , enum port_fdmi_event event ) ;
static void bfa_fcs_lport_fdmi_sm_online(struct bfa_fcs_lport_fdmi_s *fdmi , enum port_fdmi_event event ) ;
static void bfa_fcs_lport_fdmi_sm_disabled(struct bfa_fcs_lport_fdmi_s *fdmi , enum port_fdmi_event event ) ;
static void bfa_fcs_lport_fdmi_sm_offline(struct bfa_fcs_lport_fdmi_s *fdmi , enum port_fdmi_event event ) 
{ 
  struct bfa_fcs_lport_s *port ;

  {
  port = (fdmi->ms)->port;
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 1479, port->port_cfg.pwwn);
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 1480, (unsigned long long )event);
  fdmi->retry_cnt = 0U;
  switch ((unsigned int )event) {
  case 1U: ;
  if ((unsigned long )port->vport != (unsigned long )((struct bfa_fcs_vport_s *)0)) {
    fdmi->sm = (void (*)(void * , int  ))(& bfa_fcs_lport_fdmi_sm_sending_rprt);
    bfa_fcs_lport_fdmi_send_rprt((void *)fdmi, (struct bfa_fcxp_s *)0);
  } else {
    fdmi->sm = (void (*)(void * , int  ))(& bfa_fcs_lport_fdmi_sm_sending_rhba);
    bfa_fcs_lport_fdmi_send_rhba((void *)fdmi, (struct bfa_fcxp_s *)0);
  }
  goto ldv_49233;
  case 2U: ;
  goto ldv_49233;
  default: 
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 1509, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcs_lport.c",
         1509, (unsigned int )event);
  }
  ldv_49233: ;
  return;
}
}
static void bfa_fcs_lport_fdmi_sm_sending_rhba(struct bfa_fcs_lport_fdmi_s *fdmi ,
                                               enum port_fdmi_event event ) 
{ 
  struct bfa_fcs_lport_s *port ;

  {
  port = (fdmi->ms)->port;
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 1519, port->port_cfg.pwwn);
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 1520, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 7U: 
  fdmi->sm = (void (*)(void * , int  ))(& bfa_fcs_lport_fdmi_sm_rhba);
  goto ldv_49242;
  case 2U: 
  fdmi->sm = (void (*)(void * , int  ))(& bfa_fcs_lport_fdmi_sm_offline);
  bfa_fcxp_walloc_cancel((port->fcs)->bfa, & fdmi->fcxp_wqe);
  goto ldv_49242;
  default: 
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 1534, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcs_lport.c",
         1534, (unsigned int )event);
  }
  ldv_49242: ;
  return;
}
}
static void bfa_fcs_lport_fdmi_sm_rhba(struct bfa_fcs_lport_fdmi_s *fdmi , enum port_fdmi_event event ) 
{ 
  struct bfa_fcs_lport_s *port ;
  u8 tmp ;

  {
  port = (fdmi->ms)->port;
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 1544, port->port_cfg.pwwn);
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 1545, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 5U: 
  tmp = fdmi->retry_cnt;
  fdmi->retry_cnt = (u8 )((int )fdmi->retry_cnt + 1);
  if ((unsigned int )tmp <= 1U) {
    fdmi->sm = (void (*)(void * , int  ))(& bfa_fcs_lport_fdmi_sm_rhba_retry);
    bfa_timer_begin(& ((port->fcs)->bfa)->timer_mod, & fdmi->timer, & bfa_fcs_lport_fdmi_timeout,
                    (void *)fdmi, 2000U);
  } else {
    fdmi->sm = (void (*)(void * , int  ))(& bfa_fcs_lport_fdmi_sm_offline);
  }
  goto ldv_49251;
  case 4U: 
  fdmi->sm = (void (*)(void * , int  ))(& bfa_fcs_lport_fdmi_sm_sending_rpa);
  fdmi->retry_cnt = 0U;
  bfa_fcs_lport_fdmi_send_rpa((void *)fdmi, (struct bfa_fcxp_s *)0);
  goto ldv_49251;
  case 2U: 
  bfa_fcxp_discard(fdmi->fcxp);
  fdmi->sm = (void (*)(void * , int  ))(& bfa_fcs_lport_fdmi_sm_offline);
  goto ldv_49251;
  default: 
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 1583, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcs_lport.c",
         1583, (unsigned int )event);
  }
  ldv_49251: ;
  return;
}
}
static void bfa_fcs_lport_fdmi_sm_rhba_retry(struct bfa_fcs_lport_fdmi_s *fdmi , enum port_fdmi_event event ) 
{ 
  struct bfa_fcs_lport_s *port ;

  {
  port = (fdmi->ms)->port;
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 1593, port->port_cfg.pwwn);
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 1594, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 6U: 
  fdmi->sm = (void (*)(void * , int  ))(& bfa_fcs_lport_fdmi_sm_sending_rhba);
  bfa_fcs_lport_fdmi_send_rhba((void *)fdmi, (struct bfa_fcxp_s *)0);
  goto ldv_49261;
  case 2U: 
  fdmi->sm = (void (*)(void * , int  ))(& bfa_fcs_lport_fdmi_sm_offline);
  bfa_timer_stop(& fdmi->timer);
  goto ldv_49261;
  default: 
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 1611, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcs_lport.c",
         1611, (unsigned int )event);
  }
  ldv_49261: ;
  return;
}
}
static void bfa_fcs_lport_fdmi_sm_sending_rprt(struct bfa_fcs_lport_fdmi_s *fdmi ,
                                               enum port_fdmi_event event ) 
{ 
  struct bfa_fcs_lport_s *port ;

  {
  port = (fdmi->ms)->port;
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 1624, port->port_cfg.pwwn);
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 1625, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 8U: 
  fdmi->sm = (void (*)(void * , int  ))(& bfa_fcs_lport_fdmi_sm_rprt);
  goto ldv_49270;
  case 2U: 
  fdmi->sm = (void (*)(void * , int  ))(& bfa_fcs_lport_fdmi_sm_offline);
  bfa_fcxp_walloc_cancel((port->fcs)->bfa, & fdmi->fcxp_wqe);
  goto ldv_49270;
  default: 
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 1639, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcs_lport.c",
         1639, (unsigned int )event);
  }
  ldv_49270: ;
  return;
}
}
static void bfa_fcs_lport_fdmi_sm_rprt(struct bfa_fcs_lport_fdmi_s *fdmi , enum port_fdmi_event event ) 
{ 
  struct bfa_fcs_lport_s *port ;
  u8 tmp ;

  {
  port = (fdmi->ms)->port;
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 1649, port->port_cfg.pwwn);
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 1650, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 5U: 
  tmp = fdmi->retry_cnt;
  fdmi->retry_cnt = (u8 )((int )fdmi->retry_cnt + 1);
  if ((unsigned int )tmp <= 1U) {
    fdmi->sm = (void (*)(void * , int  ))(& bfa_fcs_lport_fdmi_sm_rprt_retry);
    bfa_timer_begin(& ((port->fcs)->bfa)->timer_mod, & fdmi->timer, & bfa_fcs_lport_fdmi_timeout,
                    (void *)fdmi, 2000U);
  } else {
    fdmi->sm = (void (*)(void * , int  ))(& bfa_fcs_lport_fdmi_sm_offline);
    fdmi->retry_cnt = 0U;
  }
  goto ldv_49279;
  case 4U: 
  fdmi->retry_cnt = 0U;
  fdmi->sm = (void (*)(void * , int  ))(& bfa_fcs_lport_fdmi_sm_online);
  goto ldv_49279;
  case 2U: 
  bfa_fcxp_discard(fdmi->fcxp);
  fdmi->sm = (void (*)(void * , int  ))(& bfa_fcs_lport_fdmi_sm_offline);
  goto ldv_49279;
  default: 
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 1686, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcs_lport.c",
         1686, (unsigned int )event);
  }
  ldv_49279: ;
  return;
}
}
static void bfa_fcs_lport_fdmi_sm_rprt_retry(struct bfa_fcs_lport_fdmi_s *fdmi , enum port_fdmi_event event ) 
{ 
  struct bfa_fcs_lport_s *port ;

  {
  port = (fdmi->ms)->port;
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 1696, port->port_cfg.pwwn);
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 1697, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 6U: 
  fdmi->sm = (void (*)(void * , int  ))(& bfa_fcs_lport_fdmi_sm_sending_rprt);
  bfa_fcs_lport_fdmi_send_rprt((void *)fdmi, (struct bfa_fcxp_s *)0);
  goto ldv_49289;
  case 2U: 
  fdmi->sm = (void (*)(void * , int  ))(& bfa_fcs_lport_fdmi_sm_offline);
  bfa_timer_stop(& fdmi->timer);
  goto ldv_49289;
  default: 
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 1714, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcs_lport.c",
         1714, (unsigned int )event);
  }
  ldv_49289: ;
  return;
}
}
static void bfa_fcs_lport_fdmi_sm_sending_rpa(struct bfa_fcs_lport_fdmi_s *fdmi ,
                                              enum port_fdmi_event event ) 
{ 
  struct bfa_fcs_lport_s *port ;

  {
  port = (fdmi->ms)->port;
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 1727, port->port_cfg.pwwn);
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 1728, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 9U: 
  fdmi->sm = (void (*)(void * , int  ))(& bfa_fcs_lport_fdmi_sm_rpa);
  goto ldv_49298;
  case 2U: 
  fdmi->sm = (void (*)(void * , int  ))(& bfa_fcs_lport_fdmi_sm_offline);
  bfa_fcxp_walloc_cancel((port->fcs)->bfa, & fdmi->fcxp_wqe);
  goto ldv_49298;
  default: 
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 1742, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcs_lport.c",
         1742, (unsigned int )event);
  }
  ldv_49298: ;
  return;
}
}
static void bfa_fcs_lport_fdmi_sm_rpa(struct bfa_fcs_lport_fdmi_s *fdmi , enum port_fdmi_event event ) 
{ 
  struct bfa_fcs_lport_s *port ;
  u8 tmp ;

  {
  port = (fdmi->ms)->port;
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 1752, port->port_cfg.pwwn);
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 1753, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 5U: 
  tmp = fdmi->retry_cnt;
  fdmi->retry_cnt = (u8 )((int )fdmi->retry_cnt + 1);
  if ((unsigned int )tmp <= 1U) {
    fdmi->sm = (void (*)(void * , int  ))(& bfa_fcs_lport_fdmi_sm_rpa_retry);
    bfa_timer_begin(& ((port->fcs)->bfa)->timer_mod, & fdmi->timer, & bfa_fcs_lport_fdmi_timeout,
                    (void *)fdmi, 2000U);
  } else {
    fdmi->sm = (void (*)(void * , int  ))(& bfa_fcs_lport_fdmi_sm_offline);
    fdmi->retry_cnt = 0U;
  }
  goto ldv_49307;
  case 4U: 
  fdmi->sm = (void (*)(void * , int  ))(& bfa_fcs_lport_fdmi_sm_online);
  fdmi->retry_cnt = 0U;
  goto ldv_49307;
  case 2U: 
  bfa_fcxp_discard(fdmi->fcxp);
  fdmi->sm = (void (*)(void * , int  ))(& bfa_fcs_lport_fdmi_sm_offline);
  goto ldv_49307;
  default: 
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 1787, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcs_lport.c",
         1787, (unsigned int )event);
  }
  ldv_49307: ;
  return;
}
}
static void bfa_fcs_lport_fdmi_sm_rpa_retry(struct bfa_fcs_lport_fdmi_s *fdmi , enum port_fdmi_event event ) 
{ 
  struct bfa_fcs_lport_s *port ;

  {
  port = (fdmi->ms)->port;
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 1797, port->port_cfg.pwwn);
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 1798, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 6U: 
  fdmi->sm = (void (*)(void * , int  ))(& bfa_fcs_lport_fdmi_sm_sending_rpa);
  bfa_fcs_lport_fdmi_send_rpa((void *)fdmi, (struct bfa_fcxp_s *)0);
  goto ldv_49317;
  case 2U: 
  fdmi->sm = (void (*)(void * , int  ))(& bfa_fcs_lport_fdmi_sm_offline);
  bfa_timer_stop(& fdmi->timer);
  goto ldv_49317;
  default: 
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 1815, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcs_lport.c",
         1815, (unsigned int )event);
  }
  ldv_49317: ;
  return;
}
}
static void bfa_fcs_lport_fdmi_sm_online(struct bfa_fcs_lport_fdmi_s *fdmi , enum port_fdmi_event event ) 
{ 
  struct bfa_fcs_lport_s *port ;

  {
  port = (fdmi->ms)->port;
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 1825, port->port_cfg.pwwn);
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 1826, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 2U: 
  fdmi->sm = (void (*)(void * , int  ))(& bfa_fcs_lport_fdmi_sm_offline);
  goto ldv_49326;
  default: 
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 1834, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcs_lport.c",
         1834, (unsigned int )event);
  }
  ldv_49326: ;
  return;
}
}
static void bfa_fcs_lport_fdmi_sm_disabled(struct bfa_fcs_lport_fdmi_s *fdmi , enum port_fdmi_event event ) 
{ 
  struct bfa_fcs_lport_s *port ;

  {
  port = (fdmi->ms)->port;
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 1846, port->port_cfg.pwwn);
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 1847, (unsigned long long )event);
  return;
}
}
static void bfa_fcs_lport_fdmi_send_rhba(void *fdmi_cbarg , struct bfa_fcxp_s *fcxp_alloced ) 
{ 
  struct bfa_fcs_lport_fdmi_s *fdmi ;
  struct bfa_fcs_lport_s *port ;
  struct fchs_s fchs ;
  int len ;
  int attr_len ;
    klee_make_symbolic(&attr_len, sizeof(int), "attr_len");
  struct bfa_fcxp_s *fcxp ;
  u8 *pyld ;
  struct bfa_fcxp_s *tmp ;
  void *tmp___0 ;
  u16 tmp___1 ;
  u16 tmp___2 ;

  {
  fdmi = (struct bfa_fcs_lport_fdmi_s *)fdmi_cbarg;
  port = (fdmi->ms)->port;
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 1865, port->port_cfg.pwwn);
  if ((unsigned long )fcxp_alloced == (unsigned long )((struct bfa_fcxp_s *)0)) {
    tmp = bfa_fcxp_req_rsp_alloc((void *)0, (port->fcs)->bfa, 0, 0, (u64 (*)(void * ,
                                                                             int  ))0,
                                 (u32 (*)(void * , int  ))0, (u64 (*)(void * , int  ))0,
                                 (u32 (*)(void * , int  ))0, 1);
    fcxp = tmp;
  } else {
    fcxp = fcxp_alloced;
  }
  if ((unsigned long )fcxp == (unsigned long )((struct bfa_fcxp_s *)0)) {
    bfa_fcxp_req_rsp_alloc_wait((port->fcs)->bfa, & fdmi->fcxp_wqe, & bfa_fcs_lport_fdmi_send_rhba,
                                (void *)fdmi, (void *)0, 0, 0, (u64 (*)(void * , int  ))0,
                                (u32 (*)(void * , int  ))0, (u64 (*)(void * , int  ))0,
                                (u32 (*)(void * , int  ))0, 1);
    return;
  } else {

  }
  fdmi->fcxp = fcxp;
  tmp___0 = bfa_fcxp_get_reqbuf(fcxp);
  pyld = (u8 *)tmp___0;
  memset((void *)pyld, 0, 2112UL);
  tmp___1 = fc_fdmi_reqhdr_build(& fchs, (void *)pyld, port->pid, 512);
  len = (int )tmp___1;
  tmp___2 = bfa_fcs_lport_fdmi_build_rhba_pyld(fdmi, pyld + 1U);
  attr_len = (int )tmp___2;
  bfa_fcxp_send(fcxp, (struct bfa_rport_s *)0, (int )(port->fabric)->vf_id, (int )port->lp_tag,
                0, 8, (u32 )(len + attr_len), & fchs, & bfa_fcs_lport_fdmi_rhba_response,
                (void *)fdmi, 2112U, 30);
  (*(fdmi->sm))((void *)fdmi, 7);
  return;
}
}
static u16 bfa_fcs_lport_fdmi_build_rhba_pyld(struct bfa_fcs_lport_fdmi_s *fdmi ,
                                              u8 *pyld ) 
{ 
  struct bfa_fcs_lport_s *port ;
  struct bfa_fcs_fdmi_hba_attr_s hba_attr ;
  struct bfa_fcs_fdmi_hba_attr_s *fcs_hba_attr ;
  struct fdmi_rhba_s *rhba ;
  struct fdmi_attr_s *attr ;
  u8 *curr_ptr ;
  u16 len ;
  u16 count ;
  u16 templen ;
  __u16 tmp ;
  size_t tmp___0 ;
  __u16 tmp___1 ;
  size_t tmp___2 ;
  __u16 tmp___3 ;
  size_t tmp___4 ;
  __u16 tmp___5 ;
  size_t tmp___6 ;
  __u16 tmp___7 ;
  size_t tmp___8 ;
  __u16 tmp___9 ;
  size_t tmp___10 ;
  __u16 tmp___11 ;
  size_t tmp___12 ;
  __u16 tmp___13 ;
  size_t tmp___14 ;
  __u16 tmp___15 ;
  size_t tmp___16 ;
  __u16 tmp___17 ;
  __u16 tmp___18 ;
  __u16 tmp___19 ;
  __u16 tmp___20 ;
  __u16 tmp___21 ;
  __u16 tmp___22 ;
  __u16 tmp___23 ;
  __u32 tmp___24 ;

  {
  port = (fdmi->ms)->port;
  fcs_hba_attr = & hba_attr;
  rhba = (struct fdmi_rhba_s *)pyld;
  bfa_fcs_fdmi_get_hbaattr(fdmi, fcs_hba_attr);
  rhba->hba_id = port->port_cfg.pwwn;
  rhba->port_list.num_ports = 16777216U;
  rhba->port_list.port_entry = port->port_cfg.pwwn;
  len = 20U;
  count = 0U;
  len = (unsigned int )len + 4U;
  curr_ptr = (u8 *)(& rhba->hba_attr_blk.hba_attr);
  attr = (struct fdmi_attr_s *)curr_ptr;
  attr->type = 256U;
  templen = 8U;
  memcpy((void *)(& attr->value), (void const   *)(& port->port_cfg.nwwn), (size_t )templen);
  curr_ptr = curr_ptr + ((unsigned long )templen + 4UL);
  len = (int )len + (int )templen;
  count = (u16 )((int )count + 1);
  tmp = __fswab16((int )((unsigned int )templen + 4U));
  attr->len = tmp;
  attr = (struct fdmi_attr_s *)curr_ptr;
  attr->type = 512U;
  tmp___0 = strlen((char const   *)(& fcs_hba_attr->manufacturer));
  templen = (unsigned short )tmp___0;
  memcpy((void *)(& attr->value), (void const   *)(& fcs_hba_attr->manufacturer),
           (size_t )templen);
  templen = ((unsigned int )templen + 3U) & 65532U;
  curr_ptr = curr_ptr + ((unsigned long )templen + 4UL);
  len = (int )len + (int )templen;
  count = (u16 )((int )count + 1);
  tmp___1 = __fswab16((int )((unsigned int )templen + 4U));
  attr->len = tmp___1;
  attr = (struct fdmi_attr_s *)curr_ptr;
  attr->type = 768U;
  tmp___2 = strlen((char const   *)(& fcs_hba_attr->serial_num));
  templen = (unsigned short )tmp___2;
  memcpy((void *)(& attr->value), (void const   *)(& fcs_hba_attr->serial_num),
           (size_t )templen);
  templen = ((unsigned int )templen + 3U) & 65532U;
  curr_ptr = curr_ptr + ((unsigned long )templen + 4UL);
  len = (int )len + (int )templen;
  count = (u16 )((int )count + 1);
  tmp___3 = __fswab16((int )((unsigned int )templen + 4U));
  attr->len = tmp___3;
  attr = (struct fdmi_attr_s *)curr_ptr;
  attr->type = 1024U;
  tmp___4 = strlen((char const   *)(& fcs_hba_attr->model));
  templen = (unsigned short )tmp___4;
  memcpy((void *)(& attr->value), (void const   *)(& fcs_hba_attr->model), (size_t )templen);
  templen = ((unsigned int )templen + 3U) & 65532U;
  curr_ptr = curr_ptr + ((unsigned long )templen + 4UL);
  len = (int )len + (int )templen;
  count = (u16 )((int )count + 1);
  tmp___5 = __fswab16((int )((unsigned int )templen + 4U));
  attr->len = tmp___5;
  attr = (struct fdmi_attr_s *)curr_ptr;
  attr->type = 1280U;
  tmp___6 = strlen((char const   *)(& fcs_hba_attr->model_desc));
  templen = (unsigned short )tmp___6;
  memcpy((void *)(& attr->value), (void const   *)(& fcs_hba_attr->model_desc),
           (size_t )templen);
  templen = ((unsigned int )templen + 3U) & 65532U;
  curr_ptr = curr_ptr + ((unsigned long )templen + 4UL);
  len = (int )len + (int )templen;
  count = (u16 )((int )count + 1);
  tmp___7 = __fswab16((int )((unsigned int )templen + 4U));
  attr->len = tmp___7;
  if ((unsigned int )fcs_hba_attr->hw_version[0] != 0U) {
    attr = (struct fdmi_attr_s *)curr_ptr;
    attr->type = 1536U;
    tmp___8 = strlen((char const   *)(& fcs_hba_attr->hw_version));
    templen = (unsigned short )tmp___8;
    memcpy((void *)(& attr->value), (void const   *)(& fcs_hba_attr->hw_version),
             (size_t )templen);
    templen = ((unsigned int )templen + 3U) & 65532U;
    curr_ptr = curr_ptr + ((unsigned long )templen + 4UL);
    len = (int )len + (int )templen;
    count = (u16 )((int )count + 1);
    tmp___9 = __fswab16((int )((unsigned int )templen + 4U));
    attr->len = tmp___9;
  } else {

  }
  attr = (struct fdmi_attr_s *)curr_ptr;
  attr->type = 1792U;
  tmp___10 = strlen((char const   *)(& fcs_hba_attr->driver_version));
  templen = (unsigned short )tmp___10;
  memcpy((void *)(& attr->value), (void const   *)(& fcs_hba_attr->driver_version),
           (size_t )templen);
  templen = ((unsigned int )templen + 3U) & 65532U;
  curr_ptr = curr_ptr + ((unsigned long )templen + 4UL);
  len = (int )len + (int )templen;
  count = (u16 )((int )count + 1);
  tmp___11 = __fswab16((int )((unsigned int )templen + 4U));
  attr->len = tmp___11;
  if ((unsigned int )fcs_hba_attr->option_rom_ver[0] != 0U) {
    attr = (struct fdmi_attr_s *)curr_ptr;
    attr->type = 2048U;
    tmp___12 = strlen((char const   *)(& fcs_hba_attr->option_rom_ver));
    templen = (unsigned short )tmp___12;
    memcpy((void *)(& attr->value), (void const   *)(& fcs_hba_attr->option_rom_ver),
             (size_t )templen);
    templen = ((unsigned int )templen + 3U) & 65532U;
    curr_ptr = curr_ptr + ((unsigned long )templen + 4UL);
    len = (int )len + (int )templen;
    count = (u16 )((int )count + 1);
    tmp___13 = __fswab16((int )((unsigned int )templen + 4U));
    attr->len = tmp___13;
  } else {

  }
  attr = (struct fdmi_attr_s *)curr_ptr;
  attr->type = 2304U;
  tmp___14 = strlen((char const   *)(& fcs_hba_attr->fw_version));
  templen = (unsigned short )tmp___14;
  memcpy((void *)(& attr->value), (void const   *)(& fcs_hba_attr->fw_version),
           (size_t )templen);
  templen = ((unsigned int )templen + 3U) & 65532U;
  curr_ptr = curr_ptr + ((unsigned long )templen + 4UL);
  len = (int )len + (int )templen;
  count = (u16 )((int )count + 1);
  tmp___15 = __fswab16((int )((unsigned int )templen + 4U));
  attr->len = tmp___15;
  if ((unsigned int )fcs_hba_attr->os_name[0] != 0U) {
    attr = (struct fdmi_attr_s *)curr_ptr;
    attr->type = 2560U;
    tmp___16 = strlen((char const   *)(& fcs_hba_attr->os_name));
    templen = (unsigned short )tmp___16;
    memcpy((void *)(& attr->value), (void const   *)(& fcs_hba_attr->os_name), (size_t )templen);
    templen = ((unsigned int )templen + 3U) & 65532U;
    curr_ptr = curr_ptr + ((unsigned long )templen + 4UL);
    len = (int )len + (int )templen;
    count = (u16 )((int )count + 1);
    tmp___17 = __fswab16((int )((unsigned int )templen + 4U));
    attr->len = tmp___17;
  } else {

  }
  attr = (struct fdmi_attr_s *)curr_ptr;
  attr->type = 2816U;
  templen = 4U;
  memcpy((void *)(& attr->value), (void const   *)(& fcs_hba_attr->max_ct_pyld),
           (size_t )templen);
  templen = ((unsigned int )templen + 3U) & 65532U;
  curr_ptr = curr_ptr + ((unsigned long )templen + 4UL);
  len = (int )len + (int )templen;
  count = (u16 )((int )count + 1);
  tmp___18 = __fswab16((int )((unsigned int )templen + 4U));
  attr->len = tmp___18;
  if ((unsigned int )fdmi->retry_cnt == 0U) {
    attr = (struct fdmi_attr_s *)curr_ptr;
    attr->type = 3072U;
    templen = 128U;
    memcpy((void *)(& attr->value), (void const   *)(& fcs_hba_attr->node_sym_name),
             (size_t )templen);
    templen = ((unsigned int )templen + 3U) & 65532U;
    curr_ptr = curr_ptr + ((unsigned long )templen + 4UL);
    len = (int )len + (int )templen;
    count = (u16 )((int )count + 1);
    tmp___19 = __fswab16((int )((unsigned int )templen + 4U));
    attr->len = tmp___19;
    attr = (struct fdmi_attr_s *)curr_ptr;
    attr->type = 57344U;
    templen = 8U;
    memcpy((void *)(& attr->value), (void const   *)(& fcs_hba_attr->vendor_info),
             (size_t )templen);
    templen = ((unsigned int )templen + 3U) & 65532U;
    curr_ptr = curr_ptr + ((unsigned long )templen + 4UL);
    len = (int )len + (int )templen;
    count = (u16 )((int )count + 1);
    tmp___20 = __fswab16((int )((unsigned int )templen + 4U));
    attr->len = tmp___20;
    attr = (struct fdmi_attr_s *)curr_ptr;
    attr->type = 3584U;
    templen = 4U;
    memcpy((void *)(& attr->value), (void const   *)(& fcs_hba_attr->num_ports),
             (size_t )templen);
    templen = ((unsigned int )templen + 3U) & 65532U;
    curr_ptr = curr_ptr + ((unsigned long )templen + 4UL);
    len = (int )len + (int )templen;
    count = (u16 )((int )count + 1);
    tmp___21 = __fswab16((int )((unsigned int )templen + 4U));
    attr->len = tmp___21;
    attr = (struct fdmi_attr_s *)curr_ptr;
    attr->type = 3840U;
    templen = 8U;
    memcpy((void *)(& attr->value), (void const   *)(& fcs_hba_attr->fabric_name),
             (size_t )templen);
    templen = ((unsigned int )templen + 3U) & 65532U;
    curr_ptr = curr_ptr + ((unsigned long )templen + 4UL);
    len = (int )len + (int )templen;
    count = (u16 )((int )count + 1);
    tmp___22 = __fswab16((int )((unsigned int )templen + 4U));
    attr->len = tmp___22;
    attr = (struct fdmi_attr_s *)curr_ptr;
    attr->type = 4096U;
    templen = 64U;
    memcpy((void *)(& attr->value), (void const   *)(& fcs_hba_attr->bios_ver),
             (size_t )templen);
    templen = ((unsigned int )attr->len + 3U) & 65532U;
    curr_ptr = curr_ptr + ((unsigned long )templen + 4UL);
    len = (int )len + (int )templen;
    count = (u16 )((int )count + 1);
    tmp___23 = __fswab16((int )((unsigned int )templen + 4U));
    attr->len = tmp___23;
  } else {

  }
  len = (unsigned int )count * 4U + (unsigned int )len;
  tmp___24 = __fswab32((__u32 )count);
  rhba->hba_attr_blk.attr_count = tmp___24;
  return (len);
}
}
static void bfa_fcs_lport_fdmi_rhba_response(void *fcsarg , struct bfa_fcxp_s *fcxp ,
                                             void *cbarg , enum bfa_status req_status ,
                                             u32 rsp_len , u32 resid_len , struct fchs_s *rsp_fchs ) 
{ 
  struct bfa_fcs_lport_fdmi_s *fdmi ;
  struct bfa_fcs_lport_s *port ;
  struct ct_hdr_s *cthdr ;
  void *tmp ;
  __u16 tmp___0 ;

  {
  fdmi = (struct bfa_fcs_lport_fdmi_s *)cbarg;
  port = (fdmi->ms)->port;
  cthdr = (struct ct_hdr_s *)0;
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 2161, port->port_cfg.pwwn);
  if ((unsigned int )req_status != 0U) {
    __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 2167, (unsigned long long )req_status);
    (*(fdmi->sm))((void *)fdmi, 5);
    return;
  } else {

  }
  tmp = bfa_fcxp_get_rspbuf(fcxp);
  cthdr = (struct ct_hdr_s *)tmp;
  tmp___0 = __fswab16((int )cthdr->cmd_rsp_code);
  cthdr->cmd_rsp_code = tmp___0;
  if ((unsigned int )cthdr->cmd_rsp_code == 32770U) {
    (*(fdmi->sm))((void *)fdmi, 4);
    return;
  } else {

  }
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 2180, (unsigned long long )cthdr->reason_code);
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 2181, (unsigned long long )cthdr->exp_code);
  (*(fdmi->sm))((void *)fdmi, 5);
  return;
}
}
static void bfa_fcs_lport_fdmi_send_rprt(void *fdmi_cbarg , struct bfa_fcxp_s *fcxp_alloced ) 
{ 
  struct bfa_fcs_lport_fdmi_s *fdmi ;
  struct bfa_fcs_lport_s *port ;
  struct fchs_s fchs ;
  u16 len ;
  u16 attr_len ;
  struct bfa_fcxp_s *fcxp ;
  u8 *pyld ;
  struct bfa_fcxp_s *tmp ;
  void *tmp___0 ;

  {
  fdmi = (struct bfa_fcs_lport_fdmi_s *)fdmi_cbarg;
  port = (fdmi->ms)->port;
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 2198, port->port_cfg.pwwn);
  if ((unsigned long )fcxp_alloced == (unsigned long )((struct bfa_fcxp_s *)0)) {
    tmp = bfa_fcxp_req_rsp_alloc((void *)0, (port->fcs)->bfa, 0, 0, (u64 (*)(void * ,
                                                                             int  ))0,
                                 (u32 (*)(void * , int  ))0, (u64 (*)(void * , int  ))0,
                                 (u32 (*)(void * , int  ))0, 1);
    fcxp = tmp;
  } else {
    fcxp = fcxp_alloced;
  }
  if ((unsigned long )fcxp == (unsigned long )((struct bfa_fcxp_s *)0)) {
    bfa_fcxp_req_rsp_alloc_wait((port->fcs)->bfa, & fdmi->fcxp_wqe, & bfa_fcs_lport_fdmi_send_rprt,
                                (void *)fdmi, (void *)0, 0, 0, (u64 (*)(void * , int  ))0,
                                (u32 (*)(void * , int  ))0, (u64 (*)(void * , int  ))0,
                                (u32 (*)(void * , int  ))0, 1);
    return;
  } else {

  }
  fdmi->fcxp = fcxp;
  tmp___0 = bfa_fcxp_get_reqbuf(fcxp);
  pyld = (u8 *)tmp___0;
  memset((void *)pyld, 0, 2112UL);
  len = fc_fdmi_reqhdr_build(& fchs, (void *)pyld, port->pid, 528);
  attr_len = bfa_fcs_lport_fdmi_build_rprt_pyld(fdmi, pyld + 1U);
  bfa_fcxp_send(fcxp, (struct bfa_rport_s *)0, (int )(port->fabric)->vf_id, (int )port->lp_tag,
                0, 8, (u32 )((int )len + (int )attr_len), & fchs, & bfa_fcs_lport_fdmi_rprt_response,
                (void *)fdmi, 2112U, 30);
  (*(fdmi->sm))((void *)fdmi, 8);
  return;
}
}
static u16 bfa_fcs_lport_fdmi_build_portattr_block(struct bfa_fcs_lport_fdmi_s *fdmi ,
                                                   u8 *pyld ) 
{ 
  struct bfa_fcs_fdmi_port_attr_s fcs_port_attr ;
  struct fdmi_port_attr_s *port_attrib ;
  struct fdmi_attr_s *attr ;
  u8 *curr_ptr ;
  u16 len ;
  u8 count ;
  u16 templen ;
  __u16 tmp ;
  __u16 tmp___0 ;
  __u16 tmp___1 ;
  __u16 tmp___2 ;
  size_t tmp___3 ;
  __u16 tmp___4 ;
  size_t tmp___5 ;
  __u16 tmp___6 ;
  __u16 tmp___7 ;
  __u16 tmp___8 ;
  __u16 tmp___9 ;
  __u16 tmp___10 ;
  __u16 tmp___11 ;
  __u16 tmp___12 ;
  __u16 tmp___13 ;
  __u16 tmp___14 ;
  __u16 tmp___15 ;
  __u32 tmp___16 ;

  {
  port_attrib = (struct fdmi_port_attr_s *)pyld;
  count = 0U;
  bfa_fcs_fdmi_get_portattr(fdmi, & fcs_port_attr);
  len = 4U;
  curr_ptr = (u8 *)(& port_attrib->port_attr);
  attr = (struct fdmi_attr_s *)curr_ptr;
  attr->type = 256U;
  templen = 32U;
  memcpy((void *)(& attr->value), (void const   *)(& fcs_port_attr.supp_fc4_types),
           (size_t )templen);
  curr_ptr = curr_ptr + ((unsigned long )templen + 4UL);
  len = (int )len + (int )templen;
  count = (u8 )((int )count + 1);
  tmp = __fswab16((int )((unsigned int )templen + 4U));
  attr->len = tmp;
  attr = (struct fdmi_attr_s *)curr_ptr;
  attr->type = 512U;
  templen = 4U;
  memcpy((void *)(& attr->value), (void const   *)(& fcs_port_attr.supp_speed),
           (size_t )templen);
  curr_ptr = curr_ptr + ((unsigned long )templen + 4UL);
  len = (int )len + (int )templen;
  count = (u8 )((int )count + 1);
  tmp___0 = __fswab16((int )((unsigned int )templen + 4U));
  attr->len = tmp___0;
  attr = (struct fdmi_attr_s *)curr_ptr;
  attr->type = 768U;
  templen = 4U;
  memcpy((void *)(& attr->value), (void const   *)(& fcs_port_attr.curr_speed),
           (size_t )templen);
  curr_ptr = curr_ptr + ((unsigned long )templen + 4UL);
  len = (int )len + (int )templen;
  count = (u8 )((int )count + 1);
  tmp___1 = __fswab16((int )((unsigned int )templen + 4U));
  attr->len = tmp___1;
  attr = (struct fdmi_attr_s *)curr_ptr;
  attr->type = 1024U;
  templen = 4U;
  memcpy((void *)(& attr->value), (void const   *)(& fcs_port_attr.max_frm_size),
           (size_t )templen);
  curr_ptr = curr_ptr + ((unsigned long )templen + 4UL);
  len = (int )len + (int )templen;
  count = (u8 )((int )count + 1);
  tmp___2 = __fswab16((int )((unsigned int )templen + 4U));
  attr->len = tmp___2;
  if ((unsigned int )fcs_port_attr.os_device_name[0] != 0U) {
    attr = (struct fdmi_attr_s *)curr_ptr;
    attr->type = 1280U;
    tmp___3 = strlen((char const   *)(& fcs_port_attr.os_device_name));
    templen = (unsigned short )tmp___3;
    memcpy((void *)(& attr->value), (void const   *)(& fcs_port_attr.os_device_name),
             (size_t )templen);
    templen = ((unsigned int )templen + 3U) & 65532U;
    curr_ptr = curr_ptr + ((unsigned long )templen + 4UL);
    len = (int )len + (int )templen;
    count = (u8 )((int )count + 1);
    tmp___4 = __fswab16((int )((unsigned int )templen + 4U));
    attr->len = tmp___4;
  } else {

  }
  if ((unsigned int )fcs_port_attr.host_name[0] != 0U) {
    attr = (struct fdmi_attr_s *)curr_ptr;
    attr->type = 1536U;
    tmp___5 = strlen((char const   *)(& fcs_port_attr.host_name));
    templen = (unsigned short )tmp___5;
    memcpy((void *)(& attr->value), (void const   *)(& fcs_port_attr.host_name),
             (size_t )templen);
    templen = ((unsigned int )templen + 3U) & 65532U;
    curr_ptr = curr_ptr + ((unsigned long )templen + 4UL);
    len = (int )len + (int )templen;
    count = (u8 )((int )count + 1);
    tmp___6 = __fswab16((int )((unsigned int )templen + 4U));
    attr->len = tmp___6;
  } else {

  }
  if ((unsigned int )fdmi->retry_cnt == 0U) {
    attr = (struct fdmi_attr_s *)curr_ptr;
    attr->type = 1792U;
    templen = 8U;
    memcpy((void *)(& attr->value), (void const   *)(& fcs_port_attr.node_name),
             (size_t )templen);
    templen = ((unsigned int )templen + 3U) & 65532U;
    curr_ptr = curr_ptr + ((unsigned long )templen + 4UL);
    len = (int )len + (int )templen;
    count = (u8 )((int )count + 1);
    tmp___7 = __fswab16((int )((unsigned int )templen + 4U));
    attr->len = tmp___7;
    attr = (struct fdmi_attr_s *)curr_ptr;
    attr->type = 2048U;
    templen = 8U;
    memcpy((void *)(& attr->value), (void const   *)(& fcs_port_attr.port_name),
             (size_t )templen);
    templen = ((unsigned int )templen + 3U) & 65532U;
    curr_ptr = curr_ptr + ((unsigned long )templen + 4UL);
    len = (int )len + (int )templen;
    count = (u8 )((int )count + 1);
    tmp___8 = __fswab16((int )((unsigned int )templen + 4U));
    attr->len = tmp___8;
    if ((int )((signed char )fcs_port_attr.port_sym_name.symname[0]) != 0) {
      attr = (struct fdmi_attr_s *)curr_ptr;
      attr->type = 2304U;
      templen = 128U;
      memcpy((void *)(& attr->value), (void const   *)(& fcs_port_attr.port_sym_name),
               (size_t )templen);
      templen = ((unsigned int )templen + 3U) & 65532U;
      curr_ptr = curr_ptr + ((unsigned long )templen + 4UL);
      len = (int )len + (int )templen;
      count = (u8 )((int )count + 1);
      tmp___9 = __fswab16((int )((unsigned int )templen + 4U));
      attr->len = tmp___9;
    } else {

    }
    attr = (struct fdmi_attr_s *)curr_ptr;
    attr->type = 2560U;
    templen = 4U;
    memcpy((void *)(& attr->value), (void const   *)(& fcs_port_attr.port_type),
             (size_t )templen);
    templen = ((unsigned int )templen + 3U) & 65532U;
    curr_ptr = curr_ptr + ((unsigned long )templen + 4UL);
    len = (int )len + (int )templen;
    count = (u8 )((int )count + 1);
    tmp___10 = __fswab16((int )((unsigned int )templen + 4U));
    attr->len = tmp___10;
    attr = (struct fdmi_attr_s *)curr_ptr;
    attr->type = 2816U;
    templen = 4U;
    memcpy((void *)(& attr->value), (void const   *)(& fcs_port_attr.scos), (size_t )templen);
    templen = ((unsigned int )templen + 3U) & 65532U;
    curr_ptr = curr_ptr + ((unsigned long )templen + 4UL);
    len = (int )len + (int )templen;
    count = (u8 )((int )count + 1);
    tmp___11 = __fswab16((int )((unsigned int )templen + 4U));
    attr->len = tmp___11;
    attr = (struct fdmi_attr_s *)curr_ptr;
    attr->type = 3072U;
    templen = 8U;
    memcpy((void *)(& attr->value), (void const   *)(& fcs_port_attr.port_fabric_name),
             (size_t )templen);
    templen = ((unsigned int )templen + 3U) & 65532U;
    curr_ptr = curr_ptr + ((unsigned long )templen + 4UL);
    len = (int )len + (int )templen;
    count = (u8 )((int )count + 1);
    tmp___12 = __fswab16((int )((unsigned int )templen + 4U));
    attr->len = tmp___12;
    attr = (struct fdmi_attr_s *)curr_ptr;
    attr->type = 3328U;
    templen = 32U;
    memcpy((void *)(& attr->value), (void const   *)(& fcs_port_attr.port_act_fc4_type),
             (size_t )templen);
    templen = ((unsigned int )templen + 3U) & 65532U;
    curr_ptr = curr_ptr + ((unsigned long )templen + 4UL);
    len = (int )len + (int )templen;
    count = (u8 )((int )count + 1);
    tmp___13 = __fswab16((int )((unsigned int )templen + 4U));
    attr->len = tmp___13;
    attr = (struct fdmi_attr_s *)curr_ptr;
    attr->type = 257U;
    templen = 4U;
    memcpy((void *)(& attr->value), (void const   *)(& fcs_port_attr.port_state),
             (size_t )templen);
    templen = ((unsigned int )templen + 3U) & 65532U;
    curr_ptr = curr_ptr + ((unsigned long )templen + 4UL);
    len = (int )len + (int )templen;
    count = (u8 )((int )count + 1);
    tmp___14 = __fswab16((int )((unsigned int )templen + 4U));
    attr->len = tmp___14;
    attr = (struct fdmi_attr_s *)curr_ptr;
    attr->type = 513U;
    templen = 4U;
    memcpy((void *)(& attr->value), (void const   *)(& fcs_port_attr.num_ports),
             (size_t )templen);
    templen = ((unsigned int )templen + 3U) & 65532U;
    curr_ptr = curr_ptr + ((unsigned long )templen + 4UL);
    len = (int )len + (int )templen;
    count = (u8 )((int )count + 1);
    tmp___15 = __fswab16((int )((unsigned int )templen + 4U));
    attr->len = tmp___15;
  } else {

  }
  tmp___16 = __fswab32((__u32 )count);
  port_attrib->attr_count = tmp___16;
  len = (unsigned int )((u16 )count) * 4U + (unsigned int )len;
  return (len);
}
}
static u16 bfa_fcs_lport_fdmi_build_rprt_pyld(struct bfa_fcs_lport_fdmi_s *fdmi ,
                                              u8 *pyld ) 
{ 
  struct bfa_fcs_lport_s *port ;
  struct fdmi_rprt_s *rprt ;
  u16 len ;
  struct bfa_fcs_lport_s *tmp ;

  {
  port = (fdmi->ms)->port;
  rprt = (struct fdmi_rprt_s *)pyld;
  tmp = bfa_fcs_get_base_port(port->fcs);
  rprt->hba_id = tmp->port_cfg.pwwn;
  rprt->port_name = port->port_cfg.pwwn;
  len = bfa_fcs_lport_fdmi_build_portattr_block(fdmi, (u8 *)(& rprt->port_attr_blk));
  len = (unsigned int )len + 16U;
  return (len);
}
}
static void bfa_fcs_lport_fdmi_rprt_response(void *fcsarg , struct bfa_fcxp_s *fcxp ,
                                             void *cbarg , enum bfa_status req_status ,
                                             u32 rsp_len , u32 resid_len , struct fchs_s *rsp_fchs ) 
{ 
  struct bfa_fcs_lport_fdmi_s *fdmi ;
  struct bfa_fcs_lport_s *port ;
  struct ct_hdr_s *cthdr ;
  void *tmp ;
  __u16 tmp___0 ;

  {
  fdmi = (struct bfa_fcs_lport_fdmi_s *)cbarg;
  port = (fdmi->ms)->port;
  cthdr = (struct ct_hdr_s *)0;
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 2484, port->port_cfg.pwwn);
  if ((unsigned int )req_status != 0U) {
    __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 2490, (unsigned long long )req_status);
    (*(fdmi->sm))((void *)fdmi, 5);
    return;
  } else {

  }
  tmp = bfa_fcxp_get_rspbuf(fcxp);
  cthdr = (struct ct_hdr_s *)tmp;
  tmp___0 = __fswab16((int )cthdr->cmd_rsp_code);
  cthdr->cmd_rsp_code = tmp___0;
  if ((unsigned int )cthdr->cmd_rsp_code == 32770U) {
    (*(fdmi->sm))((void *)fdmi, 4);
    return;
  } else {

  }
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 2503, (unsigned long long )cthdr->reason_code);
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 2504, (unsigned long long )cthdr->exp_code);
  (*(fdmi->sm))((void *)fdmi, 5);
  return;
}
}
static void bfa_fcs_lport_fdmi_send_rpa(void *fdmi_cbarg , struct bfa_fcxp_s *fcxp_alloced ) 
{ 
  struct bfa_fcs_lport_fdmi_s *fdmi ;
  struct bfa_fcs_lport_s *port ;
  struct fchs_s fchs ;
  u16 len ;
  u16 attr_len ;
  struct bfa_fcxp_s *fcxp ;
  u8 *pyld ;
  struct bfa_fcxp_s *tmp ;
  void *tmp___0 ;

  {
  fdmi = (struct bfa_fcs_lport_fdmi_s *)fdmi_cbarg;
  port = (fdmi->ms)->port;
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 2521, port->port_cfg.pwwn);
  if ((unsigned long )fcxp_alloced == (unsigned long )((struct bfa_fcxp_s *)0)) {
    tmp = bfa_fcxp_req_rsp_alloc((void *)0, (port->fcs)->bfa, 0, 0, (u64 (*)(void * ,
                                                                             int  ))0,
                                 (u32 (*)(void * , int  ))0, (u64 (*)(void * , int  ))0,
                                 (u32 (*)(void * , int  ))0, 1);
    fcxp = tmp;
  } else {
    fcxp = fcxp_alloced;
  }
  if ((unsigned long )fcxp == (unsigned long )((struct bfa_fcxp_s *)0)) {
    bfa_fcxp_req_rsp_alloc_wait((port->fcs)->bfa, & fdmi->fcxp_wqe, & bfa_fcs_lport_fdmi_send_rpa,
                                (void *)fdmi, (void *)0, 0, 0, (u64 (*)(void * , int  ))0,
                                (u32 (*)(void * , int  ))0, (u64 (*)(void * , int  ))0,
                                (u32 (*)(void * , int  ))0, 1);
    return;
  } else {

  }
  fdmi->fcxp = fcxp;
  tmp___0 = bfa_fcxp_get_reqbuf(fcxp);
  pyld = (u8 *)tmp___0;
  memset((void *)pyld, 0, 2112UL);
  len = fc_fdmi_reqhdr_build(& fchs, (void *)pyld, port->pid, 529);
  attr_len = bfa_fcs_lport_fdmi_build_rpa_pyld(fdmi, pyld + 1U);
  bfa_fcxp_send(fcxp, (struct bfa_rport_s *)0, (int )(port->fabric)->vf_id, (int )port->lp_tag,
                0, 8, (u32 )((int )len + (int )attr_len), & fchs, & bfa_fcs_lport_fdmi_rpa_response,
                (void *)fdmi, 2112U, 30);
  (*(fdmi->sm))((void *)fdmi, 9);
  return;
}
}
static u16 bfa_fcs_lport_fdmi_build_rpa_pyld(struct bfa_fcs_lport_fdmi_s *fdmi , u8 *pyld ) 
{ 
  struct bfa_fcs_lport_s *port ;
  struct fdmi_rpa_s *rpa ;
  u16 len ;

  {
  port = (fdmi->ms)->port;
  rpa = (struct fdmi_rpa_s *)pyld;
  rpa->port_name = port->port_cfg.pwwn;
  len = bfa_fcs_lport_fdmi_build_portattr_block(fdmi, (u8 *)(& rpa->port_attr_blk));
  len = (unsigned int )len + 8U;
  return (len);
}
}
static void bfa_fcs_lport_fdmi_rpa_response(void *fcsarg , struct bfa_fcxp_s *fcxp ,
                                            void *cbarg , enum bfa_status req_status ,
                                            u32 rsp_len , u32 resid_len , struct fchs_s *rsp_fchs ) 
{ 
  struct bfa_fcs_lport_fdmi_s *fdmi ;
  struct bfa_fcs_lport_s *port ;
  struct ct_hdr_s *cthdr ;
  void *tmp ;
  __u16 tmp___0 ;

  {
  fdmi = (struct bfa_fcs_lport_fdmi_s *)cbarg;
  port = (fdmi->ms)->port;
  cthdr = (struct ct_hdr_s *)0;
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 2576, port->port_cfg.pwwn);
  if ((unsigned int )req_status != 0U) {
    __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 2582, (unsigned long long )req_status);
    (*(fdmi->sm))((void *)fdmi, 5);
    return;
  } else {

  }
  tmp = bfa_fcxp_get_rspbuf(fcxp);
  cthdr = (struct ct_hdr_s *)tmp;
  tmp___0 = __fswab16((int )cthdr->cmd_rsp_code);
  cthdr->cmd_rsp_code = tmp___0;
  if ((unsigned int )cthdr->cmd_rsp_code == 32770U) {
    (*(fdmi->sm))((void *)fdmi, 4);
    return;
  } else {

  }
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 2595, (unsigned long long )cthdr->reason_code);
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 2596, (unsigned long long )cthdr->exp_code);
  (*(fdmi->sm))((void *)fdmi, 5);
  return;
}
}
static void bfa_fcs_lport_fdmi_timeout(void *arg ) 
{ 
  struct bfa_fcs_lport_fdmi_s *fdmi ;

  {
  fdmi = (struct bfa_fcs_lport_fdmi_s *)arg;
  (*(fdmi->sm))((void *)fdmi, 6);
  return;
}
}
static void bfa_fcs_fdmi_get_hbaattr(struct bfa_fcs_lport_fdmi_s *fdmi , struct bfa_fcs_fdmi_hba_attr_s *hba_attr ) 
{ 
  struct bfa_fcs_lport_s *port ;
  struct bfa_fcs_driver_info_s *driver_info ;
  struct bfa_fcs_fdmi_port_attr_s fcs_port_attr ;
  __u32 tmp ;

  {
  port = (fdmi->ms)->port;
  driver_info = & (port->fcs)->driver_info;
  memset((void *)hba_attr, 0, 952UL);
  bfa_ioc_get_adapter_manufacturer(& ((port->fcs)->bfa)->ioc, (char *)(& hba_attr->manufacturer));
  bfa_ioc_get_adapter_serial_num(& ((port->fcs)->bfa)->ioc, (char *)(& hba_attr->serial_num));
  bfa_ioc_get_adapter_model(& ((port->fcs)->bfa)->ioc, (char *)(& hba_attr->model));
  bfa_ioc_get_adapter_model(& ((port->fcs)->bfa)->ioc, (char *)(& hba_attr->model_desc));
  bfa_ioc_get_pci_chip_rev(& ((port->fcs)->bfa)->ioc, (char *)(& hba_attr->hw_version));
  bfa_ioc_get_adapter_optrom_ver(& ((port->fcs)->bfa)->ioc, (char *)(& hba_attr->option_rom_ver));
  bfa_ioc_get_adapter_fw_ver(& ((port->fcs)->bfa)->ioc, (char *)(& hba_attr->fw_version));
  strncpy((char *)(& hba_attr->driver_version), (char const   *)(& driver_info->version),
          64UL);
  strncpy((char *)(& hba_attr->os_name), (char const   *)(& driver_info->host_os_name),
          256UL);
  if ((unsigned int )driver_info->host_os_patch[0] != 0U) {
    strncat((char *)(& hba_attr->os_name), " | ", 4UL);
    strncat((char *)(& hba_attr->os_name), (char const   *)(& driver_info->host_os_patch),
            64UL);
  } else {

  }
  bfa_fcs_fdmi_get_portattr(fdmi, & fcs_port_attr);
  hba_attr->max_ct_pyld = fcs_port_attr.max_frm_size;
  strncpy((char *)(& hba_attr->node_sym_name.symname), (char const   *)(& port->port_cfg.node_sym_name.symname),
          128UL);
  strcpy((char *)(& hba_attr->vendor_info), "BROCADE");
  tmp = __fswab32(((((port->fcs)->bfa)->ioc.attr)->adapter_prop & 65280U) >> 8);
  hba_attr->num_ports = tmp;
  hba_attr->fabric_name = ((port->fabric)->lps)->pr_nwwn;
  strncpy((char *)(& hba_attr->bios_ver), (char const   *)(& hba_attr->option_rom_ver),
          64UL);
  return;
}
}
static void bfa_fcs_fdmi_get_portattr(struct bfa_fcs_lport_fdmi_s *fdmi , struct bfa_fcs_fdmi_port_attr_s *port_attr ) 
{ 
  struct bfa_fcs_lport_s *port ;
  struct bfa_fcs_driver_info_s *driver_info ;
  struct bfa_port_attr_s pport_attr ;
  struct bfa_lport_attr_s lport_attr ;
  u32 tmp ;
  __u32 tmp___0 ;
  __u32 tmp___1 ;
  __u32 tmp___2 ;
  __u32 tmp___3 ;
  __u32 tmp___4 ;

  {
  port = (fdmi->ms)->port;
  driver_info = & (port->fcs)->driver_info;
  memset((void *)port_attr, 0, 760UL);
  bfa_fcport_get_attr((port->fcs)->bfa, & pport_attr);
  fc_get_fc4type_bitmask(8, (u8 *)(& port_attr->supp_fc4_types));
  switch ((unsigned int )pport_attr.speed_supported) {
  case 16U: 
  port_attr->supp_speed = 973078528U;
  goto ldv_49460;
  case 10U: 
  port_attr->supp_speed = 67108864U;
  goto ldv_49460;
  case 8U: 
  port_attr->supp_speed = 452984832U;
  goto ldv_49460;
  case 4U: 
  port_attr->supp_speed = 184549376U;
  goto ldv_49460;
  default: 
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 2710, (unsigned long long )((unsigned int )pport_attr.speed_supported | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcs_lport.c",
         2710, (unsigned int )pport_attr.speed_supported);
  }
  ldv_49460: 
  tmp = bfa_fcs_fdmi_convert_speed(pport_attr.speed);
  tmp___0 = __fswab32(tmp);
  port_attr->curr_speed = tmp___0;
  tmp___1 = __fswab32((__u32 )pport_attr.pport_cfg.maxfrsize);
  port_attr->max_frm_size = tmp___1;
  strncpy((char *)(& port_attr->os_device_name), (char const   *)(& driver_info->os_device_name),
          256UL);
  strncpy((char *)(& port_attr->host_name), (char const   *)(& driver_info->host_machine_name),
          256UL);
  port_attr->node_name = port->port_cfg.nwwn;
  port_attr->port_name = port->port_cfg.pwwn;
  strncpy((char *)(& port_attr->port_sym_name.symname), (char const   *)(& port->port_cfg.sym_name),
          128UL);
  bfa_fcs_lport_get_attr(port, & lport_attr);
  tmp___2 = __fswab32((__u32 )lport_attr.port_type);
  port_attr->port_type = tmp___2;
  port_attr->scos = pport_attr.cos_supported;
  port_attr->port_fabric_name = ((port->fabric)->lps)->pr_nwwn;
  fc_get_fc4type_bitmask(8, (u8 *)(& port_attr->port_act_fc4_type));
  tmp___3 = __fswab32((__u32 )pport_attr.port_state);
  port_attr->port_state = tmp___3;
  tmp___4 = __fswab32((__u32 )port->num_rports);
  port_attr->num_ports = tmp___4;
  return;
}
}
u32 bfa_fcs_fdmi_convert_speed(enum bfa_port_speed pport_speed ) 
{ 
  u32 ret ;

  {
  switch ((unsigned int )pport_speed) {
  case 1U: ;
  case 2U: 
  ret = (u32 )pport_speed;
  goto ldv_49471;
  case 4U: 
  ret = 8U;
  goto ldv_49471;
  case 8U: 
  ret = 16U;
  goto ldv_49471;
  case 10U: 
  ret = 4U;
  goto ldv_49471;
  case 16U: 
  ret = 32U;
  goto ldv_49471;
  default: 
  ret = 32768U;
  }
  ldv_49471: ;
  return (ret);
}
}
void bfa_fcs_lport_fdmi_init(struct bfa_fcs_lport_ms_s *ms ) 
{ 
  struct bfa_fcs_lport_fdmi_s *fdmi ;

  {
  fdmi = & ms->fdmi;
  fdmi->ms = ms;
  if ((unsigned int )((ms->port)->fcs)->fdmi_enabled != 0U) {
    fdmi->sm = (void (*)(void * , int  ))(& bfa_fcs_lport_fdmi_sm_offline);
  } else {
    fdmi->sm = (void (*)(void * , int  ))(& bfa_fcs_lport_fdmi_sm_disabled);
  }
  return;
}
}
void bfa_fcs_lport_fdmi_offline(struct bfa_fcs_lport_ms_s *ms ) 
{ 
  struct bfa_fcs_lport_fdmi_s *fdmi ;

  {
  fdmi = & ms->fdmi;
  fdmi->ms = ms;
  (*(fdmi->sm))((void *)fdmi, 2);
  return;
}
}
void bfa_fcs_lport_fdmi_online(struct bfa_fcs_lport_ms_s *ms ) 
{ 
  struct bfa_fcs_lport_fdmi_s *fdmi ;

  {
  fdmi = & ms->fdmi;
  fdmi->ms = ms;
  (*(fdmi->sm))((void *)fdmi, 1);
  return;
}
}
static void bfa_fcs_lport_ms_send_plogi(void *ms_cbarg , struct bfa_fcxp_s *fcxp_alloced ) ;
static void bfa_fcs_lport_ms_timeout(void *arg ) ;
static void bfa_fcs_lport_ms_plogi_response(void *fcsarg , struct bfa_fcxp_s *fcxp ,
                                            void *cbarg , enum bfa_status req_status ,
                                            u32 rsp_len , u32 resid_len , struct fchs_s *rsp_fchs ) ;
static void bfa_fcs_lport_ms_send_gmal(void *ms_cbarg , struct bfa_fcxp_s *fcxp_alloced ) ;
static void bfa_fcs_lport_ms_gmal_response(void *fcsarg , struct bfa_fcxp_s *fcxp ,
                                           void *cbarg , enum bfa_status req_status ,
                                           u32 rsp_len , u32 resid_len , struct fchs_s *rsp_fchs ) ;
static void bfa_fcs_lport_ms_send_gfn(void *ms_cbarg , struct bfa_fcxp_s *fcxp_alloced ) ;
static void bfa_fcs_lport_ms_gfn_response(void *fcsarg , struct bfa_fcxp_s *fcxp ,
                                          void *cbarg , enum bfa_status req_status ,
                                          u32 rsp_len , u32 resid_len , struct fchs_s *rsp_fchs ) ;
static void bfa_fcs_lport_ms_sm_offline(struct bfa_fcs_lport_ms_s *ms , enum port_ms_event event ) ;
static void bfa_fcs_lport_ms_sm_plogi_sending(struct bfa_fcs_lport_ms_s *ms , enum port_ms_event event ) ;
static void bfa_fcs_lport_ms_sm_plogi(struct bfa_fcs_lport_ms_s *ms , enum port_ms_event event ) ;
static void bfa_fcs_lport_ms_sm_plogi_retry(struct bfa_fcs_lport_ms_s *ms , enum port_ms_event event ) ;
static void bfa_fcs_lport_ms_sm_gmal_sending(struct bfa_fcs_lport_ms_s *ms , enum port_ms_event event ) ;
static void bfa_fcs_lport_ms_sm_gmal(struct bfa_fcs_lport_ms_s *ms , enum port_ms_event event ) ;
static void bfa_fcs_lport_ms_sm_gmal_retry(struct bfa_fcs_lport_ms_s *ms , enum port_ms_event event ) ;
static void bfa_fcs_lport_ms_sm_gfn_sending(struct bfa_fcs_lport_ms_s *ms , enum port_ms_event event ) ;
static void bfa_fcs_lport_ms_sm_gfn(struct bfa_fcs_lport_ms_s *ms , enum port_ms_event event ) ;
static void bfa_fcs_lport_ms_sm_gfn_retry(struct bfa_fcs_lport_ms_s *ms , enum port_ms_event event ) ;
static void bfa_fcs_lport_ms_sm_online(struct bfa_fcs_lport_ms_s *ms , enum port_ms_event event ) ;
static void bfa_fcs_lport_ms_sm_offline(struct bfa_fcs_lport_ms_s *ms , enum port_ms_event event ) 
{ 


  {
  __bfa_trc(((ms->port)->fcs)->trcmod, __trc_fileno___7, 2896, (ms->port)->port_cfg.pwwn);
  __bfa_trc(((ms->port)->fcs)->trcmod, __trc_fileno___7, 2897, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 1U: 
  ms->sm = (void (*)(void * , int  ))(& bfa_fcs_lport_ms_sm_plogi_sending);
  bfa_fcs_lport_ms_send_plogi((void *)ms, (struct bfa_fcxp_s *)0);
  goto ldv_49570;
  case 2U: ;
  goto ldv_49570;
  default: 
  __bfa_trc(((ms->port)->fcs)->trcmod, __trc_fileno___7, 2909, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcs_lport.c",
         2909, (unsigned int )event);
  }
  ldv_49570: ;
  return;
}
}
static void bfa_fcs_lport_ms_sm_plogi_sending(struct bfa_fcs_lport_ms_s *ms , enum port_ms_event event ) 
{ 


  {
  __bfa_trc(((ms->port)->fcs)->trcmod, __trc_fileno___7, 2917, (ms->port)->port_cfg.pwwn);
  __bfa_trc(((ms->port)->fcs)->trcmod, __trc_fileno___7, 2918, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 6U: 
  ms->sm = (void (*)(void * , int  ))(& bfa_fcs_lport_ms_sm_plogi);
  goto ldv_49578;
  case 2U: 
  ms->sm = (void (*)(void * , int  ))(& bfa_fcs_lport_ms_sm_offline);
  bfa_fcxp_walloc_cancel(((ms->port)->fcs)->bfa, & ms->fcxp_wqe);
  goto ldv_49578;
  default: 
  __bfa_trc(((ms->port)->fcs)->trcmod, __trc_fileno___7, 2932, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcs_lport.c",
         2932, (unsigned int )event);
  }
  ldv_49578: ;
  return;
}
}
static void bfa_fcs_lport_ms_sm_plogi(struct bfa_fcs_lport_ms_s *ms , enum port_ms_event event ) 
{ 


  {
  __bfa_trc(((ms->port)->fcs)->trcmod, __trc_fileno___7, 2940, (ms->port)->port_cfg.pwwn);
  __bfa_trc(((ms->port)->fcs)->trcmod, __trc_fileno___7, 2941, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 4U: 
  ms->sm = (void (*)(void * , int  ))(& bfa_fcs_lport_ms_sm_plogi_retry);
  (ms->port)->stats.ms_retries = (ms->port)->stats.ms_retries + 1U;
  bfa_timer_begin(& (((ms->port)->fcs)->bfa)->timer_mod, & ms->timer, & bfa_fcs_lport_ms_timeout,
                  (void *)ms, 2000U);
  goto ldv_49586;
  case 3U: 
  bfa_fcs_lport_fdmi_online(ms);
  if ((unsigned long )(ms->port)->vport != (unsigned long )((struct bfa_fcs_vport_s *)0)) {
    ms->sm = (void (*)(void * , int  ))(& bfa_fcs_lport_ms_sm_online);
    goto ldv_49586;
  } else {

  }
  ms->sm = (void (*)(void * , int  ))(& bfa_fcs_lport_ms_sm_gmal_sending);
  bfa_fcs_lport_ms_send_gmal((void *)ms, (struct bfa_fcxp_s *)0);
  goto ldv_49586;
  case 2U: 
  ms->sm = (void (*)(void * , int  ))(& bfa_fcs_lport_ms_sm_offline);
  bfa_fcxp_discard(ms->fcxp);
  goto ldv_49586;
  default: 
  __bfa_trc(((ms->port)->fcs)->trcmod, __trc_fileno___7, 2983, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcs_lport.c",
         2983, (unsigned int )event);
  }
  ldv_49586: ;
  return;
}
}
static void bfa_fcs_lport_ms_sm_plogi_retry(struct bfa_fcs_lport_ms_s *ms , enum port_ms_event event ) 
{ 


  {
  __bfa_trc(((ms->port)->fcs)->trcmod, __trc_fileno___7, 2991, (ms->port)->port_cfg.pwwn);
  __bfa_trc(((ms->port)->fcs)->trcmod, __trc_fileno___7, 2992, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 5U: 
  ms->sm = (void (*)(void * , int  ))(& bfa_fcs_lport_ms_sm_plogi_sending);
  bfa_fcs_lport_ms_send_plogi((void *)ms, (struct bfa_fcxp_s *)0);
  goto ldv_49595;
  case 2U: 
  ms->sm = (void (*)(void * , int  ))(& bfa_fcs_lport_ms_sm_offline);
  bfa_timer_stop(& ms->timer);
  goto ldv_49595;
  default: 
  __bfa_trc(((ms->port)->fcs)->trcmod, __trc_fileno___7, 3009, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcs_lport.c",
         3009, (unsigned int )event);
  }
  ldv_49595: ;
  return;
}
}
static void bfa_fcs_lport_ms_sm_online(struct bfa_fcs_lport_ms_s *ms , enum port_ms_event event ) 
{ 


  {
  __bfa_trc(((ms->port)->fcs)->trcmod, __trc_fileno___7, 3017, (ms->port)->port_cfg.pwwn);
  __bfa_trc(((ms->port)->fcs)->trcmod, __trc_fileno___7, 3018, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 2U: 
  ms->sm = (void (*)(void * , int  ))(& bfa_fcs_lport_ms_sm_offline);
  goto ldv_49603;
  case 7U: 
  ms->sm = (void (*)(void * , int  ))(& bfa_fcs_lport_ms_sm_gfn_sending);
  ms->retry_cnt = 0U;
  bfa_fcs_lport_ms_send_gfn((void *)ms, (struct bfa_fcxp_s *)0);
  goto ldv_49603;
  default: 
  __bfa_trc(((ms->port)->fcs)->trcmod, __trc_fileno___7, 3032, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcs_lport.c",
         3032, (unsigned int )event);
  }
  ldv_49603: ;
  return;
}
}
static void bfa_fcs_lport_ms_sm_gmal_sending(struct bfa_fcs_lport_ms_s *ms , enum port_ms_event event ) 
{ 


  {
  __bfa_trc(((ms->port)->fcs)->trcmod, __trc_fileno___7, 3040, (ms->port)->port_cfg.pwwn);
  __bfa_trc(((ms->port)->fcs)->trcmod, __trc_fileno___7, 3041, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 6U: 
  ms->sm = (void (*)(void * , int  ))(& bfa_fcs_lport_ms_sm_gmal);
  goto ldv_49611;
  case 2U: 
  ms->sm = (void (*)(void * , int  ))(& bfa_fcs_lport_ms_sm_offline);
  bfa_fcxp_walloc_cancel(((ms->port)->fcs)->bfa, & ms->fcxp_wqe);
  goto ldv_49611;
  default: 
  __bfa_trc(((ms->port)->fcs)->trcmod, __trc_fileno___7, 3055, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcs_lport.c",
         3055, (unsigned int )event);
  }
  ldv_49611: ;
  return;
}
}
static void bfa_fcs_lport_ms_sm_gmal(struct bfa_fcs_lport_ms_s *ms , enum port_ms_event event ) 
{ 
  u8 tmp ;

  {
  __bfa_trc(((ms->port)->fcs)->trcmod, __trc_fileno___7, 3063, (ms->port)->port_cfg.pwwn);
  __bfa_trc(((ms->port)->fcs)->trcmod, __trc_fileno___7, 3064, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 4U: 
  tmp = ms->retry_cnt;
  ms->retry_cnt = (u8 )((int )ms->retry_cnt + 1);
  if ((unsigned int )tmp <= 1U) {
    ms->sm = (void (*)(void * , int  ))(& bfa_fcs_lport_ms_sm_gmal_retry);
    (ms->port)->stats.ms_retries = (ms->port)->stats.ms_retries + 1U;
    bfa_timer_begin(& (((ms->port)->fcs)->bfa)->timer_mod, & ms->timer, & bfa_fcs_lport_ms_timeout,
                    (void *)ms, 2000U);
  } else {
    ms->sm = (void (*)(void * , int  ))(& bfa_fcs_lport_ms_sm_gfn_sending);
    bfa_fcs_lport_ms_send_gfn((void *)ms, (struct bfa_fcxp_s *)0);
    ms->retry_cnt = 0U;
  }
  goto ldv_49619;
  case 3U: 
  ms->sm = (void (*)(void * , int  ))(& bfa_fcs_lport_ms_sm_gfn_sending);
  bfa_fcs_lport_ms_send_gfn((void *)ms, (struct bfa_fcxp_s *)0);
  goto ldv_49619;
  case 2U: 
  ms->sm = (void (*)(void * , int  ))(& bfa_fcs_lport_ms_sm_offline);
  bfa_fcxp_discard(ms->fcxp);
  goto ldv_49619;
  default: 
  __bfa_trc(((ms->port)->fcs)->trcmod, __trc_fileno___7, 3095, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcs_lport.c",
         3095, (unsigned int )event);
  }
  ldv_49619: ;
  return;
}
}
static void bfa_fcs_lport_ms_sm_gmal_retry(struct bfa_fcs_lport_ms_s *ms , enum port_ms_event event ) 
{ 


  {
  __bfa_trc(((ms->port)->fcs)->trcmod, __trc_fileno___7, 3103, (ms->port)->port_cfg.pwwn);
  __bfa_trc(((ms->port)->fcs)->trcmod, __trc_fileno___7, 3104, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 5U: 
  ms->sm = (void (*)(void * , int  ))(& bfa_fcs_lport_ms_sm_gmal_sending);
  bfa_fcs_lport_ms_send_gmal((void *)ms, (struct bfa_fcxp_s *)0);
  goto ldv_49628;
  case 2U: 
  ms->sm = (void (*)(void * , int  ))(& bfa_fcs_lport_ms_sm_offline);
  bfa_timer_stop(& ms->timer);
  goto ldv_49628;
  default: 
  __bfa_trc(((ms->port)->fcs)->trcmod, __trc_fileno___7, 3121, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcs_lport.c",
         3121, (unsigned int )event);
  }
  ldv_49628: ;
  return;
}
}
static void bfa_fcs_lport_ms_send_gmal(void *ms_cbarg , struct bfa_fcxp_s *fcxp_alloced ) 
{ 
  struct bfa_fcs_lport_ms_s *ms ;
  struct bfa_fcs_lport_s *port ;
  struct fchs_s fchs ;
  int len ;
  struct bfa_fcxp_s *fcxp ;
  struct bfa_fcxp_s *tmp ;
  void *tmp___0 ;
  u16 tmp___1 ;

  {
  ms = (struct bfa_fcs_lport_ms_s *)ms_cbarg;
  port = ms->port;
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 3137, (unsigned long long )port->pid);
  if ((unsigned long )fcxp_alloced == (unsigned long )((struct bfa_fcxp_s *)0)) {
    tmp = bfa_fcxp_req_rsp_alloc((void *)0, (port->fcs)->bfa, 0, 0, (u64 (*)(void * ,
                                                                             int  ))0,
                                 (u32 (*)(void * , int  ))0, (u64 (*)(void * , int  ))0,
                                 (u32 (*)(void * , int  ))0, 1);
    fcxp = tmp;
  } else {
    fcxp = fcxp_alloced;
  }
  if ((unsigned long )fcxp == (unsigned long )((struct bfa_fcxp_s *)0)) {
    bfa_fcxp_req_rsp_alloc_wait((port->fcs)->bfa, & ms->fcxp_wqe, & bfa_fcs_lport_ms_send_gmal,
                                (void *)ms, (void *)0, 0, 0, (u64 (*)(void * , int  ))0,
                                (u32 (*)(void * , int  ))0, (u64 (*)(void * , int  ))0,
                                (u32 (*)(void * , int  ))0, 1);
    return;
  } else {

  }
  ms->fcxp = fcxp;
  tmp___0 = bfa_fcxp_get_reqbuf(fcxp);
  tmp___1 = fc_gmal_req_build(& fchs, tmp___0, port->pid, ((port->fabric)->lps)->pr_nwwn);
  len = (int )tmp___1;
  bfa_fcxp_send(fcxp, (struct bfa_rport_s *)0, (int )(port->fabric)->vf_id, (int )port->lp_tag,
                0, 8, (u32 )len, & fchs, & bfa_fcs_lport_ms_gmal_response, (void *)ms,
                2112U, 30);
  (*(ms->sm))((void *)ms, 6);
  return;
}
}
static void bfa_fcs_lport_ms_gmal_response(void *fcsarg , struct bfa_fcxp_s *fcxp ,
                                           void *cbarg , enum bfa_status req_status ,
                                           u32 rsp_len , u32 resid_len , struct fchs_s *rsp_fchs ) 
{ 
  struct bfa_fcs_lport_ms_s *ms ;
  struct bfa_fcs_lport_s *port ;
  struct ct_hdr_s *cthdr ;
  struct fcgs_gmal_resp_s *gmal_resp ;
  struct fcgs_gmal_entry_s *gmal_entry ;
  u32 num_entries ;
  u8 *rsp_str ;
  void *tmp ;
  __u16 tmp___0 ;
  __u32 tmp___1 ;
  int tmp___2 ;

  {
  ms = (struct bfa_fcs_lport_ms_s *)cbarg;
  port = ms->port;
  cthdr = (struct ct_hdr_s *)0;
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 3174, (unsigned long long )req_status);
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 3175, port->port_cfg.pwwn);
  if ((unsigned int )req_status != 0U) {
    __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 3181, (unsigned long long )req_status);
    (*(ms->sm))((void *)ms, 4);
    return;
  } else {

  }
  tmp = bfa_fcxp_get_rspbuf(fcxp);
  cthdr = (struct ct_hdr_s *)tmp;
  tmp___0 = __fswab16((int )cthdr->cmd_rsp_code);
  cthdr->cmd_rsp_code = tmp___0;
  if ((unsigned int )cthdr->cmd_rsp_code == 32770U) {
    gmal_resp = (struct fcgs_gmal_resp_s *)cthdr + 1U;
    tmp___1 = __fswab32(gmal_resp->ms_len);
    num_entries = tmp___1;
    if (num_entries == 0U) {
      (*(ms->sm))((void *)ms, 4);
      return;
    } else {

    }
    gmal_entry = (struct fcgs_gmal_entry_s *)(& gmal_resp->ms_ma);
    goto ldv_49658;
    ldv_49657: 
    tmp___2 = strncmp((char const   *)(& gmal_entry->prefix), "http://", 7UL);
    if (tmp___2 == 0) {
      rsp_str = (u8 *)(& gmal_entry->prefix);
      if ((unsigned int )*(rsp_str + ((unsigned long )gmal_entry->len + 0xffffffffffffffffUL)) == 47U) {
        *(rsp_str + ((unsigned long )gmal_entry->len + 0xffffffffffffffffUL)) = 0U;
      } else {

      }
      strncpy((char *)(& (port->fabric)->fabric_ip_addr), (char const   *)(& gmal_entry->ip_addr),
              16UL);
      goto ldv_49656;
    } else {
      num_entries = num_entries - 1U;
      gmal_entry = gmal_entry + 1;
    }
    ldv_49658: ;
    if (num_entries != 0U) {
      goto ldv_49657;
    } else {

    }
    ldv_49656: 
    (*(ms->sm))((void *)ms, 3);
    return;
  } else {

  }
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 3234, (unsigned long long )cthdr->reason_code);
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 3235, (unsigned long long )cthdr->exp_code);
  (*(ms->sm))((void *)ms, 4);
  return;
}
}
static void bfa_fcs_lport_ms_sm_gfn_sending(struct bfa_fcs_lport_ms_s *ms , enum port_ms_event event ) 
{ 


  {
  __bfa_trc(((ms->port)->fcs)->trcmod, __trc_fileno___7, 3243, (ms->port)->port_cfg.pwwn);
  __bfa_trc(((ms->port)->fcs)->trcmod, __trc_fileno___7, 3244, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 6U: 
  ms->sm = (void (*)(void * , int  ))(& bfa_fcs_lport_ms_sm_gfn);
  goto ldv_49664;
  case 2U: 
  ms->sm = (void (*)(void * , int  ))(& bfa_fcs_lport_ms_sm_offline);
  bfa_fcxp_walloc_cancel(((ms->port)->fcs)->bfa, & ms->fcxp_wqe);
  goto ldv_49664;
  default: 
  __bfa_trc(((ms->port)->fcs)->trcmod, __trc_fileno___7, 3258, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcs_lport.c",
         3258, (unsigned int )event);
  }
  ldv_49664: ;
  return;
}
}
static void bfa_fcs_lport_ms_sm_gfn(struct bfa_fcs_lport_ms_s *ms , enum port_ms_event event ) 
{ 
  u8 tmp ;

  {
  __bfa_trc(((ms->port)->fcs)->trcmod, __trc_fileno___7, 3266, (ms->port)->port_cfg.pwwn);
  __bfa_trc(((ms->port)->fcs)->trcmod, __trc_fileno___7, 3267, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 4U: 
  tmp = ms->retry_cnt;
  ms->retry_cnt = (u8 )((int )ms->retry_cnt + 1);
  if ((unsigned int )tmp <= 1U) {
    ms->sm = (void (*)(void * , int  ))(& bfa_fcs_lport_ms_sm_gfn_retry);
    (ms->port)->stats.ms_retries = (ms->port)->stats.ms_retries + 1U;
    bfa_timer_begin(& (((ms->port)->fcs)->bfa)->timer_mod, & ms->timer, & bfa_fcs_lport_ms_timeout,
                    (void *)ms, 2000U);
  } else {
    ms->sm = (void (*)(void * , int  ))(& bfa_fcs_lport_ms_sm_online);
    ms->retry_cnt = 0U;
  }
  goto ldv_49672;
  case 3U: 
  ms->sm = (void (*)(void * , int  ))(& bfa_fcs_lport_ms_sm_online);
  goto ldv_49672;
  case 2U: 
  ms->sm = (void (*)(void * , int  ))(& bfa_fcs_lport_ms_sm_offline);
  bfa_fcxp_discard(ms->fcxp);
  goto ldv_49672;
  default: 
  __bfa_trc(((ms->port)->fcs)->trcmod, __trc_fileno___7, 3296, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcs_lport.c",
         3296, (unsigned int )event);
  }
  ldv_49672: ;
  return;
}
}
static void bfa_fcs_lport_ms_sm_gfn_retry(struct bfa_fcs_lport_ms_s *ms , enum port_ms_event event ) 
{ 


  {
  __bfa_trc(((ms->port)->fcs)->trcmod, __trc_fileno___7, 3304, (ms->port)->port_cfg.pwwn);
  __bfa_trc(((ms->port)->fcs)->trcmod, __trc_fileno___7, 3305, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 5U: 
  ms->sm = (void (*)(void * , int  ))(& bfa_fcs_lport_ms_sm_gfn_sending);
  bfa_fcs_lport_ms_send_gfn((void *)ms, (struct bfa_fcxp_s *)0);
  goto ldv_49681;
  case 2U: 
  ms->sm = (void (*)(void * , int  ))(& bfa_fcs_lport_ms_sm_offline);
  bfa_timer_stop(& ms->timer);
  goto ldv_49681;
  default: 
  __bfa_trc(((ms->port)->fcs)->trcmod, __trc_fileno___7, 3322, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcs_lport.c",
         3322, (unsigned int )event);
  }
  ldv_49681: ;
  return;
}
}
static void bfa_fcs_lport_ms_send_gfn(void *ms_cbarg , struct bfa_fcxp_s *fcxp_alloced ) 
{ 
  struct bfa_fcs_lport_ms_s *ms ;
  struct bfa_fcs_lport_s *port ;
  struct fchs_s fchs ;
  int len ;
  struct bfa_fcxp_s *fcxp ;
  struct bfa_fcxp_s *tmp ;
  void *tmp___0 ;
  u16 tmp___1 ;

  {
  ms = (struct bfa_fcs_lport_ms_s *)ms_cbarg;
  port = ms->port;
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 3338, (unsigned long long )port->pid);
  if ((unsigned long )fcxp_alloced == (unsigned long )((struct bfa_fcxp_s *)0)) {
    tmp = bfa_fcxp_req_rsp_alloc((void *)0, (port->fcs)->bfa, 0, 0, (u64 (*)(void * ,
                                                                             int  ))0,
                                 (u32 (*)(void * , int  ))0, (u64 (*)(void * , int  ))0,
                                 (u32 (*)(void * , int  ))0, 1);
    fcxp = tmp;
  } else {
    fcxp = fcxp_alloced;
  }
  if ((unsigned long )fcxp == (unsigned long )((struct bfa_fcxp_s *)0)) {
    bfa_fcxp_req_rsp_alloc_wait((port->fcs)->bfa, & ms->fcxp_wqe, & bfa_fcs_lport_ms_send_gfn,
                                (void *)ms, (void *)0, 0, 0, (u64 (*)(void * , int  ))0,
                                (u32 (*)(void * , int  ))0, (u64 (*)(void * , int  ))0,
                                (u32 (*)(void * , int  ))0, 1);
    return;
  } else {

  }
  ms->fcxp = fcxp;
  tmp___0 = bfa_fcxp_get_reqbuf(fcxp);
  tmp___1 = fc_gfn_req_build(& fchs, tmp___0, port->pid, ((port->fabric)->lps)->pr_nwwn);
  len = (int )tmp___1;
  bfa_fcxp_send(fcxp, (struct bfa_rport_s *)0, (int )(port->fabric)->vf_id, (int )port->lp_tag,
                0, 8, (u32 )len, & fchs, & bfa_fcs_lport_ms_gfn_response, (void *)ms,
                2112U, 30);
  (*(ms->sm))((void *)ms, 6);
  return;
}
}
static void bfa_fcs_lport_ms_gfn_response(void *fcsarg , struct bfa_fcxp_s *fcxp ,
                                          void *cbarg , enum bfa_status req_status ,
                                          u32 rsp_len , u32 resid_len , struct fchs_s *rsp_fchs ) 
{ 
  struct bfa_fcs_lport_ms_s *ms ;
  struct bfa_fcs_lport_s *port ;
  struct ct_hdr_s *cthdr ;
  wwn_t *gfn_resp ;
  void *tmp ;
  __u16 tmp___0 ;
  int tmp___1 ;

  {
  ms = (struct bfa_fcs_lport_ms_s *)cbarg;
  port = ms->port;
  cthdr = (struct ct_hdr_s *)0;
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 3371, (unsigned long long )req_status);
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 3372, port->port_cfg.pwwn);
  if ((unsigned int )req_status != 0U) {
    __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 3378, (unsigned long long )req_status);
    (*(ms->sm))((void *)ms, 4);
    return;
  } else {

  }
  tmp = bfa_fcxp_get_rspbuf(fcxp);
  cthdr = (struct ct_hdr_s *)tmp;
  tmp___0 = __fswab16((int )cthdr->cmd_rsp_code);
  cthdr->cmd_rsp_code = tmp___0;
  if ((unsigned int )cthdr->cmd_rsp_code == 32770U) {
    gfn_resp = (wwn_t *)cthdr + 1U;
    tmp___1 = memcmp((void const   *)(& (port->fabric)->fabric_name), (void const   *)gfn_resp,
                     8UL);
    if (tmp___1 != 0) {
      bfa_fcs_fabric_set_fabric_name(port->fabric, *gfn_resp);
    } else {

    }
    (*(ms->sm))((void *)ms, 3);
    return;
  } else {

  }
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 3397, (unsigned long long )cthdr->reason_code);
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 3398, (unsigned long long )cthdr->exp_code);
  (*(ms->sm))((void *)ms, 4);
  return;
}
}
static void bfa_fcs_lport_ms_send_plogi(void *ms_cbarg , struct bfa_fcxp_s *fcxp_alloced ) 
{ 
  struct bfa_fcs_lport_ms_s *ms ;
  struct bfa_fcs_lport_s *port ;
  struct fchs_s fchs ;
  int len ;
  struct bfa_fcxp_s *fcxp ;
  struct bfa_fcxp_s *tmp ;
  u8 tmp___0 ;
  u16 tmp___1 ;
  void *tmp___2 ;
  u16 tmp___3 ;

  {
  ms = (struct bfa_fcs_lport_ms_s *)ms_cbarg;
  port = ms->port;
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 3415, (unsigned long long )port->pid);
  if ((unsigned long )fcxp_alloced == (unsigned long )((struct bfa_fcxp_s *)0)) {
    tmp = bfa_fcxp_req_rsp_alloc((void *)0, (port->fcs)->bfa, 0, 0, (u64 (*)(void * ,
                                                                             int  ))0,
                                 (u32 (*)(void * , int  ))0, (u64 (*)(void * , int  ))0,
                                 (u32 (*)(void * , int  ))0, 1);
    fcxp = tmp;
  } else {
    fcxp = fcxp_alloced;
  }
  if ((unsigned long )fcxp == (unsigned long )((struct bfa_fcxp_s *)0)) {
    port->stats.ms_plogi_alloc_wait = port->stats.ms_plogi_alloc_wait + 1U;
    bfa_fcxp_req_rsp_alloc_wait((port->fcs)->bfa, & ms->fcxp_wqe, & bfa_fcs_lport_ms_send_plogi,
                                (void *)ms, (void *)0, 0, 0, (u64 (*)(void * , int  ))0,
                                (u32 (*)(void * , int  ))0, (u64 (*)(void * , int  ))0,
                                (u32 (*)(void * , int  ))0, 1);
    return;
  } else {

  }
  ms->fcxp = fcxp;
  tmp___0 = bfa_fcport_get_rx_bbcredit((port->fcs)->bfa);
  tmp___1 = bfa_fcport_get_maxfrsize((port->fcs)->bfa);
  tmp___2 = bfa_fcxp_get_reqbuf(fcxp);
  tmp___3 = fc_plogi_build(& fchs, tmp___2, 16449535U, port->pid, 0, port->port_cfg.pwwn,
                           port->port_cfg.nwwn, (int )tmp___1, (int )tmp___0);
  len = (int )tmp___3;
  bfa_fcxp_send(fcxp, (struct bfa_rport_s *)0, (int )(port->fabric)->vf_id, (int )port->lp_tag,
                0, 8, (u32 )len, & fchs, & bfa_fcs_lport_ms_plogi_response, (void *)ms,
                2112U, 20);
  port->stats.ms_plogi_sent = port->stats.ms_plogi_sent + 1U;
  (*(ms->sm))((void *)ms, 6);
  return;
}
}
static void bfa_fcs_lport_ms_plogi_response(void *fcsarg , struct bfa_fcxp_s *fcxp ,
                                            void *cbarg , enum bfa_status req_status ,
                                            u32 rsp_len , u32 resid_len , struct fchs_s *rsp_fchs ) 
{ 
  struct bfa_fcs_lport_ms_s *ms ;
  struct bfa_fcs_lport_s *port ;
  struct fc_els_cmd_s *els_cmd ;
  struct fc_ls_rjt_s *ls_rjt ;
  void *tmp ;
  void *tmp___0 ;

  {
  ms = (struct bfa_fcs_lport_ms_s *)cbarg;
  port = ms->port;
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 3453, (unsigned long long )req_status);
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 3454, port->port_cfg.pwwn);
  if ((unsigned int )req_status != 0U) {
    port->stats.ms_plogi_rsp_err = port->stats.ms_plogi_rsp_err + 1U;
    __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 3461, (unsigned long long )req_status);
    (*(ms->sm))((void *)ms, 4);
    return;
  } else {

  }
  tmp = bfa_fcxp_get_rspbuf(fcxp);
  els_cmd = (struct fc_els_cmd_s *)tmp;
  switch ((int )els_cmd->els_code) {
  case 2: ;
  if (rsp_len <= 115U) {
    __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 3472, (unsigned long long )rsp_len);
    port->stats.ms_plogi_acc_err = port->stats.ms_plogi_acc_err + 1U;
    (*(ms->sm))((void *)ms, 4);
    goto ldv_49729;
  } else {

  }
  port->stats.ms_plogi_accepts = port->stats.ms_plogi_accepts + 1U;
  (*(ms->sm))((void *)ms, 3);
  goto ldv_49729;
  case 1: 
  tmp___0 = bfa_fcxp_get_rspbuf(fcxp);
  ls_rjt = (struct fc_ls_rjt_s *)tmp___0;
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 3484, (unsigned long long )ls_rjt->reason_code);
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 3485, (unsigned long long )ls_rjt->reason_code_expl);
  port->stats.ms_rejects = port->stats.ms_rejects + 1U;
  (*(ms->sm))((void *)ms, 4);
  goto ldv_49729;
  default: 
  port->stats.ms_plogi_unknown_rsp = port->stats.ms_plogi_unknown_rsp + 1U;
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 3493, (unsigned long long )els_cmd->els_code);
  (*(ms->sm))((void *)ms, 4);
  }
  ldv_49729: ;
  return;
}
}
static void bfa_fcs_lport_ms_timeout(void *arg ) 
{ 
  struct bfa_fcs_lport_ms_s *ms ;

  {
  ms = (struct bfa_fcs_lport_ms_s *)arg;
  (ms->port)->stats.ms_timeouts = (ms->port)->stats.ms_timeouts + 1U;
  (*(ms->sm))((void *)ms, 5);
  return;
}
}
void bfa_fcs_lport_ms_init(struct bfa_fcs_lport_s *port ) 
{ 
  struct bfa_fcs_lport_ms_s *ms ;

  {
  ms = & port->port_topo.pfab.ms;
  ms->port = port;
  ms->sm = (void (*)(void * , int  ))(& bfa_fcs_lport_ms_sm_offline);
  bfa_fcs_lport_fdmi_init(ms);
  return;
}
}
void bfa_fcs_lport_ms_offline(struct bfa_fcs_lport_s *port ) 
{ 
  struct bfa_fcs_lport_ms_s *ms ;

  {
  ms = & port->port_topo.pfab.ms;
  ms->port = port;
  (*(ms->sm))((void *)ms, 2);
  bfa_fcs_lport_fdmi_offline(ms);
  return;
}
}
void bfa_fcs_lport_ms_online(struct bfa_fcs_lport_s *port ) 
{ 
  struct bfa_fcs_lport_ms_s *ms ;

  {
  ms = & port->port_topo.pfab.ms;
  ms->port = port;
  (*(ms->sm))((void *)ms, 1);
  return;
}
}
void bfa_fcs_lport_ms_fabric_rscn(struct bfa_fcs_lport_s *port ) 
{ 
  struct bfa_fcs_lport_ms_s *ms ;

  {
  ms = & port->port_topo.pfab.ms;
  if ((unsigned long )ms->sm == (unsigned long )((void (*)(void * , int  ))(& bfa_fcs_lport_ms_sm_online))) {
    (*(ms->sm))((void *)ms, 7);
  } else {

  }
  return;
}
}
static void bfa_fcs_lport_ns_send_plogi(void *ns_cbarg , struct bfa_fcxp_s *fcxp_alloced ) ;
static void bfa_fcs_lport_ns_send_rspn_id(void *ns_cbarg , struct bfa_fcxp_s *fcxp_alloced ) ;
static void bfa_fcs_lport_ns_send_rft_id(void *ns_cbarg , struct bfa_fcxp_s *fcxp_alloced ) ;
static void bfa_fcs_lport_ns_send_rff_id(void *ns_cbarg , struct bfa_fcxp_s *fcxp_alloced ) ;
static void bfa_fcs_lport_ns_send_gid_ft(void *ns_cbarg , struct bfa_fcxp_s *fcxp_alloced ) ;
static void bfa_fcs_lport_ns_send_rnn_id(void *ns_cbarg , struct bfa_fcxp_s *fcxp_alloced ) ;
static void bfa_fcs_lport_ns_send_rsnn_nn(void *ns_cbarg , struct bfa_fcxp_s *fcxp_alloced ) ;
static void bfa_fcs_lport_ns_timeout(void *arg ) ;
static void bfa_fcs_lport_ns_plogi_response(void *fcsarg , struct bfa_fcxp_s *fcxp ,
                                            void *cbarg , enum bfa_status req_status ,
                                            u32 rsp_len , u32 resid_len , struct fchs_s *rsp_fchs ) ;
static void bfa_fcs_lport_ns_rspn_id_response(void *fcsarg , struct bfa_fcxp_s *fcxp ,
                                              void *cbarg , enum bfa_status req_status ,
                                              u32 rsp_len , u32 resid_len , struct fchs_s *rsp_fchs ) ;
static void bfa_fcs_lport_ns_rft_id_response(void *fcsarg , struct bfa_fcxp_s *fcxp ,
                                             void *cbarg , enum bfa_status req_status ,
                                             u32 rsp_len , u32 resid_len , struct fchs_s *rsp_fchs ) ;
static void bfa_fcs_lport_ns_rff_id_response(void *fcsarg , struct bfa_fcxp_s *fcxp ,
                                             void *cbarg , enum bfa_status req_status ,
                                             u32 rsp_len , u32 resid_len , struct fchs_s *rsp_fchs ) ;
static void bfa_fcs_lport_ns_gid_ft_response(void *fcsarg , struct bfa_fcxp_s *fcxp ,
                                             void *cbarg , enum bfa_status req_status ,
                                             u32 rsp_len , u32 resid_len , struct fchs_s *rsp_fchs ) ;
static void bfa_fcs_lport_ns_rnn_id_response(void *fcsarg , struct bfa_fcxp_s *fcxp ,
                                             void *cbarg , enum bfa_status req_status ,
                                             u32 rsp_len , u32 resid_len , struct fchs_s *rsp_fchs ) ;
static void bfa_fcs_lport_ns_rsnn_nn_response(void *fcsarg , struct bfa_fcxp_s *fcxp ,
                                              void *cbarg , enum bfa_status req_status ,
                                              u32 rsp_len , u32 resid_len , struct fchs_s *rsp_fchs ) ;
static void bfa_fcs_lport_ns_process_gidft_pids(struct bfa_fcs_lport_s *port , u32 *pid_buf ,
                                                u32 n_pids ) ;
static void bfa_fcs_lport_ns_boot_target_disc(struct bfa_fcs_lport_s *port ) ;
static void bfa_fcs_lport_ns_sm_offline(struct bfa_fcs_lport_ns_s *ns , enum vport_ns_event event ) ;
static void bfa_fcs_lport_ns_sm_plogi_sending(struct bfa_fcs_lport_ns_s *ns , enum vport_ns_event event ) ;
static void bfa_fcs_lport_ns_sm_plogi(struct bfa_fcs_lport_ns_s *ns , enum vport_ns_event event ) ;
static void bfa_fcs_lport_ns_sm_plogi_retry(struct bfa_fcs_lport_ns_s *ns , enum vport_ns_event event ) ;
static void bfa_fcs_lport_ns_sm_sending_rspn_id(struct bfa_fcs_lport_ns_s *ns , enum vport_ns_event event ) ;
static void bfa_fcs_lport_ns_sm_rspn_id(struct bfa_fcs_lport_ns_s *ns , enum vport_ns_event event ) ;
static void bfa_fcs_lport_ns_sm_rspn_id_retry(struct bfa_fcs_lport_ns_s *ns , enum vport_ns_event event ) ;
static void bfa_fcs_lport_ns_sm_sending_rft_id(struct bfa_fcs_lport_ns_s *ns , enum vport_ns_event event ) ;
static void bfa_fcs_lport_ns_sm_rft_id_retry(struct bfa_fcs_lport_ns_s *ns , enum vport_ns_event event ) ;
static void bfa_fcs_lport_ns_sm_rft_id(struct bfa_fcs_lport_ns_s *ns , enum vport_ns_event event ) ;
static void bfa_fcs_lport_ns_sm_sending_rff_id(struct bfa_fcs_lport_ns_s *ns , enum vport_ns_event event ) ;
static void bfa_fcs_lport_ns_sm_rff_id_retry(struct bfa_fcs_lport_ns_s *ns , enum vport_ns_event event ) ;
static void bfa_fcs_lport_ns_sm_rff_id(struct bfa_fcs_lport_ns_s *ns , enum vport_ns_event event ) ;
static void bfa_fcs_lport_ns_sm_sending_gid_ft(struct bfa_fcs_lport_ns_s *ns , enum vport_ns_event event ) ;
static void bfa_fcs_lport_ns_sm_gid_ft(struct bfa_fcs_lport_ns_s *ns , enum vport_ns_event event ) ;
static void bfa_fcs_lport_ns_sm_gid_ft_retry(struct bfa_fcs_lport_ns_s *ns , enum vport_ns_event event ) ;
static void bfa_fcs_lport_ns_sm_online(struct bfa_fcs_lport_ns_s *ns , enum vport_ns_event event ) ;
static void bfa_fcs_lport_ns_sm_sending_rnn_id(struct bfa_fcs_lport_ns_s *ns , enum vport_ns_event event ) ;
static void bfa_fcs_lport_ns_sm_rnn_id(struct bfa_fcs_lport_ns_s *ns , enum vport_ns_event event ) ;
static void bfa_fcs_lport_ns_sm_rnn_id_retry(struct bfa_fcs_lport_ns_s *ns , enum vport_ns_event event ) ;
static void bfa_fcs_lport_ns_sm_sending_rsnn_nn(struct bfa_fcs_lport_ns_s *ns , enum vport_ns_event event ) ;
static void bfa_fcs_lport_ns_sm_rsnn_nn(struct bfa_fcs_lport_ns_s *ns , enum vport_ns_event event ) ;
static void bfa_fcs_lport_ns_sm_rsnn_nn_retry(struct bfa_fcs_lport_ns_s *ns , enum vport_ns_event event ) ;
static void bfa_fcs_lport_ns_sm_offline(struct bfa_fcs_lport_ns_s *ns , enum vport_ns_event event ) 
{ 


  {
  __bfa_trc(((ns->port)->fcs)->trcmod, __trc_fileno___7, 3714, (ns->port)->port_cfg.pwwn);
  __bfa_trc(((ns->port)->fcs)->trcmod, __trc_fileno___7, 3715, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 1U: 
  ns->sm = (void (*)(void * , int  ))(& bfa_fcs_lport_ns_sm_plogi_sending);
  bfa_fcs_lport_ns_send_plogi((void *)ns, (struct bfa_fcxp_s *)0);
  goto ldv_49925;
  case 2U: ;
  goto ldv_49925;
  default: 
  __bfa_trc(((ns->port)->fcs)->trcmod, __trc_fileno___7, 3727, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcs_lport.c",
         3727, (unsigned int )event);
  }
  ldv_49925: ;
  return;
}
}
static void bfa_fcs_lport_ns_sm_plogi_sending(struct bfa_fcs_lport_ns_s *ns , enum vport_ns_event event ) 
{ 


  {
  __bfa_trc(((ns->port)->fcs)->trcmod, __trc_fileno___7, 3735, (ns->port)->port_cfg.pwwn);
  __bfa_trc(((ns->port)->fcs)->trcmod, __trc_fileno___7, 3736, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 3U: 
  ns->sm = (void (*)(void * , int  ))(& bfa_fcs_lport_ns_sm_plogi);
  goto ldv_49933;
  case 2U: 
  ns->sm = (void (*)(void * , int  ))(& bfa_fcs_lport_ns_sm_offline);
  bfa_fcxp_walloc_cancel(((ns->port)->fcs)->bfa, & ns->fcxp_wqe);
  goto ldv_49933;
  default: 
  __bfa_trc(((ns->port)->fcs)->trcmod, __trc_fileno___7, 3750, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcs_lport.c",
         3750, (unsigned int )event);
  }
  ldv_49933: ;
  return;
}
}
static void bfa_fcs_lport_ns_sm_plogi(struct bfa_fcs_lport_ns_s *ns , enum vport_ns_event event ) 
{ 


  {
  __bfa_trc(((ns->port)->fcs)->trcmod, __trc_fileno___7, 3758, (ns->port)->port_cfg.pwwn);
  __bfa_trc(((ns->port)->fcs)->trcmod, __trc_fileno___7, 3759, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 5U: 
  ns->sm = (void (*)(void * , int  ))(& bfa_fcs_lport_ns_sm_plogi_retry);
  (ns->port)->stats.ns_retries = (ns->port)->stats.ns_retries + 1U;
  bfa_timer_begin(& (((ns->port)->fcs)->bfa)->timer_mod, & ns->timer, & bfa_fcs_lport_ns_timeout,
                  (void *)ns, 2000U);
  goto ldv_49941;
  case 4U: 
  ns->sm = (void (*)(void * , int  ))(& bfa_fcs_lport_ns_sm_sending_rnn_id);
  ns->num_rnnid_retries = 0U;
  bfa_fcs_lport_ns_send_rnn_id((void *)ns, (struct bfa_fcxp_s *)0);
  goto ldv_49941;
  case 2U: 
  ns->sm = (void (*)(void * , int  ))(& bfa_fcs_lport_ns_sm_offline);
  bfa_fcxp_discard(ns->fcxp);
  goto ldv_49941;
  default: 
  __bfa_trc(((ns->port)->fcs)->trcmod, __trc_fileno___7, 3785, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcs_lport.c",
         3785, (unsigned int )event);
  }
  ldv_49941: ;
  return;
}
}
static void bfa_fcs_lport_ns_sm_plogi_retry(struct bfa_fcs_lport_ns_s *ns , enum vport_ns_event event ) 
{ 


  {
  __bfa_trc(((ns->port)->fcs)->trcmod, __trc_fileno___7, 3793, (ns->port)->port_cfg.pwwn);
  __bfa_trc(((ns->port)->fcs)->trcmod, __trc_fileno___7, 3794, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 6U: 
  ns->sm = (void (*)(void * , int  ))(& bfa_fcs_lport_ns_sm_plogi_sending);
  bfa_fcs_lport_ns_send_plogi((void *)ns, (struct bfa_fcxp_s *)0);
  goto ldv_49950;
  case 2U: 
  ns->sm = (void (*)(void * , int  ))(& bfa_fcs_lport_ns_sm_offline);
  bfa_timer_stop(& ns->timer);
  goto ldv_49950;
  default: 
  __bfa_trc(((ns->port)->fcs)->trcmod, __trc_fileno___7, 3811, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcs_lport.c",
         3811, (unsigned int )event);
  }
  ldv_49950: ;
  return;
}
}
static void bfa_fcs_lport_ns_sm_sending_rnn_id(struct bfa_fcs_lport_ns_s *ns , enum vport_ns_event event ) 
{ 


  {
  __bfa_trc(((ns->port)->fcs)->trcmod, __trc_fileno___7, 3819, (ns->port)->port_cfg.pwwn);
  __bfa_trc(((ns->port)->fcs)->trcmod, __trc_fileno___7, 3820, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 12U: 
  ns->sm = (void (*)(void * , int  ))(& bfa_fcs_lport_ns_sm_rnn_id);
  goto ldv_49958;
  case 2U: 
  ns->sm = (void (*)(void * , int  ))(& bfa_fcs_lport_ns_sm_offline);
  bfa_fcxp_walloc_cancel(((ns->port)->fcs)->bfa, & ns->fcxp_wqe);
  goto ldv_49958;
  default: 
  __bfa_trc(((ns->port)->fcs)->trcmod, __trc_fileno___7, 3833, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcs_lport.c",
         3833, (unsigned int )event);
  }
  ldv_49958: ;
  return;
}
}
static void bfa_fcs_lport_ns_sm_rnn_id(struct bfa_fcs_lport_ns_s *ns , enum vport_ns_event event ) 
{ 


  {
  __bfa_trc(((ns->port)->fcs)->trcmod, __trc_fileno___7, 3841, (ns->port)->port_cfg.pwwn);
  __bfa_trc(((ns->port)->fcs)->trcmod, __trc_fileno___7, 3842, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 4U: 
  ns->sm = (void (*)(void * , int  ))(& bfa_fcs_lport_ns_sm_sending_rsnn_nn);
  ns->num_rnnid_retries = 0U;
  ns->num_rsnn_nn_retries = 0U;
  bfa_fcs_lport_ns_send_rsnn_nn((void *)ns, (struct bfa_fcxp_s *)0);
  goto ldv_49966;
  case 5U: ;
  if ((unsigned int )ns->num_rnnid_retries <= 4U) {
    ns->sm = (void (*)(void * , int  ))(& bfa_fcs_lport_ns_sm_rnn_id_retry);
    (ns->port)->stats.ns_retries = (ns->port)->stats.ns_retries + 1U;
    ns->num_rnnid_retries = (u8 )((int )ns->num_rnnid_retries + 1);
    bfa_timer_begin(& (((ns->port)->fcs)->bfa)->timer_mod, & ns->timer, & bfa_fcs_lport_ns_timeout,
                    (void *)ns, 2000U);
  } else {
    ns->sm = (void (*)(void * , int  ))(& bfa_fcs_lport_ns_sm_sending_rspn_id);
    bfa_fcs_lport_ns_send_rspn_id((void *)ns, (struct bfa_fcxp_s *)0);
  }
  goto ldv_49966;
  case 2U: 
  bfa_fcxp_discard(ns->fcxp);
  ns->sm = (void (*)(void * , int  ))(& bfa_fcs_lport_ns_sm_offline);
  goto ldv_49966;
  default: 
  __bfa_trc(((ns->port)->fcs)->trcmod, __trc_fileno___7, 3873, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcs_lport.c",
         3873, (unsigned int )event);
  }
  ldv_49966: ;
  return;
}
}
static void bfa_fcs_lport_ns_sm_rnn_id_retry(struct bfa_fcs_lport_ns_s *ns , enum vport_ns_event event ) 
{ 


  {
  __bfa_trc(((ns->port)->fcs)->trcmod, __trc_fileno___7, 3881, (ns->port)->port_cfg.pwwn);
  __bfa_trc(((ns->port)->fcs)->trcmod, __trc_fileno___7, 3882, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 6U: 
  ns->sm = (void (*)(void * , int  ))(& bfa_fcs_lport_ns_sm_sending_rnn_id);
  bfa_fcs_lport_ns_send_rnn_id((void *)ns, (struct bfa_fcxp_s *)0);
  goto ldv_49975;
  case 2U: 
  ns->sm = (void (*)(void * , int  ))(& bfa_fcs_lport_ns_sm_offline);
  bfa_timer_stop(& ns->timer);
  goto ldv_49975;
  default: 
  __bfa_trc(((ns->port)->fcs)->trcmod, __trc_fileno___7, 3896, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcs_lport.c",
         3896, (unsigned int )event);
  }
  ldv_49975: ;
  return;
}
}
static void bfa_fcs_lport_ns_sm_sending_rsnn_nn(struct bfa_fcs_lport_ns_s *ns , enum vport_ns_event event ) 
{ 


  {
  __bfa_trc(((ns->port)->fcs)->trcmod, __trc_fileno___7, 3904, (ns->port)->port_cfg.pwwn);
  __bfa_trc(((ns->port)->fcs)->trcmod, __trc_fileno___7, 3905, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 13U: 
  ns->sm = (void (*)(void * , int  ))(& bfa_fcs_lport_ns_sm_rsnn_nn);
  goto ldv_49983;
  case 2U: 
  ns->sm = (void (*)(void * , int  ))(& bfa_fcs_lport_ns_sm_offline);
  bfa_fcxp_walloc_cancel(((ns->port)->fcs)->bfa, & ns->fcxp_wqe);
  goto ldv_49983;
  default: 
  __bfa_trc(((ns->port)->fcs)->trcmod, __trc_fileno___7, 3919, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcs_lport.c",
         3919, (unsigned int )event);
  }
  ldv_49983: ;
  return;
}
}
static void bfa_fcs_lport_ns_sm_rsnn_nn(struct bfa_fcs_lport_ns_s *ns , enum vport_ns_event event ) 
{ 


  {
  __bfa_trc(((ns->port)->fcs)->trcmod, __trc_fileno___7, 3927, (ns->port)->port_cfg.pwwn);
  __bfa_trc(((ns->port)->fcs)->trcmod, __trc_fileno___7, 3928, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 4U: 
  ns->sm = (void (*)(void * , int  ))(& bfa_fcs_lport_ns_sm_sending_rspn_id);
  ns->num_rsnn_nn_retries = 0U;
  bfa_fcs_lport_ns_send_rspn_id((void *)ns, (struct bfa_fcxp_s *)0);
  goto ldv_49991;
  case 5U: ;
  if ((unsigned int )ns->num_rsnn_nn_retries <= 4U) {
    ns->sm = (void (*)(void * , int  ))(& bfa_fcs_lport_ns_sm_rsnn_nn_retry);
    (ns->port)->stats.ns_retries = (ns->port)->stats.ns_retries + 1U;
    ns->num_rsnn_nn_retries = (u8 )((int )ns->num_rsnn_nn_retries + 1);
    bfa_timer_begin(& (((ns->port)->fcs)->bfa)->timer_mod, & ns->timer, & bfa_fcs_lport_ns_timeout,
                    (void *)ns, 2000U);
  } else {
    ns->sm = (void (*)(void * , int  ))(& bfa_fcs_lport_ns_sm_sending_rspn_id);
    bfa_fcs_lport_ns_send_rspn_id((void *)ns, (struct bfa_fcxp_s *)0);
  }
  goto ldv_49991;
  case 2U: 
  ns->sm = (void (*)(void * , int  ))(& bfa_fcs_lport_ns_sm_offline);
  bfa_fcxp_discard(ns->fcxp);
  goto ldv_49991;
  default: 
  __bfa_trc(((ns->port)->fcs)->trcmod, __trc_fileno___7, 3958, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcs_lport.c",
         3958, (unsigned int )event);
  }
  ldv_49991: ;
  return;
}
}
static void bfa_fcs_lport_ns_sm_rsnn_nn_retry(struct bfa_fcs_lport_ns_s *ns , enum vport_ns_event event ) 
{ 


  {
  __bfa_trc(((ns->port)->fcs)->trcmod, __trc_fileno___7, 3966, (ns->port)->port_cfg.pwwn);
  __bfa_trc(((ns->port)->fcs)->trcmod, __trc_fileno___7, 3967, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 6U: 
  ns->sm = (void (*)(void * , int  ))(& bfa_fcs_lport_ns_sm_sending_rsnn_nn);
  bfa_fcs_lport_ns_send_rsnn_nn((void *)ns, (struct bfa_fcxp_s *)0);
  goto ldv_50000;
  case 2U: 
  ns->sm = (void (*)(void * , int  ))(& bfa_fcs_lport_ns_sm_offline);
  bfa_timer_stop(& ns->timer);
  goto ldv_50000;
  default: 
  __bfa_trc(((ns->port)->fcs)->trcmod, __trc_fileno___7, 3981, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcs_lport.c",
         3981, (unsigned int )event);
  }
  ldv_50000: ;
  return;
}
}
static void bfa_fcs_lport_ns_sm_sending_rspn_id(struct bfa_fcs_lport_ns_s *ns , enum vport_ns_event event ) 
{ 


  {
  __bfa_trc(((ns->port)->fcs)->trcmod, __trc_fileno___7, 3989, (ns->port)->port_cfg.pwwn);
  __bfa_trc(((ns->port)->fcs)->trcmod, __trc_fileno___7, 3990, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 8U: 
  ns->sm = (void (*)(void * , int  ))(& bfa_fcs_lport_ns_sm_rspn_id);
  goto ldv_50008;
  case 2U: 
  ns->sm = (void (*)(void * , int  ))(& bfa_fcs_lport_ns_sm_offline);
  bfa_fcxp_walloc_cancel(((ns->port)->fcs)->bfa, & ns->fcxp_wqe);
  goto ldv_50008;
  default: 
  __bfa_trc(((ns->port)->fcs)->trcmod, __trc_fileno___7, 4004, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcs_lport.c",
         4004, (unsigned int )event);
  }
  ldv_50008: ;
  return;
}
}
static void bfa_fcs_lport_ns_sm_rspn_id(struct bfa_fcs_lport_ns_s *ns , enum vport_ns_event event ) 
{ 


  {
  __bfa_trc(((ns->port)->fcs)->trcmod, __trc_fileno___7, 4012, (ns->port)->port_cfg.pwwn);
  __bfa_trc(((ns->port)->fcs)->trcmod, __trc_fileno___7, 4013, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 5U: 
  ns->sm = (void (*)(void * , int  ))(& bfa_fcs_lport_ns_sm_rspn_id_retry);
  (ns->port)->stats.ns_retries = (ns->port)->stats.ns_retries + 1U;
  bfa_timer_begin(& (((ns->port)->fcs)->bfa)->timer_mod, & ns->timer, & bfa_fcs_lport_ns_timeout,
                  (void *)ns, 2000U);
  goto ldv_50016;
  case 4U: 
  ns->sm = (void (*)(void * , int  ))(& bfa_fcs_lport_ns_sm_sending_rft_id);
  bfa_fcs_lport_ns_send_rft_id((void *)ns, (struct bfa_fcxp_s *)0);
  goto ldv_50016;
  case 2U: 
  bfa_fcxp_discard(ns->fcxp);
  ns->sm = (void (*)(void * , int  ))(& bfa_fcs_lport_ns_sm_offline);
  goto ldv_50016;
  default: 
  __bfa_trc(((ns->port)->fcs)->trcmod, __trc_fileno___7, 4038, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcs_lport.c",
         4038, (unsigned int )event);
  }
  ldv_50016: ;
  return;
}
}
static void bfa_fcs_lport_ns_sm_rspn_id_retry(struct bfa_fcs_lport_ns_s *ns , enum vport_ns_event event ) 
{ 


  {
  __bfa_trc(((ns->port)->fcs)->trcmod, __trc_fileno___7, 4046, (ns->port)->port_cfg.pwwn);
  __bfa_trc(((ns->port)->fcs)->trcmod, __trc_fileno___7, 4047, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 6U: 
  ns->sm = (void (*)(void * , int  ))(& bfa_fcs_lport_ns_sm_sending_rspn_id);
  bfa_fcs_lport_ns_send_rspn_id((void *)ns, (struct bfa_fcxp_s *)0);
  goto ldv_50025;
  case 2U: 
  ns->sm = (void (*)(void * , int  ))(& bfa_fcs_lport_ns_sm_offline);
  bfa_timer_stop(& ns->timer);
  goto ldv_50025;
  default: 
  __bfa_trc(((ns->port)->fcs)->trcmod, __trc_fileno___7, 4064, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcs_lport.c",
         4064, (unsigned int )event);
  }
  ldv_50025: ;
  return;
}
}
static void bfa_fcs_lport_ns_sm_sending_rft_id(struct bfa_fcs_lport_ns_s *ns , enum vport_ns_event event ) 
{ 


  {
  __bfa_trc(((ns->port)->fcs)->trcmod, __trc_fileno___7, 4072, (ns->port)->port_cfg.pwwn);
  __bfa_trc(((ns->port)->fcs)->trcmod, __trc_fileno___7, 4073, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 9U: 
  ns->sm = (void (*)(void * , int  ))(& bfa_fcs_lport_ns_sm_rft_id);
  goto ldv_50033;
  case 2U: 
  ns->sm = (void (*)(void * , int  ))(& bfa_fcs_lport_ns_sm_offline);
  bfa_fcxp_walloc_cancel(((ns->port)->fcs)->bfa, & ns->fcxp_wqe);
  goto ldv_50033;
  default: 
  __bfa_trc(((ns->port)->fcs)->trcmod, __trc_fileno___7, 4087, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcs_lport.c",
         4087, (unsigned int )event);
  }
  ldv_50033: ;
  return;
}
}
static void bfa_fcs_lport_ns_sm_rft_id(struct bfa_fcs_lport_ns_s *ns , enum vport_ns_event event ) 
{ 


  {
  __bfa_trc(((ns->port)->fcs)->trcmod, __trc_fileno___7, 4095, (ns->port)->port_cfg.pwwn);
  __bfa_trc(((ns->port)->fcs)->trcmod, __trc_fileno___7, 4096, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 4U: 
  ns->sm = (void (*)(void * , int  ))(& bfa_fcs_lport_ns_sm_sending_rff_id);
  bfa_fcs_lport_ns_send_rff_id((void *)ns, (struct bfa_fcxp_s *)0);
  goto ldv_50041;
  case 5U: 
  ns->sm = (void (*)(void * , int  ))(& bfa_fcs_lport_ns_sm_rft_id_retry);
  (ns->port)->stats.ns_retries = (ns->port)->stats.ns_retries + 1U;
  bfa_timer_begin(& (((ns->port)->fcs)->bfa)->timer_mod, & ns->timer, & bfa_fcs_lport_ns_timeout,
                  (void *)ns, 2000U);
  goto ldv_50041;
  case 2U: 
  ns->sm = (void (*)(void * , int  ))(& bfa_fcs_lport_ns_sm_offline);
  bfa_fcxp_discard(ns->fcxp);
  goto ldv_50041;
  default: 
  __bfa_trc(((ns->port)->fcs)->trcmod, __trc_fileno___7, 4122, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcs_lport.c",
         4122, (unsigned int )event);
  }
  ldv_50041: ;
  return;
}
}
static void bfa_fcs_lport_ns_sm_rft_id_retry(struct bfa_fcs_lport_ns_s *ns , enum vport_ns_event event ) 
{ 


  {
  __bfa_trc(((ns->port)->fcs)->trcmod, __trc_fileno___7, 4130, (ns->port)->port_cfg.pwwn);
  __bfa_trc(((ns->port)->fcs)->trcmod, __trc_fileno___7, 4131, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 6U: 
  ns->sm = (void (*)(void * , int  ))(& bfa_fcs_lport_ns_sm_sending_rft_id);
  bfa_fcs_lport_ns_send_rft_id((void *)ns, (struct bfa_fcxp_s *)0);
  goto ldv_50050;
  case 2U: 
  ns->sm = (void (*)(void * , int  ))(& bfa_fcs_lport_ns_sm_offline);
  bfa_timer_stop(& ns->timer);
  goto ldv_50050;
  default: 
  __bfa_trc(((ns->port)->fcs)->trcmod, __trc_fileno___7, 4145, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcs_lport.c",
         4145, (unsigned int )event);
  }
  ldv_50050: ;
  return;
}
}
static void bfa_fcs_lport_ns_sm_sending_rff_id(struct bfa_fcs_lport_ns_s *ns , enum vport_ns_event event ) 
{ 


  {
  __bfa_trc(((ns->port)->fcs)->trcmod, __trc_fileno___7, 4153, (ns->port)->port_cfg.pwwn);
  __bfa_trc(((ns->port)->fcs)->trcmod, __trc_fileno___7, 4154, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 10U: 
  ns->sm = (void (*)(void * , int  ))(& bfa_fcs_lport_ns_sm_rff_id);
  goto ldv_50058;
  case 2U: 
  ns->sm = (void (*)(void * , int  ))(& bfa_fcs_lport_ns_sm_offline);
  bfa_fcxp_walloc_cancel(((ns->port)->fcs)->bfa, & ns->fcxp_wqe);
  goto ldv_50058;
  default: 
  __bfa_trc(((ns->port)->fcs)->trcmod, __trc_fileno___7, 4168, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcs_lport.c",
         4168, (unsigned int )event);
  }
  ldv_50058: ;
  return;
}
}
static void bfa_fcs_lport_ns_sm_rff_id(struct bfa_fcs_lport_ns_s *ns , enum vport_ns_event event ) 
{ 


  {
  __bfa_trc(((ns->port)->fcs)->trcmod, __trc_fileno___7, 4176, (ns->port)->port_cfg.pwwn);
  __bfa_trc(((ns->port)->fcs)->trcmod, __trc_fileno___7, 4177, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 4U: ;
  if ((unsigned int )((ns->port)->fcs)->min_cfg != 0U) {
    bfa_fcs_lport_ns_boot_target_disc(ns->port);
    ns->sm = (void (*)(void * , int  ))(& bfa_fcs_lport_ns_sm_online);
    return;
  } else {

  }
  if ((int )(ns->port)->port_cfg.roles & 1) {
    ns->sm = (void (*)(void * , int  ))(& bfa_fcs_lport_ns_sm_sending_gid_ft);
    bfa_fcs_lport_ns_send_gid_ft((void *)ns, (struct bfa_fcxp_s *)0);
  } else {

  }
  bfa_fcs_lport_ms_online(ns->port);
  goto ldv_50066;
  case 5U: 
  ns->sm = (void (*)(void * , int  ))(& bfa_fcs_lport_ns_sm_rff_id_retry);
  (ns->port)->stats.ns_retries = (ns->port)->stats.ns_retries + 1U;
  bfa_timer_begin(& (((ns->port)->fcs)->bfa)->timer_mod, & ns->timer, & bfa_fcs_lport_ns_timeout,
                  (void *)ns, 2000U);
  goto ldv_50066;
  case 2U: 
  ns->sm = (void (*)(void * , int  ))(& bfa_fcs_lport_ns_sm_offline);
  bfa_fcxp_discard(ns->fcxp);
  goto ldv_50066;
  default: 
  __bfa_trc(((ns->port)->fcs)->trcmod, __trc_fileno___7, 4225, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcs_lport.c",
         4225, (unsigned int )event);
  }
  ldv_50066: ;
  return;
}
}
static void bfa_fcs_lport_ns_sm_rff_id_retry(struct bfa_fcs_lport_ns_s *ns , enum vport_ns_event event ) 
{ 


  {
  __bfa_trc(((ns->port)->fcs)->trcmod, __trc_fileno___7, 4233, (ns->port)->port_cfg.pwwn);
  __bfa_trc(((ns->port)->fcs)->trcmod, __trc_fileno___7, 4234, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 6U: 
  ns->sm = (void (*)(void * , int  ))(& bfa_fcs_lport_ns_sm_sending_rff_id);
  bfa_fcs_lport_ns_send_rff_id((void *)ns, (struct bfa_fcxp_s *)0);
  goto ldv_50075;
  case 2U: 
  ns->sm = (void (*)(void * , int  ))(& bfa_fcs_lport_ns_sm_offline);
  bfa_timer_stop(& ns->timer);
  goto ldv_50075;
  default: 
  __bfa_trc(((ns->port)->fcs)->trcmod, __trc_fileno___7, 4248, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcs_lport.c",
         4248, (unsigned int )event);
  }
  ldv_50075: ;
  return;
}
}
static void bfa_fcs_lport_ns_sm_sending_gid_ft(struct bfa_fcs_lport_ns_s *ns , enum vport_ns_event event ) 
{ 


  {
  __bfa_trc(((ns->port)->fcs)->trcmod, __trc_fileno___7, 4255, (ns->port)->port_cfg.pwwn);
  __bfa_trc(((ns->port)->fcs)->trcmod, __trc_fileno___7, 4256, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 11U: 
  ns->sm = (void (*)(void * , int  ))(& bfa_fcs_lport_ns_sm_gid_ft);
  goto ldv_50083;
  case 2U: 
  ns->sm = (void (*)(void * , int  ))(& bfa_fcs_lport_ns_sm_offline);
  bfa_fcxp_walloc_cancel(((ns->port)->fcs)->bfa, & ns->fcxp_wqe);
  goto ldv_50083;
  default: 
  __bfa_trc(((ns->port)->fcs)->trcmod, __trc_fileno___7, 4270, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcs_lport.c",
         4270, (unsigned int )event);
  }
  ldv_50083: ;
  return;
}
}
static void bfa_fcs_lport_ns_sm_gid_ft(struct bfa_fcs_lport_ns_s *ns , enum vport_ns_event event ) 
{ 


  {
  __bfa_trc(((ns->port)->fcs)->trcmod, __trc_fileno___7, 4278, (ns->port)->port_cfg.pwwn);
  __bfa_trc(((ns->port)->fcs)->trcmod, __trc_fileno___7, 4279, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 4U: 
  ns->sm = (void (*)(void * , int  ))(& bfa_fcs_lport_ns_sm_online);
  goto ldv_50091;
  case 5U: 
  ns->sm = (void (*)(void * , int  ))(& bfa_fcs_lport_ns_sm_gid_ft_retry);
  (ns->port)->stats.ns_retries = (ns->port)->stats.ns_retries + 1U;
  bfa_timer_begin(& (((ns->port)->fcs)->bfa)->timer_mod, & ns->timer, & bfa_fcs_lport_ns_timeout,
                  (void *)ns, 2000U);
  goto ldv_50091;
  case 2U: 
  ns->sm = (void (*)(void * , int  ))(& bfa_fcs_lport_ns_sm_offline);
  bfa_fcxp_discard(ns->fcxp);
  goto ldv_50091;
  case 7U: ;
  goto ldv_50091;
  default: 
  __bfa_trc(((ns->port)->fcs)->trcmod, __trc_fileno___7, 4309, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcs_lport.c",
         4309, (unsigned int )event);
  }
  ldv_50091: ;
  return;
}
}
static void bfa_fcs_lport_ns_sm_gid_ft_retry(struct bfa_fcs_lport_ns_s *ns , enum vport_ns_event event ) 
{ 


  {
  __bfa_trc(((ns->port)->fcs)->trcmod, __trc_fileno___7, 4317, (ns->port)->port_cfg.pwwn);
  __bfa_trc(((ns->port)->fcs)->trcmod, __trc_fileno___7, 4318, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 6U: 
  ns->sm = (void (*)(void * , int  ))(& bfa_fcs_lport_ns_sm_sending_gid_ft);
  bfa_fcs_lport_ns_send_gid_ft((void *)ns, (struct bfa_fcxp_s *)0);
  goto ldv_50101;
  case 2U: 
  ns->sm = (void (*)(void * , int  ))(& bfa_fcs_lport_ns_sm_offline);
  bfa_timer_stop(& ns->timer);
  goto ldv_50101;
  default: 
  __bfa_trc(((ns->port)->fcs)->trcmod, __trc_fileno___7, 4332, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcs_lport.c",
         4332, (unsigned int )event);
  }
  ldv_50101: ;
  return;
}
}
static void bfa_fcs_lport_ns_sm_online(struct bfa_fcs_lport_ns_s *ns , enum vport_ns_event event ) 
{ 


  {
  __bfa_trc(((ns->port)->fcs)->trcmod, __trc_fileno___7, 4340, (ns->port)->port_cfg.pwwn);
  __bfa_trc(((ns->port)->fcs)->trcmod, __trc_fileno___7, 4341, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 2U: 
  ns->sm = (void (*)(void * , int  ))(& bfa_fcs_lport_ns_sm_offline);
  goto ldv_50109;
  case 7U: ;
  if ((int )(ns->port)->port_cfg.roles & 1) {
    ns->sm = (void (*)(void * , int  ))(& bfa_fcs_lport_ns_sm_sending_gid_ft);
    bfa_fcs_lport_ns_send_gid_ft((void *)ns, (struct bfa_fcxp_s *)0);
  } else {

  }
  goto ldv_50109;
  default: 
  __bfa_trc(((ns->port)->fcs)->trcmod, __trc_fileno___7, 4361, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcs_lport.c",
         4361, (unsigned int )event);
  }
  ldv_50109: ;
  return;
}
}
static void bfa_fcs_lport_ns_send_plogi(void *ns_cbarg , struct bfa_fcxp_s *fcxp_alloced ) 
{ 
  struct bfa_fcs_lport_ns_s *ns ;
  struct bfa_fcs_lport_s *port ;
  struct fchs_s fchs ;
  int len ;
  struct bfa_fcxp_s *fcxp ;
  struct bfa_fcxp_s *tmp ;
  u8 tmp___0 ;
  u16 tmp___1 ;
  void *tmp___2 ;
  u16 tmp___3 ;

  {
  ns = (struct bfa_fcs_lport_ns_s *)ns_cbarg;
  port = ns->port;
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 4380, (unsigned long long )port->pid);
  if ((unsigned long )fcxp_alloced == (unsigned long )((struct bfa_fcxp_s *)0)) {
    tmp = bfa_fcxp_req_rsp_alloc((void *)0, (port->fcs)->bfa, 0, 0, (u64 (*)(void * ,
                                                                             int  ))0,
                                 (u32 (*)(void * , int  ))0, (u64 (*)(void * , int  ))0,
                                 (u32 (*)(void * , int  ))0, 1);
    fcxp = tmp;
  } else {
    fcxp = fcxp_alloced;
  }
  if ((unsigned long )fcxp == (unsigned long )((struct bfa_fcxp_s *)0)) {
    port->stats.ns_plogi_alloc_wait = port->stats.ns_plogi_alloc_wait + 1U;
    bfa_fcxp_req_rsp_alloc_wait((port->fcs)->bfa, & ns->fcxp_wqe, & bfa_fcs_lport_ns_send_plogi,
                                (void *)ns, (void *)0, 0, 0, (u64 (*)(void * , int  ))0,
                                (u32 (*)(void * , int  ))0, (u64 (*)(void * , int  ))0,
                                (u32 (*)(void * , int  ))0, 1);
    return;
  } else {

  }
  ns->fcxp = fcxp;
  tmp___0 = bfa_fcport_get_rx_bbcredit((port->fcs)->bfa);
  tmp___1 = bfa_fcport_get_maxfrsize((port->fcs)->bfa);
  tmp___2 = bfa_fcxp_get_reqbuf(fcxp);
  tmp___3 = fc_plogi_build(& fchs, tmp___2, 16580607U, port->pid, 0, port->port_cfg.pwwn,
                           port->port_cfg.nwwn, (int )tmp___1, (int )tmp___0);
  len = (int )tmp___3;
  bfa_fcxp_send(fcxp, (struct bfa_rport_s *)0, (int )(port->fabric)->vf_id, (int )port->lp_tag,
                0, 8, (u32 )len, & fchs, & bfa_fcs_lport_ns_plogi_response, (void *)ns,
                2112U, 20);
  port->stats.ns_plogi_sent = port->stats.ns_plogi_sent + 1U;
  (*(ns->sm))((void *)ns, 3);
  return;
}
}
static void bfa_fcs_lport_ns_plogi_response(void *fcsarg , struct bfa_fcxp_s *fcxp ,
                                            void *cbarg , enum bfa_status req_status ,
                                            u32 rsp_len , u32 resid_len , struct fchs_s *rsp_fchs ) 
{ 
  struct bfa_fcs_lport_ns_s *ns ;
  struct bfa_fcs_lport_s *port ;
  struct fc_els_cmd_s *els_cmd ;
  struct fc_ls_rjt_s *ls_rjt ;
  void *tmp ;
  void *tmp___0 ;

  {
  ns = (struct bfa_fcs_lport_ns_s *)cbarg;
  port = ns->port;
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 4419, (unsigned long long )req_status);
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 4420, port->port_cfg.pwwn);
  if ((unsigned int )req_status != 0U) {
    __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 4426, (unsigned long long )req_status);
    port->stats.ns_plogi_rsp_err = port->stats.ns_plogi_rsp_err + 1U;
    (*(ns->sm))((void *)ns, 5);
    return;
  } else {

  }
  tmp = bfa_fcxp_get_rspbuf(fcxp);
  els_cmd = (struct fc_els_cmd_s *)tmp;
  switch ((int )els_cmd->els_code) {
  case 2: ;
  if (rsp_len <= 115U) {
    __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 4438, (unsigned long long )rsp_len);
    port->stats.ns_plogi_acc_err = port->stats.ns_plogi_acc_err + 1U;
    (*(ns->sm))((void *)ns, 5);
    goto ldv_50135;
  } else {

  }
  port->stats.ns_plogi_accepts = port->stats.ns_plogi_accepts + 1U;
  (*(ns->sm))((void *)ns, 4);
  goto ldv_50135;
  case 1: 
  tmp___0 = bfa_fcxp_get_rspbuf(fcxp);
  ls_rjt = (struct fc_ls_rjt_s *)tmp___0;
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 4450, (unsigned long long )ls_rjt->reason_code);
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 4451, (unsigned long long )ls_rjt->reason_code_expl);
  port->stats.ns_rejects = port->stats.ns_rejects + 1U;
  (*(ns->sm))((void *)ns, 5);
  goto ldv_50135;
  default: 
  port->stats.ns_plogi_unknown_rsp = port->stats.ns_plogi_unknown_rsp + 1U;
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 4460, (unsigned long long )els_cmd->els_code);
  (*(ns->sm))((void *)ns, 5);
  }
  ldv_50135: ;
  return;
}
}
static void bfa_fcs_lport_ns_send_rnn_id(void *ns_cbarg , struct bfa_fcxp_s *fcxp_alloced ) 
{ 
  struct bfa_fcs_lport_ns_s *ns ;
  struct bfa_fcs_lport_s *port ;
  struct fchs_s fchs ;
  int len ;
  struct bfa_fcxp_s *fcxp ;
  struct bfa_fcxp_s *tmp ;
  void *tmp___0 ;
  u16 tmp___1 ;

  {
  ns = (struct bfa_fcs_lport_ns_s *)ns_cbarg;
  port = ns->port;
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 4477, port->port_cfg.pwwn);
  if ((unsigned long )fcxp_alloced == (unsigned long )((struct bfa_fcxp_s *)0)) {
    tmp = bfa_fcxp_req_rsp_alloc((void *)0, (port->fcs)->bfa, 0, 0, (u64 (*)(void * ,
                                                                             int  ))0,
                                 (u32 (*)(void * , int  ))0, (u64 (*)(void * , int  ))0,
                                 (u32 (*)(void * , int  ))0, 1);
    fcxp = tmp;
  } else {
    fcxp = fcxp_alloced;
  }
  if ((unsigned long )fcxp == (unsigned long )((struct bfa_fcxp_s *)0)) {
    port->stats.ns_rnnid_alloc_wait = port->stats.ns_rnnid_alloc_wait + 1U;
    bfa_fcxp_req_rsp_alloc_wait((port->fcs)->bfa, & ns->fcxp_wqe, & bfa_fcs_lport_ns_send_rnn_id,
                                (void *)ns, (void *)0, 0, 0, (u64 (*)(void * , int  ))0,
                                (u32 (*)(void * , int  ))0, (u64 (*)(void * , int  ))0,
                                (u32 (*)(void * , int  ))0, 1);
    return;
  } else {

  }
  ns->fcxp = fcxp;
  tmp___0 = bfa_fcxp_get_reqbuf(fcxp);
  tmp___1 = fc_rnnid_build(& fchs, tmp___0, port->pid, port->pid, port->port_cfg.nwwn);
  len = (int )tmp___1;
  bfa_fcxp_send(fcxp, (struct bfa_rport_s *)0, (int )(port->fabric)->vf_id, (int )port->lp_tag,
                0, 8, (u32 )len, & fchs, & bfa_fcs_lport_ns_rnn_id_response, (void *)ns,
                2112U, 30);
  port->stats.ns_rnnid_sent = port->stats.ns_rnnid_sent + 1U;
  (*(ns->sm))((void *)ns, 12);
  return;
}
}
static void bfa_fcs_lport_ns_rnn_id_response(void *fcsarg , struct bfa_fcxp_s *fcxp ,
                                             void *cbarg , enum bfa_status req_status ,
                                             u32 rsp_len , u32 resid_len , struct fchs_s *rsp_fchs ) 
{ 
  struct bfa_fcs_lport_ns_s *ns ;
  struct bfa_fcs_lport_s *port ;
  struct ct_hdr_s *cthdr ;
  void *tmp ;
  __u16 tmp___0 ;

  {
  ns = (struct bfa_fcs_lport_ns_s *)cbarg;
  port = ns->port;
  cthdr = (struct ct_hdr_s *)0;
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 4515, port->port_cfg.pwwn);
  if ((unsigned int )req_status != 0U) {
    __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 4521, (unsigned long long )req_status);
    port->stats.ns_rnnid_rsp_err = port->stats.ns_rnnid_rsp_err + 1U;
    (*(ns->sm))((void *)ns, 5);
    return;
  } else {

  }
  tmp = bfa_fcxp_get_rspbuf(fcxp);
  cthdr = (struct ct_hdr_s *)tmp;
  tmp___0 = __fswab16((int )cthdr->cmd_rsp_code);
  cthdr->cmd_rsp_code = tmp___0;
  if ((unsigned int )cthdr->cmd_rsp_code == 32770U) {
    port->stats.ns_rnnid_accepts = port->stats.ns_rnnid_accepts + 1U;
    (*(ns->sm))((void *)ns, 4);
    return;
  } else {

  }
  port->stats.ns_rnnid_rejects = port->stats.ns_rnnid_rejects + 1U;
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 4537, (unsigned long long )cthdr->reason_code);
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 4538, (unsigned long long )cthdr->exp_code);
  (*(ns->sm))((void *)ns, 5);
  return;
}
}
static void bfa_fcs_lport_ns_send_rsnn_nn(void *ns_cbarg , struct bfa_fcxp_s *fcxp_alloced ) 
{ 
  struct bfa_fcs_lport_ns_s *ns ;
  struct bfa_fcs_lport_s *port ;
  struct fchs_s fchs ;
  int len ;
  struct bfa_fcxp_s *fcxp ;
  u8 *nsymbl ;
  struct bfa_fcxp_s *tmp ;
  struct bfa_fcs_lport_s *tmp___0 ;
  void *tmp___1 ;
  u16 tmp___2 ;

  {
  ns = (struct bfa_fcs_lport_ns_s *)ns_cbarg;
  port = ns->port;
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 4555, port->port_cfg.pwwn);
  if ((unsigned long )fcxp_alloced == (unsigned long )((struct bfa_fcxp_s *)0)) {
    tmp = bfa_fcxp_req_rsp_alloc((void *)0, (port->fcs)->bfa, 0, 0, (u64 (*)(void * ,
                                                                             int  ))0,
                                 (u32 (*)(void * , int  ))0, (u64 (*)(void * , int  ))0,
                                 (u32 (*)(void * , int  ))0, 1);
    fcxp = tmp;
  } else {
    fcxp = fcxp_alloced;
  }
  if ((unsigned long )fcxp == (unsigned long )((struct bfa_fcxp_s *)0)) {
    port->stats.ns_rsnn_nn_alloc_wait = port->stats.ns_rsnn_nn_alloc_wait + 1U;
    bfa_fcxp_req_rsp_alloc_wait((port->fcs)->bfa, & ns->fcxp_wqe, & bfa_fcs_lport_ns_send_rsnn_nn,
                                (void *)ns, (void *)0, 0, 0, (u64 (*)(void * , int  ))0,
                                (u32 (*)(void * , int  ))0, (u64 (*)(void * , int  ))0,
                                (u32 (*)(void * , int  ))0, 1);
    return;
  } else {

  }
  ns->fcxp = fcxp;
  tmp___0 = bfa_fcs_get_base_port(port->fcs);
  nsymbl = (u8 *)(& tmp___0->port_cfg.node_sym_name);
  tmp___1 = bfa_fcxp_get_reqbuf(fcxp);
  tmp___2 = fc_rsnn_nn_build(& fchs, tmp___1, port->pid, port->port_cfg.nwwn, nsymbl);
  len = (int )tmp___2;
  bfa_fcxp_send(fcxp, (struct bfa_rport_s *)0, (int )(port->fabric)->vf_id, (int )port->lp_tag,
                0, 8, (u32 )len, & fchs, & bfa_fcs_lport_ns_rsnn_nn_response, (void *)ns,
                2112U, 30);
  port->stats.ns_rsnn_nn_sent = port->stats.ns_rsnn_nn_sent + 1U;
  (*(ns->sm))((void *)ns, 13);
  return;
}
}
static void bfa_fcs_lport_ns_rsnn_nn_response(void *fcsarg , struct bfa_fcxp_s *fcxp ,
                                              void *cbarg , enum bfa_status req_status ,
                                              u32 rsp_len , u32 resid_len , struct fchs_s *rsp_fchs ) 
{ 
  struct bfa_fcs_lport_ns_s *ns ;
  struct bfa_fcs_lport_s *port ;
  struct ct_hdr_s *cthdr ;
  void *tmp ;
  __u16 tmp___0 ;

  {
  ns = (struct bfa_fcs_lport_ns_s *)cbarg;
  port = ns->port;
  cthdr = (struct ct_hdr_s *)0;
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 4594, port->port_cfg.pwwn);
  if ((unsigned int )req_status != 0U) {
    __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 4600, (unsigned long long )req_status);
    port->stats.ns_rsnn_nn_rsp_err = port->stats.ns_rsnn_nn_rsp_err + 1U;
    (*(ns->sm))((void *)ns, 5);
    return;
  } else {

  }
  tmp = bfa_fcxp_get_rspbuf(fcxp);
  cthdr = (struct ct_hdr_s *)tmp;
  tmp___0 = __fswab16((int )cthdr->cmd_rsp_code);
  cthdr->cmd_rsp_code = tmp___0;
  if ((unsigned int )cthdr->cmd_rsp_code == 32770U) {
    port->stats.ns_rsnn_nn_accepts = port->stats.ns_rsnn_nn_accepts + 1U;
    (*(ns->sm))((void *)ns, 4);
    return;
  } else {

  }
  port->stats.ns_rsnn_nn_rejects = port->stats.ns_rsnn_nn_rejects + 1U;
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 4616, (unsigned long long )cthdr->reason_code);
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 4617, (unsigned long long )cthdr->exp_code);
  (*(ns->sm))((void *)ns, 5);
  return;
}
}
static void bfa_fcs_lport_ns_send_rspn_id(void *ns_cbarg , struct bfa_fcxp_s *fcxp_alloced ) 
{ 
  struct bfa_fcs_lport_ns_s *ns ;
  struct bfa_fcs_lport_s *port ;
  struct fchs_s fchs ;
  int len ;
  struct bfa_fcxp_s *fcxp ;
  u8 symbl[256U] ;
  u8 *psymbl ;
  struct bfa_fcxp_s *tmp ;
  struct bfa_fcs_lport_s *tmp___0 ;
  size_t tmp___1 ;
  struct bfa_fcs_lport_s *tmp___2 ;
  struct bfa_fcs_lport_s *tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  void *tmp___6 ;
  u16 tmp___7 ;

  {
  ns = (struct bfa_fcs_lport_ns_s *)ns_cbarg;
  port = ns->port;
  psymbl = (u8 *)(& symbl);
  memset((void *)(& symbl), 0, 256UL);
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 4637, port->port_cfg.pwwn);
  if ((unsigned long )fcxp_alloced == (unsigned long )((struct bfa_fcxp_s *)0)) {
    tmp = bfa_fcxp_req_rsp_alloc((void *)0, (port->fcs)->bfa, 0, 0, (u64 (*)(void * ,
                                                                             int  ))0,
                                 (u32 (*)(void * , int  ))0, (u64 (*)(void * , int  ))0,
                                 (u32 (*)(void * , int  ))0, 1);
    fcxp = tmp;
  } else {
    fcxp = fcxp_alloced;
  }
  if ((unsigned long )fcxp == (unsigned long )((struct bfa_fcxp_s *)0)) {
    port->stats.ns_rspnid_alloc_wait = port->stats.ns_rspnid_alloc_wait + 1U;
    bfa_fcxp_req_rsp_alloc_wait((port->fcs)->bfa, & ns->fcxp_wqe, & bfa_fcs_lport_ns_send_rspn_id,
                                (void *)ns, (void *)0, 0, 0, (u64 (*)(void * , int  ))0,
                                (u32 (*)(void * , int  ))0, (u64 (*)(void * , int  ))0,
                                (u32 (*)(void * , int  ))0, 1);
    return;
  } else {

  }
  ns->fcxp = fcxp;
  if ((unsigned long )port->vport != (unsigned long )((struct bfa_fcs_vport_s *)0)) {
    tmp___0 = bfa_fcs_get_base_port(port->fcs);
    tmp___1 = strlen((char const   *)(& tmp___0->port_cfg.sym_name));
    tmp___2 = bfa_fcs_get_base_port(port->fcs);
    strncpy((char *)psymbl, (char const   *)(& tmp___2->port_cfg.sym_name), tmp___1);
    tmp___3 = bfa_fcs_get_base_port(port->fcs);
    tmp___4 = strlen((char const   *)(& tmp___3->port_cfg.sym_name));
    *((char *)psymbl + tmp___4) = 0;
    tmp___5 = strlen((char const   *)(& port->port_cfg.sym_name));
    strncat((char *)psymbl, (char const   *)(& port->port_cfg.sym_name), tmp___5);
  } else {
    psymbl = (u8 *)(& port->port_cfg.sym_name);
  }
  tmp___6 = bfa_fcxp_get_reqbuf(fcxp);
  tmp___7 = fc_rspnid_build(& fchs, tmp___6, port->pid, 0, psymbl);
  len = (int )tmp___7;
  bfa_fcxp_send(fcxp, (struct bfa_rport_s *)0, (int )(port->fabric)->vf_id, (int )port->lp_tag,
                0, 8, (u32 )len, & fchs, & bfa_fcs_lport_ns_rspn_id_response, (void *)ns,
                2112U, 30);
  port->stats.ns_rspnid_sent = port->stats.ns_rspnid_sent + 1U;
  (*(ns->sm))((void *)ns, 8);
  return;
}
}
static void bfa_fcs_lport_ns_rspn_id_response(void *fcsarg , struct bfa_fcxp_s *fcxp ,
                                              void *cbarg , enum bfa_status req_status ,
                                              u32 rsp_len , u32 resid_len , struct fchs_s *rsp_fchs ) 
{ 
  struct bfa_fcs_lport_ns_s *ns ;
  struct bfa_fcs_lport_s *port ;
  struct ct_hdr_s *cthdr ;
  void *tmp ;
  __u16 tmp___0 ;

  {
  ns = (struct bfa_fcs_lport_ns_s *)cbarg;
  port = ns->port;
  cthdr = (struct ct_hdr_s *)0;
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 4700, port->port_cfg.pwwn);
  if ((unsigned int )req_status != 0U) {
    __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 4706, (unsigned long long )req_status);
    port->stats.ns_rspnid_rsp_err = port->stats.ns_rspnid_rsp_err + 1U;
    (*(ns->sm))((void *)ns, 5);
    return;
  } else {

  }
  tmp = bfa_fcxp_get_rspbuf(fcxp);
  cthdr = (struct ct_hdr_s *)tmp;
  tmp___0 = __fswab16((int )cthdr->cmd_rsp_code);
  cthdr->cmd_rsp_code = tmp___0;
  if ((unsigned int )cthdr->cmd_rsp_code == 32770U) {
    port->stats.ns_rspnid_accepts = port->stats.ns_rspnid_accepts + 1U;
    (*(ns->sm))((void *)ns, 4);
    return;
  } else {

  }
  port->stats.ns_rspnid_rejects = port->stats.ns_rspnid_rejects + 1U;
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 4722, (unsigned long long )cthdr->reason_code);
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 4723, (unsigned long long )cthdr->exp_code);
  (*(ns->sm))((void *)ns, 5);
  return;
}
}
static void bfa_fcs_lport_ns_send_rft_id(void *ns_cbarg , struct bfa_fcxp_s *fcxp_alloced ) 
{ 
  struct bfa_fcs_lport_ns_s *ns ;
  struct bfa_fcs_lport_s *port ;
  struct fchs_s fchs ;
  int len ;
  struct bfa_fcxp_s *fcxp ;
  struct bfa_fcxp_s *tmp ;
  void *tmp___0 ;
  u16 tmp___1 ;

  {
  ns = (struct bfa_fcs_lport_ns_s *)ns_cbarg;
  port = ns->port;
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 4739, port->port_cfg.pwwn);
  if ((unsigned long )fcxp_alloced == (unsigned long )((struct bfa_fcxp_s *)0)) {
    tmp = bfa_fcxp_req_rsp_alloc((void *)0, (port->fcs)->bfa, 0, 0, (u64 (*)(void * ,
                                                                             int  ))0,
                                 (u32 (*)(void * , int  ))0, (u64 (*)(void * , int  ))0,
                                 (u32 (*)(void * , int  ))0, 1);
    fcxp = tmp;
  } else {
    fcxp = fcxp_alloced;
  }
  if ((unsigned long )fcxp == (unsigned long )((struct bfa_fcxp_s *)0)) {
    port->stats.ns_rftid_alloc_wait = port->stats.ns_rftid_alloc_wait + 1U;
    bfa_fcxp_req_rsp_alloc_wait((port->fcs)->bfa, & ns->fcxp_wqe, & bfa_fcs_lport_ns_send_rft_id,
                                (void *)ns, (void *)0, 0, 0, (u64 (*)(void * , int  ))0,
                                (u32 (*)(void * , int  ))0, (u64 (*)(void * , int  ))0,
                                (u32 (*)(void * , int  ))0, 1);
    return;
  } else {

  }
  ns->fcxp = fcxp;
  tmp___0 = bfa_fcxp_get_reqbuf(fcxp);
  tmp___1 = fc_rftid_build(& fchs, tmp___0, port->pid, 0, port->port_cfg.roles);
  len = (int )tmp___1;
  bfa_fcxp_send(fcxp, (struct bfa_rport_s *)0, (int )(port->fabric)->vf_id, (int )port->lp_tag,
                0, 8, (u32 )len, & fchs, & bfa_fcs_lport_ns_rft_id_response, (void *)ns,
                2112U, 30);
  port->stats.ns_rftid_sent = port->stats.ns_rftid_sent + 1U;
  (*(ns->sm))((void *)ns, 9);
  return;
}
}
static void bfa_fcs_lport_ns_rft_id_response(void *fcsarg , struct bfa_fcxp_s *fcxp ,
                                             void *cbarg , enum bfa_status req_status ,
                                             u32 rsp_len , u32 resid_len , struct fchs_s *rsp_fchs ) 
{ 
  struct bfa_fcs_lport_ns_s *ns ;
  struct bfa_fcs_lport_s *port ;
  struct ct_hdr_s *cthdr ;
  void *tmp ;
  __u16 tmp___0 ;

  {
  ns = (struct bfa_fcs_lport_ns_s *)cbarg;
  port = ns->port;
  cthdr = (struct ct_hdr_s *)0;
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 4773, port->port_cfg.pwwn);
  if ((unsigned int )req_status != 0U) {
    __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 4779, (unsigned long long )req_status);
    port->stats.ns_rftid_rsp_err = port->stats.ns_rftid_rsp_err + 1U;
    (*(ns->sm))((void *)ns, 5);
    return;
  } else {

  }
  tmp = bfa_fcxp_get_rspbuf(fcxp);
  cthdr = (struct ct_hdr_s *)tmp;
  tmp___0 = __fswab16((int )cthdr->cmd_rsp_code);
  cthdr->cmd_rsp_code = tmp___0;
  if ((unsigned int )cthdr->cmd_rsp_code == 32770U) {
    port->stats.ns_rftid_accepts = port->stats.ns_rftid_accepts + 1U;
    (*(ns->sm))((void *)ns, 4);
    return;
  } else {

  }
  port->stats.ns_rftid_rejects = port->stats.ns_rftid_rejects + 1U;
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 4795, (unsigned long long )cthdr->reason_code);
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 4796, (unsigned long long )cthdr->exp_code);
  (*(ns->sm))((void *)ns, 5);
  return;
}
}
static void bfa_fcs_lport_ns_send_rff_id(void *ns_cbarg , struct bfa_fcxp_s *fcxp_alloced ) 
{ 
  struct bfa_fcs_lport_ns_s *ns ;
  struct bfa_fcs_lport_s *port ;
  struct fchs_s fchs ;
  int len ;
  struct bfa_fcxp_s *fcxp ;
  u8 fc4_ftrs ;
  struct bfa_fcxp_s *tmp ;
  void *tmp___0 ;
  u16 tmp___1 ;

  {
  ns = (struct bfa_fcs_lport_ns_s *)ns_cbarg;
  port = ns->port;
  fc4_ftrs = 0U;
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 4813, port->port_cfg.pwwn);
  if ((unsigned long )fcxp_alloced == (unsigned long )((struct bfa_fcxp_s *)0)) {
    tmp = bfa_fcxp_req_rsp_alloc((void *)0, (port->fcs)->bfa, 0, 0, (u64 (*)(void * ,
                                                                             int  ))0,
                                 (u32 (*)(void * , int  ))0, (u64 (*)(void * , int  ))0,
                                 (u32 (*)(void * , int  ))0, 1);
    fcxp = tmp;
  } else {
    fcxp = fcxp_alloced;
  }
  if ((unsigned long )fcxp == (unsigned long )((struct bfa_fcxp_s *)0)) {
    port->stats.ns_rffid_alloc_wait = port->stats.ns_rffid_alloc_wait + 1U;
    bfa_fcxp_req_rsp_alloc_wait((port->fcs)->bfa, & ns->fcxp_wqe, & bfa_fcs_lport_ns_send_rff_id,
                                (void *)ns, (void *)0, 0, 0, (u64 (*)(void * , int  ))0,
                                (u32 (*)(void * , int  ))0, (u64 (*)(void * , int  ))0,
                                (u32 (*)(void * , int  ))0, 1);
    return;
  } else {

  }
  ns->fcxp = fcxp;
  if ((int )(ns->port)->port_cfg.roles & 1) {
    fc4_ftrs = 2U;
  } else {

  }
  tmp___0 = bfa_fcxp_get_reqbuf(fcxp);
  tmp___1 = fc_rffid_build(& fchs, tmp___0, port->pid, 0, 8, (int )fc4_ftrs);
  len = (int )tmp___1;
  bfa_fcxp_send(fcxp, (struct bfa_rport_s *)0, (int )(port->fabric)->vf_id, (int )port->lp_tag,
                0, 8, (u32 )len, & fchs, & bfa_fcs_lport_ns_rff_id_response, (void *)ns,
                2112U, 30);
  port->stats.ns_rffid_sent = port->stats.ns_rffid_sent + 1U;
  (*(ns->sm))((void *)ns, 10);
  return;
}
}
static void bfa_fcs_lport_ns_rff_id_response(void *fcsarg , struct bfa_fcxp_s *fcxp ,
                                             void *cbarg , enum bfa_status req_status ,
                                             u32 rsp_len , u32 resid_len , struct fchs_s *rsp_fchs ) 
{ 
  struct bfa_fcs_lport_ns_s *ns ;
  struct bfa_fcs_lport_s *port ;
  struct ct_hdr_s *cthdr ;
  void *tmp ;
  __u16 tmp___0 ;

  {
  ns = (struct bfa_fcs_lport_ns_s *)cbarg;
  port = ns->port;
  cthdr = (struct ct_hdr_s *)0;
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 4851, port->port_cfg.pwwn);
  if ((unsigned int )req_status != 0U) {
    __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 4857, (unsigned long long )req_status);
    port->stats.ns_rffid_rsp_err = port->stats.ns_rffid_rsp_err + 1U;
    (*(ns->sm))((void *)ns, 5);
    return;
  } else {

  }
  tmp = bfa_fcxp_get_rspbuf(fcxp);
  cthdr = (struct ct_hdr_s *)tmp;
  tmp___0 = __fswab16((int )cthdr->cmd_rsp_code);
  cthdr->cmd_rsp_code = tmp___0;
  if ((unsigned int )cthdr->cmd_rsp_code == 32770U) {
    port->stats.ns_rffid_accepts = port->stats.ns_rffid_accepts + 1U;
    (*(ns->sm))((void *)ns, 4);
    return;
  } else {

  }
  port->stats.ns_rffid_rejects = port->stats.ns_rffid_rejects + 1U;
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 4873, (unsigned long long )cthdr->reason_code);
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 4874, (unsigned long long )cthdr->exp_code);
  if ((unsigned int )cthdr->reason_code == 11U) {
    (*(ns->sm))((void *)ns, 4);
  } else {
    (*(ns->sm))((void *)ns, 5);
  }
  return;
}
}
static void bfa_fcs_lport_ns_send_gid_ft(void *ns_cbarg , struct bfa_fcxp_s *fcxp_alloced ) 
{ 
  struct bfa_fcs_lport_ns_s *ns ;
  struct bfa_fcs_lport_s *port ;
  struct fchs_s fchs ;
  int len ;
  struct bfa_fcxp_s *fcxp ;
  struct bfa_fcxp_s *tmp ;
  void *tmp___0 ;
  u16 tmp___1 ;
  u32 tmp___2 ;

  {
  ns = (struct bfa_fcs_lport_ns_s *)ns_cbarg;
  port = ns->port;
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 4897, (unsigned long long )port->pid);
  if ((unsigned long )fcxp_alloced == (unsigned long )((struct bfa_fcxp_s *)0)) {
    tmp = bfa_fcxp_req_rsp_alloc((void *)0, (port->fcs)->bfa, 0, 0, (u64 (*)(void * ,
                                                                             int  ))0,
                                 (u32 (*)(void * , int  ))0, (u64 (*)(void * , int  ))0,
                                 (u32 (*)(void * , int  ))0, 1);
    fcxp = tmp;
  } else {
    fcxp = fcxp_alloced;
  }
  if ((unsigned long )fcxp == (unsigned long )((struct bfa_fcxp_s *)0)) {
    port->stats.ns_gidft_alloc_wait = port->stats.ns_gidft_alloc_wait + 1U;
    bfa_fcxp_req_rsp_alloc_wait((port->fcs)->bfa, & ns->fcxp_wqe, & bfa_fcs_lport_ns_send_gid_ft,
                                (void *)ns, (void *)0, 0, 0, (u64 (*)(void * , int  ))0,
                                (u32 (*)(void * , int  ))0, (u64 (*)(void * , int  ))0,
                                (u32 (*)(void * , int  ))0, 1);
    return;
  } else {

  }
  ns->fcxp = fcxp;
  tmp___0 = bfa_fcxp_get_reqbuf(fcxp);
  tmp___1 = fc_gid_ft_build(& fchs, tmp___0, (ns->port)->pid, 8);
  len = (int )tmp___1;
  tmp___2 = bfa_fcxp_get_maxrsp((port->fcs)->bfa);
  bfa_fcxp_send(fcxp, (struct bfa_rport_s *)0, (int )(port->fabric)->vf_id, (int )port->lp_tag,
                0, 8, (u32 )len, & fchs, & bfa_fcs_lport_ns_gid_ft_response, (void *)ns,
                tmp___2, 30);
  port->stats.ns_gidft_sent = port->stats.ns_gidft_sent + 1U;
  (*(ns->sm))((void *)ns, 11);
  return;
}
}
static void bfa_fcs_lport_ns_gid_ft_response(void *fcsarg , struct bfa_fcxp_s *fcxp ,
                                             void *cbarg , enum bfa_status req_status ,
                                             u32 rsp_len , u32 resid_len , struct fchs_s *rsp_fchs ) 
{ 
  struct bfa_fcs_lport_ns_s *ns ;
  struct bfa_fcs_lport_s *port ;
  struct ct_hdr_s *cthdr ;
  u32 n_pids ;
  void *tmp ;
  __u16 tmp___0 ;
  u32 tmp___1 ;

  {
  ns = (struct bfa_fcs_lport_ns_s *)cbarg;
  port = ns->port;
  cthdr = (struct ct_hdr_s *)0;
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 4936, port->port_cfg.pwwn);
  if ((unsigned int )req_status != 0U) {
    __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 4942, (unsigned long long )req_status);
    port->stats.ns_gidft_rsp_err = port->stats.ns_gidft_rsp_err + 1U;
    (*(ns->sm))((void *)ns, 5);
    return;
  } else {

  }
  if (resid_len != 0U) {
    __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 4953, (unsigned long long )rsp_len);
    __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 4954, (unsigned long long )resid_len);
    return;
  } else {

  }
  tmp = bfa_fcxp_get_rspbuf(fcxp);
  cthdr = (struct ct_hdr_s *)tmp;
  tmp___0 = __fswab16((int )cthdr->cmd_rsp_code);
  cthdr->cmd_rsp_code = tmp___0;
  switch ((int )cthdr->cmd_rsp_code) {
  case 32770: 
  port->stats.ns_gidft_accepts = port->stats.ns_gidft_accepts + 1U;
  tmp___1 = fc_get_ctresp_pyld_len(rsp_len);
  n_pids = tmp___1 / 4U;
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 4967, (unsigned long long )n_pids);
  bfa_fcs_lport_ns_process_gidft_pids(port, (u32 *)cthdr + 1U, n_pids);
  (*(ns->sm))((void *)ns, 4);
  goto ldv_50270;
  case 32769: 
  port->stats.ns_gidft_rejects = port->stats.ns_gidft_rejects + 1U;
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 4981, (unsigned long long )cthdr->reason_code);
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 4982, (unsigned long long )cthdr->exp_code);
  if ((unsigned int )cthdr->reason_code == 9U && (unsigned int )cthdr->exp_code == 7U) {
    (*(ns->sm))((void *)ns, 4);
  } else {
    (*(ns->sm))((void *)ns, 5);
  }
  goto ldv_50270;
  default: 
  port->stats.ns_gidft_unknown_rsp = port->stats.ns_gidft_unknown_rsp + 1U;
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 4998, (unsigned long long )cthdr->cmd_rsp_code);
  (*(ns->sm))((void *)ns, 5);
  }
  ldv_50270: ;
  return;
}
}
static void bfa_fcs_lport_ns_timeout(void *arg ) 
{ 
  struct bfa_fcs_lport_ns_s *ns ;

  {
  ns = (struct bfa_fcs_lport_ns_s *)arg;
  (ns->port)->stats.ns_timeouts = (ns->port)->stats.ns_timeouts + 1U;
  (*(ns->sm))((void *)ns, 6);
  return;
}
}
static void bfa_fcs_lport_ns_process_gidft_pids(struct bfa_fcs_lport_s *port , u32 *pid_buf ,
                                                u32 n_pids ) 
{ 
  struct fcgs_gidft_resp_s *gidft_entry ;
  struct bfa_fcs_rport_s *rport ;
  u32 ii ;
  struct bfa_fcs_fabric_s *fabric ;
  struct bfa_fcs_vport_s *vport ;
  struct list_head *qe ;
  u8 found ;

  {
  fabric = port->fabric;
  found = 0U;
  ii = 0U;
  goto ldv_50294;
  ldv_50293: 
  gidft_entry = (struct fcgs_gidft_resp_s *)pid_buf + (unsigned long )ii;
  if (gidft_entry->pid == port->pid) {
    goto ldv_50289;
  } else {

  }
  if (gidft_entry->pid == fabric->bport.pid) {
    goto ldv_50289;
  } else {

  }
  qe = fabric->vport_q.next;
  goto ldv_50291;
  ldv_50290: 
  vport = (struct bfa_fcs_vport_s *)qe;
  if (vport->lport.pid == gidft_entry->pid) {
    found = 1U;
  } else {

  }
  qe = qe->next;
  ldv_50291: ;
  if ((unsigned long )(& fabric->vport_q) != (unsigned long )qe) {
    goto ldv_50290;
  } else {

  }

  if ((unsigned int )found != 0U) {
    found = 0U;
    goto ldv_50289;
  } else {

  }
  rport = bfa_fcs_lport_get_rport_by_pid(port, gidft_entry->pid);
  if ((unsigned long )rport == (unsigned long )((struct bfa_fcs_rport_s *)0)) {
    rport = bfa_fcs_rport_create(port, gidft_entry->pid);
  } else {
    bfa_fcs_rport_scn(rport);
  }
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 5084, (unsigned long long )gidft_entry->pid);
  if ((unsigned int )*((unsigned char *)gidft_entry + 0UL) != 0U) {
    return;
  } else {

  }
  ldv_50289: 
  ii = ii + 1U;
  ldv_50294: ;
  if (ii < n_pids) {
    goto ldv_50293;
  } else {

  }

  return;
}
}
void bfa_fcs_lport_ns_init(struct bfa_fcs_lport_s *port ) 
{ 
  struct bfa_fcs_lport_ns_s *ns ;

  {
  ns = & port->port_topo.pfab.ns;
  ns->port = port;
  ns->sm = (void (*)(void * , int  ))(& bfa_fcs_lport_ns_sm_offline);
  return;
}
}
void bfa_fcs_lport_ns_offline(struct bfa_fcs_lport_s *port ) 
{ 
  struct bfa_fcs_lport_ns_s *ns ;

  {
  ns = & port->port_topo.pfab.ns;
  ns->port = port;
  (*(ns->sm))((void *)ns, 2);
  return;
}
}
void bfa_fcs_lport_ns_online(struct bfa_fcs_lport_s *port ) 
{ 
  struct bfa_fcs_lport_ns_s *ns ;

  {
  ns = & port->port_topo.pfab.ns;
  ns->port = port;
  (*(ns->sm))((void *)ns, 1);
  return;
}
}
void bfa_fcs_lport_ns_query(struct bfa_fcs_lport_s *port ) 
{ 
  struct bfa_fcs_lport_ns_s *ns ;

  {
  ns = & port->port_topo.pfab.ns;
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 5134, (unsigned long long )port->pid);
  if ((unsigned long )ns->sm == (unsigned long )((void (*)(void * , int  ))(& bfa_fcs_lport_ns_sm_online))) {
    (*(ns->sm))((void *)ns, 7);
  } else {

  }
  return;
}
}
static void bfa_fcs_lport_ns_boot_target_disc(struct bfa_fcs_lport_s *port ) 
{ 
  struct bfa_fcs_rport_s *rport ;
  u8 nwwns ;
  wwn_t wwns[8U] ;
  int ii ;
    klee_make_symbolic(&ii, sizeof(int), "ii");
  int __ret_warn_on ;
  long tmp ;

  {
  bfa_iocfc_get_bootwwns((port->fcs)->bfa, & nwwns, (wwn_t *)(& wwns));
  ii = 0;
  goto ldv_50322;
  ldv_50321: 
  rport = bfa_fcs_rport_create_by_wwn(port, wwns[ii]);
  __ret_warn_on = (unsigned long )rport == (unsigned long )((struct bfa_fcs_rport_s *)0);
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcs_lport.c",
                       5152);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  ii = ii + 1;
  ldv_50322: ;
  if ((int )nwwns > ii) {
    goto ldv_50321;
  } else {

  }

  return;
}
}
void bfa_fcs_lport_ns_util_send_rspn_id(void *cbarg , struct bfa_fcxp_s *fcxp_alloced ) 
{ 
  struct bfa_fcs_lport_ns_s *ns ;
  struct bfa_fcs_lport_s *port ;
  struct fchs_s fchs ;
  struct bfa_fcxp_s *fcxp ;
  u8 symbl[256U] ;
  u8 *psymbl ;
  int len ;
  struct bfa_fcxp_s *tmp ;
  struct bfa_fcs_lport_s *tmp___0 ;
  size_t tmp___1 ;
  struct bfa_fcs_lport_s *tmp___2 ;
  struct bfa_fcs_lport_s *tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  void *tmp___6 ;
  u16 tmp___7 ;

  {
  ns = (struct bfa_fcs_lport_ns_s *)cbarg;
  port = ns->port;
  psymbl = (u8 *)(& symbl);
  if (((((unsigned long )ns->sm == (unsigned long )((void (*)(void * , int  ))(& bfa_fcs_lport_ns_sm_offline)) || (unsigned long )ns->sm == (unsigned long )((void (*)(void * ,
                                                                                                                                                                       int  ))(& bfa_fcs_lport_ns_sm_plogi_sending))) || (unsigned long )ns->sm == (unsigned long )((void (*)(void * ,
                                                                                                                                                                                                                                                                              int  ))(& bfa_fcs_lport_ns_sm_plogi))) || (unsigned long )ns->sm == (unsigned long )((void (*)(void * ,
                                                                                                                                                                                                                                                                                                                                                                             int  ))(& bfa_fcs_lport_ns_sm_plogi_retry))) || (unsigned long )ns->sm == (unsigned long )((void (*)(void * ,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  int  ))(& bfa_fcs_lport_ns_sm_rspn_id_retry))) {
    return;
  } else {

  }
  memset((void *)(& symbl), 0, 256UL);
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 5176, port->port_cfg.pwwn);
  if ((unsigned long )fcxp_alloced == (unsigned long )((struct bfa_fcxp_s *)0)) {
    tmp = bfa_fcxp_req_rsp_alloc((void *)0, (port->fcs)->bfa, 0, 0, (u64 (*)(void * ,
                                                                             int  ))0,
                                 (u32 (*)(void * , int  ))0, (u64 (*)(void * , int  ))0,
                                 (u32 (*)(void * , int  ))0, 0);
    fcxp = tmp;
  } else {
    fcxp = fcxp_alloced;
  }
  if ((unsigned long )fcxp == (unsigned long )((struct bfa_fcxp_s *)0)) {
    port->stats.ns_rspnid_alloc_wait = port->stats.ns_rspnid_alloc_wait + 1U;
    bfa_fcxp_req_rsp_alloc_wait((port->fcs)->bfa, & ns->fcxp_wqe, & bfa_fcs_lport_ns_util_send_rspn_id,
                                (void *)ns, (void *)0, 0, 0, (u64 (*)(void * , int  ))0,
                                (u32 (*)(void * , int  ))0, (u64 (*)(void * , int  ))0,
                                (u32 (*)(void * , int  ))0, 0);
    return;
  } else {

  }
  ns->fcxp = fcxp;
  if ((unsigned long )port->vport != (unsigned long )((struct bfa_fcs_vport_s *)0)) {
    tmp___0 = bfa_fcs_get_base_port(port->fcs);
    tmp___1 = strlen((char const   *)(& tmp___0->port_cfg.sym_name));
    tmp___2 = bfa_fcs_get_base_port(port->fcs);
    strncpy((char *)psymbl, (char const   *)(& tmp___2->port_cfg.sym_name), tmp___1);
    tmp___3 = bfa_fcs_get_base_port(port->fcs);
    tmp___4 = strlen((char const   *)(& tmp___3->port_cfg.sym_name));
    *((char *)psymbl + tmp___4) = 0;
    tmp___5 = strlen((char const   *)(& port->port_cfg.sym_name));
    strncat((char *)psymbl, (char const   *)(& port->port_cfg.sym_name), tmp___5);
  } else {

  }
  tmp___6 = bfa_fcxp_get_reqbuf(fcxp);
  tmp___7 = fc_rspnid_build(& fchs, tmp___6, port->pid, 0, psymbl);
  len = (int )tmp___7;
  bfa_fcxp_send(fcxp, (struct bfa_rport_s *)0, (int )(port->fabric)->vf_id, (int )port->lp_tag,
                0, 8, (u32 )len, & fchs, (void (*)(void * , struct bfa_fcxp_s * ,
                                                   void * , enum bfa_status  , u32  ,
                                                   u32  , struct fchs_s * ))0, (void *)0,
                2112U, 0);
  port->stats.ns_rspnid_sent = port->stats.ns_rspnid_sent + 1U;
  return;
}
}
static void bfa_fcs_lport_scn_send_scr(void *scn_cbarg , struct bfa_fcxp_s *fcxp_alloced ) ;
static void bfa_fcs_lport_scn_scr_response(void *fcsarg , struct bfa_fcxp_s *fcxp ,
                                           void *cbarg , enum bfa_status req_status ,
                                           u32 rsp_len , u32 resid_len , struct fchs_s *rsp_fchs ) ;
static void bfa_fcs_lport_scn_send_ls_acc(struct bfa_fcs_lport_s *port , struct fchs_s *rx_fchs ) ;
static void bfa_fcs_lport_scn_timeout(void *arg ) ;
static void bfa_fcs_lport_scn_sm_offline(struct bfa_fcs_lport_scn_s *scn , enum port_scn_event event ) ;
static void bfa_fcs_lport_scn_sm_sending_scr(struct bfa_fcs_lport_scn_s *scn , enum port_scn_event event ) ;
static void bfa_fcs_lport_scn_sm_scr(struct bfa_fcs_lport_scn_s *scn , enum port_scn_event event ) ;
static void bfa_fcs_lport_scn_sm_scr_retry(struct bfa_fcs_lport_scn_s *scn , enum port_scn_event event ) ;
static void bfa_fcs_lport_scn_sm_online(struct bfa_fcs_lport_scn_s *scn , enum port_scn_event event ) ;
static void bfa_fcs_lport_scn_sm_offline(struct bfa_fcs_lport_scn_s *scn , enum port_scn_event event ) 
{ 


  {
  switch ((unsigned int )event) {
  case 1U: 
  scn->sm = (void (*)(void * , int  ))(& bfa_fcs_lport_scn_sm_sending_scr);
  bfa_fcs_lport_scn_send_scr((void *)scn, (struct bfa_fcxp_s *)0);
  goto ldv_50378;
  case 2U: ;
  goto ldv_50378;
  default: 
  __bfa_trc(((scn->port)->fcs)->trcmod, __trc_fileno___7, 5285, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcs_lport.c",
         5285, (unsigned int )event);
  }
  ldv_50378: ;
  return;
}
}
static void bfa_fcs_lport_scn_sm_sending_scr(struct bfa_fcs_lport_scn_s *scn , enum port_scn_event event ) 
{ 


  {
  switch ((unsigned int )event) {
  case 6U: 
  scn->sm = (void (*)(void * , int  ))(& bfa_fcs_lport_scn_sm_scr);
  goto ldv_50386;
  case 2U: 
  scn->sm = (void (*)(void * , int  ))(& bfa_fcs_lport_scn_sm_offline);
  bfa_fcxp_walloc_cancel(((scn->port)->fcs)->bfa, & scn->fcxp_wqe);
  goto ldv_50386;
  default: 
  __bfa_trc(((scn->port)->fcs)->trcmod, __trc_fileno___7, 5304, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcs_lport.c",
         5304, (unsigned int )event);
  }
  ldv_50386: ;
  return;
}
}
static void bfa_fcs_lport_scn_sm_scr(struct bfa_fcs_lport_scn_s *scn , enum port_scn_event event ) 
{ 
  struct bfa_fcs_lport_s *port ;

  {
  port = scn->port;
  switch ((unsigned int )event) {
  case 3U: 
  scn->sm = (void (*)(void * , int  ))(& bfa_fcs_lport_scn_sm_online);
  goto ldv_50395;
  case 4U: 
  scn->sm = (void (*)(void * , int  ))(& bfa_fcs_lport_scn_sm_scr_retry);
  bfa_timer_begin(& ((port->fcs)->bfa)->timer_mod, & scn->timer, & bfa_fcs_lport_scn_timeout,
                  (void *)scn, 2000U);
  goto ldv_50395;
  case 2U: 
  scn->sm = (void (*)(void * , int  ))(& bfa_fcs_lport_scn_sm_offline);
  bfa_fcxp_discard(scn->fcxp);
  goto ldv_50395;
  default: 
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 5332, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcs_lport.c",
         5332, (unsigned int )event);
  }
  ldv_50395: ;
  return;
}
}
static void bfa_fcs_lport_scn_sm_scr_retry(struct bfa_fcs_lport_scn_s *scn , enum port_scn_event event ) 
{ 


  {
  switch ((unsigned int )event) {
  case 5U: 
  scn->sm = (void (*)(void * , int  ))(& bfa_fcs_lport_scn_sm_sending_scr);
  bfa_fcs_lport_scn_send_scr((void *)scn, (struct bfa_fcxp_s *)0);
  goto ldv_50404;
  case 2U: 
  scn->sm = (void (*)(void * , int  ))(& bfa_fcs_lport_scn_sm_offline);
  bfa_timer_stop(& scn->timer);
  goto ldv_50404;
  default: 
  __bfa_trc(((scn->port)->fcs)->trcmod, __trc_fileno___7, 5352, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcs_lport.c",
         5352, (unsigned int )event);
  }
  ldv_50404: ;
  return;
}
}
static void bfa_fcs_lport_scn_sm_online(struct bfa_fcs_lport_scn_s *scn , enum port_scn_event event ) 
{ 


  {
  switch ((unsigned int )event) {
  case 2U: 
  scn->sm = (void (*)(void * , int  ))(& bfa_fcs_lport_scn_sm_offline);
  goto ldv_50412;
  default: 
  __bfa_trc(((scn->port)->fcs)->trcmod, __trc_fileno___7, 5366, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcs_lport.c",
         5366, (unsigned int )event);
  }
  ldv_50412: ;
  return;
}
}
static void bfa_fcs_lport_scn_send_scr(void *scn_cbarg , struct bfa_fcxp_s *fcxp_alloced ) 
{ 
  struct bfa_fcs_lport_scn_s *scn ;
  struct bfa_fcs_lport_s *port ;
  struct fchs_s fchs ;
  int len ;
  struct bfa_fcxp_s *fcxp ;
  struct bfa_fcxp_s *tmp ;
  void *tmp___0 ;
  u16 tmp___1 ;
  void *tmp___2 ;
  u16 tmp___3 ;

  {
  scn = (struct bfa_fcs_lport_scn_s *)scn_cbarg;
  port = scn->port;
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 5388, (unsigned long long )port->pid);
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 5389, port->port_cfg.pwwn);
  if ((unsigned long )fcxp_alloced == (unsigned long )((struct bfa_fcxp_s *)0)) {
    tmp = bfa_fcxp_req_rsp_alloc((void *)0, (port->fcs)->bfa, 0, 0, (u64 (*)(void * ,
                                                                             int  ))0,
                                 (u32 (*)(void * , int  ))0, (u64 (*)(void * , int  ))0,
                                 (u32 (*)(void * , int  ))0, 1);
    fcxp = tmp;
  } else {
    fcxp = fcxp_alloced;
  }
  if ((unsigned long )fcxp == (unsigned long )((struct bfa_fcxp_s *)0)) {
    bfa_fcxp_req_rsp_alloc_wait((port->fcs)->bfa, & scn->fcxp_wqe, & bfa_fcs_lport_scn_send_scr,
                                (void *)scn, (void *)0, 0, 0, (u64 (*)(void * , int  ))0,
                                (u32 (*)(void * , int  ))0, (u64 (*)(void * , int  ))0,
                                (u32 (*)(void * , int  ))0, 1);
    return;
  } else {

  }
  scn->fcxp = fcxp;
  if ((unsigned long )port->vport == (unsigned long )((struct bfa_fcs_vport_s *)0) && (unsigned int )((port->fcs)->bfa)->ioc.fcmode != 0U) {
    tmp___0 = bfa_fcxp_get_reqbuf(fcxp);
    tmp___1 = fc_scr_build(& fchs, (struct fc_scr_s *)tmp___0, (int )((u8 )((port->fabric)->lps)->brcd_switch),
                           port->pid, 0);
    len = (int )tmp___1;
  } else {
    tmp___2 = bfa_fcxp_get_reqbuf(fcxp);
    tmp___3 = fc_scr_build(& fchs, (struct fc_scr_s *)tmp___2, 0, port->pid, 0);
    len = (int )tmp___3;
  }
  bfa_fcxp_send(fcxp, (struct bfa_rport_s *)0, (int )(port->fabric)->vf_id, (int )port->lp_tag,
                0, 8, (u32 )len, & fchs, & bfa_fcs_lport_scn_scr_response, (void *)scn,
                2112U, 20);
  (*(scn->sm))((void *)scn, 6);
  return;
}
}
static void bfa_fcs_lport_scn_scr_response(void *fcsarg , struct bfa_fcxp_s *fcxp ,
                                           void *cbarg , enum bfa_status req_status ,
                                           u32 rsp_len , u32 resid_len , struct fchs_s *rsp_fchs ) 
{ 
  struct bfa_fcs_lport_scn_s *scn ;
  struct bfa_fcs_lport_s *port ;
  struct fc_els_cmd_s *els_cmd ;
  struct fc_ls_rjt_s *ls_rjt ;
  void *tmp ;
  void *tmp___0 ;

  {
  scn = (struct bfa_fcs_lport_scn_s *)cbarg;
  port = scn->port;
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 5429, port->port_cfg.pwwn);
  if ((unsigned int )req_status != 0U) {
    __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 5435, (unsigned long long )req_status);
    (*(scn->sm))((void *)scn, 4);
    return;
  } else {

  }
  tmp = bfa_fcxp_get_rspbuf(fcxp);
  els_cmd = (struct fc_els_cmd_s *)tmp;
  switch ((int )els_cmd->els_code) {
  case 2: 
  (*(scn->sm))((void *)scn, 3);
  goto ldv_50437;
  case 1: 
  tmp___0 = bfa_fcxp_get_rspbuf(fcxp);
  ls_rjt = (struct fc_ls_rjt_s *)tmp___0;
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 5452, (unsigned long long )ls_rjt->reason_code);
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 5453, (unsigned long long )ls_rjt->reason_code_expl);
  (*(scn->sm))((void *)scn, 4);
  goto ldv_50437;
  default: 
  (*(scn->sm))((void *)scn, 4);
  }
  ldv_50437: ;
  return;
}
}
static void bfa_fcs_lport_scn_send_ls_acc(struct bfa_fcs_lport_s *port , struct fchs_s *rx_fchs ) 
{ 
  struct fchs_s fchs ;
  struct bfa_fcxp_s *fcxp ;
  struct bfa_rport_s *bfa_rport ;
  int len ;
  void *tmp ;
  u16 tmp___0 ;

  {
  bfa_rport = (struct bfa_rport_s *)0;
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 5475, (unsigned long long )rx_fchs->s_id);
  fcxp = bfa_fcxp_req_rsp_alloc((void *)0, (port->fcs)->bfa, 0, 0, (u64 (*)(void * ,
                                                                            int  ))0,
                                (u32 (*)(void * , int  ))0, (u64 (*)(void * , int  ))0,
                                (u32 (*)(void * , int  ))0, 0);
  if ((unsigned long )fcxp == (unsigned long )((struct bfa_fcxp_s *)0)) {
    return;
  } else {

  }
  tmp = bfa_fcxp_get_reqbuf(fcxp);
  tmp___0 = fc_ls_acc_build(& fchs, (struct fc_els_cmd_s *)tmp, rx_fchs->s_id, port->pid,
                            (int )rx_fchs->ox_id);
  len = (int )tmp___0;
  bfa_fcxp_send(fcxp, bfa_rport, (int )(port->fabric)->vf_id, (int )port->lp_tag,
                0, 8, (u32 )len, & fchs, (void (*)(void * , struct bfa_fcxp_s * ,
                                                   void * , enum bfa_status  , u32  ,
                                                   u32  , struct fchs_s * ))0, (void *)0,
                2112U, 0);
  return;
}
}
static void bfa_fcs_lport_scn_timeout(void *arg ) 
{ 
  struct bfa_fcs_lport_scn_s *scn ;

  {
  scn = (struct bfa_fcs_lport_scn_s *)arg;
  (*(scn->sm))((void *)scn, 5);
  return;
}
}
void bfa_fcs_lport_scn_init(struct bfa_fcs_lport_s *port ) 
{ 
  struct bfa_fcs_lport_scn_s *scn ;

  {
  scn = & port->port_topo.pfab.scn;
  scn->port = port;
  scn->sm = (void (*)(void * , int  ))(& bfa_fcs_lport_scn_sm_offline);
  return;
}
}
void bfa_fcs_lport_scn_offline(struct bfa_fcs_lport_s *port ) 
{ 
  struct bfa_fcs_lport_scn_s *scn ;

  {
  scn = & port->port_topo.pfab.scn;
  scn->port = port;
  (*(scn->sm))((void *)scn, 2);
  return;
}
}
void bfa_fcs_lport_fab_scn_online(struct bfa_fcs_lport_s *port ) 
{ 
  struct bfa_fcs_lport_scn_s *scn ;

  {
  scn = & port->port_topo.pfab.scn;
  scn->port = port;
  (*(scn->sm))((void *)scn, 1);
  return;
}
}
static void bfa_fcs_lport_scn_portid_rscn(struct bfa_fcs_lport_s *port , u32 rpid ) 
{ 
  struct bfa_fcs_rport_s *rport ;
  struct bfa_fcs_fabric_s *fabric ;
  struct bfa_fcs_vport_s *vport ;
  struct list_head *qe ;

  {
  fabric = port->fabric;
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 5555, (unsigned long long )rpid);
  if (fabric->bport.pid == rpid) {
    return;
  } else {

  }
  qe = fabric->vport_q.next;
  goto ldv_50473;
  ldv_50472: 
  vport = (struct bfa_fcs_vport_s *)qe;
  if (vport->lport.pid == rpid) {
    return;
  } else {

  }
  qe = qe->next;
  ldv_50473: ;
  if ((unsigned long )(& fabric->vport_q) != (unsigned long )qe) {
    goto ldv_50472;
  } else {

  }
  rport = bfa_fcs_lport_get_rport_by_pid(port, rpid);
  if ((unsigned long )rport == (unsigned long )((struct bfa_fcs_rport_s *)0)) {
    rport = bfa_fcs_lport_get_rport_by_old_pid(port, rpid);
  } else {

  }
  if ((unsigned long )rport == (unsigned long )((struct bfa_fcs_rport_s *)0)) {
    if ((unsigned int )(port->fcs)->min_cfg == 0U) {
      rport = bfa_fcs_rport_create(port, rpid);
    } else {

    }
  } else {
    bfa_fcs_rport_scn(rport);
  }
  return;
}
}
static void bfa_fcs_lport_scn_multiport_rscn(struct bfa_fcs_lport_s *port , enum fc_rscn_format format ,
                                             u32 rscn_pid ) 
{ 
  struct bfa_fcs_rport_s *rport ;
  struct list_head *qe ;
  struct list_head *qe_next ;
  u8 *c0 ;
  u8 *c1 ;

  {
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 5609, (unsigned long long )format);
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 5610, (unsigned long long )rscn_pid);
  c0 = (u8 *)(& rscn_pid);
  qe = port->rport_q.next;
  qe_next = qe->next;
  goto ldv_50486;
  ldv_50485: 
  rport = (struct bfa_fcs_rport_s *)qe;
  c1 = (u8 *)(& rport->pid);
  if (((unsigned int )format == 3U || ((unsigned int )format == 2U && (int )*c0 == (int )*c1)) || (((unsigned int )format == 1U && (int )*c0 == (int )*c1) && (int )*(c0 + 1UL) == (int )*(c1 + 1UL))) {
    bfa_fcs_rport_scn(rport);
  } else {

  }
  qe = qe_next;
  qe_next = qe->next;
  ldv_50486: ;
  if ((unsigned long )(& port->rport_q) != (unsigned long )qe) {
    goto ldv_50485;
  } else {

  }

  return;
}
}
void bfa_fcs_lport_scn_process_rscn(struct bfa_fcs_lport_s *port , struct fchs_s *fchs ,
                                    u32 len ) 
{ 
  struct fc_rscn_pl_s *rscn ;
  int num_entries ;
  u32 rscn_pid ;
  enum bfa_boolean nsquery ;
  enum bfa_boolean found ;
  int i ;
  int j ;
  __u16 tmp ;
  int __ret_warn_on ;
  long tmp___0 ;

  {
  rscn = (struct fc_rscn_pl_s *)fchs + 1U;
  nsquery = 0;
  i = 0;
  tmp = __fswab16((int )rscn->payldlen);
  num_entries = (int )(((unsigned long )tmp - 4UL) / 4UL);
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 5637, (unsigned long long )num_entries);
  port->stats.num_rscn = port->stats.num_rscn + 1U;
  bfa_fcs_lport_scn_send_ls_acc(port, fchs);
  i = 0;
  goto ldv_50513;
  ldv_50512: 
  rscn_pid = rscn->event[i].portid;
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 5646, (unsigned long long )rscn->event[i].format);
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 5647, (unsigned long long )rscn_pid);
  found = 0;
  j = 0;
  goto ldv_50502;
  ldv_50501: ;
  if (rscn->event[j].portid == rscn_pid) {
    found = 1;
    goto ldv_50500;
  } else {

  }
  j = j + 1;
  ldv_50502: ;
  if (j < i) {
    goto ldv_50501;
  } else {

  }
  ldv_50500: ;
  if ((unsigned int )found != 0U) {
    __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 5660, (unsigned long long )rscn_pid);
    goto ldv_50503;
  } else {

  }
  switch ((int )rscn->event[i].format) {
  case 0: ;
  if ((unsigned int )rscn->event[i].qualifier == 12U) {
    __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 5671, (unsigned long long )rscn_pid);
  } else {
    port->stats.num_portid_rscn = port->stats.num_portid_rscn + 1U;
    bfa_fcs_lport_scn_portid_rscn(port, rscn_pid);
  }
  goto ldv_50505;
  case 3: ;
  if ((unsigned int )rscn->event[i].qualifier == 13U) {
    bfa_fcs_lport_ms_fabric_rscn(port);
    goto ldv_50505;
  } else {

  }
  case 1: ;
  case 2: 
  nsquery = 1;
  bfa_fcs_lport_scn_multiport_rscn(port, (enum fc_rscn_format )rscn->event[i].format,
                                   rscn_pid);
  goto ldv_50505;
  default: 
  __ret_warn_on = 1;
  tmp___0 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp___0 != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcs_lport.c",
                       5696);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  nsquery = 1;
  }
  ldv_50505: ;
  ldv_50503: 
  i = i + 1;
  ldv_50513: ;
  if (i < num_entries) {
    goto ldv_50512;
  } else {

  }

  if ((unsigned int )nsquery != 0U) {
    bfa_fcs_lport_ns_query(port);
  } else {

  }
  return;
}
}
struct bfa_fcs_lport_s *bfa_fcs_get_base_port(struct bfa_fcs_s *fcs ) 
{ 


  {
  return (& fcs->fabric.bport);
}
}
wwn_t bfa_fcs_lport_get_rport(struct bfa_fcs_lport_s *port , wwn_t wwn , int index ,
                              int nrports , enum bfa_boolean bwwn ) 
{ 
  struct list_head *qh ;
  struct list_head *qe ;
  struct bfa_fcs_rport_s *rport ;
  int i ;
  struct bfa_fcs_s *fcs ;
  int tmp ;

  {
  rport = (struct bfa_fcs_rport_s *)0;
  if ((unsigned long )port == (unsigned long )((struct bfa_fcs_lport_s *)0) || nrports == 0) {
    return (0ULL);
  } else {

  }
  fcs = port->fcs;
  __bfa_trc(fcs->trcmod, __trc_fileno___7, 5734, (unsigned long long )((unsigned int )nrports));
  i = 0;
  qh = & port->rport_q;
  qe = qh->next;
  goto ldv_50530;
  ldv_50532: 
  rport = (struct bfa_fcs_rport_s *)qe;
  if (((((rport->pid & 255U) << 16) | (rport->pid & 65280U)) | ((rport->pid & 16711680U) >> 16)) > 16773120U) {
    qe = qe->next;
    __bfa_trc(fcs->trcmod, __trc_fileno___7, 5744, (unsigned long long )((unsigned int )rport->pwwn));
    __bfa_trc(fcs->trcmod, __trc_fileno___7, 5745, (unsigned long long )rport->pid);
    __bfa_trc(fcs->trcmod, __trc_fileno___7, 5746, (unsigned long long )i);
    goto ldv_50530;
  } else {

  }
  if ((unsigned int )bwwn != 0U) {
    tmp = memcmp((void const   *)(& wwn), (void const   *)(& rport->pwwn), 8UL);
    if (tmp == 0) {
      goto ldv_50531;
    } else {

    }
  } else
  if (i == index) {
    goto ldv_50531;
  } else {

  }
  i = i + 1;
  qe = qe->next;
  ldv_50530: ;
  if ((unsigned long )qe != (unsigned long )qh && i < nrports) {
    goto ldv_50532;
  } else {

  }
  ldv_50531: 
  __bfa_trc(fcs->trcmod, __trc_fileno___7, 5762, (unsigned long long )i);
  if ((unsigned long )rport != (unsigned long )((struct bfa_fcs_rport_s *)0)) {
    return (rport->pwwn);
  } else {
    return (0ULL);
  }
}
}
void bfa_fcs_lport_get_rport_quals(struct bfa_fcs_lport_s *port , struct bfa_rport_qualifier_s *rports ,
                                   int *nrports ) 
{ 
  struct list_head *qh ;
  struct list_head *qe ;
  struct bfa_fcs_rport_s *rport ;
  int i ;
  struct bfa_fcs_s *fcs ;

  {
  rport = (struct bfa_fcs_rport_s *)0;
  if (((unsigned long )port == (unsigned long )((struct bfa_fcs_lport_s *)0) || (unsigned long )rports == (unsigned long )((struct bfa_rport_qualifier_s *)0)) || *nrports == 0) {
    return;
  } else {

  }
  fcs = port->fcs;
  __bfa_trc(fcs->trcmod, __trc_fileno___7, 5782, (unsigned long long )((unsigned int )*nrports));
  i = 0;
  qh = & port->rport_q;
  qe = qh->next;
  goto ldv_50543;
  ldv_50544: 
  rport = (struct bfa_fcs_rport_s *)qe;
  if (((((rport->pid & 255U) << 16) | (rport->pid & 65280U)) | ((rport->pid & 16711680U) >> 16)) > 16773120U) {
    qe = qe->next;
    __bfa_trc(fcs->trcmod, __trc_fileno___7, 5792, (unsigned long long )((unsigned int )rport->pwwn));
    __bfa_trc(fcs->trcmod, __trc_fileno___7, 5793, (unsigned long long )rport->pid);
    __bfa_trc(fcs->trcmod, __trc_fileno___7, 5794, (unsigned long long )i);
    goto ldv_50543;
  } else {

  }
  if (rport->pwwn == 0ULL && rport->pid == 0U) {
    qe = qe->next;
    goto ldv_50543;
  } else {

  }
  (rports + (unsigned long )i)->pwwn = rport->pwwn;
  (rports + (unsigned long )i)->pid = rport->pid;
  i = i + 1;
  qe = qe->next;
  ldv_50543: ;
  if ((unsigned long )qe != (unsigned long )qh && *nrports > i) {
    goto ldv_50544;
  } else {

  }
  __bfa_trc(fcs->trcmod, __trc_fileno___7, 5810, (unsigned long long )i);
  *nrports = i;
  return;
}
}
enum bfa_port_speed bfa_fcs_lport_get_rport_max_speed(struct bfa_fcs_lport_s *port ) 
{ 
  struct list_head *qh ;
  struct list_head *qe ;
  struct bfa_fcs_rport_s *rport ;
  struct bfa_fcs_s *fcs ;
  enum bfa_port_speed max_speed ;
  struct bfa_port_attr_s port_attr ;
  enum bfa_port_speed port_speed ;
  enum bfa_port_speed rport_speed ;
  enum bfa_boolean trl_enabled ;
  enum bfa_boolean tmp ;
  int tmp___0 ;

  {
  rport = (struct bfa_fcs_rport_s *)0;
  max_speed = 0;
  tmp = bfa_fcport_is_ratelim((port->fcs)->bfa);
  trl_enabled = tmp;
  if ((unsigned long )port == (unsigned long )((struct bfa_fcs_lport_s *)0)) {
    return (0);
  } else {

  }
  fcs = port->fcs;
  bfa_fcport_get_attr((port->fcs)->bfa, & port_attr);
  port_speed = port_attr.speed;
  __bfa_trc(fcs->trcmod, __trc_fileno___7, 5840, (unsigned long long )port_speed);
  qh = & port->rport_q;
  qe = qh->next;
  goto ldv_50558;
  ldv_50559: 
  rport = (struct bfa_fcs_rport_s *)qe;
  if (((((rport->pid & 255U) << 16) | (rport->pid & 65280U)) | ((rport->pid & 16711680U) >> 16)) > 16773120U) {
    qe = qe->next;
    goto ldv_50558;
  } else {
    tmp___0 = bfa_fcs_rport_get_state(rport);
    if (tmp___0 == 1) {
      qe = qe->next;
      goto ldv_50558;
    } else
    if ((unsigned int )rport->scsi_function != 2U) {
      qe = qe->next;
      goto ldv_50558;
    } else {

    }
  }
  rport_speed = rport->rpf.rpsc_speed;
  if ((unsigned int )trl_enabled != 0U && (unsigned int )rport_speed == 0U) {
    rport_speed = bfa_fcport_get_ratelim_speed((port->fcs)->bfa);
  } else {

  }
  if ((unsigned int )rport_speed > (unsigned int )max_speed) {
    max_speed = rport_speed;
  } else {

  }
  qe = qe->next;
  ldv_50558: ;
  if ((unsigned long )qe != (unsigned long )qh) {
    goto ldv_50559;
  } else {

  }

  if ((unsigned int )max_speed > (unsigned int )port_speed) {
    max_speed = port_speed;
  } else {

  }
  __bfa_trc(fcs->trcmod, __trc_fileno___7, 5871, (unsigned long long )max_speed);
  return (max_speed);
}
}
struct bfa_fcs_lport_s *bfa_fcs_lookup_port(struct bfa_fcs_s *fcs , u16 vf_id , wwn_t lpwwn ) 
{ 
  struct bfa_fcs_vport_s *vport ;
  struct bfa_fcs_fabric_s *vf ;
  int __ret_warn_on ;
  long tmp ;

  {
  __ret_warn_on = (unsigned long )fcs == (unsigned long )((struct bfa_fcs_s *)0);
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcs_lport.c",
                       5881);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  vf = bfa_fcs_vf_lookup(fcs, (int )vf_id);
  if ((unsigned long )vf == (unsigned long )((struct bfa_fcs_fabric_s *)0)) {
    __bfa_trc(fcs->trcmod, __trc_fileno___7, 5885, (unsigned long long )vf_id);
    return ((struct bfa_fcs_lport_s *)0);
  } else {

  }
  if (lpwwn == 0ULL || vf->bport.port_cfg.pwwn == lpwwn) {
    return (& vf->bport);
  } else {

  }
  vport = bfa_fcs_fabric_vport_lookup(vf, lpwwn);
  if ((unsigned long )vport != (unsigned long )((struct bfa_fcs_vport_s *)0)) {
    return (& vport->lport);
  } else {

  }
  return ((struct bfa_fcs_lport_s *)0);
}
}
void bfa_fcs_lport_get_info(struct bfa_fcs_lport_s *port , struct bfa_lport_info_s *port_info ) 
{ 


  {
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___7, 5907, (port->fabric)->fabric_name);
  if ((unsigned long )port->vport == (unsigned long )((struct bfa_fcs_vport_s *)0)) {
    port_info->port_type = 0U;
    port_info->port_state = 0U;
    port_info->offline_reason = 0U;
    port_info->port_wwn = port->port_cfg.pwwn;
    port_info->node_wwn = port->port_cfg.nwwn;
    port_info->max_vports_supp = bfa_lps_get_max_vport((port->fcs)->bfa);
    port_info->num_vports_inuse = (u32 )(port->fabric)->num_vports;
    port_info->max_rports_supp = 256U;
    port_info->num_rports_inuse = (u32 )port->num_rports;
  } else {
    port_info->port_type = 1U;
    port_info->port_state = 0U;
    port_info->offline_reason = 0U;
    port_info->port_wwn = port->port_cfg.pwwn;
    port_info->node_wwn = port->port_cfg.nwwn;
  }
  return;
}
}
void bfa_fcs_lport_get_stats(struct bfa_fcs_lport_s *fcs_port , struct bfa_lport_stats_s *port_stats ) 
{ 


  {
  *port_stats = fcs_port->stats;
  return;
}
}
void bfa_fcs_lport_clear_stats(struct bfa_fcs_lport_s *fcs_port ) 
{ 


  {
  memset((void *)(& fcs_port->stats), 0, 248UL);
  return;
}
}
void bfa_fcs_lport_lip_scn_online(struct bfa_fcs_lport_s *port ) 
{ 


  {
  bfa_fcs_lport_loop_online(port);
  return;
}
}
static void bfa_fcs_vport_do_fdisc(struct bfa_fcs_vport_s *vport ) ;
static void bfa_fcs_vport_timeout(void *vport_arg ) ;
static void bfa_fcs_vport_do_logo(struct bfa_fcs_vport_s *vport ) ;
static void bfa_fcs_vport_free(struct bfa_fcs_vport_s *vport ) ;
static void bfa_fcs_vport_sm_uninit(struct bfa_fcs_vport_s *vport , enum bfa_fcs_vport_event event ) ;
static void bfa_fcs_vport_sm_created(struct bfa_fcs_vport_s *vport , enum bfa_fcs_vport_event event ) ;
static void bfa_fcs_vport_sm_offline(struct bfa_fcs_vport_s *vport , enum bfa_fcs_vport_event event ) ;
static void bfa_fcs_vport_sm_fdisc(struct bfa_fcs_vport_s *vport , enum bfa_fcs_vport_event event ) ;
static void bfa_fcs_vport_sm_fdisc_retry(struct bfa_fcs_vport_s *vport , enum bfa_fcs_vport_event event ) ;
static void bfa_fcs_vport_sm_fdisc_rsp_wait(struct bfa_fcs_vport_s *vport , enum bfa_fcs_vport_event event ) ;
static void bfa_fcs_vport_sm_online(struct bfa_fcs_vport_s *vport , enum bfa_fcs_vport_event event ) ;
static void bfa_fcs_vport_sm_deleting(struct bfa_fcs_vport_s *vport , enum bfa_fcs_vport_event event ) ;
static void bfa_fcs_vport_sm_cleanup(struct bfa_fcs_vport_s *vport , enum bfa_fcs_vport_event event ) ;
static void bfa_fcs_vport_sm_logo(struct bfa_fcs_vport_s *vport , enum bfa_fcs_vport_event event ) ;
static void bfa_fcs_vport_sm_error(struct bfa_fcs_vport_s *vport , enum bfa_fcs_vport_event event ) ;
static void bfa_fcs_vport_sm_stopping(struct bfa_fcs_vport_s *vport , enum bfa_fcs_vport_event event ) ;
static void bfa_fcs_vport_sm_logo_for_stop(struct bfa_fcs_vport_s *vport , enum bfa_fcs_vport_event event ) ;
static struct bfa_sm_table_s vport_sm_table[11U]  = 
  {      {(void (*)(void * , int  ))(& bfa_fcs_vport_sm_uninit), 0, 0}, 
        {(void (*)(void * , int  ))(& bfa_fcs_vport_sm_created), 1, 0}, 
        {(void (*)(void * , int  ))(& bfa_fcs_vport_sm_offline), 1, 0}, 
        {(void (*)(void * , int  ))(& bfa_fcs_vport_sm_fdisc), 3, 0}, 
        {(void (*)(void * , int  ))(& bfa_fcs_vport_sm_fdisc_retry), 4, 0}, 
        {(void (*)(void * , int  ))(& bfa_fcs_vport_sm_fdisc_rsp_wait), 5, 0}, 
        {(void (*)(void * , int  ))(& bfa_fcs_vport_sm_online), 6, 0}, 
        {(void (*)(void * , int  ))(& bfa_fcs_vport_sm_deleting), 7, 0}, 
        {(void (*)(void * , int  ))(& bfa_fcs_vport_sm_cleanup), 8, 0}, 
        {(void (*)(void * , int  ))(& bfa_fcs_vport_sm_logo), 10, 0}, 
        {(void (*)(void * , int  ))(& bfa_fcs_vport_sm_error), 11, 0}};
static void bfa_fcs_vport_sm_uninit(struct bfa_fcs_vport_s *vport , enum bfa_fcs_vport_event event ) 
{ 


  {
  __bfa_trc((vport->lport.fcs)->trcmod, __trc_fileno___7, 6063, vport->lport.port_cfg.pwwn);
  __bfa_trc((vport->lport.fcs)->trcmod, __trc_fileno___7, 6064, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 1U: 
  vport->sm = (void (*)(void * , int  ))(& bfa_fcs_vport_sm_created);
  bfa_fcs_fabric_addvport(vport->lport.fabric, vport);
  goto ldv_50653;
  default: 
  __bfa_trc((vport->lport.fcs)->trcmod, __trc_fileno___7, 6073, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcs_lport.c",
         6073, (unsigned int )event);
  }
  ldv_50653: ;
  return;
}
}
static void bfa_fcs_vport_sm_created(struct bfa_fcs_vport_s *vport , enum bfa_fcs_vport_event event ) 
{ 


  {
  __bfa_trc((vport->lport.fcs)->trcmod, __trc_fileno___7, 6084, vport->lport.port_cfg.pwwn);
  __bfa_trc((vport->lport.fcs)->trcmod, __trc_fileno___7, 6085, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 3U: ;
  if ((unsigned long )(vport->lport.fabric)->sm == (unsigned long )((void (*)(void * ,
                                                                              int  ))(& bfa_fcs_fabric_sm_online)) && (unsigned int )(vport->lport.fabric)->is_npiv != 0U) {
    vport->sm = (void (*)(void * , int  ))(& bfa_fcs_vport_sm_fdisc);
    bfa_fcs_vport_do_fdisc(vport);
  } else {
    vport->vport_stats.fab_no_npiv = vport->vport_stats.fab_no_npiv + 1U;
    vport->sm = (void (*)(void * , int  ))(& bfa_fcs_vport_sm_offline);
  }
  goto ldv_50660;
  case 2U: 
  vport->sm = (void (*)(void * , int  ))(& bfa_fcs_vport_sm_cleanup);
  bfa_fcs_lport_delete(& vport->lport);
  goto ldv_50660;
  case 5U: ;
  case 6U: ;
  goto ldv_50660;
  default: 
  __bfa_trc((vport->lport.fcs)->trcmod, __trc_fileno___7, 6118, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcs_lport.c",
         6118, (unsigned int )event);
  }
  ldv_50660: ;
  return;
}
}
static void bfa_fcs_vport_sm_offline(struct bfa_fcs_vport_s *vport , enum bfa_fcs_vport_event event ) 
{ 


  {
  __bfa_trc((vport->lport.fcs)->trcmod, __trc_fileno___7, 6129, vport->lport.port_cfg.pwwn);
  __bfa_trc((vport->lport.fcs)->trcmod, __trc_fileno___7, 6130, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 2U: 
  vport->sm = (void (*)(void * , int  ))(& bfa_fcs_vport_sm_cleanup);
  bfa_fcs_lport_delete(& vport->lport);
  goto ldv_50670;
  case 5U: 
  vport->sm = (void (*)(void * , int  ))(& bfa_fcs_vport_sm_fdisc);
  vport->fdisc_retries = 0;
  bfa_fcs_vport_do_fdisc(vport);
  goto ldv_50670;
  case 4U: 
  vport->sm = (void (*)(void * , int  ))(& bfa_fcs_vport_sm_cleanup);
  (*(vport->lport.sm))((void *)(& vport->lport), 6);
  goto ldv_50670;
  case 6U: ;
  goto ldv_50670;
  default: 
  __bfa_trc((vport->lport.fcs)->trcmod, __trc_fileno___7, 6160, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcs_lport.c",
         6160, (unsigned int )event);
  }
  ldv_50670: ;
  return;
}
}
static void bfa_fcs_vport_sm_fdisc(struct bfa_fcs_vport_s *vport , enum bfa_fcs_vport_event event ) 
{ 


  {
  __bfa_trc((vport->lport.fcs)->trcmod, __trc_fileno___7, 6172, vport->lport.port_cfg.pwwn);
  __bfa_trc((vport->lport.fcs)->trcmod, __trc_fileno___7, 6173, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 2U: 
  vport->sm = (void (*)(void * , int  ))(& bfa_fcs_vport_sm_fdisc_rsp_wait);
  goto ldv_50680;
  case 6U: 
  vport->sm = (void (*)(void * , int  ))(& bfa_fcs_vport_sm_offline);
  (*((vport->lps)->sm))((void *)vport->lps, 6);
  goto ldv_50680;
  case 8U: 
  vport->sm = (void (*)(void * , int  ))(& bfa_fcs_vport_sm_online);
  bfa_fcs_lport_online(& vport->lport);
  goto ldv_50680;
  case 9U: 
  vport->sm = (void (*)(void * , int  ))(& bfa_fcs_vport_sm_fdisc_retry);
  bfa_timer_begin(& ((vport->lport.fcs)->bfa)->timer_mod, & vport->timer, & bfa_fcs_vport_timeout,
                  (void *)vport, 2000U);
  goto ldv_50680;
  case 13U: ;
  case 15U: 
  vport->sm = (void (*)(void * , int  ))(& bfa_fcs_vport_sm_offline);
  goto ldv_50680;
  case 12U: 
  vport->sm = (void (*)(void * , int  ))(& bfa_fcs_vport_sm_error);
  goto ldv_50680;
  default: 
  __bfa_trc((vport->lport.fcs)->trcmod, __trc_fileno___7, 6207, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcs_lport.c",
         6207, (unsigned int )event);
  }
  ldv_50680: ;
  return;
}
}
static void bfa_fcs_vport_sm_fdisc_retry(struct bfa_fcs_vport_s *vport , enum bfa_fcs_vport_event event ) 
{ 


  {
  __bfa_trc((vport->lport.fcs)->trcmod, __trc_fileno___7, 6218, vport->lport.port_cfg.pwwn);
  __bfa_trc((vport->lport.fcs)->trcmod, __trc_fileno___7, 6219, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 2U: 
  vport->sm = (void (*)(void * , int  ))(& bfa_fcs_vport_sm_cleanup);
  bfa_timer_stop(& vport->timer);
  bfa_fcs_lport_delete(& vport->lport);
  goto ldv_50693;
  case 6U: 
  vport->sm = (void (*)(void * , int  ))(& bfa_fcs_vport_sm_offline);
  bfa_timer_stop(& vport->timer);
  goto ldv_50693;
  case 10U: 
  vport->sm = (void (*)(void * , int  ))(& bfa_fcs_vport_sm_fdisc);
  vport->vport_stats.fdisc_retries = vport->vport_stats.fdisc_retries + 1U;
  vport->fdisc_retries = vport->fdisc_retries + 1;
  bfa_fcs_vport_do_fdisc(vport);
  goto ldv_50693;
  default: 
  __bfa_trc((vport->lport.fcs)->trcmod, __trc_fileno___7, 6241, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcs_lport.c",
         6241, (unsigned int )event);
  }
  ldv_50693: ;
  return;
}
}
static void bfa_fcs_vport_sm_fdisc_rsp_wait(struct bfa_fcs_vport_s *vport , enum bfa_fcs_vport_event event ) 
{ 


  {
  __bfa_trc((vport->lport.fcs)->trcmod, __trc_fileno___7, 6254, vport->lport.port_cfg.pwwn);
  __bfa_trc((vport->lport.fcs)->trcmod, __trc_fileno___7, 6255, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 8U: 
  vport->sm = (void (*)(void * , int  ))(& bfa_fcs_vport_sm_deleting);
  bfa_fcs_lport_delete(& vport->lport);
  goto ldv_50702;
  case 2U: ;
  goto ldv_50702;
  case 6U: ;
  case 9U: ;
  case 13U: ;
  case 15U: ;
  case 12U: 
  vport->sm = (void (*)(void * , int  ))(& bfa_fcs_vport_sm_cleanup);
  (*((vport->lps)->sm))((void *)vport->lps, 6);
  bfa_fcs_lport_delete(& vport->lport);
  goto ldv_50702;
  default: 
  __bfa_trc((vport->lport.fcs)->trcmod, __trc_fileno___7, 6277, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcs_lport.c",
         6277, (unsigned int )event);
  }
  ldv_50702: ;
  return;
}
}
static void bfa_fcs_vport_sm_online(struct bfa_fcs_vport_s *vport , enum bfa_fcs_vport_event event ) 
{ 


  {
  __bfa_trc((vport->lport.fcs)->trcmod, __trc_fileno___7, 6288, vport->lport.port_cfg.pwwn);
  __bfa_trc((vport->lport.fcs)->trcmod, __trc_fileno___7, 6289, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 2U: 
  vport->sm = (void (*)(void * , int  ))(& bfa_fcs_vport_sm_deleting);
  bfa_fcs_lport_delete(& vport->lport);
  goto ldv_50715;
  case 4U: 
  vport->sm = (void (*)(void * , int  ))(& bfa_fcs_vport_sm_stopping);
  (*(vport->lport.sm))((void *)(& vport->lport), 6);
  goto ldv_50715;
  case 6U: 
  vport->sm = (void (*)(void * , int  ))(& bfa_fcs_vport_sm_offline);
  (*((vport->lps)->sm))((void *)vport->lps, 6);
  bfa_fcs_lport_offline(& vport->lport);
  goto ldv_50715;
  default: 
  __bfa_trc((vport->lport.fcs)->trcmod, __trc_fileno___7, 6309, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcs_lport.c",
         6309, (unsigned int )event);
  }
  ldv_50715: ;
  return;
}
}
static void bfa_fcs_vport_sm_stopping(struct bfa_fcs_vport_s *vport , enum bfa_fcs_vport_event event ) 
{ 


  {
  __bfa_trc((vport->lport.fcs)->trcmod, __trc_fileno___7, 6321, vport->lport.port_cfg.pwwn);
  __bfa_trc((vport->lport.fcs)->trcmod, __trc_fileno___7, 6322, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 14U: 
  vport->sm = (void (*)(void * , int  ))(& bfa_fcs_vport_sm_logo_for_stop);
  bfa_fcs_vport_do_logo(vport);
  goto ldv_50724;
  case 6U: 
  vport->sm = (void (*)(void * , int  ))(& bfa_fcs_vport_sm_cleanup);
  goto ldv_50724;
  default: 
  __bfa_trc((vport->lport.fcs)->trcmod, __trc_fileno___7, 6335, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcs_lport.c",
         6335, (unsigned int )event);
  }
  ldv_50724: ;
  return;
}
}
static void bfa_fcs_vport_sm_deleting(struct bfa_fcs_vport_s *vport , enum bfa_fcs_vport_event event ) 
{ 


  {
  __bfa_trc((vport->lport.fcs)->trcmod, __trc_fileno___7, 6347, vport->lport.port_cfg.pwwn);
  __bfa_trc((vport->lport.fcs)->trcmod, __trc_fileno___7, 6348, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 2U: ;
  goto ldv_50732;
  case 11U: 
  vport->sm = (void (*)(void * , int  ))(& bfa_fcs_vport_sm_logo);
  bfa_fcs_vport_do_logo(vport);
  goto ldv_50732;
  case 6U: 
  vport->sm = (void (*)(void * , int  ))(& bfa_fcs_vport_sm_cleanup);
  goto ldv_50732;
  default: 
  __bfa_trc((vport->lport.fcs)->trcmod, __trc_fileno___7, 6364, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcs_lport.c",
         6364, (unsigned int )event);
  }
  ldv_50732: ;
  return;
}
}
static void bfa_fcs_vport_sm_error(struct bfa_fcs_vport_s *vport , enum bfa_fcs_vport_event event ) 
{ 


  {
  __bfa_trc((vport->lport.fcs)->trcmod, __trc_fileno___7, 6378, vport->lport.port_cfg.pwwn);
  __bfa_trc((vport->lport.fcs)->trcmod, __trc_fileno___7, 6379, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 2U: 
  vport->sm = (void (*)(void * , int  ))(& bfa_fcs_vport_sm_cleanup);
  bfa_fcs_lport_delete(& vport->lport);
  goto ldv_50741;
  default: 
  __bfa_trc((vport->lport.fcs)->trcmod, __trc_fileno___7, 6388, (unsigned long long )event);
  }
  ldv_50741: ;
  return;
}
}
static void bfa_fcs_vport_sm_cleanup(struct bfa_fcs_vport_s *vport , enum bfa_fcs_vport_event event ) 
{ 


  {
  __bfa_trc((vport->lport.fcs)->trcmod, __trc_fileno___7, 6400, vport->lport.port_cfg.pwwn);
  __bfa_trc((vport->lport.fcs)->trcmod, __trc_fileno___7, 6401, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 11U: 
  vport->sm = (void (*)(void * , int  ))(& bfa_fcs_vport_sm_uninit);
  bfa_fcs_vport_free(vport);
  goto ldv_50748;
  case 14U: 
  vport->sm = (void (*)(void * , int  ))(& bfa_fcs_vport_sm_created);
  goto ldv_50748;
  case 2U: ;
  goto ldv_50748;
  default: 
  __bfa_trc((vport->lport.fcs)->trcmod, __trc_fileno___7, 6417, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcs_lport.c",
         6417, (unsigned int )event);
  }
  ldv_50748: ;
  return;
}
}
static void bfa_fcs_vport_sm_logo_for_stop(struct bfa_fcs_vport_s *vport , enum bfa_fcs_vport_event event ) 
{ 


  {
  __bfa_trc((vport->lport.fcs)->trcmod, __trc_fileno___7, 6429, vport->lport.port_cfg.pwwn);
  __bfa_trc((vport->lport.fcs)->trcmod, __trc_fileno___7, 6430, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 6U: 
  (*((vport->lps)->sm))((void *)vport->lps, 6);
  case 8U: ;
  case 9U: 
  vport->sm = (void (*)(void * , int  ))(& bfa_fcs_vport_sm_created);
  goto ldv_50759;
  default: 
  __bfa_trc((vport->lport.fcs)->trcmod, __trc_fileno___7, 6445, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcs_lport.c",
         6445, (unsigned int )event);
  }
  ldv_50759: ;
  return;
}
}
static void bfa_fcs_vport_sm_logo(struct bfa_fcs_vport_s *vport , enum bfa_fcs_vport_event event ) 
{ 


  {
  __bfa_trc((vport->lport.fcs)->trcmod, __trc_fileno___7, 6457, vport->lport.port_cfg.pwwn);
  __bfa_trc((vport->lport.fcs)->trcmod, __trc_fileno___7, 6458, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 6U: 
  (*((vport->lps)->sm))((void *)vport->lps, 6);
  case 8U: ;
  case 9U: 
  vport->sm = (void (*)(void * , int  ))(& bfa_fcs_vport_sm_uninit);
  bfa_fcs_vport_free(vport);
  goto ldv_50768;
  case 2U: ;
  goto ldv_50768;
  default: 
  __bfa_trc((vport->lport.fcs)->trcmod, __trc_fileno___7, 6477, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcs_lport.c",
         6477, (unsigned int )event);
  }
  ldv_50768: ;
  return;
}
}
static void bfa_fcs_vport_aen_post(struct bfa_fcs_lport_s *port , enum bfa_lport_aen_event event ) 
{ 
  struct bfad_s *bfad ;
  struct bfa_aen_entry_s *aen_entry ;
  unsigned long _flags ;
  raw_spinlock_t *tmp ;
  int tmp___0 ;
  struct bfa_fcs_lport_s *tmp___1 ;

  {
  bfad = ((port->fabric)->fcs)->bfad;
  tmp = spinlock_check(& bfad->bfad_aen_spinlock);
  _flags = _raw_spin_lock_irqsave(tmp);
  tmp___0 = list_empty((struct list_head  const  *)(& bfad->free_aen_q));
  if (tmp___0 == 0) {
    *((struct list_head **)(& aen_entry)) = bfad->free_aen_q.next;
    ((*((struct list_head **)(& aen_entry)))->next)->prev = & bfad->free_aen_q;
    bfad->free_aen_q.next = (*((struct list_head **)(& aen_entry)))->next;
  } else {
    *((struct list_head **)(& aen_entry)) = (struct list_head *)0;
  }
  if ((unsigned long )aen_entry != (unsigned long )((struct bfa_aen_entry_s *)0)) {
    list_add_tail(& aen_entry->qe, & bfad->active_aen_q);
  } else {

  }
  spin_unlock_irqrestore(& bfad->bfad_aen_spinlock, _flags);
  if ((unsigned long )aen_entry == (unsigned long )((struct bfa_aen_entry_s *)0)) {
    return;
  } else {

  }
  aen_entry->aen_data.lport.vf_id = (port->fabric)->vf_id;
  aen_entry->aen_data.lport.roles = (u16 )port->port_cfg.roles;
  tmp___1 = bfa_fcs_get_base_port(port->fcs);
  aen_entry->aen_data.lport.ppwwn = tmp___1->port_cfg.pwwn;
  aen_entry->aen_data.lport.lpwwn = port->port_cfg.pwwn;
  do_gettimeofday(& aen_entry->aen_tv);
  aen_entry->bfad_num = bfad->inst_no;
  (port->fcs)->fcs_aen_seq = (port->fcs)->fcs_aen_seq + 1;
  aen_entry->seq_num = (u32 )(port->fcs)->fcs_aen_seq;
  aen_entry->aen_category = 3;
  aen_entry->aen_type = (u32 )event;
  if ((bfad->bfad_flags & 512U) != 0U) {
    queue_work___2((bfad->im)->drv_workq, & (bfad->im)->aen_im_notify_work);
  } else {

  }
  return;
}
}
static void bfa_fcs_vport_do_fdisc(struct bfa_fcs_vport_s *vport ) 
{ 
  u16 tmp ;

  {
  tmp = bfa_fcport_get_maxfrsize((vport->lport.fcs)->bfa);
  bfa_lps_fdisc(vport->lps, (void *)vport, (int )tmp, vport->lport.port_cfg.pwwn,
                vport->lport.port_cfg.nwwn);
  vport->vport_stats.fdisc_sent = vport->vport_stats.fdisc_sent + 1U;
  return;
}
}
static void bfa_fcs_vport_fdisc_rejected(struct bfa_fcs_vport_s *vport ) 
{ 
  u8 lsrjt_rsn ;
  u8 lsrjt_expl ;

  {
  lsrjt_rsn = (vport->lps)->lsrjt_rsn;
  lsrjt_expl = (vport->lps)->lsrjt_expl;
  __bfa_trc((vport->lport.fcs)->trcmod, __trc_fileno___7, 6529, (unsigned long long )lsrjt_rsn);
  __bfa_trc((vport->lport.fcs)->trcmod, __trc_fileno___7, 6530, (unsigned long long )lsrjt_expl);
  switch ((int )(vport->lps)->lsrjt_expl) {
  case 13: ;
  case 31: ;
  if (vport->fdisc_retries <= 4) {
    (*(vport->sm))((void *)vport, 9);
  } else {
    bfa_fcs_vport_aen_post(& vport->lport, 10);
    (*(vport->sm))((void *)vport, 12);
  }
  goto ldv_50791;
  case 41: ;
  if (vport->fdisc_retries <= 4) {
    (*(vport->sm))((void *)vport, 9);
  } else {
    bfa_fcs_vport_aen_post(& vport->lport, 11);
    (*(vport->sm))((void *)vport, 15);
  }
  goto ldv_50791;
  default: ;
  if (vport->fdisc_retries == 0) {
    bfa_fcs_vport_aen_post(& vport->lport, 12);
  } else {

  }
  (*(vport->sm))((void *)vport, 9);
  }
  ldv_50791: ;
  return;
}
}
static void bfa_fcs_vport_do_logo(struct bfa_fcs_vport_s *vport ) 
{ 


  {
  __bfa_trc((vport->lport.fcs)->trcmod, __trc_fileno___7, 6574, vport->lport.port_cfg.pwwn);
  vport->vport_stats.logo_sent = vport->vport_stats.logo_sent + 1U;
  bfa_lps_fdisclogo(vport->lps);
  return;
}
}
static void bfa_fcs_vport_timeout(void *vport_arg ) 
{ 
  struct bfa_fcs_vport_s *vport ;

  {
  vport = (struct bfa_fcs_vport_s *)vport_arg;
  vport->vport_stats.fdisc_timeouts = vport->vport_stats.fdisc_timeouts + 1U;
  (*(vport->sm))((void *)vport, 10);
  return;
}
}
static void bfa_fcs_vport_free(struct bfa_fcs_vport_s *vport ) 
{ 
  struct bfad_vport_s *vport_drv ;

  {
  vport_drv = vport->vport_drv;
  bfa_fcs_fabric_delvport(vport->lport.fabric, vport);
  bfa_lps_delete(vport->lps);
  if ((unsigned long )vport_drv->comp_del != (unsigned long )((struct completion *)0)) {
    complete(vport_drv->comp_del);
    return;
  } else {

  }
  bfad_im_port_delete(vport_drv->drv_port.bfad, & vport_drv->drv_port);
  return;
}
}
void bfa_fcs_vport_online(struct bfa_fcs_vport_s *vport ) 
{ 


  {
  vport->vport_stats.fab_online = vport->vport_stats.fab_online + 1U;
  if ((unsigned int )(vport->lport.fabric)->is_npiv != 0U) {
    (*(vport->sm))((void *)vport, 5);
  } else {
    vport->vport_stats.fab_no_npiv = vport->vport_stats.fab_no_npiv + 1U;
  }
  return;
}
}
void bfa_fcs_vport_offline(struct bfa_fcs_vport_s *vport ) 
{ 


  {
  vport->vport_stats.fab_offline = vport->vport_stats.fab_offline + 1U;
  (*(vport->sm))((void *)vport, 6);
  return;
}
}
void bfa_fcs_vport_cleanup(struct bfa_fcs_vport_s *vport ) 
{ 


  {
  vport->vport_stats.fab_cleanup = vport->vport_stats.fab_cleanup + 1U;
  return;
}
}
void bfa_fcs_vport_fcs_stop(struct bfa_fcs_vport_s *vport ) 
{ 


  {
  (*(vport->sm))((void *)vport, 4);
  return;
}
}
void bfa_fcs_vport_fcs_delete(struct bfa_fcs_vport_s *vport ) 
{ 


  {
  (*(vport->sm))((void *)vport, 2);
  return;
}
}
void bfa_fcs_vport_stop_comp(struct bfa_fcs_vport_s *vport ) 
{ 


  {
  (*(vport->sm))((void *)vport, 14);
  return;
}
}
void bfa_fcs_vport_delete_comp(struct bfa_fcs_vport_s *vport ) 
{ 


  {
  (*(vport->sm))((void *)vport, 11);
  return;
}
}
enum bfa_status bfa_fcs_vport_create(struct bfa_fcs_vport_s *vport , struct bfa_fcs_s *fcs ,
                                     u16 vf_id , struct bfa_lport_cfg_s *vport_cfg ,
                                     struct bfad_vport_s *vport_drv ) 
{ 
  struct bfa_fcs_vport_s *tmp ;
  u32 tmp___0 ;

  {
  if (vport_cfg->pwwn == 0ULL) {
    return (57);
  } else {

  }
  if (fcs->fabric.bport.port_cfg.pwwn == vport_cfg->pwwn) {
    return (46);
  } else {

  }
  tmp = bfa_fcs_vport_lookup(fcs, (int )vf_id, vport_cfg->pwwn);
  if ((unsigned long )tmp != (unsigned long )((struct bfa_fcs_vport_s *)0)) {
    return (21);
  } else {

  }
  tmp___0 = bfa_lps_get_max_vport(fcs->bfa);
  if ((u32 )fcs->fabric.num_vports == tmp___0) {
    return (22);
  } else {

  }
  vport->lps = bfa_lps_alloc(fcs->bfa);
  if ((unsigned long )vport->lps == (unsigned long )((struct bfa_lps_s *)0)) {
    return (22);
  } else {

  }
  vport->vport_drv = vport_drv;
  vport_cfg->preboot_vp = 0;
  vport->sm = (void (*)(void * , int  ))(& bfa_fcs_vport_sm_uninit);
  bfa_fcs_lport_attach(& vport->lport, fcs, (int )vf_id, vport);
  bfa_fcs_lport_init(& vport->lport, vport_cfg);
  (*(vport->sm))((void *)vport, 1);
  return (0);
}
}
enum bfa_status bfa_fcs_pbc_vport_create(struct bfa_fcs_vport_s *vport , struct bfa_fcs_s *fcs ,
                                         u16 vf_id , struct bfa_lport_cfg_s *vport_cfg ,
                                         struct bfad_vport_s *vport_drv ) 
{ 
  enum bfa_status rc ;

  {
  rc = bfa_fcs_vport_create(vport, fcs, (int )vf_id, vport_cfg, vport_drv);
  vport->lport.port_cfg.preboot_vp = 1;
  return (rc);
}
}
enum bfa_boolean bfa_fcs_is_pbc_vport(struct bfa_fcs_vport_s *vport ) 
{ 


  {
  if ((unsigned long )vport != (unsigned long )((struct bfa_fcs_vport_s *)0) && (unsigned int )vport->lport.port_cfg.preboot_vp == 1U) {
    return (1);
  } else {
    return (0);
  }
}
}
enum bfa_status bfa_fcs_vport_start(struct bfa_fcs_vport_s *vport ) 
{ 


  {
  (*(vport->sm))((void *)vport, 3);
  return (0);
}
}
enum bfa_status bfa_fcs_vport_stop(struct bfa_fcs_vport_s *vport ) 
{ 


  {
  (*(vport->sm))((void *)vport, 4);
  return (0);
}
}
enum bfa_status bfa_fcs_vport_delete(struct bfa_fcs_vport_s *vport ) 
{ 


  {
  if ((unsigned int )vport->lport.port_cfg.preboot_vp != 0U) {
    return (154);
  } else {

  }
  (*(vport->sm))((void *)vport, 2);
  return (0);
}
}
void bfa_fcs_vport_get_attr(struct bfa_fcs_vport_s *vport , struct bfa_vport_attr_s *attr ) 
{ 
  int tmp ;

  {
  if ((unsigned long )vport == (unsigned long )((struct bfa_fcs_vport_s *)0) || (unsigned long )attr == (unsigned long )((struct bfa_vport_attr_s *)0)) {
    return;
  } else {

  }
  memset((void *)attr, 0, 360UL);
  bfa_fcs_lport_get_attr(& vport->lport, & attr->port_attr);
  tmp = bfa_sm_to_state((struct bfa_sm_table_s *)(& vport_sm_table), vport->sm);
  attr->vport_state = (enum bfa_vport_state )tmp;
  return;
}
}
struct bfa_fcs_vport_s *bfa_fcs_vport_lookup(struct bfa_fcs_s *fcs , u16 vf_id , wwn_t vpwwn ) 
{ 
  struct bfa_fcs_vport_s *vport ;
  struct bfa_fcs_fabric_s *fabric ;

  {
  __bfa_trc(fcs->trcmod, __trc_fileno___7, 6886, (unsigned long long )vf_id);
  __bfa_trc(fcs->trcmod, __trc_fileno___7, 6887, vpwwn);
  fabric = bfa_fcs_vf_lookup(fcs, (int )vf_id);
  if ((unsigned long )fabric == (unsigned long )((struct bfa_fcs_fabric_s *)0)) {
    __bfa_trc(fcs->trcmod, __trc_fileno___7, 6891, (unsigned long long )vf_id);
    return ((struct bfa_fcs_vport_s *)0);
  } else {

  }
  vport = bfa_fcs_fabric_vport_lookup(fabric, vpwwn);
  return (vport);
}
}
void bfa_cb_lps_fdisc_comp(void *bfad , void *uarg , enum bfa_status status ) 
{ 
  struct bfa_fcs_vport_s *vport ;

  {
  vport = (struct bfa_fcs_vport_s *)uarg;
  __bfa_trc((vport->lport.fcs)->trcmod, __trc_fileno___7, 6907, vport->lport.port_cfg.pwwn);
  __bfa_trc((vport->lport.fcs)->trcmod, __trc_fileno___7, 6908, (unsigned long long )status);
  switch ((unsigned int )status) {
  case 0U: 
  vport->lport.pid = (vport->lps)->lp_pid;
  vport->vport_stats.fdisc_accepts = vport->vport_stats.fdisc_accepts + 1U;
  (*(vport->sm))((void *)vport, 8);
  goto ldv_50871;
  case 134U: 
  vport->vport_stats.fdisc_acc_bad = vport->vport_stats.fdisc_acc_bad + 1U;
  (*(vport->sm))((void *)vport, 9);
  goto ldv_50871;
  case 6U: ;
  switch ((unsigned int )(vport->lps)->ext_status) {
  case 0U: 
  vport->vport_stats.fdisc_acc_bad = vport->vport_stats.fdisc_acc_bad + 1U;
  goto ldv_50875;
  case 1U: 
  vport->vport_stats.fdisc_unknown_rsp = vport->vport_stats.fdisc_unknown_rsp + 1U;
  goto ldv_50875;
  default: ;
  goto ldv_50875;
  }
  ldv_50875: ;
  if (vport->fdisc_retries <= 4) {
    (*(vport->sm))((void *)vport, 9);
  } else {
    (*(vport->sm))((void *)vport, 13);
  }
  goto ldv_50871;
  case 5U: 
  vport->vport_stats.fdisc_timeouts = vport->vport_stats.fdisc_timeouts + 1U;
  if (vport->fdisc_retries <= 4) {
    (*(vport->sm))((void *)vport, 9);
  } else {
    (*(vport->sm))((void *)vport, 13);
  }
  goto ldv_50871;
  case 29U: 
  vport->vport_stats.fdisc_rejects = vport->vport_stats.fdisc_rejects + 1U;
  bfa_fcs_vport_fdisc_rejected(vport);
  goto ldv_50871;
  default: 
  vport->vport_stats.fdisc_rsp_err = vport->vport_stats.fdisc_rsp_err + 1U;
  (*(vport->sm))((void *)vport, 9);
  }
  ldv_50871: ;
  return;
}
}
void bfa_cb_lps_fdisclogo_comp(void *bfad , void *uarg ) 
{ 
  struct bfa_fcs_vport_s *vport ;

  {
  vport = (struct bfa_fcs_vport_s *)uarg;
  (*(vport->sm))((void *)vport, 8);
  return;
}
}
void bfa_cb_lps_cvl_event(void *bfad , void *uarg ) 
{ 
  struct bfa_fcs_vport_s *vport ;

  {
  vport = (struct bfa_fcs_vport_s *)uarg;
  (*(vport->sm))((void *)vport, 6);
  (*(vport->sm))((void *)vport, 5);
  return;
}
}
bool ldv_queue_work_on_417(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_3(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_delayed_work_on_418(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_3(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_work_on_419(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_3(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
void ldv_flush_workqueue_420(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
  flush_workqueue(ldv_func_arg1);
  call_and_disable_all_3(2);
  return;
}
}
bool ldv_queue_delayed_work_on_421(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_3(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
void ldv_mutex_lock_422(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_lock_lock(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_423(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_unlock_lock(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_424(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
int ldv_mutex_trylock_425(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
  tmp = mutex_trylock(ldv_func_arg1);
  ldv_func_res = tmp;
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
  return (tmp___0);
  return (ldv_func_res);
}
}
void ldv_mutex_unlock_426(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_427(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_unlock_i_mutex_of_inode(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_428(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_lock_i_mutex_of_inode(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
int ldv_scsi_add_host_with_dma_429(struct Scsi_Host *shost , struct device *dev ,
                                   struct device *dma_dev ) 
{ 
  ldv_func_ret_type___4 ldv_func_res ;
  int tmp ;

  {
  tmp = scsi_add_host_with_dma(shost, dev, dma_dev);
  ldv_func_res = tmp;
  if (ldv_func_res == 0) {
    ldv_state_variable_35 = 1;
    ldv_initialize_scsi_host_template_35();
  } else {

  }
  return (ldv_func_res);
}
}
__inline static long ldv__builtin_expect(long exp , long c ) ;
int ldv_mutex_trylock_455(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_453(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_456(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_457(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_452(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_454(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_458(struct mutex *ldv_func_arg1 ) ;
bool ldv_queue_work_on_447(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_work_on_449(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_delayed_work_on_448(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
bool ldv_queue_delayed_work_on_451(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
void ldv_flush_workqueue_450(struct workqueue_struct *ldv_func_arg1 ) ;
__inline static bool queue_work___3(struct workqueue_struct *wq , struct work_struct *work ) 
{ 
  bool tmp ;

  {
  tmp = ldv_queue_work_on_447(8192, wq, work);
  return (tmp);
}
}
int ldv_scsi_add_host_with_dma_459(struct Scsi_Host *shost , struct device *dev ,
                                   struct device *dma_dev ) ;
__inline static void wwn2str___3(char *wwn_str , u64 wwn ) 
{ 
  union __anonunion_w_281___2 w ;

  {
  w.wwn = wwn;
  sprintf(wwn_str, "%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x", (int )w.byte[0], (int )w.byte[1],
          (int )w.byte[2], (int )w.byte[3], (int )w.byte[4], (int )w.byte[5], (int )w.byte[6],
          (int )w.byte[7]);
  return;
}
}
struct bfa_rport_s *bfa_rport_create(struct bfa_s *bfa , void *rport_drv ) ;
void bfa_rport_online(struct bfa_rport_s *rport , struct bfa_rport_info_s *rport_info ) ;
void bfa_cb_rport_online(void *cbarg ) ;
void bfa_cb_rport_offline(void *cbarg ) ;
void bfa_cb_rport_qos_scn_flowid(void *cbarg , struct bfa_rport_qos_attr_s old_qos_attr ,
                                 struct bfa_rport_qos_attr_s new_qos_attr ) ;
void bfa_cb_rport_scn_online(struct bfa_s *bfa ) ;
void bfa_cb_rport_scn_offline(struct bfa_s *bfa ) ;
void bfa_cb_rport_scn_no_dev(void *rport ) ;
void bfa_cb_rport_qos_scn_prio(void *cbarg , struct bfa_rport_qos_attr_s old_qos_attr ,
                               struct bfa_rport_qos_attr_s new_qos_attr ) ;
struct bfa_fcs_rport_s *bfa_fcs_rport_lookup_by_nwwn(struct bfa_fcs_lport_s *port ,
                                                     wwn_t rnwwn ) ;
void bfa_fcs_rport_start(struct bfa_fcs_lport_s *port , struct fchs_s *fchs , struct fc_logi_s *plogi ) ;
void bfa_fcs_rport_prlo(struct bfa_fcs_rport_s *rport , __be16 ox_id ) ;
void bfa_fcs_rpf_init(struct bfa_fcs_rport_s *rport ) ;
void bfa_fcs_rpf_rport_online(struct bfa_fcs_rport_s *rport ) ;
void bfa_fcs_rpf_rport_offline(struct bfa_fcs_rport_s *rport ) ;
struct bfa_fcs_itnim_s *bfa_fcs_itnim_create(struct bfa_fcs_rport_s *rport ) ;
void bfa_fcs_itnim_delete(struct bfa_fcs_itnim_s *itnim ) ;
void bfa_fcs_itnim_rport_offline(struct bfa_fcs_itnim_s *itnim ) ;
void bfa_fcs_itnim_brp_online(struct bfa_fcs_itnim_s *itnim ) ;
enum bfa_status bfa_fcs_itnim_get_online_state(struct bfa_fcs_itnim_s *itnim ) ;
void bfa_fcs_itnim_is_initiator(struct bfa_fcs_itnim_s *itnim ) ;
void bfa_fcs_fcpim_uf_recv(struct bfa_fcs_itnim_s *itnim , struct fchs_s *fchs , u16 len ) ;
__inline static enum bfa_port_speed fc_rpsc_operspeed_to_bfa_speed(enum fc_rpsc_op_speed speed ) 
{ 


  {
  switch ((unsigned int )speed) {
  case 32768U: ;
  return (1);
  case 16384U: ;
  return (2);
  case 8192U: ;
  return (4);
  case 2048U: ;
  return (8);
  case 1024U: ;
  return (16);
  case 4096U: ;
  return (10);
  default: ;
  return (0);
  }
}
}
__inline static enum fc_rpsc_op_speed fc_bfa_speed_to_rpsc_operspeed(enum bfa_port_speed op_speed ) 
{ 


  {
  switch ((unsigned int )op_speed) {
  case 1U: ;
  return (32768);
  case 2U: ;
  return (16384);
  case 4U: ;
  return (8192);
  case 8U: ;
  return (2048);
  case 16U: ;
  return (1024);
  case 10U: ;
  return (4096);
  default: ;
  return (1);
  }
}
}
u16 fc_gidpn_build(struct fchs_s *fchs , void *pyld , u32 s_id , u16 ox_id , wwn_t port_name ) ;
u16 fc_gpnid_build(struct fchs_s *fchs , void *pyld , u32 s_id , u16 ox_id , u32 port_id ) ;
u16 fc_plogi_acc_build(struct fchs_s *fchs , void *pld , u32 d_id , u32 s_id , u16 ox_id ,
                       wwn_t port_name , wwn_t node_name , u16 pdu_size , u16 bb_cr ) ;
u16 fc_adisc_build(struct fchs_s *fchs , struct fc_adisc_s *adisc , u32 d_id , u32 s_id ,
                   __be16 ox_id , wwn_t port_name , wwn_t node_name ) ;
enum fc_parse_status fc_adisc_rsp_parse(struct fc_adisc_s *adisc , int len , wwn_t port_name ,
                                        wwn_t node_name ) ;
u16 fc_adisc_acc_build(struct fchs_s *fchs , struct fc_adisc_s *adisc , u32 d_id ,
                       u32 s_id , __be16 ox_id , wwn_t port_name , wwn_t node_name ) ;
u16 fc_prli_acc_build(struct fchs_s *fchs , void *pld , u32 d_id , u32 s_id , __be16 ox_id ,
                      enum bfa_lport_role role ) ;
u16 fc_rpsc2_build(struct fchs_s *fchs , struct fc_rpsc2_cmd_s *rpsc2 , u32 d_id ,
                   u32 s_id , u32 *pid_list , u16 npids ) ;
u16 fc_rpsc_acc_build(struct fchs_s *fchs , struct fc_rpsc_acc_s *rpsc_acc , u32 d_id ,
                      u32 s_id , __be16 ox_id , struct fc_rpsc_speed_info_s *oper_speed ) ;
u16 fc_logo_build(struct fchs_s *fchs , struct fc_logo_s *logo , u32 d_id , u32 s_id ,
                  u16 ox_id , wwn_t port_name ) ;
u16 fc_logo_acc_build(struct fchs_s *fchs , void *pld , u32 d_id , u32 s_id , __be16 ox_id ) ;
u16 fc_prlo_acc_build(struct fchs_s *fchs , struct fc_prlo_acc_s *prlo_acc , u32 d_id ,
                      u32 s_id , __be16 ox_id , int num_pages ) ;
static int __trc_fileno___8  =    2051;
static u32 bfa_fcs_rport_del_timeout  =    90000U;
static u32 bfa_fcs_rport_max_logins  =    1024U;
static struct bfa_fcs_rport_s *bfa_fcs_rport_alloc(struct bfa_fcs_lport_s *port ,
                                                   wwn_t pwwn , u32 rpid ) ;
static void bfa_fcs_rport_free(struct bfa_fcs_rport_s *rport ) ;
static void bfa_fcs_rport_hal_online(struct bfa_fcs_rport_s *rport ) ;
static void bfa_fcs_rport_fcs_online_action(struct bfa_fcs_rport_s *rport ) ;
static void bfa_fcs_rport_hal_online_action(struct bfa_fcs_rport_s *rport ) ;
static void bfa_fcs_rport_fcs_offline_action(struct bfa_fcs_rport_s *rport ) ;
static void bfa_fcs_rport_hal_offline_action(struct bfa_fcs_rport_s *rport ) ;
static void bfa_fcs_rport_update(struct bfa_fcs_rport_s *rport , struct fc_logi_s *plogi ) ;
static void bfa_fcs_rport_timeout(void *arg ) ;
static void bfa_fcs_rport_send_plogi(void *rport_cbarg , struct bfa_fcxp_s *fcxp_alloced ) ;
static void bfa_fcs_rport_send_plogiacc(void *rport_cbarg , struct bfa_fcxp_s *fcxp_alloced ) ;
static void bfa_fcs_rport_plogi_response(void *fcsarg , struct bfa_fcxp_s *fcxp ,
                                         void *cbarg , enum bfa_status req_status ,
                                         u32 rsp_len , u32 resid_len , struct fchs_s *rsp_fchs ) ;
static void bfa_fcs_rport_send_adisc(void *rport_cbarg , struct bfa_fcxp_s *fcxp_alloced ) ;
static void bfa_fcs_rport_adisc_response(void *fcsarg , struct bfa_fcxp_s *fcxp ,
                                         void *cbarg , enum bfa_status req_status ,
                                         u32 rsp_len , u32 resid_len , struct fchs_s *rsp_fchs ) ;
static void bfa_fcs_rport_send_nsdisc(void *rport_cbarg , struct bfa_fcxp_s *fcxp_alloced ) ;
static void bfa_fcs_rport_gidpn_response(void *fcsarg , struct bfa_fcxp_s *fcxp ,
                                         void *cbarg , enum bfa_status req_status ,
                                         u32 rsp_len , u32 resid_len , struct fchs_s *rsp_fchs ) ;
static void bfa_fcs_rport_gpnid_response(void *fcsarg , struct bfa_fcxp_s *fcxp ,
                                         void *cbarg , enum bfa_status req_status ,
                                         u32 rsp_len , u32 resid_len , struct fchs_s *rsp_fchs ) ;
static void bfa_fcs_rport_send_logo(void *rport_cbarg , struct bfa_fcxp_s *fcxp_alloced ) ;
static void bfa_fcs_rport_send_logo_acc(void *rport_cbarg ) ;
static void bfa_fcs_rport_process_prli(struct bfa_fcs_rport_s *rport , struct fchs_s *rx_fchs ,
                                       u16 len ) ;
static void bfa_fcs_rport_send_ls_rjt(struct bfa_fcs_rport_s *rport , struct fchs_s *rx_fchs ,
                                      u8 reason_code , u8 reason_code_expl ) ;
static void bfa_fcs_rport_process_adisc(struct bfa_fcs_rport_s *rport , struct fchs_s *rx_fchs ,
                                        u16 len ) ;
static void bfa_fcs_rport_send_prlo_acc(struct bfa_fcs_rport_s *rport ) ;
static void bfa_fcs_rport_hal_offline(struct bfa_fcs_rport_s *rport ) ;
static void bfa_fcs_rport_sm_uninit(struct bfa_fcs_rport_s *rport , enum rport_event event ) ;
static void bfa_fcs_rport_sm_plogi_sending(struct bfa_fcs_rport_s *rport , enum rport_event event ) ;
static void bfa_fcs_rport_sm_plogiacc_sending(struct bfa_fcs_rport_s *rport , enum rport_event event ) ;
static void bfa_fcs_rport_sm_plogi_retry(struct bfa_fcs_rport_s *rport , enum rport_event event ) ;
static void bfa_fcs_rport_sm_plogi(struct bfa_fcs_rport_s *rport , enum rport_event event ) ;
static void bfa_fcs_rport_sm_fc4_fcs_online(struct bfa_fcs_rport_s *rport , enum rport_event event ) ;
static void bfa_fcs_rport_sm_hal_online(struct bfa_fcs_rport_s *rport , enum rport_event event ) ;
static void bfa_fcs_rport_sm_online(struct bfa_fcs_rport_s *rport , enum rport_event event ) ;
static void bfa_fcs_rport_sm_nsquery_sending(struct bfa_fcs_rport_s *rport , enum rport_event event ) ;
static void bfa_fcs_rport_sm_nsquery(struct bfa_fcs_rport_s *rport , enum rport_event event ) ;
static void bfa_fcs_rport_sm_adisc_online_sending(struct bfa_fcs_rport_s *rport ,
                                                  enum rport_event event ) ;
static void bfa_fcs_rport_sm_adisc_online(struct bfa_fcs_rport_s *rport , enum rport_event event ) ;
static void bfa_fcs_rport_sm_adisc_offline_sending(struct bfa_fcs_rport_s *rport ,
                                                   enum rport_event event ) ;
static void bfa_fcs_rport_sm_adisc_offline(struct bfa_fcs_rport_s *rport , enum rport_event event ) ;
static void bfa_fcs_rport_sm_fc4_logorcv(struct bfa_fcs_rport_s *rport , enum rport_event event ) ;
static void bfa_fcs_rport_sm_fc4_logosend(struct bfa_fcs_rport_s *rport , enum rport_event event ) ;
static void bfa_fcs_rport_sm_fc4_offline(struct bfa_fcs_rport_s *rport , enum rport_event event ) ;
static void bfa_fcs_rport_sm_hcb_offline(struct bfa_fcs_rport_s *rport , enum rport_event event ) ;
static void bfa_fcs_rport_sm_hcb_logorcv(struct bfa_fcs_rport_s *rport , enum rport_event event ) ;
static void bfa_fcs_rport_sm_hcb_logosend(struct bfa_fcs_rport_s *rport , enum rport_event event ) ;
static void bfa_fcs_rport_sm_logo_sending(struct bfa_fcs_rport_s *rport , enum rport_event event ) ;
static void bfa_fcs_rport_sm_offline(struct bfa_fcs_rport_s *rport , enum rport_event event ) ;
static void bfa_fcs_rport_sm_nsdisc_sending(struct bfa_fcs_rport_s *rport , enum rport_event event ) ;
static void bfa_fcs_rport_sm_nsdisc_retry(struct bfa_fcs_rport_s *rport , enum rport_event event ) ;
static void bfa_fcs_rport_sm_nsdisc_sent(struct bfa_fcs_rport_s *rport , enum rport_event event ) ;
static void bfa_fcs_rport_sm_fc4_off_delete(struct bfa_fcs_rport_s *rport , enum rport_event event ) ;
static void bfa_fcs_rport_sm_delete_pending(struct bfa_fcs_rport_s *rport , enum rport_event event ) ;
static struct bfa_sm_table_s rport_sm_table[25U]  = 
  {      {(void (*)(void * , int  ))(& bfa_fcs_rport_sm_uninit), 0, 0}, 
        {(void (*)(void * , int  ))(& bfa_fcs_rport_sm_plogi_sending), 2, 0}, 
        {(void (*)(void * , int  ))(& bfa_fcs_rport_sm_plogiacc_sending), 3, 0}, 
        {(void (*)(void * , int  ))(& bfa_fcs_rport_sm_plogi_retry), 4, 0}, 
        {(void (*)(void * , int  ))(& bfa_fcs_rport_sm_plogi), 2, 0}, 
        {(void (*)(void * , int  ))(& bfa_fcs_rport_sm_fc4_fcs_online), 3, 0}, 
        {(void (*)(void * , int  ))(& bfa_fcs_rport_sm_hal_online), 3, 0}, 
        {(void (*)(void * , int  ))(& bfa_fcs_rport_sm_online), 3, 0}, 
        {(void (*)(void * , int  ))(& bfa_fcs_rport_sm_nsquery_sending), 5, 0}, 
        {(void (*)(void * , int  ))(& bfa_fcs_rport_sm_nsquery), 5, 0}, 
        {(void (*)(void * , int  ))(& bfa_fcs_rport_sm_adisc_online_sending), 6, 0}, 
        {(void (*)(void * , int  ))(& bfa_fcs_rport_sm_adisc_online), 6, 0}, 
        {(void (*)(void * , int  ))(& bfa_fcs_rport_sm_adisc_offline_sending), 6, 0}, 
        {(void (*)(void * ,
                int  ))(& bfa_fcs_rport_sm_adisc_offline), 6, 0}, 
        {(void (*)(void * , int  ))(& bfa_fcs_rport_sm_fc4_logorcv), 8, 0}, 
        {(void (*)(void * , int  ))(& bfa_fcs_rport_sm_fc4_logosend), 7, 0}, 
        {(void (*)(void * , int  ))(& bfa_fcs_rport_sm_fc4_offline), 1, 0}, 
        {(void (*)(void * , int  ))(& bfa_fcs_rport_sm_hcb_offline), 1, 0}, 
        {(void (*)(void * , int  ))(& bfa_fcs_rport_sm_hcb_logorcv), 8, 0}, 
        {(void (*)(void * , int  ))(& bfa_fcs_rport_sm_hcb_logosend), 7, 0}, 
        {(void (*)(void * , int  ))(& bfa_fcs_rport_sm_logo_sending), 7, 0}, 
        {(void (*)(void * , int  ))(& bfa_fcs_rport_sm_offline), 1, 0}, 
        {(void (*)(void * , int  ))(& bfa_fcs_rport_sm_nsdisc_sending), 9, 0}, 
        {(void (*)(void * , int  ))(& bfa_fcs_rport_sm_nsdisc_retry), 9, 0}, 
        {(void (*)(void * , int  ))(& bfa_fcs_rport_sm_nsdisc_sent), 9, 0}};
static void bfa_fcs_rport_sm_uninit(struct bfa_fcs_rport_s *rport , enum rport_event event ) 
{ 


  {
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 180, rport->pwwn);
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 181, (unsigned long long )rport->pid);
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 182, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 1U: 
  rport->sm = (void (*)(void * , int  ))(& bfa_fcs_rport_sm_plogi_sending);
  rport->plogi_retries = 0;
  bfa_fcs_rport_send_plogi((void *)rport, (struct bfa_fcxp_s *)0);
  goto ldv_48877;
  case 2U: 
  rport->sm = (void (*)(void * , int  ))(& bfa_fcs_rport_sm_plogiacc_sending);
  bfa_fcs_rport_send_plogiacc((void *)rport, (struct bfa_fcxp_s *)0);
  goto ldv_48877;
  case 3U: 
  rport->sm = (void (*)(void * , int  ))(& bfa_fcs_rport_sm_hal_online);
  bfa_fcs_rport_hal_online(rport);
  goto ldv_48877;
  case 15U: ;
  case 16U: 
  rport->sm = (void (*)(void * , int  ))(& bfa_fcs_rport_sm_nsdisc_sending);
  rport->ns_retries = 0;
  bfa_fcs_rport_send_nsdisc((void *)rport, (struct bfa_fcxp_s *)0);
  goto ldv_48877;
  default: 
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 208, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcs_rport.c",
         208, (unsigned int )event);
  }
  ldv_48877: ;
  return;
}
}
static void bfa_fcs_rport_sm_plogi_sending(struct bfa_fcs_rport_s *rport , enum rport_event event ) 
{ 
  int __ret_warn_on ;
  enum bfa_port_topology tmp ;
  long tmp___0 ;

  {
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 219, rport->pwwn);
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 220, (unsigned long long )rport->pid);
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 221, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 6U: 
  rport->sm = (void (*)(void * , int  ))(& bfa_fcs_rport_sm_plogi);
  goto ldv_48888;
  case 7U: 
  rport->sm = (void (*)(void * , int  ))(& bfa_fcs_rport_sm_uninit);
  bfa_fcxp_walloc_cancel((rport->fcs)->bfa, & rport->fcxp_wqe);
  bfa_fcs_rport_free(rport);
  goto ldv_48888;
  case 2U: 
  rport->sm = (void (*)(void * , int  ))(& bfa_fcs_rport_sm_plogiacc_sending);
  bfa_fcxp_walloc_cancel((rport->fcs)->bfa, & rport->fcxp_wqe);
  bfa_fcs_rport_send_plogiacc((void *)rport, (struct bfa_fcxp_s *)0);
  goto ldv_48888;
  case 19U: 
  rport->sm = (void (*)(void * , int  ))(& bfa_fcs_rport_sm_offline);
  bfa_fcxp_walloc_cancel((rport->fcs)->bfa, & rport->fcxp_wqe);
  bfa_timer_begin(& ((rport->fcs)->bfa)->timer_mod, & rport->timer, & bfa_fcs_rport_timeout,
                  (void *)rport, bfa_fcs_rport_del_timeout);
  goto ldv_48888;
  case 15U: ;
  case 8U: 
  bfa_fcxp_walloc_cancel((rport->fcs)->bfa, & rport->fcxp_wqe);
  tmp = bfa_fcport_get_topology(((rport->port)->fcs)->bfa);
  __ret_warn_on = (unsigned int )tmp == 2U;
  tmp___0 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp___0 != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcs_rport.c",
                       252);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  rport->sm = (void (*)(void * , int  ))(& bfa_fcs_rport_sm_nsdisc_sending);
  rport->ns_retries = 0;
  bfa_fcs_rport_send_nsdisc((void *)rport, (struct bfa_fcxp_s *)0);
  goto ldv_48888;
  case 5U: 
  rport->pid = 0U;
  rport->sm = (void (*)(void * , int  ))(& bfa_fcs_rport_sm_offline);
  bfa_fcxp_walloc_cancel((rport->fcs)->bfa, & rport->fcxp_wqe);
  bfa_timer_begin(& ((rport->fcs)->bfa)->timer_mod, & rport->timer, & bfa_fcs_rport_timeout,
                  (void *)rport, bfa_fcs_rport_del_timeout);
  goto ldv_48888;
  default: 
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 269, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcs_rport.c",
         269, (unsigned int )event);
  }
  ldv_48888: ;
  return;
}
}
static void bfa_fcs_rport_sm_plogiacc_sending(struct bfa_fcs_rport_s *rport , enum rport_event event ) 
{ 


  {
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 280, rport->pwwn);
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 281, (unsigned long long )rport->pid);
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 282, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 6U: 
  rport->sm = (void (*)(void * , int  ))(& bfa_fcs_rport_sm_fc4_fcs_online);
  bfa_fcs_rport_fcs_online_action(rport);
  goto ldv_48903;
  case 7U: 
  rport->sm = (void (*)(void * , int  ))(& bfa_fcs_rport_sm_uninit);
  bfa_fcxp_walloc_cancel((rport->fcs)->bfa, & rport->fcxp_wqe);
  bfa_fcs_rport_free(rport);
  goto ldv_48903;
  case 2U: ;
  case 3U: ;
  case 8U: ;
  goto ldv_48903;
  case 19U: 
  rport->sm = (void (*)(void * , int  ))(& bfa_fcs_rport_sm_offline);
  bfa_fcxp_walloc_cancel((rport->fcs)->bfa, & rport->fcxp_wqe);
  bfa_timer_begin(& ((rport->fcs)->bfa)->timer_mod, & rport->timer, & bfa_fcs_rport_timeout,
                  (void *)rport, bfa_fcs_rport_del_timeout);
  goto ldv_48903;
  case 15U: 
  bfa_fcxp_walloc_cancel((rport->fcs)->bfa, & rport->fcxp_wqe);
  rport->sm = (void (*)(void * , int  ))(& bfa_fcs_rport_sm_nsdisc_sending);
  rport->ns_retries = 0;
  bfa_fcs_rport_send_nsdisc((void *)rport, (struct bfa_fcxp_s *)0);
  goto ldv_48903;
  case 5U: 
  rport->pid = 0U;
  rport->sm = (void (*)(void * , int  ))(& bfa_fcs_rport_sm_offline);
  bfa_fcxp_walloc_cancel((rport->fcs)->bfa, & rport->fcxp_wqe);
  bfa_timer_begin(& ((rport->fcs)->bfa)->timer_mod, & rport->timer, & bfa_fcs_rport_timeout,
                  (void *)rport, bfa_fcs_rport_del_timeout);
  goto ldv_48903;
  case 13U: ;
  goto ldv_48903;
  default: 
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 335, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcs_rport.c",
         335, (unsigned int )event);
  }
  ldv_48903: ;
  return;
}
}
static void bfa_fcs_rport_sm_plogi_retry(struct bfa_fcs_rport_s *rport , enum rport_event event ) 
{ 
  int __ret_warn_on ;
  enum bfa_port_topology tmp ;
  long tmp___0 ;

  {
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 346, rport->pwwn);
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 347, (unsigned long long )rport->pid);
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 348, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 11U: 
  rport->sm = (void (*)(void * , int  ))(& bfa_fcs_rport_sm_plogi_sending);
  bfa_fcs_rport_send_plogi((void *)rport, (struct bfa_fcxp_s *)0);
  goto ldv_48918;
  case 7U: 
  rport->sm = (void (*)(void * , int  ))(& bfa_fcs_rport_sm_uninit);
  bfa_timer_stop(& rport->timer);
  bfa_fcs_rport_free(rport);
  goto ldv_48918;
  case 17U: ;
  case 4U: ;
  goto ldv_48918;
  case 2U: 
  rport->sm = (void (*)(void * , int  ))(& bfa_fcs_rport_sm_plogiacc_sending);
  bfa_timer_stop(& rport->timer);
  bfa_fcs_rport_send_plogiacc((void *)rport, (struct bfa_fcxp_s *)0);
  goto ldv_48918;
  case 19U: 
  rport->sm = (void (*)(void * , int  ))(& bfa_fcs_rport_sm_offline);
  bfa_timer_stop(& rport->timer);
  bfa_timer_begin(& ((rport->fcs)->bfa)->timer_mod, & rport->timer, & bfa_fcs_rport_timeout,
                  (void *)rport, bfa_fcs_rport_del_timeout);
  goto ldv_48918;
  case 15U: ;
  case 8U: 
  bfa_timer_stop(& rport->timer);
  tmp = bfa_fcport_get_topology(((rport->port)->fcs)->bfa);
  __ret_warn_on = (unsigned int )tmp == 2U;
  tmp___0 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp___0 != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcs_rport.c",
                       384);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  rport->sm = (void (*)(void * , int  ))(& bfa_fcs_rport_sm_nsdisc_sending);
  rport->ns_retries = 0;
  bfa_fcs_rport_send_nsdisc((void *)rport, (struct bfa_fcxp_s *)0);
  goto ldv_48918;
  case 5U: 
  rport->pid = 0U;
  rport->sm = (void (*)(void * , int  ))(& bfa_fcs_rport_sm_offline);
  bfa_timer_stop(& rport->timer);
  bfa_timer_begin(& ((rport->fcs)->bfa)->timer_mod, & rport->timer, & bfa_fcs_rport_timeout,
                  (void *)rport, bfa_fcs_rport_del_timeout);
  goto ldv_48918;
  case 3U: 
  rport->sm = (void (*)(void * , int  ))(& bfa_fcs_rport_sm_fc4_fcs_online);
  bfa_timer_stop(& rport->timer);
  bfa_fcs_rport_fcs_online_action(rport);
  goto ldv_48918;
  default: 
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 406, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcs_rport.c",
         406, (unsigned int )event);
  }
  ldv_48918: ;
  return;
}
}
static void bfa_fcs_rport_sm_plogi(struct bfa_fcs_rport_s *rport , enum rport_event event ) 
{ 
  int __ret_warn_on ;
  enum bfa_port_topology tmp ;
  long tmp___0 ;

  {
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 416, rport->pwwn);
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 417, (unsigned long long )rport->pid);
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 418, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 9U: 
  rport->sm = (void (*)(void * , int  ))(& bfa_fcs_rport_sm_fc4_fcs_online);
  rport->plogi_retries = 0;
  bfa_fcs_rport_fcs_online_action(rport);
  goto ldv_48936;
  case 4U: 
  bfa_fcs_rport_send_logo_acc((void *)rport);
  case 17U: ;
  if ((unsigned int )rport->prlo == 1U) {
    bfa_fcs_rport_send_prlo_acc(rport);
  } else {

  }
  bfa_fcxp_discard(rport->fcxp);
  case 10U: ;
  if (rport->plogi_retries <= 4) {
    rport->plogi_retries = rport->plogi_retries + 1;
    rport->sm = (void (*)(void * , int  ))(& bfa_fcs_rport_sm_plogi_retry);
    bfa_timer_begin(& ((rport->fcs)->bfa)->timer_mod, & rport->timer, & bfa_fcs_rport_timeout,
                    (void *)rport, 2000U);
  } else {
    (rport->port)->stats.rport_del_max_plogi_retry = (rport->port)->stats.rport_del_max_plogi_retry + 1U;
    rport->old_pid = rport->pid;
    rport->pid = 0U;
    rport->sm = (void (*)(void * , int  ))(& bfa_fcs_rport_sm_offline);
    bfa_timer_begin(& ((rport->fcs)->bfa)->timer_mod, & rport->timer, & bfa_fcs_rport_timeout,
                    (void *)rport, bfa_fcs_rport_del_timeout);
  }
  goto ldv_48936;
  case 20U: ;
  goto ldv_48936;
  case 19U: 
  rport->sm = (void (*)(void * , int  ))(& bfa_fcs_rport_sm_offline);
  bfa_fcxp_discard(rport->fcxp);
  bfa_timer_begin(& ((rport->fcs)->bfa)->timer_mod, & rport->timer, & bfa_fcs_rport_timeout,
                  (void *)rport, bfa_fcs_rport_del_timeout);
  goto ldv_48936;
  case 18U: 
  rport->plogi_retries = 0;
  rport->sm = (void (*)(void * , int  ))(& bfa_fcs_rport_sm_plogi_retry);
  bfa_timer_begin(& ((rport->fcs)->bfa)->timer_mod, & rport->timer, & bfa_fcs_rport_timeout,
                  (void *)rport, 10000U);
  goto ldv_48936;
  case 5U: 
  rport->pid = 0U;
  rport->sm = (void (*)(void * , int  ))(& bfa_fcs_rport_sm_offline);
  bfa_fcxp_discard(rport->fcxp);
  bfa_timer_begin(& ((rport->fcs)->bfa)->timer_mod, & rport->timer, & bfa_fcs_rport_timeout,
                  (void *)rport, bfa_fcs_rport_del_timeout);
  goto ldv_48936;
  case 15U: ;
  case 8U: 
  bfa_fcxp_discard(rport->fcxp);
  tmp = bfa_fcport_get_topology(((rport->port)->fcs)->bfa);
  __ret_warn_on = (unsigned int )tmp == 2U;
  tmp___0 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp___0 != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcs_rport.c",
                       490);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  rport->sm = (void (*)(void * , int  ))(& bfa_fcs_rport_sm_nsdisc_sending);
  rport->ns_retries = 0;
  bfa_fcs_rport_send_nsdisc((void *)rport, (struct bfa_fcxp_s *)0);
  goto ldv_48936;
  case 2U: 
  rport->sm = (void (*)(void * , int  ))(& bfa_fcs_rport_sm_plogiacc_sending);
  bfa_fcxp_discard(rport->fcxp);
  bfa_fcs_rport_send_plogiacc((void *)rport, (struct bfa_fcxp_s *)0);
  goto ldv_48936;
  case 7U: 
  rport->sm = (void (*)(void * , int  ))(& bfa_fcs_rport_sm_uninit);
  bfa_fcxp_discard(rport->fcxp);
  bfa_fcs_rport_free(rport);
  goto ldv_48936;
  case 3U: 
  rport->sm = (void (*)(void * , int  ))(& bfa_fcs_rport_sm_fc4_fcs_online);
  bfa_fcxp_discard(rport->fcxp);
  bfa_fcs_rport_fcs_online_action(rport);
  goto ldv_48936;
  default: 
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 515, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcs_rport.c",
         515, (unsigned int )event);
  }
  ldv_48936: ;
  return;
}
}
static void bfa_fcs_rport_sm_fc4_fcs_online(struct bfa_fcs_rport_s *rport , enum rport_event event ) 
{ 


  {
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 526, rport->pwwn);
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 527, (unsigned long long )rport->pid);
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 528, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 21U: ;
  if ((unsigned int )rport->scsi_function == 1U) {
    if (((((rport->pid & 255U) << 16) | (rport->pid & 65280U)) | ((rport->pid & 16711680U) >> 16)) <= 16773120U) {
      bfa_fcs_rpf_rport_online(rport);
    } else {

    }
    rport->sm = (void (*)(void * , int  ))(& bfa_fcs_rport_sm_online);
    goto ldv_48957;
  } else {

  }
  if ((unsigned long )rport->bfa_rport == (unsigned long )((struct bfa_rport_s *)0)) {
    rport->bfa_rport = bfa_rport_create((rport->fcs)->bfa, (void *)rport);
  } else {

  }
  if ((unsigned long )rport->bfa_rport != (unsigned long )((struct bfa_rport_s *)0)) {
    rport->sm = (void (*)(void * , int  ))(& bfa_fcs_rport_sm_hal_online);
    bfa_fcs_rport_hal_online(rport);
  } else {
    rport->sm = (void (*)(void * , int  ))(& bfa_fcs_rport_sm_fc4_logosend);
    bfa_fcs_rport_fcs_offline_action(rport);
  }
  goto ldv_48957;
  case 2U: 
  rport->sm = (void (*)(void * , int  ))(& bfa_fcs_rport_sm_fc4_offline);
  rport->plogi_pending = 1;
  bfa_fcs_rport_fcs_offline_action(rport);
  goto ldv_48957;
  case 3U: ;
  case 5U: ;
  case 15U: ;
  case 8U: ;
  case 19U: 
  rport->sm = (void (*)(void * , int  ))(& bfa_fcs_rport_sm_fc4_offline);
  bfa_fcs_rport_fcs_offline_action(rport);
  goto ldv_48957;
  case 4U: ;
  case 17U: 
  rport->sm = (void (*)(void * , int  ))(& bfa_fcs_rport_sm_fc4_logorcv);
  bfa_fcs_rport_fcs_offline_action(rport);
  goto ldv_48957;
  case 7U: 
  rport->sm = (void (*)(void * , int  ))(& bfa_fcs_rport_sm_fc4_logosend);
  bfa_fcs_rport_fcs_offline_action(rport);
  goto ldv_48957;
  default: 
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 579, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcs_rport.c",
         579, (unsigned int )event);
  goto ldv_48957;
  }
  ldv_48957: ;
  return;
}
}
static void bfa_fcs_rport_sm_hal_online(struct bfa_fcs_rport_s *rport , enum rport_event event ) 
{ 


  {
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 592, rport->pwwn);
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 593, (unsigned long long )rport->pid);
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 594, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 12U: 
  rport->sm = (void (*)(void * , int  ))(& bfa_fcs_rport_sm_online);
  bfa_fcs_rport_hal_online_action(rport);
  goto ldv_48973;
  case 3U: ;
  goto ldv_48973;
  case 17U: ;
  case 4U: 
  rport->sm = (void (*)(void * , int  ))(& bfa_fcs_rport_sm_fc4_logorcv);
  bfa_fcs_rport_fcs_offline_action(rport);
  goto ldv_48973;
  case 8U: ;
  case 5U: ;
  case 15U: ;
  case 19U: 
  rport->sm = (void (*)(void * , int  ))(& bfa_fcs_rport_sm_fc4_offline);
  bfa_fcs_rport_fcs_offline_action(rport);
  goto ldv_48973;
  case 2U: 
  rport->plogi_pending = 1;
  rport->sm = (void (*)(void * , int  ))(& bfa_fcs_rport_sm_fc4_offline);
  bfa_fcs_rport_fcs_offline_action(rport);
  goto ldv_48973;
  case 7U: 
  rport->sm = (void (*)(void * , int  ))(& bfa_fcs_rport_sm_fc4_logosend);
  bfa_fcs_rport_fcs_offline_action(rport);
  goto ldv_48973;
  default: 
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 631, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcs_rport.c",
         631, (unsigned int )event);
  }
  ldv_48973: ;
  return;
}
}
static void bfa_fcs_rport_sm_online(struct bfa_fcs_rport_s *rport , enum rport_event event ) 
{ 


  {
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 641, rport->pwwn);
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 642, (unsigned long long )rport->pid);
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 643, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 8U: ;
  if ((unsigned int )((rport->port)->fabric)->fab_type == 1U) {
    rport->sm = (void (*)(void * , int  ))(& bfa_fcs_rport_sm_nsquery_sending);
    rport->ns_retries = 0;
    bfa_fcs_rport_send_nsdisc((void *)rport, (struct bfa_fcxp_s *)0);
  } else {
    rport->sm = (void (*)(void * , int  ))(& bfa_fcs_rport_sm_adisc_online_sending);
    bfa_fcs_rport_send_adisc((void *)rport, (struct bfa_fcxp_s *)0);
  }
  goto ldv_48989;
  case 2U: ;
  case 5U: ;
  case 15U: ;
  case 19U: 
  rport->sm = (void (*)(void * , int  ))(& bfa_fcs_rport_sm_fc4_offline);
  bfa_fcs_rport_hal_offline_action(rport);
  goto ldv_48989;
  case 7U: 
  rport->sm = (void (*)(void * , int  ))(& bfa_fcs_rport_sm_fc4_logosend);
  bfa_fcs_rport_hal_offline_action(rport);
  goto ldv_48989;
  case 4U: ;
  case 17U: 
  rport->sm = (void (*)(void * , int  ))(& bfa_fcs_rport_sm_fc4_logorcv);
  bfa_fcs_rport_hal_offline_action(rport);
  goto ldv_48989;
  case 20U: ;
  case 3U: ;
  goto ldv_48989;
  default: 
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 683, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcs_rport.c",
         683, (unsigned int )event);
  }
  ldv_48989: ;
  return;
}
}
static void bfa_fcs_rport_sm_nsquery_sending(struct bfa_fcs_rport_s *rport , enum rport_event event ) 
{ 


  {
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 695, rport->pwwn);
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 696, (unsigned long long )rport->pid);
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 697, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 6U: 
  rport->sm = (void (*)(void * , int  ))(& bfa_fcs_rport_sm_nsquery);
  goto ldv_49005;
  case 7U: 
  rport->sm = (void (*)(void * , int  ))(& bfa_fcs_rport_sm_fc4_logosend);
  bfa_fcxp_walloc_cancel((rport->fcs)->bfa, & rport->fcxp_wqe);
  bfa_fcs_rport_hal_offline_action(rport);
  goto ldv_49005;
  case 8U: ;
  goto ldv_49005;
  case 4U: ;
  case 17U: 
  rport->sm = (void (*)(void * , int  ))(& bfa_fcs_rport_sm_fc4_logorcv);
  bfa_fcxp_walloc_cancel((rport->fcs)->bfa, & rport->fcxp_wqe);
  bfa_fcs_rport_hal_offline_action(rport);
  goto ldv_49005;
  case 5U: ;
  case 2U: ;
  case 15U: ;
  case 3U: 
  rport->sm = (void (*)(void * , int  ))(& bfa_fcs_rport_sm_fc4_offline);
  bfa_fcxp_walloc_cancel((rport->fcs)->bfa, & rport->fcxp_wqe);
  bfa_fcs_rport_hal_offline_action(rport);
  goto ldv_49005;
  default: 
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 733, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcs_rport.c",
         733, (unsigned int )event);
  }
  ldv_49005: ;
  return;
}
}
static void bfa_fcs_rport_sm_nsquery(struct bfa_fcs_rport_s *rport , enum rport_event event ) 
{ 


  {
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 744, rport->pwwn);
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 745, (unsigned long long )rport->pid);
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 746, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 9U: 
  rport->sm = (void (*)(void * , int  ))(& bfa_fcs_rport_sm_adisc_online_sending);
  bfa_fcs_rport_send_adisc((void *)rport, (struct bfa_fcxp_s *)0);
  goto ldv_49020;
  case 10U: 
  rport->ns_retries = rport->ns_retries + 1;
  if (rport->ns_retries <= 4) {
    rport->sm = (void (*)(void * , int  ))(& bfa_fcs_rport_sm_nsquery_sending);
    bfa_fcs_rport_send_nsdisc((void *)rport, (struct bfa_fcxp_s *)0);
  } else {
    rport->sm = (void (*)(void * , int  ))(& bfa_fcs_rport_sm_fc4_offline);
    bfa_fcs_rport_hal_offline_action(rport);
  }
  goto ldv_49020;
  case 7U: 
  rport->sm = (void (*)(void * , int  ))(& bfa_fcs_rport_sm_fc4_logosend);
  bfa_fcxp_discard(rport->fcxp);
  bfa_fcs_rport_hal_offline_action(rport);
  goto ldv_49020;
  case 8U: ;
  goto ldv_49020;
  case 4U: ;
  case 17U: 
  rport->sm = (void (*)(void * , int  ))(& bfa_fcs_rport_sm_fc4_logorcv);
  bfa_fcxp_discard(rport->fcxp);
  bfa_fcs_rport_hal_offline_action(rport);
  goto ldv_49020;
  case 3U: ;
  case 15U: ;
  case 2U: ;
  case 5U: 
  rport->sm = (void (*)(void * , int  ))(& bfa_fcs_rport_sm_fc4_offline);
  bfa_fcxp_discard(rport->fcxp);
  bfa_fcs_rport_hal_offline_action(rport);
  goto ldv_49020;
  default: 
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 792, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcs_rport.c",
         792, (unsigned int )event);
  }
  ldv_49020: ;
  return;
}
}
static void bfa_fcs_rport_sm_adisc_online_sending(struct bfa_fcs_rport_s *rport ,
                                                  enum rport_event event ) 
{ 


  {
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 804, rport->pwwn);
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 805, (unsigned long long )rport->pid);
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 806, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 6U: 
  rport->sm = (void (*)(void * , int  ))(& bfa_fcs_rport_sm_adisc_online);
  goto ldv_49036;
  case 7U: 
  rport->sm = (void (*)(void * , int  ))(& bfa_fcs_rport_sm_fc4_logosend);
  bfa_fcxp_walloc_cancel((rport->fcs)->bfa, & rport->fcxp_wqe);
  bfa_fcs_rport_hal_offline_action(rport);
  goto ldv_49036;
  case 5U: ;
  case 15U: 
  rport->sm = (void (*)(void * , int  ))(& bfa_fcs_rport_sm_fc4_offline);
  bfa_fcxp_walloc_cancel((rport->fcs)->bfa, & rport->fcxp_wqe);
  bfa_fcs_rport_hal_offline_action(rport);
  goto ldv_49036;
  case 4U: ;
  case 17U: 
  rport->sm = (void (*)(void * , int  ))(& bfa_fcs_rport_sm_fc4_logorcv);
  bfa_fcxp_walloc_cancel((rport->fcs)->bfa, & rport->fcxp_wqe);
  bfa_fcs_rport_hal_offline_action(rport);
  goto ldv_49036;
  case 8U: ;
  goto ldv_49036;
  case 2U: 
  rport->sm = (void (*)(void * , int  ))(& bfa_fcs_rport_sm_fc4_offline);
  bfa_fcxp_walloc_cancel((rport->fcs)->bfa, & rport->fcxp_wqe);
  bfa_fcs_rport_hal_offline_action(rport);
  goto ldv_49036;
  default: 
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 843, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcs_rport.c",
         843, (unsigned int )event);
  }
  ldv_49036: ;
  return;
}
}
static void bfa_fcs_rport_sm_adisc_online(struct bfa_fcs_rport_s *rport , enum rport_event event ) 
{ 


  {
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 855, rport->pwwn);
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 856, (unsigned long long )rport->pid);
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 857, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 9U: 
  rport->sm = (void (*)(void * , int  ))(& bfa_fcs_rport_sm_online);
  goto ldv_49050;
  case 2U: 
  bfa_fcxp_discard(rport->fcxp);
  case 10U: ;
  case 15U: 
  rport->sm = (void (*)(void * , int  ))(& bfa_fcs_rport_sm_fc4_offline);
  bfa_fcs_rport_hal_offline_action(rport);
  goto ldv_49050;
  case 7U: 
  rport->sm = (void (*)(void * , int  ))(& bfa_fcs_rport_sm_fc4_logosend);
  bfa_fcxp_discard(rport->fcxp);
  bfa_fcs_rport_hal_offline_action(rport);
  goto ldv_49050;
  case 8U: ;
  goto ldv_49050;
  case 5U: 
  rport->sm = (void (*)(void * , int  ))(& bfa_fcs_rport_sm_fc4_offline);
  bfa_fcxp_discard(rport->fcxp);
  bfa_fcs_rport_hal_offline_action(rport);
  goto ldv_49050;
  case 4U: ;
  case 17U: 
  rport->sm = (void (*)(void * , int  ))(& bfa_fcs_rport_sm_fc4_logorcv);
  bfa_fcxp_discard(rport->fcxp);
  bfa_fcs_rport_hal_offline_action(rport);
  goto ldv_49050;
  default: 
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 906, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcs_rport.c",
         906, (unsigned int )event);
  }
  ldv_49050: ;
  return;
}
}
static void bfa_fcs_rport_sm_adisc_offline_sending(struct bfa_fcs_rport_s *rport ,
                                                   enum rport_event event ) 
{ 


  {
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 918, rport->pwwn);
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 919, (unsigned long long )rport->pid);
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 920, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 6U: 
  rport->sm = (void (*)(void * , int  ))(& bfa_fcs_rport_sm_adisc_offline);
  goto ldv_49065;
  case 7U: ;
  case 19U: ;
  case 5U: ;
  case 4U: ;
  case 17U: 
  rport->sm = (void (*)(void * , int  ))(& bfa_fcs_rport_sm_offline);
  bfa_fcxp_walloc_cancel((rport->fcs)->bfa, & rport->fcxp_wqe);
  bfa_timer_begin(& ((rport->fcs)->bfa)->timer_mod, & rport->timer, & bfa_fcs_rport_timeout,
                  (void *)rport, bfa_fcs_rport_del_timeout);
  goto ldv_49065;
  case 2U: 
  rport->sm = (void (*)(void * , int  ))(& bfa_fcs_rport_sm_plogiacc_sending);
  bfa_fcxp_walloc_cancel((rport->fcs)->bfa, & rport->fcxp_wqe);
  bfa_fcs_rport_send_plogiacc((void *)rport, (struct bfa_fcxp_s *)0);
  goto ldv_49065;
  default: 
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 947, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcs_rport.c",
         947, (unsigned int )event);
  }
  ldv_49065: ;
  return;
}
}
static void bfa_fcs_rport_sm_adisc_offline(struct bfa_fcs_rport_s *rport , enum rport_event event ) 
{ 


  {
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 959, rport->pwwn);
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 960, (unsigned long long )rport->pid);
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 961, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 9U: 
  rport->sm = (void (*)(void * , int  ))(& bfa_fcs_rport_sm_hal_online);
  bfa_fcs_rport_hal_online(rport);
  goto ldv_49078;
  case 2U: 
  rport->sm = (void (*)(void * , int  ))(& bfa_fcs_rport_sm_plogiacc_sending);
  bfa_fcxp_discard(rport->fcxp);
  bfa_fcs_rport_send_plogiacc((void *)rport, (struct bfa_fcxp_s *)0);
  goto ldv_49078;
  case 10U: 
  rport->sm = (void (*)(void * , int  ))(& bfa_fcs_rport_sm_offline);
  bfa_timer_begin(& ((rport->fcs)->bfa)->timer_mod, & rport->timer, & bfa_fcs_rport_timeout,
                  (void *)rport, bfa_fcs_rport_del_timeout);
  goto ldv_49078;
  case 7U: ;
  case 19U: ;
  case 5U: ;
  case 4U: ;
  case 17U: 
  rport->sm = (void (*)(void * , int  ))(& bfa_fcs_rport_sm_offline);
  bfa_fcxp_discard(rport->fcxp);
  bfa_timer_begin(& ((rport->fcs)->bfa)->timer_mod, & rport->timer, & bfa_fcs_rport_timeout,
                  (void *)rport, bfa_fcs_rport_del_timeout);
  goto ldv_49078;
  default: 
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 995, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcs_rport.c",
         995, (unsigned int )event);
  }
  ldv_49078: ;
  return;
}
}
static void bfa_fcs_rport_sm_fc4_logorcv(struct bfa_fcs_rport_s *rport , enum rport_event event ) 
{ 


  {
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 1006, rport->pwwn);
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 1007, (unsigned long long )rport->pid);
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 1008, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 14U: 
  rport->sm = (void (*)(void * , int  ))(& bfa_fcs_rport_sm_hcb_logorcv);
  bfa_fcs_rport_hal_offline(rport);
  goto ldv_49092;
  case 7U: ;
  if (rport->pid != 0U && (unsigned int )rport->prlo == 1U) {
    bfa_fcs_rport_send_prlo_acc(rport);
  } else {

  }
  if (rport->pid != 0U && (unsigned int )rport->prlo == 0U) {
    bfa_fcs_rport_send_logo_acc((void *)rport);
  } else {

  }
  rport->sm = (void (*)(void * , int  ))(& bfa_fcs_rport_sm_fc4_off_delete);
  goto ldv_49092;
  case 20U: ;
  case 19U: ;
  case 12U: ;
  case 4U: ;
  case 17U: ;
  case 15U: ;
  goto ldv_49092;
  default: 
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 1034, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcs_rport.c",
         1034, (unsigned int )event);
  }
  ldv_49092: ;
  return;
}
}
static void bfa_fcs_rport_sm_fc4_logosend(struct bfa_fcs_rport_s *rport , enum rport_event event ) 
{ 


  {
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 1046, rport->pwwn);
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 1047, (unsigned long long )rport->pid);
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 1048, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 14U: 
  rport->sm = (void (*)(void * , int  ))(& bfa_fcs_rport_sm_hcb_logosend);
  bfa_fcs_rport_hal_offline(rport);
  goto ldv_49106;
  case 4U: 
  bfa_fcs_rport_send_logo_acc((void *)rport);
  case 17U: ;
  if ((unsigned int )rport->prlo == 1U) {
    bfa_fcs_rport_send_prlo_acc(rport);
  } else {

  }
  rport->sm = (void (*)(void * , int  ))(& bfa_fcs_rport_sm_fc4_off_delete);
  goto ldv_49106;
  case 12U: ;
  case 7U: ;
  goto ldv_49106;
  default: 
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 1070, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcs_rport.c",
         1070, (unsigned int )event);
  }
  ldv_49106: ;
  return;
}
}
static void bfa_fcs_rport_sm_fc4_offline(struct bfa_fcs_rport_s *rport , enum rport_event event ) 
{ 


  {
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 1081, rport->pwwn);
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 1082, (unsigned long long )rport->pid);
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 1083, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 14U: 
  rport->sm = (void (*)(void * , int  ))(& bfa_fcs_rport_sm_hcb_offline);
  bfa_fcs_rport_hal_offline(rport);
  goto ldv_49117;
  case 20U: ;
  goto ldv_49117;
  case 4U: 
  bfa_fcs_rport_send_logo_acc((void *)rport);
  goto ldv_49117;
  case 17U: 
  bfa_fcs_rport_send_prlo_acc(rport);
  goto ldv_49117;
  case 19U: ;
  case 12U: ;
  case 8U: ;
  case 5U: ;
  case 15U: ;
  goto ldv_49117;
  case 7U: 
  rport->sm = (void (*)(void * , int  ))(& bfa_fcs_rport_sm_fc4_logosend);
  goto ldv_49117;
  default: 
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 1120, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcs_rport.c",
         1120, (unsigned int )event);
  }
  ldv_49117: ;
  return;
}
}
static void bfa_fcs_rport_sm_hcb_offline(struct bfa_fcs_rport_s *rport , enum rport_event event ) 
{ 
  enum bfa_boolean tmp ;
  enum bfa_boolean tmp___0 ;
  enum bfa_port_topology tmp___1 ;

  {
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 1132, rport->pwwn);
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 1133, (unsigned long long )rport->pid);
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 1134, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 13U: 
  tmp = bfa_fcs_lport_is_online(rport->port);
  if ((unsigned int )tmp != 0U && (unsigned int )rport->plogi_pending != 0U) {
    rport->plogi_pending = 0;
    rport->sm = (void (*)(void * , int  ))(& bfa_fcs_rport_sm_plogiacc_sending);
    bfa_fcs_rport_send_plogiacc((void *)rport, (struct bfa_fcxp_s *)0);
    goto ldv_49133;
  } else {

  }
  case 15U: 
  tmp___0 = bfa_fcs_lport_is_online(rport->port);
  if ((unsigned int )tmp___0 == 0U) {
    rport->pid = 0U;
    rport->sm = (void (*)(void * , int  ))(& bfa_fcs_rport_sm_offline);
    bfa_timer_begin(& ((rport->fcs)->bfa)->timer_mod, & rport->timer, & bfa_fcs_rport_timeout,
                    (void *)rport, bfa_fcs_rport_del_timeout);
    goto ldv_49133;
  } else {

  }
  if ((unsigned int )((rport->port)->fabric)->fab_type == 1U) {
    rport->sm = (void (*)(void * , int  ))(& bfa_fcs_rport_sm_nsdisc_sending);
    rport->ns_retries = 0;
    bfa_fcs_rport_send_nsdisc((void *)rport, (struct bfa_fcxp_s *)0);
  } else {
    tmp___1 = bfa_fcport_get_topology(((rport->port)->fcs)->bfa);
    if ((unsigned int )tmp___1 == 2U) {
      if ((unsigned int )rport->scn_online != 0U) {
        rport->sm = (void (*)(void * , int  ))(& bfa_fcs_rport_sm_adisc_offline_sending);
        bfa_fcs_rport_send_adisc((void *)rport, (struct bfa_fcxp_s *)0);
      } else {
        rport->sm = (void (*)(void * , int  ))(& bfa_fcs_rport_sm_offline);
        bfa_timer_begin(& ((rport->fcs)->bfa)->timer_mod, & rport->timer, & bfa_fcs_rport_timeout,
                        (void *)rport, bfa_fcs_rport_del_timeout);
      }
    } else {
      rport->sm = (void (*)(void * , int  ))(& bfa_fcs_rport_sm_plogi_sending);
      rport->plogi_retries = 0;
      bfa_fcs_rport_send_plogi((void *)rport, (struct bfa_fcxp_s *)0);
    }
  }
  goto ldv_49133;
  case 7U: 
  rport->sm = (void (*)(void * , int  ))(& bfa_fcs_rport_sm_uninit);
  bfa_fcs_rport_free(rport);
  goto ldv_49133;
  case 20U: ;
  case 19U: ;
  case 8U: ;
  case 4U: ;
  case 17U: ;
  case 2U: ;
  case 5U: ;
  goto ldv_49133;
  default: 
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 1202, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcs_rport.c",
         1202, (unsigned int )event);
  }
  ldv_49133: ;
  return;
}
}
static void bfa_fcs_rport_sm_hcb_logorcv(struct bfa_fcs_rport_s *rport , enum rport_event event ) 
{ 
  enum bfa_boolean tmp ;

  {
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 1214, rport->pwwn);
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 1215, (unsigned long long )rport->pid);
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 1216, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 13U: ;
  case 15U: ;
  if (rport->pid != 0U && (unsigned int )rport->prlo == 1U) {
    bfa_fcs_rport_send_prlo_acc(rport);
  } else {

  }
  if (rport->pid != 0U && (unsigned int )rport->prlo == 0U) {
    bfa_fcs_rport_send_logo_acc((void *)rport);
  } else {

  }
  tmp = bfa_fcs_lport_is_online(rport->port);
  if ((unsigned int )tmp != 0U && ((((rport->pid & 255U) << 16) | (rport->pid & 65280U)) | ((rport->pid & 16711680U) >> 16)) <= 16773120U) {
    if ((unsigned int )((rport->port)->fabric)->fab_type == 1U) {
      rport->sm = (void (*)(void * , int  ))(& bfa_fcs_rport_sm_nsdisc_sending);
      rport->ns_retries = 0;
      bfa_fcs_rport_send_nsdisc((void *)rport, (struct bfa_fcxp_s *)0);
    } else {
      rport->sm = (void (*)(void * , int  ))(& bfa_fcs_rport_sm_plogi_sending);
      rport->plogi_retries = 0;
      bfa_fcs_rport_send_plogi((void *)rport, (struct bfa_fcxp_s *)0);
    }
  } else {
    if (((((rport->pid & 255U) << 16) | (rport->pid & 65280U)) | ((rport->pid & 16711680U) >> 16)) <= 16773120U) {
      rport->pid = 0U;
    } else {

    }
    rport->sm = (void (*)(void * , int  ))(& bfa_fcs_rport_sm_offline);
    bfa_timer_begin(& ((rport->fcs)->bfa)->timer_mod, & rport->timer, & bfa_fcs_rport_timeout,
                    (void *)rport, bfa_fcs_rport_del_timeout);
  }
  goto ldv_49150;
  case 7U: 
  rport->sm = (void (*)(void * , int  ))(& bfa_fcs_rport_sm_delete_pending);
  if (rport->pid != 0U && (unsigned int )rport->prlo == 1U) {
    bfa_fcs_rport_send_prlo_acc(rport);
  } else {

  }
  if (rport->pid != 0U && (unsigned int )rport->prlo == 0U) {
    bfa_fcs_rport_send_logo_acc((void *)rport);
  } else {

  }
  goto ldv_49150;
  case 5U: 
  rport->sm = (void (*)(void * , int  ))(& bfa_fcs_rport_sm_hcb_offline);
  goto ldv_49150;
  case 20U: ;
  case 19U: ;
  case 4U: ;
  case 17U: ;
  goto ldv_49150;
  default: 
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 1280, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcs_rport.c",
         1280, (unsigned int )event);
  }
  ldv_49150: ;
  return;
}
}
static void bfa_fcs_rport_sm_hcb_logosend(struct bfa_fcs_rport_s *rport , enum rport_event event ) 
{ 


  {
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 1293, rport->pwwn);
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 1294, (unsigned long long )rport->pid);
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 1295, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 13U: 
  rport->sm = (void (*)(void * , int  ))(& bfa_fcs_rport_sm_logo_sending);
  bfa_fcs_rport_send_logo((void *)rport, (struct bfa_fcxp_s *)0);
  goto ldv_49163;
  case 4U: 
  bfa_fcs_rport_send_logo_acc((void *)rport);
  case 17U: ;
  if ((unsigned int )rport->prlo == 1U) {
    bfa_fcs_rport_send_prlo_acc(rport);
  } else {

  }
  rport->sm = (void (*)(void * , int  ))(& bfa_fcs_rport_sm_delete_pending);
  goto ldv_49163;
  case 20U: ;
  case 19U: ;
  case 15U: ;
  goto ldv_49163;
  default: 
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 1318, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcs_rport.c",
         1318, (unsigned int )event);
  }
  ldv_49163: ;
  return;
}
}
static void bfa_fcs_rport_sm_logo_sending(struct bfa_fcs_rport_s *rport , enum rport_event event ) 
{ 


  {
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 1329, rport->pwwn);
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 1330, (unsigned long long )rport->pid);
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 1331, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 6U: 
  rport->sm = (void (*)(void * , int  ))(& bfa_fcs_rport_sm_uninit);
  bfa_fcs_rport_free(rport);
  goto ldv_49175;
  case 20U: ;
  case 19U: ;
  case 8U: ;
  case 15U: ;
  goto ldv_49175;
  case 4U: 
  bfa_fcs_rport_send_logo_acc((void *)rport);
  case 17U: ;
  if ((unsigned int )rport->prlo == 1U) {
    bfa_fcs_rport_send_prlo_acc(rport);
  } else {

  }
  rport->sm = (void (*)(void * , int  ))(& bfa_fcs_rport_sm_uninit);
  bfa_fcxp_walloc_cancel((rport->fcs)->bfa, & rport->fcxp_wqe);
  bfa_fcs_rport_free(rport);
  goto ldv_49175;
  default: 
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 1358, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcs_rport.c",
         1358, (unsigned int )event);
  }
  ldv_49175: ;
  return;
}
}
static void bfa_fcs_rport_sm_offline(struct bfa_fcs_rport_s *rport , enum rport_event event ) 
{ 
  int __ret_warn_on ;
  enum bfa_port_topology tmp ;
  long tmp___0 ;

  {
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 1369, rport->pwwn);
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 1370, (unsigned long long )rport->pid);
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 1371, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 11U: 
  rport->sm = (void (*)(void * , int  ))(& bfa_fcs_rport_sm_uninit);
  bfa_fcs_rport_free(rport);
  goto ldv_49188;
  case 8U: ;
  case 15U: 
  bfa_timer_stop(& rport->timer);
  tmp = bfa_fcport_get_topology(((rport->port)->fcs)->bfa);
  __ret_warn_on = (unsigned int )tmp == 2U;
  tmp___0 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp___0 != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcs_rport.c",
                       1383);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  rport->sm = (void (*)(void * , int  ))(& bfa_fcs_rport_sm_nsdisc_sending);
  rport->ns_retries = 0;
  bfa_fcs_rport_send_nsdisc((void *)rport, (struct bfa_fcxp_s *)0);
  goto ldv_49188;
  case 7U: 
  rport->sm = (void (*)(void * , int  ))(& bfa_fcs_rport_sm_uninit);
  bfa_timer_stop(& rport->timer);
  bfa_fcs_rport_free(rport);
  goto ldv_49188;
  case 2U: 
  rport->sm = (void (*)(void * , int  ))(& bfa_fcs_rport_sm_plogiacc_sending);
  bfa_timer_stop(& rport->timer);
  bfa_fcs_rport_send_plogiacc((void *)rport, (struct bfa_fcxp_s *)0);
  goto ldv_49188;
  case 4U: ;
  case 17U: ;
  case 5U: ;
  case 19U: ;
  goto ldv_49188;
  case 3U: 
  rport->sm = (void (*)(void * , int  ))(& bfa_fcs_rport_sm_fc4_fcs_online);
  bfa_timer_stop(& rport->timer);
  bfa_fcs_rport_fcs_online_action(rport);
  goto ldv_49188;
  case 20U: 
  bfa_timer_stop(& rport->timer);
  rport->sm = (void (*)(void * , int  ))(& bfa_fcs_rport_sm_plogi_sending);
  bfa_fcs_rport_send_plogi((void *)rport, (struct bfa_fcxp_s *)0);
  goto ldv_49188;
  case 1U: 
  bfa_timer_stop(& rport->timer);
  rport->sm = (void (*)(void * , int  ))(& bfa_fcs_rport_sm_plogi_sending);
  rport->plogi_retries = 0;
  bfa_fcs_rport_send_plogi((void *)rport, (struct bfa_fcxp_s *)0);
  goto ldv_49188;
  default: 
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 1427, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcs_rport.c",
         1427, (unsigned int )event);
  }
  ldv_49188: ;
  return;
}
}
static void bfa_fcs_rport_sm_nsdisc_sending(struct bfa_fcs_rport_s *rport , enum rport_event event ) 
{ 


  {
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 1438, rport->pwwn);
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 1439, (unsigned long long )rport->pid);
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 1440, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 6U: 
  rport->sm = (void (*)(void * , int  ))(& bfa_fcs_rport_sm_nsdisc_sent);
  goto ldv_49208;
  case 7U: 
  rport->sm = (void (*)(void * , int  ))(& bfa_fcs_rport_sm_uninit);
  bfa_fcxp_walloc_cancel((rport->fcs)->bfa, & rport->fcxp_wqe);
  bfa_fcs_rport_free(rport);
  goto ldv_49208;
  case 2U: 
  rport->sm = (void (*)(void * , int  ))(& bfa_fcs_rport_sm_plogiacc_sending);
  bfa_fcxp_walloc_cancel((rport->fcs)->bfa, & rport->fcxp_wqe);
  bfa_fcs_rport_send_plogiacc((void *)rport, (struct bfa_fcxp_s *)0);
  goto ldv_49208;
  case 8U: ;
  case 4U: ;
  case 17U: ;
  case 1U: ;
  goto ldv_49208;
  case 15U: 
  rport->ns_retries = 0;
  goto ldv_49208;
  case 5U: 
  rport->sm = (void (*)(void * , int  ))(& bfa_fcs_rport_sm_offline);
  bfa_fcxp_walloc_cancel((rport->fcs)->bfa, & rport->fcxp_wqe);
  bfa_timer_begin(& ((rport->fcs)->bfa)->timer_mod, & rport->timer, & bfa_fcs_rport_timeout,
                  (void *)rport, bfa_fcs_rport_del_timeout);
  goto ldv_49208;
  case 3U: 
  rport->sm = (void (*)(void * , int  ))(& bfa_fcs_rport_sm_fc4_fcs_online);
  bfa_fcxp_walloc_cancel((rport->fcs)->bfa, & rport->fcxp_wqe);
  bfa_fcs_rport_fcs_online_action(rport);
  goto ldv_49208;
  default: 
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 1484, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcs_rport.c",
         1484, (unsigned int )event);
  }
  ldv_49208: ;
  return;
}
}
static void bfa_fcs_rport_sm_nsdisc_retry(struct bfa_fcs_rport_s *rport , enum rport_event event ) 
{ 


  {
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 1495, rport->pwwn);
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 1496, (unsigned long long )rport->pid);
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 1497, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 11U: 
  rport->sm = (void (*)(void * , int  ))(& bfa_fcs_rport_sm_nsdisc_sending);
  bfa_fcs_rport_send_nsdisc((void *)rport, (struct bfa_fcxp_s *)0);
  goto ldv_49224;
  case 8U: ;
  case 15U: 
  rport->sm = (void (*)(void * , int  ))(& bfa_fcs_rport_sm_nsdisc_sending);
  bfa_timer_stop(& rport->timer);
  rport->ns_retries = 0;
  bfa_fcs_rport_send_nsdisc((void *)rport, (struct bfa_fcxp_s *)0);
  goto ldv_49224;
  case 7U: 
  rport->sm = (void (*)(void * , int  ))(& bfa_fcs_rport_sm_uninit);
  bfa_timer_stop(& rport->timer);
  bfa_fcs_rport_free(rport);
  goto ldv_49224;
  case 2U: 
  rport->sm = (void (*)(void * , int  ))(& bfa_fcs_rport_sm_plogiacc_sending);
  bfa_timer_stop(& rport->timer);
  bfa_fcs_rport_send_plogiacc((void *)rport, (struct bfa_fcxp_s *)0);
  goto ldv_49224;
  case 5U: 
  rport->pid = 0U;
  rport->sm = (void (*)(void * , int  ))(& bfa_fcs_rport_sm_offline);
  bfa_timer_stop(& rport->timer);
  bfa_timer_begin(& ((rport->fcs)->bfa)->timer_mod, & rport->timer, & bfa_fcs_rport_timeout,
                  (void *)rport, bfa_fcs_rport_del_timeout);
  goto ldv_49224;
  case 4U: 
  bfa_fcs_rport_send_logo_acc((void *)rport);
  goto ldv_49224;
  case 17U: 
  bfa_fcs_rport_send_prlo_acc(rport);
  goto ldv_49224;
  case 3U: 
  rport->sm = (void (*)(void * , int  ))(& bfa_fcs_rport_sm_fc4_fcs_online);
  bfa_timer_stop(& rport->timer);
  bfa_fcs_rport_fcs_online_action(rport);
  goto ldv_49224;
  default: 
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 1548, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcs_rport.c",
         1548, (unsigned int )event);
  }
  ldv_49224: ;
  return;
}
}
static void bfa_fcs_rport_sm_nsdisc_sent(struct bfa_fcs_rport_s *rport , enum rport_event event ) 
{ 


  {
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 1559, rport->pwwn);
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 1560, (unsigned long long )rport->pid);
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 1561, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 9U: ;
  case 15U: ;
  if (rport->pid != 0U) {
    rport->sm = (void (*)(void * , int  ))(& bfa_fcs_rport_sm_plogi_sending);
    bfa_fcs_rport_send_plogi((void *)rport, (struct bfa_fcxp_s *)0);
  } else {
    rport->sm = (void (*)(void * , int  ))(& bfa_fcs_rport_sm_nsdisc_sending);
    rport->ns_retries = 0;
    bfa_fcs_rport_send_nsdisc((void *)rport, (struct bfa_fcxp_s *)0);
  }
  goto ldv_49240;
  case 10U: 
  rport->ns_retries = rport->ns_retries + 1;
  if (rport->ns_retries <= 4) {
    rport->sm = (void (*)(void * , int  ))(& bfa_fcs_rport_sm_nsdisc_sending);
    bfa_fcs_rport_send_nsdisc((void *)rport, (struct bfa_fcxp_s *)0);
  } else {
    rport->old_pid = rport->pid;
    rport->pid = 0U;
    rport->sm = (void (*)(void * , int  ))(& bfa_fcs_rport_sm_offline);
    bfa_timer_begin(& ((rport->fcs)->bfa)->timer_mod, & rport->timer, & bfa_fcs_rport_timeout,
                    (void *)rport, bfa_fcs_rport_del_timeout);
  }
  goto ldv_49240;
  case 7U: 
  rport->sm = (void (*)(void * , int  ))(& bfa_fcs_rport_sm_uninit);
  bfa_fcxp_discard(rport->fcxp);
  bfa_fcs_rport_free(rport);
  goto ldv_49240;
  case 2U: 
  rport->sm = (void (*)(void * , int  ))(& bfa_fcs_rport_sm_plogiacc_sending);
  bfa_fcxp_discard(rport->fcxp);
  bfa_fcs_rport_send_plogiacc((void *)rport, (struct bfa_fcxp_s *)0);
  goto ldv_49240;
  case 5U: 
  rport->pid = 0U;
  rport->sm = (void (*)(void * , int  ))(& bfa_fcs_rport_sm_offline);
  bfa_fcxp_discard(rport->fcxp);
  bfa_timer_begin(& ((rport->fcs)->bfa)->timer_mod, & rport->timer, & bfa_fcs_rport_timeout,
                  (void *)rport, bfa_fcs_rport_del_timeout);
  goto ldv_49240;
  case 17U: 
  bfa_fcs_rport_send_prlo_acc(rport);
  goto ldv_49240;
  case 8U: ;
  goto ldv_49240;
  case 4U: 
  bfa_fcs_rport_send_logo_acc((void *)rport);
  goto ldv_49240;
  case 3U: 
  rport->sm = (void (*)(void * , int  ))(& bfa_fcs_rport_sm_fc4_fcs_online);
  bfa_fcxp_discard(rport->fcxp);
  bfa_fcs_rport_fcs_online_action(rport);
  goto ldv_49240;
  default: 
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 1638, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcs_rport.c",
         1638, (unsigned int )event);
  }
  ldv_49240: ;
  return;
}
}
static void bfa_fcs_rport_sm_fc4_off_delete(struct bfa_fcs_rport_s *rport , enum rport_event event ) 
{ 


  {
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 1650, rport->pwwn);
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 1651, (unsigned long long )rport->pid);
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 1652, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 14U: 
  rport->sm = (void (*)(void * , int  ))(& bfa_fcs_rport_sm_delete_pending);
  bfa_fcs_rport_hal_offline(rport);
  goto ldv_49255;
  case 7U: ;
  case 2U: ;
  goto ldv_49255;
  default: 
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 1666, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcs_rport.c",
         1666, (unsigned int )event);
  goto ldv_49255;
  }
  ldv_49255: ;
  return;
}
}
static void bfa_fcs_rport_sm_delete_pending(struct bfa_fcs_rport_s *rport , enum rport_event event ) 
{ 


  {
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 1679, rport->pwwn);
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 1680, (unsigned long long )rport->pid);
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 1681, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 13U: 
  rport->sm = (void (*)(void * , int  ))(& bfa_fcs_rport_sm_uninit);
  bfa_fcs_rport_free(rport);
  goto ldv_49264;
  case 7U: ;
  case 5U: ;
  case 2U: ;
  goto ldv_49264;
  default: 
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 1696, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcs_rport.c",
         1696, (unsigned int )event);
  }
  ldv_49264: ;
  return;
}
}
static void bfa_fcs_rport_send_plogi(void *rport_cbarg , struct bfa_fcxp_s *fcxp_alloced ) 
{ 
  struct bfa_fcs_rport_s *rport ;
  struct bfa_fcs_lport_s *port ;
  struct fchs_s fchs ;
  int len ;
  struct bfa_fcxp_s *fcxp ;
  struct bfa_fcxp_s *tmp ;
  u8 tmp___0 ;
  u16 tmp___1 ;
  void *tmp___2 ;
  u16 tmp___3 ;

  {
  rport = (struct bfa_fcs_rport_s *)rport_cbarg;
  port = rport->port;
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 1713, rport->pwwn);
  if ((unsigned long )fcxp_alloced == (unsigned long )((struct bfa_fcxp_s *)0)) {
    tmp = bfa_fcxp_req_rsp_alloc((void *)0, (port->fcs)->bfa, 0, 0, (u64 (*)(void * ,
                                                                             int  ))0,
                                 (u32 (*)(void * , int  ))0, (u64 (*)(void * , int  ))0,
                                 (u32 (*)(void * , int  ))0, 1);
    fcxp = tmp;
  } else {
    fcxp = fcxp_alloced;
  }
  if ((unsigned long )fcxp == (unsigned long )((struct bfa_fcxp_s *)0)) {
    bfa_fcxp_req_rsp_alloc_wait((port->fcs)->bfa, & rport->fcxp_wqe, & bfa_fcs_rport_send_plogi,
                                (void *)rport, (void *)0, 0, 0, (u64 (*)(void * ,
                                                                         int  ))0,
                                (u32 (*)(void * , int  ))0, (u64 (*)(void * , int  ))0,
                                (u32 (*)(void * , int  ))0, 1);
    return;
  } else {

  }
  rport->fcxp = fcxp;
  tmp___0 = bfa_fcport_get_rx_bbcredit((port->fcs)->bfa);
  tmp___1 = bfa_fcport_get_maxfrsize((port->fcs)->bfa);
  tmp___2 = bfa_fcxp_get_reqbuf(fcxp);
  tmp___3 = fc_plogi_build(& fchs, tmp___2, rport->pid, port->pid, 0, port->port_cfg.pwwn,
                           port->port_cfg.nwwn, (int )tmp___1, (int )tmp___0);
  len = (int )tmp___3;
  bfa_fcxp_send(fcxp, (struct bfa_rport_s *)0, (int )(port->fabric)->vf_id, (int )port->lp_tag,
                0, 8, (u32 )len, & fchs, & bfa_fcs_rport_plogi_response, (void *)rport,
                2112U, 20);
  rport->stats.plogis = rport->stats.plogis + 1U;
  (*(rport->sm))((void *)rport, 6);
  return;
}
}
static void bfa_fcs_rport_plogi_response(void *fcsarg , struct bfa_fcxp_s *fcxp ,
                                         void *cbarg , enum bfa_status req_status ,
                                         u32 rsp_len , u32 resid_len , struct fchs_s *rsp_fchs ) 
{ 
  struct bfa_fcs_rport_s *rport ;
  struct fc_logi_s *plogi_rsp ;
  struct fc_ls_rjt_s *ls_rjt ;
  struct bfa_fcs_rport_s *twin ;
  struct list_head *qe ;
  void *tmp ;
  void *tmp___0 ;

  {
  rport = (struct bfa_fcs_rport_s *)cbarg;
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 1749, rport->pwwn);
  if ((unsigned int )req_status != 0U) {
    __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 1755, (unsigned long long )req_status);
    rport->stats.plogi_failed = rport->stats.plogi_failed + 1U;
    (*(rport->sm))((void *)rport, 10);
    return;
  } else {

  }
  tmp = bfa_fcxp_get_rspbuf(fcxp);
  plogi_rsp = (struct fc_logi_s *)tmp;
  if ((unsigned int )plogi_rsp->els_cmd.els_code != 2U) {
    tmp___0 = bfa_fcxp_get_rspbuf(fcxp);
    ls_rjt = (struct fc_ls_rjt_s *)tmp___0;
    __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 1769, (unsigned long long )ls_rjt->reason_code);
    __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 1770, (unsigned long long )ls_rjt->reason_code_expl);
    if ((unsigned int )ls_rjt->reason_code == 9U && (unsigned int )ls_rjt->reason_code_expl == 41U) {
      rport->stats.rjt_insuff_res = rport->stats.rjt_insuff_res + 1U;
      (*(rport->sm))((void *)rport, 18);
      return;
    } else {

    }
    rport->stats.plogi_rejects = rport->stats.plogi_rejects + 1U;
    (*(rport->sm))((void *)rport, 10);
    return;
  } else {

  }
  qe = (rport->port)->rport_q.next;
  goto ldv_49294;
  ldv_49293: 
  twin = (struct bfa_fcs_rport_s *)qe;
  if ((unsigned long )twin == (unsigned long )rport) {
    goto ldv_49292;
  } else {

  }
  if (rport->pwwn == 0ULL && plogi_rsp->port_name == twin->pwwn) {
    __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 1793, (unsigned long long )twin->pid);
    __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 1794, (unsigned long long )rport->pid);
    twin->stats.plogis = twin->stats.plogis + rport->stats.plogis;
    twin->stats.plogi_rejects = twin->stats.plogi_rejects + rport->stats.plogi_rejects;
    twin->stats.plogi_timeouts = twin->stats.plogi_timeouts + rport->stats.plogi_timeouts;
    twin->stats.plogi_failed = twin->stats.plogi_failed + rport->stats.plogi_failed;
    twin->stats.plogi_rcvd = twin->stats.plogi_rcvd + rport->stats.plogi_rcvd;
    twin->stats.plogi_accs = twin->stats.plogi_accs + 1U;
    (*(rport->sm))((void *)rport, 7);
    bfa_fcs_rport_update(twin, plogi_rsp);
    twin->pid = rsp_fchs->s_id;
    (*(twin->sm))((void *)twin, 3);
    return;
  } else {

  }
  ldv_49292: 
  qe = qe->next;
  ldv_49294: ;
  if ((unsigned long )(& (rport->port)->rport_q) != (unsigned long )qe) {
    goto ldv_49293;
  } else {

  }
  rport->stats.plogi_accs = rport->stats.plogi_accs + 1U;
  bfa_fcs_rport_update(rport, plogi_rsp);
  (*(rport->sm))((void *)rport, 9);
  return;
}
}
static void bfa_fcs_rport_send_plogiacc(void *rport_cbarg , struct bfa_fcxp_s *fcxp_alloced ) 
{ 
  struct bfa_fcs_rport_s *rport ;
  struct bfa_fcs_lport_s *port ;
  struct fchs_s fchs ;
  int len ;
  struct bfa_fcxp_s *fcxp ;
  struct bfa_fcxp_s *tmp ;
  u8 tmp___0 ;
  u16 tmp___1 ;
  void *tmp___2 ;
  u16 tmp___3 ;

  {
  rport = (struct bfa_fcs_rport_s *)rport_cbarg;
  port = rport->port;
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 1833, rport->pwwn);
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 1834, (unsigned long long )rport->reply_oxid);
  if ((unsigned long )fcxp_alloced == (unsigned long )((struct bfa_fcxp_s *)0)) {
    tmp = bfa_fcxp_req_rsp_alloc((void *)0, (port->fcs)->bfa, 0, 0, (u64 (*)(void * ,
                                                                             int  ))0,
                                 (u32 (*)(void * , int  ))0, (u64 (*)(void * , int  ))0,
                                 (u32 (*)(void * , int  ))0, 0);
    fcxp = tmp;
  } else {
    fcxp = fcxp_alloced;
  }
  if ((unsigned long )fcxp == (unsigned long )((struct bfa_fcxp_s *)0)) {
    bfa_fcxp_req_rsp_alloc_wait((port->fcs)->bfa, & rport->fcxp_wqe, & bfa_fcs_rport_send_plogiacc,
                                (void *)rport, (void *)0, 0, 0, (u64 (*)(void * ,
                                                                         int  ))0,
                                (u32 (*)(void * , int  ))0, (u64 (*)(void * , int  ))0,
                                (u32 (*)(void * , int  ))0, 0);
    return;
  } else {

  }
  rport->fcxp = fcxp;
  tmp___0 = bfa_fcport_get_rx_bbcredit((port->fcs)->bfa);
  tmp___1 = bfa_fcport_get_maxfrsize((port->fcs)->bfa);
  tmp___2 = bfa_fcxp_get_reqbuf(fcxp);
  tmp___3 = fc_plogi_acc_build(& fchs, tmp___2, rport->pid, port->pid, (int )rport->reply_oxid,
                               port->port_cfg.pwwn, port->port_cfg.nwwn, (int )tmp___1,
                               (int )tmp___0);
  len = (int )tmp___3;
  bfa_fcxp_send(fcxp, (struct bfa_rport_s *)0, (int )(port->fabric)->vf_id, (int )port->lp_tag,
                0, 8, (u32 )len, & fchs, (void (*)(void * , struct bfa_fcxp_s * ,
                                                   void * , enum bfa_status  , u32  ,
                                                   u32  , struct fchs_s * ))0, (void *)0,
                2112U, 0);
  (*(rport->sm))((void *)rport, 6);
  return;
}
}
static void bfa_fcs_rport_send_adisc(void *rport_cbarg , struct bfa_fcxp_s *fcxp_alloced ) 
{ 
  struct bfa_fcs_rport_s *rport ;
  struct bfa_fcs_lport_s *port ;
  struct fchs_s fchs ;
  int len ;
  struct bfa_fcxp_s *fcxp ;
  struct bfa_fcxp_s *tmp ;
  void *tmp___0 ;
  u16 tmp___1 ;

  {
  rport = (struct bfa_fcs_rport_s *)rport_cbarg;
  port = rport->port;
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 1867, rport->pwwn);
  if ((unsigned long )fcxp_alloced == (unsigned long )((struct bfa_fcxp_s *)0)) {
    tmp = bfa_fcxp_req_rsp_alloc((void *)0, (port->fcs)->bfa, 0, 0, (u64 (*)(void * ,
                                                                             int  ))0,
                                 (u32 (*)(void * , int  ))0, (u64 (*)(void * , int  ))0,
                                 (u32 (*)(void * , int  ))0, 1);
    fcxp = tmp;
  } else {
    fcxp = fcxp_alloced;
  }
  if ((unsigned long )fcxp == (unsigned long )((struct bfa_fcxp_s *)0)) {
    bfa_fcxp_req_rsp_alloc_wait((port->fcs)->bfa, & rport->fcxp_wqe, & bfa_fcs_rport_send_adisc,
                                (void *)rport, (void *)0, 0, 0, (u64 (*)(void * ,
                                                                         int  ))0,
                                (u32 (*)(void * , int  ))0, (u64 (*)(void * , int  ))0,
                                (u32 (*)(void * , int  ))0, 1);
    return;
  } else {

  }
  rport->fcxp = fcxp;
  tmp___0 = bfa_fcxp_get_reqbuf(fcxp);
  tmp___1 = fc_adisc_build(& fchs, (struct fc_adisc_s *)tmp___0, rport->pid, port->pid,
                           0, port->port_cfg.pwwn, port->port_cfg.nwwn);
  len = (int )tmp___1;
  bfa_fcxp_send(fcxp, (struct bfa_rport_s *)0, (int )(port->fabric)->vf_id, (int )port->lp_tag,
                0, 8, (u32 )len, & fchs, & bfa_fcs_rport_adisc_response, (void *)rport,
                2112U, 20);
  rport->stats.adisc_sent = rport->stats.adisc_sent + 1U;
  (*(rport->sm))((void *)rport, 6);
  return;
}
}
static void bfa_fcs_rport_adisc_response(void *fcsarg , struct bfa_fcxp_s *fcxp ,
                                         void *cbarg , enum bfa_status req_status ,
                                         u32 rsp_len , u32 resid_len , struct fchs_s *rsp_fchs ) 
{ 
  struct bfa_fcs_rport_s *rport ;
  void *pld ;
  void *tmp ;
  struct fc_ls_rjt_s *ls_rjt ;
  enum fc_parse_status tmp___0 ;

  {
  rport = (struct bfa_fcs_rport_s *)cbarg;
  tmp = bfa_fcxp_get_rspbuf(fcxp);
  pld = tmp;
  if ((unsigned int )req_status != 0U) {
    __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 1900, (unsigned long long )req_status);
    rport->stats.adisc_failed = rport->stats.adisc_failed + 1U;
    (*(rport->sm))((void *)rport, 10);
    return;
  } else {

  }
  tmp___0 = fc_adisc_rsp_parse((struct fc_adisc_s *)pld, (int )rsp_len, rport->pwwn,
                               rport->nwwn);
  if ((unsigned int )tmp___0 == 0U) {
    rport->stats.adisc_accs = rport->stats.adisc_accs + 1U;
    (*(rport->sm))((void *)rport, 9);
    return;
  } else {

  }
  rport->stats.adisc_rejects = rport->stats.adisc_rejects + 1U;
  ls_rjt = (struct fc_ls_rjt_s *)pld;
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 1915, (unsigned long long )ls_rjt->els_cmd.els_code);
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 1916, (unsigned long long )ls_rjt->reason_code);
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 1917, (unsigned long long )ls_rjt->reason_code_expl);
  (*(rport->sm))((void *)rport, 10);
  return;
}
}
static void bfa_fcs_rport_send_nsdisc(void *rport_cbarg , struct bfa_fcxp_s *fcxp_alloced ) 
{ 
  struct bfa_fcs_rport_s *rport ;
  struct bfa_fcs_lport_s *port ;
  struct fchs_s fchs ;
  struct bfa_fcxp_s *fcxp ;
  int len ;
  void (*cbfn)(void * , struct bfa_fcxp_s * , void * , enum bfa_status  , u32  , u32  ,
               struct fchs_s * ) ;
  struct bfa_fcxp_s *tmp ;
  void *tmp___0 ;
  u16 tmp___1 ;
  void *tmp___2 ;
  u16 tmp___3 ;

  {
  rport = (struct bfa_fcs_rport_s *)rport_cbarg;
  port = rport->port;
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 1931, (unsigned long long )rport->pid);
  if ((unsigned long )fcxp_alloced == (unsigned long )((struct bfa_fcxp_s *)0)) {
    tmp = bfa_fcxp_req_rsp_alloc((void *)0, (port->fcs)->bfa, 0, 0, (u64 (*)(void * ,
                                                                             int  ))0,
                                 (u32 (*)(void * , int  ))0, (u64 (*)(void * , int  ))0,
                                 (u32 (*)(void * , int  ))0, 1);
    fcxp = tmp;
  } else {
    fcxp = fcxp_alloced;
  }
  if ((unsigned long )fcxp == (unsigned long )((struct bfa_fcxp_s *)0)) {
    bfa_fcxp_req_rsp_alloc_wait((port->fcs)->bfa, & rport->fcxp_wqe, & bfa_fcs_rport_send_nsdisc,
                                (void *)rport, (void *)0, 0, 0, (u64 (*)(void * ,
                                                                         int  ))0,
                                (u32 (*)(void * , int  ))0, (u64 (*)(void * , int  ))0,
                                (u32 (*)(void * , int  ))0, 1);
    return;
  } else {

  }
  rport->fcxp = fcxp;
  if (rport->pwwn != 0ULL) {
    tmp___0 = bfa_fcxp_get_reqbuf(fcxp);
    tmp___1 = fc_gidpn_build(& fchs, tmp___0, port->pid, 0, rport->pwwn);
    len = (int )tmp___1;
    cbfn = & bfa_fcs_rport_gidpn_response;
  } else {
    tmp___2 = bfa_fcxp_get_reqbuf(fcxp);
    tmp___3 = fc_gpnid_build(& fchs, tmp___2, port->pid, 0, rport->pid);
    len = (int )tmp___3;
    cbfn = & bfa_fcs_rport_gpnid_response;
  }
  bfa_fcxp_send(fcxp, (struct bfa_rport_s *)0, (int )(port->fabric)->vf_id, (int )port->lp_tag,
                0, 8, (u32 )len, & fchs, cbfn, (void *)rport, 2112U, 30);
  (*(rport->sm))((void *)rport, 6);
  return;
}
}
static void bfa_fcs_rport_gidpn_response(void *fcsarg , struct bfa_fcxp_s *fcxp ,
                                         void *cbarg , enum bfa_status req_status ,
                                         u32 rsp_len , u32 resid_len , struct fchs_s *rsp_fchs ) 
{ 
  struct bfa_fcs_rport_s *rport ;
  struct ct_hdr_s *cthdr ;
  struct fcgs_gidpn_resp_s *gidpn_rsp ;
  struct bfa_fcs_rport_s *twin ;
  struct list_head *qe ;
  void *tmp ;
  __u16 tmp___0 ;

  {
  rport = (struct bfa_fcs_rport_s *)cbarg;
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 1970, rport->pwwn);
  tmp = bfa_fcxp_get_rspbuf(fcxp);
  cthdr = (struct ct_hdr_s *)tmp;
  tmp___0 = __fswab16((int )cthdr->cmd_rsp_code);
  cthdr->cmd_rsp_code = tmp___0;
  if ((unsigned int )cthdr->cmd_rsp_code == 32770U) {
    gidpn_rsp = (struct fcgs_gidpn_resp_s *)cthdr + 1U;
    if (gidpn_rsp->dap == rport->pid) {
      (*(rport->sm))((void *)rport, 9);
    } else {
      qe = (rport->port)->rport_q.next;
      goto ldv_49352;
      ldv_49351: 
      twin = (struct bfa_fcs_rport_s *)qe;
      if ((unsigned long )twin == (unsigned long )rport) {
        goto ldv_49350;
      } else {

      }
      if (gidpn_rsp->dap == twin->pid) {
        __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 1994, (unsigned long long )twin->pid);
        __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 1995, (unsigned long long )rport->pid);
        twin->pid = 0U;
        (*(twin->sm))((void *)twin, 15);
      } else {

      }
      ldv_49350: 
      qe = qe->next;
      ldv_49352: ;
      if ((unsigned long )(& (rport->port)->rport_q) != (unsigned long )qe) {
        goto ldv_49351;
      } else {

      }
      rport->pid = gidpn_rsp->dap;
      (*(rport->sm))((void *)rport, 15);
    }
    return;
  } else {

  }
  switch ((int )cthdr->reason_code) {
  case 5: 
  (*(rport->sm))((void *)rport, 11);
  goto ldv_49355;
  case 9: 
  (*(rport->sm))((void *)rport, 10);
  goto ldv_49355;
  default: 
  (*(rport->sm))((void *)rport, 10);
  goto ldv_49355;
  }
  ldv_49355: ;
  return;
}
}
static void bfa_fcs_rport_gpnid_response(void *fcsarg , struct bfa_fcxp_s *fcxp ,
                                         void *cbarg , enum bfa_status req_status ,
                                         u32 rsp_len , u32 resid_len , struct fchs_s *rsp_fchs ) 
{ 
  struct bfa_fcs_rport_s *rport ;
  struct ct_hdr_s *cthdr ;
  void *tmp ;
  __u16 tmp___0 ;

  {
  rport = (struct bfa_fcs_rport_s *)cbarg;
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 2040, rport->pwwn);
  tmp = bfa_fcxp_get_rspbuf(fcxp);
  cthdr = (struct ct_hdr_s *)tmp;
  tmp___0 = __fswab16((int )cthdr->cmd_rsp_code);
  cthdr->cmd_rsp_code = tmp___0;
  if ((unsigned int )cthdr->cmd_rsp_code == 32770U) {
    (*(rport->sm))((void *)rport, 9);
    return;
  } else {

  }
  switch ((int )cthdr->reason_code) {
  case 5: 
  (*(rport->sm))((void *)rport, 11);
  goto ldv_49370;
  case 9: 
  (*(rport->sm))((void *)rport, 10);
  goto ldv_49370;
  default: 
  (*(rport->sm))((void *)rport, 10);
  goto ldv_49370;
  }
  ldv_49370: ;
  return;
}
}
static void bfa_fcs_rport_send_logo(void *rport_cbarg , struct bfa_fcxp_s *fcxp_alloced ) 
{ 
  struct bfa_fcs_rport_s *rport ;
  struct bfa_fcs_lport_s *port ;
  struct fchs_s fchs ;
  struct bfa_fcxp_s *fcxp ;
  u16 len ;
  struct bfa_fcxp_s *tmp ;
  void *tmp___0 ;

  {
  rport = (struct bfa_fcs_rport_s *)rport_cbarg;
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 2086, (unsigned long long )rport->pid);
  port = rport->port;
  if ((unsigned long )fcxp_alloced == (unsigned long )((struct bfa_fcxp_s *)0)) {
    tmp = bfa_fcxp_req_rsp_alloc((void *)0, (port->fcs)->bfa, 0, 0, (u64 (*)(void * ,
                                                                             int  ))0,
                                 (u32 (*)(void * , int  ))0, (u64 (*)(void * , int  ))0,
                                 (u32 (*)(void * , int  ))0, 0);
    fcxp = tmp;
  } else {
    fcxp = fcxp_alloced;
  }
  if ((unsigned long )fcxp == (unsigned long )((struct bfa_fcxp_s *)0)) {
    bfa_fcxp_req_rsp_alloc_wait((port->fcs)->bfa, & rport->fcxp_wqe, & bfa_fcs_rport_send_logo,
                                (void *)rport, (void *)0, 0, 0, (u64 (*)(void * ,
                                                                         int  ))0,
                                (u32 (*)(void * , int  ))0, (u64 (*)(void * , int  ))0,
                                (u32 (*)(void * , int  ))0, 0);
    return;
  } else {

  }
  rport->fcxp = fcxp;
  tmp___0 = bfa_fcxp_get_reqbuf(fcxp);
  len = fc_logo_build(& fchs, (struct fc_logo_s *)tmp___0, rport->pid, port->pid,
                      0, port->port_cfg.pwwn);
  bfa_fcxp_send(fcxp, (struct bfa_rport_s *)0, (int )(port->fabric)->vf_id, (int )port->lp_tag,
                0, 8, (u32 )len, & fchs, (void (*)(void * , struct bfa_fcxp_s * ,
                                                   void * , enum bfa_status  , u32  ,
                                                   u32  , struct fchs_s * ))0, (void *)rport,
                2112U, 20);
  rport->stats.logos = rport->stats.logos + 1U;
  bfa_fcxp_discard(rport->fcxp);
  (*(rport->sm))((void *)rport, 6);
  return;
}
}
static void bfa_fcs_rport_send_logo_acc(void *rport_cbarg ) 
{ 
  struct bfa_fcs_rport_s *rport ;
  struct bfa_fcs_lport_s *port ;
  struct fchs_s fchs ;
  struct bfa_fcxp_s *fcxp ;
  u16 len ;
  void *tmp ;

  {
  rport = (struct bfa_fcs_rport_s *)rport_cbarg;
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 2124, (unsigned long long )rport->pid);
  port = rport->port;
  fcxp = bfa_fcxp_req_rsp_alloc((void *)0, (port->fcs)->bfa, 0, 0, (u64 (*)(void * ,
                                                                            int  ))0,
                                (u32 (*)(void * , int  ))0, (u64 (*)(void * , int  ))0,
                                (u32 (*)(void * , int  ))0, 0);
  if ((unsigned long )fcxp == (unsigned long )((struct bfa_fcxp_s *)0)) {
    return;
  } else {

  }
  rport->stats.logo_rcvd = rport->stats.logo_rcvd + 1U;
  tmp = bfa_fcxp_get_reqbuf(fcxp);
  len = fc_logo_acc_build(& fchs, tmp, rport->pid, port->pid, (int )rport->reply_oxid);
  bfa_fcxp_send(fcxp, (struct bfa_rport_s *)0, (int )(port->fabric)->vf_id, (int )port->lp_tag,
                0, 8, (u32 )len, & fchs, (void (*)(void * , struct bfa_fcxp_s * ,
                                                   void * , enum bfa_status  , u32  ,
                                                   u32  , struct fchs_s * ))0, (void *)0,
                2112U, 0);
  return;
}
}
static void bfa_fcs_rport_timeout(void *arg ) 
{ 
  struct bfa_fcs_rport_s *rport ;

  {
  rport = (struct bfa_fcs_rport_s *)arg;
  rport->stats.plogi_timeouts = rport->stats.plogi_timeouts + 1U;
  (rport->port)->stats.rport_plogi_timeouts = (rport->port)->stats.rport_plogi_timeouts + 1U;
  (*(rport->sm))((void *)rport, 11);
  return;
}
}
static void bfa_fcs_rport_process_prli(struct bfa_fcs_rport_s *rport , struct fchs_s *rx_fchs ,
                                       u16 len ) 
{ 
  struct bfa_fcxp_s *fcxp ;
  struct fchs_s fchs ;
  struct bfa_fcs_lport_s *port ;
  struct fc_prli_s *prli ;
  void *tmp ;

  {
  port = rport->port;
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___8, 2174, (unsigned long long )rx_fchs->s_id);
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___8, 2175, (unsigned long long )rx_fchs->d_id);
  rport->stats.prli_rcvd = rport->stats.prli_rcvd + 1U;
  prli = (struct fc_prli_s *)rx_fchs + 1U;
  if ((unsigned int )*((unsigned char *)prli + 19UL) != 0U) {
    __bfa_trc((port->fcs)->trcmod, __trc_fileno___8, 2191, (unsigned long long )rx_fchs->s_id);
    rport->scsi_function = 2;
  } else {
    __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 2194, (unsigned long long )prli->parampage.type);
    rport->scsi_function = 1;
    bfa_fcs_itnim_is_initiator(rport->itnim);
  }
  fcxp = bfa_fcxp_req_rsp_alloc((void *)0, (port->fcs)->bfa, 0, 0, (u64 (*)(void * ,
                                                                            int  ))0,
                                (u32 (*)(void * , int  ))0, (u64 (*)(void * , int  ))0,
                                (u32 (*)(void * , int  ))0, 0);
  if ((unsigned long )fcxp == (unsigned long )((struct bfa_fcxp_s *)0)) {
    return;
  } else {

  }
  tmp = bfa_fcxp_get_reqbuf(fcxp);
  len = fc_prli_acc_build(& fchs, tmp, rx_fchs->s_id, port->pid, (int )rx_fchs->ox_id,
                          port->port_cfg.roles);
  bfa_fcxp_send(fcxp, (struct bfa_rport_s *)0, (int )(port->fabric)->vf_id, (int )port->lp_tag,
                0, 8, (u32 )len, & fchs, (void (*)(void * , struct bfa_fcxp_s * ,
                                                   void * , enum bfa_status  , u32  ,
                                                   u32  , struct fchs_s * ))0, (void *)0,
                2112U, 0);
  return;
}
}
static void bfa_fcs_rport_process_rpsc(struct bfa_fcs_rport_s *rport , struct fchs_s *rx_fchs ,
                                       u16 len ) 
{ 
  struct bfa_fcxp_s *fcxp ;
  struct fchs_s fchs ;
  struct bfa_fcs_lport_s *port ;
  struct fc_rpsc_speed_info_s speeds ;
  struct bfa_port_attr_s pport_attr ;
  enum fc_rpsc_op_speed tmp ;
  void *tmp___0 ;

  {
  port = rport->port;
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___8, 2221, (unsigned long long )rx_fchs->s_id);
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___8, 2222, (unsigned long long )rx_fchs->d_id);
  rport->stats.rpsc_rcvd = rport->stats.rpsc_rcvd + 1U;
  speeds.port_speed_cap = 59392U;
  bfa_fcport_get_attr((port->fcs)->bfa, & pport_attr);
  tmp = fc_bfa_speed_to_rpsc_operspeed(pport_attr.speed);
  speeds.port_op_speed = (__be16 )tmp;
  fcxp = bfa_fcxp_req_rsp_alloc((void *)0, (port->fcs)->bfa, 0, 0, (u64 (*)(void * ,
                                                                            int  ))0,
                                (u32 (*)(void * , int  ))0, (u64 (*)(void * , int  ))0,
                                (u32 (*)(void * , int  ))0, 0);
  if ((unsigned long )fcxp == (unsigned long )((struct bfa_fcxp_s *)0)) {
    return;
  } else {

  }
  tmp___0 = bfa_fcxp_get_reqbuf(fcxp);
  len = fc_rpsc_acc_build(& fchs, (struct fc_rpsc_acc_s *)tmp___0, rx_fchs->s_id,
                          port->pid, (int )rx_fchs->ox_id, & speeds);
  bfa_fcxp_send(fcxp, (struct bfa_rport_s *)0, (int )(port->fabric)->vf_id, (int )port->lp_tag,
                0, 8, (u32 )len, & fchs, (void (*)(void * , struct bfa_fcxp_s * ,
                                                   void * , enum bfa_status  , u32  ,
                                                   u32  , struct fchs_s * ))0, (void *)0,
                2112U, 0);
  return;
}
}
static void bfa_fcs_rport_process_adisc(struct bfa_fcs_rport_s *rport , struct fchs_s *rx_fchs ,
                                        u16 len ) 
{ 
  struct bfa_fcxp_s *fcxp ;
  struct fchs_s fchs ;
  struct bfa_fcs_lport_s *port ;
  struct fc_adisc_s *adisc ;
  void *tmp ;
  enum bfa_status tmp___0 ;

  {
  port = rport->port;
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___8, 2257, (unsigned long long )rx_fchs->s_id);
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___8, 2258, (unsigned long long )rx_fchs->d_id);
  rport->stats.adisc_rcvd = rport->stats.adisc_rcvd + 1U;
  adisc = (struct fc_adisc_s *)rx_fchs + 1U;
  tmp___0 = bfa_fcs_itnim_get_online_state(rport->itnim);
  if ((unsigned int )tmp___0 == 0U) {
    fcxp = bfa_fcxp_req_rsp_alloc((void *)0, (port->fcs)->bfa, 0, 0, (u64 (*)(void * ,
                                                                              int  ))0,
                                  (u32 (*)(void * , int  ))0, (u64 (*)(void * , int  ))0,
                                  (u32 (*)(void * , int  ))0, 0);
    if ((unsigned long )fcxp == (unsigned long )((struct bfa_fcxp_s *)0)) {
      return;
    } else {

    }
    tmp = bfa_fcxp_get_reqbuf(fcxp);
    len = fc_adisc_acc_build(& fchs, (struct fc_adisc_s *)tmp, rx_fchs->s_id, port->pid,
                             (int )rx_fchs->ox_id, port->port_cfg.pwwn, port->port_cfg.nwwn);
    bfa_fcxp_send(fcxp, (struct bfa_rport_s *)0, (int )(port->fabric)->vf_id, (int )port->lp_tag,
                  0, 8, (u32 )len, & fchs, (void (*)(void * , struct bfa_fcxp_s * ,
                                                     void * , enum bfa_status  , u32  ,
                                                     u32  , struct fchs_s * ))0, (void *)0,
                  2112U, 0);
  } else {
    rport->stats.adisc_rejected = rport->stats.adisc_rejected + 1U;
    bfa_fcs_rport_send_ls_rjt(rport, rx_fchs, 9, 30);
  }
  return;
}
}
static void bfa_fcs_rport_hal_online(struct bfa_fcs_rport_s *rport ) 
{ 
  struct bfa_fcs_lport_s *port ;
  struct bfa_rport_info_s rport_info ;

  {
  port = rport->port;
  rport_info.pid = rport->pid;
  rport_info.local_pid = port->pid;
  rport_info.lp_tag = port->lp_tag;
  rport_info.vf_id = (port->fabric)->vf_id;
  rport_info.vf_en = (port->fabric)->is_vf;
  rport_info.fc_class = (u8 )rport->fc_cos;
  rport_info.cisc = (unsigned char )rport->cisc;
  rport_info.max_frmsz = rport->maxfrsize;
  bfa_rport_online(rport->bfa_rport, & rport_info);
  return;
}
}
static void bfa_fcs_rport_hal_offline(struct bfa_fcs_rport_s *rport ) 
{ 


  {
  if ((unsigned long )rport->bfa_rport != (unsigned long )((struct bfa_rport_s *)0)) {
    (*((rport->bfa_rport)->sm))((void *)rport->bfa_rport, 4);
  } else {
    bfa_cb_rport_offline((void *)rport);
  }
  return;
}
}
static struct bfa_fcs_rport_s *bfa_fcs_rport_alloc(struct bfa_fcs_lport_s *port ,
                                                   wwn_t pwwn , u32 rpid ) 
{ 
  struct bfa_fcs_s *fcs ;
  struct bfa_fcs_rport_s *rport ;
  struct bfad_rport_s *rport_drv ;
  enum bfa_status tmp ;
  int __ret_warn_on ;
  long tmp___0 ;

  {
  fcs = port->fcs;
  if (fcs->num_rport_logins >= bfa_fcs_rport_max_logins) {
    __bfa_trc(fcs->trcmod, __trc_fileno___8, 2327, (unsigned long long )rpid);
    return ((struct bfa_fcs_rport_s *)0);
  } else {

  }
  tmp = bfa_fcb_rport_alloc(fcs->bfad, & rport, & rport_drv);
  if ((unsigned int )tmp != 0U) {
    __bfa_trc(fcs->trcmod, __trc_fileno___8, 2333, (unsigned long long )rpid);
    return ((struct bfa_fcs_rport_s *)0);
  } else {

  }
  rport->port = port;
  rport->fcs = fcs;
  rport->rp_drv = rport_drv;
  rport->pid = rpid;
  rport->pwwn = pwwn;
  rport->old_pid = 0U;
  rport->bfa_rport = (struct bfa_rport_s *)0;
  __ret_warn_on = ((unsigned int )port->port_cfg.roles & 1U) == 0U;
  tmp___0 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp___0 != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcs_rport.c",
                       2352);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if ((int )port->port_cfg.roles & 1) {
    rport->itnim = bfa_fcs_itnim_create(rport);
    if ((unsigned long )rport->itnim == (unsigned long )((struct bfa_fcs_itnim_s *)0)) {
      __bfa_trc(fcs->trcmod, __trc_fileno___8, 2357, (unsigned long long )rpid);
      kfree((void const   *)rport_drv);
      return ((struct bfa_fcs_rport_s *)0);
    } else {

    }
  } else {

  }
  bfa_fcs_lport_add_rport(port, rport);
  fcs->num_rport_logins = fcs->num_rport_logins + 1U;
  rport->sm = (void (*)(void * , int  ))(& bfa_fcs_rport_sm_uninit);
  if (((((rport->pid & 255U) << 16) | (rport->pid & 65280U)) | ((rport->pid & 16711680U) >> 16)) <= 16773120U) {
    bfa_fcs_rpf_init(rport);
  } else {

  }
  return (rport);
}
}
static void bfa_fcs_rport_free(struct bfa_fcs_rport_s *rport ) 
{ 
  struct bfa_fcs_lport_s *port ;
  struct bfa_fcs_s *fcs ;

  {
  port = rport->port;
  fcs = port->fcs;
  rport->plogi_pending = 0;
  if ((int )port->port_cfg.roles & 1) {
    bfa_fcs_itnim_delete(rport->itnim);
    if (rport->pid != 0U && ((((rport->pid & 255U) << 16) | (rport->pid & 65280U)) | ((rport->pid & 16711680U) >> 16)) <= 16773120U) {
      bfa_fcs_rpf_rport_offline(rport);
    } else {

    }
  } else {

  }
  if ((unsigned long )rport->bfa_rport != (unsigned long )((struct bfa_rport_s *)0)) {
    (*((rport->bfa_rport)->sm))((void *)rport->bfa_rport, 2);
    rport->bfa_rport = (struct bfa_rport_s *)0;
  } else {

  }
  bfa_fcs_lport_del_rport(port, rport);
  fcs->num_rport_logins = fcs->num_rport_logins - 1U;
  kfree((void const   *)rport->rp_drv);
  return;
}
}
static void bfa_fcs_rport_aen_post(struct bfa_fcs_rport_s *rport , enum bfa_rport_aen_event event ,
                                   struct bfa_rport_aen_data_s *data ) 
{ 
  struct bfa_fcs_lport_s *port ;
  struct bfad_s *bfad ;
  struct bfa_aen_entry_s *aen_entry ;
  unsigned long _flags ;
  raw_spinlock_t *tmp ;
  int tmp___0 ;
  struct bfa_fcs_lport_s *tmp___1 ;

  {
  port = rport->port;
  bfad = (port->fcs)->bfad;
  tmp = spinlock_check(& bfad->bfad_aen_spinlock);
  _flags = _raw_spin_lock_irqsave(tmp);
  tmp___0 = list_empty((struct list_head  const  *)(& bfad->free_aen_q));
  if (tmp___0 == 0) {
    *((struct list_head **)(& aen_entry)) = bfad->free_aen_q.next;
    ((*((struct list_head **)(& aen_entry)))->next)->prev = & bfad->free_aen_q;
    bfad->free_aen_q.next = (*((struct list_head **)(& aen_entry)))->next;
  } else {
    *((struct list_head **)(& aen_entry)) = (struct list_head *)0;
  }
  if ((unsigned long )aen_entry != (unsigned long )((struct bfa_aen_entry_s *)0)) {
    list_add_tail(& aen_entry->qe, & bfad->active_aen_q);
  } else {

  }
  spin_unlock_irqrestore(& bfad->bfad_aen_spinlock, _flags);
  if ((unsigned long )aen_entry == (unsigned long )((struct bfa_aen_entry_s *)0)) {
    return;
  } else {

  }
  if ((unsigned int )event == 4U) {
    aen_entry->aen_data.rport.priv.qos = data->priv.qos;
  } else
  if ((unsigned int )event == 5U) {
    aen_entry->aen_data.rport.priv.qos = data->priv.qos;
  } else {

  }
  aen_entry->aen_data.rport.vf_id = ((rport->port)->fabric)->vf_id;
  tmp___1 = bfa_fcs_get_base_port(rport->fcs);
  aen_entry->aen_data.rport.ppwwn = tmp___1->port_cfg.pwwn;
  aen_entry->aen_data.rport.lpwwn = (rport->port)->port_cfg.pwwn;
  aen_entry->aen_data.rport.rpwwn = rport->pwwn;
  do_gettimeofday(& aen_entry->aen_tv);
  aen_entry->bfad_num = bfad->inst_no;
  (rport->fcs)->fcs_aen_seq = (rport->fcs)->fcs_aen_seq + 1;
  aen_entry->seq_num = (u32 )(rport->fcs)->fcs_aen_seq;
  aen_entry->aen_category = 4;
  aen_entry->aen_type = (u32 )event;
  if ((bfad->bfad_flags & 512U) != 0U) {
    queue_work___3((bfad->im)->drv_workq, & (bfad->im)->aen_im_notify_work);
  } else {

  }
  return;
}
}
static void bfa_fcs_rport_fcs_online_action(struct bfa_fcs_rport_s *rport ) 
{ 


  {
  if (rport->pid == 0U || rport->pwwn == 0ULL) {
    __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 2438, (unsigned long long )rport->pid);
    __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 2439, (unsigned long long )(rport->pid | 3735879680U));
    printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcs_rport.c",
           2439, rport->pid);
  } else {

  }
  (*((rport->itnim)->sm))((void *)rport->itnim, 1);
  return;
}
}
static void bfa_fcs_rport_hal_online_action(struct bfa_fcs_rport_s *rport ) 
{ 
  struct bfa_fcs_lport_s *port ;
  struct bfad_s *bfad ;
  char lpwwn_buf[32U] ;
  char rpwwn_buf[32U] ;

  {
  port = rport->port;
  bfad = (port->fcs)->bfad;
  rport->stats.onlines = rport->stats.onlines + 1U;
  if (rport->pid == 0U || rport->pwwn == 0ULL) {
    __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 2456, (unsigned long long )rport->pid);
    __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 2457, (unsigned long long )(rport->pid | 3735879680U));
    printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcs_rport.c",
           2457, rport->pid);
  } else {

  }
  if ((int )port->port_cfg.roles & 1) {
    bfa_fcs_itnim_brp_online(rport->itnim);
    if (((((rport->pid & 255U) << 16) | (rport->pid & 65280U)) | ((rport->pid & 16711680U) >> 16)) <= 16773120U) {
      bfa_fcs_rpf_rport_online(rport);
    } else {

    }
  } else {

  }
  wwn2str___3((char *)(& lpwwn_buf), port->port_cfg.pwwn);
  wwn2str___3((char *)(& rpwwn_buf), rport->pwwn);
  if (((((rport->pid & 255U) << 16) | (rport->pid & 65280U)) | ((rport->pid & 16711680U) >> 16)) <= 16773120U) {
    if (bfa_log_level == 4 || (int )((signed char )*("\016" + 1)) <= 52) {
      dev_printk("\016", (struct device  const  *)(& (bfad->pcidev)->dev), "Remote port (WWN = %s) online for logical port (WWN = %s)\n",
                 (char *)(& rpwwn_buf), (char *)(& lpwwn_buf));
    } else {

    }
    bfa_fcs_rport_aen_post(rport, 1, (struct bfa_rport_aen_data_s *)0);
  } else {

  }
  return;
}
}
static void bfa_fcs_rport_fcs_offline_action(struct bfa_fcs_rport_s *rport ) 
{ 


  {
  if (((((rport->pid & 255U) << 16) | (rport->pid & 65280U)) | ((rport->pid & 16711680U) >> 16)) <= 16773120U) {
    bfa_fcs_rpf_rport_offline(rport);
  } else {

  }
  bfa_fcs_itnim_rport_offline(rport->itnim);
  return;
}
}
static void bfa_fcs_rport_hal_offline_action(struct bfa_fcs_rport_s *rport ) 
{ 
  struct bfa_fcs_lport_s *port ;
  struct bfad_s *bfad ;
  char lpwwn_buf[32U] ;
  char rpwwn_buf[32U] ;
  enum bfa_boolean tmp ;

  {
  port = rport->port;
  bfad = (port->fcs)->bfad;
  if ((unsigned long )rport->bfa_rport == (unsigned long )((struct bfa_rport_s *)0)) {
    bfa_fcs_rport_fcs_offline_action(rport);
    return;
  } else {

  }
  rport->stats.offlines = rport->stats.offlines + 1U;
  wwn2str___3((char *)(& lpwwn_buf), port->port_cfg.pwwn);
  wwn2str___3((char *)(& rpwwn_buf), rport->pwwn);
  if (((((rport->pid & 255U) << 16) | (rport->pid & 65280U)) | ((rport->pid & 16711680U) >> 16)) <= 16773120U) {
    tmp = bfa_fcs_lport_is_online(rport->port);
    if ((unsigned int )tmp == 1U) {
      if (bfa_log_level == 4 || (int )((signed char )*("\v" + 1)) <= 52) {
        dev_printk("\v", (struct device  const  *)(& (bfad->pcidev)->dev), "Remote port (WWN = %s) connectivity lost for logical port (WWN = %s)\n",
                   (char *)(& rpwwn_buf), (char *)(& lpwwn_buf));
      } else {

      }
      bfa_fcs_rport_aen_post(rport, 3, (struct bfa_rport_aen_data_s *)0);
    } else {
      if (bfa_log_level == 4 || (int )((signed char )*("\016" + 1)) <= 52) {
        dev_printk("\016", (struct device  const  *)(& (bfad->pcidev)->dev), "Remote port (WWN = %s) offlined by logical port (WWN = %s)\n",
                   (char *)(& rpwwn_buf), (char *)(& lpwwn_buf));
      } else {

      }
      bfa_fcs_rport_aen_post(rport, 2, (struct bfa_rport_aen_data_s *)0);
    }
  } else {

  }
  if ((int )port->port_cfg.roles & 1) {
    bfa_fcs_itnim_rport_offline(rport->itnim);
    if (((((rport->pid & 255U) << 16) | (rport->pid & 65280U)) | ((rport->pid & 16711680U) >> 16)) <= 16773120U) {
      bfa_fcs_rpf_rport_offline(rport);
    } else {

    }
  } else {

  }
  return;
}
}
static void bfa_fcs_rport_update(struct bfa_fcs_rport_s *rport , struct fc_logi_s *plogi ) 
{ 
  struct bfa_fcs_lport_s *port ;
  __u16 tmp ;
  __u16 tmp___0 ;
  __u16 tmp___1 ;
  __u16 tmp___2 ;
  __u16 tmp___3 ;
  __u16 tmp___4 ;
  __u16 tmp___5 ;
  __u16 tmp___6 ;

  {
  port = rport->port;
  rport->pwwn = plogi->port_name;
  rport->nwwn = plogi->node_name;
  rport->fc_cos = 0;
  if ((unsigned int )*((unsigned char *)plogi + 68UL) != 0U) {
    rport->fc_cos = 8;
  } else {

  }
  if ((unsigned int )*((unsigned char *)plogi + 52UL) != 0U) {
    rport->fc_cos = (enum fc_cos )((unsigned int )rport->fc_cos | 4U);
  } else {

  }
  rport->cisc = (enum bfa_boolean )plogi->csp.cisc;
  tmp___1 = __fswab16((int )plogi->class3.rxsz);
  tmp___2 = __fswab16((int )plogi->csp.rxsz);
  if ((int )tmp___1 < (int )tmp___2) {
    tmp = __fswab16((int )plogi->class3.rxsz);
    rport->maxfrsize = tmp;
  } else {
    tmp___0 = __fswab16((int )plogi->csp.rxsz);
    rport->maxfrsize = tmp___0;
  }
  tmp___3 = __fswab16((int )plogi->csp.bbcred);
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___8, 2562, (unsigned long long )tmp___3);
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___8, 2563, (unsigned long long )(port->fabric)->bb_credit);
  if ((unsigned int )(port->fabric)->fab_type != 1U) {
    tmp___6 = __fswab16((int )plogi->csp.bbcred);
    if ((int )tmp___6 < (int )(port->fabric)->bb_credit) {
      tmp___4 = __fswab16((int )plogi->csp.bbcred);
      __bfa_trc((port->fcs)->trcmod, __trc_fileno___8, 2575, (unsigned long long )tmp___4);
      __bfa_trc((port->fcs)->trcmod, __trc_fileno___8, 2576, (unsigned long long )(port->fabric)->bb_credit);
      tmp___5 = __fswab16((int )plogi->csp.bbcred);
      (port->fabric)->bb_credit = tmp___5;
      bfa_fcport_set_tx_bbcredit((port->fcs)->bfa, (int )(port->fabric)->bb_credit);
    } else {

    }
  } else {

  }
  return;
}
}
static void bfa_fcs_rport_process_logo(struct bfa_fcs_rport_s *rport , struct fchs_s *fchs ) 
{ 


  {
  rport->reply_oxid = fchs->ox_id;
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 2592, (unsigned long long )rport->reply_oxid);
  rport->prlo = 0;
  rport->stats.logo_rcvd = rport->stats.logo_rcvd + 1U;
  (*(rport->sm))((void *)rport, 4);
  return;
}
}
struct bfa_fcs_rport_s *bfa_fcs_rport_create(struct bfa_fcs_lport_s *port , u32 rpid ) 
{ 
  struct bfa_fcs_rport_s *rport ;

  {
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___8, 2619, (unsigned long long )rpid);
  rport = bfa_fcs_rport_alloc(port, 0ULL, rpid);
  if ((unsigned long )rport == (unsigned long )((struct bfa_fcs_rport_s *)0)) {
    return ((struct bfa_fcs_rport_s *)0);
  } else {

  }
  (*(rport->sm))((void *)rport, 1);
  return (rport);
}
}
struct bfa_fcs_rport_s *bfa_fcs_rport_create_by_wwn(struct bfa_fcs_lport_s *port ,
                                                    wwn_t rpwwn ) 
{ 
  struct bfa_fcs_rport_s *rport ;

  {
  __bfa_trc((port->fcs)->trcmod, __trc_fileno___8, 2640, rpwwn);
  rport = bfa_fcs_rport_alloc(port, rpwwn, 0U);
  if ((unsigned long )rport == (unsigned long )((struct bfa_fcs_rport_s *)0)) {
    return ((struct bfa_fcs_rport_s *)0);
  } else {

  }
  (*(rport->sm))((void *)rport, 16);
  return (rport);
}
}
void bfa_fcs_rport_start(struct bfa_fcs_lport_s *port , struct fchs_s *fchs , struct fc_logi_s *plogi ) 
{ 
  struct bfa_fcs_rport_s *rport ;

  {
  rport = bfa_fcs_rport_alloc(port, 0ULL, fchs->s_id);
  if ((unsigned long )rport == (unsigned long )((struct bfa_fcs_rport_s *)0)) {
    return;
  } else {

  }
  bfa_fcs_rport_update(rport, plogi);
  (*(rport->sm))((void *)rport, 3);
  return;
}
}
void bfa_fcs_rport_plogi_create(struct bfa_fcs_lport_s *port , struct fchs_s *fchs ,
                                struct fc_logi_s *plogi ) 
{ 
  struct bfa_fcs_rport_s *rport ;

  {
  rport = bfa_fcs_rport_alloc(port, plogi->port_name, fchs->s_id);
  if ((unsigned long )rport == (unsigned long )((struct bfa_fcs_rport_s *)0)) {
    return;
  } else {

  }
  bfa_fcs_rport_update(rport, plogi);
  rport->reply_oxid = fchs->ox_id;
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 2687, (unsigned long long )rport->reply_oxid);
  rport->stats.plogi_rcvd = rport->stats.plogi_rcvd + 1U;
  (*(rport->sm))((void *)rport, 2);
  return;
}
}
void bfa_fcs_rport_plogi(struct bfa_fcs_rport_s *rport , struct fchs_s *rx_fchs ,
                         struct fc_logi_s *plogi ) 
{ 


  {
  bfa_fcs_rport_update(rport, plogi);
  rport->reply_oxid = rx_fchs->ox_id;
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 2708, (unsigned long long )rport->reply_oxid);
  rport->pid = rx_fchs->s_id;
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 2711, (unsigned long long )rport->pid);
  rport->stats.plogi_rcvd = rport->stats.plogi_rcvd + 1U;
  (*(rport->sm))((void *)rport, 2);
  return;
}
}
void bfa_fcs_rport_scn(struct bfa_fcs_rport_s *rport ) 
{ 


  {
  rport->stats.rscns = rport->stats.rscns + 1U;
  (*(rport->sm))((void *)rport, 8);
  return;
}
}
void bfa_cb_rport_online(void *cbarg ) 
{ 
  struct bfa_fcs_rport_s *rport ;

  {
  rport = (struct bfa_fcs_rport_s *)cbarg;
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 2747, rport->pwwn);
  (*(rport->sm))((void *)rport, 12);
  return;
}
}
void bfa_cb_rport_offline(void *cbarg ) 
{ 
  struct bfa_fcs_rport_s *rport ;

  {
  rport = (struct bfa_fcs_rport_s *)cbarg;
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 2769, rport->pwwn);
  (*(rport->sm))((void *)rport, 13);
  return;
}
}
void bfa_cb_rport_qos_scn_flowid(void *cbarg , struct bfa_rport_qos_attr_s old_qos_attr ,
                                 struct bfa_rport_qos_attr_s new_qos_attr ) 
{ 
  struct bfa_fcs_rport_s *rport ;
  struct bfa_rport_aen_data_s aen_data ;

  {
  rport = (struct bfa_fcs_rport_s *)cbarg;
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 2795, rport->pwwn);
  aen_data.priv.qos = new_qos_attr;
  bfa_fcs_rport_aen_post(rport, 5, & aen_data);
  return;
}
}
void bfa_cb_rport_scn_online(struct bfa_s *bfa ) 
{ 
  struct bfa_fcs_s *fcs ;
  struct bfa_fcs_lport_s *port ;
  struct bfa_fcs_lport_s *tmp ;
  struct bfa_fcs_rport_s *rp ;
  struct list_head *qe ;
  enum bfa_boolean tmp___0 ;

  {
  fcs = & ((struct bfad_s *)bfa->bfad)->bfa_fcs;
  tmp = bfa_fcs_get_base_port(fcs);
  port = tmp;
  qe = port->rport_q.next;
  goto ldv_49539;
  ldv_49538: 
  rp = (struct bfa_fcs_rport_s *)qe;
  (*(rp->sm))((void *)rp, 20);
  rp->scn_online = 1;
  qe = qe->next;
  ldv_49539: ;
  if ((unsigned long )(& port->rport_q) != (unsigned long )qe) {
    goto ldv_49538;
  } else {

  }
  tmp___0 = bfa_fcs_lport_is_online(port);
  if ((unsigned int )tmp___0 != 0U) {
    bfa_fcs_lport_lip_scn_online(port);
  } else {

  }
  return;
}
}
void bfa_cb_rport_scn_no_dev(void *rport ) 
{ 
  struct bfa_fcs_rport_s *rp ;

  {
  rp = (struct bfa_fcs_rport_s *)rport;
  (*(rp->sm))((void *)rp, 19);
  rp->scn_online = 0;
  return;
}
}
void bfa_cb_rport_scn_offline(struct bfa_s *bfa ) 
{ 
  struct bfa_fcs_s *fcs ;
  struct bfa_fcs_lport_s *port ;
  struct bfa_fcs_lport_s *tmp ;
  struct bfa_fcs_rport_s *rp ;
  struct list_head *qe ;

  {
  fcs = & ((struct bfad_s *)bfa->bfad)->bfa_fcs;
  tmp = bfa_fcs_get_base_port(fcs);
  port = tmp;
  qe = port->rport_q.next;
  goto ldv_49553;
  ldv_49552: 
  rp = (struct bfa_fcs_rport_s *)qe;
  (*(rp->sm))((void *)rp, 19);
  rp->scn_online = 0;
  qe = qe->next;
  ldv_49553: ;
  if ((unsigned long )(& port->rport_q) != (unsigned long )qe) {
    goto ldv_49552;
  } else {

  }

  return;
}
}
void bfa_cb_rport_qos_scn_prio(void *cbarg , struct bfa_rport_qos_attr_s old_qos_attr ,
                               struct bfa_rport_qos_attr_s new_qos_attr ) 
{ 
  struct bfa_fcs_rport_s *rport ;
  struct bfa_rport_aen_data_s aen_data ;

  {
  rport = (struct bfa_fcs_rport_s *)cbarg;
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 2864, rport->pwwn);
  aen_data.priv.qos = new_qos_attr;
  bfa_fcs_rport_aen_post(rport, 4, & aen_data);
  return;
}
}
void bfa_fcs_rport_uf_recv(struct bfa_fcs_rport_s *rport , struct fchs_s *fchs , u16 len ) 
{ 
  struct bfa_fcs_lport_s *port ;
  struct fc_els_cmd_s *els_cmd ;

  {
  port = rport->port;
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 2879, (unsigned long long )fchs->s_id);
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 2880, (unsigned long long )fchs->d_id);
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 2881, (unsigned long long )fchs->type);
  if ((unsigned int )fchs->type != 1U) {
    return;
  } else {

  }
  els_cmd = (struct fc_els_cmd_s *)fchs + 1U;
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 2888, (unsigned long long )els_cmd->els_code);
  switch ((int )els_cmd->els_code) {
  case 5: 
  port->stats.plogi_rcvd = port->stats.plogi_rcvd + 1U;
  bfa_fcs_rport_process_logo(rport, fchs);
  goto ldv_49570;
  case 82: 
  port->stats.adisc_rcvd = port->stats.adisc_rcvd + 1U;
  bfa_fcs_rport_process_adisc(rport, fchs, (int )len);
  goto ldv_49570;
  case 33: 
  port->stats.prlo_rcvd = port->stats.prlo_rcvd + 1U;
  if ((int )port->port_cfg.roles & 1) {
    bfa_fcs_fcpim_uf_recv(rport->itnim, fchs, (int )len);
  } else {

  }
  goto ldv_49570;
  case 32: 
  port->stats.prli_rcvd = port->stats.prli_rcvd + 1U;
  bfa_fcs_rport_process_prli(rport, fchs, (int )len);
  goto ldv_49570;
  case 125: 
  port->stats.rpsc_rcvd = port->stats.rpsc_rcvd + 1U;
  bfa_fcs_rport_process_rpsc(rport, fchs, (int )len);
  goto ldv_49570;
  default: 
  port->stats.un_handled_els_rcvd = port->stats.un_handled_els_rcvd + 1U;
  bfa_fcs_rport_send_ls_rjt(rport, fchs, 11, 0);
  goto ldv_49570;
  }
  ldv_49570: ;
  return;
}
}
static void bfa_fcs_rport_send_prlo_acc(struct bfa_fcs_rport_s *rport ) 
{ 
  struct bfa_fcs_lport_s *port ;
  struct fchs_s fchs ;
  struct bfa_fcxp_s *fcxp ;
  int len ;
  void *tmp ;
  u16 tmp___0 ;

  {
  port = rport->port;
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 2935, (unsigned long long )rport->pid);
  fcxp = bfa_fcxp_req_rsp_alloc((void *)0, (port->fcs)->bfa, 0, 0, (u64 (*)(void * ,
                                                                            int  ))0,
                                (u32 (*)(void * , int  ))0, (u64 (*)(void * , int  ))0,
                                (u32 (*)(void * , int  ))0, 0);
  if ((unsigned long )fcxp == (unsigned long )((struct bfa_fcxp_s *)0)) {
    return;
  } else {

  }
  tmp = bfa_fcxp_get_reqbuf(fcxp);
  tmp___0 = fc_prlo_acc_build(& fchs, (struct fc_prlo_acc_s *)tmp, rport->pid, port->pid,
                              (int )rport->reply_oxid, 0);
  len = (int )tmp___0;
  bfa_fcxp_send(fcxp, rport->bfa_rport, (int )(port->fabric)->vf_id, (int )port->lp_tag,
                0, 8, (u32 )len, & fchs, (void (*)(void * , struct bfa_fcxp_s * ,
                                                   void * , enum bfa_status  , u32  ,
                                                   u32  , struct fchs_s * ))0, (void *)0,
                2112U, 0);
  return;
}
}
static void bfa_fcs_rport_send_ls_rjt(struct bfa_fcs_rport_s *rport , struct fchs_s *rx_fchs ,
                                      u8 reason_code , u8 reason_code_expl ) 
{ 
  struct bfa_fcs_lport_s *port ;
  struct fchs_s fchs ;
  struct bfa_fcxp_s *fcxp ;
  int len ;
  void *tmp ;
  u16 tmp___0 ;

  {
  port = rport->port;
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 2961, (unsigned long long )rx_fchs->s_id);
  fcxp = bfa_fcxp_req_rsp_alloc((void *)0, (rport->fcs)->bfa, 0, 0, (u64 (*)(void * ,
                                                                             int  ))0,
                                (u32 (*)(void * , int  ))0, (u64 (*)(void * , int  ))0,
                                (u32 (*)(void * , int  ))0, 0);
  if ((unsigned long )fcxp == (unsigned long )((struct bfa_fcxp_s *)0)) {
    return;
  } else {

  }
  tmp = bfa_fcxp_get_reqbuf(fcxp);
  tmp___0 = fc_ls_rjt_build(& fchs, (struct fc_ls_rjt_s *)tmp, rx_fchs->s_id, port->pid,
                            (int )rx_fchs->ox_id, (int )reason_code, (int )reason_code_expl);
  len = (int )tmp___0;
  bfa_fcxp_send(fcxp, (struct bfa_rport_s *)0, (int )(port->fabric)->vf_id, (int )port->lp_tag,
                0, 8, (u32 )len, & fchs, (void (*)(void * , struct bfa_fcxp_s * ,
                                                   void * , enum bfa_status  , u32  ,
                                                   u32  , struct fchs_s * ))0, (void *)0,
                2112U, 0);
  return;
}
}
int bfa_fcs_rport_get_state(struct bfa_fcs_rport_s *rport ) 
{ 
  int tmp ;

  {
  tmp = bfa_sm_to_state((struct bfa_sm_table_s *)(& rport_sm_table), rport->sm);
  return (tmp);
}
}
void bfa_fcs_rport_set_del_timeout(u8 rport_tmo ) 
{ 


  {
  if ((unsigned int )rport_tmo != 0U) {
    bfa_fcs_rport_del_timeout = (u32 )((int )rport_tmo * 1000);
  } else {

  }
  return;
}
}
void bfa_fcs_rport_prlo(struct bfa_fcs_rport_s *rport , __be16 ox_id ) 
{ 


  {
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 3004, (unsigned long long )rport->pid);
  rport->prlo = 1;
  rport->reply_oxid = ox_id;
  (*(rport->sm))((void *)rport, 17);
  return;
}
}
void bfa_fcs_rport_set_max_logins(u32 max_logins ) 
{ 


  {
  if (max_logins != 0U) {
    bfa_fcs_rport_max_logins = max_logins;
  } else {

  }
  return;
}
}
void bfa_fcs_rport_get_attr(struct bfa_fcs_rport_s *rport , struct bfa_rport_attr_s *rport_attr ) 
{ 
  struct bfa_rport_qos_attr_s qos_attr ;
  struct bfa_fcs_lport_s *port ;
  enum bfa_port_speed rport_speed ;
  struct bfa_port_attr_s port_attr ;
  int tmp ;
  __u32 tmp___0 ;
  enum bfa_port_speed tmp___1 ;
  enum bfa_boolean tmp___2 ;

  {
  port = rport->port;
  rport_speed = rport->rpf.rpsc_speed;
  bfa_fcport_get_attr((rport->fcs)->bfa, & port_attr);
  memset((void *)rport_attr, 0, 320UL);
  memset((void *)(& qos_attr), 0, 8UL);
  rport_attr->pid = rport->pid;
  rport_attr->pwwn = rport->pwwn;
  rport_attr->nwwn = rport->nwwn;
  rport_attr->cos_supported = rport->fc_cos;
  rport_attr->df_sz = (u32 )rport->maxfrsize;
  tmp = bfa_fcs_rport_get_state(rport);
  rport_attr->state = (enum bfa_rport_state )tmp;
  rport_attr->fc_cos = rport->fc_cos;
  rport_attr->cisc = rport->cisc;
  rport_attr->scsi_function = rport->scsi_function;
  rport_attr->curr_speed = rport->rpf.rpsc_speed;
  rport_attr->assigned_speed = rport->rpf.assigned_speed;
  if ((unsigned long )rport->bfa_rport != (unsigned long )((struct bfa_rport_s *)0)) {
    qos_attr.qos_priority = (rport->bfa_rport)->qos_attr.qos_priority;
    tmp___0 = __fswab32((rport->bfa_rport)->qos_attr.qos_flow_id);
    qos_attr.qos_flow_id = tmp___0;
  } else {

  }
  rport_attr->qos_attr = qos_attr;
  rport_attr->trl_enforced = 0;
  tmp___2 = bfa_fcport_is_ratelim((port->fcs)->bfa);
  if ((unsigned int )tmp___2 != 0U && (unsigned int )rport->scsi_function == 2U) {
    if ((unsigned int )rport_speed == 0U) {
      rport_speed = bfa_fcport_get_ratelim_speed((rport->fcs)->bfa);
    } else {

    }
    tmp___1 = bfa_fcs_lport_get_rport_max_speed(port);
    if ((unsigned int )tmp___1 != 0U && (unsigned int )port_attr.speed > (unsigned int )rport_speed) {
      rport_attr->trl_enforced = 1;
    } else {

    }
  } else {

  }
  return;
}
}
struct bfa_fcs_rport_s *bfa_fcs_rport_lookup(struct bfa_fcs_lport_s *port , wwn_t rpwwn ) 
{ 
  struct bfa_fcs_rport_s *rport ;

  {
  rport = bfa_fcs_lport_get_rport_by_pwwn(port, rpwwn);
  return (rport);
}
}
struct bfa_fcs_rport_s *bfa_fcs_rport_lookup_by_nwwn(struct bfa_fcs_lport_s *port ,
                                                     wwn_t rnwwn ) 
{ 
  struct bfa_fcs_rport_s *rport ;

  {
  rport = bfa_fcs_lport_get_rport_by_nwwn(port, rnwwn);
  return (rport);
}
}
static void bfa_fcs_rpf_send_rpsc2(void *rpf_cbarg , struct bfa_fcxp_s *fcxp_alloced ) ;
static void bfa_fcs_rpf_rpsc2_response(void *fcsarg , struct bfa_fcxp_s *fcxp , void *cbarg ,
                                       enum bfa_status req_status , u32 rsp_len ,
                                       u32 resid_len , struct fchs_s *rsp_fchs ) ;
static void bfa_fcs_rpf_timeout(void *arg ) ;
static void bfa_fcs_rpf_sm_uninit(struct bfa_fcs_rpf_s *rpf , enum rpf_event event ) ;
static void bfa_fcs_rpf_sm_rpsc_sending(struct bfa_fcs_rpf_s *rpf , enum rpf_event event ) ;
static void bfa_fcs_rpf_sm_rpsc(struct bfa_fcs_rpf_s *rpf , enum rpf_event event ) ;
static void bfa_fcs_rpf_sm_rpsc_retry(struct bfa_fcs_rpf_s *rpf , enum rpf_event event ) ;
static void bfa_fcs_rpf_sm_offline(struct bfa_fcs_rpf_s *rpf , enum rpf_event event ) ;
static void bfa_fcs_rpf_sm_online(struct bfa_fcs_rpf_s *rpf , enum rpf_event event ) ;
static void bfa_fcs_rpf_sm_uninit(struct bfa_fcs_rpf_s *rpf , enum rpf_event event ) 
{ 
  struct bfa_fcs_rport_s *rport ;
  struct bfa_fcs_fabric_s *fabric ;
  u16 tmp ;

  {
  rport = rpf->rport;
  fabric = & (rport->fcs)->fabric;
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 3158, rport->pwwn);
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 3159, (unsigned long long )rport->pid);
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 3160, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 2U: ;
  if (((((rport->pid & 255U) << 16) | (rport->pid & 65280U)) | ((rport->pid & 16711680U) >> 16)) <= 16773120U) {
    if ((unsigned int )(((rport->port)->fabric)->lps)->brcd_switch != 0U) {
      rpf->sm = (void (*)(void * , int  ))(& bfa_fcs_rpf_sm_rpsc_sending);
      rpf->rpsc_retries = 0;
      bfa_fcs_rpf_send_rpsc2((void *)rpf, (struct bfa_fcxp_s *)0);
    } else {
      tmp = bfa_fcs_fabric_get_switch_oui(fabric);
      if ((unsigned int )tmp == 1310U) {
        rpf->sm = (void (*)(void * , int  ))(& bfa_fcs_rpf_sm_rpsc_sending);
        rpf->rpsc_retries = 0;
        bfa_fcs_rpf_send_rpsc2((void *)rpf, (struct bfa_fcxp_s *)0);
      } else {

      }
    }
  } else {

  }
  goto ldv_49670;
  case 1U: ;
  goto ldv_49670;
  default: 
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 3179, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcs_rport.c",
         3179, (unsigned int )event);
  }
  ldv_49670: ;
  return;
}
}
static void bfa_fcs_rpf_sm_rpsc_sending(struct bfa_fcs_rpf_s *rpf , enum rpf_event event ) 
{ 
  struct bfa_fcs_rport_s *rport ;

  {
  rport = rpf->rport;
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 3188, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 3U: 
  rpf->sm = (void (*)(void * , int  ))(& bfa_fcs_rpf_sm_rpsc);
  goto ldv_49679;
  case 1U: 
  rpf->sm = (void (*)(void * , int  ))(& bfa_fcs_rpf_sm_offline);
  bfa_fcxp_walloc_cancel((rport->fcs)->bfa, & rpf->fcxp_wqe);
  rpf->rpsc_retries = 0;
  goto ldv_49679;
  default: 
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 3202, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcs_rport.c",
         3202, (unsigned int )event);
  }
  ldv_49679: ;
  return;
}
}
static void bfa_fcs_rpf_sm_rpsc(struct bfa_fcs_rpf_s *rpf , enum rpf_event event ) 
{ 
  struct bfa_fcs_rport_s *rport ;
  int tmp ;

  {
  rport = rpf->rport;
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 3211, (unsigned long long )rport->pid);
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 3212, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 5U: 
  rpf->sm = (void (*)(void * , int  ))(& bfa_fcs_rpf_sm_online);
  if ((unsigned int )rpf->rpsc_speed != 0U) {
    bfa_rport_speed(rport->bfa_rport, rpf->rpsc_speed);
  } else
  if ((unsigned int )rpf->assigned_speed != 0U) {
    bfa_rport_speed(rport->bfa_rport, rpf->assigned_speed);
  } else {

  }
  goto ldv_49688;
  case 6U: 
  rpf->sm = (void (*)(void * , int  ))(& bfa_fcs_rpf_sm_online);
  goto ldv_49688;
  case 7U: 
  tmp = rpf->rpsc_retries;
  rpf->rpsc_retries = rpf->rpsc_retries + 1;
  if (tmp <= 2) {
    bfa_timer_begin(& ((rport->fcs)->bfa)->timer_mod, & rpf->timer, & bfa_fcs_rpf_timeout,
                    (void *)rpf, 1000U);
    rpf->sm = (void (*)(void * , int  ))(& bfa_fcs_rpf_sm_rpsc_retry);
  } else {
    rpf->sm = (void (*)(void * , int  ))(& bfa_fcs_rpf_sm_online);
  }
  goto ldv_49688;
  case 1U: 
  rpf->sm = (void (*)(void * , int  ))(& bfa_fcs_rpf_sm_offline);
  bfa_fcxp_discard(rpf->fcxp);
  rpf->rpsc_retries = 0;
  goto ldv_49688;
  default: 
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 3248, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcs_rport.c",
         3248, (unsigned int )event);
  }
  ldv_49688: ;
  return;
}
}
static void bfa_fcs_rpf_sm_rpsc_retry(struct bfa_fcs_rpf_s *rpf , enum rpf_event event ) 
{ 
  struct bfa_fcs_rport_s *rport ;

  {
  rport = rpf->rport;
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 3257, (unsigned long long )rport->pid);
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 3258, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 4U: 
  rpf->sm = (void (*)(void * , int  ))(& bfa_fcs_rpf_sm_rpsc_sending);
  bfa_fcs_rpf_send_rpsc2((void *)rpf, (struct bfa_fcxp_s *)0);
  goto ldv_49699;
  case 1U: 
  bfa_timer_stop(& rpf->timer);
  rpf->sm = (void (*)(void * , int  ))(& bfa_fcs_rpf_sm_offline);
  rpf->rpsc_retries = 0;
  goto ldv_49699;
  default: 
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 3274, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcs_rport.c",
         3274, (unsigned int )event);
  }
  ldv_49699: ;
  return;
}
}
static void bfa_fcs_rpf_sm_online(struct bfa_fcs_rpf_s *rpf , enum rpf_event event ) 
{ 
  struct bfa_fcs_rport_s *rport ;

  {
  rport = rpf->rport;
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 3283, rport->pwwn);
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 3284, (unsigned long long )rport->pid);
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 3285, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 1U: 
  rpf->sm = (void (*)(void * , int  ))(& bfa_fcs_rpf_sm_offline);
  rpf->rpsc_retries = 0;
  goto ldv_49708;
  default: 
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 3294, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcs_rport.c",
         3294, (unsigned int )event);
  }
  ldv_49708: ;
  return;
}
}
static void bfa_fcs_rpf_sm_offline(struct bfa_fcs_rpf_s *rpf , enum rpf_event event ) 
{ 
  struct bfa_fcs_rport_s *rport ;

  {
  rport = rpf->rport;
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 3303, rport->pwwn);
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 3304, (unsigned long long )rport->pid);
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 3305, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 2U: 
  rpf->sm = (void (*)(void * , int  ))(& bfa_fcs_rpf_sm_rpsc_sending);
  bfa_fcs_rpf_send_rpsc2((void *)rpf, (struct bfa_fcxp_s *)0);
  goto ldv_49716;
  case 1U: ;
  goto ldv_49716;
  default: 
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 3317, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcs_rport.c",
         3317, (unsigned int )event);
  }
  ldv_49716: ;
  return;
}
}
void bfa_fcs_rpf_init(struct bfa_fcs_rport_s *rport ) 
{ 
  struct bfa_fcs_rpf_s *rpf ;

  {
  rpf = & rport->rpf;
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 3328, (unsigned long long )rport->pid);
  rpf->rport = rport;
  rpf->sm = (void (*)(void * , int  ))(& bfa_fcs_rpf_sm_uninit);
  return;
}
}
void bfa_fcs_rpf_rport_online(struct bfa_fcs_rport_s *rport ) 
{ 


  {
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 3340, (unsigned long long )rport->pid);
  if ((unsigned int )((rport->port)->fcs)->min_cfg != 0U) {
    return;
  } else {

  }
  if ((unsigned int )((rport->port)->fabric)->fab_type == 1U) {
    (*(rport->rpf.sm))((void *)(& rport->rpf), 2);
  } else {

  }
  return;
}
}
void bfa_fcs_rpf_rport_offline(struct bfa_fcs_rport_s *rport ) 
{ 


  {
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 3355, (unsigned long long )rport->pid);
  if ((unsigned int )((rport->port)->fcs)->min_cfg != 0U) {
    return;
  } else {

  }
  rport->rpf.rpsc_speed = 0;
  (*(rport->rpf.sm))((void *)(& rport->rpf), 1);
  return;
}
}
static void bfa_fcs_rpf_timeout(void *arg ) 
{ 
  struct bfa_fcs_rpf_s *rpf ;
  struct bfa_fcs_rport_s *rport ;

  {
  rpf = (struct bfa_fcs_rpf_s *)arg;
  rport = rpf->rport;
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 3370, (unsigned long long )rport->pid);
  (*(rpf->sm))((void *)rpf, 4);
  return;
}
}
static void bfa_fcs_rpf_send_rpsc2(void *rpf_cbarg , struct bfa_fcxp_s *fcxp_alloced ) 
{ 
  struct bfa_fcs_rpf_s *rpf ;
  struct bfa_fcs_rport_s *rport ;
  struct bfa_fcs_lport_s *port ;
  struct fchs_s fchs ;
  int len ;
  struct bfa_fcxp_s *fcxp ;
  struct bfa_fcxp_s *tmp ;
  void *tmp___0 ;
  u16 tmp___1 ;

  {
  rpf = (struct bfa_fcs_rpf_s *)rpf_cbarg;
  rport = rpf->rport;
  port = rport->port;
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 3384, rport->pwwn);
  if ((unsigned long )fcxp_alloced == (unsigned long )((struct bfa_fcxp_s *)0)) {
    tmp = bfa_fcxp_req_rsp_alloc((void *)0, (port->fcs)->bfa, 0, 0, (u64 (*)(void * ,
                                                                             int  ))0,
                                 (u32 (*)(void * , int  ))0, (u64 (*)(void * , int  ))0,
                                 (u32 (*)(void * , int  ))0, 1);
    fcxp = tmp;
  } else {
    fcxp = fcxp_alloced;
  }
  if ((unsigned long )fcxp == (unsigned long )((struct bfa_fcxp_s *)0)) {
    bfa_fcxp_req_rsp_alloc_wait((port->fcs)->bfa, & rpf->fcxp_wqe, & bfa_fcs_rpf_send_rpsc2,
                                (void *)rpf, (void *)0, 0, 0, (u64 (*)(void * , int  ))0,
                                (u32 (*)(void * , int  ))0, (u64 (*)(void * , int  ))0,
                                (u32 (*)(void * , int  ))0, 1);
    return;
  } else {

  }
  rpf->fcxp = fcxp;
  tmp___0 = bfa_fcxp_get_reqbuf(fcxp);
  tmp___1 = fc_rpsc2_build(& fchs, (struct fc_rpsc2_cmd_s *)tmp___0, rport->pid, port->pid,
                           & rport->pid, 1);
  len = (int )tmp___1;
  bfa_fcxp_send(fcxp, (struct bfa_rport_s *)0, (int )(port->fabric)->vf_id, (int )port->lp_tag,
                0, 8, (u32 )len, & fchs, & bfa_fcs_rpf_rpsc2_response, (void *)rpf,
                2112U, 20);
  rport->stats.rpsc_sent = rport->stats.rpsc_sent + 1U;
  (*(rpf->sm))((void *)rpf, 3);
  return;
}
}
static void bfa_fcs_rpf_rpsc2_response(void *fcsarg , struct bfa_fcxp_s *fcxp , void *cbarg ,
                                       enum bfa_status req_status , u32 rsp_len ,
                                       u32 resid_len , struct fchs_s *rsp_fchs ) 
{ 
  struct bfa_fcs_rpf_s *rpf ;
  struct bfa_fcs_rport_s *rport ;
  struct fc_ls_rjt_s *ls_rjt ;
  struct fc_rpsc2_acc_s *rpsc2_acc ;
  u16 num_ents ;
  void *tmp ;
  __u16 tmp___0 ;
  int __ret_warn_on ;
  __u32 tmp___1 ;
  long tmp___2 ;
  __u32 tmp___3 ;
  __u16 tmp___4 ;
  __u16 tmp___5 ;
  __u16 tmp___6 ;
  void *tmp___7 ;

  {
  rpf = (struct bfa_fcs_rpf_s *)cbarg;
  rport = rpf->rport;
  __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 3417, (unsigned long long )req_status);
  if ((unsigned int )req_status != 0U) {
    __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 3420, (unsigned long long )req_status);
    if ((unsigned int )req_status == 5U) {
      rport->stats.rpsc_failed = rport->stats.rpsc_failed + 1U;
    } else {

    }
    (*(rpf->sm))((void *)rpf, 7);
    return;
  } else {

  }
  tmp = bfa_fcxp_get_rspbuf(fcxp);
  rpsc2_acc = (struct fc_rpsc2_acc_s *)tmp;
  if ((unsigned int )rpsc2_acc->els_cmd == 2U) {
    rport->stats.rpsc_accs = rport->stats.rpsc_accs + 1U;
    tmp___0 = __fswab16((int )rpsc2_acc->num_pids);
    num_ents = tmp___0;
    __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 3431, (unsigned long long )num_ents);
    if ((unsigned int )num_ents != 0U) {
      tmp___1 = __fswab32(rpsc2_acc->port_info[0].pid);
      __ret_warn_on = tmp___1 != ((((rport->pid & 255U) << 16) | (rport->pid & 65280U)) | ((rport->pid & 16711680U) >> 16));
      tmp___2 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
      if (tmp___2 != 0L) {
        warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcs_rport.c",
                           3434);
      } else {

      }
      ldv__builtin_expect(__ret_warn_on != 0, 0L);
      tmp___3 = __fswab32(rpsc2_acc->port_info[0].pid);
      __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 3436, (unsigned long long )tmp___3);
      tmp___4 = __fswab16((int )rpsc2_acc->port_info[0].speed);
      __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 3438, (unsigned long long )tmp___4);
      tmp___5 = __fswab16((int )rpsc2_acc->port_info[0].index);
      __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 3440, (unsigned long long )tmp___5);
      __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 3442, (unsigned long long )rpsc2_acc->port_info[0].type);
      if ((unsigned int )rpsc2_acc->port_info[0].speed == 0U) {
        (*(rpf->sm))((void *)rpf, 7);
        return;
      } else {

      }
      tmp___6 = __fswab16((int )rpsc2_acc->port_info[0].speed);
      rpf->rpsc_speed = fc_rpsc_operspeed_to_bfa_speed((enum fc_rpsc_op_speed )tmp___6);
      (*(rpf->sm))((void *)rpf, 5);
    } else {

    }
  } else {
    tmp___7 = bfa_fcxp_get_rspbuf(fcxp);
    ls_rjt = (struct fc_ls_rjt_s *)tmp___7;
    __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 3456, (unsigned long long )ls_rjt->reason_code);
    __bfa_trc((rport->fcs)->trcmod, __trc_fileno___8, 3457, (unsigned long long )ls_rjt->reason_code_expl);
    rport->stats.rpsc_rejects = rport->stats.rpsc_rejects + 1U;
    if ((unsigned int )ls_rjt->reason_code == 11U) {
      (*(rpf->sm))((void *)rpf, 6);
    } else {
      (*(rpf->sm))((void *)rpf, 7);
    }
  }
  return;
}
}
bool ldv_queue_work_on_447(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_3(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_delayed_work_on_448(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_3(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_work_on_449(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_3(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
void ldv_flush_workqueue_450(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
  flush_workqueue(ldv_func_arg1);
  call_and_disable_all_3(2);
  return;
}
}
bool ldv_queue_delayed_work_on_451(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_3(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
void ldv_mutex_lock_452(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_lock_lock(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_453(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_unlock_lock(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_454(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
int ldv_mutex_trylock_455(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
  tmp = mutex_trylock(ldv_func_arg1);
  ldv_func_res = tmp;
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
  return (tmp___0);
  return (ldv_func_res);
}
}
void ldv_mutex_unlock_456(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_457(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_unlock_i_mutex_of_inode(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_458(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_lock_i_mutex_of_inode(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
int ldv_scsi_add_host_with_dma_459(struct Scsi_Host *shost , struct device *dev ,
                                   struct device *dma_dev ) 
{ 
  ldv_func_ret_type___4 ldv_func_res ;
  int tmp ;

  {
  tmp = scsi_add_host_with_dma(shost, dev, dma_dev);
  ldv_func_res = tmp;
  if (ldv_func_res == 0) {
    ldv_state_variable_35 = 1;
    ldv_initialize_scsi_host_template_35();
  } else {

  }
  return (ldv_func_res);
}
}
__inline static long ldv__builtin_expect(long exp , long c ) ;
int ldv_mutex_trylock_485(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_483(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_486(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_487(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_482(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_484(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_488(struct mutex *ldv_func_arg1 ) ;
bool ldv_queue_work_on_477(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_work_on_479(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_delayed_work_on_478(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
bool ldv_queue_delayed_work_on_481(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
void ldv_flush_workqueue_480(struct workqueue_struct *ldv_func_arg1 ) ;
__inline static bool queue_work___4(struct workqueue_struct *wq , struct work_struct *work ) 
{ 
  bool tmp ;

  {
  tmp = ldv_queue_work_on_477(8192, wq, work);
  return (tmp);
}
}
int ldv_scsi_add_host_with_dma_489(struct Scsi_Host *shost , struct device *dev ,
                                   struct device *dma_dev ) ;
__inline static void wwn2str___4(char *wwn_str , u64 wwn ) 
{ 
  union __anonunion_w_281___3 w ;

  {
  w.wwn = wwn;
  sprintf(wwn_str, "%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x", (int )w.byte[0], (int )w.byte[1],
          (int )w.byte[2], (int )w.byte[3], (int )w.byte[4], (int )w.byte[5], (int )w.byte[6],
          (int )w.byte[7]);
  return;
}
}
struct bfa_itnim_s *bfa_itnim_create(struct bfa_s *bfa , struct bfa_rport_s *rport ,
                                     void *ditn ) ;
void bfa_itnim_delete(struct bfa_itnim_s *itnim ) ;
void bfa_itnim_online(struct bfa_itnim_s *itnim , enum bfa_boolean seq_rec ) ;
void bfa_itnim_offline(struct bfa_itnim_s *itnim ) ;
void bfa_cb_itnim_online(void *cbarg ) ;
void bfa_cb_itnim_offline(void *cb_arg ) ;
void bfa_cb_itnim_tov_begin(void *cb_arg ) ;
void bfa_cb_itnim_tov(void *cb_arg ) ;
void bfa_cb_itnim_sler(void *cb_arg ) ;
u16 fc_prli_build(struct fchs_s *fchs , void *pld , u32 d_id , u32 s_id , u16 ox_id ) ;
enum fc_parse_status fc_prli_rsp_parse(struct fc_prli_s *prli , int len ) ;
static int __trc_fileno___9  =    2052;
static void bfa_fcs_itnim_timeout(void *arg ) ;
static void bfa_fcs_itnim_free(struct bfa_fcs_itnim_s *itnim ) ;
static void bfa_fcs_itnim_send_prli(void *itnim_cbarg , struct bfa_fcxp_s *fcxp_alloced ) ;
static void bfa_fcs_itnim_prli_response(void *fcsarg , struct bfa_fcxp_s *fcxp , void *cbarg ,
                                        enum bfa_status req_status , u32 rsp_len ,
                                        u32 resid_len , struct fchs_s *rsp_fchs ) ;
static void bfa_fcs_itnim_aen_post(struct bfa_fcs_itnim_s *itnim , enum bfa_itnim_aen_event event ) ;
static void bfa_fcs_itnim_sm_offline(struct bfa_fcs_itnim_s *itnim , enum bfa_fcs_itnim_event event ) ;
static void bfa_fcs_itnim_sm_prli_send(struct bfa_fcs_itnim_s *itnim , enum bfa_fcs_itnim_event event ) ;
static void bfa_fcs_itnim_sm_prli(struct bfa_fcs_itnim_s *itnim , enum bfa_fcs_itnim_event event ) ;
static void bfa_fcs_itnim_sm_prli_retry(struct bfa_fcs_itnim_s *itnim , enum bfa_fcs_itnim_event event ) ;
static void bfa_fcs_itnim_sm_hcb_online(struct bfa_fcs_itnim_s *itnim , enum bfa_fcs_itnim_event event ) ;
static void bfa_fcs_itnim_sm_hal_rport_online(struct bfa_fcs_itnim_s *itnim , enum bfa_fcs_itnim_event event ) ;
static void bfa_fcs_itnim_sm_online(struct bfa_fcs_itnim_s *itnim , enum bfa_fcs_itnim_event event ) ;
static void bfa_fcs_itnim_sm_hcb_offline(struct bfa_fcs_itnim_s *itnim , enum bfa_fcs_itnim_event event ) ;
static void bfa_fcs_itnim_sm_initiator(struct bfa_fcs_itnim_s *itnim , enum bfa_fcs_itnim_event event ) ;
static struct bfa_sm_table_s itnim_sm_table[8U]  = 
  {      {(void (*)(void * , int  ))(& bfa_fcs_itnim_sm_offline), 0, 0}, 
        {(void (*)(void * , int  ))(& bfa_fcs_itnim_sm_prli_send), 1, 0}, 
        {(void (*)(void * , int  ))(& bfa_fcs_itnim_sm_prli), 2, 0}, 
        {(void (*)(void * , int  ))(& bfa_fcs_itnim_sm_prli_retry), 3, 0}, 
        {(void (*)(void * , int  ))(& bfa_fcs_itnim_sm_hcb_online), 4, 0}, 
        {(void (*)(void * , int  ))(& bfa_fcs_itnim_sm_online), 5, 0}, 
        {(void (*)(void * , int  ))(& bfa_fcs_itnim_sm_hcb_offline), 6, 0}, 
        {(void (*)(void * , int  ))(& bfa_fcs_itnim_sm_initiator), 7, 0}};
static void bfa_fcs_itnim_sm_offline(struct bfa_fcs_itnim_s *itnim , enum bfa_fcs_itnim_event event ) 
{ 


  {
  __bfa_trc((itnim->fcs)->trcmod, __trc_fileno___9, 81, (itnim->rport)->pwwn);
  __bfa_trc((itnim->fcs)->trcmod, __trc_fileno___9, 82, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 1U: 
  itnim->sm = (void (*)(void * , int  ))(& bfa_fcs_itnim_sm_prli_send);
  itnim->prli_retries = 0U;
  bfa_fcs_itnim_send_prli((void *)itnim, (struct bfa_fcxp_s *)0);
  goto ldv_48749;
  case 2U: 
  (*((itnim->rport)->sm))((void *)itnim->rport, 14);
  goto ldv_48749;
  case 9U: 
  itnim->sm = (void (*)(void * , int  ))(& bfa_fcs_itnim_sm_initiator);
  goto ldv_48749;
  case 10U: 
  bfa_fcs_itnim_free(itnim);
  goto ldv_48749;
  default: 
  __bfa_trc((itnim->fcs)->trcmod, __trc_fileno___9, 104, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcs_fcpim.c",
         104, (unsigned int )event);
  }
  ldv_48749: ;
  return;
}
}
static void bfa_fcs_itnim_sm_prli_send(struct bfa_fcs_itnim_s *itnim , enum bfa_fcs_itnim_event event ) 
{ 


  {
  __bfa_trc((itnim->fcs)->trcmod, __trc_fileno___9, 113, (itnim->rport)->pwwn);
  __bfa_trc((itnim->fcs)->trcmod, __trc_fileno___9, 114, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 3U: 
  itnim->sm = (void (*)(void * , int  ))(& bfa_fcs_itnim_sm_prli);
  goto ldv_48759;
  case 9U: 
  itnim->sm = (void (*)(void * , int  ))(& bfa_fcs_itnim_sm_initiator);
  bfa_fcxp_walloc_cancel((itnim->fcs)->bfa, & itnim->fcxp_wqe);
  (*((itnim->rport)->sm))((void *)itnim->rport, 21);
  goto ldv_48759;
  case 2U: 
  itnim->sm = (void (*)(void * , int  ))(& bfa_fcs_itnim_sm_offline);
  bfa_fcxp_walloc_cancel((itnim->fcs)->bfa, & itnim->fcxp_wqe);
  (*((itnim->rport)->sm))((void *)itnim->rport, 14);
  goto ldv_48759;
  case 10U: 
  itnim->sm = (void (*)(void * , int  ))(& bfa_fcs_itnim_sm_offline);
  bfa_fcxp_walloc_cancel((itnim->fcs)->bfa, & itnim->fcxp_wqe);
  bfa_fcs_itnim_free(itnim);
  goto ldv_48759;
  default: 
  __bfa_trc((itnim->fcs)->trcmod, __trc_fileno___9, 140, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcs_fcpim.c",
         140, (unsigned int )event);
  }
  ldv_48759: ;
  return;
}
}
static void bfa_fcs_itnim_sm_prli(struct bfa_fcs_itnim_s *itnim , enum bfa_fcs_itnim_event event ) 
{ 


  {
  __bfa_trc((itnim->fcs)->trcmod, __trc_fileno___9, 148, (itnim->rport)->pwwn);
  __bfa_trc((itnim->fcs)->trcmod, __trc_fileno___9, 149, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 4U: ;
  if ((unsigned int )(itnim->rport)->scsi_function == 1U) {
    itnim->sm = (void (*)(void * , int  ))(& bfa_fcs_itnim_sm_initiator);
  } else {
    itnim->sm = (void (*)(void * , int  ))(& bfa_fcs_itnim_sm_hal_rport_online);
  }
  (*((itnim->rport)->sm))((void *)itnim->rport, 21);
  goto ldv_48769;
  case 5U: 
  itnim->sm = (void (*)(void * , int  ))(& bfa_fcs_itnim_sm_prli_retry);
  bfa_timer_begin(& ((itnim->fcs)->bfa)->timer_mod, & itnim->timer, & bfa_fcs_itnim_timeout,
                  (void *)itnim, 2000U);
  goto ldv_48769;
  case 12U: 
  itnim->sm = (void (*)(void * , int  ))(& bfa_fcs_itnim_sm_offline);
  goto ldv_48769;
  case 2U: 
  itnim->sm = (void (*)(void * , int  ))(& bfa_fcs_itnim_sm_offline);
  bfa_fcxp_discard(itnim->fcxp);
  (*((itnim->rport)->sm))((void *)itnim->rport, 14);
  goto ldv_48769;
  case 9U: 
  itnim->sm = (void (*)(void * , int  ))(& bfa_fcs_itnim_sm_initiator);
  bfa_fcxp_discard(itnim->fcxp);
  (*((itnim->rport)->sm))((void *)itnim->rport, 21);
  goto ldv_48769;
  case 10U: 
  itnim->sm = (void (*)(void * , int  ))(& bfa_fcs_itnim_sm_offline);
  bfa_fcxp_discard(itnim->fcxp);
  bfa_fcs_itnim_free(itnim);
  goto ldv_48769;
  default: 
  __bfa_trc((itnim->fcs)->trcmod, __trc_fileno___9, 192, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcs_fcpim.c",
         192, (unsigned int )event);
  }
  ldv_48769: ;
  return;
}
}
static void bfa_fcs_itnim_sm_hal_rport_online(struct bfa_fcs_itnim_s *itnim , enum bfa_fcs_itnim_event event ) 
{ 


  {
  __bfa_trc((itnim->fcs)->trcmod, __trc_fileno___9, 200, (itnim->rport)->pwwn);
  __bfa_trc((itnim->fcs)->trcmod, __trc_fileno___9, 201, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 13U: ;
  if ((unsigned long )itnim->bfa_itnim == (unsigned long )((struct bfa_itnim_s *)0)) {
    itnim->bfa_itnim = bfa_itnim_create((itnim->fcs)->bfa, (itnim->rport)->bfa_rport,
                                        (void *)itnim);
  } else {

  }
  if ((unsigned long )itnim->bfa_itnim != (unsigned long )((struct bfa_itnim_s *)0)) {
    itnim->sm = (void (*)(void * , int  ))(& bfa_fcs_itnim_sm_hcb_online);
    bfa_itnim_online(itnim->bfa_itnim, itnim->seq_rec);
  } else {
    itnim->sm = (void (*)(void * , int  ))(& bfa_fcs_itnim_sm_offline);
    (*((itnim->rport)->sm))((void *)itnim->rport, 7);
  }
  goto ldv_48781;
  case 2U: 
  itnim->sm = (void (*)(void * , int  ))(& bfa_fcs_itnim_sm_offline);
  (*((itnim->rport)->sm))((void *)itnim->rport, 14);
  goto ldv_48781;
  case 10U: 
  itnim->sm = (void (*)(void * , int  ))(& bfa_fcs_itnim_sm_offline);
  bfa_fcs_itnim_free(itnim);
  goto ldv_48781;
  default: 
  __bfa_trc((itnim->fcs)->trcmod, __trc_fileno___9, 230, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcs_fcpim.c",
         230, (unsigned int )event);
  }
  ldv_48781: ;
  return;
}
}
static void bfa_fcs_itnim_sm_prli_retry(struct bfa_fcs_itnim_s *itnim , enum bfa_fcs_itnim_event event ) 
{ 


  {
  __bfa_trc((itnim->fcs)->trcmod, __trc_fileno___9, 238, (itnim->rport)->pwwn);
  __bfa_trc((itnim->fcs)->trcmod, __trc_fileno___9, 239, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 6U: ;
  if (itnim->prli_retries <= 4U) {
    itnim->prli_retries = itnim->prli_retries + 1U;
    __bfa_trc((itnim->fcs)->trcmod, __trc_fileno___9, 245, (unsigned long long )itnim->prli_retries);
    itnim->sm = (void (*)(void * , int  ))(& bfa_fcs_itnim_sm_prli_send);
    bfa_fcs_itnim_send_prli((void *)itnim, (struct bfa_fcxp_s *)0);
  } else {
    itnim->sm = (void (*)(void * , int  ))(& bfa_fcs_itnim_sm_offline);
    (*((itnim->rport)->sm))((void *)itnim->rport, 5);
  }
  goto ldv_48790;
  case 2U: 
  itnim->sm = (void (*)(void * , int  ))(& bfa_fcs_itnim_sm_offline);
  bfa_timer_stop(& itnim->timer);
  (*((itnim->rport)->sm))((void *)itnim->rport, 14);
  goto ldv_48790;
  case 9U: 
  itnim->sm = (void (*)(void * , int  ))(& bfa_fcs_itnim_sm_initiator);
  bfa_timer_stop(& itnim->timer);
  (*((itnim->rport)->sm))((void *)itnim->rport, 21);
  goto ldv_48790;
  case 10U: 
  itnim->sm = (void (*)(void * , int  ))(& bfa_fcs_itnim_sm_offline);
  bfa_timer_stop(& itnim->timer);
  bfa_fcs_itnim_free(itnim);
  goto ldv_48790;
  default: 
  __bfa_trc((itnim->fcs)->trcmod, __trc_fileno___9, 275, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcs_fcpim.c",
         275, (unsigned int )event);
  }
  ldv_48790: ;
  return;
}
}
static void bfa_fcs_itnim_sm_hcb_online(struct bfa_fcs_itnim_s *itnim , enum bfa_fcs_itnim_event event ) 
{ 
  struct bfad_s *bfad ;
  char lpwwn_buf[32U] ;
  char rpwwn_buf[32U] ;

  {
  bfad = (itnim->fcs)->bfad;
  __bfa_trc((itnim->fcs)->trcmod, __trc_fileno___9, 287, (itnim->rport)->pwwn);
  __bfa_trc((itnim->fcs)->trcmod, __trc_fileno___9, 288, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 8U: 
  itnim->sm = (void (*)(void * , int  ))(& bfa_fcs_itnim_sm_online);
  bfa_fcb_itnim_online(itnim->itnim_drv);
  wwn2str___4((char *)(& lpwwn_buf), ((itnim->rport)->port)->port_cfg.pwwn);
  wwn2str___4((char *)(& rpwwn_buf), (itnim->rport)->pwwn);
  if (bfa_log_level == 4 || (int )((signed char )*("\016" + 1)) <= 52) {
    dev_printk("\016", (struct device  const  *)(& (bfad->pcidev)->dev), "Target (WWN = %s) is online for initiator (WWN = %s)\n",
               (char *)(& rpwwn_buf), (char *)(& lpwwn_buf));
  } else {

  }
  bfa_fcs_itnim_aen_post(itnim, 1);
  goto ldv_48803;
  case 2U: 
  itnim->sm = (void (*)(void * , int  ))(& bfa_fcs_itnim_sm_hcb_offline);
  bfa_itnim_offline(itnim->bfa_itnim);
  goto ldv_48803;
  case 10U: 
  itnim->sm = (void (*)(void * , int  ))(& bfa_fcs_itnim_sm_offline);
  bfa_fcs_itnim_free(itnim);
  goto ldv_48803;
  default: 
  __bfa_trc((itnim->fcs)->trcmod, __trc_fileno___9, 313, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcs_fcpim.c",
         313, (unsigned int )event);
  }
  ldv_48803: ;
  return;
}
}
static void bfa_fcs_itnim_sm_online(struct bfa_fcs_itnim_s *itnim , enum bfa_fcs_itnim_event event ) 
{ 
  struct bfad_s *bfad ;
  char lpwwn_buf[32U] ;
  char rpwwn_buf[32U] ;
  enum bfa_boolean tmp ;

  {
  bfad = (itnim->fcs)->bfad;
  __bfa_trc((itnim->fcs)->trcmod, __trc_fileno___9, 325, (itnim->rport)->pwwn);
  __bfa_trc((itnim->fcs)->trcmod, __trc_fileno___9, 326, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 2U: 
  itnim->sm = (void (*)(void * , int  ))(& bfa_fcs_itnim_sm_hcb_offline);
  bfa_fcb_itnim_offline(itnim->itnim_drv);
  bfa_itnim_offline(itnim->bfa_itnim);
  wwn2str___4((char *)(& lpwwn_buf), ((itnim->rport)->port)->port_cfg.pwwn);
  wwn2str___4((char *)(& rpwwn_buf), (itnim->rport)->pwwn);
  tmp = bfa_fcs_lport_is_online((itnim->rport)->port);
  if ((unsigned int )tmp == 1U) {
    if (bfa_log_level == 4 || (int )((signed char )*("\v" + 1)) <= 52) {
      dev_printk("\v", (struct device  const  *)(& (bfad->pcidev)->dev), "Target (WWN = %s) connectivity lost for initiator (WWN = %s)\n",
                 (char *)(& rpwwn_buf), (char *)(& lpwwn_buf));
    } else {

    }
    bfa_fcs_itnim_aen_post(itnim, 3);
  } else {
    if (bfa_log_level == 4 || (int )((signed char )*("\016" + 1)) <= 52) {
      dev_printk("\016", (struct device  const  *)(& (bfad->pcidev)->dev), "Target (WWN = %s) offlined by initiator (WWN = %s)\n",
                 (char *)(& rpwwn_buf), (char *)(& lpwwn_buf));
    } else {

    }
    bfa_fcs_itnim_aen_post(itnim, 2);
  }
  goto ldv_48815;
  case 10U: 
  itnim->sm = (void (*)(void * , int  ))(& bfa_fcs_itnim_sm_offline);
  bfa_fcs_itnim_free(itnim);
  goto ldv_48815;
  default: 
  __bfa_trc((itnim->fcs)->trcmod, __trc_fileno___9, 354, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcs_fcpim.c",
         354, (unsigned int )event);
  }
  ldv_48815: ;
  return;
}
}
static void bfa_fcs_itnim_sm_hcb_offline(struct bfa_fcs_itnim_s *itnim , enum bfa_fcs_itnim_event event ) 
{ 


  {
  __bfa_trc((itnim->fcs)->trcmod, __trc_fileno___9, 362, (itnim->rport)->pwwn);
  __bfa_trc((itnim->fcs)->trcmod, __trc_fileno___9, 363, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 7U: 
  itnim->sm = (void (*)(void * , int  ))(& bfa_fcs_itnim_sm_offline);
  (*((itnim->rport)->sm))((void *)itnim->rport, 14);
  goto ldv_48823;
  case 10U: 
  itnim->sm = (void (*)(void * , int  ))(& bfa_fcs_itnim_sm_offline);
  bfa_fcs_itnim_free(itnim);
  goto ldv_48823;
  default: 
  __bfa_trc((itnim->fcs)->trcmod, __trc_fileno___9, 377, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcs_fcpim.c",
         377, (unsigned int )event);
  }
  ldv_48823: ;
  return;
}
}
static void bfa_fcs_itnim_sm_initiator(struct bfa_fcs_itnim_s *itnim , enum bfa_fcs_itnim_event event ) 
{ 


  {
  __bfa_trc((itnim->fcs)->trcmod, __trc_fileno___9, 390, (itnim->rport)->pwwn);
  __bfa_trc((itnim->fcs)->trcmod, __trc_fileno___9, 391, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 2U: 
  itnim->sm = (void (*)(void * , int  ))(& bfa_fcs_itnim_sm_offline);
  (*((itnim->rport)->sm))((void *)itnim->rport, 14);
  goto ldv_48831;
  case 1U: 
  (*((itnim->rport)->sm))((void *)itnim->rport, 21);
  goto ldv_48831;
  case 5U: ;
  case 9U: ;
  goto ldv_48831;
  case 10U: 
  itnim->sm = (void (*)(void * , int  ))(& bfa_fcs_itnim_sm_offline);
  bfa_fcs_itnim_free(itnim);
  goto ldv_48831;
  default: 
  __bfa_trc((itnim->fcs)->trcmod, __trc_fileno___9, 416, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcs_fcpim.c",
         416, (unsigned int )event);
  }
  ldv_48831: ;
  return;
}
}
static void bfa_fcs_itnim_aen_post(struct bfa_fcs_itnim_s *itnim , enum bfa_itnim_aen_event event ) 
{ 
  struct bfa_fcs_rport_s *rport ;
  struct bfad_s *bfad ;
  struct bfa_aen_entry_s *aen_entry ;
  unsigned long _flags ;
  raw_spinlock_t *tmp ;
  int tmp___0 ;
  struct bfa_fcs_lport_s *tmp___1 ;

  {
  rport = itnim->rport;
  bfad = (itnim->fcs)->bfad;
  if (((((rport->pid & 255U) << 16) | (rport->pid & 65280U)) | ((rport->pid & 16711680U) >> 16)) > 16773120U) {
    return;
  } else {

  }
  tmp = spinlock_check(& bfad->bfad_aen_spinlock);
  _flags = _raw_spin_lock_irqsave(tmp);
  tmp___0 = list_empty((struct list_head  const  *)(& bfad->free_aen_q));
  if (tmp___0 == 0) {
    *((struct list_head **)(& aen_entry)) = bfad->free_aen_q.next;
    ((*((struct list_head **)(& aen_entry)))->next)->prev = & bfad->free_aen_q;
    bfad->free_aen_q.next = (*((struct list_head **)(& aen_entry)))->next;
  } else {
    *((struct list_head **)(& aen_entry)) = (struct list_head *)0;
  }
  if ((unsigned long )aen_entry != (unsigned long )((struct bfa_aen_entry_s *)0)) {
    list_add_tail(& aen_entry->qe, & bfad->active_aen_q);
  } else {

  }
  spin_unlock_irqrestore(& bfad->bfad_aen_spinlock, _flags);
  if ((unsigned long )aen_entry == (unsigned long )((struct bfa_aen_entry_s *)0)) {
    return;
  } else {

  }
  aen_entry->aen_data.itnim.vf_id = ((rport->port)->fabric)->vf_id;
  tmp___1 = bfa_fcs_get_base_port(itnim->fcs);
  aen_entry->aen_data.itnim.ppwwn = tmp___1->port_cfg.pwwn;
  aen_entry->aen_data.itnim.lpwwn = (rport->port)->port_cfg.pwwn;
  aen_entry->aen_data.itnim.rpwwn = rport->pwwn;
  do_gettimeofday(& aen_entry->aen_tv);
  aen_entry->bfad_num = bfad->inst_no;
  (rport->fcs)->fcs_aen_seq = (rport->fcs)->fcs_aen_seq + 1;
  aen_entry->seq_num = (u32 )(rport->fcs)->fcs_aen_seq;
  aen_entry->aen_category = 5;
  aen_entry->aen_type = (u32 )event;
  if ((bfad->bfad_flags & 512U) != 0U) {
    queue_work___4((bfad->im)->drv_workq, & (bfad->im)->aen_im_notify_work);
  } else {

  }
  return;
}
}
static void bfa_fcs_itnim_send_prli(void *itnim_cbarg , struct bfa_fcxp_s *fcxp_alloced ) 
{ 
  struct bfa_fcs_itnim_s *itnim ;
  struct bfa_fcs_rport_s *rport ;
  struct bfa_fcs_lport_s *port ;
  struct fchs_s fchs ;
  struct bfa_fcxp_s *fcxp ;
  int len ;
  struct bfa_fcxp_s *tmp ;
  void *tmp___0 ;
  u16 tmp___1 ;

  {
  itnim = (struct bfa_fcs_itnim_s *)itnim_cbarg;
  rport = itnim->rport;
  port = rport->port;
  __bfa_trc((itnim->fcs)->trcmod, __trc_fileno___9, 457, (itnim->rport)->pwwn);
  if ((unsigned long )fcxp_alloced == (unsigned long )((struct bfa_fcxp_s *)0)) {
    tmp = bfa_fcxp_req_rsp_alloc((void *)0, (port->fcs)->bfa, 0, 0, (u64 (*)(void * ,
                                                                             int  ))0,
                                 (u32 (*)(void * , int  ))0, (u64 (*)(void * , int  ))0,
                                 (u32 (*)(void * , int  ))0, 1);
    fcxp = tmp;
  } else {
    fcxp = fcxp_alloced;
  }
  if ((unsigned long )fcxp == (unsigned long )((struct bfa_fcxp_s *)0)) {
    itnim->stats.fcxp_alloc_wait = itnim->stats.fcxp_alloc_wait + 1U;
    bfa_fcxp_req_rsp_alloc_wait((port->fcs)->bfa, & itnim->fcxp_wqe, & bfa_fcs_itnim_send_prli,
                                (void *)itnim, (void *)0, 0, 0, (u64 (*)(void * ,
                                                                         int  ))0,
                                (u32 (*)(void * , int  ))0, (u64 (*)(void * , int  ))0,
                                (u32 (*)(void * , int  ))0, 1);
    return;
  } else {

  }
  itnim->fcxp = fcxp;
  tmp___0 = bfa_fcxp_get_reqbuf(fcxp);
  tmp___1 = fc_prli_build(& fchs, tmp___0, (itnim->rport)->pid, port->pid, 0);
  len = (int )tmp___1;
  bfa_fcxp_send(fcxp, rport->bfa_rport, (int )(port->fabric)->vf_id, (int )port->lp_tag,
                0, 8, (u32 )len, & fchs, & bfa_fcs_itnim_prli_response, (void *)itnim,
                2112U, 20);
  itnim->stats.prli_sent = itnim->stats.prli_sent + 1U;
  (*(itnim->sm))((void *)itnim, 3);
  return;
}
}
static void bfa_fcs_itnim_prli_response(void *fcsarg , struct bfa_fcxp_s *fcxp , void *cbarg ,
                                        enum bfa_status req_status , u32 rsp_len ,
                                        u32 resid_len , struct fchs_s *rsp_fchs ) 
{ 
  struct bfa_fcs_itnim_s *itnim ;
  struct fc_els_cmd_s *els_cmd ;
  struct fc_prli_s *prli_resp ;
  struct fc_ls_rjt_s *ls_rjt ;
  struct fc_prli_params_s *sparams ;
  void *tmp ;
  enum fc_parse_status tmp___0 ;
  void *tmp___1 ;

  {
  itnim = (struct bfa_fcs_itnim_s *)cbarg;
  __bfa_trc((itnim->fcs)->trcmod, __trc_fileno___9, 492, (unsigned long long )req_status);
  if ((unsigned int )req_status != 0U) {
    itnim->stats.prli_rsp_err = itnim->stats.prli_rsp_err + 1U;
    (*(itnim->sm))((void *)itnim, 5);
    return;
  } else {

  }
  tmp = bfa_fcxp_get_rspbuf(fcxp);
  els_cmd = (struct fc_els_cmd_s *)tmp;
  if ((unsigned int )els_cmd->els_code == 2U) {
    prli_resp = (struct fc_prli_s *)els_cmd;
    tmp___0 = fc_prli_rsp_parse(prli_resp, (int )rsp_len);
    if ((unsigned int )tmp___0 != 0U) {
      __bfa_trc((itnim->fcs)->trcmod, __trc_fileno___9, 509, (unsigned long long )rsp_len);
      if ((unsigned int )*((unsigned char *)prli_resp + 19UL) != 0U) {
        __bfa_trc((itnim->fcs)->trcmod, __trc_fileno___9, 515, (unsigned long long )prli_resp->parampage.type);
        (itnim->rport)->scsi_function = 1;
        itnim->stats.prli_rsp_acc = itnim->stats.prli_rsp_acc + 1U;
        itnim->stats.initiator = itnim->stats.initiator + 1U;
        (*(itnim->sm))((void *)itnim, 4);
        return;
      } else {

      }
      itnim->stats.prli_rsp_parse_err = itnim->stats.prli_rsp_parse_err + 1U;
      return;
    } else {

    }
    (itnim->rport)->scsi_function = 2;
    sparams = & prli_resp->parampage.servparams;
    itnim->seq_rec = (enum bfa_boolean )sparams->retry;
    itnim->rec_support = (enum bfa_boolean )sparams->rec_support;
    itnim->task_retry_id = (enum bfa_boolean )sparams->task_retry_id;
    itnim->conf_comp = (enum bfa_boolean )sparams->confirm;
    itnim->stats.prli_rsp_acc = itnim->stats.prli_rsp_acc + 1U;
    (*(itnim->sm))((void *)itnim, 4);
  } else {
    tmp___1 = bfa_fcxp_get_rspbuf(fcxp);
    ls_rjt = (struct fc_ls_rjt_s *)tmp___1;
    __bfa_trc((itnim->fcs)->trcmod, __trc_fileno___9, 541, (unsigned long long )ls_rjt->reason_code);
    __bfa_trc((itnim->fcs)->trcmod, __trc_fileno___9, 542, (unsigned long long )ls_rjt->reason_code_expl);
    itnim->stats.prli_rsp_rjt = itnim->stats.prli_rsp_rjt + 1U;
    if ((unsigned int )ls_rjt->reason_code == 11U) {
      (*(itnim->sm))((void *)itnim, 12);
      return;
    } else {

    }
    (*(itnim->sm))((void *)itnim, 5);
  }
  return;
}
}
static void bfa_fcs_itnim_timeout(void *arg ) 
{ 
  struct bfa_fcs_itnim_s *itnim ;

  {
  itnim = (struct bfa_fcs_itnim_s *)arg;
  itnim->stats.timeout = itnim->stats.timeout + 1U;
  (*(itnim->sm))((void *)itnim, 6);
  return;
}
}
static void bfa_fcs_itnim_free(struct bfa_fcs_itnim_s *itnim ) 
{ 


  {
  if ((unsigned long )itnim->bfa_itnim != (unsigned long )((struct bfa_itnim_s *)0)) {
    bfa_itnim_delete(itnim->bfa_itnim);
    itnim->bfa_itnim = (struct bfa_itnim_s *)0;
  } else {

  }
  bfa_fcb_itnim_free((itnim->fcs)->bfad, itnim->itnim_drv);
  return;
}
}
struct bfa_fcs_itnim_s *bfa_fcs_itnim_create(struct bfa_fcs_rport_s *rport ) 
{ 
  struct bfa_fcs_lport_s *port ;
  struct bfa_fcs_itnim_s *itnim ;
  struct bfad_itnim_s *itnim_drv ;

  {
  port = rport->port;
  bfa_fcb_itnim_alloc((port->fcs)->bfad, & itnim, & itnim_drv);
  if ((unsigned long )itnim == (unsigned long )((struct bfa_fcs_itnim_s *)0)) {
    __bfa_trc((port->fcs)->trcmod, __trc_fileno___9, 596, rport->pwwn);
    return ((struct bfa_fcs_itnim_s *)0);
  } else {

  }
  itnim->rport = rport;
  itnim->fcs = rport->fcs;
  itnim->itnim_drv = itnim_drv;
  itnim->bfa_itnim = (struct bfa_itnim_s *)0;
  itnim->seq_rec = 0;
  itnim->rec_support = 0;
  itnim->conf_comp = 0;
  itnim->task_retry_id = 0;
  itnim->sm = (void (*)(void * , int  ))(& bfa_fcs_itnim_sm_offline);
  return (itnim);
}
}
void bfa_fcs_itnim_delete(struct bfa_fcs_itnim_s *itnim ) 
{ 


  {
  __bfa_trc((itnim->fcs)->trcmod, __trc_fileno___9, 629, (unsigned long long )(itnim->rport)->pid);
  (*(itnim->sm))((void *)itnim, 10);
  return;
}
}
void bfa_fcs_itnim_brp_online(struct bfa_fcs_itnim_s *itnim ) 
{ 


  {
  itnim->stats.onlines = itnim->stats.onlines + 1U;
  if ((((((itnim->rport)->pid & 255U) << 16) | ((itnim->rport)->pid & 65280U)) | (((itnim->rport)->pid & 16711680U) >> 16)) <= 16773120U) {
    (*(itnim->sm))((void *)itnim, 13);
  } else {

  }
  return;
}
}
void bfa_fcs_itnim_rport_offline(struct bfa_fcs_itnim_s *itnim ) 
{ 


  {
  itnim->stats.offlines = itnim->stats.offlines + 1U;
  (*(itnim->sm))((void *)itnim, 2);
  return;
}
}
void bfa_fcs_itnim_is_initiator(struct bfa_fcs_itnim_s *itnim ) 
{ 


  {
  __bfa_trc((itnim->fcs)->trcmod, __trc_fileno___9, 662, (unsigned long long )(itnim->rport)->pid);
  itnim->stats.initiator = itnim->stats.initiator + 1U;
  (*(itnim->sm))((void *)itnim, 9);
  return;
}
}
enum bfa_status bfa_fcs_itnim_get_online_state(struct bfa_fcs_itnim_s *itnim ) 
{ 
  int tmp ;

  {
  __bfa_trc((itnim->fcs)->trcmod, __trc_fileno___9, 673, (unsigned long long )(itnim->rport)->pid);
  tmp = bfa_sm_to_state((struct bfa_sm_table_s *)(& itnim_sm_table), itnim->sm);
  switch (tmp) {
  case 5: ;
  case 7: ;
  return (0);
  default: ;
  return (52);
  }
}
}
void bfa_cb_itnim_online(void *cbarg ) 
{ 
  struct bfa_fcs_itnim_s *itnim ;

  {
  itnim = (struct bfa_fcs_itnim_s *)cbarg;
  __bfa_trc((itnim->fcs)->trcmod, __trc_fileno___9, 692, (itnim->rport)->pwwn);
  (*(itnim->sm))((void *)itnim, 8);
  return;
}
}
void bfa_cb_itnim_offline(void *cb_arg ) 
{ 
  struct bfa_fcs_itnim_s *itnim ;

  {
  itnim = (struct bfa_fcs_itnim_s *)cb_arg;
  __bfa_trc((itnim->fcs)->trcmod, __trc_fileno___9, 704, (itnim->rport)->pwwn);
  (*(itnim->sm))((void *)itnim, 7);
  return;
}
}
void bfa_cb_itnim_tov_begin(void *cb_arg ) 
{ 
  struct bfa_fcs_itnim_s *itnim ;

  {
  itnim = (struct bfa_fcs_itnim_s *)cb_arg;
  __bfa_trc((itnim->fcs)->trcmod, __trc_fileno___9, 717, (itnim->rport)->pwwn);
  return;
}
}
void bfa_cb_itnim_tov(void *cb_arg ) 
{ 
  struct bfa_fcs_itnim_s *itnim ;
  struct bfad_itnim_s *itnim_drv ;

  {
  itnim = (struct bfa_fcs_itnim_s *)cb_arg;
  itnim_drv = itnim->itnim_drv;
  __bfa_trc((itnim->fcs)->trcmod, __trc_fileno___9, 729, (itnim->rport)->pwwn);
  itnim_drv->state = 4;
  return;
}
}
void bfa_cb_itnim_sler(void *cb_arg ) 
{ 
  struct bfa_fcs_itnim_s *itnim ;

  {
  itnim = (struct bfa_fcs_itnim_s *)cb_arg;
  itnim->stats.sler = itnim->stats.sler + 1U;
  __bfa_trc((itnim->fcs)->trcmod, __trc_fileno___9, 746, (itnim->rport)->pwwn);
  (*((itnim->rport)->sm))((void *)itnim->rport, 5);
  return;
}
}
struct bfa_fcs_itnim_s *bfa_fcs_itnim_lookup(struct bfa_fcs_lport_s *port , wwn_t rpwwn ) 
{ 
  struct bfa_fcs_rport_s *rport ;
  int __ret_warn_on ;
  long tmp ;

  {
  rport = bfa_fcs_rport_lookup(port, rpwwn);
  if ((unsigned long )rport == (unsigned long )((struct bfa_fcs_rport_s *)0)) {
    return ((struct bfa_fcs_itnim_s *)0);
  } else {

  }
  __ret_warn_on = (unsigned long )rport->itnim == (unsigned long )((struct bfa_fcs_itnim_s *)0);
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcs_fcpim.c",
                       759);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  return (rport->itnim);
}
}
enum bfa_status bfa_fcs_itnim_attr_get(struct bfa_fcs_lport_s *port , wwn_t rpwwn ,
                                       struct bfa_itnim_attr_s *attr ) 
{ 
  struct bfa_fcs_itnim_s *itnim ;
  int tmp ;

  {
  itnim = (struct bfa_fcs_itnim_s *)0;
  itnim = bfa_fcs_itnim_lookup(port, rpwwn);
  if ((unsigned long )itnim == (unsigned long )((struct bfa_fcs_itnim_s *)0)) {
    return (52);
  } else {

  }
  tmp = bfa_sm_to_state((struct bfa_sm_table_s *)(& itnim_sm_table), itnim->sm);
  attr->state = (enum bfa_itnim_state )tmp;
  attr->retry = (u8 )itnim->seq_rec;
  attr->rec_support = (u8 )itnim->rec_support;
  attr->conf_comp = (u8 )itnim->conf_comp;
  attr->task_retry_id = (u8 )itnim->task_retry_id;
  return (0);
}
}
enum bfa_status bfa_fcs_itnim_stats_get(struct bfa_fcs_lport_s *port , wwn_t rpwwn ,
                                        struct bfa_itnim_stats_s *stats ) 
{ 
  struct bfa_fcs_itnim_s *itnim ;
  int __ret_warn_on ;
  long tmp ;

  {
  itnim = (struct bfa_fcs_itnim_s *)0;
  __ret_warn_on = (unsigned long )port == (unsigned long )((struct bfa_fcs_lport_s *)0);
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcs_fcpim.c",
                       788);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  itnim = bfa_fcs_itnim_lookup(port, rpwwn);
  if ((unsigned long )itnim == (unsigned long )((struct bfa_fcs_itnim_s *)0)) {
    return (52);
  } else {

  }
  memcpy((void *)stats, (void const   *)(& itnim->stats), 48UL);
  return (0);
}
}
enum bfa_status bfa_fcs_itnim_stats_clear(struct bfa_fcs_lport_s *port , wwn_t rpwwn ) 
{ 
  struct bfa_fcs_itnim_s *itnim ;
  int __ret_warn_on ;
  long tmp ;

  {
  itnim = (struct bfa_fcs_itnim_s *)0;
  __ret_warn_on = (unsigned long )port == (unsigned long )((struct bfa_fcs_lport_s *)0);
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcs_fcpim.c",
                       805);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  itnim = bfa_fcs_itnim_lookup(port, rpwwn);
  if ((unsigned long )itnim == (unsigned long )((struct bfa_fcs_itnim_s *)0)) {
    return (52);
  } else {

  }
  memset((void *)(& itnim->stats), 0, 48UL);
  return (0);
}
}
void bfa_fcs_fcpim_uf_recv(struct bfa_fcs_itnim_s *itnim , struct fchs_s *fchs , u16 len ) 
{ 
  struct fc_els_cmd_s *els_cmd ;
  int __ret_warn_on ;
  long tmp ;

  {
  __bfa_trc((itnim->fcs)->trcmod, __trc_fileno___9, 822, (unsigned long long )fchs->type);
  if ((unsigned int )fchs->type != 1U) {
    return;
  } else {

  }
  els_cmd = (struct fc_els_cmd_s *)fchs + 1U;
  __bfa_trc((itnim->fcs)->trcmod, __trc_fileno___9, 829, (unsigned long long )els_cmd->els_code);
  switch ((int )els_cmd->els_code) {
  case 33: 
  bfa_fcs_rport_prlo(itnim->rport, (int )fchs->ox_id);
  goto ldv_48959;
  default: 
  __ret_warn_on = 1;
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcs_fcpim.c",
                       837);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  }
  ldv_48959: ;
  return;
}
}
bool ldv_queue_work_on_477(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_3(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_delayed_work_on_478(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_3(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_work_on_479(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_3(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
void ldv_flush_workqueue_480(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
  flush_workqueue(ldv_func_arg1);
  call_and_disable_all_3(2);
  return;
}
}
bool ldv_queue_delayed_work_on_481(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_3(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
void ldv_mutex_lock_482(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_lock_lock(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_483(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_unlock_lock(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_484(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
int ldv_mutex_trylock_485(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
  tmp = mutex_trylock(ldv_func_arg1);
  ldv_func_res = tmp;
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
  return (tmp___0);
  return (ldv_func_res);
}
}
void ldv_mutex_unlock_486(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_487(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_unlock_i_mutex_of_inode(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_488(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_lock_i_mutex_of_inode(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
int ldv_scsi_add_host_with_dma_489(struct Scsi_Host *shost , struct device *dev ,
                                   struct device *dma_dev ) 
{ 
  ldv_func_ret_type___4 ldv_func_res ;
  int tmp ;

  {
  tmp = scsi_add_host_with_dma(shost, dev, dma_dev);
  ldv_func_res = tmp;
  if (ldv_func_res == 0) {
    ldv_state_variable_35 = 1;
    ldv_initialize_scsi_host_template_35();
  } else {

  }
  return (ldv_func_res);
}
}
int ldv_mutex_trylock_515(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_513(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_516(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_517(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_512(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_514(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_518(struct mutex *ldv_func_arg1 ) ;
bool ldv_queue_work_on_507(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_work_on_509(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_delayed_work_on_508(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
bool ldv_queue_delayed_work_on_511(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
void ldv_flush_workqueue_510(struct workqueue_struct *ldv_func_arg1 ) ;
int ldv_scsi_add_host_with_dma_519(struct Scsi_Host *shost , struct device *dev ,
                                   struct device *dma_dev ) ;
u16 fc_flogi_build(struct fchs_s *fchs , struct fc_logi_s *flogi , u32 s_id , u16 ox_id ,
                   wwn_t port_name , wwn_t node_name , u16 pdu_size , u8 set_npiv ,
                   u8 set_auth , u16 local_bb_credits ) ;
u16 fc_fdisc_build(struct fchs_s *fchs , struct fc_logi_s *flogi , u32 s_id , u16 ox_id ,
                   wwn_t port_name , wwn_t node_name , u16 pdu_size ) ;
u16 fc_abts_build(struct fchs_s *fchs , u32 d_id , u32 s_id , u16 ox_id ) ;
enum fc_parse_status fc_abts_rsp_parse(struct fchs_s *fchs , int len ) ;
u16 fc_rrq_build(struct fchs_s *fchs , struct fc_rrq_s *rrq , u32 d_id , u32 s_id ,
                 u16 ox_id , u16 rrq_oxid ) ;
enum fc_parse_status fc_rrq_rsp_parse(struct fchs_s *fchs , int len ) ;
u16 fc_rftid_build_sol(struct fchs_s *fchs , void *pyld , u32 s_id , u16 ox_id , u8 *fc4_bitmap ,
                       u32 bitmap_size ) ;
enum fc_parse_status fc_adisc_parse(struct fchs_s *fchs , void *pld , u32 host_dap ,
                                    wwn_t node_name , wwn_t port_name ) ;
u16 fc_rnid_build(struct fchs_s *fchs , struct fc_rnid_cmd_s *rnid , u32 d_id , u32 s_id ,
                  u16 ox_id , u32 data_format ) ;
u16 fc_rpsc_build(struct fchs_s *fchs , struct fc_rpsc_cmd_s *rpsc , u32 d_id , u32 s_id ,
                  u16 ox_id ) ;
u16 fc_rpnid_build(struct fchs_s *fchs , void *pyld , u32 s_id , u32 port_id , wwn_t port_name ) ;
u16 fc_rcsid_build(struct fchs_s *fchs , void *pyld , u32 s_id , u32 port_id , u32 cos ) ;
u16 fc_rptid_build(struct fchs_s *fchs , void *pyld , u32 s_id , u32 port_id , u8 port_type ) ;
u16 fc_ganxt_build(struct fchs_s *fchs , void *pyld , u32 s_id , u32 port_id ) ;
void fc_els_req_build(struct fchs_s *fchs , u32 d_id , u32 s_id , __be16 ox_id ) ;
enum fc_parse_status fc_els_rsp_parse(struct fchs_s *fchs , int len ) ;
enum fc_parse_status fc_plogi_rsp_parse(struct fchs_s *fchs , int len , wwn_t port_name ) ;
enum fc_parse_status fc_prli_parse(struct fc_prli_s *prli ) ;
enum fc_parse_status fc_pdisc_parse(struct fchs_s *fchs , wwn_t node_name , wwn_t port_name ) ;
int fc_logout_params_pages(struct fchs_s *fc_frame , u8 els_code ) ;
u16 fc_tprlo_acc_build(struct fchs_s *fchs , struct fc_tprlo_acc_s *tprlo_acc , u32 d_id ,
                       u32 s_id , __be16 ox_id , int num_pages ) ;
u16 fc_logo_rsp_parse(struct fchs_s *fchs , int len ) ;
u16 fc_pdisc_build(struct fchs_s *fchs , u32 d_id , u32 s_id , u16 ox_id , wwn_t port_name ,
                   wwn_t node_name , u16 pdu_size ) ;
u16 fc_pdisc_rsp_parse(struct fchs_s *fchs , int len , wwn_t port_name ) ;
u16 fc_prlo_build(struct fchs_s *fchs , u32 d_id , u32 s_id , u16 ox_id , int num_pages ) ;
u16 fc_prlo_rsp_parse(struct fchs_s *fchs , int len ) ;
u16 fc_tprlo_build(struct fchs_s *fchs , u32 d_id , u32 s_id , u16 ox_id , int num_pages ,
                   enum fc_tprlo_type tprlo_type , u32 tpr_id ) ;
u16 fc_tprlo_rsp_parse(struct fchs_s *fchs , int len ) ;
u16 fc_ba_rjt_build(struct fchs_s *fchs , u32 d_id , u32 s_id , __be16 ox_id , u32 reason_code ,
                    u32 reason_expl ) ;
u16 fc_gnnid_build(struct fchs_s *fchs , void *pyld , u32 s_id , u16 ox_id , u32 port_id ) ;
u16 fc_ct_rsp_parse(struct ct_hdr_s *cthdr ) ;
u16 fc_rscn_build(struct fchs_s *fchs , struct fc_rscn_pl_s *rscn , u32 s_id , u16 ox_id ) ;
static void fc_els_rsp_build(struct fchs_s *fchs , u32 d_id , u32 s_id , __be16 ox_id ) ;
static void fc_bls_rsp_build(struct fchs_s *fchs , u32 d_id , u32 s_id , __be16 ox_id ) ;
static struct fchs_s fc_els_req_tmpl  ;
static struct fchs_s fc_els_rsp_tmpl  ;
static struct fchs_s fc_bls_req_tmpl  ;
static struct fchs_s fc_bls_rsp_tmpl  ;
static struct fc_ba_acc_s ba_acc_tmpl  ;
static struct fc_logi_s plogi_tmpl  ;
static struct fc_prli_s prli_tmpl  ;
static struct fc_rrq_s rrq_tmpl  ;
static struct fchs_s fcp_fchs_tmpl  ;
void fcbuild_init(void) 
{ 


  {
  fc_els_req_tmpl.routing = 2U;
  fc_els_req_tmpl.cat_info = 2U;
  fc_els_req_tmpl.type = 1U;
  fc_els_req_tmpl.f_ctl = 41U;
  fc_els_req_tmpl.rx_id = 65535U;
  fc_els_rsp_tmpl.routing = 2U;
  fc_els_rsp_tmpl.cat_info = 3U;
  fc_els_rsp_tmpl.type = 1U;
  fc_els_rsp_tmpl.f_ctl = 153U;
  fc_els_rsp_tmpl.rx_id = 65535U;
  fc_bls_req_tmpl.routing = 8U;
  fc_bls_req_tmpl.type = 0U;
  fc_bls_req_tmpl.f_ctl = 9U;
  fc_bls_req_tmpl.rx_id = 65535U;
  fc_bls_rsp_tmpl.routing = 8U;
  fc_bls_rsp_tmpl.cat_info = 4U;
  fc_bls_rsp_tmpl.type = 0U;
  fc_bls_rsp_tmpl.f_ctl = 153U;
  fc_bls_rsp_tmpl.rx_id = 65535U;
  ba_acc_tmpl.seq_id_valid = 0U;
  ba_acc_tmpl.low_seq_cnt = 0U;
  ba_acc_tmpl.high_seq_cnt = 65535U;
  plogi_tmpl.csp.verhi = 32U;
  plogi_tmpl.csp.verlo = 9U;
  plogi_tmpl.csp.ciro = 1U;
  plogi_tmpl.csp.cisc = 0U;
  plogi_tmpl.csp.altbbcred = 0U;
  plogi_tmpl.csp.conseq = 65280U;
  plogi_tmpl.csp.ro_bitmap = 512U;
  plogi_tmpl.csp.e_d_tov = 3490119680U;
  plogi_tmpl.class3.class_valid = 1U;
  plogi_tmpl.class3.sequential = 1U;
  plogi_tmpl.class3.conseq = 255U;
  plogi_tmpl.class3.ospx = 1U;
  prli_tmpl.command = 32U;
  prli_tmpl.pglen = 16U;
  prli_tmpl.pagebytes = 5120U;
  prli_tmpl.parampage.type = 8U;
  prli_tmpl.parampage.imagepair = 1U;
  prli_tmpl.parampage.servparams.rxrdisab = 1U;
  rrq_tmpl.els_cmd.els_code = 18U;
  fcp_fchs_tmpl.routing = 0U;
  fcp_fchs_tmpl.cat_info = 6U;
  fcp_fchs_tmpl.type = 8U;
  fcp_fchs_tmpl.f_ctl = 41U;
  fcp_fchs_tmpl.seq_id = 1U;
  fcp_fchs_tmpl.rx_id = 65535U;
  return;
}
}
static void fc_gs_fchdr_build(struct fchs_s *fchs , u32 d_id , u32 s_id , u32 ox_id ) 
{ 
  __u16 tmp ;

  {
  memset((void *)fchs, 0, 24UL);
  fchs->routing = 0U;
  fchs->cat_info = 2U;
  fchs->type = 32U;
  fchs->f_ctl = 41U;
  fchs->rx_id = 65535U;
  fchs->d_id = d_id;
  fchs->s_id = s_id;
  tmp = __fswab16((int )((__u16 )ox_id));
  fchs->ox_id = tmp;
  return;
}
}
static void fc_gsresp_fchdr_build(struct fchs_s *fchs , u32 d_id , u32 s_id , u16 ox_id ) 
{ 


  {
  memset((void *)fchs, 0, 24UL);
  fchs->routing = 0U;
  fchs->cat_info = 3U;
  fchs->type = 32U;
  fchs->f_ctl = 153U;
  fchs->d_id = d_id;
  fchs->s_id = s_id;
  fchs->ox_id = ox_id;
  return;
}
}
void fc_els_req_build(struct fchs_s *fchs , u32 d_id , u32 s_id , __be16 ox_id ) 
{ 
  __u16 tmp ;

  {
  memcpy((void *)fchs, (void const   *)(& fc_els_req_tmpl), 24UL);
  fchs->d_id = d_id;
  fchs->s_id = s_id;
  tmp = __fswab16((int )ox_id);
  fchs->ox_id = tmp;
  return;
}
}
static void fc_els_rsp_build(struct fchs_s *fchs , u32 d_id , u32 s_id , __be16 ox_id ) 
{ 


  {
  memcpy((void *)fchs, (void const   *)(& fc_els_rsp_tmpl), 24UL);
  fchs->d_id = d_id;
  fchs->s_id = s_id;
  fchs->ox_id = ox_id;
  return;
}
}
enum fc_parse_status fc_els_rsp_parse(struct fchs_s *fchs , int len ) 
{ 
  struct fc_els_cmd_s *els_cmd ;
  struct fc_ls_rjt_s *ls_rjt ;

  {
  els_cmd = (struct fc_els_cmd_s *)fchs + 1U;
  ls_rjt = (struct fc_ls_rjt_s *)els_cmd;
  len = len;
  switch ((int )els_cmd->els_code) {
  case 1: ;
  if ((unsigned int )ls_rjt->reason_code == 5U) {
    return (2);
  } else {
    return (1);
  }
  case 2: ;
  return (0);
  }
  return (0);
}
}
static void fc_bls_rsp_build(struct fchs_s *fchs , u32 d_id , u32 s_id , __be16 ox_id ) 
{ 


  {
  memcpy((void *)fchs, (void const   *)(& fc_bls_rsp_tmpl), 24UL);
  fchs->d_id = d_id;
  fchs->s_id = s_id;
  fchs->ox_id = ox_id;
  return;
}
}
static u16 fc_plogi_x_build(struct fchs_s *fchs , void *pld , u32 d_id , u32 s_id ,
                            __be16 ox_id , wwn_t port_name , wwn_t node_name , u16 pdu_size ,
                            u16 bb_cr , u8 els_code ) 
{ 
  struct fc_logi_s *plogi ;
  unsigned short tmp ;
  __u16 tmp___0 ;
  __u16 tmp___1 ;

  {
  plogi = (struct fc_logi_s *)pld;
  memcpy((void *)plogi, (void const   *)(& plogi_tmpl), 116UL);
  if ((unsigned int )bb_cr == 0U) {
    plogi->csp.altbbcred = 1U;
  } else {

  }
  plogi->els_cmd.els_code = els_code;
  if ((unsigned int )els_code == 3U) {
    fc_els_req_build(fchs, d_id, s_id, (int )ox_id);
  } else {
    fc_els_rsp_build(fchs, d_id, s_id, (int )ox_id);
  }
  tmp___0 = __fswab16((int )pdu_size);
  tmp = tmp___0;
  plogi->class3.rxsz = tmp;
  plogi->csp.rxsz = tmp;
  tmp___1 = __fswab16((int )bb_cr);
  plogi->csp.bbcred = tmp___1;
  memcpy((void *)(& plogi->port_name), (void const   *)(& port_name), 8UL);
  memcpy((void *)(& plogi->node_name), (void const   *)(& node_name), 8UL);
  return (116U);
}
}
u16 fc_flogi_build(struct fchs_s *fchs , struct fc_logi_s *flogi , u32 s_id , u16 ox_id ,
                   wwn_t port_name , wwn_t node_name , u16 pdu_size , u8 set_npiv ,
                   u8 set_auth , u16 local_bb_credits ) 
{ 
  u32 d_id ;
  __be32 *vvl_info ;
  unsigned short tmp ;
  __u16 tmp___0 ;
  __u16 tmp___1 ;

  {
  d_id = 16711679U;
  memcpy((void *)flogi, (void const   *)(& plogi_tmpl), 116UL);
  flogi->els_cmd.els_code = 4U;
  fc_els_req_build(fchs, d_id, s_id, (int )ox_id);
  tmp___0 = __fswab16((int )pdu_size);
  tmp = tmp___0;
  flogi->class3.rxsz = tmp;
  flogi->csp.rxsz = tmp;
  flogi->port_name = port_name;
  flogi->node_name = node_name;
  flogi->csp.ciro = set_npiv;
  flogi->csp.security = set_auth;
  tmp___1 = __fswab16((int )local_bb_credits);
  flogi->csp.bbcred = tmp___1;
  vvl_info = (__be32 *)(& flogi->vvl);
  flogi->csp.npiv_supp = 1U;
  *vvl_info = 1145262658U;
  return (116U);
}
}
u16 fc_flogi_acc_build(struct fchs_s *fchs , struct fc_logi_s *flogi , u32 s_id ,
                       __be16 ox_id , wwn_t port_name , wwn_t node_name , u16 pdu_size ,
                       u16 local_bb_credits , u8 bb_scn ) 
{ 
  u32 d_id ;
  u16 bbscn_rxsz ;
  __u16 tmp ;
  __u16 tmp___0 ;
  __u16 tmp___1 ;

  {
  d_id = 0U;
  bbscn_rxsz = (u16 )((int )((short )((int )bb_scn << 12)) | (int )((short )pdu_size));
  memcpy((void *)flogi, (void const   *)(& plogi_tmpl), 116UL);
  fc_els_rsp_build(fchs, d_id, s_id, (int )ox_id);
  flogi->els_cmd.els_code = 2U;
  tmp = __fswab16((int )pdu_size);
  flogi->class3.rxsz = tmp;
  tmp___0 = __fswab16((int )bbscn_rxsz);
  flogi->csp.rxsz = tmp___0;
  flogi->port_name = port_name;
  flogi->node_name = node_name;
  tmp___1 = __fswab16((int )local_bb_credits);
  flogi->csp.bbcred = tmp___1;
  return (116U);
}
}
u16 fc_fdisc_build(struct fchs_s *fchs , struct fc_logi_s *flogi , u32 s_id , u16 ox_id ,
                   wwn_t port_name , wwn_t node_name , u16 pdu_size ) 
{ 
  u32 d_id ;
  unsigned short tmp ;
  __u16 tmp___0 ;

  {
  d_id = 16711679U;
  memcpy((void *)flogi, (void const   *)(& plogi_tmpl), 116UL);
  flogi->els_cmd.els_code = 81U;
  fc_els_req_build(fchs, d_id, s_id, (int )ox_id);
  tmp___0 = __fswab16((int )pdu_size);
  tmp = tmp___0;
  flogi->class3.rxsz = tmp;
  flogi->csp.rxsz = tmp;
  flogi->port_name = port_name;
  flogi->node_name = node_name;
  return (116U);
}
}
u16 fc_plogi_build(struct fchs_s *fchs , void *pld , u32 d_id , u32 s_id , u16 ox_id ,
                   wwn_t port_name , wwn_t node_name , u16 pdu_size , u16 bb_cr ) 
{ 
  u16 tmp ;

  {
  tmp = fc_plogi_x_build(fchs, pld, d_id, s_id, (int )ox_id, port_name, node_name,
                         (int )pdu_size, (int )bb_cr, 3);
  return (tmp);
}
}
u16 fc_plogi_acc_build(struct fchs_s *fchs , void *pld , u32 d_id , u32 s_id , u16 ox_id ,
                       wwn_t port_name , wwn_t node_name , u16 pdu_size , u16 bb_cr ) 
{ 
  u16 tmp ;

  {
  tmp = fc_plogi_x_build(fchs, pld, d_id, s_id, (int )ox_id, port_name, node_name,
                         (int )pdu_size, (int )bb_cr, 2);
  return (tmp);
}
}
enum fc_parse_status fc_plogi_rsp_parse(struct fchs_s *fchs , int len , wwn_t port_name ) 
{ 
  struct fc_els_cmd_s *els_cmd ;
  struct fc_logi_s *plogi ;
  struct fc_ls_rjt_s *ls_rjt ;
  int tmp ;
  __u16 tmp___0 ;

  {
  els_cmd = (struct fc_els_cmd_s *)fchs + 1U;
  switch ((int )els_cmd->els_code) {
  case 1: 
  ls_rjt = (struct fc_ls_rjt_s *)fchs + 1U;
  if ((unsigned int )ls_rjt->reason_code == 5U) {
    return (2);
  } else {
    return (1);
  }
  case 2: 
  plogi = (struct fc_logi_s *)fchs + 1U;
  if ((unsigned int )len <= 115U) {
    return (1);
  } else {

  }
  tmp = memcmp((void const   *)(& plogi->port_name), (void const   *)(& port_name),
               8UL);
  if (tmp != 0) {
    return (1);
  } else {

  }
  if ((unsigned int )*((unsigned char *)plogi + 68UL) == 0U) {
    return (1);
  } else {

  }
  tmp___0 = __fswab16((int )plogi->class3.rxsz);
  if ((unsigned int )tmp___0 <= 511U) {
    return (1);
  } else {

  }
  return (0);
  default: ;
  return (1);
  }
}
}
enum fc_parse_status fc_plogi_parse(struct fchs_s *fchs ) 
{ 
  struct fc_logi_s *plogi ;
  __u16 tmp ;
  __u16 tmp___0 ;

  {
  plogi = (struct fc_logi_s *)fchs + 1U;
  if ((unsigned int )*((unsigned char *)plogi + 68UL) == 0U) {
    return (1);
  } else {

  }
  tmp = __fswab16((int )plogi->class3.rxsz);
  if ((unsigned int )tmp <= 511U) {
    return (1);
  } else {
    tmp___0 = __fswab16((int )plogi->class3.rxsz);
    if ((unsigned int )tmp___0 > 2112U) {
      return (1);
    } else
    if ((unsigned int )plogi->class3.rxsz == 0U) {
      return (1);
    } else {

    }
  }
  return (0);
}
}
u16 fc_prli_build(struct fchs_s *fchs , void *pld , u32 d_id , u32 s_id , u16 ox_id ) 
{ 
  struct fc_prli_s *prli ;

  {
  prli = (struct fc_prli_s *)pld;
  fc_els_req_build(fchs, d_id, s_id, (int )ox_id);
  memcpy((void *)prli, (void const   *)(& prli_tmpl), 20UL);
  prli->command = 32U;
  prli->parampage.servparams.initiator = 1U;
  prli->parampage.servparams.retry = 1U;
  prli->parampage.servparams.rec_support = 1U;
  prli->parampage.servparams.task_retry_id = 0U;
  prli->parampage.servparams.confirm = 1U;
  return (20U);
}
}
u16 fc_prli_acc_build(struct fchs_s *fchs , void *pld , u32 d_id , u32 s_id , __be16 ox_id ,
                      enum bfa_lport_role role ) 
{ 
  struct fc_prli_s *prli ;

  {
  prli = (struct fc_prli_s *)pld;
  fc_els_rsp_build(fchs, d_id, s_id, (int )ox_id);
  memcpy((void *)prli, (void const   *)(& prli_tmpl), 20UL);
  prli->command = 2U;
  prli->parampage.servparams.initiator = 1U;
  prli->parampage.rspcode = 1U;
  return (20U);
}
}
enum fc_parse_status fc_prli_rsp_parse(struct fc_prli_s *prli , int len ) 
{ 


  {
  if ((unsigned int )len <= 19U) {
    return (1);
  } else {

  }
  if ((unsigned int )prli->command != 2U) {
    return (1);
  } else {

  }
  if ((unsigned int )*((unsigned char *)prli + 6UL) != 1U && (unsigned int )*((unsigned char *)prli + 6UL) != 5U) {
    return (1);
  } else {

  }
  if ((unsigned int )*((unsigned char *)prli + 19UL) == 0U) {
    return (1);
  } else {

  }
  return (0);
}
}
enum fc_parse_status fc_prli_parse(struct fc_prli_s *prli ) 
{ 


  {
  if ((unsigned int )prli->parampage.type != 8U) {
    return (1);
  } else {

  }
  if ((unsigned int )*((unsigned char *)prli + 6UL) == 0U) {
    return (1);
  } else {

  }
  if ((unsigned int )*((unsigned char *)prli + 19UL) == 0U) {
    return (1);
  } else {

  }
  return (0);
}
}
u16 fc_logo_build(struct fchs_s *fchs , struct fc_logo_s *logo , u32 d_id , u32 s_id ,
                  u16 ox_id , wwn_t port_name ) 
{ 


  {
  fc_els_req_build(fchs, d_id, s_id, (int )ox_id);
  memset((void *)logo, 0, 16UL);
  logo->els_cmd.els_code = 5U;
  logo->nport_id = s_id;
  logo->orig_port_name = port_name;
  return (16U);
}
}
static u16 fc_adisc_x_build(struct fchs_s *fchs , struct fc_adisc_s *adisc , u32 d_id ,
                            u32 s_id , __be16 ox_id , wwn_t port_name , wwn_t node_name ,
                            u8 els_code ) 
{ 


  {
  memset((void *)adisc, 0, 28UL);
  adisc->els_cmd.els_code = els_code;
  if ((unsigned int )els_code == 82U) {
    fc_els_req_build(fchs, d_id, s_id, (int )ox_id);
  } else {
    fc_els_rsp_build(fchs, d_id, s_id, (int )ox_id);
  }
  adisc->orig_HA = 0U;
  adisc->orig_port_name = port_name;
  adisc->orig_node_name = node_name;
  adisc->nport_id = s_id;
  return (28U);
}
}
u16 fc_adisc_build(struct fchs_s *fchs , struct fc_adisc_s *adisc , u32 d_id , u32 s_id ,
                   __be16 ox_id , wwn_t port_name , wwn_t node_name ) 
{ 
  u16 tmp ;

  {
  tmp = fc_adisc_x_build(fchs, adisc, d_id, s_id, (int )ox_id, port_name, node_name,
                         82);
  return (tmp);
}
}
u16 fc_adisc_acc_build(struct fchs_s *fchs , struct fc_adisc_s *adisc , u32 d_id ,
                       u32 s_id , __be16 ox_id , wwn_t port_name , wwn_t node_name ) 
{ 
  u16 tmp ;

  {
  tmp = fc_adisc_x_build(fchs, adisc, d_id, s_id, (int )ox_id, port_name, node_name,
                         2);
  return (tmp);
}
}
enum fc_parse_status fc_adisc_rsp_parse(struct fc_adisc_s *adisc , int len , wwn_t port_name ,
                                        wwn_t node_name ) 
{ 
  int tmp ;

  {
  if ((unsigned int )len <= 27U) {
    return (1);
  } else {

  }
  if ((unsigned int )adisc->els_cmd.els_code != 2U) {
    return (1);
  } else {

  }
  tmp = memcmp((void const   *)(& adisc->orig_port_name), (void const   *)(& port_name),
               8UL);
  if (tmp != 0) {
    return (1);
  } else {

  }
  return (0);
}
}
enum fc_parse_status fc_adisc_parse(struct fchs_s *fchs , void *pld , u32 host_dap ,
                                    wwn_t node_name , wwn_t port_name ) 
{ 
  struct fc_adisc_s *adisc ;
  int tmp ;
  int tmp___0 ;

  {
  adisc = (struct fc_adisc_s *)pld;
  if ((unsigned int )adisc->els_cmd.els_code != 2U) {
    return (1);
  } else {

  }
  if (adisc->nport_id == host_dap) {
    tmp = memcmp((void const   *)(& adisc->orig_port_name), (void const   *)(& port_name),
                 8UL);
    if (tmp == 0) {
      tmp___0 = memcmp((void const   *)(& adisc->orig_node_name), (void const   *)(& node_name),
                       8UL);
      if (tmp___0 == 0) {
        return (0);
      } else {

      }
    } else {

    }
  } else {

  }
  return (1);
}
}
enum fc_parse_status fc_pdisc_parse(struct fchs_s *fchs , wwn_t node_name , wwn_t port_name ) 
{ 
  struct fc_logi_s *pdisc ;
  __u16 tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  pdisc = (struct fc_logi_s *)fchs + 1U;
  if ((unsigned int )*((unsigned char *)pdisc + 68UL) == 0U) {
    return (1);
  } else {

  }
  tmp = __fswab16((int )pdisc->class3.rxsz);
  if ((unsigned int )tmp <= 487U || (unsigned int )pdisc->class3.rxsz == 0U) {
    return (1);
  } else {

  }
  tmp___0 = memcmp((void const   *)(& pdisc->port_name), (void const   *)(& port_name),
                   8UL);
  if (tmp___0 != 0) {
    return (1);
  } else {

  }
  tmp___1 = memcmp((void const   *)(& pdisc->node_name), (void const   *)(& node_name),
                   8UL);
  if (tmp___1 != 0) {
    return (1);
  } else {

  }
  return (0);
}
}
u16 fc_abts_build(struct fchs_s *fchs , u32 d_id , u32 s_id , u16 ox_id ) 
{ 
  __u16 tmp ;

  {
  memcpy((void *)fchs, (void const   *)(& fc_bls_req_tmpl), 24UL);
  fchs->cat_info = 1U;
  fchs->d_id = d_id;
  fchs->s_id = s_id;
  tmp = __fswab16((int )ox_id);
  fchs->ox_id = tmp;
  return (24U);
}
}
enum fc_parse_status fc_abts_rsp_parse(struct fchs_s *fchs , int len ) 
{ 


  {
  if ((unsigned int )*((unsigned char *)fchs + 0UL) == 4U || (unsigned int )*((unsigned char *)fchs + 0UL) == 5U) {
    return (0);
  } else {

  }
  return (1);
}
}
u16 fc_rrq_build(struct fchs_s *fchs , struct fc_rrq_s *rrq , u32 d_id , u32 s_id ,
                 u16 ox_id , u16 rrq_oxid ) 
{ 
  __u16 tmp ;

  {
  fc_els_req_build(fchs, d_id, s_id, (int )ox_id);
  memcpy((void *)rrq, (void const   *)(& rrq_tmpl), 44UL);
  rrq->s_id = s_id;
  tmp = __fswab16((int )rrq_oxid);
  rrq->ox_id = tmp;
  rrq->rx_id = 65535U;
  return (44U);
}
}
u16 fc_logo_acc_build(struct fchs_s *fchs , void *pld , u32 d_id , u32 s_id , __be16 ox_id ) 
{ 
  struct fc_els_cmd_s *acc ;

  {
  acc = (struct fc_els_cmd_s *)pld;
  fc_els_rsp_build(fchs, d_id, s_id, (int )ox_id);
  memset((void *)acc, 0, 4UL);
  acc->els_code = 2U;
  return (4U);
}
}
u16 fc_ls_rjt_build(struct fchs_s *fchs , struct fc_ls_rjt_s *ls_rjt , u32 d_id ,
                    u32 s_id , __be16 ox_id , u8 reason_code , u8 reason_code_expl ) 
{ 


  {
  fc_els_rsp_build(fchs, d_id, s_id, (int )ox_id);
  memset((void *)ls_rjt, 0, 8UL);
  ls_rjt->els_cmd.els_code = 1U;
  ls_rjt->reason_code = reason_code;
  ls_rjt->reason_code_expl = reason_code_expl;
  ls_rjt->vendor_unique = 0U;
  return (8U);
}
}
u16 fc_ba_acc_build(struct fchs_s *fchs , struct fc_ba_acc_s *ba_acc , u32 d_id ,
                    u32 s_id , __be16 ox_id , u16 rx_id ) 
{ 


  {
  fc_bls_rsp_build(fchs, d_id, s_id, (int )ox_id);
  memcpy((void *)ba_acc, (void const   *)(& ba_acc_tmpl), 12UL);
  fchs->rx_id = rx_id;
  ba_acc->ox_id = fchs->ox_id;
  ba_acc->rx_id = fchs->rx_id;
  return (12U);
}
}
u16 fc_ls_acc_build(struct fchs_s *fchs , struct fc_els_cmd_s *els_cmd , u32 d_id ,
                    u32 s_id , __be16 ox_id ) 
{ 


  {
  fc_els_rsp_build(fchs, d_id, s_id, (int )ox_id);
  memset((void *)els_cmd, 0, 4UL);
  els_cmd->els_code = 2U;
  return (4U);
}
}
int fc_logout_params_pages(struct fchs_s *fc_frame , u8 els_code ) 
{ 
  int num_pages ;
    klee_make_symbolic(&num_pages, sizeof(int), "num_pages");
  struct fc_prlo_s *prlo ;
  struct fc_tprlo_s *tprlo ;
  __u16 tmp ;
  __u16 tmp___0 ;

  {
  num_pages = 0;
  if ((unsigned int )els_code == 33U) {
    prlo = (struct fc_prlo_s *)fc_frame + 1U;
    tmp = __fswab16((int )prlo->payload_len);
    num_pages = ((int )tmp + -4) / 16;
  } else {
    tprlo = (struct fc_tprlo_s *)fc_frame + 1U;
    tmp___0 = __fswab16((int )tprlo->payload_len);
    num_pages = ((int )tmp___0 + -4) / 16;
  }
  return (num_pages);
}
}
u16 fc_tprlo_acc_build(struct fchs_s *fchs , struct fc_tprlo_acc_s *tprlo_acc , u32 d_id ,
                       u32 s_id , __be16 ox_id , int num_pages ) 
{ 
  int page ;
    klee_make_symbolic(&page, sizeof(int), "page");
  __u16 tmp ;
  __u16 tmp___0 ;

  {
  fc_els_rsp_build(fchs, d_id, s_id, (int )ox_id);
  memset((void *)tprlo_acc, 0, (size_t )(num_pages * 16 + 4));
  tprlo_acc->command = 2U;
  tprlo_acc->page_len = 16U;
  tmp = __fswab16((int )((unsigned int )((__u16 )num_pages) * 16U + 4U));
  tprlo_acc->payload_len = tmp;
  page = 0;
  goto ldv_48881;
  ldv_48880: 
  tprlo_acc->tprlo_acc_params[page].opa_valid = 0U;
  tprlo_acc->tprlo_acc_params[page].rpa_valid = 0U;
  tprlo_acc->tprlo_acc_params[page].fc4type_csp = 8U;
  tprlo_acc->tprlo_acc_params[page].orig_process_assc = 0U;
  tprlo_acc->tprlo_acc_params[page].resp_process_assc = 0U;
  page = page + 1;
  ldv_48881: ;
  if (page < num_pages) {
    goto ldv_48880;
  } else {

  }
  tmp___0 = __fswab16((int )tprlo_acc->payload_len);
  return (tmp___0);
}
}
u16 fc_prlo_acc_build(struct fchs_s *fchs , struct fc_prlo_acc_s *prlo_acc , u32 d_id ,
                      u32 s_id , __be16 ox_id , int num_pages ) 
{ 
  int page ;
  __u16 tmp ;
  __u16 tmp___0 ;

  {
  fc_els_rsp_build(fchs, d_id, s_id, (int )ox_id);
  memset((void *)prlo_acc, 0, (size_t )(num_pages * 16 + 4));
  prlo_acc->command = 2U;
  prlo_acc->page_len = 16U;
  tmp = __fswab16((int )((unsigned int )((__u16 )num_pages) * 16U + 4U));
  prlo_acc->payload_len = tmp;
  page = 0;
  goto ldv_48893;
  ldv_48892: 
  prlo_acc->prlo_acc_params[page].opa_valid = 0U;
  prlo_acc->prlo_acc_params[page].rpa_valid = 0U;
  prlo_acc->prlo_acc_params[page].fc4type_csp = 8U;
  prlo_acc->prlo_acc_params[page].orig_process_assc = 0U;
  prlo_acc->prlo_acc_params[page].resp_process_assc = 0U;
  page = page + 1;
  ldv_48893: ;
  if (page < num_pages) {
    goto ldv_48892;
  } else {

  }
  tmp___0 = __fswab16((int )prlo_acc->payload_len);
  return (tmp___0);
}
}
u16 fc_rnid_build(struct fchs_s *fchs , struct fc_rnid_cmd_s *rnid , u32 d_id , u32 s_id ,
                  u16 ox_id , u32 data_format ) 
{ 


  {
  fc_els_req_build(fchs, d_id, s_id, (int )ox_id);
  memset((void *)rnid, 0, 8UL);
  rnid->els_cmd.els_code = 120U;
  rnid->node_id_data_format = (unsigned char )data_format;
  return (8U);
}
}
u16 fc_rnid_acc_build(struct fchs_s *fchs , struct fc_rnid_acc_s *rnid_acc , u32 d_id ,
                      u32 s_id , __be16 ox_id , u32 data_format , struct fc_rnid_common_id_data_s *common_id_data ,
                      struct fc_rnid_general_topology_data_s *gen_topo_data ) 
{ 


  {
  memset((void *)rnid_acc, 0, 76UL);
  fc_els_rsp_build(fchs, d_id, s_id, (int )ox_id);
  rnid_acc->els_cmd.els_code = 2U;
  rnid_acc->node_id_data_format = (unsigned char )data_format;
  rnid_acc->common_id_data_length = 16U;
  rnid_acc->common_id_data = *common_id_data;
  if (data_format == 223U) {
    rnid_acc->specific_id_data_length = 52U;
    rnid_acc->gen_topology_data = *gen_topo_data;
    return (76U);
  } else {
    return (24U);
  }
}
}
u16 fc_rpsc_build(struct fchs_s *fchs , struct fc_rpsc_cmd_s *rpsc , u32 d_id , u32 s_id ,
                  u16 ox_id ) 
{ 


  {
  fc_els_req_build(fchs, d_id, s_id, (int )ox_id);
  memset((void *)rpsc, 0, 4UL);
  rpsc->els_cmd.els_code = 125U;
  return (4U);
}
}
u16 fc_rpsc2_build(struct fchs_s *fchs , struct fc_rpsc2_cmd_s *rpsc2 , u32 d_id ,
                   u32 s_id , u32 *pid_list , u16 npids ) 
{ 
  u32 dctlr_id ;
  int i ;
  __u16 tmp ;

  {
  dctlr_id = ((((((d_id & 255U) << 16) | (d_id & 65280U)) | ((d_id & 16711680U) >> 16)) & 16711680U) >> 16) | 16776192U;
  i = 0;
  fc_els_req_build(fchs, (((dctlr_id & 255U) << 16) | (dctlr_id & 65280U)) | ((dctlr_id & 16711680U) >> 16),
                   s_id, 0);
  memset((void *)rpsc2, 0, 16UL);
  rpsc2->els_cmd.els_code = 125U;
  rpsc2->token = 1145262658U;
  tmp = __fswab16((int )npids);
  rpsc2->num_pids = tmp;
  i = 0;
  goto ldv_48931;
  ldv_48930: 
  rpsc2->pid_list[i].pid = *(pid_list + (unsigned long )i);
  i = i + 1;
  ldv_48931: ;
  if ((int )npids > i) {
    goto ldv_48930;
  } else {

  }

  return ((unsigned int )((u16 )((unsigned long )((int )npids + -1) + 4UL)) * 4U);
}
}
u16 fc_rpsc_acc_build(struct fchs_s *fchs , struct fc_rpsc_acc_s *rpsc_acc , u32 d_id ,
                      u32 s_id , __be16 ox_id , struct fc_rpsc_speed_info_s *oper_speed ) 
{ 
  __u16 tmp ;
  __u16 tmp___0 ;

  {
  memset((void *)rpsc_acc, 0, 8UL);
  fc_els_rsp_build(fchs, d_id, s_id, (int )ox_id);
  rpsc_acc->command = 2U;
  rpsc_acc->num_entries = 256U;
  tmp = __fswab16((int )oper_speed->port_speed_cap);
  rpsc_acc->speed_info[0].port_speed_cap = tmp;
  tmp___0 = __fswab16((int )oper_speed->port_op_speed);
  rpsc_acc->speed_info[0].port_op_speed = tmp___0;
  return (8U);
}
}
u16 fc_logo_rsp_parse(struct fchs_s *fchs , int len ) 
{ 
  struct fc_els_cmd_s *els_cmd ;

  {
  els_cmd = (struct fc_els_cmd_s *)fchs + 1U;
  len = len;
  if ((unsigned int )els_cmd->els_code != 2U) {
    return (1U);
  } else {

  }
  return (0U);
}
}
u16 fc_pdisc_build(struct fchs_s *fchs , u32 d_id , u32 s_id , u16 ox_id , wwn_t port_name ,
                   wwn_t node_name , u16 pdu_size ) 
{ 
  struct fc_logi_s *pdisc ;
  unsigned short tmp ;
  __u16 tmp___0 ;

  {
  pdisc = (struct fc_logi_s *)fchs + 1U;
  memcpy((void *)pdisc, (void const   *)(& plogi_tmpl), 116UL);
  pdisc->els_cmd.els_code = 80U;
  fc_els_req_build(fchs, d_id, s_id, (int )ox_id);
  tmp___0 = __fswab16((int )pdu_size);
  tmp = tmp___0;
  pdisc->class3.rxsz = tmp;
  pdisc->csp.rxsz = tmp;
  pdisc->port_name = port_name;
  pdisc->node_name = node_name;
  return (116U);
}
}
u16 fc_pdisc_rsp_parse(struct fchs_s *fchs , int len , wwn_t port_name ) 
{ 
  struct fc_logi_s *pdisc ;
  int tmp ;
  __u16 tmp___0 ;

  {
  pdisc = (struct fc_logi_s *)fchs + 1U;
  if ((unsigned int )len <= 115U) {
    return (3U);
  } else {

  }
  if ((unsigned int )pdisc->els_cmd.els_code != 2U) {
    return (4U);
  } else {

  }
  tmp = memcmp((void const   *)(& pdisc->port_name), (void const   *)(& port_name),
               8UL);
  if (tmp != 0) {
    return (5U);
  } else {

  }
  if ((unsigned int )*((unsigned char *)pdisc + 68UL) == 0U) {
    return (6U);
  } else {

  }
  tmp___0 = __fswab16((int )pdisc->class3.rxsz);
  if ((unsigned int )tmp___0 <= 511U) {
    return (7U);
  } else {

  }
  return (0U);
}
}
u16 fc_prlo_build(struct fchs_s *fchs , u32 d_id , u32 s_id , u16 ox_id , int num_pages ) 
{ 
  struct fc_prlo_s *prlo ;
  int page ;
  __u16 tmp ;
  __u16 tmp___0 ;

  {
  prlo = (struct fc_prlo_s *)fchs + 1U;
  fc_els_req_build(fchs, d_id, s_id, (int )ox_id);
  memset((void *)prlo, 0, (size_t )(num_pages * 16 + 4));
  prlo->command = 33U;
  prlo->page_len = 16U;
  tmp = __fswab16((int )((unsigned int )((__u16 )num_pages) * 16U + 4U));
  prlo->payload_len = tmp;
  page = 0;
  goto ldv_48972;
  ldv_48971: 
  prlo->prlo_params[page].type = 8U;
  prlo->prlo_params[page].opa_valid = 0U;
  prlo->prlo_params[page].rpa_valid = 0U;
  prlo->prlo_params[page].orig_process_assc = 0U;
  prlo->prlo_params[page].resp_process_assc = 0U;
  page = page + 1;
  ldv_48972: ;
  if (page < num_pages) {
    goto ldv_48971;
  } else {

  }
  tmp___0 = __fswab16((int )prlo->payload_len);
  return (tmp___0);
}
}
u16 fc_prlo_rsp_parse(struct fchs_s *fchs , int len ) 
{ 
  struct fc_prlo_acc_s *prlo ;
  int num_pages ;
  int page ;
  __u16 tmp ;

  {
  prlo = (struct fc_prlo_acc_s *)fchs + 1U;
  num_pages = 0;
  page = 0;
  len = len;
  if ((unsigned int )prlo->command != 2U) {
    return (1U);
  } else {

  }
  tmp = __fswab16((int )prlo->payload_len);
  num_pages = ((int )tmp + -4) / 16;
  page = 0;
  goto ldv_48982;
  ldv_48981: ;
  if ((unsigned int )prlo->prlo_acc_params[page].type != 8U) {
    return (1U);
  } else {

  }
  if ((unsigned int )prlo->prlo_acc_params[page].opa_valid != 0U) {
    return (1U);
  } else {

  }
  if ((unsigned int )prlo->prlo_acc_params[page].rpa_valid != 0U) {
    return (1U);
  } else {

  }
  if (prlo->prlo_acc_params[page].orig_process_assc != 0U) {
    return (1U);
  } else {

  }
  if (prlo->prlo_acc_params[page].resp_process_assc != 0U) {
    return (1U);
  } else {

  }
  page = page + 1;
  ldv_48982: ;
  if (page < num_pages) {
    goto ldv_48981;
  } else {

  }

  return (0U);
}
}
u16 fc_tprlo_build(struct fchs_s *fchs , u32 d_id , u32 s_id , u16 ox_id , int num_pages ,
                   enum fc_tprlo_type tprlo_type , u32 tpr_id ) 
{ 
  struct fc_tprlo_s *tprlo ;
  int page ;
  __u16 tmp ;
  __u16 tmp___0 ;

  {
  tprlo = (struct fc_tprlo_s *)fchs + 1U;
  fc_els_req_build(fchs, d_id, s_id, (int )ox_id);
  memset((void *)tprlo, 0, (size_t )(num_pages * 16 + 4));
  tprlo->command = 36U;
  tprlo->page_len = 16U;
  tmp = __fswab16((int )((unsigned int )((__u16 )num_pages) * 16U + 4U));
  tprlo->payload_len = tmp;
  page = 0;
  goto ldv_48996;
  ldv_48995: 
  tprlo->tprlo_params[page].type = 8U;
  tprlo->tprlo_params[page].opa_valid = 0U;
  tprlo->tprlo_params[page].rpa_valid = 0U;
  tprlo->tprlo_params[page].orig_process_assc = 0U;
  tprlo->tprlo_params[page].resp_process_assc = 0U;
  if ((unsigned int )tprlo_type == 1U) {
    tprlo->tprlo_params[page].global_process_logout = 1U;
  } else
  if ((unsigned int )tprlo_type == 2U) {
    tprlo->tprlo_params[page].tpo_nport_valid = 1U;
    tprlo->tprlo_params[page].tpo_nport_id = tpr_id;
  } else {

  }
  page = page + 1;
  ldv_48996: ;
  if (page < num_pages) {
    goto ldv_48995;
  } else {

  }
  tmp___0 = __fswab16((int )tprlo->payload_len);
  return (tmp___0);
}
}
u16 fc_tprlo_rsp_parse(struct fchs_s *fchs , int len ) 
{ 
  struct fc_tprlo_acc_s *tprlo ;
  int num_pages ;
  int page ;
  __u16 tmp ;

  {
  tprlo = (struct fc_tprlo_acc_s *)fchs + 1U;
  num_pages = 0;
  page = 0;
  len = len;
  if ((unsigned int )tprlo->command != 2U) {
    return (4U);
  } else {

  }
  tmp = __fswab16((int )tprlo->payload_len);
  num_pages = ((int )tmp + -4) / 16;
  page = 0;
  goto ldv_49006;
  ldv_49005: ;
  if ((unsigned int )tprlo->tprlo_acc_params[page].type != 8U) {
    return (8U);
  } else {

  }
  if ((unsigned int )tprlo->tprlo_acc_params[page].opa_valid != 0U) {
    return (9U);
  } else {

  }
  if ((unsigned int )tprlo->tprlo_acc_params[page].rpa_valid != 0U) {
    return (10U);
  } else {

  }
  if (tprlo->tprlo_acc_params[page].orig_process_assc != 0U) {
    return (11U);
  } else {

  }
  if (tprlo->tprlo_acc_params[page].resp_process_assc != 0U) {
    return (12U);
  } else {

  }
  page = page + 1;
  ldv_49006: ;
  if (page < num_pages) {
    goto ldv_49005;
  } else {

  }

  return (0U);
}
}
enum fc_parse_status fc_rrq_rsp_parse(struct fchs_s *fchs , int len ) 
{ 
  struct fc_els_cmd_s *els_cmd ;

  {
  els_cmd = (struct fc_els_cmd_s *)fchs + 1U;
  len = len;
  if ((unsigned int )els_cmd->els_code != 2U) {
    return (1);
  } else {

  }
  return (0);
}
}
u16 fc_ba_rjt_build(struct fchs_s *fchs , u32 d_id , u32 s_id , __be16 ox_id , u32 reason_code ,
                    u32 reason_expl ) 
{ 
  struct fc_ba_rjt_s *ba_rjt ;

  {
  ba_rjt = (struct fc_ba_rjt_s *)fchs + 1U;
  fc_bls_rsp_build(fchs, d_id, s_id, (int )ox_id);
  fchs->cat_info = 5U;
  ba_rjt->reason_code = (unsigned char )reason_code;
  ba_rjt->reason_expl = (unsigned char )reason_expl;
  return (4U);
}
}
static void fc_gs_cthdr_build(struct ct_hdr_s *cthdr , u32 s_id , u16 cmd_code ) 
{ 
  __u16 tmp ;

  {
  memset((void *)cthdr, 0, 16UL);
  cthdr->rev_id = 1U;
  cthdr->gs_type = 252U;
  cthdr->gs_sub_type = 2U;
  tmp = __fswab16((int )cmd_code);
  cthdr->cmd_rsp_code = tmp;
  return;
}
}
static void fc_gs_fdmi_cthdr_build(struct ct_hdr_s *cthdr , u32 s_id , u16 cmd_code ) 
{ 
  __u16 tmp ;

  {
  memset((void *)cthdr, 0, 16UL);
  cthdr->rev_id = 1U;
  cthdr->gs_type = 250U;
  cthdr->gs_sub_type = 16U;
  tmp = __fswab16((int )cmd_code);
  cthdr->cmd_rsp_code = tmp;
  return;
}
}
static void fc_gs_ms_cthdr_build(struct ct_hdr_s *cthdr , u32 s_id , u16 cmd_code ,
                                 u8 sub_type ) 
{ 
  __u16 tmp ;

  {
  memset((void *)cthdr, 0, 16UL);
  cthdr->rev_id = 1U;
  cthdr->gs_type = 250U;
  cthdr->gs_sub_type = sub_type;
  tmp = __fswab16((int )cmd_code);
  cthdr->cmd_rsp_code = tmp;
  return;
}
}
u16 fc_gidpn_build(struct fchs_s *fchs , void *pyld , u32 s_id , u16 ox_id , wwn_t port_name ) 
{ 
  struct ct_hdr_s *cthdr ;
  struct fcgs_gidpn_req_s *gidpn ;
  u32 d_id ;

  {
  cthdr = (struct ct_hdr_s *)pyld;
  gidpn = (struct fcgs_gidpn_req_s *)cthdr + 1U;
  d_id = 16580607U;
  fc_gs_fchdr_build(fchs, d_id, s_id, (u32 )ox_id);
  fc_gs_cthdr_build(cthdr, s_id, 289);
  memset((void *)gidpn, 0, 8UL);
  gidpn->port_name = port_name;
  return (24U);
}
}
u16 fc_gpnid_build(struct fchs_s *fchs , void *pyld , u32 s_id , u16 ox_id , u32 port_id ) 
{ 
  struct ct_hdr_s *cthdr ;
  struct fcgs_id_req_s *gpnid ;
  u32 d_id ;

  {
  cthdr = (struct ct_hdr_s *)pyld;
  gpnid = (struct fcgs_id_req_s *)cthdr + 1U;
  d_id = 16580607U;
  fc_gs_fchdr_build(fchs, d_id, s_id, (u32 )ox_id);
  fc_gs_cthdr_build(cthdr, s_id, 274);
  memset((void *)gpnid, 0, 4UL);
  gpnid->dap = port_id;
  return (20U);
}
}
u16 fc_gnnid_build(struct fchs_s *fchs , void *pyld , u32 s_id , u16 ox_id , u32 port_id ) 
{ 
  struct ct_hdr_s *cthdr ;
  struct fcgs_id_req_s *gnnid ;
  u32 d_id ;

  {
  cthdr = (struct ct_hdr_s *)pyld;
  gnnid = (struct fcgs_id_req_s *)cthdr + 1U;
  d_id = 16580607U;
  fc_gs_fchdr_build(fchs, d_id, s_id, (u32 )ox_id);
  fc_gs_cthdr_build(cthdr, s_id, 275);
  memset((void *)gnnid, 0, 4UL);
  gnnid->dap = port_id;
  return (20U);
}
}
u16 fc_ct_rsp_parse(struct ct_hdr_s *cthdr ) 
{ 
  __u16 tmp ;

  {
  tmp = __fswab16((int )cthdr->cmd_rsp_code);
  if ((unsigned int )tmp != 32770U) {
    if ((unsigned int )cthdr->reason_code == 5U) {
      return (2U);
    } else {
      return (1U);
    }
  } else {

  }
  return (0U);
}
}
u16 fc_gs_rjt_build(struct fchs_s *fchs , struct ct_hdr_s *cthdr , u32 d_id , u32 s_id ,
                    u16 ox_id , u8 reason_code , u8 reason_code_expl ) 
{ 


  {
  fc_gsresp_fchdr_build(fchs, d_id, s_id, (int )ox_id);
  cthdr->cmd_rsp_code = 384U;
  cthdr->rev_id = 1U;
  cthdr->reason_code = reason_code;
  cthdr->exp_code = reason_code_expl;
  return (16U);
}
}
u16 fc_scr_build(struct fchs_s *fchs , struct fc_scr_s *scr , u8 set_br_reg , u32 s_id ,
                 u16 ox_id ) 
{ 
  u32 d_id ;

  {
  d_id = 16646143U;
  fc_els_req_build(fchs, d_id, s_id, (int )ox_id);
  memset((void *)scr, 0, 8UL);
  scr->command = 98U;
  scr->reg_func = 3U;
  if ((unsigned int )set_br_reg != 0U) {
    scr->vu_reg_func = 1U;
  } else {

  }
  return (8U);
}
}
u16 fc_rscn_build(struct fchs_s *fchs , struct fc_rscn_pl_s *rscn , u32 s_id , u16 ox_id ) 
{ 
  u32 d_id ;
  u16 payldlen ;
  __u16 tmp ;

  {
  d_id = 16646143U;
  fc_els_req_build(fchs, d_id, s_id, (int )ox_id);
  rscn->command = 97U;
  rscn->pagelen = 4U;
  payldlen = (unsigned int )((u16 )rscn->pagelen) + 4U;
  tmp = __fswab16((int )payldlen);
  rscn->payldlen = tmp;
  rscn->event[0].format = 0U;
  rscn->event[0].portid = s_id;
  return (8U);
}
}
u16 fc_rftid_build(struct fchs_s *fchs , void *pyld , u32 s_id , u16 ox_id , enum bfa_lport_role roles ) 
{ 
  struct ct_hdr_s *cthdr ;
  struct fcgs_rftid_req_s *rftid ;
  u32 type_value ;
  u32 d_id ;
  u8 index ;
  __u32 tmp ;

  {
  cthdr = (struct ct_hdr_s *)pyld;
  rftid = (struct fcgs_rftid_req_s *)cthdr + 1U;
  d_id = 16580607U;
  fc_gs_fchdr_build(fchs, d_id, s_id, (u32 )ox_id);
  fc_gs_cthdr_build(cthdr, s_id, 535);
  memset((void *)rftid, 0, 36UL);
  rftid->dap = s_id;
  index = 0U;
  type_value = 256U;
  tmp = __fswab32(type_value);
  rftid->fc4_type[(int )index] = tmp;
  return (52U);
}
}
u16 fc_rftid_build_sol(struct fchs_s *fchs , void *pyld , u32 s_id , u16 ox_id , u8 *fc4_bitmap ,
                       u32 bitmap_size ) 
{ 
  struct ct_hdr_s *cthdr ;
  struct fcgs_rftid_req_s *rftid ;
  u32 d_id ;

  {
  cthdr = (struct ct_hdr_s *)pyld;
  rftid = (struct fcgs_rftid_req_s *)cthdr + 1U;
  d_id = 16580607U;
  fc_gs_fchdr_build(fchs, d_id, s_id, (u32 )ox_id);
  fc_gs_cthdr_build(cthdr, s_id, 535);
  memset((void *)rftid, 0, 36UL);
  rftid->dap = s_id;
  memcpy((void *)(& rftid->fc4_type), (void const   *)fc4_bitmap, (size_t )(32U < bitmap_size ? 32U : bitmap_size));
  return (52U);
}
}
u16 fc_rffid_build(struct fchs_s *fchs , void *pyld , u32 s_id , u16 ox_id , u8 fc4_type ,
                   u8 fc4_ftrs ) 
{ 
  struct ct_hdr_s *cthdr ;
  struct fcgs_rffid_req_s *rffid ;
  u32 d_id ;

  {
  cthdr = (struct ct_hdr_s *)pyld;
  rffid = (struct fcgs_rffid_req_s *)cthdr + 1U;
  d_id = 16580607U;
  fc_gs_fchdr_build(fchs, d_id, s_id, (u32 )ox_id);
  fc_gs_cthdr_build(cthdr, s_id, 543);
  memset((void *)rffid, 0, 8UL);
  rffid->dap = s_id;
  rffid->fc4ftr_bits = fc4_ftrs;
  rffid->fc4_type = fc4_type;
  return (24U);
}
}
u16 fc_rspnid_build(struct fchs_s *fchs , void *pyld , u32 s_id , u16 ox_id , u8 *name ) 
{ 
  struct ct_hdr_s *cthdr ;
  struct fcgs_rspnid_req_s *rspnid ;
  u32 d_id ;
  size_t tmp ;

  {
  cthdr = (struct ct_hdr_s *)pyld;
  rspnid = (struct fcgs_rspnid_req_s *)cthdr + 1U;
  d_id = 16580607U;
  fc_gs_fchdr_build(fchs, d_id, s_id, (u32 )ox_id);
  fc_gs_cthdr_build(cthdr, s_id, 536);
  memset((void *)rspnid, 0, 261UL);
  rspnid->dap = s_id;
  tmp = strlen((char const   *)name);
  rspnid->spn_len = (unsigned char )tmp;
  strncpy((char *)(& rspnid->spn), (char const   *)name, (__kernel_size_t )rspnid->spn_len);
  return (277U);
}
}
u16 fc_rsnn_nn_build(struct fchs_s *fchs , void *pyld , u32 s_id , wwn_t node_name ,
                     u8 *name ) 
{ 
  struct ct_hdr_s *cthdr ;
  struct fcgs_rsnn_nn_req_s *rsnn_nn ;
  u32 d_id ;
  size_t tmp ;

  {
  cthdr = (struct ct_hdr_s *)pyld;
  rsnn_nn = (struct fcgs_rsnn_nn_req_s *)cthdr + 1U;
  d_id = 16580607U;
  fc_gs_fchdr_build(fchs, d_id, s_id, 0U);
  fc_gs_cthdr_build(cthdr, s_id, 569);
  memset((void *)rsnn_nn, 0, 265UL);
  rsnn_nn->node_name = node_name;
  tmp = strlen((char const   *)name);
  rsnn_nn->snn_len = (unsigned char )tmp;
  strncpy((char *)(& rsnn_nn->snn), (char const   *)name, (__kernel_size_t )rsnn_nn->snn_len);
  return (281U);
}
}
u16 fc_gid_ft_build(struct fchs_s *fchs , void *pyld , u32 s_id , u8 fc4_type ) 
{ 
  struct ct_hdr_s *cthdr ;
  struct fcgs_gidft_req_s *gidft ;
  u32 d_id ;

  {
  cthdr = (struct ct_hdr_s *)pyld;
  gidft = (struct fcgs_gidft_req_s *)cthdr + 1U;
  d_id = 16580607U;
  fc_gs_fchdr_build(fchs, d_id, s_id, 0U);
  fc_gs_cthdr_build(cthdr, s_id, 369);
  memset((void *)gidft, 0, 4UL);
  gidft->fc4_type = fc4_type;
  gidft->domain_id = 0U;
  gidft->area_id = 0U;
  return (20U);
}
}
u16 fc_rpnid_build(struct fchs_s *fchs , void *pyld , u32 s_id , u32 port_id , wwn_t port_name ) 
{ 
  struct ct_hdr_s *cthdr ;
  struct fcgs_rpnid_req_s *rpnid ;
  u32 d_id ;

  {
  cthdr = (struct ct_hdr_s *)pyld;
  rpnid = (struct fcgs_rpnid_req_s *)cthdr + 1U;
  d_id = 16580607U;
  fc_gs_fchdr_build(fchs, d_id, s_id, 0U);
  fc_gs_cthdr_build(cthdr, s_id, 530);
  memset((void *)rpnid, 0, 12UL);
  rpnid->port_id = port_id;
  rpnid->port_name = port_name;
  return (28U);
}
}
u16 fc_rnnid_build(struct fchs_s *fchs , void *pyld , u32 s_id , u32 port_id , wwn_t node_name ) 
{ 
  struct ct_hdr_s *cthdr ;
  struct fcgs_rnnid_req_s *rnnid ;
  u32 d_id ;

  {
  cthdr = (struct ct_hdr_s *)pyld;
  rnnid = (struct fcgs_rnnid_req_s *)cthdr + 1U;
  d_id = 16580607U;
  fc_gs_fchdr_build(fchs, d_id, s_id, 0U);
  fc_gs_cthdr_build(cthdr, s_id, 531);
  memset((void *)rnnid, 0, 12UL);
  rnnid->port_id = port_id;
  rnnid->node_name = node_name;
  return (28U);
}
}
u16 fc_rcsid_build(struct fchs_s *fchs , void *pyld , u32 s_id , u32 port_id , u32 cos ) 
{ 
  struct ct_hdr_s *cthdr ;
  struct fcgs_rcsid_req_s *rcsid ;
  u32 d_id ;

  {
  cthdr = (struct ct_hdr_s *)pyld;
  rcsid = (struct fcgs_rcsid_req_s *)cthdr + 1U;
  d_id = 16580607U;
  fc_gs_fchdr_build(fchs, d_id, s_id, 0U);
  fc_gs_cthdr_build(cthdr, s_id, 532);
  memset((void *)rcsid, 0, 8UL);
  rcsid->port_id = port_id;
  rcsid->cos = cos;
  return (24U);
}
}
u16 fc_rptid_build(struct fchs_s *fchs , void *pyld , u32 s_id , u32 port_id , u8 port_type ) 
{ 
  struct ct_hdr_s *cthdr ;
  struct fcgs_rptid_req_s *rptid ;
  u32 d_id ;

  {
  cthdr = (struct ct_hdr_s *)pyld;
  rptid = (struct fcgs_rptid_req_s *)cthdr + 1U;
  d_id = 16580607U;
  fc_gs_fchdr_build(fchs, d_id, s_id, 0U);
  fc_gs_cthdr_build(cthdr, s_id, 538);
  memset((void *)rptid, 0, 8UL);
  rptid->port_id = port_id;
  rptid->port_type = port_type;
  return (24U);
}
}
u16 fc_ganxt_build(struct fchs_s *fchs , void *pyld , u32 s_id , u32 port_id ) 
{ 
  struct ct_hdr_s *cthdr ;
  struct fcgs_ganxt_req_s *ganxt ;
  u32 d_id ;

  {
  cthdr = (struct ct_hdr_s *)pyld;
  ganxt = (struct fcgs_ganxt_req_s *)cthdr + 1U;
  d_id = 16580607U;
  fc_gs_fchdr_build(fchs, d_id, s_id, 0U);
  fc_gs_cthdr_build(cthdr, s_id, 256);
  memset((void *)ganxt, 0, 4UL);
  ganxt->port_id = port_id;
  return (20U);
}
}
u16 fc_fdmi_reqhdr_build(struct fchs_s *fchs , void *pyld , u32 s_id , u16 cmd_code ) 
{ 
  struct ct_hdr_s *cthdr ;
  u32 d_id ;

  {
  cthdr = (struct ct_hdr_s *)pyld;
  d_id = 16449535U;
  fc_gs_fchdr_build(fchs, d_id, s_id, 0U);
  fc_gs_fdmi_cthdr_build(cthdr, s_id, (int )cmd_code);
  return (16U);
}
}
void fc_get_fc4type_bitmask(u8 fc4_type , u8 *bit_mask ) 
{ 
  u8 index ;
  __be32 *ptr ;
  u32 type_value ;
  __u32 tmp ;

  {
  ptr = (__be32 *)bit_mask;
  index = (u8 )((int )fc4_type >> 5);
  type_value = (u32 )(1 << ((int )fc4_type & 31));
  tmp = __fswab32(type_value);
  *(ptr + (unsigned long )index) = tmp;
  return;
}
}
u16 fc_gmal_req_build(struct fchs_s *fchs , void *pyld , u32 s_id , wwn_t wwn ) 
{ 
  struct ct_hdr_s *cthdr ;
  struct fcgs_req_s *gmal ;
  u32 d_id ;

  {
  cthdr = (struct ct_hdr_s *)pyld;
  gmal = (struct fcgs_req_s *)cthdr + 1U;
  d_id = 16449535U;
  fc_gs_fchdr_build(fchs, d_id, s_id, 0U);
  fc_gs_ms_cthdr_build(cthdr, s_id, 278, 1);
  memset((void *)gmal, 0, 8UL);
  gmal->wwn = wwn;
  return (24U);
}
}
u16 fc_gfn_req_build(struct fchs_s *fchs , void *pyld , u32 s_id , wwn_t wwn ) 
{ 
  struct ct_hdr_s *cthdr ;
  struct fcgs_req_s *gfn ;
  u32 d_id ;

  {
  cthdr = (struct ct_hdr_s *)pyld;
  gfn = (struct fcgs_req_s *)cthdr + 1U;
  d_id = 16449535U;
  fc_gs_fchdr_build(fchs, d_id, s_id, 0U);
  fc_gs_ms_cthdr_build(cthdr, s_id, 276, 1);
  memset((void *)gfn, 0, 8UL);
  gfn->wwn = wwn;
  return (24U);
}
}
bool ldv_queue_work_on_507(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_3(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_delayed_work_on_508(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_3(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_work_on_509(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_3(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
void ldv_flush_workqueue_510(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
  flush_workqueue(ldv_func_arg1);
  call_and_disable_all_3(2);
  return;
}
}
bool ldv_queue_delayed_work_on_511(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_3(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
void ldv_mutex_lock_512(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_lock_lock(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_513(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_unlock_lock(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_514(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
int ldv_mutex_trylock_515(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
  tmp = mutex_trylock(ldv_func_arg1);
  ldv_func_res = tmp;
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
  return (tmp___0);
  return (ldv_func_res);
}
}
void ldv_mutex_unlock_516(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_517(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_unlock_i_mutex_of_inode(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_518(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_lock_i_mutex_of_inode(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
int ldv_scsi_add_host_with_dma_519(struct Scsi_Host *shost , struct device *dev ,
                                   struct device *dma_dev ) 
{ 
  ldv_func_ret_type___4 ldv_func_res ;
  int tmp ;

  {
  tmp = scsi_add_host_with_dma(shost, dev, dma_dev);
  ldv_func_res = tmp;
  if (ldv_func_res == 0) {
    ldv_state_variable_35 = 1;
    ldv_initialize_scsi_host_template_35();
  } else {

  }
  return (ldv_func_res);
}
}
__inline static long ldv__builtin_expect(long exp , long c ) ;
int ldv_mutex_trylock_545(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_543(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_546(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_547(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_542(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_544(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_548(struct mutex *ldv_func_arg1 ) ;
bool ldv_queue_work_on_537(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_work_on_539(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_delayed_work_on_538(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
bool ldv_queue_delayed_work_on_541(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
void ldv_flush_workqueue_540(struct workqueue_struct *ldv_func_arg1 ) ;
int ldv_scsi_add_host_with_dma_549(struct Scsi_Host *shost , struct device *dev ,
                                   struct device *dma_dev ) ;
void bfa_port_attach(struct bfa_port_s *port , struct bfa_ioc_s *ioc , void *dev ,
                     struct bfa_trc_mod_s *trcmod ) ;
void bfa_port_notify(void *arg , enum bfa_ioc_event_e event ) ;
u32 bfa_port_meminfo(void) ;
void bfa_port_mem_claim(struct bfa_port_s *port , u8 *dma_kva , u64 dma_pa ) ;
void bfa_port_set_dportenabled(struct bfa_port_s *port , enum bfa_boolean enabled ) ;
u32 bfa_cee_meminfo(void) ;
void bfa_cee_mem_claim(struct bfa_cee_s *cee , u8 *dma_kva , u64 dma_pa ) ;
void bfa_cee_attach(struct bfa_cee_s *cee , struct bfa_ioc_s *ioc , void *dev ) ;
static int __trc_fileno___10  =    4097;
static void bfa_port_stats_swap(struct bfa_port_s *port , union bfa_port_stats_u *stats ) 
{ 
  u32 *dip ;
  __be32 t0 ;
  __be32 t1 ;
  int i ;
  __u32 tmp ;
  __u32 tmp___0 ;

  {
  dip = (u32 *)stats;
  i = 0;
  goto ldv_48171;
  ldv_48170: 
  t0 = *(dip + (unsigned long )i);
  t1 = *(dip + ((unsigned long )i + 1UL));
  tmp = __fswab32(t1);
  *(dip + (unsigned long )i) = tmp;
  tmp___0 = __fswab32(t0);
  *(dip + ((unsigned long )i + 1UL)) = tmp___0;
  i = i + 2;
  ldv_48171: ;
  if ((unsigned int )i <= 83U) {
    goto ldv_48170;
  } else {

  }

  return;
}
}
static void bfa_port_enable_isr(struct bfa_port_s *port , enum bfa_status status ) 
{ 


  {
  __bfa_trc(port->trcmod, __trc_fileno___10, 60, (unsigned long long )status);
  port->endis_pending = 0;
  (*(port->endis_cbfn))(port->endis_cbarg, status);
  return;
}
}
static void bfa_port_disable_isr(struct bfa_port_s *port , enum bfa_status status ) 
{ 


  {
  __bfa_trc(port->trcmod, __trc_fileno___10, 77, (unsigned long long )status);
  port->endis_pending = 0;
  (*(port->endis_cbfn))(port->endis_cbarg, status);
  return;
}
}
static void bfa_port_get_stats_isr(struct bfa_port_s *port , enum bfa_status status ) 
{ 
  struct timeval tv ;

  {
  port->stats_status = status;
  port->stats_busy = 0;
  if ((unsigned int )status == 0U) {
    memcpy((void *)port->stats, (void const   *)port->stats_dma.kva, 336UL);
    bfa_port_stats_swap(port, port->stats);
    do_gettimeofday(& tv);
    (port->stats)->fc.secs_reset = (u64 )(tv.tv_sec - (__kernel_time_t )port->stats_reset_time);
  } else {

  }
  if ((unsigned long )port->stats_cbfn != (unsigned long )((void (*)(void * , enum bfa_status  ))0)) {
    (*(port->stats_cbfn))(port->stats_cbarg, status);
    port->stats_cbfn = (void (*)(void * , enum bfa_status  ))0;
  } else {

  }
  return;
}
}
static void bfa_port_clear_stats_isr(struct bfa_port_s *port , enum bfa_status status ) 
{ 
  struct timeval tv ;

  {
  port->stats_status = status;
  port->stats_busy = 0;
  do_gettimeofday(& tv);
  port->stats_reset_time = (u32 )tv.tv_sec;
  if ((unsigned long )port->stats_cbfn != (unsigned long )((void (*)(void * , enum bfa_status  ))0)) {
    (*(port->stats_cbfn))(port->stats_cbarg, status);
    port->stats_cbfn = (void (*)(void * , enum bfa_status  ))0;
  } else {

  }
  return;
}
}
static void bfa_port_isr(void *cbarg , struct bfi_mbmsg_s *m ) 
{ 
  struct bfa_port_s *port ;
  union bfi_port_i2h_msg_u *i2hmsg ;
  int __ret_warn_on ;
  long tmp ;

  {
  port = (struct bfa_port_s *)cbarg;
  i2hmsg = (union bfi_port_i2h_msg_u *)m;
  __bfa_trc(port->trcmod, __trc_fileno___10, 158, (unsigned long long )m->mh.msg_id);
  switch ((int )m->mh.msg_id) {
  case 129: ;
  if ((unsigned int )port->endis_pending == 0U) {
    goto ldv_48198;
  } else {

  }
  bfa_port_enable_isr(port, (enum bfa_status )i2hmsg->enable_rsp.status);
  goto ldv_48198;
  case 130: ;
  if ((unsigned int )port->endis_pending == 0U) {
    goto ldv_48198;
  } else {

  }
  bfa_port_disable_isr(port, (enum bfa_status )i2hmsg->disable_rsp.status);
  goto ldv_48198;
  case 131: ;
  if ((unsigned int )port->stats_busy == 0U) {
    goto ldv_48198;
  } else {

  }
  bfa_port_get_stats_isr(port, (enum bfa_status )i2hmsg->getstats_rsp.status);
  goto ldv_48198;
  case 132: ;
  if ((unsigned int )port->stats_busy == 0U) {
    goto ldv_48198;
  } else {

  }
  bfa_port_clear_stats_isr(port, (enum bfa_status )i2hmsg->clearstats_rsp.status);
  goto ldv_48198;
  default: 
  __ret_warn_on = 1;
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_port.c",
                       187);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  }
  ldv_48198: ;
  return;
}
}
u32 bfa_port_meminfo(void) 
{ 


  {
  return (512U);
}
}
void bfa_port_mem_claim(struct bfa_port_s *port , u8 *dma_kva , u64 dma_pa ) 
{ 


  {
  port->stats_dma.kva = (void *)dma_kva;
  port->stats_dma.pa = dma_pa;
  return;
}
}
enum bfa_status bfa_port_enable(struct bfa_port_s *port , void (*cbfn)(void * , enum bfa_status  ) ,
                                void *cbarg ) 
{ 
  struct bfi_port_generic_req_s *m ;
  enum bfa_boolean tmp ;
  enum bfa_boolean tmp___0 ;

  {
  if ((unsigned int )port->pbc_disabled != 0U) {
    __bfa_trc(port->trcmod, __trc_fileno___10, 239, 154ULL);
    return (154);
  } else {

  }
  tmp = bfa_ioc_is_disabled(port->ioc);
  if ((unsigned int )tmp != 0U) {
    __bfa_trc(port->trcmod, __trc_fileno___10, 244, 82ULL);
    return (82);
  } else {

  }
  tmp___0 = bfa_ioc_is_operational(port->ioc);
  if ((unsigned int )tmp___0 == 0U) {
    __bfa_trc(port->trcmod, __trc_fileno___10, 249, 56ULL);
    return (56);
  } else {

  }
  if ((unsigned int )port->dport_enabled != 0U) {
    __bfa_trc(port->trcmod, __trc_fileno___10, 255, 245ULL);
    return (245);
  } else {

  }
  if ((unsigned int )port->endis_pending != 0U) {
    __bfa_trc(port->trcmod, __trc_fileno___10, 260, 13ULL);
    return (13);
  } else {

  }
  m = (struct bfi_port_generic_req_s *)(& port->endis_mb.msg);
  port->msgtag = port->msgtag + 1U;
  port->endis_cbfn = cbfn;
  port->endis_cbarg = cbarg;
  port->endis_pending = 1;
  m->mh.msg_class = 21U;
  m->mh.msg_id = 1U;
  m->mh.mtag.h2i.fn_lpu = (port->ioc)->port_id;
  bfa_ioc_mbox_queue(port->ioc, & port->endis_mb);
  return (0);
}
}
enum bfa_status bfa_port_disable(struct bfa_port_s *port , void (*cbfn)(void * , enum bfa_status  ) ,
                                 void *cbarg ) 
{ 
  struct bfi_port_generic_req_s *m ;
  enum bfa_boolean tmp ;
  enum bfa_boolean tmp___0 ;

  {
  if ((unsigned int )port->pbc_disabled != 0U) {
    __bfa_trc(port->trcmod, __trc_fileno___10, 295, 154ULL);
    return (154);
  } else {

  }
  tmp = bfa_ioc_is_disabled(port->ioc);
  if ((unsigned int )tmp != 0U) {
    __bfa_trc(port->trcmod, __trc_fileno___10, 300, 82ULL);
    return (82);
  } else {

  }
  tmp___0 = bfa_ioc_is_operational(port->ioc);
  if ((unsigned int )tmp___0 == 0U) {
    __bfa_trc(port->trcmod, __trc_fileno___10, 305, 56ULL);
    return (56);
  } else {

  }
  if ((unsigned int )port->dport_enabled != 0U) {
    __bfa_trc(port->trcmod, __trc_fileno___10, 311, 245ULL);
    return (245);
  } else {

  }
  if ((unsigned int )port->endis_pending != 0U) {
    __bfa_trc(port->trcmod, __trc_fileno___10, 316, 13ULL);
    return (13);
  } else {

  }
  m = (struct bfi_port_generic_req_s *)(& port->endis_mb.msg);
  port->msgtag = port->msgtag + 1U;
  port->endis_cbfn = cbfn;
  port->endis_cbarg = cbarg;
  port->endis_pending = 1;
  m->mh.msg_class = 21U;
  m->mh.msg_id = 2U;
  m->mh.mtag.h2i.fn_lpu = (port->ioc)->port_id;
  bfa_ioc_mbox_queue(port->ioc, & port->endis_mb);
  return (0);
}
}
enum bfa_status bfa_port_get_stats(struct bfa_port_s *port , union bfa_port_stats_u *stats ,
                                   void (*cbfn)(void * , enum bfa_status  ) , void *cbarg ) 
{ 
  struct bfi_port_get_stats_req_s *m ;
  enum bfa_boolean tmp ;

  {
  tmp = bfa_ioc_is_operational(port->ioc);
  if ((unsigned int )tmp == 0U) {
    __bfa_trc(port->trcmod, __trc_fileno___10, 350, 56ULL);
    return (56);
  } else {

  }
  if ((unsigned int )port->stats_busy != 0U) {
    __bfa_trc(port->trcmod, __trc_fileno___10, 355, 13ULL);
    return (13);
  } else {

  }
  m = (struct bfi_port_get_stats_req_s *)(& port->stats_mb.msg);
  port->stats = stats;
  port->stats_cbfn = cbfn;
  port->stats_cbarg = cbarg;
  port->stats_busy = 1;
  __bfa_dma_be_addr_set(& m->dma_addr, port->stats_dma.pa);
  m->mh.msg_class = 21U;
  m->mh.msg_id = 3U;
  m->mh.mtag.h2i.fn_lpu = (port->ioc)->port_id;
  bfa_ioc_mbox_queue(port->ioc, & port->stats_mb);
  return (0);
}
}
enum bfa_status bfa_port_clear_stats(struct bfa_port_s *port , void (*cbfn)(void * ,
                                                                            enum bfa_status  ) ,
                                     void *cbarg ) 
{ 
  struct bfi_port_generic_req_s *m ;
  enum bfa_boolean tmp ;

  {
  tmp = bfa_ioc_is_operational(port->ioc);
  if ((unsigned int )tmp == 0U) {
    __bfa_trc(port->trcmod, __trc_fileno___10, 389, 56ULL);
    return (56);
  } else {

  }
  if ((unsigned int )port->stats_busy != 0U) {
    __bfa_trc(port->trcmod, __trc_fileno___10, 394, 13ULL);
    return (13);
  } else {

  }
  m = (struct bfi_port_generic_req_s *)(& port->stats_mb.msg);
  port->stats_cbfn = cbfn;
  port->stats_cbarg = cbarg;
  port->stats_busy = 1;
  m->mh.msg_class = 21U;
  m->mh.msg_id = 4U;
  m->mh.mtag.h2i.fn_lpu = (port->ioc)->port_id;
  bfa_ioc_mbox_queue(port->ioc, & port->stats_mb);
  return (0);
}
}
void bfa_port_notify(void *arg , enum bfa_ioc_event_e event ) 
{ 
  struct bfa_port_s *port ;

  {
  port = (struct bfa_port_s *)arg;
  switch ((unsigned int )event) {
  case 2U: ;
  case 3U: ;
  if ((unsigned int )port->stats_busy != 0U) {
    if ((unsigned long )port->stats_cbfn != (unsigned long )((void (*)(void * , enum bfa_status  ))0)) {
      (*(port->stats_cbfn))(port->stats_cbarg, 1);
    } else {

    }
    port->stats_cbfn = (void (*)(void * , enum bfa_status  ))0;
    port->stats_busy = 0;
  } else {

  }
  if ((unsigned int )port->endis_pending != 0U) {
    if ((unsigned long )port->endis_cbfn != (unsigned long )((void (*)(void * , enum bfa_status  ))0)) {
      (*(port->endis_cbfn))(port->endis_cbarg, 1);
    } else {

    }
    port->endis_cbfn = (void (*)(void * , enum bfa_status  ))0;
    port->endis_pending = 0;
  } else {

  }
  if ((unsigned int )port->dport_enabled != 0U) {
    bfa_port_set_dportenabled(port, 0);
  } else {

  }
  goto ldv_48245;
  default: ;
  goto ldv_48245;
  }
  ldv_48245: ;
  return;
}
}
void bfa_port_attach(struct bfa_port_s *port , struct bfa_ioc_s *ioc , void *dev ,
                     struct bfa_trc_mod_s *trcmod ) 
{ 
  struct timeval tv ;
  int __ret_warn_on ;
  long tmp ;

  {
  __ret_warn_on = (unsigned long )port == (unsigned long )((struct bfa_port_s *)0);
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_port.c",
                       475);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  port->dev = dev;
  port->ioc = ioc;
  port->trcmod = trcmod;
  port->stats_busy = 0;
  port->endis_pending = 0;
  port->stats_cbfn = (void (*)(void * , enum bfa_status  ))0;
  port->endis_cbfn = (void (*)(void * , enum bfa_status  ))0;
  port->pbc_disabled = 0;
  port->dport_enabled = 0;
  bfa_ioc_mbox_regisr(port->ioc, 21, & bfa_port_isr, (void *)port);
  ((struct list_head *)(& port->ioc_notify))->next = (struct list_head *)0;
  ((struct list_head *)(& port->ioc_notify))->prev = (struct list_head *)0;
  port->ioc_notify.cbfn = & bfa_port_notify;
  port->ioc_notify.cbarg = (void *)port;
  list_add_tail(& port->ioc_notify.qe, & (port->ioc)->notify_q);
  do_gettimeofday(& tv);
  port->stats_reset_time = (u32 )tv.tv_sec;
  __bfa_trc(port->trcmod, __trc_fileno___10, 499, 0ULL);
  return;
}
}
void bfa_port_set_dportenabled(struct bfa_port_s *port , enum bfa_boolean enabled ) 
{ 


  {
  port->dport_enabled = enabled;
  return;
}
}
static void bfa_cee_get_attr_isr(struct bfa_cee_s *cee , enum bfa_status status ) 
{ 
  struct bfa_cee_lldp_cfg_s *lldp_cfg ;
  __u16 tmp ;
  __u16 tmp___0 ;

  {
  lldp_cfg = & (cee->attr)->lldp_remote;
  cee->get_attr_status = status;
  __bfa_trc(cee->trcmod, __trc_fileno___10, 537, 0ULL);
  if ((unsigned int )status == 0U) {
    __bfa_trc(cee->trcmod, __trc_fileno___10, 539, 0ULL);
    memcpy((void *)cee->attr, (void const   *)cee->attr_dma.kva, 832UL);
    tmp = __fswab16((int )lldp_cfg->time_to_live);
    lldp_cfg->time_to_live = tmp;
    tmp___0 = __fswab16((int )lldp_cfg->enabled_system_cap);
    lldp_cfg->enabled_system_cap = tmp___0;
  } else {

  }
  cee->get_attr_pending = 0;
  if ((unsigned long )cee->cbfn.get_attr_cbfn != (unsigned long )((void (*)(void * ,
                                                                            enum bfa_status  ))0)) {
    __bfa_trc(cee->trcmod, __trc_fileno___10, 548, 0ULL);
    (*(cee->cbfn.get_attr_cbfn))(cee->cbfn.get_attr_cbarg, status);
  } else {

  }
  return;
}
}
static void bfa_cee_get_stats_isr(struct bfa_cee_s *cee , enum bfa_status status ) 
{ 
  u32 *buffer ;
  int i ;
  __u32 tmp ;

  {
  cee->get_stats_status = status;
  __bfa_trc(cee->trcmod, __trc_fileno___10, 570, 0ULL);
  if ((unsigned int )status == 0U) {
    __bfa_trc(cee->trcmod, __trc_fileno___10, 572, 0ULL);
    memcpy((void *)cee->stats, (void const   *)cee->stats_dma.kva, 72UL);
    buffer = (u32 *)cee->stats;
    i = 0;
    goto ldv_48272;
    ldv_48271: 
    tmp = __fswab32(*(buffer + (unsigned long )i));
    *(buffer + (unsigned long )i) = tmp;
    i = i + 1;
    ldv_48272: ;
    if ((unsigned int )i <= 17U) {
      goto ldv_48271;
    } else {

    }

  } else {

  }
  cee->get_stats_pending = 0;
  __bfa_trc(cee->trcmod, __trc_fileno___10, 582, 0ULL);
  if ((unsigned long )cee->cbfn.get_stats_cbfn != (unsigned long )((void (*)(void * ,
                                                                             enum bfa_status  ))0)) {
    __bfa_trc(cee->trcmod, __trc_fileno___10, 584, 0ULL);
    (*(cee->cbfn.get_stats_cbfn))(cee->cbfn.get_stats_cbarg, status);
  } else {

  }
  return;
}
}
static void bfa_cee_reset_stats_isr(struct bfa_cee_s *cee , enum bfa_status status ) 
{ 


  {
  cee->reset_stats_status = status;
  cee->reset_stats_pending = 0;
  if ((unsigned long )cee->cbfn.reset_stats_cbfn != (unsigned long )((void (*)(void * ,
                                                                               enum bfa_status  ))0)) {
    (*(cee->cbfn.reset_stats_cbfn))(cee->cbfn.reset_stats_cbarg, status);
  } else {

  }
  return;
}
}
u32 bfa_cee_meminfo(void) 
{ 


  {
  return (1280U);
}
}
void bfa_cee_mem_claim(struct bfa_cee_s *cee , u8 *dma_kva , u64 dma_pa ) 
{ 


  {
  cee->attr_dma.kva = (void *)dma_kva;
  cee->attr_dma.pa = dma_pa;
  cee->stats_dma.kva = (void *)dma_kva + 1024U;
  cee->stats_dma.pa = dma_pa + 1024ULL;
  cee->attr = (struct bfa_cee_attr_s *)dma_kva;
  cee->stats = (struct bfa_cee_stats_s *)dma_kva + 1024U;
  return;
}
}
enum bfa_status bfa_cee_get_attr(struct bfa_cee_s *cee , struct bfa_cee_attr_s *attr ,
                                 void (*cbfn)(void * , enum bfa_status  ) , void *cbarg ) 
{ 
  struct bfi_cee_get_req_s *cmd ;
  int __ret_warn_on ;
  long tmp ;
  enum bfa_boolean tmp___0 ;

  {
  __ret_warn_on = (unsigned long )cee == (unsigned long )((struct bfa_cee_s *)0) || (unsigned long )cee->ioc == (unsigned long )((struct bfa_ioc_s *)0);
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_port.c",
                       666);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  __bfa_trc(cee->trcmod, __trc_fileno___10, 667, 0ULL);
  tmp___0 = bfa_ioc_is_operational(cee->ioc);
  if ((unsigned int )tmp___0 == 0U) {
    __bfa_trc(cee->trcmod, __trc_fileno___10, 669, 0ULL);
    return (56);
  } else {

  }
  if ((unsigned int )cee->get_attr_pending == 1U) {
    __bfa_trc(cee->trcmod, __trc_fileno___10, 673, 0ULL);
    return (13);
  } else {

  }
  cee->get_attr_pending = 1;
  cmd = (struct bfi_cee_get_req_s *)(& cee->get_cfg_mb.msg);
  cee->attr = attr;
  cee->cbfn.get_attr_cbfn = cbfn;
  cee->cbfn.get_attr_cbarg = cbarg;
  cmd->mh.msg_class = 4U;
  cmd->mh.msg_id = 1U;
  cmd->mh.mtag.h2i.fn_lpu = (cee->ioc)->port_id;
  __bfa_dma_be_addr_set(& cmd->dma_addr, cee->attr_dma.pa);
  bfa_ioc_mbox_queue(cee->ioc, & cee->get_cfg_mb);
  return (0);
}
}
enum bfa_status bfa_cee_get_stats(struct bfa_cee_s *cee , struct bfa_cee_stats_s *stats ,
                                  void (*cbfn)(void * , enum bfa_status  ) , void *cbarg ) 
{ 
  struct bfi_cee_get_req_s *cmd ;
  int __ret_warn_on ;
  long tmp ;
  enum bfa_boolean tmp___0 ;

  {
  __ret_warn_on = (unsigned long )cee == (unsigned long )((struct bfa_cee_s *)0) || (unsigned long )cee->ioc == (unsigned long )((struct bfa_ioc_s *)0);
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_port.c",
                       706);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  tmp___0 = bfa_ioc_is_operational(cee->ioc);
  if ((unsigned int )tmp___0 == 0U) {
    __bfa_trc(cee->trcmod, __trc_fileno___10, 709, 0ULL);
    return (56);
  } else {

  }
  if ((unsigned int )cee->get_stats_pending == 1U) {
    __bfa_trc(cee->trcmod, __trc_fileno___10, 713, 0ULL);
    return (13);
  } else {

  }
  cee->get_stats_pending = 1;
  cmd = (struct bfi_cee_get_req_s *)(& cee->get_stats_mb.msg);
  cee->stats = stats;
  cee->cbfn.get_stats_cbfn = cbfn;
  cee->cbfn.get_stats_cbarg = cbarg;
  cmd->mh.msg_class = 4U;
  cmd->mh.msg_id = 3U;
  cmd->mh.mtag.h2i.fn_lpu = (cee->ioc)->port_id;
  __bfa_dma_be_addr_set(& cmd->dma_addr, cee->stats_dma.pa);
  bfa_ioc_mbox_queue(cee->ioc, & cee->get_stats_mb);
  return (0);
}
}
enum bfa_status bfa_cee_reset_stats(struct bfa_cee_s *cee , void (*cbfn)(void * ,
                                                                         enum bfa_status  ) ,
                                    void *cbarg ) 
{ 
  struct bfi_cee_reset_stats_s *cmd ;
  int __ret_warn_on ;
  long tmp ;
  enum bfa_boolean tmp___0 ;

  {
  __ret_warn_on = (unsigned long )cee == (unsigned long )((struct bfa_cee_s *)0) || (unsigned long )cee->ioc == (unsigned long )((struct bfa_ioc_s *)0);
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_port.c",
                       745);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  tmp___0 = bfa_ioc_is_operational(cee->ioc);
  if ((unsigned int )tmp___0 == 0U) {
    __bfa_trc(cee->trcmod, __trc_fileno___10, 747, 0ULL);
    return (56);
  } else {

  }
  if ((unsigned int )cee->reset_stats_pending == 1U) {
    __bfa_trc(cee->trcmod, __trc_fileno___10, 751, 0ULL);
    return (13);
  } else {

  }
  cee->reset_stats_pending = 1;
  cmd = (struct bfi_cee_reset_stats_s *)(& cee->reset_stats_mb.msg);
  cee->cbfn.reset_stats_cbfn = cbfn;
  cee->cbfn.reset_stats_cbarg = cbarg;
  cmd->mh.msg_class = 4U;
  cmd->mh.msg_id = 2U;
  cmd->mh.mtag.h2i.fn_lpu = (cee->ioc)->port_id;
  bfa_ioc_mbox_queue(cee->ioc, & cee->reset_stats_mb);
  return (0);
}
}
void bfa_cee_isr(void *cbarg , struct bfi_mbmsg_s *m ) 
{ 
  union bfi_cee_i2h_msg_u *msg ;
  struct bfi_cee_get_rsp_s *get_rsp ;
  struct bfa_cee_s *cee ;
  int __ret_warn_on ;
  long tmp ;

  {
  cee = (struct bfa_cee_s *)cbarg;
  msg = (union bfi_cee_i2h_msg_u *)m;
  get_rsp = (struct bfi_cee_get_rsp_s *)m;
  __bfa_trc(cee->trcmod, __trc_fileno___10, 783, (unsigned long long )msg->mh.msg_id);
  switch ((int )msg->mh.msg_id) {
  case 129: 
  __bfa_trc(cee->trcmod, __trc_fileno___10, 786, (unsigned long long )get_rsp->cmd_status);
  bfa_cee_get_attr_isr(cee, (enum bfa_status )get_rsp->cmd_status);
  goto ldv_48320;
  case 131: 
  bfa_cee_get_stats_isr(cee, (enum bfa_status )get_rsp->cmd_status);
  goto ldv_48320;
  case 130: 
  bfa_cee_reset_stats_isr(cee, (enum bfa_status )get_rsp->cmd_status);
  goto ldv_48320;
  default: 
  __ret_warn_on = 1;
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_port.c",
                       796);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  }
  ldv_48320: ;
  return;
}
}
void bfa_cee_notify(void *arg , enum bfa_ioc_event_e event ) 
{ 
  struct bfa_cee_s *cee ;

  {
  cee = (struct bfa_cee_s *)arg;
  __bfa_trc(cee->trcmod, __trc_fileno___10, 816, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 2U: ;
  case 3U: ;
  if ((unsigned int )cee->get_attr_pending == 1U) {
    cee->get_attr_status = 1;
    cee->get_attr_pending = 0;
    if ((unsigned long )cee->cbfn.get_attr_cbfn != (unsigned long )((void (*)(void * ,
                                                                              enum bfa_status  ))0)) {
      (*(cee->cbfn.get_attr_cbfn))(cee->cbfn.get_attr_cbarg, 1);
    } else {

    }
  } else {

  }
  if ((unsigned int )cee->get_stats_pending == 1U) {
    cee->get_stats_status = 1;
    cee->get_stats_pending = 0;
    if ((unsigned long )cee->cbfn.get_stats_cbfn != (unsigned long )((void (*)(void * ,
                                                                               enum bfa_status  ))0)) {
      (*(cee->cbfn.get_stats_cbfn))(cee->cbfn.get_stats_cbarg, 1);
    } else {

    }
  } else {

  }
  if ((unsigned int )cee->reset_stats_pending == 1U) {
    cee->reset_stats_status = 1;
    cee->reset_stats_pending = 0;
    if ((unsigned long )cee->cbfn.reset_stats_cbfn != (unsigned long )((void (*)(void * ,
                                                                                 enum bfa_status  ))0)) {
      (*(cee->cbfn.reset_stats_cbfn))(cee->cbfn.reset_stats_cbarg, 1);
    } else {

    }
  } else {

  }
  goto ldv_48333;
  default: ;
  goto ldv_48333;
  }
  ldv_48333: ;
  return;
}
}
void bfa_cee_attach(struct bfa_cee_s *cee , struct bfa_ioc_s *ioc , void *dev ) 
{ 
  int __ret_warn_on ;
  long tmp ;

  {
  __ret_warn_on = (unsigned long )cee == (unsigned long )((struct bfa_cee_s *)0);
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_port.c",
                       872);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  cee->dev = dev;
  cee->ioc = ioc;
  bfa_ioc_mbox_regisr(cee->ioc, 4, & bfa_cee_isr, (void *)cee);
  ((struct list_head *)(& cee->ioc_notify))->next = (struct list_head *)0;
  ((struct list_head *)(& cee->ioc_notify))->prev = (struct list_head *)0;
  cee->ioc_notify.cbfn = & bfa_cee_notify;
  cee->ioc_notify.cbarg = (void *)cee;
  list_add_tail(& cee->ioc_notify.qe, & (cee->ioc)->notify_q);
  return;
}
}
bool ldv_queue_work_on_537(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_3(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_delayed_work_on_538(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_3(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_work_on_539(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_3(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
void ldv_flush_workqueue_540(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
  flush_workqueue(ldv_func_arg1);
  call_and_disable_all_3(2);
  return;
}
}
bool ldv_queue_delayed_work_on_541(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_3(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
void ldv_mutex_lock_542(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_lock_lock(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_543(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_unlock_lock(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_544(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
int ldv_mutex_trylock_545(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
  tmp = mutex_trylock(ldv_func_arg1);
  ldv_func_res = tmp;
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
  return (tmp___0);
  return (ldv_func_res);
}
}
void ldv_mutex_unlock_546(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_547(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_unlock_i_mutex_of_inode(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_548(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_lock_i_mutex_of_inode(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
int ldv_scsi_add_host_with_dma_549(struct Scsi_Host *shost , struct device *dev ,
                                   struct device *dma_dev ) 
{ 
  ldv_func_ret_type___4 ldv_func_res ;
  int tmp ;

  {
  tmp = scsi_add_host_with_dma(shost, dev, dma_dev);
  ldv_func_res = tmp;
  if (ldv_func_res == 0) {
    ldv_state_variable_35 = 1;
    ldv_initialize_scsi_host_template_35();
  } else {

  }
  return (ldv_func_res);
}
}
__inline static long ldv__builtin_expect(long exp , long c ) ;
__inline static void __list_splice(struct list_head  const  *list , struct list_head *prev ,
                                   struct list_head *next ) 
{ 
  struct list_head *first ;
  struct list_head *last ;

  {
  first = list->next;
  last = list->prev;
  first->prev = prev;
  prev->next = first;
  last->next = next;
  next->prev = last;
  return;
}
}
__inline static void list_splice_tail_init(struct list_head *list , struct list_head *head ) 
{ 
  int tmp ;

  {
  tmp = list_empty((struct list_head  const  *)list);
  if (tmp == 0) {
    __list_splice((struct list_head  const  *)list, head->prev, head);
    INIT_LIST_HEAD(list);
  } else {

  }
  return;
}
}
int ldv_mutex_trylock_575(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_573(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_576(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_577(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_572(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_574(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_578(struct mutex *ldv_func_arg1 ) ;
bool ldv_queue_work_on_567(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_work_on_569(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_delayed_work_on_568(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
bool ldv_queue_delayed_work_on_571(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
void ldv_flush_workqueue_570(struct workqueue_struct *ldv_func_arg1 ) ;
extern struct scatterlist *sg_next(struct scatterlist * ) ;
int ldv_scsi_add_host_with_dma_579(struct Scsi_Host *shost , struct device *dev ,
                                   struct device *dma_dev ) ;
__inline static struct scatterlist *scsi_sglist(struct scsi_cmnd *cmd ) 
{ 


  {
  return (cmd->sdb.table.sgl);
}
}
__inline static void bfa_reqq_winit(struct bfa_reqq_wait_s *wqe , void (*qresume)(void * ) ,
                                    void *cbarg ) 
{ 


  {
  wqe->qresume = qresume;
  wqe->cbarg = cbarg;
  return;
}
}
void bfa_iocfc_set_snsbase(struct bfa_s *bfa , int seg_no , u64 snsbase_pa ) ;
enum bfa_status bfa_sgpg_malloc(struct bfa_s *bfa , struct list_head *sgpg_q , int nsgpgs ) ;
void bfa_sgpg_mfree(struct bfa_s *bfa , struct list_head *sgpg_q , int nsgpg ) ;
void bfa_sgpg_winit(struct bfa_sgpg_wqe_s *wqe , void (*cbfn)(void * ) , void *cbarg ) ;
void bfa_sgpg_wait(struct bfa_s *bfa , struct bfa_sgpg_wqe_s *wqe , int nsgpg ) ;
void bfa_sgpg_wcancel(struct bfa_s *bfa , struct bfa_sgpg_wqe_s *wqe ) ;
void bfa_rport_unset_lunmask(struct bfa_s *bfa , struct bfa_rport_s *rp ) ;
void bfa_itn_create(struct bfa_s *bfa , struct bfa_rport_s *rport , void (*isr)(struct bfa_s * ,
                                                                                struct bfi_msg_s * ) ) ;
void bfa_itn_isr(struct bfa_s *bfa , struct bfi_msg_s *m ) ;
void bfa_iotag_attach(struct bfa_fcp_mod_s *fcp ) ;
void bfa_fcp_res_recfg(struct bfa_s *bfa , u16 num_ioim_fw , u16 max_ioim_fw ) ;
__inline static u32 bfa_ioim_get_index(u32 n ) 
{ 
  int pos ;
    klee_make_symbolic(&pos, sizeof(int), "pos");

  {
  pos = 0;
  if (n > 4194303U) {
    return (13U);
  } else {

  }
  n = n >> 8;
  if (n > 65535U) {
    n = n >> 16;
    pos = pos + 16;
  } else {

  }
  if (n > 255U) {
    n = n >> 8;
    pos = pos + 8;
  } else {

  }
  if (n > 15U) {
    n = n >> 4;
    pos = pos + 4;
  } else {

  }
  if (n > 3U) {
    n = n >> 2;
    pos = pos + 2;
  } else {

  }
  if (n > 1U) {
    pos = pos + 1;
  } else {

  }
  return (n != 0U ? (u32 )pos : 0U);
}
}
__inline static enum bfa_boolean bfa_ioim_maxretry_reached(struct bfa_ioim_s *ioim ) 
{ 
  uint16_t k ;

  {
  k = (uint16_t )((int )ioim->iotag >> 11);
  if ((unsigned int )k <= 6U) {
    return (0);
  } else {

  }
  return (1);
}
}
void bfa_ioim_attach(struct bfa_fcpim_s *fcpim ) ;
void bfa_ioim_isr(struct bfa_s *bfa , struct bfi_msg_s *m ) ;
void bfa_ioim_good_comp_isr(struct bfa_s *bfa , struct bfi_msg_s *m ) ;
void bfa_ioim_cleanup(struct bfa_ioim_s *ioim ) ;
void bfa_ioim_cleanup_tm(struct bfa_ioim_s *ioim , struct bfa_tskim_s *tskim ) ;
void bfa_ioim_iocdisable(struct bfa_ioim_s *ioim ) ;
void bfa_ioim_tov(struct bfa_ioim_s *ioim ) ;
void bfa_tskim_attach(struct bfa_fcpim_s *fcpim ) ;
void bfa_tskim_isr(struct bfa_s *bfa , struct bfi_msg_s *m ) ;
void bfa_tskim_iodone(struct bfa_tskim_s *tskim ) ;
void bfa_tskim_iocdisable(struct bfa_tskim_s *tskim ) ;
void bfa_tskim_cleanup(struct bfa_tskim_s *tskim ) ;
void bfa_tskim_res_recfg(struct bfa_s *bfa , u16 num_tskim_fw ) ;
void bfa_itnim_meminfo(struct bfa_iocfc_cfg_s *cfg , u32 *km_len ) ;
void bfa_itnim_attach(struct bfa_fcpim_s *fcpim ) ;
void bfa_itnim_iocdisable(struct bfa_itnim_s *itnim ) ;
void bfa_itnim_isr(struct bfa_s *bfa , struct bfi_msg_s *m ) ;
void bfa_itnim_iodone(struct bfa_itnim_s *itnim ) ;
void bfa_itnim_tskdone(struct bfa_itnim_s *itnim ) ;
enum bfa_boolean bfa_itnim_hold_io(struct bfa_itnim_s *itnim ) ;
u16 bfa_fcpim_qdepth_get(struct bfa_s *bfa ) ;
void bfa_ioim_free(struct bfa_ioim_s *ioim ) ;
void bfa_ioim_delayed_comp(struct bfa_ioim_s *ioim , enum bfa_boolean iotov ) ;
void bfa_tskim_free(struct bfa_tskim_s *tskim ) ;
void bfa_fcpim_lunmask_rp_update(struct bfa_s *bfa , wwn_t lp_wwn , wwn_t rp_wwn ,
                                 u16 rp_tag , u8 lp_tag ) ;
u16 bfa_fcpim_read_throttle(struct bfa_s *bfa ) ;
enum bfa_status bfa_fcpim_write_throttle(struct bfa_s *bfa , u16 value ) ;
u16 bfa_fcpim_get_throttle_cfg(struct bfa_s *bfa , u16 drv_cfg_param ) ;
struct bfa_module_s hal_mod_fcp ;
static int __trc_fileno___11  =    1027;
static void bfa_itnim_update_del_itn_stats(struct bfa_itnim_s *itnim ) ;
static void bfa_ioim_lm_init(struct bfa_s *bfa ) ;
static void bfa_itnim_iocdisable_cleanup(struct bfa_itnim_s *itnim ) ;
static enum bfa_boolean bfa_itnim_send_fwcreate(struct bfa_itnim_s *itnim ) ;
static enum bfa_boolean bfa_itnim_send_fwdelete(struct bfa_itnim_s *itnim ) ;
static void bfa_itnim_cleanp_comp(void *itnim_cbarg ) ;
static void bfa_itnim_cleanup(struct bfa_itnim_s *itnim ) ;
static void __bfa_cb_itnim_online(void *cbarg , enum bfa_boolean complete___0 ) ;
static void __bfa_cb_itnim_offline(void *cbarg , enum bfa_boolean complete___0 ) ;
static void __bfa_cb_itnim_sler(void *cbarg , enum bfa_boolean complete___0 ) ;
static void bfa_itnim_iotov_online(struct bfa_itnim_s *itnim ) ;
static void bfa_itnim_iotov_cleanup(struct bfa_itnim_s *itnim ) ;
static void bfa_itnim_iotov(void *itnim_arg ) ;
static void bfa_itnim_iotov_start(struct bfa_itnim_s *itnim ) ;
static void bfa_itnim_iotov_stop(struct bfa_itnim_s *itnim ) ;
static void bfa_itnim_iotov_delete(struct bfa_itnim_s *itnim ) ;
static void bfa_itnim_sm_uninit(struct bfa_itnim_s *itnim , enum bfa_itnim_event event ) ;
static void bfa_itnim_sm_created(struct bfa_itnim_s *itnim , enum bfa_itnim_event event ) ;
static void bfa_itnim_sm_fwcreate(struct bfa_itnim_s *itnim , enum bfa_itnim_event event ) ;
static void bfa_itnim_sm_delete_pending(struct bfa_itnim_s *itnim , enum bfa_itnim_event event ) ;
static void bfa_itnim_sm_online(struct bfa_itnim_s *itnim , enum bfa_itnim_event event ) ;
static void bfa_itnim_sm_sler(struct bfa_itnim_s *itnim , enum bfa_itnim_event event ) ;
static void bfa_itnim_sm_cleanup_offline(struct bfa_itnim_s *itnim , enum bfa_itnim_event event ) ;
static void bfa_itnim_sm_cleanup_delete(struct bfa_itnim_s *itnim , enum bfa_itnim_event event ) ;
static void bfa_itnim_sm_fwdelete(struct bfa_itnim_s *itnim , enum bfa_itnim_event event ) ;
static void bfa_itnim_sm_offline(struct bfa_itnim_s *itnim , enum bfa_itnim_event event ) ;
static void bfa_itnim_sm_iocdisable(struct bfa_itnim_s *itnim , enum bfa_itnim_event event ) ;
static void bfa_itnim_sm_deleting(struct bfa_itnim_s *itnim , enum bfa_itnim_event event ) ;
static void bfa_itnim_sm_fwcreate_qfull(struct bfa_itnim_s *itnim , enum bfa_itnim_event event ) ;
static void bfa_itnim_sm_fwdelete_qfull(struct bfa_itnim_s *itnim , enum bfa_itnim_event event ) ;
static void bfa_itnim_sm_deleting_qfull(struct bfa_itnim_s *itnim , enum bfa_itnim_event event ) ;
static enum bfa_boolean bfa_ioim_send_ioreq(struct bfa_ioim_s *ioim ) ;
static enum bfa_boolean bfa_ioim_sgpg_alloc(struct bfa_ioim_s *ioim ) ;
static enum bfa_boolean bfa_ioim_send_abort(struct bfa_ioim_s *ioim ) ;
static void bfa_ioim_notify_cleanup(struct bfa_ioim_s *ioim ) ;
static void __bfa_cb_ioim_good_comp(void *cbarg , enum bfa_boolean complete___0 ) ;
static void __bfa_cb_ioim_comp(void *cbarg , enum bfa_boolean complete___0 ) ;
static void __bfa_cb_ioim_abort(void *cbarg , enum bfa_boolean complete___0 ) ;
static void __bfa_cb_ioim_failed(void *cbarg , enum bfa_boolean complete___0 ) ;
static void __bfa_cb_ioim_pathtov(void *cbarg , enum bfa_boolean complete___0 ) ;
static enum bfa_boolean bfa_ioim_is_abortable(struct bfa_ioim_s *ioim ) ;
static void bfa_ioim_sm_uninit(struct bfa_ioim_s *ioim , enum bfa_ioim_event event ) ;
static void bfa_ioim_sm_sgalloc(struct bfa_ioim_s *ioim , enum bfa_ioim_event event ) ;
static void bfa_ioim_sm_active(struct bfa_ioim_s *ioim , enum bfa_ioim_event event ) ;
static void bfa_ioim_sm_abort(struct bfa_ioim_s *ioim , enum bfa_ioim_event event ) ;
static void bfa_ioim_sm_cleanup(struct bfa_ioim_s *ioim , enum bfa_ioim_event event ) ;
static void bfa_ioim_sm_qfull(struct bfa_ioim_s *ioim , enum bfa_ioim_event event ) ;
static void bfa_ioim_sm_abort_qfull(struct bfa_ioim_s *ioim , enum bfa_ioim_event event ) ;
static void bfa_ioim_sm_cleanup_qfull(struct bfa_ioim_s *ioim , enum bfa_ioim_event event ) ;
static void bfa_ioim_sm_hcb(struct bfa_ioim_s *ioim , enum bfa_ioim_event event ) ;
static void bfa_ioim_sm_hcb_free(struct bfa_ioim_s *ioim , enum bfa_ioim_event event ) ;
static void bfa_ioim_sm_resfree(struct bfa_ioim_s *ioim , enum bfa_ioim_event event ) ;
static void bfa_ioim_sm_cmnd_retry(struct bfa_ioim_s *ioim , enum bfa_ioim_event event ) ;
static void __bfa_cb_tskim_done(void *cbarg , enum bfa_boolean complete___0 ) ;
static void __bfa_cb_tskim_failed(void *cbarg , enum bfa_boolean complete___0 ) ;
static enum bfa_boolean bfa_tskim_match_scope(struct bfa_tskim_s *tskim , struct scsi_lun lun ) ;
static void bfa_tskim_gather_ios(struct bfa_tskim_s *tskim ) ;
static void bfa_tskim_cleanp_comp(void *tskim_cbarg ) ;
static void bfa_tskim_cleanup_ios(struct bfa_tskim_s *tskim ) ;
static enum bfa_boolean bfa_tskim_send(struct bfa_tskim_s *tskim ) ;
static enum bfa_boolean bfa_tskim_send_abort(struct bfa_tskim_s *tskim ) ;
static void bfa_tskim_iocdisable_ios(struct bfa_tskim_s *tskim ) ;
static void bfa_tskim_sm_uninit(struct bfa_tskim_s *tskim , enum bfa_tskim_event event ) ;
static void bfa_tskim_sm_active(struct bfa_tskim_s *tskim , enum bfa_tskim_event event ) ;
static void bfa_tskim_sm_cleanup(struct bfa_tskim_s *tskim , enum bfa_tskim_event event ) ;
static void bfa_tskim_sm_iocleanup(struct bfa_tskim_s *tskim , enum bfa_tskim_event event ) ;
static void bfa_tskim_sm_qfull(struct bfa_tskim_s *tskim , enum bfa_tskim_event event ) ;
static void bfa_tskim_sm_cleanup_qfull(struct bfa_tskim_s *tskim , enum bfa_tskim_event event ) ;
static void bfa_tskim_sm_hcb(struct bfa_tskim_s *tskim , enum bfa_tskim_event event ) ;
static void bfa_fcpim_meminfo(struct bfa_iocfc_cfg_s *cfg , u32 *km_len ) 
{ 


  {
  bfa_itnim_meminfo(cfg, km_len);
  *km_len = *km_len + (u32 )cfg->fwcfg.num_ioim_reqs * 400U;
  if ((unsigned int )cfg->fwcfg.num_tskim_reqs <= 3U) {
    cfg->fwcfg.num_tskim_reqs = 4U;
  } else {

  }
  *km_len = *km_len + (u32 )cfg->fwcfg.num_tskim_reqs * 208U;
  return;
}
}
static void bfa_fcpim_attach(struct bfa_fcp_mod_s *fcp , void *bfad , struct bfa_iocfc_cfg_s *cfg ,
                             struct bfa_pcidev_s *pcidev ) 
{ 
  struct bfa_fcpim_s *fcpim ;
  struct bfa_s *bfa ;

  {
  fcpim = & fcp->fcpim;
  bfa = fcp->bfa;
  __bfa_trc(bfa->trcmod, __trc_fileno___11, 322, (unsigned long long )cfg->drvcfg.path_tov);
  __bfa_trc(bfa->trcmod, __trc_fileno___11, 323, (unsigned long long )cfg->fwcfg.num_rports);
  __bfa_trc(bfa->trcmod, __trc_fileno___11, 324, (unsigned long long )cfg->fwcfg.num_ioim_reqs);
  __bfa_trc(bfa->trcmod, __trc_fileno___11, 325, (unsigned long long )cfg->fwcfg.num_tskim_reqs);
  fcpim->fcp = fcp;
  fcpim->bfa = bfa;
  fcpim->num_itnims = (int )cfg->fwcfg.num_rports;
  fcpim->num_tskim_reqs = (int )cfg->fwcfg.num_tskim_reqs;
  fcpim->path_tov = (u32 )cfg->drvcfg.path_tov;
  fcpim->delay_comp = (u32 )cfg->drvcfg.delay_comp;
  fcpim->profile_comp = (void (*)(struct bfa_ioim_s * ))0;
  fcpim->profile_start = (void (*)(struct bfa_ioim_s * ))0;
  bfa_itnim_attach(fcpim);
  bfa_tskim_attach(fcpim);
  bfa_ioim_attach(fcpim);
  return;
}
}
static void bfa_fcpim_iocdisable(struct bfa_fcp_mod_s *fcp ) 
{ 
  struct bfa_fcpim_s *fcpim ;
  struct bfa_itnim_s *itnim ;
  struct list_head *qe ;
  struct list_head *qen ;

  {
  fcpim = & fcp->fcpim;
  list_splice_tail_init(& fcpim->tskim_unused_q, & fcpim->tskim_free_q);
  qe = fcpim->itnim_q.next;
  qen = qe->next;
  goto ldv_48407;
  ldv_48406: 
  itnim = (struct bfa_itnim_s *)qe;
  bfa_itnim_iocdisable(itnim);
  qe = qen;
  qen = qe->next;
  ldv_48407: ;
  if ((unsigned long )(& fcpim->itnim_q) != (unsigned long )qe) {
    goto ldv_48406;
  } else {

  }

  return;
}
}
void bfa_fcpim_path_tov_set(struct bfa_s *bfa , u16 path_tov ) 
{ 
  struct bfa_fcpim_s *fcpim ;

  {
  fcpim = & bfa->modules.fcp_mod.fcpim;
  fcpim->path_tov = (u32 )((int )path_tov * 1000);
  if (fcpim->path_tov > 90000U) {
    fcpim->path_tov = 90000U;
  } else {

  }
  return;
}
}
u16 bfa_fcpim_path_tov_get(struct bfa_s *bfa ) 
{ 
  struct bfa_fcpim_s *fcpim ;

  {
  fcpim = & bfa->modules.fcp_mod.fcpim;
  return ((u16 )(fcpim->path_tov / 1000U));
}
}
void bfa_fcpim_add_stats(struct bfa_itnim_iostats_s *lstats , struct bfa_itnim_iostats_s *rstats ) 
{ 


  {
  lstats->total_ios = lstats->total_ios + rstats->total_ios;
  lstats->qresumes = lstats->qresumes + rstats->qresumes;
  lstats->no_iotags = lstats->no_iotags + rstats->no_iotags;
  lstats->io_aborts = lstats->io_aborts + rstats->io_aborts;
  lstats->no_tskims = lstats->no_tskims + rstats->no_tskims;
  lstats->iocomp_ok = lstats->iocomp_ok + rstats->iocomp_ok;
  lstats->iocomp_underrun = lstats->iocomp_underrun + rstats->iocomp_underrun;
  lstats->iocomp_overrun = lstats->iocomp_overrun + rstats->iocomp_overrun;
  lstats->iocomp_aborted = lstats->iocomp_aborted + rstats->iocomp_aborted;
  lstats->iocomp_timedout = lstats->iocomp_timedout + rstats->iocomp_timedout;
  lstats->iocom_nexus_abort = lstats->iocom_nexus_abort + rstats->iocom_nexus_abort;
  lstats->iocom_proto_err = lstats->iocom_proto_err + rstats->iocom_proto_err;
  lstats->iocom_dif_err = lstats->iocom_dif_err + rstats->iocom_dif_err;
  lstats->iocom_sqer_needed = lstats->iocom_sqer_needed + rstats->iocom_sqer_needed;
  lstats->iocom_res_free = lstats->iocom_res_free + rstats->iocom_res_free;
  lstats->iocom_hostabrts = lstats->iocom_hostabrts + rstats->iocom_hostabrts;
  lstats->iocom_utags = lstats->iocom_utags + rstats->iocom_utags;
  lstats->io_cleanups = lstats->io_cleanups + rstats->io_cleanups;
  lstats->io_tmaborts = lstats->io_tmaborts + rstats->io_tmaborts;
  lstats->onlines = lstats->onlines + rstats->onlines;
  lstats->offlines = lstats->offlines + rstats->offlines;
  lstats->creates = lstats->creates + rstats->creates;
  lstats->deletes = lstats->deletes + rstats->deletes;
  lstats->create_comps = lstats->create_comps + rstats->create_comps;
  lstats->delete_comps = lstats->delete_comps + rstats->delete_comps;
  lstats->sler_events = lstats->sler_events + rstats->sler_events;
  lstats->fw_create = lstats->fw_create + rstats->fw_create;
  lstats->fw_delete = lstats->fw_delete + rstats->fw_delete;
  lstats->ioc_disabled = lstats->ioc_disabled + rstats->ioc_disabled;
  lstats->cleanup_comps = lstats->cleanup_comps + rstats->cleanup_comps;
  lstats->tm_cmnds = lstats->tm_cmnds + rstats->tm_cmnds;
  lstats->tm_fw_rsps = lstats->tm_fw_rsps + rstats->tm_fw_rsps;
  lstats->tm_success = lstats->tm_success + rstats->tm_success;
  lstats->tm_failures = lstats->tm_failures + rstats->tm_failures;
  lstats->tm_io_comps = lstats->tm_io_comps + rstats->tm_io_comps;
  lstats->tm_qresumes = lstats->tm_qresumes + rstats->tm_qresumes;
  lstats->tm_iocdowns = lstats->tm_iocdowns + rstats->tm_iocdowns;
  lstats->tm_cleanups = lstats->tm_cleanups + rstats->tm_cleanups;
  lstats->tm_cleanup_comps = lstats->tm_cleanup_comps + rstats->tm_cleanup_comps;
  lstats->io_comps = lstats->io_comps + rstats->io_comps;
  lstats->input_reqs = lstats->input_reqs + rstats->input_reqs;
  lstats->output_reqs = lstats->output_reqs + rstats->output_reqs;
  lstats->rd_throughput = lstats->rd_throughput + rstats->rd_throughput;
  lstats->wr_throughput = lstats->wr_throughput + rstats->wr_throughput;
  return;
}
}
enum bfa_status bfa_fcpim_port_iostats(struct bfa_s *bfa , struct bfa_itnim_iostats_s *stats ,
                                       u8 lp_tag ) 
{ 
  struct bfa_fcpim_s *fcpim ;
  struct list_head *qe ;
  struct list_head *qen ;
  struct bfa_itnim_s *itnim ;

  {
  fcpim = & bfa->modules.fcp_mod.fcpim;
  memset((void *)stats, 0, 216UL);
  qe = fcpim->itnim_q.next;
  qen = qe->next;
  goto ldv_48433;
  ldv_48432: 
  itnim = (struct bfa_itnim_s *)qe;
  if ((int )(itnim->rport)->rport_info.lp_tag != (int )lp_tag) {
    goto ldv_48431;
  } else {

  }
  bfa_fcpim_add_stats(stats, & itnim->stats);
  ldv_48431: 
  qe = qen;
  qen = qe->next;
  ldv_48433: ;
  if ((unsigned long )(& fcpim->itnim_q) != (unsigned long )qe) {
    goto ldv_48432;
  } else {

  }

  return (0);
}
}
void bfa_ioim_profile_comp(struct bfa_ioim_s *ioim ) 
{ 
  struct bfa_itnim_latency_s *io_lat ;
  u32 val ;
  u32 idx ;
  unsigned int tmp ;

  {
  io_lat = & (ioim->itnim)->ioprofile.io_latency;
  val = (unsigned int )jiffies - (unsigned int )ioim->start_time;
  tmp = scsi_bufflen((struct scsi_cmnd *)ioim->dio);
  idx = bfa_ioim_get_index(tmp);
  (ioim->itnim)->ioprofile.iocomps[idx] = (ioim->itnim)->ioprofile.iocomps[idx] + 1U;
  io_lat->count[idx] = io_lat->count[idx] + 1U;
  io_lat->min[idx] = val < io_lat->min[idx] ? val : io_lat->min[idx];
  io_lat->max[idx] = val > io_lat->max[idx] ? val : io_lat->max[idx];
  io_lat->avg[idx] = io_lat->avg[idx] + val;
  return;
}
}
void bfa_ioim_profile_start(struct bfa_ioim_s *ioim ) 
{ 


  {
  ioim->start_time = (u64 )jiffies;
  return;
}
}
enum bfa_status bfa_fcpim_profile_on(struct bfa_s *bfa , u32 time ) 
{ 
  struct bfa_itnim_s *itnim ;
  struct bfa_fcpim_s *fcpim ;
  struct list_head *qe ;
  struct list_head *qen ;

  {
  fcpim = & bfa->modules.fcp_mod.fcpim;
  qe = fcpim->itnim_q.next;
  qen = qe->next;
  goto ldv_48453;
  ldv_48452: 
  itnim = (struct bfa_itnim_s *)qe;
  bfa_itnim_clear_stats(itnim);
  qe = qen;
  qen = qe->next;
  ldv_48453: ;
  if ((unsigned long )(& fcpim->itnim_q) != (unsigned long )qe) {
    goto ldv_48452;
  } else {

  }
  fcpim->io_profile = 1;
  fcpim->io_profile_start_time = time;
  fcpim->profile_comp = & bfa_ioim_profile_comp;
  fcpim->profile_start = & bfa_ioim_profile_start;
  return (0);
}
}
enum bfa_status bfa_fcpim_profile_off(struct bfa_s *bfa ) 
{ 
  struct bfa_fcpim_s *fcpim ;

  {
  fcpim = & bfa->modules.fcp_mod.fcpim;
  fcpim->io_profile = 0;
  fcpim->io_profile_start_time = 0U;
  fcpim->profile_comp = (void (*)(struct bfa_ioim_s * ))0;
  fcpim->profile_start = (void (*)(struct bfa_ioim_s * ))0;
  return (0);
}
}
u16 bfa_fcpim_qdepth_get(struct bfa_s *bfa ) 
{ 
  struct bfa_fcpim_s *fcpim ;

  {
  fcpim = & bfa->modules.fcp_mod.fcpim;
  return (fcpim->q_depth);
}
}
static void bfa_itnim_sm_uninit(struct bfa_itnim_s *itnim , enum bfa_itnim_event event ) 
{ 


  {
  __bfa_trc((itnim->bfa)->trcmod, __trc_fileno___11, 518, (unsigned long long )(itnim->rport)->rport_tag);
  __bfa_trc((itnim->bfa)->trcmod, __trc_fileno___11, 519, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 1U: 
  itnim->sm = (void (*)(void * , int  ))(& bfa_itnim_sm_created);
  itnim->is_online = 0;
  list_add_tail(& itnim->qe, & (itnim->fcpim)->itnim_q);
  goto ldv_48468;
  default: 
  __bfa_trc((itnim->bfa)->trcmod, __trc_fileno___11, 529, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcpim.c",
         529, (unsigned int )event);
  }
  ldv_48468: ;
  return;
}
}
static void bfa_itnim_sm_created(struct bfa_itnim_s *itnim , enum bfa_itnim_event event ) 
{ 
  enum bfa_boolean tmp ;
  int __ret_warn_on ;
  int tmp___0 ;
  long tmp___1 ;
  int __ret_warn_on___0 ;
  int tmp___2 ;
  long tmp___3 ;
  int __ret_warn_on___1 ;
  int tmp___4 ;
  long tmp___5 ;
  int __ret_warn_on___2 ;
    klee_make_symbolic(&__ret_warn_on___2, sizeof(int), "__ret_warn_on___2");
  int tmp___6 ;
  long tmp___7 ;
    klee_make_symbolic(&tmp___7, sizeof(long), "tmp___7");

  {
  __bfa_trc((itnim->bfa)->trcmod, __trc_fileno___11, 539, (unsigned long long )(itnim->rport)->rport_tag);
  __bfa_trc((itnim->bfa)->trcmod, __trc_fileno___11, 540, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 2U: 
  tmp = bfa_itnim_send_fwcreate(itnim);
  if ((unsigned int )tmp != 0U) {
    itnim->sm = (void (*)(void * , int  ))(& bfa_itnim_sm_fwcreate);
  } else {
    itnim->sm = (void (*)(void * , int  ))(& bfa_itnim_sm_fwcreate_qfull);
  }
  goto ldv_48475;
  case 5U: 
  itnim->sm = (void (*)(void * , int  ))(& bfa_itnim_sm_uninit);
  tmp___0 = bfa_q_is_on_q_func(& (itnim->fcpim)->itnim_q, (struct list_head *)itnim);
  __ret_warn_on = tmp___0 == 0;
  tmp___1 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp___1 != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcpim.c",
                       552);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  bfa_itnim_update_del_itn_stats(itnim);
  list_del(& itnim->qe);
  tmp___2 = list_empty((struct list_head  const  *)(& itnim->io_q));
  __ret_warn_on___0 = tmp___2 == 0;
  tmp___3 = ldv__builtin_expect(__ret_warn_on___0 != 0, 0L);
  if (tmp___3 != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcpim.c",
                       552);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on___0 != 0, 0L);
  tmp___4 = list_empty((struct list_head  const  *)(& itnim->io_cleanup_q));
  __ret_warn_on___1 = tmp___4 == 0;
  tmp___5 = ldv__builtin_expect(__ret_warn_on___1 != 0, 0L);
  if (tmp___5 != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcpim.c",
                       552);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on___1 != 0, 0L);
  tmp___6 = list_empty((struct list_head  const  *)(& itnim->pending_q));
  __ret_warn_on___2 = tmp___6 == 0;
  tmp___7 = ldv__builtin_expect(__ret_warn_on___2 != 0, 0L);
  if (tmp___7 != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcpim.c",
                       552);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on___2 != 0, 0L);
  goto ldv_48475;
  case 8U: 
  itnim->sm = (void (*)(void * , int  ))(& bfa_itnim_sm_iocdisable);
  goto ldv_48475;
  default: 
  __bfa_trc((itnim->bfa)->trcmod, __trc_fileno___11, 560, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcpim.c",
         560, (unsigned int )event);
  }
  ldv_48475: ;
  return;
}
}
static void bfa_itnim_sm_fwcreate(struct bfa_itnim_s *itnim , enum bfa_itnim_event event ) 
{ 
  enum bfa_boolean tmp ;

  {
  __bfa_trc((itnim->bfa)->trcmod, __trc_fileno___11, 570, (unsigned long long )(itnim->rport)->rport_tag);
  __bfa_trc((itnim->bfa)->trcmod, __trc_fileno___11, 571, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 4U: 
  itnim->sm = (void (*)(void * , int  ))(& bfa_itnim_sm_online);
  itnim->is_online = 1;
  bfa_itnim_iotov_online(itnim);
  if ((unsigned int )(itnim->bfa)->fcs != 0U) {
    bfa_cb_itnim_online(itnim->ditn);
  } else {
    itnim->hcb_qe.cbfn = & __bfa_cb_itnim_online;
    itnim->hcb_qe.cbarg = (void *)itnim;
    itnim->hcb_qe.pre_rmv = 0;
    list_add_tail(& itnim->hcb_qe.qe, & (itnim->bfa)->comp_q);
  }
  goto ldv_48492;
  case 5U: 
  itnim->sm = (void (*)(void * , int  ))(& bfa_itnim_sm_delete_pending);
  goto ldv_48492;
  case 3U: 
  tmp = bfa_itnim_send_fwdelete(itnim);
  if ((unsigned int )tmp != 0U) {
    itnim->sm = (void (*)(void * , int  ))(& bfa_itnim_sm_fwdelete);
  } else {
    itnim->sm = (void (*)(void * , int  ))(& bfa_itnim_sm_fwdelete_qfull);
  }
  goto ldv_48492;
  case 8U: 
  itnim->sm = (void (*)(void * , int  ))(& bfa_itnim_sm_iocdisable);
  goto ldv_48492;
  default: 
  __bfa_trc((itnim->bfa)->trcmod, __trc_fileno___11, 597, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcpim.c",
         597, (unsigned int )event);
  }
  ldv_48492: ;
  return;
}
}
static void bfa_itnim_sm_fwcreate_qfull(struct bfa_itnim_s *itnim , enum bfa_itnim_event event ) 
{ 
  int __ret_warn_on ;
  int tmp ;
  long tmp___0 ;
  int __ret_warn_on___0 ;
  int tmp___1 ;
  long tmp___2 ;
  int __ret_warn_on___1 ;
  int tmp___3 ;
  long tmp___4 ;
  int __ret_warn_on___2 ;
  int tmp___5 ;
  long tmp___6 ;

  {
  __bfa_trc((itnim->bfa)->trcmod, __trc_fileno___11, 605, (unsigned long long )(itnim->rport)->rport_tag);
  __bfa_trc((itnim->bfa)->trcmod, __trc_fileno___11, 606, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 9U: 
  itnim->sm = (void (*)(void * , int  ))(& bfa_itnim_sm_fwcreate);
  bfa_itnim_send_fwcreate(itnim);
  goto ldv_48502;
  case 5U: 
  itnim->sm = (void (*)(void * , int  ))(& bfa_itnim_sm_uninit);
  list_del(& itnim->reqq_wait.qe);
  tmp = bfa_q_is_on_q_func(& (itnim->fcpim)->itnim_q, (struct list_head *)itnim);
  __ret_warn_on = tmp == 0;
  tmp___0 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp___0 != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcpim.c",
                       617);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  bfa_itnim_update_del_itn_stats(itnim);
  list_del(& itnim->qe);
  tmp___1 = list_empty((struct list_head  const  *)(& itnim->io_q));
  __ret_warn_on___0 = tmp___1 == 0;
  tmp___2 = ldv__builtin_expect(__ret_warn_on___0 != 0, 0L);
  if (tmp___2 != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcpim.c",
                       617);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on___0 != 0, 0L);
  tmp___3 = list_empty((struct list_head  const  *)(& itnim->io_cleanup_q));
  __ret_warn_on___1 = tmp___3 == 0;
  tmp___4 = ldv__builtin_expect(__ret_warn_on___1 != 0, 0L);
  if (tmp___4 != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcpim.c",
                       617);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on___1 != 0, 0L);
  tmp___5 = list_empty((struct list_head  const  *)(& itnim->pending_q));
  __ret_warn_on___2 = tmp___5 == 0;
  tmp___6 = ldv__builtin_expect(__ret_warn_on___2 != 0, 0L);
  if (tmp___6 != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcpim.c",
                       617);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on___2 != 0, 0L);
  goto ldv_48502;
  case 3U: 
  itnim->sm = (void (*)(void * , int  ))(& bfa_itnim_sm_offline);
  list_del(& itnim->reqq_wait.qe);
  if ((unsigned int )(itnim->bfa)->fcs != 0U) {
    bfa_cb_itnim_offline(itnim->ditn);
  } else {
    itnim->hcb_qe.cbfn = & __bfa_cb_itnim_offline;
    itnim->hcb_qe.cbarg = (void *)itnim;
    itnim->hcb_qe.pre_rmv = 0;
    list_add_tail(& itnim->hcb_qe.qe, & (itnim->bfa)->comp_q);
  }
  goto ldv_48502;
  case 8U: 
  itnim->sm = (void (*)(void * , int  ))(& bfa_itnim_sm_iocdisable);
  list_del(& itnim->reqq_wait.qe);
  goto ldv_48502;
  default: 
  __bfa_trc((itnim->bfa)->trcmod, __trc_fileno___11, 632, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcpim.c",
         632, (unsigned int )event);
  }
  ldv_48502: ;
  return;
}
}
static void bfa_itnim_sm_delete_pending(struct bfa_itnim_s *itnim , enum bfa_itnim_event event ) 
{ 
  enum bfa_boolean tmp ;
  int __ret_warn_on ;
  int tmp___0 ;
  long tmp___1 ;
  int __ret_warn_on___0 ;
  int tmp___2 ;
  long tmp___3 ;
  int __ret_warn_on___1 ;
  int tmp___4 ;
  long tmp___5 ;
  int __ret_warn_on___2 ;
  int tmp___6 ;
  long tmp___7 ;

  {
  __bfa_trc((itnim->bfa)->trcmod, __trc_fileno___11, 643, (unsigned long long )(itnim->rport)->rport_tag);
  __bfa_trc((itnim->bfa)->trcmod, __trc_fileno___11, 644, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 4U: 
  tmp = bfa_itnim_send_fwdelete(itnim);
  if ((unsigned int )tmp != 0U) {
    itnim->sm = (void (*)(void * , int  ))(& bfa_itnim_sm_deleting);
  } else {
    itnim->sm = (void (*)(void * , int  ))(& bfa_itnim_sm_deleting_qfull);
  }
  goto ldv_48520;
  case 8U: 
  itnim->sm = (void (*)(void * , int  ))(& bfa_itnim_sm_uninit);
  tmp___0 = bfa_q_is_on_q_func(& (itnim->fcpim)->itnim_q, (struct list_head *)itnim);
  __ret_warn_on = tmp___0 == 0;
  tmp___1 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp___1 != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcpim.c",
                       656);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  bfa_itnim_update_del_itn_stats(itnim);
  list_del(& itnim->qe);
  tmp___2 = list_empty((struct list_head  const  *)(& itnim->io_q));
  __ret_warn_on___0 = tmp___2 == 0;
  tmp___3 = ldv__builtin_expect(__ret_warn_on___0 != 0, 0L);
  if (tmp___3 != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcpim.c",
                       656);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on___0 != 0, 0L);
  tmp___4 = list_empty((struct list_head  const  *)(& itnim->io_cleanup_q));
  __ret_warn_on___1 = tmp___4 == 0;
  tmp___5 = ldv__builtin_expect(__ret_warn_on___1 != 0, 0L);
  if (tmp___5 != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcpim.c",
                       656);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on___1 != 0, 0L);
  tmp___6 = list_empty((struct list_head  const  *)(& itnim->pending_q));
  __ret_warn_on___2 = tmp___6 == 0;
  tmp___7 = ldv__builtin_expect(__ret_warn_on___2 != 0, 0L);
  if (tmp___7 != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcpim.c",
                       656);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on___2 != 0, 0L);
  goto ldv_48520;
  default: 
  __bfa_trc((itnim->bfa)->trcmod, __trc_fileno___11, 660, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcpim.c",
         660, (unsigned int )event);
  }
  ldv_48520: ;
  return;
}
}
static void bfa_itnim_sm_online(struct bfa_itnim_s *itnim , enum bfa_itnim_event event ) 
{ 


  {
  __bfa_trc((itnim->bfa)->trcmod, __trc_fileno___11, 670, (unsigned long long )(itnim->rport)->rport_tag);
  __bfa_trc((itnim->bfa)->trcmod, __trc_fileno___11, 671, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 3U: 
  itnim->sm = (void (*)(void * , int  ))(& bfa_itnim_sm_cleanup_offline);
  itnim->is_online = 0;
  bfa_itnim_iotov_start(itnim);
  bfa_itnim_cleanup(itnim);
  goto ldv_48536;
  case 5U: 
  itnim->sm = (void (*)(void * , int  ))(& bfa_itnim_sm_cleanup_delete);
  itnim->is_online = 0;
  bfa_itnim_cleanup(itnim);
  goto ldv_48536;
  case 7U: 
  itnim->sm = (void (*)(void * , int  ))(& bfa_itnim_sm_sler);
  itnim->is_online = 0;
  bfa_itnim_iotov_start(itnim);
  if ((unsigned int )(itnim->bfa)->fcs != 0U) {
    bfa_cb_itnim_sler(itnim->ditn);
  } else {
    itnim->hcb_qe.cbfn = & __bfa_cb_itnim_sler;
    itnim->hcb_qe.cbarg = (void *)itnim;
    itnim->hcb_qe.pre_rmv = 0;
    list_add_tail(& itnim->hcb_qe.qe, & (itnim->bfa)->comp_q);
  }
  goto ldv_48536;
  case 8U: 
  itnim->sm = (void (*)(void * , int  ))(& bfa_itnim_sm_iocdisable);
  itnim->is_online = 0;
  bfa_itnim_iotov_start(itnim);
  bfa_itnim_iocdisable_cleanup(itnim);
  goto ldv_48536;
  default: 
  __bfa_trc((itnim->bfa)->trcmod, __trc_fileno___11, 702, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcpim.c",
         702, (unsigned int )event);
  }
  ldv_48536: ;
  return;
}
}
static void bfa_itnim_sm_sler(struct bfa_itnim_s *itnim , enum bfa_itnim_event event ) 
{ 


  {
  __bfa_trc((itnim->bfa)->trcmod, __trc_fileno___11, 712, (unsigned long long )(itnim->rport)->rport_tag);
  __bfa_trc((itnim->bfa)->trcmod, __trc_fileno___11, 713, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 3U: 
  itnim->sm = (void (*)(void * , int  ))(& bfa_itnim_sm_cleanup_offline);
  bfa_itnim_cleanup(itnim);
  goto ldv_48546;
  case 5U: 
  itnim->sm = (void (*)(void * , int  ))(& bfa_itnim_sm_cleanup_delete);
  bfa_itnim_cleanup(itnim);
  bfa_itnim_iotov_delete(itnim);
  goto ldv_48546;
  case 8U: 
  itnim->sm = (void (*)(void * , int  ))(& bfa_itnim_sm_iocdisable);
  bfa_itnim_iocdisable_cleanup(itnim);
  goto ldv_48546;
  default: 
  __bfa_trc((itnim->bfa)->trcmod, __trc_fileno___11, 733, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcpim.c",
         733, (unsigned int )event);
  }
  ldv_48546: ;
  return;
}
}
static void bfa_itnim_sm_cleanup_offline(struct bfa_itnim_s *itnim , enum bfa_itnim_event event ) 
{ 
  enum bfa_boolean tmp ;

  {
  __bfa_trc((itnim->bfa)->trcmod, __trc_fileno___11, 744, (unsigned long long )(itnim->rport)->rport_tag);
  __bfa_trc((itnim->bfa)->trcmod, __trc_fileno___11, 745, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 6U: 
  tmp = bfa_itnim_send_fwdelete(itnim);
  if ((unsigned int )tmp != 0U) {
    itnim->sm = (void (*)(void * , int  ))(& bfa_itnim_sm_fwdelete);
  } else {
    itnim->sm = (void (*)(void * , int  ))(& bfa_itnim_sm_fwdelete_qfull);
  }
  goto ldv_48555;
  case 5U: 
  itnim->sm = (void (*)(void * , int  ))(& bfa_itnim_sm_cleanup_delete);
  bfa_itnim_iotov_delete(itnim);
  goto ldv_48555;
  case 8U: 
  itnim->sm = (void (*)(void * , int  ))(& bfa_itnim_sm_iocdisable);
  bfa_itnim_iocdisable_cleanup(itnim);
  if ((unsigned int )(itnim->bfa)->fcs != 0U) {
    bfa_cb_itnim_offline(itnim->ditn);
  } else {
    itnim->hcb_qe.cbfn = & __bfa_cb_itnim_offline;
    itnim->hcb_qe.cbarg = (void *)itnim;
    itnim->hcb_qe.pre_rmv = 0;
    list_add_tail(& itnim->hcb_qe.qe, & (itnim->bfa)->comp_q);
  }
  goto ldv_48555;
  case 7U: ;
  goto ldv_48555;
  default: 
  __bfa_trc((itnim->bfa)->trcmod, __trc_fileno___11, 770, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcpim.c",
         770, (unsigned int )event);
  }
  ldv_48555: ;
  return;
}
}
static void bfa_itnim_sm_cleanup_delete(struct bfa_itnim_s *itnim , enum bfa_itnim_event event ) 
{ 
  enum bfa_boolean tmp ;

  {
  __bfa_trc((itnim->bfa)->trcmod, __trc_fileno___11, 781, (unsigned long long )(itnim->rport)->rport_tag);
  __bfa_trc((itnim->bfa)->trcmod, __trc_fileno___11, 782, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 6U: 
  tmp = bfa_itnim_send_fwdelete(itnim);
  if ((unsigned int )tmp != 0U) {
    itnim->sm = (void (*)(void * , int  ))(& bfa_itnim_sm_deleting);
  } else {
    itnim->sm = (void (*)(void * , int  ))(& bfa_itnim_sm_deleting_qfull);
  }
  goto ldv_48565;
  case 8U: 
  itnim->sm = (void (*)(void * , int  ))(& bfa_itnim_sm_iocdisable);
  bfa_itnim_iocdisable_cleanup(itnim);
  goto ldv_48565;
  default: 
  __bfa_trc((itnim->bfa)->trcmod, __trc_fileno___11, 798, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcpim.c",
         798, (unsigned int )event);
  }
  ldv_48565: ;
  return;
}
}
static void bfa_itnim_sm_fwdelete(struct bfa_itnim_s *itnim , enum bfa_itnim_event event ) 
{ 


  {
  __bfa_trc((itnim->bfa)->trcmod, __trc_fileno___11, 808, (unsigned long long )(itnim->rport)->rport_tag);
  __bfa_trc((itnim->bfa)->trcmod, __trc_fileno___11, 809, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 4U: 
  itnim->sm = (void (*)(void * , int  ))(& bfa_itnim_sm_offline);
  if ((unsigned int )(itnim->bfa)->fcs != 0U) {
    bfa_cb_itnim_offline(itnim->ditn);
  } else {
    itnim->hcb_qe.cbfn = & __bfa_cb_itnim_offline;
    itnim->hcb_qe.cbarg = (void *)itnim;
    itnim->hcb_qe.pre_rmv = 0;
    list_add_tail(& itnim->hcb_qe.qe, & (itnim->bfa)->comp_q);
  }
  goto ldv_48573;
  case 5U: 
  itnim->sm = (void (*)(void * , int  ))(& bfa_itnim_sm_deleting);
  goto ldv_48573;
  case 8U: 
  itnim->sm = (void (*)(void * , int  ))(& bfa_itnim_sm_iocdisable);
  if ((unsigned int )(itnim->bfa)->fcs != 0U) {
    bfa_cb_itnim_offline(itnim->ditn);
  } else {
    itnim->hcb_qe.cbfn = & __bfa_cb_itnim_offline;
    itnim->hcb_qe.cbarg = (void *)itnim;
    itnim->hcb_qe.pre_rmv = 0;
    list_add_tail(& itnim->hcb_qe.qe, & (itnim->bfa)->comp_q);
  }
  goto ldv_48573;
  default: 
  __bfa_trc((itnim->bfa)->trcmod, __trc_fileno___11, 827, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcpim.c",
         827, (unsigned int )event);
  }
  ldv_48573: ;
  return;
}
}
static void bfa_itnim_sm_fwdelete_qfull(struct bfa_itnim_s *itnim , enum bfa_itnim_event event ) 
{ 


  {
  __bfa_trc((itnim->bfa)->trcmod, __trc_fileno___11, 835, (unsigned long long )(itnim->rport)->rport_tag);
  __bfa_trc((itnim->bfa)->trcmod, __trc_fileno___11, 836, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 9U: 
  itnim->sm = (void (*)(void * , int  ))(& bfa_itnim_sm_fwdelete);
  bfa_itnim_send_fwdelete(itnim);
  goto ldv_48582;
  case 5U: 
  itnim->sm = (void (*)(void * , int  ))(& bfa_itnim_sm_deleting_qfull);
  goto ldv_48582;
  case 8U: 
  itnim->sm = (void (*)(void * , int  ))(& bfa_itnim_sm_iocdisable);
  list_del(& itnim->reqq_wait.qe);
  if ((unsigned int )(itnim->bfa)->fcs != 0U) {
    bfa_cb_itnim_offline(itnim->ditn);
  } else {
    itnim->hcb_qe.cbfn = & __bfa_cb_itnim_offline;
    itnim->hcb_qe.cbarg = (void *)itnim;
    itnim->hcb_qe.pre_rmv = 0;
    list_add_tail(& itnim->hcb_qe.qe, & (itnim->bfa)->comp_q);
  }
  goto ldv_48582;
  default: 
  __bfa_trc((itnim->bfa)->trcmod, __trc_fileno___11, 855, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcpim.c",
         855, (unsigned int )event);
  }
  ldv_48582: ;
  return;
}
}
static void bfa_itnim_sm_offline(struct bfa_itnim_s *itnim , enum bfa_itnim_event event ) 
{ 
  int __ret_warn_on ;
  int tmp ;
  long tmp___0 ;
  int __ret_warn_on___0 ;
  int tmp___1 ;
  long tmp___2 ;
  int __ret_warn_on___1 ;
  int tmp___3 ;
  long tmp___4 ;
  int __ret_warn_on___2 ;
  int tmp___5 ;
  long tmp___6 ;
  enum bfa_boolean tmp___7 ;

  {
  __bfa_trc((itnim->bfa)->trcmod, __trc_fileno___11, 865, (unsigned long long )(itnim->rport)->rport_tag);
  __bfa_trc((itnim->bfa)->trcmod, __trc_fileno___11, 866, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 5U: 
  itnim->sm = (void (*)(void * , int  ))(& bfa_itnim_sm_uninit);
  bfa_itnim_iotov_delete(itnim);
  tmp = bfa_q_is_on_q_func(& (itnim->fcpim)->itnim_q, (struct list_head *)itnim);
  __ret_warn_on = tmp == 0;
  tmp___0 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp___0 != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcpim.c",
                       872);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  bfa_itnim_update_del_itn_stats(itnim);
  list_del(& itnim->qe);
  tmp___1 = list_empty((struct list_head  const  *)(& itnim->io_q));
  __ret_warn_on___0 = tmp___1 == 0;
  tmp___2 = ldv__builtin_expect(__ret_warn_on___0 != 0, 0L);
  if (tmp___2 != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcpim.c",
                       872);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on___0 != 0, 0L);
  tmp___3 = list_empty((struct list_head  const  *)(& itnim->io_cleanup_q));
  __ret_warn_on___1 = tmp___3 == 0;
  tmp___4 = ldv__builtin_expect(__ret_warn_on___1 != 0, 0L);
  if (tmp___4 != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcpim.c",
                       872);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on___1 != 0, 0L);
  tmp___5 = list_empty((struct list_head  const  *)(& itnim->pending_q));
  __ret_warn_on___2 = tmp___5 == 0;
  tmp___6 = ldv__builtin_expect(__ret_warn_on___2 != 0, 0L);
  if (tmp___6 != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcpim.c",
                       872);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on___2 != 0, 0L);
  goto ldv_48599;
  case 2U: 
  tmp___7 = bfa_itnim_send_fwcreate(itnim);
  if ((unsigned int )tmp___7 != 0U) {
    itnim->sm = (void (*)(void * , int  ))(& bfa_itnim_sm_fwcreate);
  } else {
    itnim->sm = (void (*)(void * , int  ))(& bfa_itnim_sm_fwcreate_qfull);
  }
  goto ldv_48599;
  case 8U: 
  itnim->sm = (void (*)(void * , int  ))(& bfa_itnim_sm_iocdisable);
  goto ldv_48599;
  default: 
  __bfa_trc((itnim->bfa)->trcmod, __trc_fileno___11, 887, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcpim.c",
         887, (unsigned int )event);
  }
  ldv_48599: ;
  return;
}
}
static void bfa_itnim_sm_iocdisable(struct bfa_itnim_s *itnim , enum bfa_itnim_event event ) 
{ 
  int __ret_warn_on ;
  int tmp ;
  long tmp___0 ;
  int __ret_warn_on___0 ;
  int tmp___1 ;
  long tmp___2 ;
  int __ret_warn_on___1 ;
  int tmp___3 ;
  long tmp___4 ;
  int __ret_warn_on___2 ;
  int tmp___5 ;
  long tmp___6 ;
  enum bfa_boolean tmp___7 ;

  {
  __bfa_trc((itnim->bfa)->trcmod, __trc_fileno___11, 895, (unsigned long long )(itnim->rport)->rport_tag);
  __bfa_trc((itnim->bfa)->trcmod, __trc_fileno___11, 896, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 5U: 
  itnim->sm = (void (*)(void * , int  ))(& bfa_itnim_sm_uninit);
  bfa_itnim_iotov_delete(itnim);
  tmp = bfa_q_is_on_q_func(& (itnim->fcpim)->itnim_q, (struct list_head *)itnim);
  __ret_warn_on = tmp == 0;
  tmp___0 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp___0 != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcpim.c",
                       902);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  bfa_itnim_update_del_itn_stats(itnim);
  list_del(& itnim->qe);
  tmp___1 = list_empty((struct list_head  const  *)(& itnim->io_q));
  __ret_warn_on___0 = tmp___1 == 0;
  tmp___2 = ldv__builtin_expect(__ret_warn_on___0 != 0, 0L);
  if (tmp___2 != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcpim.c",
                       902);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on___0 != 0, 0L);
  tmp___3 = list_empty((struct list_head  const  *)(& itnim->io_cleanup_q));
  __ret_warn_on___1 = tmp___3 == 0;
  tmp___4 = ldv__builtin_expect(__ret_warn_on___1 != 0, 0L);
  if (tmp___4 != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcpim.c",
                       902);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on___1 != 0, 0L);
  tmp___5 = list_empty((struct list_head  const  *)(& itnim->pending_q));
  __ret_warn_on___2 = tmp___5 == 0;
  tmp___6 = ldv__builtin_expect(__ret_warn_on___2 != 0, 0L);
  if (tmp___6 != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcpim.c",
                       902);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on___2 != 0, 0L);
  goto ldv_48616;
  case 3U: ;
  if ((unsigned int )(itnim->bfa)->fcs != 0U) {
    bfa_cb_itnim_offline(itnim->ditn);
  } else {
    itnim->hcb_qe.cbfn = & __bfa_cb_itnim_offline;
    itnim->hcb_qe.cbarg = (void *)itnim;
    itnim->hcb_qe.pre_rmv = 0;
    list_add_tail(& itnim->hcb_qe.qe, & (itnim->bfa)->comp_q);
  }
  goto ldv_48616;
  case 2U: 
  tmp___7 = bfa_itnim_send_fwcreate(itnim);
  if ((unsigned int )tmp___7 != 0U) {
    itnim->sm = (void (*)(void * , int  ))(& bfa_itnim_sm_fwcreate);
  } else {
    itnim->sm = (void (*)(void * , int  ))(& bfa_itnim_sm_fwcreate_qfull);
  }
  goto ldv_48616;
  case 8U: ;
  goto ldv_48616;
  default: 
  __bfa_trc((itnim->bfa)->trcmod, __trc_fileno___11, 920, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcpim.c",
         920, (unsigned int )event);
  }
  ldv_48616: ;
  return;
}
}
static void bfa_itnim_sm_deleting(struct bfa_itnim_s *itnim , enum bfa_itnim_event event ) 
{ 
  int __ret_warn_on ;
  int tmp ;
  long tmp___0 ;
  int __ret_warn_on___0 ;
  int tmp___1 ;
  long tmp___2 ;
  int __ret_warn_on___1 ;
  int tmp___3 ;
  long tmp___4 ;
  int __ret_warn_on___2 ;
  int tmp___5 ;
  long tmp___6 ;

  {
  __bfa_trc((itnim->bfa)->trcmod, __trc_fileno___11, 930, (unsigned long long )(itnim->rport)->rport_tag);
  __bfa_trc((itnim->bfa)->trcmod, __trc_fileno___11, 931, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 4U: ;
  case 8U: 
  itnim->sm = (void (*)(void * , int  ))(& bfa_itnim_sm_uninit);
  tmp = bfa_q_is_on_q_func(& (itnim->fcpim)->itnim_q, (struct list_head *)itnim);
  __ret_warn_on = tmp == 0;
  tmp___0 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp___0 != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcpim.c",
                       937);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  bfa_itnim_update_del_itn_stats(itnim);
  list_del(& itnim->qe);
  tmp___1 = list_empty((struct list_head  const  *)(& itnim->io_q));
  __ret_warn_on___0 = tmp___1 == 0;
  tmp___2 = ldv__builtin_expect(__ret_warn_on___0 != 0, 0L);
  if (tmp___2 != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcpim.c",
                       937);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on___0 != 0, 0L);
  tmp___3 = list_empty((struct list_head  const  *)(& itnim->io_cleanup_q));
  __ret_warn_on___1 = tmp___3 == 0;
  tmp___4 = ldv__builtin_expect(__ret_warn_on___1 != 0, 0L);
  if (tmp___4 != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcpim.c",
                       937);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on___1 != 0, 0L);
  tmp___5 = list_empty((struct list_head  const  *)(& itnim->pending_q));
  __ret_warn_on___2 = tmp___5 == 0;
  tmp___6 = ldv__builtin_expect(__ret_warn_on___2 != 0, 0L);
  if (tmp___6 != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcpim.c",
                       937);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on___2 != 0, 0L);
  goto ldv_48635;
  default: 
  __bfa_trc((itnim->bfa)->trcmod, __trc_fileno___11, 941, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcpim.c",
         941, (unsigned int )event);
  }
  ldv_48635: ;
  return;
}
}
static void bfa_itnim_sm_deleting_qfull(struct bfa_itnim_s *itnim , enum bfa_itnim_event event ) 
{ 
  int __ret_warn_on ;
  int tmp ;
  long tmp___0 ;
  int __ret_warn_on___0 ;
  int tmp___1 ;
  long tmp___2 ;
  int __ret_warn_on___1 ;
  int tmp___3 ;
  long tmp___4 ;
  int __ret_warn_on___2 ;
  int tmp___5 ;
  long tmp___6 ;

  {
  __bfa_trc((itnim->bfa)->trcmod, __trc_fileno___11, 949, (unsigned long long )(itnim->rport)->rport_tag);
  __bfa_trc((itnim->bfa)->trcmod, __trc_fileno___11, 950, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 9U: 
  itnim->sm = (void (*)(void * , int  ))(& bfa_itnim_sm_deleting);
  bfa_itnim_send_fwdelete(itnim);
  goto ldv_48642;
  case 8U: 
  itnim->sm = (void (*)(void * , int  ))(& bfa_itnim_sm_uninit);
  list_del(& itnim->reqq_wait.qe);
  tmp = bfa_q_is_on_q_func(& (itnim->fcpim)->itnim_q, (struct list_head *)itnim);
  __ret_warn_on = tmp == 0;
  tmp___0 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp___0 != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcpim.c",
                       961);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  bfa_itnim_update_del_itn_stats(itnim);
  list_del(& itnim->qe);
  tmp___1 = list_empty((struct list_head  const  *)(& itnim->io_q));
  __ret_warn_on___0 = tmp___1 == 0;
  tmp___2 = ldv__builtin_expect(__ret_warn_on___0 != 0, 0L);
  if (tmp___2 != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcpim.c",
                       961);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on___0 != 0, 0L);
  tmp___3 = list_empty((struct list_head  const  *)(& itnim->io_cleanup_q));
  __ret_warn_on___1 = tmp___3 == 0;
  tmp___4 = ldv__builtin_expect(__ret_warn_on___1 != 0, 0L);
  if (tmp___4 != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcpim.c",
                       961);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on___1 != 0, 0L);
  tmp___5 = list_empty((struct list_head  const  *)(& itnim->pending_q));
  __ret_warn_on___2 = tmp___5 == 0;
  tmp___6 = ldv__builtin_expect(__ret_warn_on___2 != 0, 0L);
  if (tmp___6 != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcpim.c",
                       961);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on___2 != 0, 0L);
  goto ldv_48642;
  default: 
  __bfa_trc((itnim->bfa)->trcmod, __trc_fileno___11, 965, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcpim.c",
         965, (unsigned int )event);
  }
  ldv_48642: ;
  return;
}
}
static void bfa_itnim_iocdisable_cleanup(struct bfa_itnim_s *itnim ) 
{ 
  struct bfa_tskim_s *tskim ;
  struct bfa_ioim_s *ioim ;
  struct list_head *qe ;
  struct list_head *qen ;

  {
  qe = itnim->tsk_q.next;
  qen = qe->next;
  goto ldv_48661;
  ldv_48660: 
  tskim = (struct bfa_tskim_s *)qe;
  bfa_tskim_iocdisable(tskim);
  qe = qen;
  qen = qe->next;
  ldv_48661: ;
  if ((unsigned long )(& itnim->tsk_q) != (unsigned long )qe) {
    goto ldv_48660;
  } else {

  }
  qe = itnim->io_q.next;
  qen = qe->next;
  goto ldv_48664;
  ldv_48663: 
  ioim = (struct bfa_ioim_s *)qe;
  bfa_ioim_iocdisable(ioim);
  qe = qen;
  qen = qe->next;
  ldv_48664: ;
  if ((unsigned long )(& itnim->io_q) != (unsigned long )qe) {
    goto ldv_48663;
  } else {

  }
  qe = itnim->pending_q.next;
  qen = qe->next;
  goto ldv_48667;
  ldv_48666: 
  ioim = (struct bfa_ioim_s *)qe;
  bfa_ioim_tov(ioim);
  qe = qen;
  qen = qe->next;
  ldv_48667: ;
  if ((unsigned long )(& itnim->pending_q) != (unsigned long )qe) {
    goto ldv_48666;
  } else {

  }
  qe = itnim->io_cleanup_q.next;
  qen = qe->next;
  goto ldv_48670;
  ldv_48669: 
  ioim = (struct bfa_ioim_s *)qe;
  bfa_ioim_iocdisable(ioim);
  qe = qen;
  qen = qe->next;
  ldv_48670: ;
  if ((unsigned long )(& itnim->io_cleanup_q) != (unsigned long )qe) {
    goto ldv_48669;
  } else {

  }

  return;
}
}
static void bfa_itnim_cleanp_comp(void *itnim_cbarg ) 
{ 
  struct bfa_itnim_s *itnim ;

  {
  itnim = (struct bfa_itnim_s *)itnim_cbarg;
  itnim->stats.cleanup_comps = itnim->stats.cleanup_comps + 1U;
  (*(itnim->sm))((void *)itnim, 6);
  return;
}
}
static void bfa_itnim_cleanup(struct bfa_itnim_s *itnim ) 
{ 
  struct bfa_ioim_s *ioim ;
  struct bfa_tskim_s *tskim ;
  struct list_head *qe ;
  struct list_head *qen ;

  {
  bfa_wc_init(& itnim->wc, & bfa_itnim_cleanp_comp, (void *)itnim);
  qe = itnim->io_q.next;
  qen = qe->next;
  goto ldv_48684;
  ldv_48683: 
  ioim = (struct bfa_ioim_s *)qe;
  list_del(& ioim->qe);
  list_add_tail(& ioim->qe, & itnim->io_cleanup_q);
  bfa_wc_up(& itnim->wc);
  bfa_ioim_cleanup(ioim);
  qe = qen;
  qen = qe->next;
  ldv_48684: ;
  if ((unsigned long )(& itnim->io_q) != (unsigned long )qe) {
    goto ldv_48683;
  } else {

  }
  qe = itnim->tsk_q.next;
  qen = qe->next;
  goto ldv_48687;
  ldv_48686: 
  tskim = (struct bfa_tskim_s *)qe;
  bfa_wc_up(& itnim->wc);
  bfa_tskim_cleanup(tskim);
  qe = qen;
  qen = qe->next;
  ldv_48687: ;
  if ((unsigned long )(& itnim->tsk_q) != (unsigned long )qe) {
    goto ldv_48686;
  } else {

  }
  bfa_wc_wait(& itnim->wc);
  return;
}
}
static void __bfa_cb_itnim_online(void *cbarg , enum bfa_boolean complete___0 ) 
{ 
  struct bfa_itnim_s *itnim ;

  {
  itnim = (struct bfa_itnim_s *)cbarg;
  if ((unsigned int )complete___0 != 0U) {
    bfa_cb_itnim_online(itnim->ditn);
  } else {

  }
  return;
}
}
static void __bfa_cb_itnim_offline(void *cbarg , enum bfa_boolean complete___0 ) 
{ 
  struct bfa_itnim_s *itnim ;

  {
  itnim = (struct bfa_itnim_s *)cbarg;
  if ((unsigned int )complete___0 != 0U) {
    bfa_cb_itnim_offline(itnim->ditn);
  } else {

  }
  return;
}
}
static void __bfa_cb_itnim_sler(void *cbarg , enum bfa_boolean complete___0 ) 
{ 
  struct bfa_itnim_s *itnim ;

  {
  itnim = (struct bfa_itnim_s *)cbarg;
  if ((unsigned int )complete___0 != 0U) {
    bfa_cb_itnim_sler(itnim->ditn);
  } else {

  }
  return;
}
}
static void bfa_itnim_qresume(void *cbarg ) 
{ 
  struct bfa_itnim_s *itnim ;

  {
  itnim = (struct bfa_itnim_s *)cbarg;
  (*(itnim->sm))((void *)itnim, 9);
  return;
}
}
void bfa_itnim_iodone(struct bfa_itnim_s *itnim ) 
{ 


  {
  bfa_wc_down(& itnim->wc);
  return;
}
}
void bfa_itnim_tskdone(struct bfa_itnim_s *itnim ) 
{ 


  {
  bfa_wc_down(& itnim->wc);
  return;
}
}
void bfa_itnim_meminfo(struct bfa_iocfc_cfg_s *cfg , u32 *km_len ) 
{ 


  {
  *km_len = *km_len + (u32 )cfg->fwcfg.num_rports * 816U;
  return;
}
}
void bfa_itnim_attach(struct bfa_fcpim_s *fcpim ) 
{ 
  struct bfa_s *bfa ;
  struct bfa_fcp_mod_s *fcp ;
  struct bfa_itnim_s *itnim ;
  int i ;
  int j ;

  {
  bfa = fcpim->bfa;
  fcp = fcpim->fcp;
  INIT_LIST_HEAD(& fcpim->itnim_q);
  itnim = (struct bfa_itnim_s *)fcp->kva_seg.kva_curp;
  fcpim->itnim_arr = itnim;
  i = 0;
  goto ldv_48730;
  ldv_48729: 
  memset((void *)itnim, 0, 816UL);
  itnim->bfa = bfa;
  itnim->fcpim = fcpim;
  itnim->reqq = 1U;
  itnim->rport = bfa->modules.rport_mod.rps_list + (unsigned long )(((int )bfa->modules.rport_mod.num_rports + -1) & i);
  itnim->iotov_active = 0;
  bfa_reqq_winit(& itnim->reqq_wait, & bfa_itnim_qresume, (void *)itnim);
  INIT_LIST_HEAD(& itnim->io_q);
  INIT_LIST_HEAD(& itnim->io_cleanup_q);
  INIT_LIST_HEAD(& itnim->pending_q);
  INIT_LIST_HEAD(& itnim->tsk_q);
  INIT_LIST_HEAD(& itnim->delay_comp_q);
  j = 0;
  goto ldv_48727;
  ldv_48726: 
  itnim->ioprofile.io_latency.min[j] = 4294967295U;
  j = j + 1;
  ldv_48727: ;
  if (j <= 13) {
    goto ldv_48726;
  } else {

  }
  itnim->sm = (void (*)(void * , int  ))(& bfa_itnim_sm_uninit);
  i = i + 1;
  itnim = itnim + 1;
  ldv_48730: ;
  if (fcpim->num_itnims > i) {
    goto ldv_48729;
  } else {

  }
  fcp->kva_seg.kva_curp = (u8 *)itnim;
  return;
}
}
void bfa_itnim_iocdisable(struct bfa_itnim_s *itnim ) 
{ 


  {
  itnim->stats.ioc_disabled = itnim->stats.ioc_disabled + 1U;
  (*(itnim->sm))((void *)itnim, 8);
  return;
}
}
static enum bfa_boolean bfa_itnim_send_fwcreate(struct bfa_itnim_s *itnim ) 
{ 
  struct bfi_itn_create_req_s *m ;
  struct list_head *waitq ;
  int __ret_warn_on ;
  long tmp ;
  int __ret_warn_on___0 ;
  long tmp___0 ;

  {
  itnim->msg_no = (u8 )((int )itnim->msg_no + 1);
  m = (((itnim->bfa)->iocfc.req_cq_pi[(int )itnim->reqq] + 1U) & (u32 )((int )(itnim->bfa)->iocfc.cfg.drvcfg.num_reqq_elems + -1)) != *((u32 *)(itnim->bfa)->iocfc.req_cq_shadow_ci[(int )itnim->reqq].kva) ? (struct bfi_itn_create_req_s *)(itnim->bfa)->iocfc.req_cq_ba[(int )itnim->reqq].kva + (unsigned long )(itnim->bfa)->iocfc.req_cq_pi[(int )itnim->reqq] : (struct bfi_itn_create_req_s *)0;
  if ((unsigned long )m == (unsigned long )((struct bfi_itn_create_req_s *)0)) {
    waitq = (struct list_head *)(& (itnim->bfa)->reqq_waitq) + (unsigned long )itnim->reqq;
    __ret_warn_on = (unsigned int )itnim->reqq > 3U;
    tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
    if (tmp != 0L) {
      warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcpim.c",
                         1167);
    } else {

    }
    ldv__builtin_expect(__ret_warn_on != 0, 0L);
    __ret_warn_on___0 = (unsigned long )itnim->reqq_wait.qresume == (unsigned long )((void (*)(void * ))0) || (unsigned long )itnim->reqq_wait.cbarg == (unsigned long )((void *)0);
    tmp___0 = ldv__builtin_expect(__ret_warn_on___0 != 0, 0L);
    if (tmp___0 != 0L) {
      warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcpim.c",
                         1167);
    } else {

    }
    ldv__builtin_expect(__ret_warn_on___0 != 0, 0L);
    list_add_tail(& itnim->reqq_wait.qe, waitq);
    return (0);
  } else {

  }
  m->mh.msg_class = 12U;
  m->mh.msg_id = 1U;
  m->mh.mtag.h2i.fn_lpu = (u8 )((int )((signed char )((int )(itnim->bfa)->ioc.pcidev.pci_func << 1)) | (int )((signed char )(itnim->bfa)->ioc.port_id));
  m->fw_handle = (itnim->rport)->fw_handle;
  m->class = 8U;
  m->seq_rec = (u8 )itnim->seq_rec;
  m->msg_no = itnim->msg_no;
  itnim->stats.fw_create = itnim->stats.fw_create + 1U;
  m->mh.mtag.h2i.qid = (itnim->bfa)->iocfc.hw_qid[(int )itnim->reqq];
  (itnim->bfa)->iocfc.req_cq_pi[(int )itnim->reqq] = (itnim->bfa)->iocfc.req_cq_pi[(int )itnim->reqq] + 1U;
  (itnim->bfa)->iocfc.req_cq_pi[(int )itnim->reqq] = (itnim->bfa)->iocfc.req_cq_pi[(int )itnim->reqq] & (u32 )((int )(itnim->bfa)->iocfc.cfg.drvcfg.num_reqq_elems + -1);
  writel((itnim->bfa)->iocfc.req_cq_pi[(int )itnim->reqq], (void volatile   *)(itnim->bfa)->iocfc.bfa_regs.cpe_q_pi[(int )itnim->reqq]);
  __asm__  volatile   ("": : : "memory");
  return (1);
}
}
static enum bfa_boolean bfa_itnim_send_fwdelete(struct bfa_itnim_s *itnim ) 
{ 
  struct bfi_itn_delete_req_s *m ;
  struct list_head *waitq ;
  int __ret_warn_on ;
  long tmp ;
  int __ret_warn_on___0 ;
  long tmp___0 ;

  {
  m = (((itnim->bfa)->iocfc.req_cq_pi[(int )itnim->reqq] + 1U) & (u32 )((int )(itnim->bfa)->iocfc.cfg.drvcfg.num_reqq_elems + -1)) != *((u32 *)(itnim->bfa)->iocfc.req_cq_shadow_ci[(int )itnim->reqq].kva) ? (struct bfi_itn_delete_req_s *)(itnim->bfa)->iocfc.req_cq_ba[(int )itnim->reqq].kva + (unsigned long )(itnim->bfa)->iocfc.req_cq_pi[(int )itnim->reqq] : (struct bfi_itn_delete_req_s *)0;
  if ((unsigned long )m == (unsigned long )((struct bfi_itn_delete_req_s *)0)) {
    waitq = (struct list_head *)(& (itnim->bfa)->reqq_waitq) + (unsigned long )itnim->reqq;
    __ret_warn_on = (unsigned int )itnim->reqq > 3U;
    tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
    if (tmp != 0L) {
      warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcpim.c",
                         1196);
    } else {

    }
    ldv__builtin_expect(__ret_warn_on != 0, 0L);
    __ret_warn_on___0 = (unsigned long )itnim->reqq_wait.qresume == (unsigned long )((void (*)(void * ))0) || (unsigned long )itnim->reqq_wait.cbarg == (unsigned long )((void *)0);
    tmp___0 = ldv__builtin_expect(__ret_warn_on___0 != 0, 0L);
    if (tmp___0 != 0L) {
      warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcpim.c",
                         1196);
    } else {

    }
    ldv__builtin_expect(__ret_warn_on___0 != 0, 0L);
    list_add_tail(& itnim->reqq_wait.qe, waitq);
    return (0);
  } else {

  }
  m->mh.msg_class = 12U;
  m->mh.msg_id = 2U;
  m->mh.mtag.h2i.fn_lpu = (u8 )((int )((signed char )((int )(itnim->bfa)->ioc.pcidev.pci_func << 1)) | (int )((signed char )(itnim->bfa)->ioc.port_id));
  m->fw_handle = (itnim->rport)->fw_handle;
  itnim->stats.fw_delete = itnim->stats.fw_delete + 1U;
  m->mh.mtag.h2i.qid = (itnim->bfa)->iocfc.hw_qid[(int )itnim->reqq];
  (itnim->bfa)->iocfc.req_cq_pi[(int )itnim->reqq] = (itnim->bfa)->iocfc.req_cq_pi[(int )itnim->reqq] + 1U;
  (itnim->bfa)->iocfc.req_cq_pi[(int )itnim->reqq] = (itnim->bfa)->iocfc.req_cq_pi[(int )itnim->reqq] & (u32 )((int )(itnim->bfa)->iocfc.cfg.drvcfg.num_reqq_elems + -1);
  writel((itnim->bfa)->iocfc.req_cq_pi[(int )itnim->reqq], (void volatile   *)(itnim->bfa)->iocfc.bfa_regs.cpe_q_pi[(int )itnim->reqq]);
  __asm__  volatile   ("": : : "memory");
  return (1);
}
}
static void bfa_itnim_delayed_comp(struct bfa_itnim_s *itnim , enum bfa_boolean iotov ) 
{ 
  struct bfa_ioim_s *ioim ;
  struct list_head *qe ;
  struct list_head *qen ;

  {
  qe = itnim->delay_comp_q.next;
  qen = qe->next;
  goto ldv_48761;
  ldv_48760: 
  ioim = (struct bfa_ioim_s *)qe;
  bfa_ioim_delayed_comp(ioim, iotov);
  qe = qen;
  qen = qe->next;
  ldv_48761: ;
  if ((unsigned long )(& itnim->delay_comp_q) != (unsigned long )qe) {
    goto ldv_48760;
  } else {

  }

  return;
}
}
static void bfa_itnim_iotov_online(struct bfa_itnim_s *itnim ) 
{ 
  struct bfa_ioim_s *ioim ;
  int tmp ;
  int tmp___0 ;

  {
  bfa_itnim_iotov_stop(itnim);
  bfa_itnim_delayed_comp(itnim, 0);
  goto ldv_48768;
  ldv_48767: 
  tmp = list_empty((struct list_head  const  *)(& itnim->pending_q));
  if (tmp == 0) {
    *((struct list_head **)(& ioim)) = itnim->pending_q.next;
    ((*((struct list_head **)(& ioim)))->next)->prev = & itnim->pending_q;
    itnim->pending_q.next = (*((struct list_head **)(& ioim)))->next;
  } else {
    *((struct list_head **)(& ioim)) = (struct list_head *)0;
  }
  list_add_tail(& ioim->qe, & itnim->io_q);
  bfa_ioim_start(ioim);
  ldv_48768: 
  tmp___0 = list_empty((struct list_head  const  *)(& itnim->pending_q));
  if (tmp___0 == 0) {
    goto ldv_48767;
  } else {

  }

  return;
}
}
static void bfa_itnim_iotov_cleanup(struct bfa_itnim_s *itnim ) 
{ 
  struct bfa_ioim_s *ioim ;
  int tmp ;
  int tmp___0 ;

  {
  bfa_itnim_delayed_comp(itnim, 1);
  goto ldv_48775;
  ldv_48774: 
  tmp = list_empty((struct list_head  const  *)(& itnim->pending_q));
  if (tmp == 0) {
    *((struct list_head **)(& ioim)) = itnim->pending_q.next;
    ((*((struct list_head **)(& ioim)))->next)->prev = & itnim->pending_q;
    itnim->pending_q.next = (*((struct list_head **)(& ioim)))->next;
  } else {
    *((struct list_head **)(& ioim)) = (struct list_head *)0;
  }
  list_add_tail(& ioim->qe, & (ioim->fcpim)->ioim_comp_q);
  bfa_ioim_tov(ioim);
  ldv_48775: 
  tmp___0 = list_empty((struct list_head  const  *)(& itnim->pending_q));
  if (tmp___0 == 0) {
    goto ldv_48774;
  } else {

  }

  return;
}
}
static void bfa_itnim_iotov(void *itnim_arg ) 
{ 
  struct bfa_itnim_s *itnim ;

  {
  itnim = (struct bfa_itnim_s *)itnim_arg;
  itnim->iotov_active = 0;
  bfa_cb_itnim_tov_begin(itnim->ditn);
  bfa_itnim_iotov_cleanup(itnim);
  bfa_cb_itnim_tov(itnim->ditn);
  return;
}
}
static void bfa_itnim_iotov_start(struct bfa_itnim_s *itnim ) 
{ 
  int __ret_warn_on ;
  enum bfa_boolean tmp ;
  long tmp___0 ;

  {
  if ((itnim->fcpim)->path_tov != 0U) {
    itnim->iotov_active = 1;
    tmp = bfa_itnim_hold_io(itnim);
    __ret_warn_on = (unsigned int )tmp == 0U;
    tmp___0 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
    if (tmp___0 != 0L) {
      warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcpim.c",
                         1299);
    } else {

    }
    ldv__builtin_expect(__ret_warn_on != 0, 0L);
    bfa_timer_begin(& (itnim->bfa)->timer_mod, & itnim->timer, & bfa_itnim_iotov,
                    (void *)itnim, (itnim->fcpim)->path_tov);
  } else {

  }
  return;
}
}
static void bfa_itnim_iotov_stop(struct bfa_itnim_s *itnim ) 
{ 


  {
  if ((unsigned int )itnim->iotov_active != 0U) {
    itnim->iotov_active = 0;
    bfa_timer_stop(& itnim->timer);
  } else {

  }
  return;
}
}
static void bfa_itnim_iotov_delete(struct bfa_itnim_s *itnim ) 
{ 
  enum bfa_boolean pathtov_active ;

  {
  pathtov_active = 0;
  if ((unsigned int )itnim->iotov_active != 0U) {
    pathtov_active = 1;
  } else {

  }
  bfa_itnim_iotov_stop(itnim);
  if ((unsigned int )pathtov_active != 0U) {
    bfa_cb_itnim_tov_begin(itnim->ditn);
  } else {

  }
  bfa_itnim_iotov_cleanup(itnim);
  if ((unsigned int )pathtov_active != 0U) {
    bfa_cb_itnim_tov(itnim->ditn);
  } else {

  }
  return;
}
}
static void bfa_itnim_update_del_itn_stats(struct bfa_itnim_s *itnim ) 
{ 
  struct bfa_fcpim_s *fcpim ;

  {
  fcpim = & (itnim->bfa)->modules.fcp_mod.fcpim;
  fcpim->del_itn_stats.del_itn_iocomp_aborted = fcpim->del_itn_stats.del_itn_iocomp_aborted + itnim->stats.iocomp_aborted;
  fcpim->del_itn_stats.del_itn_iocomp_timedout = fcpim->del_itn_stats.del_itn_iocomp_timedout + itnim->stats.iocomp_timedout;
  fcpim->del_itn_stats.del_itn_iocom_sqer_needed = fcpim->del_itn_stats.del_itn_iocom_sqer_needed + itnim->stats.iocom_sqer_needed;
  fcpim->del_itn_stats.del_itn_iocom_res_free = fcpim->del_itn_stats.del_itn_iocom_res_free + itnim->stats.iocom_res_free;
  fcpim->del_itn_stats.del_itn_iocom_hostabrts = fcpim->del_itn_stats.del_itn_iocom_hostabrts + itnim->stats.iocom_hostabrts;
  fcpim->del_itn_stats.del_itn_total_ios = fcpim->del_itn_stats.del_itn_total_ios + itnim->stats.total_ios;
  fcpim->del_itn_stats.del_io_iocdowns = fcpim->del_itn_stats.del_io_iocdowns + itnim->stats.io_iocdowns;
  fcpim->del_itn_stats.del_tm_iocdowns = fcpim->del_itn_stats.del_tm_iocdowns + itnim->stats.tm_iocdowns;
  return;
}
}
void bfa_itnim_isr(struct bfa_s *bfa , struct bfi_msg_s *m ) 
{ 
  struct bfa_fcpim_s *fcpim ;
  union bfi_itn_i2h_msg_u msg ;
  struct bfa_itnim_s *itnim ;
  int __ret_warn_on ;
  long tmp ;
  int __ret_warn_on___0 ;
  long tmp___0 ;
  int __ret_warn_on___1 ;
  long tmp___1 ;

  {
  fcpim = & bfa->modules.fcp_mod.fcpim;
  __bfa_trc(bfa->trcmod, __trc_fileno___11, 1369, (unsigned long long )m->mhdr.msg_id);
  msg.msg = m;
  switch ((int )m->mhdr.msg_id) {
  case 129: 
  itnim = fcpim->itnim_arr + (unsigned long )((int )(msg.create_rsp)->bfa_handle & (fcpim->num_itnims + -1));
  __ret_warn_on = (unsigned int )(msg.create_rsp)->status != 0U;
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcpim.c",
                       1377);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  itnim->stats.create_comps = itnim->stats.create_comps + 1U;
  (*(itnim->sm))((void *)itnim, 4);
  goto ldv_48807;
  case 130: 
  itnim = fcpim->itnim_arr + (unsigned long )((int )(msg.delete_rsp)->bfa_handle & (fcpim->num_itnims + -1));
  __ret_warn_on___0 = (unsigned int )(msg.delete_rsp)->status != 0U;
  tmp___0 = ldv__builtin_expect(__ret_warn_on___0 != 0, 0L);
  if (tmp___0 != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcpim.c",
                       1385);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on___0 != 0, 0L);
  itnim->stats.delete_comps = itnim->stats.delete_comps + 1U;
  (*(itnim->sm))((void *)itnim, 4);
  goto ldv_48807;
  case 131: 
  itnim = fcpim->itnim_arr + (unsigned long )((int )(msg.sler_event)->bfa_handle & (fcpim->num_itnims + -1));
  itnim->stats.sler_events = itnim->stats.sler_events + 1U;
  (*(itnim->sm))((void *)itnim, 7);
  goto ldv_48807;
  default: 
  __bfa_trc(bfa->trcmod, __trc_fileno___11, 1398, (unsigned long long )m->mhdr.msg_id);
  __ret_warn_on___1 = 1;
  tmp___1 = ldv__builtin_expect(__ret_warn_on___1 != 0, 0L);
  if (tmp___1 != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcpim.c",
                       1399);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on___1 != 0, 0L);
  }
  ldv_48807: ;
  return;
}
}
struct bfa_itnim_s *bfa_itnim_create(struct bfa_s *bfa , struct bfa_rport_s *rport ,
                                     void *ditn ) 
{ 
  struct bfa_fcpim_s *fcpim ;
  struct bfa_itnim_s *itnim ;
  int __ret_warn_on ;
  long tmp ;

  {
  fcpim = & bfa->modules.fcp_mod.fcpim;
  bfa_itn_create(bfa, rport, & bfa_itnim_isr);
  itnim = fcpim->itnim_arr + (unsigned long )((int )rport->rport_tag & (fcpim->num_itnims + -1));
  __ret_warn_on = (unsigned long )itnim->rport != (unsigned long )rport;
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcpim.c",
                       1416);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  itnim->ditn = ditn;
  itnim->stats.creates = itnim->stats.creates + 1U;
  (*(itnim->sm))((void *)itnim, 1);
  return (itnim);
}
}
void bfa_itnim_delete(struct bfa_itnim_s *itnim ) 
{ 


  {
  itnim->stats.deletes = itnim->stats.deletes + 1U;
  (*(itnim->sm))((void *)itnim, 5);
  return;
}
}
void bfa_itnim_online(struct bfa_itnim_s *itnim , enum bfa_boolean seq_rec ) 
{ 


  {
  itnim->seq_rec = seq_rec;
  itnim->stats.onlines = itnim->stats.onlines + 1U;
  (*(itnim->sm))((void *)itnim, 2);
  return;
}
}
void bfa_itnim_offline(struct bfa_itnim_s *itnim ) 
{ 


  {
  itnim->stats.offlines = itnim->stats.offlines + 1U;
  (*(itnim->sm))((void *)itnim, 3);
  return;
}
}
enum bfa_boolean bfa_itnim_hold_io(struct bfa_itnim_s *itnim ) 
{ 


  {
  return ((enum bfa_boolean )(((itnim->fcpim)->path_tov != 0U && (unsigned int )itnim->iotov_active != 0U) && ((((((unsigned long )itnim->sm == (unsigned long )((void (*)(void * ,
                                                                                                                                                                           int  ))(& bfa_itnim_sm_fwcreate)) || (unsigned long )itnim->sm == (unsigned long )((void (*)(void * ,
                                                                                                                                                                                                                                                                        int  ))(& bfa_itnim_sm_sler))) || (unsigned long )itnim->sm == (unsigned long )((void (*)(void * ,
                                                                                                                                                                                                                                                                                                                                                                  int  ))(& bfa_itnim_sm_cleanup_offline))) || (unsigned long )itnim->sm == (unsigned long )((void (*)(void * ,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                       int  ))(& bfa_itnim_sm_fwdelete))) || (unsigned long )itnim->sm == (unsigned long )((void (*)(void * ,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     int  ))(& bfa_itnim_sm_offline))) || (unsigned long )itnim->sm == (unsigned long )((void (*)(void * ,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  int  ))(& bfa_itnim_sm_iocdisable)))));
}
}
enum bfa_status bfa_itnim_get_ioprofile(struct bfa_itnim_s *itnim , struct bfa_itnim_ioprofile_s *ioprofile ) 
{ 
  struct bfa_fcpim_s *fcpim ;

  {
  if ((unsigned long )itnim == (unsigned long )((struct bfa_itnim_s *)0)) {
    return (52);
  } else {

  }
  fcpim = & (itnim->bfa)->modules.fcp_mod.fcpim;
  if ((unsigned int )fcpim->io_profile == 0U) {
    return (175);
  } else {

  }
  itnim->ioprofile.index = 14U;
  itnim->ioprofile.io_profile_start_time = (itnim->bfa)->modules.fcp_mod.fcpim.io_profile_start_time;
  itnim->ioprofile.clock_res_mul = 1000U;
  itnim->ioprofile.clock_res_div = 250U;
  *ioprofile = itnim->ioprofile;
  return (0);
}
}
void bfa_itnim_clear_stats(struct bfa_itnim_s *itnim ) 
{ 
  int j ;

  {
  if ((unsigned long )itnim == (unsigned long )((struct bfa_itnim_s *)0)) {
    return;
  } else {

  }
  memset((void *)(& itnim->stats), 0, 216UL);
  memset((void *)(& itnim->ioprofile), 0, 296UL);
  j = 0;
  goto ldv_48847;
  ldv_48846: 
  itnim->ioprofile.io_latency.min[j] = 4294967295U;
  j = j + 1;
  ldv_48847: ;
  if (j <= 13) {
    goto ldv_48846;
  } else {

  }

  return;
}
}
static void bfa_ioim_sm_uninit(struct bfa_ioim_s *ioim , enum bfa_ioim_event event ) 
{ 
  enum bfa_boolean tmp ;
  enum bfa_boolean tmp___0 ;
  enum bfa_boolean tmp___1 ;
  int __ret_warn_on ;
  int tmp___2 ;
  long tmp___3 ;

  {
  switch ((unsigned int )event) {
  case 1U: ;
  if ((unsigned int )(ioim->itnim)->is_online == 0U) {
    tmp = bfa_itnim_hold_io(ioim->itnim);
    if ((unsigned int )tmp == 0U) {
      ioim->sm = (void (*)(void * , int  ))(& bfa_ioim_sm_hcb);
      list_del(& ioim->qe);
      list_add_tail(& ioim->qe, & (ioim->fcpim)->ioim_comp_q);
      ioim->hcb_qe.cbfn = & __bfa_cb_ioim_pathtov;
      ioim->hcb_qe.cbarg = (void *)ioim;
      ioim->hcb_qe.pre_rmv = 0;
      list_add_tail(& ioim->hcb_qe.qe, & (ioim->bfa)->comp_q);
    } else {
      list_del(& ioim->qe);
      list_add_tail(& ioim->qe, & (ioim->itnim)->pending_q);
    }
    goto ldv_48854;
  } else {

  }
  if ((unsigned int )ioim->nsges > 1U) {
    tmp___0 = bfa_ioim_sgpg_alloc(ioim);
    if ((unsigned int )tmp___0 == 0U) {
      ioim->sm = (void (*)(void * , int  ))(& bfa_ioim_sm_sgalloc);
      return;
    } else {

    }
  } else {

  }
  tmp___1 = bfa_ioim_send_ioreq(ioim);
  if ((unsigned int )tmp___1 == 0U) {
    ioim->sm = (void (*)(void * , int  ))(& bfa_ioim_sm_qfull);
    goto ldv_48854;
  } else {

  }
  ioim->sm = (void (*)(void * , int  ))(& bfa_ioim_sm_active);
  goto ldv_48854;
  case 18U: 
  ioim->sm = (void (*)(void * , int  ))(& bfa_ioim_sm_hcb);
  list_del(& ioim->qe);
  list_add_tail(& ioim->qe, & (ioim->fcpim)->ioim_comp_q);
  ioim->hcb_qe.cbfn = & __bfa_cb_ioim_pathtov;
  ioim->hcb_qe.cbarg = (void *)ioim;
  ioim->hcb_qe.pre_rmv = 0;
  list_add_tail(& ioim->hcb_qe.qe, & (ioim->bfa)->comp_q);
  goto ldv_48854;
  case 7U: 
  ioim->sm = (void (*)(void * , int  ))(& bfa_ioim_sm_hcb);
  tmp___2 = bfa_q_is_on_q_func(& (ioim->itnim)->pending_q, (struct list_head *)ioim);
  __ret_warn_on = tmp___2 == 0;
  tmp___3 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp___3 != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcpim.c",
                       1560);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  ioim->hcb_qe.cbfn = & __bfa_cb_ioim_abort;
  ioim->hcb_qe.cbarg = (void *)ioim;
  ioim->hcb_qe.pre_rmv = 0;
  list_add_tail(& ioim->hcb_qe.qe, & (ioim->bfa)->comp_q);
  goto ldv_48854;
  default: 
  __bfa_trc((ioim->bfa)->trcmod, __trc_fileno___11, 1566, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcpim.c",
         1566, (unsigned int )event);
  }
  ldv_48854: ;
  return;
}
}
static void bfa_ioim_sm_sgalloc(struct bfa_ioim_s *ioim , enum bfa_ioim_event event ) 
{ 
  enum bfa_boolean tmp ;

  {
  __bfa_trc((ioim->bfa)->trcmod, __trc_fileno___11, 1576, (unsigned long long )ioim->iotag);
  __bfa_trc((ioim->bfa)->trcmod, __trc_fileno___11, 1577, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 11U: 
  tmp = bfa_ioim_send_ioreq(ioim);
  if ((unsigned int )tmp == 0U) {
    ioim->sm = (void (*)(void * , int  ))(& bfa_ioim_sm_qfull);
    goto ldv_48865;
  } else {

  }
  ioim->sm = (void (*)(void * , int  ))(& bfa_ioim_sm_active);
  goto ldv_48865;
  case 14U: 
  ioim->sm = (void (*)(void * , int  ))(& bfa_ioim_sm_hcb);
  bfa_sgpg_wcancel(ioim->bfa, & (ioim->iosp)->sgpg_wqe);
  ioim->hcb_qe.cbfn = & __bfa_cb_ioim_failed;
  ioim->hcb_qe.cbarg = (void *)ioim;
  ioim->hcb_qe.pre_rmv = 0;
  list_add_tail(& ioim->hcb_qe.qe, & (ioim->bfa)->comp_q);
  bfa_ioim_notify_cleanup(ioim);
  goto ldv_48865;
  case 7U: 
  ioim->sm = (void (*)(void * , int  ))(& bfa_ioim_sm_hcb);
  bfa_sgpg_wcancel(ioim->bfa, & (ioim->iosp)->sgpg_wqe);
  list_del(& ioim->qe);
  list_add_tail(& ioim->qe, & (ioim->fcpim)->ioim_comp_q);
  ioim->hcb_qe.cbfn = & __bfa_cb_ioim_abort;
  ioim->hcb_qe.cbarg = (void *)ioim;
  ioim->hcb_qe.pre_rmv = 0;
  list_add_tail(& ioim->hcb_qe.qe, & (ioim->bfa)->comp_q);
  goto ldv_48865;
  case 17U: 
  ioim->sm = (void (*)(void * , int  ))(& bfa_ioim_sm_hcb);
  bfa_sgpg_wcancel(ioim->bfa, & (ioim->iosp)->sgpg_wqe);
  list_del(& ioim->qe);
  list_add_tail(& ioim->qe, & (ioim->fcpim)->ioim_comp_q);
  ioim->hcb_qe.cbfn = & __bfa_cb_ioim_failed;
  ioim->hcb_qe.cbarg = (void *)ioim;
  ioim->hcb_qe.pre_rmv = 0;
  list_add_tail(& ioim->hcb_qe.qe, & (ioim->bfa)->comp_q);
  goto ldv_48865;
  default: 
  __bfa_trc((ioim->bfa)->trcmod, __trc_fileno___11, 1613, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcpim.c",
         1613, (unsigned int )event);
  }
  ldv_48865: ;
  return;
}
}
static void bfa_ioim_sm_active(struct bfa_ioim_s *ioim , enum bfa_ioim_event event ) 
{ 
  struct list_head *waitq ;
  int __ret_warn_on ;
  long tmp ;
  int __ret_warn_on___0 ;
  long tmp___0 ;
  enum bfa_boolean tmp___1 ;
  struct list_head *waitq___0 ;
  int __ret_warn_on___1 ;
  long tmp___2 ;
  int __ret_warn_on___2 ;
  long tmp___3 ;
  enum bfa_boolean tmp___4 ;
  enum bfa_boolean tmp___5 ;

  {
  switch ((unsigned int )event) {
  case 2U: 
  ioim->sm = (void (*)(void * , int  ))(& bfa_ioim_sm_hcb);
  list_del(& ioim->qe);
  list_add_tail(& ioim->qe, & (ioim->fcpim)->ioim_comp_q);
  ioim->hcb_qe.cbfn = & __bfa_cb_ioim_good_comp;
  ioim->hcb_qe.cbarg = (void *)ioim;
  ioim->hcb_qe.pre_rmv = 0;
  list_add_tail(& ioim->hcb_qe.qe, & (ioim->bfa)->comp_q);
  goto ldv_48875;
  case 3U: 
  ioim->sm = (void (*)(void * , int  ))(& bfa_ioim_sm_hcb);
  list_del(& ioim->qe);
  list_add_tail(& ioim->qe, & (ioim->fcpim)->ioim_comp_q);
  ioim->hcb_qe.cbfn = & __bfa_cb_ioim_comp;
  ioim->hcb_qe.cbarg = (void *)ioim;
  ioim->hcb_qe.pre_rmv = 0;
  list_add_tail(& ioim->hcb_qe.qe, & (ioim->bfa)->comp_q);
  goto ldv_48875;
  case 5U: 
  ioim->sm = (void (*)(void * , int  ))(& bfa_ioim_sm_hcb_free);
  list_del(& ioim->qe);
  list_add_tail(& ioim->qe, & (ioim->fcpim)->ioim_comp_q);
  ioim->hcb_qe.cbfn = & __bfa_cb_ioim_comp;
  ioim->hcb_qe.cbarg = (void *)ioim;
  ioim->hcb_qe.pre_rmv = 0;
  list_add_tail(& ioim->hcb_qe.qe, & (ioim->bfa)->comp_q);
  goto ldv_48875;
  case 7U: 
  (ioim->iosp)->abort_explicit = 1;
  ioim->io_cbfn = & __bfa_cb_ioim_abort;
  tmp___1 = bfa_ioim_send_abort(ioim);
  if ((unsigned int )tmp___1 != 0U) {
    ioim->sm = (void (*)(void * , int  ))(& bfa_ioim_sm_abort);
  } else {
    ioim->sm = (void (*)(void * , int  ))(& bfa_ioim_sm_abort_qfull);
    (ioim->itnim)->stats.qwait = (ioim->itnim)->stats.qwait + 1U;
    waitq = (struct list_head *)(& (ioim->bfa)->reqq_waitq) + (unsigned long )ioim->reqq;
    __ret_warn_on = (unsigned int )ioim->reqq > 3U;
    tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
    if (tmp != 0L) {
      warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcpim.c",
                         1655);
    } else {

    }
    ldv__builtin_expect(__ret_warn_on != 0, 0L);
    __ret_warn_on___0 = (unsigned long )(ioim->iosp)->reqq_wait.qresume == (unsigned long )((void (*)(void * ))0) || (unsigned long )(ioim->iosp)->reqq_wait.cbarg == (unsigned long )((void *)0);
    tmp___0 = ldv__builtin_expect(__ret_warn_on___0 != 0, 0L);
    if (tmp___0 != 0L) {
      warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcpim.c",
                         1655);
    } else {

    }
    ldv__builtin_expect(__ret_warn_on___0 != 0, 0L);
    list_add_tail(& (ioim->iosp)->reqq_wait.qe, waitq);
  }
  goto ldv_48875;
  case 14U: 
  (ioim->iosp)->abort_explicit = 0;
  ioim->io_cbfn = & __bfa_cb_ioim_failed;
  tmp___4 = bfa_ioim_send_abort(ioim);
  if ((unsigned int )tmp___4 != 0U) {
    ioim->sm = (void (*)(void * , int  ))(& bfa_ioim_sm_cleanup);
  } else {
    ioim->sm = (void (*)(void * , int  ))(& bfa_ioim_sm_cleanup_qfull);
    (ioim->itnim)->stats.qwait = (ioim->itnim)->stats.qwait + 1U;
    waitq___0 = (struct list_head *)(& (ioim->bfa)->reqq_waitq) + (unsigned long )ioim->reqq;
    __ret_warn_on___1 = (unsigned int )ioim->reqq > 3U;
    tmp___2 = ldv__builtin_expect(__ret_warn_on___1 != 0, 0L);
    if (tmp___2 != 0L) {
      warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcpim.c",
                         1669);
    } else {

    }
    ldv__builtin_expect(__ret_warn_on___1 != 0, 0L);
    __ret_warn_on___2 = (unsigned long )(ioim->iosp)->reqq_wait.qresume == (unsigned long )((void (*)(void * ))0) || (unsigned long )(ioim->iosp)->reqq_wait.cbarg == (unsigned long )((void *)0);
    tmp___3 = ldv__builtin_expect(__ret_warn_on___2 != 0, 0L);
    if (tmp___3 != 0L) {
      warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcpim.c",
                         1669);
    } else {

    }
    ldv__builtin_expect(__ret_warn_on___2 != 0, 0L);
    list_add_tail(& (ioim->iosp)->reqq_wait.qe, waitq___0);
  }
  goto ldv_48875;
  case 17U: 
  ioim->sm = (void (*)(void * , int  ))(& bfa_ioim_sm_hcb);
  list_del(& ioim->qe);
  list_add_tail(& ioim->qe, & (ioim->fcpim)->ioim_comp_q);
  ioim->hcb_qe.cbfn = & __bfa_cb_ioim_failed;
  ioim->hcb_qe.cbarg = (void *)ioim;
  ioim->hcb_qe.pre_rmv = 0;
  list_add_tail(& ioim->hcb_qe.qe, & (ioim->bfa)->comp_q);
  goto ldv_48875;
  case 12U: 
  tmp___5 = bfa_ioim_maxretry_reached(ioim);
  if ((unsigned int )tmp___5 != 0U) {
    ioim->sm = (void (*)(void * , int  ))(& bfa_ioim_sm_hcb_free);
    list_del(& ioim->qe);
    list_add_tail(& ioim->qe, & (ioim->fcpim)->ioim_comp_q);
    ioim->hcb_qe.cbfn = & __bfa_cb_ioim_failed;
    ioim->hcb_qe.cbarg = (void *)ioim;
    ioim->hcb_qe.pre_rmv = 0;
    list_add_tail(& ioim->hcb_qe.qe, & (ioim->bfa)->comp_q);
    goto ldv_48875;
  } else {

  }
  ioim->sm = (void (*)(void * , int  ))(& bfa_ioim_sm_cmnd_retry);
  goto ldv_48875;
  default: 
  __bfa_trc((ioim->bfa)->trcmod, __trc_fileno___11, 1694, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcpim.c",
         1694, (unsigned int )event);
  }
  ldv_48875: ;
  return;
}
}
static void bfa_ioim_sm_cmnd_retry(struct bfa_ioim_s *ioim , enum bfa_ioim_event event ) 
{ 
  uint16_t k ;
  enum bfa_boolean tmp ;
  struct list_head *waitq ;
  int __ret_warn_on ;
  long tmp___0 ;
  int __ret_warn_on___0 ;
  long tmp___1 ;
  enum bfa_boolean tmp___2 ;

  {
  switch ((unsigned int )event) {
  case 6U: 
  k = (uint16_t )((int )ioim->iotag >> 11);
  k = (uint16_t )((int )k + 1);
  ioim->iotag = (unsigned int )ioim->iotag & 2047U;
  ioim->iotag = (u16 )((int )((short )ioim->iotag) | (int )((short )((int )k << 11)));
  tmp = bfa_ioim_send_ioreq(ioim);
  if ((unsigned int )tmp == 0U) {
    ioim->sm = (void (*)(void * , int  ))(& bfa_ioim_sm_qfull);
    goto ldv_48899;
  } else {

  }
  ioim->sm = (void (*)(void * , int  ))(& bfa_ioim_sm_active);
  goto ldv_48899;
  case 14U: 
  (ioim->iosp)->abort_explicit = 0;
  ioim->io_cbfn = & __bfa_cb_ioim_failed;
  tmp___2 = bfa_ioim_send_abort(ioim);
  if ((unsigned int )tmp___2 != 0U) {
    ioim->sm = (void (*)(void * , int  ))(& bfa_ioim_sm_cleanup);
  } else {
    ioim->sm = (void (*)(void * , int  ))(& bfa_ioim_sm_cleanup_qfull);
    (ioim->itnim)->stats.qwait = (ioim->itnim)->stats.qwait + 1U;
    waitq = (struct list_head *)(& (ioim->bfa)->reqq_waitq) + (unsigned long )ioim->reqq;
    __ret_warn_on = (unsigned int )ioim->reqq > 3U;
    tmp___0 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
    if (tmp___0 != 0L) {
      warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcpim.c",
                         1725);
    } else {

    }
    ldv__builtin_expect(__ret_warn_on != 0, 0L);
    __ret_warn_on___0 = (unsigned long )(ioim->iosp)->reqq_wait.qresume == (unsigned long )((void (*)(void * ))0) || (unsigned long )(ioim->iosp)->reqq_wait.cbarg == (unsigned long )((void *)0);
    tmp___1 = ldv__builtin_expect(__ret_warn_on___0 != 0, 0L);
    if (tmp___1 != 0L) {
      warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcpim.c",
                         1725);
    } else {

    }
    ldv__builtin_expect(__ret_warn_on___0 != 0, 0L);
    list_add_tail(& (ioim->iosp)->reqq_wait.qe, waitq);
  }
  goto ldv_48899;
  case 17U: 
  ioim->sm = (void (*)(void * , int  ))(& bfa_ioim_sm_hcb);
  list_del(& ioim->qe);
  list_add_tail(& ioim->qe, & (ioim->fcpim)->ioim_comp_q);
  ioim->hcb_qe.cbfn = & __bfa_cb_ioim_failed;
  ioim->hcb_qe.cbarg = (void *)ioim;
  ioim->hcb_qe.pre_rmv = 0;
  list_add_tail(& ioim->hcb_qe.qe, & (ioim->bfa)->comp_q);
  goto ldv_48899;
  case 7U: 
  ioim->sm = (void (*)(void * , int  ))(& bfa_ioim_sm_hcb_free);
  ioim->hcb_qe.cbfn = & __bfa_cb_ioim_abort;
  ioim->hcb_qe.cbarg = (void *)ioim;
  ioim->hcb_qe.pre_rmv = 0;
  list_add_tail(& ioim->hcb_qe.qe, & (ioim->bfa)->comp_q);
  goto ldv_48899;
  default: 
  __bfa_trc((ioim->bfa)->trcmod, __trc_fileno___11, 1746, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcpim.c",
         1746, (unsigned int )event);
  }
  ldv_48899: ;
  return;
}
}
static void bfa_ioim_sm_abort(struct bfa_ioim_s *ioim , enum bfa_ioim_event event ) 
{ 
  int __ret_warn_on ;
  long tmp ;
  struct list_head *waitq ;
  int __ret_warn_on___0 ;
  long tmp___0 ;
  int __ret_warn_on___1 ;
  long tmp___1 ;
  enum bfa_boolean tmp___2 ;

  {
  __bfa_trc((ioim->bfa)->trcmod, __trc_fileno___11, 1756, (unsigned long long )ioim->iotag);
  __bfa_trc((ioim->bfa)->trcmod, __trc_fileno___11, 1757, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 2U: ;
  case 3U: ;
  case 5U: ;
  case 6U: ;
  goto ldv_48917;
  case 9U: 
  ioim->sm = (void (*)(void * , int  ))(& bfa_ioim_sm_hcb_free);
  ioim->hcb_qe.cbfn = & __bfa_cb_ioim_abort;
  ioim->hcb_qe.cbarg = (void *)ioim;
  ioim->hcb_qe.pre_rmv = 0;
  list_add_tail(& ioim->hcb_qe.qe, & (ioim->bfa)->comp_q);
  goto ldv_48917;
  case 8U: 
  ioim->sm = (void (*)(void * , int  ))(& bfa_ioim_sm_hcb);
  list_del(& ioim->qe);
  list_add_tail(& ioim->qe, & (ioim->fcpim)->ioim_comp_q);
  ioim->hcb_qe.cbfn = & __bfa_cb_ioim_abort;
  ioim->hcb_qe.cbarg = (void *)ioim;
  ioim->hcb_qe.pre_rmv = 0;
  list_add_tail(& ioim->hcb_qe.qe, & (ioim->bfa)->comp_q);
  goto ldv_48917;
  case 4U: 
  ioim->sm = (void (*)(void * , int  ))(& bfa_ioim_sm_hcb);
  list_del(& ioim->qe);
  list_add_tail(& ioim->qe, & (ioim->fcpim)->ioim_comp_q);
  ioim->hcb_qe.cbfn = & __bfa_cb_ioim_abort;
  ioim->hcb_qe.cbarg = (void *)ioim;
  ioim->hcb_qe.pre_rmv = 0;
  list_add_tail(& ioim->hcb_qe.qe, & (ioim->bfa)->comp_q);
  goto ldv_48917;
  case 14U: 
  __ret_warn_on = (unsigned int )(ioim->iosp)->abort_explicit != 1U;
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcpim.c",
                       1787);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  (ioim->iosp)->abort_explicit = 0;
  tmp___2 = bfa_ioim_send_abort(ioim);
  if ((unsigned int )tmp___2 != 0U) {
    ioim->sm = (void (*)(void * , int  ))(& bfa_ioim_sm_cleanup);
  } else {
    ioim->sm = (void (*)(void * , int  ))(& bfa_ioim_sm_cleanup_qfull);
    (ioim->itnim)->stats.qwait = (ioim->itnim)->stats.qwait + 1U;
    waitq = (struct list_head *)(& (ioim->bfa)->reqq_waitq) + (unsigned long )ioim->reqq;
    __ret_warn_on___0 = (unsigned int )ioim->reqq > 3U;
    tmp___0 = ldv__builtin_expect(__ret_warn_on___0 != 0, 0L);
    if (tmp___0 != 0L) {
      warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcpim.c",
                         1796);
    } else {

    }
    ldv__builtin_expect(__ret_warn_on___0 != 0, 0L);
    __ret_warn_on___1 = (unsigned long )(ioim->iosp)->reqq_wait.qresume == (unsigned long )((void (*)(void * ))0) || (unsigned long )(ioim->iosp)->reqq_wait.cbarg == (unsigned long )((void *)0);
    tmp___1 = ldv__builtin_expect(__ret_warn_on___1 != 0, 0L);
    if (tmp___1 != 0L) {
      warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcpim.c",
                         1796);
    } else {

    }
    ldv__builtin_expect(__ret_warn_on___1 != 0, 0L);
    list_add_tail(& (ioim->iosp)->reqq_wait.qe, waitq);
  }
  goto ldv_48917;
  case 17U: 
  ioim->sm = (void (*)(void * , int  ))(& bfa_ioim_sm_hcb);
  list_del(& ioim->qe);
  list_add_tail(& ioim->qe, & (ioim->fcpim)->ioim_comp_q);
  ioim->hcb_qe.cbfn = & __bfa_cb_ioim_failed;
  ioim->hcb_qe.cbarg = (void *)ioim;
  ioim->hcb_qe.pre_rmv = 0;
  list_add_tail(& ioim->hcb_qe.qe, & (ioim->bfa)->comp_q);
  goto ldv_48917;
  default: 
  __bfa_trc((ioim->bfa)->trcmod, __trc_fileno___11, 1808, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcpim.c",
         1808, (unsigned int )event);
  }
  ldv_48917: ;
  return;
}
}
static void bfa_ioim_sm_cleanup(struct bfa_ioim_s *ioim , enum bfa_ioim_event event ) 
{ 


  {
  __bfa_trc((ioim->bfa)->trcmod, __trc_fileno___11, 1819, (unsigned long long )ioim->iotag);
  __bfa_trc((ioim->bfa)->trcmod, __trc_fileno___11, 1820, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 2U: ;
  case 3U: ;
  case 5U: ;
  case 6U: ;
  goto ldv_48939;
  case 7U: 
  ioim->io_cbfn = & __bfa_cb_ioim_abort;
  goto ldv_48939;
  case 9U: 
  ioim->sm = (void (*)(void * , int  ))(& bfa_ioim_sm_hcb_free);
  ioim->hcb_qe.cbfn = ioim->io_cbfn;
  ioim->hcb_qe.cbarg = (void *)ioim;
  ioim->hcb_qe.pre_rmv = 0;
  list_add_tail(& ioim->hcb_qe.qe, & (ioim->bfa)->comp_q);
  bfa_ioim_notify_cleanup(ioim);
  goto ldv_48939;
  case 8U: 
  ioim->sm = (void (*)(void * , int  ))(& bfa_ioim_sm_hcb);
  ioim->hcb_qe.cbfn = ioim->io_cbfn;
  ioim->hcb_qe.cbarg = (void *)ioim;
  ioim->hcb_qe.pre_rmv = 0;
  list_add_tail(& ioim->hcb_qe.qe, & (ioim->bfa)->comp_q);
  bfa_ioim_notify_cleanup(ioim);
  goto ldv_48939;
  case 4U: 
  ioim->sm = (void (*)(void * , int  ))(& bfa_ioim_sm_hcb);
  ioim->hcb_qe.cbfn = ioim->io_cbfn;
  ioim->hcb_qe.cbarg = (void *)ioim;
  ioim->hcb_qe.pre_rmv = 0;
  list_add_tail(& ioim->hcb_qe.qe, & (ioim->bfa)->comp_q);
  bfa_ioim_notify_cleanup(ioim);
  goto ldv_48939;
  case 17U: 
  ioim->sm = (void (*)(void * , int  ))(& bfa_ioim_sm_hcb);
  list_del(& ioim->qe);
  list_add_tail(& ioim->qe, & (ioim->fcpim)->ioim_comp_q);
  ioim->hcb_qe.cbfn = & __bfa_cb_ioim_failed;
  ioim->hcb_qe.cbarg = (void *)ioim;
  ioim->hcb_qe.pre_rmv = 0;
  list_add_tail(& ioim->hcb_qe.qe, & (ioim->bfa)->comp_q);
  goto ldv_48939;
  case 14U: ;
  goto ldv_48939;
  default: 
  __bfa_trc((ioim->bfa)->trcmod, __trc_fileno___11, 1869, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcpim.c",
         1869, (unsigned int )event);
  }
  ldv_48939: ;
  return;
}
}
static void bfa_ioim_sm_qfull(struct bfa_ioim_s *ioim , enum bfa_ioim_event event ) 
{ 


  {
  __bfa_trc((ioim->bfa)->trcmod, __trc_fileno___11, 1879, (unsigned long long )ioim->iotag);
  __bfa_trc((ioim->bfa)->trcmod, __trc_fileno___11, 1880, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 10U: 
  ioim->sm = (void (*)(void * , int  ))(& bfa_ioim_sm_active);
  bfa_ioim_send_ioreq(ioim);
  goto ldv_48952;
  case 7U: 
  ioim->sm = (void (*)(void * , int  ))(& bfa_ioim_sm_hcb);
  list_del(& (ioim->iosp)->reqq_wait.qe);
  list_del(& ioim->qe);
  list_add_tail(& ioim->qe, & (ioim->fcpim)->ioim_comp_q);
  ioim->hcb_qe.cbfn = & __bfa_cb_ioim_abort;
  ioim->hcb_qe.cbarg = (void *)ioim;
  ioim->hcb_qe.pre_rmv = 0;
  list_add_tail(& ioim->hcb_qe.qe, & (ioim->bfa)->comp_q);
  goto ldv_48952;
  case 14U: 
  ioim->sm = (void (*)(void * , int  ))(& bfa_ioim_sm_hcb);
  list_del(& (ioim->iosp)->reqq_wait.qe);
  ioim->hcb_qe.cbfn = & __bfa_cb_ioim_failed;
  ioim->hcb_qe.cbarg = (void *)ioim;
  ioim->hcb_qe.pre_rmv = 0;
  list_add_tail(& ioim->hcb_qe.qe, & (ioim->bfa)->comp_q);
  bfa_ioim_notify_cleanup(ioim);
  goto ldv_48952;
  case 17U: 
  ioim->sm = (void (*)(void * , int  ))(& bfa_ioim_sm_hcb);
  list_del(& (ioim->iosp)->reqq_wait.qe);
  list_del(& ioim->qe);
  list_add_tail(& ioim->qe, & (ioim->fcpim)->ioim_comp_q);
  ioim->hcb_qe.cbfn = & __bfa_cb_ioim_failed;
  ioim->hcb_qe.cbarg = (void *)ioim;
  ioim->hcb_qe.pre_rmv = 0;
  list_add_tail(& ioim->hcb_qe.qe, & (ioim->bfa)->comp_q);
  goto ldv_48952;
  default: 
  __bfa_trc((ioim->bfa)->trcmod, __trc_fileno___11, 1913, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcpim.c",
         1913, (unsigned int )event);
  }
  ldv_48952: ;
  return;
}
}
static void bfa_ioim_sm_abort_qfull(struct bfa_ioim_s *ioim , enum bfa_ioim_event event ) 
{ 
  int __ret_warn_on ;
  long tmp ;

  {
  __bfa_trc((ioim->bfa)->trcmod, __trc_fileno___11, 1923, (unsigned long long )ioim->iotag);
  __bfa_trc((ioim->bfa)->trcmod, __trc_fileno___11, 1924, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 10U: 
  ioim->sm = (void (*)(void * , int  ))(& bfa_ioim_sm_abort);
  bfa_ioim_send_abort(ioim);
  goto ldv_48962;
  case 14U: 
  __ret_warn_on = (unsigned int )(ioim->iosp)->abort_explicit != 1U;
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcpim.c",
                       1933);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  (ioim->iosp)->abort_explicit = 0;
  ioim->sm = (void (*)(void * , int  ))(& bfa_ioim_sm_cleanup_qfull);
  goto ldv_48962;
  case 2U: ;
  case 3U: 
  ioim->sm = (void (*)(void * , int  ))(& bfa_ioim_sm_hcb);
  list_del(& (ioim->iosp)->reqq_wait.qe);
  list_del(& ioim->qe);
  list_add_tail(& ioim->qe, & (ioim->fcpim)->ioim_comp_q);
  ioim->hcb_qe.cbfn = & __bfa_cb_ioim_abort;
  ioim->hcb_qe.cbarg = (void *)ioim;
  ioim->hcb_qe.pre_rmv = 0;
  list_add_tail(& ioim->hcb_qe.qe, & (ioim->bfa)->comp_q);
  goto ldv_48962;
  case 5U: 
  ioim->sm = (void (*)(void * , int  ))(& bfa_ioim_sm_hcb_free);
  list_del(& (ioim->iosp)->reqq_wait.qe);
  list_del(& ioim->qe);
  list_add_tail(& ioim->qe, & (ioim->fcpim)->ioim_comp_q);
  ioim->hcb_qe.cbfn = & __bfa_cb_ioim_abort;
  ioim->hcb_qe.cbarg = (void *)ioim;
  ioim->hcb_qe.pre_rmv = 0;
  list_add_tail(& ioim->hcb_qe.qe, & (ioim->bfa)->comp_q);
  goto ldv_48962;
  case 17U: 
  ioim->sm = (void (*)(void * , int  ))(& bfa_ioim_sm_hcb);
  list_del(& (ioim->iosp)->reqq_wait.qe);
  list_del(& ioim->qe);
  list_add_tail(& ioim->qe, & (ioim->fcpim)->ioim_comp_q);
  ioim->hcb_qe.cbfn = & __bfa_cb_ioim_failed;
  ioim->hcb_qe.cbarg = (void *)ioim;
  ioim->hcb_qe.pre_rmv = 0;
  list_add_tail(& ioim->hcb_qe.qe, & (ioim->bfa)->comp_q);
  goto ldv_48962;
  default: 
  __bfa_trc((ioim->bfa)->trcmod, __trc_fileno___11, 1964, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcpim.c",
         1964, (unsigned int )event);
  }
  ldv_48962: ;
  return;
}
}
static void bfa_ioim_sm_cleanup_qfull(struct bfa_ioim_s *ioim , enum bfa_ioim_event event ) 
{ 


  {
  __bfa_trc((ioim->bfa)->trcmod, __trc_fileno___11, 1974, (unsigned long long )ioim->iotag);
  __bfa_trc((ioim->bfa)->trcmod, __trc_fileno___11, 1975, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 10U: 
  ioim->sm = (void (*)(void * , int  ))(& bfa_ioim_sm_cleanup);
  bfa_ioim_send_abort(ioim);
  goto ldv_48976;
  case 7U: 
  ioim->io_cbfn = & __bfa_cb_ioim_abort;
  goto ldv_48976;
  case 2U: ;
  case 3U: 
  ioim->sm = (void (*)(void * , int  ))(& bfa_ioim_sm_hcb);
  list_del(& (ioim->iosp)->reqq_wait.qe);
  ioim->hcb_qe.cbfn = ioim->io_cbfn;
  ioim->hcb_qe.cbarg = (void *)ioim;
  ioim->hcb_qe.pre_rmv = 0;
  list_add_tail(& ioim->hcb_qe.qe, & (ioim->bfa)->comp_q);
  bfa_ioim_notify_cleanup(ioim);
  goto ldv_48976;
  case 5U: 
  ioim->sm = (void (*)(void * , int  ))(& bfa_ioim_sm_hcb_free);
  list_del(& (ioim->iosp)->reqq_wait.qe);
  ioim->hcb_qe.cbfn = ioim->io_cbfn;
  ioim->hcb_qe.cbarg = (void *)ioim;
  ioim->hcb_qe.pre_rmv = 0;
  list_add_tail(& ioim->hcb_qe.qe, & (ioim->bfa)->comp_q);
  bfa_ioim_notify_cleanup(ioim);
  goto ldv_48976;
  case 17U: 
  ioim->sm = (void (*)(void * , int  ))(& bfa_ioim_sm_hcb);
  list_del(& (ioim->iosp)->reqq_wait.qe);
  list_del(& ioim->qe);
  list_add_tail(& ioim->qe, & (ioim->fcpim)->ioim_comp_q);
  ioim->hcb_qe.cbfn = & __bfa_cb_ioim_failed;
  ioim->hcb_qe.cbarg = (void *)ioim;
  ioim->hcb_qe.pre_rmv = 0;
  list_add_tail(& ioim->hcb_qe.qe, & (ioim->bfa)->comp_q);
  goto ldv_48976;
  default: 
  __bfa_trc((ioim->bfa)->trcmod, __trc_fileno___11, 2014, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcpim.c",
         2014, (unsigned int )event);
  }
  ldv_48976: ;
  return;
}
}
static void bfa_ioim_sm_hcb(struct bfa_ioim_s *ioim , enum bfa_ioim_event event ) 
{ 


  {
  switch ((unsigned int )event) {
  case 13U: 
  ioim->sm = (void (*)(void * , int  ))(& bfa_ioim_sm_uninit);
  bfa_ioim_free(ioim);
  goto ldv_48988;
  case 14U: 
  bfa_ioim_notify_cleanup(ioim);
  goto ldv_48988;
  case 17U: ;
  goto ldv_48988;
  default: 
  __bfa_trc((ioim->bfa)->trcmod, __trc_fileno___11, 2038, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcpim.c",
         2038, (unsigned int )event);
  }
  ldv_48988: ;
  return;
}
}
static void bfa_ioim_sm_hcb_free(struct bfa_ioim_s *ioim , enum bfa_ioim_event event ) 
{ 


  {
  __bfa_trc((ioim->bfa)->trcmod, __trc_fileno___11, 2048, (unsigned long long )ioim->iotag);
  __bfa_trc((ioim->bfa)->trcmod, __trc_fileno___11, 2049, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 13U: 
  ioim->sm = (void (*)(void * , int  ))(& bfa_ioim_sm_resfree);
  list_del(& ioim->qe);
  list_add_tail(& ioim->qe, & (ioim->fcpim)->ioim_resfree_q);
  goto ldv_48997;
  case 6U: 
  ioim->sm = (void (*)(void * , int  ))(& bfa_ioim_sm_hcb);
  goto ldv_48997;
  case 14U: 
  bfa_ioim_notify_cleanup(ioim);
  goto ldv_48997;
  case 17U: 
  ioim->sm = (void (*)(void * , int  ))(& bfa_ioim_sm_hcb);
  goto ldv_48997;
  default: 
  __bfa_trc((ioim->bfa)->trcmod, __trc_fileno___11, 2071, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcpim.c",
         2071, (unsigned int )event);
  }
  ldv_48997: ;
  return;
}
}
static void bfa_ioim_sm_resfree(struct bfa_ioim_s *ioim , enum bfa_ioim_event event ) 
{ 


  {
  __bfa_trc((ioim->bfa)->trcmod, __trc_fileno___11, 2081, (unsigned long long )ioim->iotag);
  __bfa_trc((ioim->bfa)->trcmod, __trc_fileno___11, 2082, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 6U: 
  ioim->sm = (void (*)(void * , int  ))(& bfa_ioim_sm_uninit);
  bfa_ioim_free(ioim);
  goto ldv_49007;
  case 14U: 
  bfa_ioim_notify_cleanup(ioim);
  goto ldv_49007;
  case 17U: ;
  goto ldv_49007;
  default: 
  __bfa_trc((ioim->bfa)->trcmod, __trc_fileno___11, 2098, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcpim.c",
         2098, (unsigned int )event);
  }
  ldv_49007: ;
  return;
}
}
static void bfa_ioim_lm_init(struct bfa_s *bfa ) 
{ 
  struct bfa_lun_mask_s *lunm_list ;
  int i ;

  {
  if ((unsigned int )bfa->modules.dconf_mod.min_cfg != 0U || ((unsigned int )bfa->modules.dconf_mod.min_cfg == 0U ? & (bfa->modules.dconf_mod.dconf)->lun_mask : (struct bfa_lunmask_cfg_s *)0)->status == 2U) {
    return;
  } else {

  }
  lunm_list = (unsigned int )bfa->modules.dconf_mod.min_cfg == 0U ? ((unsigned int )bfa->modules.dconf_mod.min_cfg == 0U ? (struct bfa_lun_mask_s *)(& (bfa->modules.dconf_mod.dconf)->lun_mask.lun_list) : (struct bfa_lun_mask_s *)0) : (struct bfa_lun_mask_s *)0;
  i = 0;
  goto ldv_49017;
  ldv_49016: 
  (lunm_list + (unsigned long )i)->ua = 0U;
  (lunm_list + (unsigned long )i)->lp_tag = 255U;
  (lunm_list + (unsigned long )i)->rp_tag = 65535U;
  i = i + 1;
  ldv_49017: ;
  if (i <= 15) {
    goto ldv_49016;
  } else {

  }

  return;
}
}
static void __bfa_cb_ioim_good_comp(void *cbarg , enum bfa_boolean complete___0 ) 
{ 
  struct bfa_ioim_s *ioim ;

  {
  ioim = (struct bfa_ioim_s *)cbarg;
  if ((unsigned int )complete___0 == 0U) {
    (*(ioim->sm))((void *)ioim, 13);
    return;
  } else {

  }
  bfa_cb_ioim_good_comp((ioim->bfa)->bfad, ioim->dio);
  return;
}
}
static void __bfa_cb_ioim_comp(void *cbarg , enum bfa_boolean complete___0 ) 
{ 
  struct bfa_ioim_s *ioim ;
  struct bfi_ioim_rsp_s *m ;
  u8 *snsinfo ;
  u8 sns_len ;
  s32 residue ;
  __u32 tmp ;
  __u32 tmp___0 ;

  {
  ioim = (struct bfa_ioim_s *)cbarg;
  snsinfo = (u8 *)0U;
  sns_len = 0U;
  residue = 0;
  if ((unsigned int )complete___0 == 0U) {
    (*(ioim->sm))((void *)ioim, 13);
    return;
  } else {

  }
  m = (struct bfi_ioim_rsp_s *)(& (ioim->iosp)->comp_rspmsg);
  if ((unsigned int )m->io_status == 0U) {
    if ((unsigned int )m->scsi_status == 2U && (unsigned int )m->sns_len != 0U) {
      sns_len = m->sns_len;
      snsinfo = ((ioim->fcpim)->fcp)->dma_seg[((int )ioim->iotag & 2047) / 512].kva_curp + (unsigned long )(((int )ioim->iotag & 511) * 256);
    } else {

    }
    if ((unsigned int )m->resid_flags == 2U) {
      tmp = __fswab32(m->residue);
      residue = (s32 )tmp;
      (ioim->itnim)->stats.iocomp_underrun = (ioim->itnim)->stats.iocomp_underrun + 1U;
    } else {

    }
    if ((unsigned int )m->resid_flags == 1U) {
      tmp___0 = __fswab32(m->residue);
      residue = (s32 )tmp___0;
      residue = - residue;
      (ioim->itnim)->stats.iocomp_overrun = (ioim->itnim)->stats.iocomp_overrun + 1U;
    } else {

    }
  } else {

  }
  bfa_cb_ioim_done((ioim->bfa)->bfad, ioim->dio, (enum bfi_ioim_status )m->io_status,
                   (int )m->scsi_status, (int )sns_len, snsinfo, residue);
  return;
}
}
void bfa_fcpim_lunmask_rp_update(struct bfa_s *bfa , wwn_t lp_wwn , wwn_t rp_wwn ,
                                 u16 rp_tag , u8 lp_tag ) 
{ 
  struct bfa_lun_mask_s *lun_list ;
  u8 i ;

  {
  if ((unsigned int )bfa->modules.dconf_mod.min_cfg != 0U || ((unsigned int )bfa->modules.dconf_mod.min_cfg == 0U ? & (bfa->modules.dconf_mod.dconf)->lun_mask : (struct bfa_lunmask_cfg_s *)0)->status == 2U) {
    return;
  } else {

  }
  lun_list = (unsigned int )bfa->modules.dconf_mod.min_cfg == 0U ? ((unsigned int )bfa->modules.dconf_mod.min_cfg == 0U ? (struct bfa_lun_mask_s *)(& (bfa->modules.dconf_mod.dconf)->lun_mask.lun_list) : (struct bfa_lun_mask_s *)0) : (struct bfa_lun_mask_s *)0;
  i = 0U;
  goto ldv_49043;
  ldv_49042: ;
  if ((unsigned int )(lun_list + (unsigned long )i)->state == 1U) {
    if ((lun_list + (unsigned long )i)->lp_wwn == lp_wwn && (lun_list + (unsigned long )i)->rp_wwn == rp_wwn) {
      (lun_list + (unsigned long )i)->rp_tag = rp_tag;
      (lun_list + (unsigned long )i)->lp_tag = lp_tag;
    } else {

    }
  } else {

  }
  i = (u8 )((int )i + 1);
  ldv_49043: ;
  if ((unsigned int )i <= 15U) {
    goto ldv_49042;
  } else {

  }

  return;
}
}
static void bfa_ioim_lm_set_ua(struct bfa_s *bfa ) 
{ 
  struct bfa_lun_mask_s *lunm_list ;
  int i ;

  {
  lunm_list = (unsigned int )bfa->modules.dconf_mod.min_cfg == 0U ? ((unsigned int )bfa->modules.dconf_mod.min_cfg == 0U ? (struct bfa_lun_mask_s *)(& (bfa->modules.dconf_mod.dconf)->lun_mask.lun_list) : (struct bfa_lun_mask_s *)0) : (struct bfa_lun_mask_s *)0;
  i = 0;
  goto ldv_49052;
  ldv_49051: ;
  if ((unsigned int )(lunm_list + (unsigned long )i)->state != 1U) {
    goto ldv_49050;
  } else {

  }
  (lunm_list + (unsigned long )i)->ua = 1U;
  ldv_49050: 
  i = i + 1;
  ldv_49052: ;
  if (i <= 15) {
    goto ldv_49051;
  } else {

  }

  return;
}
}
enum bfa_status bfa_fcpim_lunmask_update(struct bfa_s *bfa , u32 update ) 
{ 
  struct bfa_lunmask_cfg_s *lun_mask ;
  enum bfa_status tmp ;

  {
  __bfa_trc(bfa->trcmod, __trc_fileno___11, 2225, (unsigned int )bfa->modules.dconf_mod.min_cfg == 0U ? (unsigned long long )((unsigned int )bfa->modules.dconf_mod.min_cfg == 0U ? & (bfa->modules.dconf_mod.dconf)->lun_mask : (struct bfa_lunmask_cfg_s *)0)->status : 2ULL);
  if ((unsigned int )bfa->modules.dconf_mod.min_cfg != 0U || ((unsigned int )bfa->modules.dconf_mod.min_cfg == 0U ? & (bfa->modules.dconf_mod.dconf)->lun_mask : (struct bfa_lunmask_cfg_s *)0)->status == 2U) {
    return (1);
  } else {

  }
  if (((unsigned int )bfa->modules.dconf_mod.min_cfg == 0U ? ((unsigned int )bfa->modules.dconf_mod.min_cfg == 0U ? & (bfa->modules.dconf_mod.dconf)->lun_mask : (struct bfa_lunmask_cfg_s *)0)->status : 2U) == update) {
    return (195);
  } else {

  }
  lun_mask = (unsigned int )bfa->modules.dconf_mod.min_cfg == 0U ? & (bfa->modules.dconf_mod.dconf)->lun_mask : (struct bfa_lunmask_cfg_s *)0;
  lun_mask->status = update;
  if ((unsigned int )bfa->modules.dconf_mod.min_cfg == 0U && ((unsigned int )bfa->modules.dconf_mod.min_cfg == 0U ? & (bfa->modules.dconf_mod.dconf)->lun_mask : (struct bfa_lunmask_cfg_s *)0)->status == 1U) {
    bfa_ioim_lm_set_ua(bfa);
  } else {

  }
  tmp = bfa_dconf_update(bfa);
  return (tmp);
}
}
enum bfa_status bfa_fcpim_lunmask_clear(struct bfa_s *bfa ) 
{ 
  int i ;
  struct bfa_lun_mask_s *lunm_list ;
  enum bfa_status tmp ;

  {
  __bfa_trc(bfa->trcmod, __trc_fileno___11, 2247, (unsigned int )bfa->modules.dconf_mod.min_cfg == 0U ? (unsigned long long )((unsigned int )bfa->modules.dconf_mod.min_cfg == 0U ? & (bfa->modules.dconf_mod.dconf)->lun_mask : (struct bfa_lunmask_cfg_s *)0)->status : 2ULL);
  if ((unsigned int )bfa->modules.dconf_mod.min_cfg != 0U || ((unsigned int )bfa->modules.dconf_mod.min_cfg == 0U ? & (bfa->modules.dconf_mod.dconf)->lun_mask : (struct bfa_lunmask_cfg_s *)0)->status == 2U) {
    return (1);
  } else {

  }
  lunm_list = (unsigned int )bfa->modules.dconf_mod.min_cfg == 0U ? ((unsigned int )bfa->modules.dconf_mod.min_cfg == 0U ? (struct bfa_lun_mask_s *)(& (bfa->modules.dconf_mod.dconf)->lun_mask.lun_list) : (struct bfa_lun_mask_s *)0) : (struct bfa_lun_mask_s *)0;
  i = 0;
  goto ldv_49065;
  ldv_49064: ;
  if ((unsigned int )(lunm_list + (unsigned long )i)->state == 1U) {
    if ((unsigned int )(lunm_list + (unsigned long )i)->rp_tag != 65535U) {
      bfa_rport_unset_lunmask(bfa, bfa->modules.rport_mod.rps_list + (unsigned long )((int )(lunm_list + (unsigned long )i)->rp_tag & ((int )bfa->modules.rport_mod.num_rports + -1)));
    } else {

    }
  } else {

  }
  i = i + 1;
  ldv_49065: ;
  if (i <= 15) {
    goto ldv_49064;
  } else {

  }
  memset((void *)lunm_list, 0, 512UL);
  tmp = bfa_dconf_update(bfa);
  return (tmp);
}
}
enum bfa_status bfa_fcpim_lunmask_query(struct bfa_s *bfa , void *buf ) 
{ 
  struct bfa_lunmask_cfg_s *lun_mask ;

  {
  __bfa_trc(bfa->trcmod, __trc_fileno___11, 2269, (unsigned int )bfa->modules.dconf_mod.min_cfg == 0U ? (unsigned long long )((unsigned int )bfa->modules.dconf_mod.min_cfg == 0U ? & (bfa->modules.dconf_mod.dconf)->lun_mask : (struct bfa_lunmask_cfg_s *)0)->status : 2ULL);
  if ((unsigned int )bfa->modules.dconf_mod.min_cfg != 0U || ((unsigned int )bfa->modules.dconf_mod.min_cfg == 0U ? & (bfa->modules.dconf_mod.dconf)->lun_mask : (struct bfa_lunmask_cfg_s *)0)->status == 2U) {
    return (1);
  } else {

  }
  lun_mask = (unsigned int )bfa->modules.dconf_mod.min_cfg == 0U ? & (bfa->modules.dconf_mod.dconf)->lun_mask : (struct bfa_lunmask_cfg_s *)0;
  memcpy(buf, (void const   *)lun_mask, 520UL);
  return (0);
}
}
enum bfa_status bfa_fcpim_lunmask_add(struct bfa_s *bfa , u16 vf_id , wwn_t *pwwn ,
                                      wwn_t rpwwn , struct scsi_lun lun ) 
{ 
  struct bfa_lun_mask_s *lunm_list ;
  struct bfa_rport_s *rp ;
  int i ;
  int free_index ;
    klee_make_symbolic(&free_index, sizeof(int), "free_index");
  struct bfa_fcs_lport_s *port ;
  struct bfa_fcs_rport_s *rp_fcs ;
  u64 tmp ;
  u64 tmp___0 ;
  enum bfa_status tmp___1 ;

  {
  rp = (struct bfa_rport_s *)0;
  free_index = 17;
  port = (struct bfa_fcs_lport_s *)0;
  __bfa_trc(bfa->trcmod, __trc_fileno___11, 2288, (unsigned int )bfa->modules.dconf_mod.min_cfg == 0U ? (unsigned long long )((unsigned int )bfa->modules.dconf_mod.min_cfg == 0U ? & (bfa->modules.dconf_mod.dconf)->lun_mask : (struct bfa_lunmask_cfg_s *)0)->status : 2ULL);
  if ((unsigned int )bfa->modules.dconf_mod.min_cfg != 0U || ((unsigned int )bfa->modules.dconf_mod.min_cfg == 0U ? & (bfa->modules.dconf_mod.dconf)->lun_mask : (struct bfa_lunmask_cfg_s *)0)->status == 2U) {
    return (1);
  } else {

  }
  port = bfa_fcs_lookup_port(& ((struct bfad_s *)bfa->bfad)->bfa_fcs, (int )vf_id,
                             *pwwn);
  if ((unsigned long )port != (unsigned long )((struct bfa_fcs_lport_s *)0)) {
    *pwwn = port->port_cfg.pwwn;
    rp_fcs = bfa_fcs_lport_get_rport_by_pwwn(port, rpwwn);
    if ((unsigned long )rp_fcs != (unsigned long )((struct bfa_fcs_rport_s *)0)) {
      rp = rp_fcs->bfa_rport;
    } else {

    }
  } else {

  }
  lunm_list = (unsigned int )bfa->modules.dconf_mod.min_cfg == 0U ? ((unsigned int )bfa->modules.dconf_mod.min_cfg == 0U ? (struct bfa_lun_mask_s *)(& (bfa->modules.dconf_mod.dconf)->lun_mask.lun_list) : (struct bfa_lun_mask_s *)0) : (struct bfa_lun_mask_s *)0;
  i = 0;
  goto ldv_49086;
  ldv_49085: ;
  if ((unsigned int )(lunm_list + (unsigned long )i)->state != 1U) {
    free_index = i;
  } else {

  }
  if ((lunm_list + (unsigned long )i)->lp_wwn == *pwwn && (lunm_list + (unsigned long )i)->rp_wwn == rpwwn) {
    tmp = scsilun_to_int(& (lunm_list + (unsigned long )i)->lun);
    tmp___0 = scsilun_to_int(& lun);
    if (tmp == tmp___0) {
      return (193);
    } else {

    }
  } else {

  }
  i = i + 1;
  ldv_49086: ;
  if (i <= 15) {
    goto ldv_49085;
  } else {

  }

  if (free_index > 16) {
    return (212);
  } else {

  }
  if ((unsigned long )rp != (unsigned long )((struct bfa_rport_s *)0)) {
    (lunm_list + (unsigned long )free_index)->lp_tag = bfa_lps_get_tag_from_pid(bfa,
                                                                                rp->rport_info.local_pid);
    (lunm_list + (unsigned long )free_index)->rp_tag = rp->rport_tag;
  } else {
    (lunm_list + (unsigned long )free_index)->lp_tag = 255U;
    (lunm_list + (unsigned long )free_index)->rp_tag = 65535U;
  }
  (lunm_list + (unsigned long )free_index)->lp_wwn = *pwwn;
  (lunm_list + (unsigned long )free_index)->rp_wwn = rpwwn;
  (lunm_list + (unsigned long )free_index)->lun = lun;
  (lunm_list + (unsigned long )free_index)->state = 1U;
  i = 0;
  goto ldv_49089;
  ldv_49088: ;
  if ((lunm_list + (unsigned long )i)->lp_wwn == *pwwn && (lunm_list + (unsigned long )i)->rp_wwn == rpwwn) {
    (lunm_list + (unsigned long )i)->ua = 1U;
  } else {

  }
  i = i + 1;
  ldv_49089: ;
  if (i <= 15) {
    goto ldv_49088;
  } else {

  }
  tmp___1 = bfa_dconf_update(bfa);
  return (tmp___1);
}
}
enum bfa_status bfa_fcpim_lunmask_delete(struct bfa_s *bfa , u16 vf_id , wwn_t *pwwn ,
                                         wwn_t rpwwn , struct scsi_lun lun ) 
{ 
  struct bfa_lun_mask_s *lunm_list ;
  struct bfa_rport_s *rp ;
  struct bfa_fcs_lport_s *port ;
  struct bfa_fcs_rport_s *rp_fcs ;
  int i ;
  u64 tmp ;
  enum bfa_status tmp___0 ;
  u64 tmp___1 ;
  u64 tmp___2 ;

  {
  rp = (struct bfa_rport_s *)0;
  port = (struct bfa_fcs_lport_s *)0;
  if ((unsigned int )bfa->modules.dconf_mod.min_cfg != 0U || ((unsigned int )bfa->modules.dconf_mod.min_cfg == 0U ? & (bfa->modules.dconf_mod.dconf)->lun_mask : (struct bfa_lunmask_cfg_s *)0)->status == 2U) {
    return (1);
  } else {

  }
  __bfa_trc(bfa->trcmod, __trc_fileno___11, 2354, (unsigned int )bfa->modules.dconf_mod.min_cfg == 0U ? (unsigned long long )((unsigned int )bfa->modules.dconf_mod.min_cfg == 0U ? & (bfa->modules.dconf_mod.dconf)->lun_mask : (struct bfa_lunmask_cfg_s *)0)->status : 2ULL);
  __bfa_trc(bfa->trcmod, __trc_fileno___11, 2355, *pwwn);
  __bfa_trc(bfa->trcmod, __trc_fileno___11, 2356, rpwwn);
  tmp = scsilun_to_int(& lun);
  __bfa_trc(bfa->trcmod, __trc_fileno___11, 2357, tmp);
  if (*pwwn == 0ULL) {
    port = bfa_fcs_lookup_port(& ((struct bfad_s *)bfa->bfad)->bfa_fcs, (int )vf_id,
                               *pwwn);
    if ((unsigned long )port != (unsigned long )((struct bfa_fcs_lport_s *)0)) {
      *pwwn = port->port_cfg.pwwn;
      rp_fcs = bfa_fcs_lport_get_rport_by_pwwn(port, rpwwn);
      if ((unsigned long )rp_fcs != (unsigned long )((struct bfa_fcs_rport_s *)0)) {
        rp = rp_fcs->bfa_rport;
      } else {

      }
    } else {

    }
  } else {

  }
  lunm_list = (unsigned int )bfa->modules.dconf_mod.min_cfg == 0U ? ((unsigned int )bfa->modules.dconf_mod.min_cfg == 0U ? (struct bfa_lun_mask_s *)(& (bfa->modules.dconf_mod.dconf)->lun_mask.lun_list) : (struct bfa_lun_mask_s *)0) : (struct bfa_lun_mask_s *)0;
  i = 0;
  goto ldv_49104;
  ldv_49103: ;
  if ((lunm_list + (unsigned long )i)->lp_wwn == *pwwn && (lunm_list + (unsigned long )i)->rp_wwn == rpwwn) {
    tmp___1 = scsilun_to_int(& (lunm_list + (unsigned long )i)->lun);
    tmp___2 = scsilun_to_int(& lun);
    if (tmp___1 == tmp___2) {
      (lunm_list + (unsigned long )i)->lp_wwn = 0ULL;
      (lunm_list + (unsigned long )i)->rp_wwn = 0ULL;
      int_to_scsilun(0ULL, & (lunm_list + (unsigned long )i)->lun);
      (lunm_list + (unsigned long )i)->state = 0U;
      if ((unsigned int )(lunm_list + (unsigned long )i)->rp_tag != 65535U) {
        (lunm_list + (unsigned long )i)->rp_tag = 65535U;
        (lunm_list + (unsigned long )i)->lp_tag = 255U;
      } else {

      }
      tmp___0 = bfa_dconf_update(bfa);
      return (tmp___0);
    } else {

    }
  } else {

  }
  i = i + 1;
  ldv_49104: ;
  if (i <= 15) {
    goto ldv_49103;
  } else {

  }
  i = 0;
  goto ldv_49107;
  ldv_49106: ;
  if ((lunm_list + (unsigned long )i)->lp_wwn == *pwwn && (lunm_list + (unsigned long )i)->rp_wwn == rpwwn) {
    (lunm_list + (unsigned long )i)->ua = 1U;
  } else {

  }
  i = i + 1;
  ldv_49107: ;
  if (i <= 15) {
    goto ldv_49106;
  } else {

  }

  return (194);
}
}
static void __bfa_cb_ioim_failed(void *cbarg , enum bfa_boolean complete___0 ) 
{ 
  struct bfa_ioim_s *ioim ;

  {
  ioim = (struct bfa_ioim_s *)cbarg;
  if ((unsigned int )complete___0 == 0U) {
    (*(ioim->sm))((void *)ioim, 13);
    return;
  } else {

  }
  bfa_cb_ioim_done((ioim->bfa)->bfad, ioim->dio, 2, 0, 0, (u8 *)0U, 0);
  return;
}
}
static void __bfa_cb_ioim_pathtov(void *cbarg , enum bfa_boolean complete___0 ) 
{ 
  struct bfa_ioim_s *ioim ;

  {
  ioim = (struct bfa_ioim_s *)cbarg;
  (ioim->itnim)->stats.path_tov_expired = (ioim->itnim)->stats.path_tov_expired + 1U;
  if ((unsigned int )complete___0 == 0U) {
    (*(ioim->sm))((void *)ioim, 13);
    return;
  } else {

  }
  bfa_cb_ioim_done((ioim->bfa)->bfad, ioim->dio, 8, 0, 0, (u8 *)0U, 0);
  return;
}
}
static void __bfa_cb_ioim_abort(void *cbarg , enum bfa_boolean complete___0 ) 
{ 
  struct bfa_ioim_s *ioim ;

  {
  ioim = (struct bfa_ioim_s *)cbarg;
  if ((unsigned int )complete___0 == 0U) {
    (*(ioim->sm))((void *)ioim, 13);
    return;
  } else {

  }
  bfa_cb_ioim_abort((ioim->bfa)->bfad, ioim->dio);
  return;
}
}
static void bfa_ioim_sgpg_alloced(void *cbarg ) 
{ 
  struct bfa_ioim_s *ioim ;

  {
  ioim = (struct bfa_ioim_s *)cbarg;
  ioim->nsgpgs = (unsigned int )((u16 )((unsigned int )ioim->nsges / 7U)) + 1U;
  list_splice_tail_init(& (ioim->iosp)->sgpg_wqe.sgpg_q, & ioim->sgpg_q);
  ioim->sgpg = (struct bfa_sgpg_s *)ioim->sgpg_q.next;
  (*(ioim->sm))((void *)ioim, 11);
  return;
}
}
static enum bfa_boolean bfa_ioim_send_ioreq(struct bfa_ioim_s *ioim ) 
{ 
  struct bfa_itnim_s *itnim ;
  struct bfi_ioim_req_s *m ;
  struct fcp_cmnd_s cmnd_z0 ;
  unsigned int tmp ;
  struct bfi_sge_s *sge ;
  struct bfi_sge_s *sgpge ;
  u32 pgdlen ;
  u32 fcp_dl ;
  u64 addr ;
  struct scatterlist *sg ;
  struct bfa_sgpg_s *sgpg ;
  struct scsi_cmnd *cmnd ;
  u32 i ;
  u32 sge_id ;
  u32 pgcumsz ;
  enum dma_data_direction dmadir ;
  struct list_head *waitq ;
  int __ret_warn_on ;
  long tmp___0 ;
  int __ret_warn_on___0 ;
  long tmp___1 ;
  __u16 tmp___2 ;
  __u32 tmp___3 ;
  __u32 tmp___4 ;
  __u32 tmp___5 ;
  __u32 tmp___6 ;
  __u32 tmp___7 ;
  __u32 tmp___8 ;
  __u32 tmp___9 ;
  unsigned int tmp___10 ;
    klee_make_symbolic(&tmp___10, sizeof(int), "tmp___10");

  {
  itnim = ioim->itnim;
  cmnd_z0.lun.scsi_lun[0] = 0U;
  tmp = 1U;
  while (1) {
    if (tmp >= 8U) {
      break;
    } else {

    }
    cmnd_z0.lun.scsi_lun[tmp] = (unsigned char)0;
    tmp = tmp + 1U;
  }
  cmnd_z0.crn = (unsigned char)0;
  cmnd_z0.taskattr = (unsigned char)0;
  cmnd_z0.priority = (unsigned char)0;
  cmnd_z0.resvd = (unsigned char)0;
  cmnd_z0.tm_flags = (unsigned char)0;
  cmnd_z0.iodir = (unsigned char)0;
  cmnd_z0.addl_cdb_len = (unsigned char)0;
  cmnd_z0.cdb.scsi_cdb[0] = (unsigned char)0;
  cmnd_z0.cdb.scsi_cdb[1] = (unsigned char)0;
  cmnd_z0.cdb.scsi_cdb[2] = (unsigned char)0;
  cmnd_z0.cdb.scsi_cdb[3] = (unsigned char)0;
  cmnd_z0.cdb.scsi_cdb[4] = (unsigned char)0;
  cmnd_z0.cdb.scsi_cdb[5] = (unsigned char)0;
  cmnd_z0.cdb.scsi_cdb[6] = (unsigned char)0;
  cmnd_z0.cdb.scsi_cdb[7] = (unsigned char)0;
  cmnd_z0.cdb.scsi_cdb[8] = (unsigned char)0;
  cmnd_z0.cdb.scsi_cdb[9] = (unsigned char)0;
  cmnd_z0.cdb.scsi_cdb[10] = (unsigned char)0;
  cmnd_z0.cdb.scsi_cdb[11] = (unsigned char)0;
  cmnd_z0.cdb.scsi_cdb[12] = (unsigned char)0;
  cmnd_z0.cdb.scsi_cdb[13] = (unsigned char)0;
  cmnd_z0.cdb.scsi_cdb[14] = (unsigned char)0;
  cmnd_z0.cdb.scsi_cdb[15] = (unsigned char)0;
  cmnd_z0.fcp_dl = 0U;
  pgdlen = 0U;
  cmnd = (struct scsi_cmnd *)ioim->dio;
  m = (((ioim->bfa)->iocfc.req_cq_pi[(int )ioim->reqq] + 1U) & (u32 )((int )(ioim->bfa)->iocfc.cfg.drvcfg.num_reqq_elems + -1)) != *((u32 *)(ioim->bfa)->iocfc.req_cq_shadow_ci[(int )ioim->reqq].kva) ? (struct bfi_ioim_req_s *)(ioim->bfa)->iocfc.req_cq_ba[(int )ioim->reqq].kva + (unsigned long )(ioim->bfa)->iocfc.req_cq_pi[(int )ioim->reqq] : (struct bfi_ioim_req_s *)0;
  if ((unsigned long )m == (unsigned long )((struct bfi_ioim_req_s *)0)) {
    (ioim->itnim)->stats.qwait = (ioim->itnim)->stats.qwait + 1U;
    waitq = (struct list_head *)(& (ioim->bfa)->reqq_waitq) + (unsigned long )ioim->reqq;
    __ret_warn_on = (unsigned int )ioim->reqq > 3U;
    tmp___0 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
    if (tmp___0 != 0L) {
      warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcpim.c",
                         2478);
    } else {

    }
    ldv__builtin_expect(__ret_warn_on != 0, 0L);
    __ret_warn_on___0 = (unsigned long )(ioim->iosp)->reqq_wait.qresume == (unsigned long )((void (*)(void * ))0) || (unsigned long )(ioim->iosp)->reqq_wait.cbarg == (unsigned long )((void *)0);
    tmp___1 = ldv__builtin_expect(__ret_warn_on___0 != 0, 0L);
    if (tmp___1 != 0L) {
      warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcpim.c",
                         2478);
    } else {

    }
    ldv__builtin_expect(__ret_warn_on___0 != 0, 0L);
    list_add_tail(& (ioim->iosp)->reqq_wait.qe, waitq);
    return (0);
  } else {

  }
  tmp___2 = __fswab16((int )ioim->iotag);
  m->io_tag = tmp___2;
  m->rport_hdl = ((ioim->itnim)->rport)->fw_handle;
  m->io_timeout = 0U;
  sge = (struct bfi_sge_s *)(& m->sges);
  sgpg = ioim->sgpg;
  sge_id = 0U;
  sgpge = (struct bfi_sge_s *)0;
  pgcumsz = 0U;
  i = 0U;
  sg = scsi_sglist(cmnd);
  goto ldv_49152;
  ldv_49151: ;
  if (i == 0U) {
    addr = sg->dma_address;
    sge->sga = *((union bfi_addr_u *)(& addr));
    pgdlen = sg->dma_length;
    sge->sg_len = pgdlen;
    sge->flags = (unsigned int )ioim->nsges > 1U ? 1U : 3U;
    tmp___3 = __fswab32(*((u32 *)sge));
    *((u32 *)sge) = tmp___3;
    tmp___4 = __fswab32(*((u32 *)sge + 1UL));
    *((u32 *)sge + 1UL) = tmp___4;
    tmp___5 = __fswab32(*((u32 *)sge + 2UL));
    *((u32 *)sge + 2UL) = tmp___5;
    sge = sge + 1;
  } else {
    if (sge_id == 0U) {
      sgpge = (struct bfi_sge_s *)(& (sgpg->sgpg)->sges);
    } else {

    }
    addr = sg->dma_address;
    sgpge->sga = *((union bfi_addr_u *)(& addr));
    sgpge->sg_len = sg->dma_length;
    pgcumsz = sgpge->sg_len + pgcumsz;
    if ((u32 )((int )ioim->nsges + -1) > i && sge_id <= 5U) {
      sgpge->flags = 0U;
    } else
    if ((u32 )((int )ioim->nsges + -1) > i) {
      sgpge->flags = 1U;
    } else {
      sgpge->flags = 3U;
    }
    sgpge = sgpge + 1;
    if ((u32 )((int )ioim->nsges + -1) == i) {
      sgpge->flags = 2U;
      sgpge->sga.a32.addr_lo = 0U;
      sgpge->sga.a32.addr_hi = 0U;
      sgpge->sg_len = pgcumsz;
    } else {
      sge_id = sge_id + 1U;
      if (sge_id == 7U) {
        sgpg = (struct bfa_sgpg_s *)((struct list_head *)sgpg)->next;
        sgpge->flags = 2U;
        sgpge->sga = sgpg->sgpg_pa;
        sgpge->sg_len = pgcumsz;
        sge_id = 0U;
        pgcumsz = 0U;
      } else {

      }
    }
  }
  i = i + 1U;
  sg = sg_next(sg);
  ldv_49152: ;
  if ((u32 )ioim->nsges > i) {
    goto ldv_49151;
  } else {

  }

  if ((unsigned int )ioim->nsges > 1U) {
    sge->sga = (ioim->sgpg)->sgpg_pa;
  } else {
    sge->sga.a32.addr_lo = 0U;
    sge->sga.a32.addr_hi = 0U;
  }
  sge->sg_len = pgdlen;
  sge->flags = 2U;
  tmp___6 = __fswab32(*((u32 *)sge));
  *((u32 *)sge) = tmp___6;
  tmp___7 = __fswab32(*((u32 *)sge + 1UL));
  *((u32 *)sge + 1UL) = tmp___7;
  tmp___8 = __fswab32(*((u32 *)sge + 2UL));
  *((u32 *)sge + 2UL) = tmp___8;
  m->cmnd = cmnd_z0;
  int_to_scsilun((cmnd->device)->lun, & m->cmnd.lun);
  dmadir = cmnd->sc_data_direction;
  if ((unsigned int )dmadir == 1U) {
    m->cmnd.iodir = 1U;
  } else
  if ((unsigned int )dmadir == 2U) {
    m->cmnd.iodir = 2U;
  } else {
    m->cmnd.iodir = 0U;
  }
  m->cmnd.cdb = *((struct scsi_cdb_s *)cmnd->cmnd);
  fcp_dl = scsi_bufflen(cmnd);
  tmp___9 = __fswab32(fcp_dl);
  m->cmnd.fcp_dl = tmp___9;
  switch ((int )m->cmnd.iodir) {
  case 2: 
  m->mh.msg_class = 13U;
  m->mh.msg_id = 0U;
  m->mh.mtag.h2i.fn_lpu = (u8 )((int )((signed char )((int )(ioim->bfa)->ioc.pcidev.pci_func << 1)) | (int )((signed char )(ioim->bfa)->ioc.port_id));
  itnim->stats.input_reqs = itnim->stats.input_reqs + 1U;
  (ioim->itnim)->stats.rd_throughput = (ioim->itnim)->stats.rd_throughput + fcp_dl;
  goto ldv_49155;
  case 1: 
  m->mh.msg_class = 14U;
  m->mh.msg_id = 0U;
  m->mh.mtag.h2i.fn_lpu = (u8 )((int )((signed char )((int )(ioim->bfa)->ioc.pcidev.pci_func << 1)) | (int )((signed char )(ioim->bfa)->ioc.port_id));
  itnim->stats.output_reqs = itnim->stats.output_reqs + 1U;
  (ioim->itnim)->stats.wr_throughput = (ioim->itnim)->stats.wr_throughput + fcp_dl;
  goto ldv_49155;
  case 3: 
  itnim->stats.input_reqs = itnim->stats.input_reqs + 1U;
  itnim->stats.output_reqs = itnim->stats.output_reqs + 1U;
  default: 
  m->mh.msg_class = 15U;
  m->mh.msg_id = 0U;
  m->mh.mtag.h2i.fn_lpu = (u8 )((int )((signed char )((int )(ioim->bfa)->ioc.pcidev.pci_func << 1)) | (int )((signed char )(ioim->bfa)->ioc.port_id));
  }
  ldv_49155: ;
  if ((unsigned int )itnim->seq_rec != 0U) {
    m->mh.msg_class = 15U;
    m->mh.msg_id = 0U;
    m->mh.mtag.h2i.fn_lpu = (u8 )((int )((signed char )((int )(ioim->bfa)->ioc.pcidev.pci_func << 1)) | (int )((signed char )(ioim->bfa)->ioc.port_id));
  } else {
    tmp___10 = scsi_bufflen(cmnd);
    if (((unsigned long )tmp___10 & 3UL) != 0UL) {
      m->mh.msg_class = 15U;
      m->mh.msg_id = 0U;
      m->mh.mtag.h2i.fn_lpu = (u8 )((int )((signed char )((int )(ioim->bfa)->ioc.pcidev.pci_func << 1)) | (int )((signed char )(ioim->bfa)->ioc.port_id));
    } else {

    }
  }
  m->mh.mtag.h2i.qid = (ioim->bfa)->iocfc.hw_qid[(int )ioim->reqq];
  (ioim->bfa)->iocfc.req_cq_pi[(int )ioim->reqq] = (ioim->bfa)->iocfc.req_cq_pi[(int )ioim->reqq] + 1U;
  (ioim->bfa)->iocfc.req_cq_pi[(int )ioim->reqq] = (ioim->bfa)->iocfc.req_cq_pi[(int )ioim->reqq] & (u32 )((int )(ioim->bfa)->iocfc.cfg.drvcfg.num_reqq_elems + -1);
  writel((ioim->bfa)->iocfc.req_cq_pi[(int )ioim->reqq], (void volatile   *)(ioim->bfa)->iocfc.bfa_regs.cpe_q_pi[(int )ioim->reqq]);
  __asm__  volatile   ("": : : "memory");
  return (1);
}
}
static enum bfa_boolean bfa_ioim_sgpg_alloc(struct bfa_ioim_s *ioim ) 
{ 
  u16 nsgpgs ;
  int __ret_warn_on ;
  long tmp ;
  enum bfa_status tmp___0 ;

  {
  __ret_warn_on = (unsigned int )ioim->nsges <= 1U;
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcpim.c",
                       2611);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  nsgpgs = (unsigned int )((u16 )((unsigned int )ioim->nsges / 7U)) + 1U;
  if ((unsigned int )nsgpgs == 0U) {
    return (1);
  } else {

  }
  tmp___0 = bfa_sgpg_malloc(ioim->bfa, & ioim->sgpg_q, (int )nsgpgs);
  if ((unsigned int )tmp___0 != 0U) {
    bfa_sgpg_wait(ioim->bfa, & (ioim->iosp)->sgpg_wqe, (int )nsgpgs);
    return (0);
  } else {

  }
  ioim->nsgpgs = nsgpgs;
  ioim->sgpg = (struct bfa_sgpg_s *)ioim->sgpg_q.next;
  return (1);
}
}
static enum bfa_boolean bfa_ioim_send_abort(struct bfa_ioim_s *ioim ) 
{ 
  struct bfi_ioim_abort_req_s *m ;
  enum bfi_ioim_h2i msgop ;
  __u16 tmp ;

  {
  m = (((ioim->bfa)->iocfc.req_cq_pi[(int )ioim->reqq] + 1U) & (u32 )((int )(ioim->bfa)->iocfc.cfg.drvcfg.num_reqq_elems + -1)) != *((u32 *)(ioim->bfa)->iocfc.req_cq_shadow_ci[(int )ioim->reqq].kva) ? (struct bfi_ioim_abort_req_s *)(ioim->bfa)->iocfc.req_cq_ba[(int )ioim->reqq].kva + (unsigned long )(ioim->bfa)->iocfc.req_cq_pi[(int )ioim->reqq] : (struct bfi_ioim_abort_req_s *)0;
  if ((unsigned long )m == (unsigned long )((struct bfi_ioim_abort_req_s *)0)) {
    return (0);
  } else {

  }
  if ((unsigned int )(ioim->iosp)->abort_explicit != 0U) {
    msgop = 1;
  } else {
    msgop = 2;
  }
  m->mh.msg_class = 16U;
  m->mh.msg_id = (u8 )msgop;
  m->mh.mtag.h2i.fn_lpu = (u8 )((int )((signed char )((int )(ioim->bfa)->ioc.pcidev.pci_func << 1)) | (int )((signed char )(ioim->bfa)->ioc.port_id));
  tmp = __fswab16((int )ioim->iotag);
  m->io_tag = tmp;
  ioim->abort_tag = (u16 )((int )ioim->abort_tag + 1);
  m->abort_tag = ioim->abort_tag;
  m->mh.mtag.h2i.qid = (ioim->bfa)->iocfc.hw_qid[(int )ioim->reqq];
  (ioim->bfa)->iocfc.req_cq_pi[(int )ioim->reqq] = (ioim->bfa)->iocfc.req_cq_pi[(int )ioim->reqq] + 1U;
  (ioim->bfa)->iocfc.req_cq_pi[(int )ioim->reqq] = (ioim->bfa)->iocfc.req_cq_pi[(int )ioim->reqq] & (u32 )((int )(ioim->bfa)->iocfc.cfg.drvcfg.num_reqq_elems + -1);
  writel((ioim->bfa)->iocfc.req_cq_pi[(int )ioim->reqq], (void volatile   *)(ioim->bfa)->iocfc.bfa_regs.cpe_q_pi[(int )ioim->reqq]);
  __asm__  volatile   ("": : : "memory");
  return (1);
}
}
static void bfa_ioim_qresume(void *cbarg ) 
{ 
  struct bfa_ioim_s *ioim ;

  {
  ioim = (struct bfa_ioim_s *)cbarg;
  (ioim->itnim)->stats.qresumes = (ioim->itnim)->stats.qresumes + 1U;
  (*(ioim->sm))((void *)ioim, 10);
  return;
}
}
static void bfa_ioim_notify_cleanup(struct bfa_ioim_s *ioim ) 
{ 


  {
  list_del(& ioim->qe);
  list_add_tail(& ioim->qe, & (ioim->fcpim)->ioim_comp_q);
  if ((unsigned long )(ioim->iosp)->tskim == (unsigned long )((struct bfa_tskim_s *)0)) {
    if ((ioim->fcpim)->delay_comp != 0U && (unsigned int )(ioim->itnim)->iotov_active != 0U) {
      list_del(& ioim->hcb_qe.qe);
      list_del(& ioim->qe);
      list_add_tail(& ioim->qe, & (ioim->itnim)->delay_comp_q);
    } else {

    }
    bfa_itnim_iodone(ioim->itnim);
  } else {
    bfa_wc_down(& ((ioim->iosp)->tskim)->wc);
  }
  return;
}
}
static enum bfa_boolean bfa_ioim_is_abortable(struct bfa_ioim_s *ioim ) 
{ 
  int tmp ;

  {
  if ((unsigned long )ioim->sm == (unsigned long )((void (*)(void * , int  ))(& bfa_ioim_sm_uninit))) {
    tmp = bfa_q_is_on_q_func(& (ioim->itnim)->pending_q, (struct list_head *)ioim);
    if (tmp == 0) {
      return (0);
    } else {
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
  if ((unsigned long )ioim->sm == (unsigned long )((void (*)(void * , int  ))(& bfa_ioim_sm_abort))) {
    return (0);
  } else
  if ((unsigned long )ioim->sm == (unsigned long )((void (*)(void * , int  ))(& bfa_ioim_sm_abort_qfull))) {
    return (0);
  } else
  if ((unsigned long )ioim->sm == (unsigned long )((void (*)(void * , int  ))(& bfa_ioim_sm_hcb))) {
    return (0);
  } else
  if ((unsigned long )ioim->sm == (unsigned long )((void (*)(void * , int  ))(& bfa_ioim_sm_hcb_free))) {
    return (0);
  } else
  if ((unsigned long )ioim->sm == (unsigned long )((void (*)(void * , int  ))(& bfa_ioim_sm_resfree))) {
    return (0);
  } else {

  }
  return (1);
}
}
void bfa_ioim_delayed_comp(struct bfa_ioim_s *ioim , enum bfa_boolean iotov ) 
{ 


  {
  if ((unsigned int )iotov != 0U) {
    ioim->io_cbfn = & __bfa_cb_ioim_pathtov;
  } else {
    ioim->io_cbfn = & __bfa_cb_ioim_failed;
    (ioim->itnim)->stats.iocom_nexus_abort = (ioim->itnim)->stats.iocom_nexus_abort + 1U;
  }
  ioim->hcb_qe.cbfn = ioim->io_cbfn;
  ioim->hcb_qe.cbarg = (void *)ioim;
  ioim->hcb_qe.pre_rmv = 0;
  list_add_tail(& ioim->hcb_qe.qe, & (ioim->bfa)->comp_q);
  list_del(& ioim->qe);
  list_add_tail(& ioim->qe, & (ioim->fcpim)->ioim_comp_q);
  return;
}
}
void bfa_ioim_attach(struct bfa_fcpim_s *fcpim ) 
{ 
  struct bfa_ioim_s *ioim ;
  struct bfa_fcp_mod_s *fcp ;
  struct bfa_ioim_sp_s *iosp ;
  u16 i ;

  {
  fcp = fcpim->fcp;
  ioim = (struct bfa_ioim_s *)fcp->kva_seg.kva_curp;
  fcpim->ioim_arr = ioim;
  fcp->kva_seg.kva_curp = (u8 *)ioim + (unsigned long )(fcpim->fcp)->num_ioim_reqs;
  iosp = (struct bfa_ioim_sp_s *)fcp->kva_seg.kva_curp;
  fcpim->ioim_sp_arr = iosp;
  fcp->kva_seg.kva_curp = (u8 *)iosp + (unsigned long )(fcpim->fcp)->num_ioim_reqs;
  INIT_LIST_HEAD(& fcpim->ioim_resfree_q);
  INIT_LIST_HEAD(& fcpim->ioim_comp_q);
  i = 0U;
  goto ldv_49192;
  ldv_49191: 
  memset((void *)ioim, 0, 168UL);
  ioim->iotag = i;
  ioim->bfa = fcpim->bfa;
  ioim->fcpim = fcpim;
  ioim->iosp = iosp;
  INIT_LIST_HEAD(& ioim->sgpg_q);
  bfa_reqq_winit(& (ioim->iosp)->reqq_wait, & bfa_ioim_qresume, (void *)ioim);
  bfa_sgpg_winit(& (ioim->iosp)->sgpg_wqe, & bfa_ioim_sgpg_alloced, (void *)ioim);
  ioim->sm = (void (*)(void * , int  ))(& bfa_ioim_sm_uninit);
  i = (u16 )((int )i + 1);
  ioim = ioim + 1;
  iosp = iosp + 1;
  ldv_49192: ;
  if ((int )i < (fcpim->fcp)->num_ioim_reqs) {
    goto ldv_49191;
  } else {

  }

  return;
}
}
void bfa_ioim_isr(struct bfa_s *bfa , struct bfi_msg_s *m ) 
{ 
  struct bfa_fcpim_s *fcpim ;
  struct bfi_ioim_rsp_s *rsp ;
  struct bfa_ioim_s *ioim ;
  u16 iotag ;
  enum bfa_ioim_event evt ;
  __u16 tmp ;
  int __ret_warn_on ;
  long tmp___0 ;
  int __ret_warn_on___0 ;
  long tmp___1 ;
  int __ret_warn_on___1 ;
  long tmp___2 ;
  int __ret_warn_on___2 ;
  long tmp___3 ;

  {
  fcpim = & bfa->modules.fcp_mod.fcpim;
  rsp = (struct bfi_ioim_rsp_s *)m;
  evt = 3;
  tmp = __fswab16((int )rsp->io_tag);
  iotag = tmp;
  ioim = fcpim->ioim_arr + ((unsigned long )iotag & 2047UL);
  __ret_warn_on = (int )ioim->iotag != (int )iotag;
  tmp___0 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp___0 != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcpim.c",
                       2802);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  __bfa_trc((ioim->bfa)->trcmod, __trc_fileno___11, 2804, (unsigned long long )ioim->iotag);
  __bfa_trc((ioim->bfa)->trcmod, __trc_fileno___11, 2805, (unsigned long long )rsp->io_status);
  __bfa_trc((ioim->bfa)->trcmod, __trc_fileno___11, 2806, (unsigned long long )rsp->reuse_io_tag);
  if ((unsigned long )ioim->sm == (unsigned long )((void (*)(void * , int  ))(& bfa_ioim_sm_active))) {
    (ioim->iosp)->comp_rspmsg = *m;
  } else {

  }
  switch ((int )rsp->io_status) {
  case 0: 
  (ioim->itnim)->stats.iocomp_ok = (ioim->itnim)->stats.iocomp_ok + 1U;
  if ((unsigned int )rsp->reuse_io_tag == 0U) {
    evt = 5;
  } else {
    evt = 3;
  }
  goto ldv_49206;
  case 3: 
  (ioim->itnim)->stats.iocomp_timedout = (ioim->itnim)->stats.iocomp_timedout + 1U;
  case 2: 
  rsp->io_status = 2U;
  (ioim->itnim)->stats.iocomp_aborted = (ioim->itnim)->stats.iocomp_aborted + 1U;
  if ((unsigned int )rsp->reuse_io_tag == 0U) {
    evt = 5;
  } else {
    evt = 3;
  }
  goto ldv_49206;
  case 6: 
  (ioim->itnim)->stats.iocom_proto_err = (ioim->itnim)->stats.iocom_proto_err + 1U;
  __ret_warn_on___0 = (unsigned int )rsp->reuse_io_tag == 0U;
  tmp___1 = ldv__builtin_expect(__ret_warn_on___0 != 0, 0L);
  if (tmp___1 != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcpim.c",
                       2833);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on___0 != 0, 0L);
  evt = 3;
  goto ldv_49206;
  case 5: 
  (ioim->itnim)->stats.iocom_sqer_needed = (ioim->itnim)->stats.iocom_sqer_needed + 1U;
  __ret_warn_on___1 = (unsigned int )rsp->reuse_io_tag != 0U;
  tmp___2 = ldv__builtin_expect(__ret_warn_on___1 != 0, 0L);
  if (tmp___2 != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcpim.c",
                       2839);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on___1 != 0, 0L);
  evt = 12;
  goto ldv_49206;
  case 4: 
  (ioim->itnim)->stats.iocom_res_free = (ioim->itnim)->stats.iocom_res_free + 1U;
  evt = 6;
  goto ldv_49206;
  case 1: 
  (ioim->itnim)->stats.iocom_hostabrts = (ioim->itnim)->stats.iocom_hostabrts + 1U;
  if ((int )rsp->abort_tag != (int )ioim->abort_tag) {
    __bfa_trc((ioim->bfa)->trcmod, __trc_fileno___11, 2851, (unsigned long long )rsp->abort_tag);
    __bfa_trc((ioim->bfa)->trcmod, __trc_fileno___11, 2852, (unsigned long long )ioim->abort_tag);
    return;
  } else {

  }
  if ((unsigned int )rsp->reuse_io_tag != 0U) {
    evt = 8;
  } else {
    evt = 9;
  }
  goto ldv_49206;
  case 7: 
  (ioim->itnim)->stats.iocom_utags = (ioim->itnim)->stats.iocom_utags + 1U;
  evt = 4;
  goto ldv_49206;
  default: 
  __ret_warn_on___2 = 1;
  tmp___3 = ldv__builtin_expect(__ret_warn_on___2 != 0, 0L);
  if (tmp___3 != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcpim.c",
                       2868);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on___2 != 0, 0L);
  }
  ldv_49206: 
  (*(ioim->sm))((void *)ioim, (int )evt);
  return;
}
}
void bfa_ioim_good_comp_isr(struct bfa_s *bfa , struct bfi_msg_s *m ) 
{ 
  struct bfa_fcpim_s *fcpim ;
  struct bfi_ioim_rsp_s *rsp ;
  struct bfa_ioim_s *ioim ;
  u16 iotag ;
  __u16 tmp ;
  int __ret_warn_on ;
  long tmp___0 ;

  {
  fcpim = & bfa->modules.fcp_mod.fcpim;
  rsp = (struct bfi_ioim_rsp_s *)m;
  tmp = __fswab16((int )rsp->io_tag);
  iotag = tmp;
  ioim = fcpim->ioim_arr + ((unsigned long )iotag & 2047UL);
  __ret_warn_on = (int )ioim->iotag != (int )iotag;
  tmp___0 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp___0 != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcpim.c",
                       2885);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if ((unsigned long )fcpim->profile_comp != (unsigned long )((void (*)(struct bfa_ioim_s * ))0)) {
    (*(fcpim->profile_comp))(ioim);
  } else {

  }
  (*(ioim->sm))((void *)ioim, 2);
  return;
}
}
void bfa_ioim_cleanup(struct bfa_ioim_s *ioim ) 
{ 


  {
  __bfa_trc((ioim->bfa)->trcmod, __trc_fileno___11, 2898, (unsigned long long )ioim->iotag);
  (ioim->itnim)->stats.io_cleanups = (ioim->itnim)->stats.io_cleanups + 1U;
  (ioim->iosp)->tskim = (struct bfa_tskim_s *)0;
  (*(ioim->sm))((void *)ioim, 14);
  return;
}
}
void bfa_ioim_cleanup_tm(struct bfa_ioim_s *ioim , struct bfa_tskim_s *tskim ) 
{ 


  {
  __bfa_trc((ioim->bfa)->trcmod, __trc_fileno___11, 2908, (unsigned long long )ioim->iotag);
  (ioim->itnim)->stats.io_tmaborts = (ioim->itnim)->stats.io_tmaborts + 1U;
  (ioim->iosp)->tskim = tskim;
  (*(ioim->sm))((void *)ioim, 14);
  return;
}
}
void bfa_ioim_iocdisable(struct bfa_ioim_s *ioim ) 
{ 


  {
  __bfa_trc((ioim->bfa)->trcmod, __trc_fileno___11, 2921, (unsigned long long )ioim->iotag);
  (ioim->itnim)->stats.io_iocdowns = (ioim->itnim)->stats.io_iocdowns + 1U;
  (*(ioim->sm))((void *)ioim, 17);
  return;
}
}
void bfa_ioim_tov(struct bfa_ioim_s *ioim ) 
{ 


  {
  __bfa_trc((ioim->bfa)->trcmod, __trc_fileno___11, 2932, (unsigned long long )ioim->iotag);
  (*(ioim->sm))((void *)ioim, 18);
  return;
}
}
struct bfa_ioim_s *bfa_ioim_alloc(struct bfa_s *bfa , struct bfad_ioim_s *dio , struct bfa_itnim_s *itnim ,
                                  u16 nsges ) 
{ 
  struct bfa_fcpim_s *fcpim ;
  struct bfa_ioim_s *ioim ;
  struct bfa_iotag_s *iotag ;
  int tmp ;

  {
  fcpim = & bfa->modules.fcp_mod.fcpim;
  iotag = (struct bfa_iotag_s *)0;
  tmp = list_empty((struct list_head  const  *)(& (fcpim->fcp)->iotag_ioim_free_q));
  if (tmp == 0) {
    *((struct list_head **)(& iotag)) = (fcpim->fcp)->iotag_ioim_free_q.next;
    ((*((struct list_head **)(& iotag)))->next)->prev = & (fcpim->fcp)->iotag_ioim_free_q;
    (fcpim->fcp)->iotag_ioim_free_q.next = (*((struct list_head **)(& iotag)))->next;
  } else {
    *((struct list_head **)(& iotag)) = (struct list_head *)0;
  }
  if ((unsigned long )iotag == (unsigned long )((struct bfa_iotag_s *)0)) {
    itnim->stats.no_iotags = itnim->stats.no_iotags + 1U;
    return ((struct bfa_ioim_s *)0);
  } else {

  }
  ioim = fcpim->ioim_arr + ((unsigned long )iotag->tag & 2047UL);
  ioim->dio = dio;
  ioim->itnim = itnim;
  ioim->nsges = nsges;
  ioim->nsgpgs = 0U;
  itnim->stats.total_ios = itnim->stats.total_ios + 1U;
  fcpim->ios_active = fcpim->ios_active + 1U;
  list_add_tail(& ioim->qe, & itnim->io_q);
  return (ioim);
}
}
void bfa_ioim_free(struct bfa_ioim_s *ioim ) 
{ 
  struct bfa_fcpim_s *fcpim ;
  struct bfa_iotag_s *iotag ;
  int __ret_warn_on ;
  long tmp ;

  {
  fcpim = ioim->fcpim;
  if ((unsigned int )ioim->nsgpgs != 0U) {
    bfa_sgpg_mfree(ioim->bfa, & ioim->sgpg_q, (int )ioim->nsgpgs);
  } else {

  }
  (ioim->itnim)->stats.io_comps = (ioim->itnim)->stats.io_comps + 1U;
  fcpim->ios_active = fcpim->ios_active - 1U;
  ioim->iotag = (unsigned int )ioim->iotag & 2047U;
  __ret_warn_on = (int )ioim->iotag >= (fcpim->fcp)->num_ioim_reqs + (fcpim->fcp)->num_fwtio_reqs;
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcpim.c",
                       2987);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  iotag = (fcpim->fcp)->iotag_arr + ((unsigned long )ioim->iotag & 2047UL);
  if ((int )ioim->iotag < (fcpim->fcp)->num_ioim_reqs) {
    list_add_tail(& iotag->qe, & (fcpim->fcp)->iotag_ioim_free_q);
  } else {
    list_add_tail(& iotag->qe, & (fcpim->fcp)->iotag_tio_free_q);
  }
  list_del(& ioim->qe);
  return;
}
}
void bfa_ioim_start(struct bfa_ioim_s *ioim ) 
{ 


  {
  if ((unsigned long )(ioim->fcpim)->profile_start != (unsigned long )((void (*)(struct bfa_ioim_s * ))0)) {
    (*((ioim->fcpim)->profile_start))(ioim);
  } else {

  }
  ioim->reqq = (unsigned int )(ioim->bfa)->modules.fcp_mod.fcpim.ioredirect == 0U ? (ioim->itnim)->reqq : 0U;
  (*(ioim->sm))((void *)ioim, 1);
  return;
}
}
enum bfa_status bfa_ioim_abort(struct bfa_ioim_s *ioim ) 
{ 
  enum bfa_boolean tmp ;

  {
  __bfa_trc((ioim->bfa)->trcmod, __trc_fileno___11, 3019, (unsigned long long )ioim->iotag);
  tmp = bfa_ioim_is_abortable(ioim);
  if ((unsigned int )tmp == 0U) {
    return (1);
  } else {

  }
  (ioim->itnim)->stats.io_aborts = (ioim->itnim)->stats.io_aborts + 1U;
  (*(ioim->sm))((void *)ioim, 7);
  return (0);
}
}
static void bfa_tskim_sm_uninit(struct bfa_tskim_s *tskim , enum bfa_tskim_event event ) 
{ 
  struct list_head *waitq ;
  int __ret_warn_on ;
  long tmp ;
  int __ret_warn_on___0 ;
  long tmp___0 ;
  enum bfa_boolean tmp___1 ;

  {
  __bfa_trc((tskim->bfa)->trcmod, __trc_fileno___11, 3040, ((unsigned long long )tskim->tsk_tag << 16) | (unsigned long long )event);
  switch ((unsigned int )event) {
  case 1U: 
  tskim->sm = (void (*)(void * , int  ))(& bfa_tskim_sm_active);
  bfa_tskim_gather_ios(tskim);
  if ((unsigned int )(tskim->itnim)->is_online == 0U) {
    tskim->sm = (void (*)(void * , int  ))(& bfa_tskim_sm_iocleanup);
    tskim->tsk_status = 0;
    bfa_tskim_cleanup_ios(tskim);
    return;
  } else {

  }
  tmp___1 = bfa_tskim_send(tskim);
  if ((unsigned int )tmp___1 == 0U) {
    tskim->sm = (void (*)(void * , int  ))(& bfa_tskim_sm_qfull);
    (tskim->itnim)->stats.tm_qwait = (tskim->itnim)->stats.tm_qwait + 1U;
    waitq = (struct list_head *)(& (tskim->bfa)->reqq_waitq) + (unsigned long )(tskim->itnim)->reqq;
    __ret_warn_on = (unsigned int )(tskim->itnim)->reqq > 3U;
    tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
    if (tmp != 0L) {
      warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcpim.c",
                         3062);
    } else {

    }
    ldv__builtin_expect(__ret_warn_on != 0, 0L);
    __ret_warn_on___0 = (unsigned long )tskim->reqq_wait.qresume == (unsigned long )((void (*)(void * ))0) || (unsigned long )tskim->reqq_wait.cbarg == (unsigned long )((void *)0);
    tmp___0 = ldv__builtin_expect(__ret_warn_on___0 != 0, 0L);
    if (tmp___0 != 0L) {
      warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcpim.c",
                         3062);
    } else {

    }
    ldv__builtin_expect(__ret_warn_on___0 != 0, 0L);
    list_add_tail(& tskim->reqq_wait.qe, waitq);
  } else {

  }
  goto ldv_49276;
  default: 
  __bfa_trc((tskim->bfa)->trcmod, __trc_fileno___11, 3067, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcpim.c",
         3067, (unsigned int )event);
  }
  ldv_49276: ;
  return;
}
}
static void bfa_tskim_sm_active(struct bfa_tskim_s *tskim , enum bfa_tskim_event event ) 
{ 
  struct list_head *waitq ;
  int __ret_warn_on ;
  long tmp ;
  int __ret_warn_on___0 ;
  long tmp___0 ;
  enum bfa_boolean tmp___1 ;

  {
  __bfa_trc((tskim->bfa)->trcmod, __trc_fileno___11, 3078, ((unsigned long long )tskim->tsk_tag << 16) | (unsigned long long )event);
  switch ((unsigned int )event) {
  case 2U: 
  tskim->sm = (void (*)(void * , int  ))(& bfa_tskim_sm_iocleanup);
  bfa_tskim_cleanup_ios(tskim);
  goto ldv_49283;
  case 8U: 
  tskim->sm = (void (*)(void * , int  ))(& bfa_tskim_sm_cleanup);
  tmp___1 = bfa_tskim_send_abort(tskim);
  if ((unsigned int )tmp___1 == 0U) {
    tskim->sm = (void (*)(void * , int  ))(& bfa_tskim_sm_cleanup_qfull);
    (tskim->itnim)->stats.tm_qwait = (tskim->itnim)->stats.tm_qwait + 1U;
    waitq = (struct list_head *)(& (tskim->bfa)->reqq_waitq) + (unsigned long )(tskim->itnim)->reqq;
    __ret_warn_on = (unsigned int )(tskim->itnim)->reqq > 3U;
    tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
    if (tmp != 0L) {
      warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcpim.c",
                         3092);
    } else {

    }
    ldv__builtin_expect(__ret_warn_on != 0, 0L);
    __ret_warn_on___0 = (unsigned long )tskim->reqq_wait.qresume == (unsigned long )((void (*)(void * ))0) || (unsigned long )tskim->reqq_wait.cbarg == (unsigned long )((void *)0);
    tmp___0 = ldv__builtin_expect(__ret_warn_on___0 != 0, 0L);
    if (tmp___0 != 0L) {
      warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcpim.c",
                         3092);
    } else {

    }
    ldv__builtin_expect(__ret_warn_on___0 != 0, 0L);
    list_add_tail(& tskim->reqq_wait.qe, waitq);
  } else {

  }
  goto ldv_49283;
  case 5U: 
  tskim->sm = (void (*)(void * , int  ))(& bfa_tskim_sm_hcb);
  bfa_tskim_iocdisable_ios(tskim);
  tskim->hcb_qe.cbfn = & __bfa_cb_tskim_failed;
  tskim->hcb_qe.cbarg = (void *)tskim;
  tskim->hcb_qe.pre_rmv = 0;
  list_add_tail(& tskim->hcb_qe.qe, & (tskim->bfa)->comp_q);
  if ((unsigned int )tskim->notify != 0U) {
    bfa_itnim_tskdone(tskim->itnim);
  } else {

  }
  goto ldv_49283;
  default: 
  __bfa_trc((tskim->bfa)->trcmod, __trc_fileno___11, 3103, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcpim.c",
         3103, (unsigned int )event);
  }
  ldv_49283: ;
  return;
}
}
static void bfa_tskim_sm_cleanup(struct bfa_tskim_s *tskim , enum bfa_tskim_event event ) 
{ 


  {
  __bfa_trc((tskim->bfa)->trcmod, __trc_fileno___11, 3114, ((unsigned long long )tskim->tsk_tag << 16) | (unsigned long long )event);
  switch ((unsigned int )event) {
  case 2U: ;
  goto ldv_49297;
  case 10U: ;
  case 9U: 
  tskim->sm = (void (*)(void * , int  ))(& bfa_tskim_sm_iocleanup);
  bfa_tskim_cleanup_ios(tskim);
  goto ldv_49297;
  case 5U: 
  tskim->sm = (void (*)(void * , int  ))(& bfa_tskim_sm_hcb);
  bfa_tskim_iocdisable_ios(tskim);
  tskim->hcb_qe.cbfn = & __bfa_cb_tskim_failed;
  tskim->hcb_qe.cbarg = (void *)tskim;
  tskim->hcb_qe.pre_rmv = 0;
  list_add_tail(& tskim->hcb_qe.qe, & (tskim->bfa)->comp_q);
  if ((unsigned int )tskim->notify != 0U) {
    bfa_itnim_tskdone(tskim->itnim);
  } else {

  }
  goto ldv_49297;
  default: 
  __bfa_trc((tskim->bfa)->trcmod, __trc_fileno___11, 3136, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcpim.c",
         3136, (unsigned int )event);
  }
  ldv_49297: ;
  return;
}
}
static void bfa_tskim_sm_iocleanup(struct bfa_tskim_s *tskim , enum bfa_tskim_event event ) 
{ 


  {
  __bfa_trc((tskim->bfa)->trcmod, __trc_fileno___11, 3143, ((unsigned long long )tskim->tsk_tag << 16) | (unsigned long long )event);
  switch ((unsigned int )event) {
  case 7U: 
  tskim->sm = (void (*)(void * , int  ))(& bfa_tskim_sm_hcb);
  tskim->hcb_qe.cbfn = & __bfa_cb_tskim_done;
  tskim->hcb_qe.cbarg = (void *)tskim;
  tskim->hcb_qe.pre_rmv = 0;
  list_add_tail(& tskim->hcb_qe.qe, & (tskim->bfa)->comp_q);
  if ((unsigned int )tskim->notify != 0U) {
    bfa_itnim_tskdone(tskim->itnim);
  } else {

  }
  goto ldv_49307;
  case 8U: ;
  goto ldv_49307;
  case 5U: 
  tskim->sm = (void (*)(void * , int  ))(& bfa_tskim_sm_hcb);
  bfa_tskim_iocdisable_ios(tskim);
  tskim->hcb_qe.cbfn = & __bfa_cb_tskim_failed;
  tskim->hcb_qe.cbarg = (void *)tskim;
  tskim->hcb_qe.pre_rmv = 0;
  list_add_tail(& tskim->hcb_qe.qe, & (tskim->bfa)->comp_q);
  if ((unsigned int )tskim->notify != 0U) {
    bfa_itnim_tskdone(tskim->itnim);
  } else {

  }
  goto ldv_49307;
  default: 
  __bfa_trc((tskim->bfa)->trcmod, __trc_fileno___11, 3165, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcpim.c",
         3165, (unsigned int )event);
  }
  ldv_49307: ;
  return;
}
}
static void bfa_tskim_sm_qfull(struct bfa_tskim_s *tskim , enum bfa_tskim_event event ) 
{ 


  {
  __bfa_trc((tskim->bfa)->trcmod, __trc_fileno___11, 3175, ((unsigned long long )tskim->tsk_tag << 16) | (unsigned long long )event);
  switch ((unsigned int )event) {
  case 3U: 
  tskim->sm = (void (*)(void * , int  ))(& bfa_tskim_sm_active);
  bfa_tskim_send(tskim);
  goto ldv_49316;
  case 8U: 
  tskim->sm = (void (*)(void * , int  ))(& bfa_tskim_sm_iocleanup);
  list_del(& tskim->reqq_wait.qe);
  bfa_tskim_cleanup_ios(tskim);
  goto ldv_49316;
  case 5U: 
  tskim->sm = (void (*)(void * , int  ))(& bfa_tskim_sm_hcb);
  list_del(& tskim->reqq_wait.qe);
  bfa_tskim_iocdisable_ios(tskim);
  tskim->hcb_qe.cbfn = & __bfa_cb_tskim_failed;
  tskim->hcb_qe.cbarg = (void *)tskim;
  tskim->hcb_qe.pre_rmv = 0;
  list_add_tail(& tskim->hcb_qe.qe, & (tskim->bfa)->comp_q);
  if ((unsigned int )tskim->notify != 0U) {
    bfa_itnim_tskdone(tskim->itnim);
  } else {

  }
  goto ldv_49316;
  default: 
  __bfa_trc((tskim->bfa)->trcmod, __trc_fileno___11, 3200, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcpim.c",
         3200, (unsigned int )event);
  }
  ldv_49316: ;
  return;
}
}
static void bfa_tskim_sm_cleanup_qfull(struct bfa_tskim_s *tskim , enum bfa_tskim_event event ) 
{ 


  {
  __bfa_trc((tskim->bfa)->trcmod, __trc_fileno___11, 3212, ((unsigned long long )tskim->tsk_tag << 16) | (unsigned long long )event);
  switch ((unsigned int )event) {
  case 2U: 
  list_del(& tskim->reqq_wait.qe);
  case 3U: 
  tskim->sm = (void (*)(void * , int  ))(& bfa_tskim_sm_cleanup);
  bfa_tskim_send_abort(tskim);
  goto ldv_49326;
  case 5U: 
  tskim->sm = (void (*)(void * , int  ))(& bfa_tskim_sm_hcb);
  list_del(& tskim->reqq_wait.qe);
  bfa_tskim_iocdisable_ios(tskim);
  tskim->hcb_qe.cbfn = & __bfa_cb_tskim_failed;
  tskim->hcb_qe.cbarg = (void *)tskim;
  tskim->hcb_qe.pre_rmv = 0;
  list_add_tail(& tskim->hcb_qe.qe, & (tskim->bfa)->comp_q);
  if ((unsigned int )tskim->notify != 0U) {
    bfa_itnim_tskdone(tskim->itnim);
  } else {

  }
  goto ldv_49326;
  default: 
  __bfa_trc((tskim->bfa)->trcmod, __trc_fileno___11, 3233, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcpim.c",
         3233, (unsigned int )event);
  }
  ldv_49326: ;
  return;
}
}
static void bfa_tskim_sm_hcb(struct bfa_tskim_s *tskim , enum bfa_tskim_event event ) 
{ 


  {
  __bfa_trc((tskim->bfa)->trcmod, __trc_fileno___11, 3243, ((unsigned long long )tskim->tsk_tag << 16) | (unsigned long long )event);
  switch ((unsigned int )event) {
  case 6U: 
  tskim->sm = (void (*)(void * , int  ))(& bfa_tskim_sm_uninit);
  bfa_tskim_free(tskim);
  goto ldv_49334;
  case 8U: ;
  if ((unsigned int )tskim->notify != 0U) {
    bfa_itnim_tskdone(tskim->itnim);
  } else {

  }
  goto ldv_49334;
  case 5U: ;
  goto ldv_49334;
  default: 
  __bfa_trc((tskim->bfa)->trcmod, __trc_fileno___11, 3259, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcpim.c",
         3259, (unsigned int )event);
  }
  ldv_49334: ;
  return;
}
}
static void __bfa_cb_tskim_done(void *cbarg , enum bfa_boolean complete___0 ) 
{ 
  struct bfa_tskim_s *tskim ;

  {
  tskim = (struct bfa_tskim_s *)cbarg;
  if ((unsigned int )complete___0 == 0U) {
    (*(tskim->sm))((void *)tskim, 6);
    return;
  } else {

  }
  (tskim->itnim)->stats.tm_success = (tskim->itnim)->stats.tm_success + 1U;
  bfa_cb_tskim_done((tskim->bfa)->bfad, tskim->dtsk, tskim->tsk_status);
  return;
}
}
static void __bfa_cb_tskim_failed(void *cbarg , enum bfa_boolean complete___0 ) 
{ 
  struct bfa_tskim_s *tskim ;

  {
  tskim = (struct bfa_tskim_s *)cbarg;
  if ((unsigned int )complete___0 == 0U) {
    (*(tskim->sm))((void *)tskim, 6);
    return;
  } else {

  }
  (tskim->itnim)->stats.tm_failures = (tskim->itnim)->stats.tm_failures + 1U;
  bfa_cb_tskim_done((tskim->bfa)->bfad, tskim->dtsk, 5);
  return;
}
}
static enum bfa_boolean bfa_tskim_match_scope(struct bfa_tskim_s *tskim , struct scsi_lun lun ) 
{ 
  int tmp ;
  int __ret_warn_on ;
  long tmp___0 ;

  {
  switch ((unsigned int )tskim->tm_cmnd) {
  case 32U: ;
  return (1);
  case 2U: ;
  case 4U: ;
  case 16U: ;
  case 64U: 
  tmp = memcmp((void const   *)(& tskim->lun), (void const   *)(& lun), 8UL);
  return (tmp == 0);
  default: 
  __ret_warn_on = 1;
  tmp___0 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp___0 != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcpim.c",
                       3306);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  }
  return (0);
}
}
static void bfa_tskim_gather_ios(struct bfa_tskim_s *tskim ) 
{ 
  struct bfa_itnim_s *itnim ;
  struct bfa_ioim_s *ioim ;
  struct list_head *qe ;
  struct list_head *qen ;
  struct scsi_cmnd *cmnd ;
  struct scsi_lun scsilun ;
  enum bfa_boolean tmp ;
  enum bfa_boolean tmp___0 ;

  {
  itnim = tskim->itnim;
  INIT_LIST_HEAD(& tskim->io_q);
  qe = itnim->io_q.next;
  qen = qe->next;
  goto ldv_49370;
  ldv_49369: 
  ioim = (struct bfa_ioim_s *)qe;
  cmnd = (struct scsi_cmnd *)ioim->dio;
  int_to_scsilun((cmnd->device)->lun, & scsilun);
  tmp = bfa_tskim_match_scope(tskim, scsilun);
  if ((unsigned int )tmp != 0U) {
    list_del(& ioim->qe);
    list_add_tail(& ioim->qe, & tskim->io_q);
  } else {

  }
  qe = qen;
  qen = qe->next;
  ldv_49370: ;
  if ((unsigned long )(& itnim->io_q) != (unsigned long )qe) {
    goto ldv_49369;
  } else {

  }
  qe = itnim->pending_q.next;
  qen = qe->next;
  goto ldv_49373;
  ldv_49372: 
  ioim = (struct bfa_ioim_s *)qe;
  cmnd = (struct scsi_cmnd *)ioim->dio;
  int_to_scsilun((cmnd->device)->lun, & scsilun);
  tmp___0 = bfa_tskim_match_scope(tskim, scsilun);
  if ((unsigned int )tmp___0 != 0U) {
    list_del(& ioim->qe);
    list_add_tail(& ioim->qe, & (ioim->fcpim)->ioim_comp_q);
    bfa_ioim_tov(ioim);
  } else {

  }
  qe = qen;
  qen = qe->next;
  ldv_49373: ;
  if ((unsigned long )(& itnim->pending_q) != (unsigned long )qe) {
    goto ldv_49372;
  } else {

  }

  return;
}
}
static void bfa_tskim_cleanp_comp(void *tskim_cbarg ) 
{ 
  struct bfa_tskim_s *tskim ;

  {
  tskim = (struct bfa_tskim_s *)tskim_cbarg;
  (tskim->itnim)->stats.tm_io_comps = (tskim->itnim)->stats.tm_io_comps + 1U;
  (*(tskim->sm))((void *)tskim, 7);
  return;
}
}
static void bfa_tskim_cleanup_ios(struct bfa_tskim_s *tskim ) 
{ 
  struct bfa_ioim_s *ioim ;
  struct list_head *qe ;
  struct list_head *qen ;

  {
  bfa_wc_init(& tskim->wc, & bfa_tskim_cleanp_comp, (void *)tskim);
  qe = tskim->io_q.next;
  qen = qe->next;
  goto ldv_49386;
  ldv_49385: 
  ioim = (struct bfa_ioim_s *)qe;
  bfa_wc_up(& tskim->wc);
  bfa_ioim_cleanup_tm(ioim, tskim);
  qe = qen;
  qen = qe->next;
  ldv_49386: ;
  if ((unsigned long )(& tskim->io_q) != (unsigned long )qe) {
    goto ldv_49385;
  } else {

  }
  bfa_wc_wait(& tskim->wc);
  return;
}
}
static enum bfa_boolean bfa_tskim_send(struct bfa_tskim_s *tskim ) 
{ 
  struct bfa_itnim_s *itnim ;
  struct bfi_tskim_req_s *m ;
  __u16 tmp ;

  {
  itnim = tskim->itnim;
  m = (((tskim->bfa)->iocfc.req_cq_pi[(int )itnim->reqq] + 1U) & (u32 )((int )(tskim->bfa)->iocfc.cfg.drvcfg.num_reqq_elems + -1)) != *((u32 *)(tskim->bfa)->iocfc.req_cq_shadow_ci[(int )itnim->reqq].kva) ? (struct bfi_tskim_req_s *)(tskim->bfa)->iocfc.req_cq_ba[(int )itnim->reqq].kva + (unsigned long )(tskim->bfa)->iocfc.req_cq_pi[(int )itnim->reqq] : (struct bfi_tskim_req_s *)0;
  if ((unsigned long )m == (unsigned long )((struct bfi_tskim_req_s *)0)) {
    return (0);
  } else {

  }
  m->mh.msg_class = 18U;
  m->mh.msg_id = 1U;
  m->mh.mtag.h2i.fn_lpu = (u8 )((int )((signed char )((int )(tskim->bfa)->ioc.pcidev.pci_func << 1)) | (int )((signed char )(tskim->bfa)->ioc.port_id));
  tmp = __fswab16((int )tskim->tsk_tag);
  m->tsk_tag = tmp;
  m->itn_fhdl = ((tskim->itnim)->rport)->fw_handle;
  m->t_secs = tskim->tsecs;
  m->lun = tskim->lun;
  m->tm_flags = (u8 )tskim->tm_cmnd;
  m->mh.mtag.h2i.qid = (tskim->bfa)->iocfc.hw_qid[(int )itnim->reqq];
  (tskim->bfa)->iocfc.req_cq_pi[(int )itnim->reqq] = (tskim->bfa)->iocfc.req_cq_pi[(int )itnim->reqq] + 1U;
  (tskim->bfa)->iocfc.req_cq_pi[(int )itnim->reqq] = (tskim->bfa)->iocfc.req_cq_pi[(int )itnim->reqq] & (u32 )((int )(tskim->bfa)->iocfc.cfg.drvcfg.num_reqq_elems + -1);
  writel((tskim->bfa)->iocfc.req_cq_pi[(int )itnim->reqq], (void volatile   *)(tskim->bfa)->iocfc.bfa_regs.cpe_q_pi[(int )itnim->reqq]);
  __asm__  volatile   ("": : : "memory");
  return (1);
}
}
static enum bfa_boolean bfa_tskim_send_abort(struct bfa_tskim_s *tskim ) 
{ 
  struct bfa_itnim_s *itnim ;
  struct bfi_tskim_abortreq_s *m ;
  __u16 tmp ;

  {
  itnim = tskim->itnim;
  m = (((tskim->bfa)->iocfc.req_cq_pi[(int )itnim->reqq] + 1U) & (u32 )((int )(tskim->bfa)->iocfc.cfg.drvcfg.num_reqq_elems + -1)) != *((u32 *)(tskim->bfa)->iocfc.req_cq_shadow_ci[(int )itnim->reqq].kva) ? (struct bfi_tskim_abortreq_s *)(tskim->bfa)->iocfc.req_cq_ba[(int )itnim->reqq].kva + (unsigned long )(tskim->bfa)->iocfc.req_cq_pi[(int )itnim->reqq] : (struct bfi_tskim_abortreq_s *)0;
  if ((unsigned long )m == (unsigned long )((struct bfi_tskim_abortreq_s *)0)) {
    return (0);
  } else {

  }
  m->mh.msg_class = 18U;
  m->mh.msg_id = 2U;
  m->mh.mtag.h2i.fn_lpu = (u8 )((int )((signed char )((int )(tskim->bfa)->ioc.pcidev.pci_func << 1)) | (int )((signed char )(tskim->bfa)->ioc.port_id));
  tmp = __fswab16((int )tskim->tsk_tag);
  m->tsk_tag = tmp;
  m->mh.mtag.h2i.qid = (tskim->bfa)->iocfc.hw_qid[(int )itnim->reqq];
  (tskim->bfa)->iocfc.req_cq_pi[(int )itnim->reqq] = (tskim->bfa)->iocfc.req_cq_pi[(int )itnim->reqq] + 1U;
  (tskim->bfa)->iocfc.req_cq_pi[(int )itnim->reqq] = (tskim->bfa)->iocfc.req_cq_pi[(int )itnim->reqq] & (u32 )((int )(tskim->bfa)->iocfc.cfg.drvcfg.num_reqq_elems + -1);
  writel((tskim->bfa)->iocfc.req_cq_pi[(int )itnim->reqq], (void volatile   *)(tskim->bfa)->iocfc.bfa_regs.cpe_q_pi[(int )itnim->reqq]);
  __asm__  volatile   ("": : : "memory");
  return (1);
}
}
static void bfa_tskim_qresume(void *cbarg ) 
{ 
  struct bfa_tskim_s *tskim ;

  {
  tskim = (struct bfa_tskim_s *)cbarg;
  (tskim->itnim)->stats.tm_qresumes = (tskim->itnim)->stats.tm_qresumes + 1U;
  (*(tskim->sm))((void *)tskim, 3);
  return;
}
}
static void bfa_tskim_iocdisable_ios(struct bfa_tskim_s *tskim ) 
{ 
  struct bfa_ioim_s *ioim ;
  struct list_head *qe ;
  struct list_head *qen ;

  {
  qe = tskim->io_q.next;
  qen = qe->next;
  goto ldv_49409;
  ldv_49408: 
  ioim = (struct bfa_ioim_s *)qe;
  bfa_ioim_iocdisable(ioim);
  qe = qen;
  qen = qe->next;
  ldv_49409: ;
  if ((unsigned long )(& tskim->io_q) != (unsigned long )qe) {
    goto ldv_49408;
  } else {

  }

  return;
}
}
void bfa_tskim_iodone(struct bfa_tskim_s *tskim ) 
{ 


  {
  bfa_wc_down(& tskim->wc);
  return;
}
}
void bfa_tskim_iocdisable(struct bfa_tskim_s *tskim ) 
{ 


  {
  tskim->notify = 0;
  (tskim->itnim)->stats.tm_iocdowns = (tskim->itnim)->stats.tm_iocdowns + 1U;
  (*(tskim->sm))((void *)tskim, 5);
  return;
}
}
void bfa_tskim_cleanup(struct bfa_tskim_s *tskim ) 
{ 


  {
  tskim->notify = 1;
  (tskim->itnim)->stats.tm_cleanups = (tskim->itnim)->stats.tm_cleanups + 1U;
  (*(tskim->sm))((void *)tskim, 8);
  return;
}
}
void bfa_tskim_attach(struct bfa_fcpim_s *fcpim ) 
{ 
  struct bfa_tskim_s *tskim ;
  struct bfa_fcp_mod_s *fcp ;
  u16 i ;

  {
  fcp = fcpim->fcp;
  INIT_LIST_HEAD(& fcpim->tskim_free_q);
  INIT_LIST_HEAD(& fcpim->tskim_unused_q);
  tskim = (struct bfa_tskim_s *)fcp->kva_seg.kva_curp;
  fcpim->tskim_arr = tskim;
  i = 0U;
  goto ldv_49427;
  ldv_49426: 
  memset((void *)tskim, 0, 208UL);
  tskim->tsk_tag = i;
  tskim->bfa = fcpim->bfa;
  tskim->fcpim = fcpim;
  tskim->notify = 0;
  bfa_reqq_winit(& tskim->reqq_wait, & bfa_tskim_qresume, (void *)tskim);
  tskim->sm = (void (*)(void * , int  ))(& bfa_tskim_sm_uninit);
  list_add_tail(& tskim->qe, & fcpim->tskim_free_q);
  i = (u16 )((int )i + 1);
  tskim = tskim + 1;
  ldv_49427: ;
  if ((int )i < fcpim->num_tskim_reqs) {
    goto ldv_49426;
  } else {

  }
  fcp->kva_seg.kva_curp = (u8 *)tskim;
  return;
}
}
void bfa_tskim_isr(struct bfa_s *bfa , struct bfi_msg_s *m ) 
{ 
  struct bfa_fcpim_s *fcpim ;
  struct bfi_tskim_rsp_s *rsp ;
  struct bfa_tskim_s *tskim ;
  u16 tsk_tag ;
  __u16 tmp ;
  int __ret_warn_on ;
  long tmp___0 ;

  {
  fcpim = & bfa->modules.fcp_mod.fcpim;
  rsp = (struct bfi_tskim_rsp_s *)m;
  tmp = __fswab16((int )rsp->tsk_tag);
  tsk_tag = tmp;
  tskim = fcpim->tskim_arr + (unsigned long )((int )tsk_tag & (fcpim->num_tskim_reqs + -1));
  __ret_warn_on = (int )tskim->tsk_tag != (int )tsk_tag;
  tmp___0 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp___0 != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcpim.c",
                       3554);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  tskim->tsk_status = (enum bfi_tskim_status )rsp->tsk_status;
  if ((unsigned int )rsp->tsk_status == 11U) {
    (tskim->itnim)->stats.tm_cleanup_comps = (tskim->itnim)->stats.tm_cleanup_comps + 1U;
    (*(tskim->sm))((void *)tskim, 9);
  } else
  if ((unsigned int )rsp->tsk_status == 12U) {
    (*(tskim->sm))((void *)tskim, 10);
  } else {
    (tskim->itnim)->stats.tm_fw_rsps = (tskim->itnim)->stats.tm_fw_rsps + 1U;
    (*(tskim->sm))((void *)tskim, 2);
  }
  return;
}
}
struct bfa_tskim_s *bfa_tskim_alloc(struct bfa_s *bfa , struct bfad_tskim_s *dtsk ) 
{ 
  struct bfa_fcpim_s *fcpim ;
  struct bfa_tskim_s *tskim ;
  int tmp ;

  {
  fcpim = & bfa->modules.fcp_mod.fcpim;
  tmp = list_empty((struct list_head  const  *)(& fcpim->tskim_free_q));
  if (tmp == 0) {
    *((struct list_head **)(& tskim)) = fcpim->tskim_free_q.next;
    ((*((struct list_head **)(& tskim)))->next)->prev = & fcpim->tskim_free_q;
    fcpim->tskim_free_q.next = (*((struct list_head **)(& tskim)))->next;
  } else {
    *((struct list_head **)(& tskim)) = (struct list_head *)0;
  }
  if ((unsigned long )tskim != (unsigned long )((struct bfa_tskim_s *)0)) {
    tskim->dtsk = dtsk;
  } else {

  }
  return (tskim);
}
}
void bfa_tskim_free(struct bfa_tskim_s *tskim ) 
{ 
  int __ret_warn_on ;
  int tmp ;
  long tmp___0 ;

  {
  tmp = bfa_q_is_on_q_func(& (tskim->itnim)->tsk_q, & tskim->qe);
  __ret_warn_on = tmp == 0;
  tmp___0 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp___0 != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcpim.c",
                       3591);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  list_del(& tskim->qe);
  list_add_tail(& tskim->qe, & (tskim->fcpim)->tskim_free_q);
  return;
}
}
void bfa_tskim_start(struct bfa_tskim_s *tskim , struct bfa_itnim_s *itnim , struct scsi_lun lun ,
                     enum fcp_tm_cmnd tm_cmnd , u8 tsecs ) 
{ 


  {
  tskim->itnim = itnim;
  tskim->lun = lun;
  tskim->tm_cmnd = tm_cmnd;
  tskim->tsecs = tsecs;
  tskim->notify = 0;
  itnim->stats.tm_cmnds = itnim->stats.tm_cmnds + 1U;
  list_add_tail(& tskim->qe, & itnim->tsk_q);
  (*(tskim->sm))((void *)tskim, 1);
  return;
}
}
void bfa_tskim_res_recfg(struct bfa_s *bfa , u16 num_tskim_fw ) 
{ 
  struct bfa_fcpim_s *fcpim ;
  struct list_head *qe ;
  int i ;
  int tmp ;

  {
  fcpim = & bfa->modules.fcp_mod.fcpim;
  i = 0;
  goto ldv_49465;
  ldv_49464: 
  tmp = list_empty((struct list_head  const  *)(& fcpim->tskim_free_q));
  if (tmp == 0) {
    qe = fcpim->tskim_free_q.prev;
    (qe->prev)->next = & fcpim->tskim_free_q;
    fcpim->tskim_free_q.prev = qe->prev;
  } else {
    qe = (struct list_head *)0;
  }
  list_add_tail(qe, & fcpim->tskim_unused_q);
  i = i + 1;
  ldv_49465: ;
  if (fcpim->num_tskim_reqs - (int )num_tskim_fw > i) {
    goto ldv_49464;
  } else {

  }

  return;
}
}
static void bfa_fcp_meminfo(struct bfa_iocfc_cfg_s *cfg , struct bfa_meminfo_s *minfo ,
                            struct bfa_s *bfa ) ;
static void bfa_fcp_attach(struct bfa_s *bfa , void *bfad , struct bfa_iocfc_cfg_s *cfg ,
                           struct bfa_pcidev_s *pcidev ) ;
static void bfa_fcp_detach(struct bfa_s *bfa ) ;
static void bfa_fcp_start(struct bfa_s *bfa ) ;
static void bfa_fcp_stop(struct bfa_s *bfa ) ;
static void bfa_fcp_iocdisable(struct bfa_s *bfa ) ;
struct bfa_module_s hal_mod_fcp  =    {& bfa_fcp_meminfo, & bfa_fcp_attach, & bfa_fcp_detach, & bfa_fcp_start, & bfa_fcp_stop,
    & bfa_fcp_iocdisable};
static void bfa_fcp_meminfo(struct bfa_iocfc_cfg_s *cfg , struct bfa_meminfo_s *minfo ,
                            struct bfa_s *bfa ) 
{ 
  struct bfa_fcp_mod_s *fcp ;
  struct bfa_mem_kva_s *fcp_kva ;
  struct bfa_mem_dma_s *seg_ptr ;
  u16 nsegs ;
  u16 idx ;
  u16 per_seg_ios ;
  u16 num_io_req ;
  u32 km_len ;

  {
  fcp = & bfa->modules.fcp_mod;
  fcp_kva = & bfa->modules.fcp_mod.kva_seg;
  km_len = 0U;
  if ((unsigned int )cfg->fwcfg.num_ioim_reqs != 0U && (unsigned int )cfg->fwcfg.num_ioim_reqs <= 7U) {
    cfg->fwcfg.num_ioim_reqs = 8U;
  } else
  if ((unsigned int )cfg->fwcfg.num_ioim_reqs > 2000U) {
    cfg->fwcfg.num_ioim_reqs = 2000U;
  } else {

  }
  if ((unsigned int )cfg->fwcfg.num_fwtio_reqs > 2000U) {
    cfg->fwcfg.num_fwtio_reqs = 2000U;
  } else {

  }
  num_io_req = (int )cfg->fwcfg.num_ioim_reqs + (int )cfg->fwcfg.num_fwtio_reqs;
  if ((unsigned int )num_io_req > 2000U) {
    if ((unsigned int )cfg->fwcfg.num_ioim_reqs != 0U && (unsigned int )cfg->fwcfg.num_fwtio_reqs != 0U) {
      cfg->fwcfg.num_ioim_reqs = 1000U;
      cfg->fwcfg.num_fwtio_reqs = 1000U;
    } else
    if ((unsigned int )cfg->fwcfg.num_fwtio_reqs != 0U) {
      cfg->fwcfg.num_fwtio_reqs = 2000U;
    } else {
      cfg->fwcfg.num_ioim_reqs = 2000U;
    }
  } else {

  }
  bfa_fcpim_meminfo(cfg, & km_len);
  num_io_req = (int )cfg->fwcfg.num_ioim_reqs + (int )cfg->fwcfg.num_fwtio_reqs;
  km_len = (u32 )num_io_req * 24U + km_len;
  km_len = (u32 )cfg->fwcfg.num_rports * 8U + km_len;
  nsegs = (unsigned short )((((int )num_io_req + 512) * 256 + -1) >> 17);
  per_seg_ios = 512U;
  idx = 0U;
  seg_ptr = (struct bfa_mem_dma_s *)(& fcp->dma_seg) + (unsigned long )idx;
  goto ldv_49500;
  ldv_49499: ;
  if ((int )num_io_req >= (int )per_seg_ios) {
    num_io_req = (int )num_io_req - (int )per_seg_ios;
    seg_ptr->mem_len = (u32 )((int )per_seg_ios * 256);
    if ((int )per_seg_ios * 256 != 0) {
      list_add_tail(& seg_ptr->qe, & minfo->dma_info.qe);
    } else {

    }
  } else {
    seg_ptr->mem_len = (u32 )((int )num_io_req * 256);
    if ((int )num_io_req * 256 != 0) {
      list_add_tail(& seg_ptr->qe, & minfo->dma_info.qe);
    } else {

    }
  }
  idx = (u16 )((int )idx + 1);
  seg_ptr = (struct bfa_mem_dma_s *)(& fcp->dma_seg) + (unsigned long )idx;
  ldv_49500: ;
  if ((int )idx < (int )nsegs) {
    goto ldv_49499;
  } else {

  }
  fcp_kva->mem_len = km_len;
  if (km_len != 0U) {
    list_add_tail(& fcp_kva->qe, & minfo->kva_info.qe);
  } else {

  }
  return;
}
}
static void bfa_fcp_attach(struct bfa_s *bfa , void *bfad , struct bfa_iocfc_cfg_s *cfg ,
                           struct bfa_pcidev_s *pcidev ) 
{ 
  struct bfa_fcp_mod_s *fcp ;
  struct bfa_mem_dma_s *seg_ptr ;
  u16 idx ;
  u16 nsegs ;
  u16 num_io_req ;

  {
  fcp = & bfa->modules.fcp_mod;
  fcp->max_ioim_reqs = (int )cfg->fwcfg.num_ioim_reqs;
  fcp->num_ioim_reqs = (int )cfg->fwcfg.num_ioim_reqs;
  fcp->num_fwtio_reqs = (int )cfg->fwcfg.num_fwtio_reqs;
  fcp->num_itns = (int )cfg->fwcfg.num_rports;
  fcp->bfa = bfa;
  num_io_req = (int )cfg->fwcfg.num_ioim_reqs + (int )cfg->fwcfg.num_fwtio_reqs;
  nsegs = (unsigned short )((((int )num_io_req + 512) * 256 + -1) >> 17);
  idx = 0U;
  seg_ptr = (struct bfa_mem_dma_s *)(& fcp->dma_seg) + (unsigned long )idx;
  goto ldv_49515;
  ldv_49514: ;
  if ((unsigned long )seg_ptr->kva_curp == (unsigned long )((u8 *)0U)) {
    goto ldv_49513;
  } else {

  }
  fcp->snsbase[(int )idx].pa = seg_ptr->dma_curp;
  fcp->snsbase[(int )idx].kva = (void *)seg_ptr->kva_curp;
  bfa_iocfc_set_snsbase(bfa, (int )idx, fcp->snsbase[(int )idx].pa);
  idx = (u16 )((int )idx + 1);
  seg_ptr = (struct bfa_mem_dma_s *)(& fcp->dma_seg) + (unsigned long )idx;
  ldv_49515: ;
  if ((int )idx < (int )nsegs) {
    goto ldv_49514;
  } else {

  }
  ldv_49513: 
  fcp->throttle_update_required = 1;
  bfa_fcpim_attach(fcp, bfad, cfg, pcidev);
  bfa_iotag_attach(fcp);
  fcp->itn_arr = (struct bfa_itn_s *)fcp->kva_seg.kva_curp;
  fcp->kva_seg.kva_curp = (u8 *)fcp->itn_arr + (unsigned long )fcp->num_itns * 8UL;
  memset((void *)fcp->itn_arr, 0, (unsigned long )fcp->num_itns * 8UL);
  return;
}
}
static void bfa_fcp_detach(struct bfa_s *bfa ) 
{ 


  {
  return;
}
}
static void bfa_fcp_start(struct bfa_s *bfa ) 
{ 
  struct bfa_fcp_mod_s *fcp ;

  {
  fcp = & bfa->modules.fcp_mod;
  bfa_ioim_lm_init(fcp->bfa);
  return;
}
}
static void bfa_fcp_stop(struct bfa_s *bfa ) 
{ 


  {
  return;
}
}
static void bfa_fcp_iocdisable(struct bfa_s *bfa ) 
{ 
  struct bfa_fcp_mod_s *fcp ;

  {
  fcp = & bfa->modules.fcp_mod;
  bfa_fcpim_iocdisable(fcp);
  return;
}
}
void bfa_fcp_res_recfg(struct bfa_s *bfa , u16 num_ioim_fw , u16 max_ioim_fw ) 
{ 
  struct bfa_fcp_mod_s *mod ;
  struct list_head *qe ;
  int i ;
  int tmp ;

  {
  mod = & bfa->modules.fcp_mod;
  if (mod->throttle_update_required == 0) {
    return;
  } else {

  }
  i = 0;
  goto ldv_49539;
  ldv_49538: 
  tmp = list_empty((struct list_head  const  *)(& mod->iotag_ioim_free_q));
  if (tmp == 0) {
    qe = mod->iotag_ioim_free_q.prev;
    (qe->prev)->next = & mod->iotag_ioim_free_q;
    mod->iotag_ioim_free_q.prev = qe->prev;
  } else {
    qe = (struct list_head *)0;
  }
  list_add_tail(qe, & mod->iotag_unused_q);
  i = i + 1;
  ldv_49539: ;
  if (mod->num_ioim_reqs - (int )num_ioim_fw > i) {
    goto ldv_49538;
  } else {

  }

  if (mod->num_ioim_reqs != (int )num_ioim_fw) {
    __bfa_trc(bfa->trcmod, __trc_fileno___11, 3788, (unsigned long long )mod->num_ioim_reqs);
    __bfa_trc(bfa->trcmod, __trc_fileno___11, 3789, (unsigned long long )num_ioim_fw);
  } else {

  }
  mod->max_ioim_reqs = (int )max_ioim_fw;
  mod->num_ioim_reqs = (int )num_ioim_fw;
  mod->throttle_update_required = 0;
  return;
}
}
void bfa_itn_create(struct bfa_s *bfa , struct bfa_rport_s *rport , void (*isr)(struct bfa_s * ,
                                                                                struct bfi_msg_s * ) ) 
{ 
  struct bfa_fcp_mod_s *fcp ;
  struct bfa_itn_s *itn ;

  {
  fcp = & bfa->modules.fcp_mod;
  itn = fcp->itn_arr + (unsigned long )((int )rport->rport_tag & (fcp->num_itns + -1));
  itn->isr = isr;
  return;
}
}
void bfa_itn_isr(struct bfa_s *bfa , struct bfi_msg_s *m ) 
{ 
  struct bfa_fcp_mod_s *fcp ;
  union bfi_itn_i2h_msg_u msg ;
  struct bfa_itn_s *itn ;
  int __ret_warn_on ;
  long tmp ;

  {
  fcp = & bfa->modules.fcp_mod;
  msg.msg = m;
  itn = fcp->itn_arr + (unsigned long )((int )(msg.create_rsp)->bfa_handle & (fcp->num_itns + -1));
  if ((unsigned long )itn->isr != (unsigned long )((void (*)(struct bfa_s * , struct bfi_msg_s * ))0)) {
    (*(itn->isr))(bfa, m);
  } else {
    __ret_warn_on = 1;
    tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
    if (tmp != 0L) {
      warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_fcpim.c",
                         3824);
    } else {

    }
    ldv__builtin_expect(__ret_warn_on != 0, 0L);
  }
  return;
}
}
void bfa_iotag_attach(struct bfa_fcp_mod_s *fcp ) 
{ 
  struct bfa_iotag_s *iotag ;
  u16 num_io_req ;
  u16 i ;

  {
  iotag = (struct bfa_iotag_s *)fcp->kva_seg.kva_curp;
  fcp->iotag_arr = iotag;
  INIT_LIST_HEAD(& fcp->iotag_ioim_free_q);
  INIT_LIST_HEAD(& fcp->iotag_tio_free_q);
  INIT_LIST_HEAD(& fcp->iotag_unused_q);
  num_io_req = (int )((u16 )fcp->num_ioim_reqs) + (int )((u16 )fcp->num_fwtio_reqs);
  i = 0U;
  goto ldv_49566;
  ldv_49565: 
  memset((void *)iotag, 0, 24UL);
  iotag->tag = i;
  if ((int )i < fcp->num_ioim_reqs) {
    list_add_tail(& iotag->qe, & fcp->iotag_ioim_free_q);
  } else {
    list_add_tail(& iotag->qe, & fcp->iotag_tio_free_q);
  }
  i = (u16 )((int )i + 1);
  iotag = iotag + 1;
  ldv_49566: ;
  if ((int )i < (int )num_io_req) {
    goto ldv_49565;
  } else {

  }
  fcp->kva_seg.kva_curp = (u8 *)iotag;
  return;
}
}
u16 bfa_fcpim_get_throttle_cfg(struct bfa_s *bfa , u16 drv_cfg_param ) 
{ 
  u16 tmp ;
  struct bfa_fcp_mod_s *fcp ;
  u16 tmp___0 ;

  {
  fcp = & bfa->modules.fcp_mod;
  if (fcp->throttle_update_required == 0) {
    return ((u16 )fcp->num_ioim_reqs);
  } else {

  }
  if ((unsigned int )bfa->modules.dconf_mod.read_data_valid != 0U) {
    tmp___0 = bfa_fcpim_read_throttle(bfa);
    tmp = tmp___0;
  } else {
    tmp = 0U;
  }
  if ((unsigned int )tmp == 0U || (int )tmp > (int )drv_cfg_param) {
    tmp = drv_cfg_param;
  } else {

  }
  return (tmp);
}
}
enum bfa_status bfa_fcpim_write_throttle(struct bfa_s *bfa , u16 value ) 
{ 


  {
  if ((unsigned int )bfa->modules.dconf_mod.min_cfg == 0U) {
    (bfa->modules.dconf_mod.dconf)->throttle_cfg.value = value;
    (bfa->modules.dconf_mod.dconf)->throttle_cfg.is_valid = 1U;
    return (0);
  } else {

  }
  return (1);
}
}
u16 bfa_fcpim_read_throttle(struct bfa_s *bfa ) 
{ 
  struct bfa_throttle_cfg_s *throttle_cfg ;

  {
  throttle_cfg = & (bfa->modules.dconf_mod.dconf)->throttle_cfg;
  return ((unsigned int )bfa->modules.dconf_mod.min_cfg == 0U ? ((unsigned int )throttle_cfg->is_valid == 1U ? throttle_cfg->value : 0U) : 0U);
}
}
enum bfa_status bfa_fcpim_throttle_set(struct bfa_s *bfa , u16 value ) 
{ 
  enum bfa_status tmp ;

  {
  if ((unsigned int )bfa->modules.dconf_mod.min_cfg == 1U || (unsigned int )bfa->modules.dconf_mod.read_data_valid == 0U) {
    return (1);
  } else {

  }
  bfa_fcpim_write_throttle(bfa, (int )value);
  tmp = bfa_dconf_update(bfa);
  return (tmp);
}
}
enum bfa_status bfa_fcpim_throttle_get(struct bfa_s *bfa , void *buf ) 
{ 
  struct bfa_fcpim_s *fcpim ;
  struct bfa_defs_fcpim_throttle_s throttle ;

  {
  fcpim = & bfa->modules.fcp_mod.fcpim;
  if ((unsigned int )bfa->modules.dconf_mod.min_cfg == 1U || (unsigned int )bfa->modules.dconf_mod.read_data_valid == 0U) {
    return (1);
  } else {

  }
  memset((void *)(& throttle), 0, 8UL);
  throttle.cur_value = (unsigned short )(fcpim->fcp)->num_ioim_reqs;
  throttle.cfg_value = bfa_fcpim_read_throttle(bfa);
  if ((unsigned int )throttle.cfg_value == 0U) {
    throttle.cfg_value = throttle.cur_value;
  } else {

  }
  throttle.max_value = (unsigned short )(fcpim->fcp)->max_ioim_reqs;
  memcpy(buf, (void const   *)(& throttle), 8UL);
  return (0);
}
}
void ldv_initialize_bfa_module_s_14(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
  tmp = ldv_init_zalloc(56UL);
  hal_mod_fcp_group0 = (struct bfa_iocfc_cfg_s *)tmp;
  tmp___0 = ldv_init_zalloc(9688UL);
  hal_mod_fcp_group1 = (struct bfa_s *)tmp___0;
  return;
}
}
void ldv_main_exported_14(void) 
{ 
  void *ldvarg50 ;
  void *tmp ;
  struct bfa_pcidev_s *ldvarg49 ;
  void *tmp___0 ;
  struct bfa_meminfo_s *ldvarg51 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
  tmp = ldv_init_zalloc(1UL);
  ldvarg50 = tmp;
  tmp___0 = ldv_init_zalloc(24UL);
  ldvarg49 = (struct bfa_pcidev_s *)tmp___0;
  tmp___1 = ldv_init_zalloc(96UL);
  ldvarg51 = (struct bfa_meminfo_s *)tmp___1;
  tmp___2 = __VERIFIER_nondet_int();
  switch (tmp___2) {
  case 0: ;
  if (ldv_state_variable_14 == 1) {
    bfa_fcp_start(hal_mod_fcp_group1);
    ldv_state_variable_14 = 1;
  } else {

  }
  goto ldv_49602;
  case 1: ;
  if (ldv_state_variable_14 == 1) {
    bfa_fcp_iocdisable(hal_mod_fcp_group1);
    ldv_state_variable_14 = 1;
  } else {

  }
  goto ldv_49602;
  case 2: ;
  if (ldv_state_variable_14 == 1) {
    bfa_fcp_meminfo(hal_mod_fcp_group0, ldvarg51, hal_mod_fcp_group1);
    ldv_state_variable_14 = 1;
  } else {

  }
  goto ldv_49602;
  case 3: ;
  if (ldv_state_variable_14 == 1) {
    bfa_fcp_stop(hal_mod_fcp_group1);
    ldv_state_variable_14 = 1;
  } else {

  }
  goto ldv_49602;
  case 4: ;
  if (ldv_state_variable_14 == 1) {
    bfa_fcp_attach(hal_mod_fcp_group1, ldvarg50, hal_mod_fcp_group0, ldvarg49);
    ldv_state_variable_14 = 1;
  } else {

  }
  goto ldv_49602;
  case 5: ;
  if (ldv_state_variable_14 == 1) {
    bfa_fcp_detach(hal_mod_fcp_group1);
    ldv_state_variable_14 = 1;
  } else {

  }
  goto ldv_49602;
  default: 
  ldv_stop();
  }
  ldv_49602: ;
  return;
}
}
bool ldv_queue_work_on_567(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_3(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_delayed_work_on_568(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_3(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_work_on_569(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_3(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
void ldv_flush_workqueue_570(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
  flush_workqueue(ldv_func_arg1);
  call_and_disable_all_3(2);
  return;
}
}
bool ldv_queue_delayed_work_on_571(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_3(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
void ldv_mutex_lock_572(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_lock_lock(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_573(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_unlock_lock(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_574(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
int ldv_mutex_trylock_575(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
  tmp = mutex_trylock(ldv_func_arg1);
  ldv_func_res = tmp;
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
  return (tmp___0);
  return (ldv_func_res);
}
}
void ldv_mutex_unlock_576(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_577(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_unlock_i_mutex_of_inode(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_578(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_lock_i_mutex_of_inode(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
int ldv_scsi_add_host_with_dma_579(struct Scsi_Host *shost , struct device *dev ,
                                   struct device *dma_dev ) 
{ 
  ldv_func_ret_type___4 ldv_func_res ;
  int tmp ;

  {
  tmp = scsi_add_host_with_dma(shost, dev, dma_dev);
  ldv_func_res = tmp;
  if (ldv_func_res == 0) {
    ldv_state_variable_35 = 1;
    ldv_initialize_scsi_host_template_35();
  } else {

  }
  return (ldv_func_res);
}
}
__inline static long ldv__builtin_expect(long exp , long c ) ;
int ldv_mutex_trylock_605(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_603(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_606(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_607(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_602(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_604(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_608(struct mutex *ldv_func_arg1 ) ;
bool ldv_queue_work_on_597(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_work_on_599(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_delayed_work_on_598(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
bool ldv_queue_delayed_work_on_601(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
void ldv_flush_workqueue_600(struct workqueue_struct *ldv_func_arg1 ) ;
int ldv_scsi_add_host_with_dma_609(struct Scsi_Host *shost , struct device *dev ,
                                   struct device *dma_dev ) ;
void bfa_isr_unhandled(struct bfa_s *bfa , struct bfi_msg_s *m ) ;
void bfa_iocfc_meminfo(struct bfa_iocfc_cfg_s *cfg , struct bfa_meminfo_s *meminfo ,
                       struct bfa_s *bfa ) ;
void bfa_iocfc_attach(struct bfa_s *bfa , void *bfad , struct bfa_iocfc_cfg_s *cfg ,
                      struct bfa_pcidev_s *pcidev ) ;
void bfa_iocfc_isr(void *bfaarg , struct bfi_mbmsg_s *m ) ;
enum bfa_boolean bfa_iocfc_is_operational(struct bfa_s *bfa ) ;
void bfa_iocfc_reset_queues(struct bfa_s *bfa ) ;
void bfa_get_pciids(struct bfa_pciid_s **pciids , int *npciids ) ;
void bfa_cfg_get_min(struct bfa_iocfc_cfg_s *cfg ) ;
void bfa_isr_enable(struct bfa_s *bfa ) ;
void bfa_fcxp_isr(struct bfa_s *bfa , struct bfi_msg_s *msg ) ;
void bfa_rport_isr(struct bfa_s *bfa , struct bfi_msg_s *m ) ;
void bfa_rport_res_recfg(struct bfa_s *bfa , u16 num_rport_fw ) ;
void bfa_uf_isr(struct bfa_s *bfa , struct bfi_msg_s *msg ) ;
void bfa_uf_res_recfg(struct bfa_s *bfa , u16 num_uf_fw ) ;
void bfa_lps_isr(struct bfa_s *bfa , struct bfi_msg_s *m ) ;
void bfa_fcport_init(struct bfa_s *bfa ) ;
void bfa_fcport_isr(struct bfa_s *bfa , struct bfi_msg_s *msg ) ;
void bfa_fcport_beacon(void *dev , enum bfa_boolean beacon , enum bfa_boolean link_e2e_beacon ) ;
void bfa_fcxp_res_recfg(struct bfa_s *bfa , u16 num_fcxp_fw ) ;
void bfa_fcdiag_intr(struct bfa_s *bfa , struct bfi_msg_s *msg ) ;
struct bfa_module_s hal_mod_fcdiag ;
struct bfa_module_s hal_mod_sgpg ;
struct bfa_module_s hal_mod_fcport ;
struct bfa_module_s hal_mod_fcxp ;
struct bfa_module_s hal_mod_lps ;
struct bfa_module_s hal_mod_uf ;
struct bfa_module_s hal_mod_rport ;
static int __trc_fileno___12  =    1025;
static struct bfa_module_s *hal_mods[10U]  = 
  {      & hal_mod_fcdiag,      & hal_mod_sgpg,      & hal_mod_fcport,      & hal_mod_fcxp, 
        & hal_mod_lps,      & hal_mod_uf,      & hal_mod_rport,      & hal_mod_fcp, 
        & hal_mod_dconf,      (struct bfa_module_s *)0};
static bfa_isr_func_t bfa_isrs[35U]  = 
  {      & bfa_isr_unhandled,      & bfa_isr_unhandled,      & bfa_fcdiag_intr,      & bfa_isr_unhandled, 
        & bfa_isr_unhandled,      & bfa_fcport_isr,      & bfa_isr_unhandled,      & bfa_isr_unhandled, 
        & bfa_uf_isr,      & bfa_fcxp_isr,      & bfa_lps_isr,      & bfa_rport_isr, 
        & bfa_itn_isr,      & bfa_isr_unhandled,      & bfa_isr_unhandled,      & bfa_isr_unhandled, 
        & bfa_ioim_isr,      & bfa_ioim_good_comp_isr,      & bfa_tskim_isr,      & bfa_isr_unhandled, 
        & bfa_isr_unhandled,      & bfa_isr_unhandled,      & bfa_isr_unhandled,      & bfa_isr_unhandled, 
        & bfa_isr_unhandled,      & bfa_isr_unhandled,      & bfa_isr_unhandled,      & bfa_isr_unhandled, 
        & bfa_isr_unhandled,      & bfa_isr_unhandled,      & bfa_isr_unhandled,      & bfa_isr_unhandled};
static bfa_ioc_mbox_mcfunc_t bfa_mbox_isrs[35U]  = 
  {      (void (*)(void * , struct bfi_mbmsg_s * ))0,      (void (*)(void * , struct bfi_mbmsg_s * ))0,      (void (*)(void * , struct bfi_mbmsg_s * ))0,      (void (*)(void * , struct bfi_mbmsg_s * ))0, 
        (void (*)(void * , struct bfi_mbmsg_s * ))0,      (void (*)(void * , struct bfi_mbmsg_s * ))0,      & bfa_iocfc_isr,      (void (*)(void * , struct bfi_mbmsg_s * ))0};
static void bfa_com_port_attach(struct bfa_s *bfa ) 
{ 
  struct bfa_port_s *port ;
  struct bfa_mem_dma_s *port_dma ;

  {
  port = & bfa->modules.port;
  port_dma = & bfa->modules.port.port_dma;
  bfa_port_attach(port, & bfa->ioc, (void *)bfa, bfa->trcmod);
  bfa_port_mem_claim(port, port_dma->kva_curp, port_dma->dma_curp);
  return;
}
}
static void bfa_com_ablk_attach(struct bfa_s *bfa ) 
{ 
  struct bfa_ablk_s *ablk ;
  struct bfa_mem_dma_s *ablk_dma ;

  {
  ablk = & bfa->modules.ablk;
  ablk_dma = & bfa->modules.ablk.ablk_dma;
  bfa_ablk_attach(ablk, & bfa->ioc);
  bfa_ablk_memclaim(ablk, ablk_dma->kva_curp, ablk_dma->dma_curp);
  return;
}
}
static void bfa_com_cee_attach(struct bfa_s *bfa ) 
{ 
  struct bfa_cee_s *cee ;
  struct bfa_mem_dma_s *cee_dma ;

  {
  cee = & bfa->modules.cee;
  cee_dma = & bfa->modules.cee.cee_dma;
  cee->trcmod = bfa->trcmod;
  bfa_cee_attach(cee, & bfa->ioc, (void *)bfa);
  bfa_cee_mem_claim(cee, cee_dma->kva_curp, cee_dma->dma_curp);
  return;
}
}
static void bfa_com_sfp_attach(struct bfa_s *bfa ) 
{ 
  struct bfa_sfp_s *sfp ;
  struct bfa_mem_dma_s *sfp_dma ;

  {
  sfp = & bfa->modules.sfp;
  sfp_dma = & bfa->modules.sfp.sfp_dma;
  bfa_sfp_attach(sfp, & bfa->ioc, (void *)bfa, bfa->trcmod);
  bfa_sfp_memclaim(sfp, sfp_dma->kva_curp, sfp_dma->dma_curp);
  return;
}
}
static void bfa_com_flash_attach(struct bfa_s *bfa , enum bfa_boolean mincfg ) 
{ 
  struct bfa_flash_s *flash ;
  struct bfa_mem_dma_s *flash_dma ;

  {
  flash = & bfa->modules.flash;
  flash_dma = & bfa->modules.flash.flash_dma;
  bfa_flash_attach(flash, & bfa->ioc, (void *)bfa, bfa->trcmod, mincfg);
  bfa_flash_memclaim(flash, flash_dma->kva_curp, flash_dma->dma_curp, mincfg);
  return;
}
}
static void bfa_com_diag_attach(struct bfa_s *bfa ) 
{ 
  struct bfa_diag_s *diag ;
  struct bfa_mem_dma_s *diag_dma ;

  {
  diag = & bfa->modules.diag_mod;
  diag_dma = & bfa->modules.diag_mod.diag_dma;
  bfa_diag_attach(diag, & bfa->ioc, (void *)bfa, & bfa_fcport_beacon, bfa->trcmod);
  bfa_diag_memclaim(diag, diag_dma->kva_curp, diag_dma->dma_curp);
  return;
}
}
static void bfa_com_phy_attach(struct bfa_s *bfa , enum bfa_boolean mincfg ) 
{ 
  struct bfa_phy_s *phy ;
  struct bfa_mem_dma_s *phy_dma ;

  {
  phy = & bfa->modules.phy;
  phy_dma = & bfa->modules.phy.phy_dma;
  bfa_phy_attach(phy, & bfa->ioc, (void *)bfa, bfa->trcmod, mincfg);
  bfa_phy_memclaim(phy, phy_dma->kva_curp, phy_dma->dma_curp, mincfg);
  return;
}
}
static void bfa_com_fru_attach(struct bfa_s *bfa , enum bfa_boolean mincfg ) 
{ 
  struct bfa_fru_s *fru ;
  struct bfa_mem_dma_s *fru_dma ;

  {
  fru = & bfa->modules.fru;
  fru_dma = & bfa->modules.fru.fru_dma;
  bfa_fru_attach(fru, & bfa->ioc, (void *)bfa, bfa->trcmod, mincfg);
  bfa_fru_memclaim(fru, fru_dma->kva_curp, fru_dma->dma_curp, mincfg);
  return;
}
}
static void bfa_iocfc_sm_stopped(struct bfa_iocfc_s *iocfc , enum iocfc_event event ) ;
static void bfa_iocfc_sm_stopped_entry(struct bfa_iocfc_s *iocfc ) ;
static void bfa_iocfc_sm_initing(struct bfa_iocfc_s *iocfc , enum iocfc_event event ) ;
static void bfa_iocfc_sm_initing_entry(struct bfa_iocfc_s *iocfc ) ;
static void bfa_iocfc_sm_dconf_read(struct bfa_iocfc_s *iocfc , enum iocfc_event event ) ;
static void bfa_iocfc_sm_dconf_read_entry(struct bfa_iocfc_s *iocfc ) ;
static void bfa_iocfc_sm_init_cfg_wait(struct bfa_iocfc_s *iocfc , enum iocfc_event event ) ;
static void bfa_iocfc_sm_init_cfg_wait_entry(struct bfa_iocfc_s *iocfc ) ;
static void bfa_iocfc_sm_init_cfg_done(struct bfa_iocfc_s *iocfc , enum iocfc_event event ) ;
static void bfa_iocfc_sm_init_cfg_done_entry(struct bfa_iocfc_s *iocfc ) ;
static void bfa_iocfc_sm_operational(struct bfa_iocfc_s *iocfc , enum iocfc_event event ) ;
static void bfa_iocfc_sm_operational_entry(struct bfa_iocfc_s *iocfc ) ;
static void bfa_iocfc_sm_dconf_write(struct bfa_iocfc_s *iocfc , enum iocfc_event event ) ;
static void bfa_iocfc_sm_dconf_write_entry(struct bfa_iocfc_s *iocfc ) ;
static void bfa_iocfc_sm_stopping(struct bfa_iocfc_s *iocfc , enum iocfc_event event ) ;
static void bfa_iocfc_sm_stopping_entry(struct bfa_iocfc_s *iocfc ) ;
static void bfa_iocfc_sm_enabling(struct bfa_iocfc_s *iocfc , enum iocfc_event event ) ;
static void bfa_iocfc_sm_enabling_entry(struct bfa_iocfc_s *iocfc ) ;
static void bfa_iocfc_sm_cfg_wait(struct bfa_iocfc_s *iocfc , enum iocfc_event event ) ;
static void bfa_iocfc_sm_cfg_wait_entry(struct bfa_iocfc_s *iocfc ) ;
static void bfa_iocfc_sm_disabling(struct bfa_iocfc_s *iocfc , enum iocfc_event event ) ;
static void bfa_iocfc_sm_disabling_entry(struct bfa_iocfc_s *iocfc ) ;
static void bfa_iocfc_sm_disabled(struct bfa_iocfc_s *iocfc , enum iocfc_event event ) ;
static void bfa_iocfc_sm_disabled_entry(struct bfa_iocfc_s *iocfc ) ;
static void bfa_iocfc_sm_failed(struct bfa_iocfc_s *iocfc , enum iocfc_event event ) ;
static void bfa_iocfc_sm_failed_entry(struct bfa_iocfc_s *iocfc ) ;
static void bfa_iocfc_sm_init_failed(struct bfa_iocfc_s *iocfc , enum iocfc_event event ) ;
static void bfa_iocfc_sm_init_failed_entry(struct bfa_iocfc_s *iocfc ) ;
static void bfa_iocfc_start_submod(struct bfa_s *bfa ) ;
static void bfa_iocfc_disable_submod(struct bfa_s *bfa ) ;
static void bfa_iocfc_send_cfg(void *bfa_arg ) ;
static void bfa_iocfc_enable_cbfn(void *bfa_arg , enum bfa_status status ) ;
static void bfa_iocfc_disable_cbfn(void *bfa_arg ) ;
static void bfa_iocfc_hbfail_cbfn(void *bfa_arg ) ;
static void bfa_iocfc_reset_cbfn(void *bfa_arg ) ;
static struct bfa_ioc_cbfn_s bfa_iocfc_cbfn  ;
static void bfa_iocfc_init_cb(void *bfa_arg , enum bfa_boolean complete___0 ) ;
static void bfa_iocfc_stop_cb(void *bfa_arg , enum bfa_boolean compl ) ;
static void bfa_iocfc_enable_cb(void *bfa_arg , enum bfa_boolean compl ) ;
static void bfa_iocfc_disable_cb(void *bfa_arg , enum bfa_boolean compl ) ;
static void bfa_iocfc_sm_stopped_entry(struct bfa_iocfc_s *iocfc ) 
{ 


  {
  return;
}
}
static void bfa_iocfc_sm_stopped(struct bfa_iocfc_s *iocfc , enum iocfc_event event ) 
{ 


  {
  __bfa_trc((iocfc->bfa)->trcmod, __trc_fileno___12, 259, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 1U: ;
  case 4U: 
  iocfc->fsm = (void (*)(void * , int  ))(& bfa_iocfc_sm_initing);
  bfa_iocfc_sm_initing_entry(iocfc);
  goto ldv_48333;
  default: 
  __bfa_trc((iocfc->bfa)->trcmod, __trc_fileno___12, 267, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_core.c",
         267, (unsigned int )event);
  goto ldv_48333;
  }
  ldv_48333: ;
  return;
}
}
static void bfa_iocfc_sm_initing_entry(struct bfa_iocfc_s *iocfc ) 
{ 


  {
  bfa_ioc_enable(& (iocfc->bfa)->ioc);
  return;
}
}
static void bfa_iocfc_sm_initing(struct bfa_iocfc_s *iocfc , enum iocfc_event event ) 
{ 


  {
  __bfa_trc((iocfc->bfa)->trcmod, __trc_fileno___12, 281, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 6U: 
  iocfc->fsm = (void (*)(void * , int  ))(& bfa_iocfc_sm_dconf_read);
  bfa_iocfc_sm_dconf_read_entry(iocfc);
  goto ldv_48343;
  case 5U: 
  iocfc->fsm = (void (*)(void * , int  ))(& bfa_iocfc_sm_disabling);
  bfa_iocfc_sm_disabling_entry(iocfc);
  goto ldv_48343;
  case 3U: 
  iocfc->fsm = (void (*)(void * , int  ))(& bfa_iocfc_sm_stopping);
  bfa_iocfc_sm_stopping_entry(iocfc);
  goto ldv_48343;
  case 8U: 
  iocfc->fsm = (void (*)(void * , int  ))(& bfa_iocfc_sm_init_failed);
  bfa_iocfc_sm_init_failed_entry(iocfc);
  goto ldv_48343;
  default: 
  __bfa_trc((iocfc->bfa)->trcmod, __trc_fileno___12, 300, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_core.c",
         300, (unsigned int )event);
  goto ldv_48343;
  }
  ldv_48343: ;
  return;
}
}
static void bfa_iocfc_sm_dconf_read_entry(struct bfa_iocfc_s *iocfc ) 
{ 


  {
  bfa_dconf_modinit(iocfc->bfa);
  return;
}
}
static void bfa_iocfc_sm_dconf_read(struct bfa_iocfc_s *iocfc , enum iocfc_event event ) 
{ 


  {
  __bfa_trc((iocfc->bfa)->trcmod, __trc_fileno___12, 314, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 9U: 
  iocfc->fsm = (void (*)(void * , int  ))(& bfa_iocfc_sm_init_cfg_wait);
  bfa_iocfc_sm_init_cfg_wait_entry(iocfc);
  goto ldv_48356;
  case 5U: 
  iocfc->fsm = (void (*)(void * , int  ))(& bfa_iocfc_sm_disabling);
  bfa_iocfc_sm_disabling_entry(iocfc);
  goto ldv_48356;
  case 3U: 
  iocfc->fsm = (void (*)(void * , int  ))(& bfa_iocfc_sm_stopping);
  bfa_iocfc_sm_stopping_entry(iocfc);
  goto ldv_48356;
  case 8U: 
  iocfc->fsm = (void (*)(void * , int  ))(& bfa_iocfc_sm_init_failed);
  bfa_iocfc_sm_init_failed_entry(iocfc);
  goto ldv_48356;
  default: 
  __bfa_trc((iocfc->bfa)->trcmod, __trc_fileno___12, 333, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_core.c",
         333, (unsigned int )event);
  goto ldv_48356;
  }
  ldv_48356: ;
  return;
}
}
static void bfa_iocfc_sm_init_cfg_wait_entry(struct bfa_iocfc_s *iocfc ) 
{ 


  {
  bfa_iocfc_send_cfg((void *)iocfc->bfa);
  return;
}
}
static void bfa_iocfc_sm_init_cfg_wait(struct bfa_iocfc_s *iocfc , enum iocfc_event event ) 
{ 


  {
  __bfa_trc((iocfc->bfa)->trcmod, __trc_fileno___12, 347, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 10U: 
  iocfc->fsm = (void (*)(void * , int  ))(& bfa_iocfc_sm_init_cfg_done);
  bfa_iocfc_sm_init_cfg_done_entry(iocfc);
  goto ldv_48369;
  case 5U: 
  iocfc->fsm = (void (*)(void * , int  ))(& bfa_iocfc_sm_disabling);
  bfa_iocfc_sm_disabling_entry(iocfc);
  goto ldv_48369;
  case 3U: 
  iocfc->fsm = (void (*)(void * , int  ))(& bfa_iocfc_sm_stopping);
  bfa_iocfc_sm_stopping_entry(iocfc);
  goto ldv_48369;
  case 8U: 
  iocfc->fsm = (void (*)(void * , int  ))(& bfa_iocfc_sm_init_failed);
  bfa_iocfc_sm_init_failed_entry(iocfc);
  goto ldv_48369;
  default: 
  __bfa_trc((iocfc->bfa)->trcmod, __trc_fileno___12, 366, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_core.c",
         366, (unsigned int )event);
  goto ldv_48369;
  }
  ldv_48369: ;
  return;
}
}
static void bfa_iocfc_sm_init_cfg_done_entry(struct bfa_iocfc_s *iocfc ) 
{ 


  {
  (iocfc->bfa)->iocfc.op_status = 0;
  (iocfc->bfa)->iocfc.init_hcb_qe.cbfn = & bfa_iocfc_init_cb;
  (iocfc->bfa)->iocfc.init_hcb_qe.cbarg = (void *)iocfc->bfa;
  (iocfc->bfa)->iocfc.init_hcb_qe.pre_rmv = 0;
  list_add_tail(& (iocfc->bfa)->iocfc.init_hcb_qe.qe, & (iocfc->bfa)->comp_q);
  return;
}
}
static void bfa_iocfc_sm_init_cfg_done(struct bfa_iocfc_s *iocfc , enum iocfc_event event ) 
{ 


  {
  __bfa_trc((iocfc->bfa)->trcmod, __trc_fileno___12, 382, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 2U: 
  iocfc->fsm = (void (*)(void * , int  ))(& bfa_iocfc_sm_operational);
  bfa_iocfc_sm_operational_entry(iocfc);
  goto ldv_48382;
  case 3U: 
  iocfc->fsm = (void (*)(void * , int  ))(& bfa_iocfc_sm_stopping);
  bfa_iocfc_sm_stopping_entry(iocfc);
  goto ldv_48382;
  case 5U: 
  iocfc->fsm = (void (*)(void * , int  ))(& bfa_iocfc_sm_disabling);
  bfa_iocfc_sm_disabling_entry(iocfc);
  goto ldv_48382;
  case 8U: 
  iocfc->fsm = (void (*)(void * , int  ))(& bfa_iocfc_sm_failed);
  bfa_iocfc_sm_failed_entry(iocfc);
  goto ldv_48382;
  default: 
  __bfa_trc((iocfc->bfa)->trcmod, __trc_fileno___12, 398, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_core.c",
         398, (unsigned int )event);
  goto ldv_48382;
  }
  ldv_48382: ;
  return;
}
}
static void bfa_iocfc_sm_operational_entry(struct bfa_iocfc_s *iocfc ) 
{ 


  {
  bfa_fcport_init(iocfc->bfa);
  bfa_iocfc_start_submod(iocfc->bfa);
  return;
}
}
static void bfa_iocfc_sm_operational(struct bfa_iocfc_s *iocfc , enum iocfc_event event ) 
{ 


  {
  __bfa_trc((iocfc->bfa)->trcmod, __trc_fileno___12, 413, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 3U: 
  iocfc->fsm = (void (*)(void * , int  ))(& bfa_iocfc_sm_dconf_write);
  bfa_iocfc_sm_dconf_write_entry(iocfc);
  goto ldv_48395;
  case 5U: 
  iocfc->fsm = (void (*)(void * , int  ))(& bfa_iocfc_sm_disabling);
  bfa_iocfc_sm_disabling_entry(iocfc);
  goto ldv_48395;
  case 8U: 
  iocfc->fsm = (void (*)(void * , int  ))(& bfa_iocfc_sm_failed);
  bfa_iocfc_sm_failed_entry(iocfc);
  goto ldv_48395;
  default: 
  __bfa_trc((iocfc->bfa)->trcmod, __trc_fileno___12, 426, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_core.c",
         426, (unsigned int )event);
  goto ldv_48395;
  }
  ldv_48395: ;
  return;
}
}
static void bfa_iocfc_sm_dconf_write_entry(struct bfa_iocfc_s *iocfc ) 
{ 


  {
  bfa_dconf_modexit(iocfc->bfa);
  return;
}
}
static void bfa_iocfc_sm_dconf_write(struct bfa_iocfc_s *iocfc , enum iocfc_event event ) 
{ 


  {
  __bfa_trc((iocfc->bfa)->trcmod, __trc_fileno___12, 440, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 9U: ;
  case 8U: 
  iocfc->fsm = (void (*)(void * , int  ))(& bfa_iocfc_sm_stopping);
  bfa_iocfc_sm_stopping_entry(iocfc);
  goto ldv_48408;
  default: 
  __bfa_trc((iocfc->bfa)->trcmod, __trc_fileno___12, 448, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_core.c",
         448, (unsigned int )event);
  goto ldv_48408;
  }
  ldv_48408: ;
  return;
}
}
static void bfa_iocfc_sm_stopping_entry(struct bfa_iocfc_s *iocfc ) 
{ 


  {
  bfa_ioc_disable(& (iocfc->bfa)->ioc);
  return;
}
}
static void bfa_iocfc_sm_stopping(struct bfa_iocfc_s *iocfc , enum iocfc_event event ) 
{ 


  {
  __bfa_trc((iocfc->bfa)->trcmod, __trc_fileno___12, 462, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 7U: 
  bfa_isr_disable(iocfc->bfa);
  bfa_iocfc_disable_submod(iocfc->bfa);
  iocfc->fsm = (void (*)(void * , int  ))(& bfa_iocfc_sm_stopped);
  bfa_iocfc_sm_stopped_entry(iocfc);
  (iocfc->bfa)->iocfc.op_status = 0;
  (iocfc->bfa)->iocfc.stop_hcb_qe.cbfn = & bfa_iocfc_stop_cb;
  (iocfc->bfa)->iocfc.stop_hcb_qe.cbarg = (void *)iocfc->bfa;
  (iocfc->bfa)->iocfc.stop_hcb_qe.pre_rmv = 0;
  list_add_tail(& (iocfc->bfa)->iocfc.stop_hcb_qe.qe, & (iocfc->bfa)->comp_q);
  goto ldv_48418;
  case 6U: ;
  case 9U: ;
  case 10U: ;
  goto ldv_48418;
  default: 
  __bfa_trc((iocfc->bfa)->trcmod, __trc_fileno___12, 480, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_core.c",
         480, (unsigned int )event);
  goto ldv_48418;
  }
  ldv_48418: ;
  return;
}
}
static void bfa_iocfc_sm_enabling_entry(struct bfa_iocfc_s *iocfc ) 
{ 


  {
  bfa_ioc_enable(& (iocfc->bfa)->ioc);
  return;
}
}
static void bfa_iocfc_sm_enabling(struct bfa_iocfc_s *iocfc , enum iocfc_event event ) 
{ 


  {
  __bfa_trc((iocfc->bfa)->trcmod, __trc_fileno___12, 494, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 6U: 
  iocfc->fsm = (void (*)(void * , int  ))(& bfa_iocfc_sm_cfg_wait);
  bfa_iocfc_sm_cfg_wait_entry(iocfc);
  goto ldv_48431;
  case 5U: 
  iocfc->fsm = (void (*)(void * , int  ))(& bfa_iocfc_sm_disabling);
  bfa_iocfc_sm_disabling_entry(iocfc);
  goto ldv_48431;
  case 3U: 
  iocfc->fsm = (void (*)(void * , int  ))(& bfa_iocfc_sm_dconf_write);
  bfa_iocfc_sm_dconf_write_entry(iocfc);
  goto ldv_48431;
  case 8U: 
  iocfc->fsm = (void (*)(void * , int  ))(& bfa_iocfc_sm_failed);
  bfa_iocfc_sm_failed_entry(iocfc);
  if ((unsigned int )(iocfc->bfa)->iocfc.cb_reqd == 0U) {
    goto ldv_48431;
  } else {

  }
  (iocfc->bfa)->iocfc.op_status = 1;
  (iocfc->bfa)->iocfc.en_hcb_qe.cbfn = & bfa_iocfc_enable_cb;
  (iocfc->bfa)->iocfc.en_hcb_qe.cbarg = (void *)iocfc->bfa;
  (iocfc->bfa)->iocfc.en_hcb_qe.pre_rmv = 0;
  list_add_tail(& (iocfc->bfa)->iocfc.en_hcb_qe.qe, & (iocfc->bfa)->comp_q);
  (iocfc->bfa)->iocfc.cb_reqd = 0;
  goto ldv_48431;
  default: 
  __bfa_trc((iocfc->bfa)->trcmod, __trc_fileno___12, 521, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_core.c",
         521, (unsigned int )event);
  goto ldv_48431;
  }
  ldv_48431: ;
  return;
}
}
static void bfa_iocfc_sm_cfg_wait_entry(struct bfa_iocfc_s *iocfc ) 
{ 


  {
  bfa_iocfc_send_cfg((void *)iocfc->bfa);
  return;
}
}
static void bfa_iocfc_sm_cfg_wait(struct bfa_iocfc_s *iocfc , enum iocfc_event event ) 
{ 


  {
  __bfa_trc((iocfc->bfa)->trcmod, __trc_fileno___12, 535, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 10U: 
  iocfc->fsm = (void (*)(void * , int  ))(& bfa_iocfc_sm_operational);
  bfa_iocfc_sm_operational_entry(iocfc);
  if ((unsigned int )(iocfc->bfa)->iocfc.cb_reqd == 0U) {
    goto ldv_48444;
  } else {

  }
  (iocfc->bfa)->iocfc.op_status = 0;
  (iocfc->bfa)->iocfc.en_hcb_qe.cbfn = & bfa_iocfc_enable_cb;
  (iocfc->bfa)->iocfc.en_hcb_qe.cbarg = (void *)iocfc->bfa;
  (iocfc->bfa)->iocfc.en_hcb_qe.pre_rmv = 0;
  list_add_tail(& (iocfc->bfa)->iocfc.en_hcb_qe.qe, & (iocfc->bfa)->comp_q);
  (iocfc->bfa)->iocfc.cb_reqd = 0;
  goto ldv_48444;
  case 5U: 
  iocfc->fsm = (void (*)(void * , int  ))(& bfa_iocfc_sm_disabling);
  bfa_iocfc_sm_disabling_entry(iocfc);
  goto ldv_48444;
  case 3U: 
  iocfc->fsm = (void (*)(void * , int  ))(& bfa_iocfc_sm_dconf_write);
  bfa_iocfc_sm_dconf_write_entry(iocfc);
  goto ldv_48444;
  case 8U: 
  iocfc->fsm = (void (*)(void * , int  ))(& bfa_iocfc_sm_failed);
  bfa_iocfc_sm_failed_entry(iocfc);
  if ((unsigned int )(iocfc->bfa)->iocfc.cb_reqd == 0U) {
    goto ldv_48444;
  } else {

  }
  (iocfc->bfa)->iocfc.op_status = 1;
  (iocfc->bfa)->iocfc.en_hcb_qe.cbfn = & bfa_iocfc_enable_cb;
  (iocfc->bfa)->iocfc.en_hcb_qe.cbarg = (void *)iocfc->bfa;
  (iocfc->bfa)->iocfc.en_hcb_qe.pre_rmv = 0;
  list_add_tail(& (iocfc->bfa)->iocfc.en_hcb_qe.qe, & (iocfc->bfa)->comp_q);
  (iocfc->bfa)->iocfc.cb_reqd = 0;
  goto ldv_48444;
  default: 
  __bfa_trc((iocfc->bfa)->trcmod, __trc_fileno___12, 566, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_core.c",
         566, (unsigned int )event);
  goto ldv_48444;
  }
  ldv_48444: ;
  return;
}
}
static void bfa_iocfc_sm_disabling_entry(struct bfa_iocfc_s *iocfc ) 
{ 


  {
  bfa_ioc_disable(& (iocfc->bfa)->ioc);
  return;
}
}
static void bfa_iocfc_sm_disabling(struct bfa_iocfc_s *iocfc , enum iocfc_event event ) 
{ 


  {
  __bfa_trc((iocfc->bfa)->trcmod, __trc_fileno___12, 580, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 7U: 
  iocfc->fsm = (void (*)(void * , int  ))(& bfa_iocfc_sm_disabled);
  bfa_iocfc_sm_disabled_entry(iocfc);
  goto ldv_48457;
  case 6U: ;
  case 9U: ;
  case 10U: ;
  goto ldv_48457;
  default: 
  __bfa_trc((iocfc->bfa)->trcmod, __trc_fileno___12, 591, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_core.c",
         591, (unsigned int )event);
  goto ldv_48457;
  }
  ldv_48457: ;
  return;
}
}
static void bfa_iocfc_sm_disabled_entry(struct bfa_iocfc_s *iocfc ) 
{ 


  {
  bfa_isr_disable(iocfc->bfa);
  bfa_iocfc_disable_submod(iocfc->bfa);
  (iocfc->bfa)->iocfc.op_status = 0;
  (iocfc->bfa)->iocfc.dis_hcb_qe.cbfn = & bfa_iocfc_disable_cb;
  (iocfc->bfa)->iocfc.dis_hcb_qe.cbarg = (void *)iocfc->bfa;
  (iocfc->bfa)->iocfc.dis_hcb_qe.pre_rmv = 0;
  list_add_tail(& (iocfc->bfa)->iocfc.dis_hcb_qe.qe, & (iocfc->bfa)->comp_q);
  return;
}
}
static void bfa_iocfc_sm_disabled(struct bfa_iocfc_s *iocfc , enum iocfc_event event ) 
{ 


  {
  __bfa_trc((iocfc->bfa)->trcmod, __trc_fileno___12, 609, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 3U: 
  iocfc->fsm = (void (*)(void * , int  ))(& bfa_iocfc_sm_dconf_write);
  bfa_iocfc_sm_dconf_write_entry(iocfc);
  goto ldv_48470;
  case 4U: 
  iocfc->fsm = (void (*)(void * , int  ))(& bfa_iocfc_sm_enabling);
  bfa_iocfc_sm_enabling_entry(iocfc);
  goto ldv_48470;
  default: 
  __bfa_trc((iocfc->bfa)->trcmod, __trc_fileno___12, 619, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_core.c",
         619, (unsigned int )event);
  goto ldv_48470;
  }
  ldv_48470: ;
  return;
}
}
static void bfa_iocfc_sm_failed_entry(struct bfa_iocfc_s *iocfc ) 
{ 


  {
  bfa_isr_disable(iocfc->bfa);
  bfa_iocfc_disable_submod(iocfc->bfa);
  return;
}
}
static void bfa_iocfc_sm_failed(struct bfa_iocfc_s *iocfc , enum iocfc_event event ) 
{ 


  {
  __bfa_trc((iocfc->bfa)->trcmod, __trc_fileno___12, 634, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 3U: 
  iocfc->fsm = (void (*)(void * , int  ))(& bfa_iocfc_sm_dconf_write);
  bfa_iocfc_sm_dconf_write_entry(iocfc);
  goto ldv_48481;
  case 5U: 
  iocfc->fsm = (void (*)(void * , int  ))(& bfa_iocfc_sm_disabling);
  bfa_iocfc_sm_disabling_entry(iocfc);
  goto ldv_48481;
  case 6U: 
  iocfc->fsm = (void (*)(void * , int  ))(& bfa_iocfc_sm_cfg_wait);
  bfa_iocfc_sm_cfg_wait_entry(iocfc);
  goto ldv_48481;
  case 8U: ;
  goto ldv_48481;
  default: 
  __bfa_trc((iocfc->bfa)->trcmod, __trc_fileno___12, 649, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_core.c",
         649, (unsigned int )event);
  goto ldv_48481;
  }
  ldv_48481: ;
  return;
}
}
static void bfa_iocfc_sm_init_failed_entry(struct bfa_iocfc_s *iocfc ) 
{ 


  {
  bfa_isr_disable(iocfc->bfa);
  (iocfc->bfa)->iocfc.op_status = 1;
  (iocfc->bfa)->iocfc.init_hcb_qe.cbfn = & bfa_iocfc_init_cb;
  (iocfc->bfa)->iocfc.init_hcb_qe.cbarg = (void *)iocfc->bfa;
  (iocfc->bfa)->iocfc.init_hcb_qe.pre_rmv = 0;
  list_add_tail(& (iocfc->bfa)->iocfc.init_hcb_qe.qe, & (iocfc->bfa)->comp_q);
  return;
}
}
static void bfa_iocfc_sm_init_failed(struct bfa_iocfc_s *iocfc , enum iocfc_event event ) 
{ 


  {
  __bfa_trc((iocfc->bfa)->trcmod, __trc_fileno___12, 666, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 3U: 
  iocfc->fsm = (void (*)(void * , int  ))(& bfa_iocfc_sm_stopping);
  bfa_iocfc_sm_stopping_entry(iocfc);
  goto ldv_48494;
  case 5U: 
  bfa_ioc_disable(& (iocfc->bfa)->ioc);
  goto ldv_48494;
  case 6U: 
  iocfc->fsm = (void (*)(void * , int  ))(& bfa_iocfc_sm_dconf_read);
  bfa_iocfc_sm_dconf_read_entry(iocfc);
  goto ldv_48494;
  case 7U: 
  iocfc->fsm = (void (*)(void * , int  ))(& bfa_iocfc_sm_stopped);
  bfa_iocfc_sm_stopped_entry(iocfc);
  (iocfc->bfa)->iocfc.op_status = 0;
  (iocfc->bfa)->iocfc.dis_hcb_qe.cbfn = & bfa_iocfc_disable_cb;
  (iocfc->bfa)->iocfc.dis_hcb_qe.cbarg = (void *)iocfc->bfa;
  (iocfc->bfa)->iocfc.dis_hcb_qe.pre_rmv = 0;
  list_add_tail(& (iocfc->bfa)->iocfc.dis_hcb_qe.qe, & (iocfc->bfa)->comp_q);
  goto ldv_48494;
  case 8U: ;
  goto ldv_48494;
  default: 
  __bfa_trc((iocfc->bfa)->trcmod, __trc_fileno___12, 687, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_core.c",
         687, (unsigned int )event);
  goto ldv_48494;
  }
  ldv_48494: ;
  return;
}
}
static void bfa_reqq_resume(struct bfa_s *bfa , int qid ) 
{ 
  struct list_head *waitq ;
  struct list_head *qe ;
  struct list_head *qen ;
  struct bfa_reqq_wait_s *wqe ;

  {
  waitq = (struct list_head *)(& bfa->reqq_waitq) + (unsigned long )qid;
  qe = waitq->next;
  qen = qe->next;
  goto ldv_48510;
  ldv_48509: ;
  if (((bfa->iocfc.req_cq_pi[qid] + 1U) & (u32 )((int )bfa->iocfc.cfg.drvcfg.num_reqq_elems + -1)) == *((u32 *)bfa->iocfc.req_cq_shadow_ci[qid].kva)) {
    goto ldv_48508;
  } else {

  }
  list_del(qe);
  wqe = (struct bfa_reqq_wait_s *)qe;
  (*(wqe->qresume))(wqe->cbarg);
  qe = qen;
  qen = qe->next;
  ldv_48510: ;
  if ((unsigned long )qe != (unsigned long )waitq) {
    goto ldv_48509;
  } else {

  }
  ldv_48508: ;
  return;
}
}
enum bfa_boolean bfa_isr_rspq(struct bfa_s *bfa , int qid ) 
{ 
  struct bfi_msg_s *m ;
  u32 pi ;
  u32 ci ;
  struct list_head *waitq ;
  enum bfa_boolean ret ;
  int __ret_warn_on ;
  long tmp ;
  int tmp___0 ;

  {
  ci = bfa->iocfc.rsp_cq_ci[qid];
  pi = *((u32 *)bfa->iocfc.rsp_cq_shadow_pi[qid].kva);
  ret = ci != pi;
  goto ldv_48523;
  ldv_48522: 
  m = (struct bfi_msg_s *)bfa->iocfc.rsp_cq_ba[qid].kva + (unsigned long )ci;
  __ret_warn_on = (unsigned int )m->mhdr.msg_class > 34U;
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_core.c",
                       730);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  (*(bfa_isrs[(int )m->mhdr.msg_class]))(bfa, m);
  ci = ci + 1U;
  ci = (u32 )((int )bfa->iocfc.cfg.drvcfg.num_rspq_elems + -1) & ci;
  ldv_48523: ;
  if (ci != pi) {
    goto ldv_48522;
  } else {

  }
  (*(bfa->iocfc.hwif.hw_rspq_ack))(bfa, qid, ci);
  waitq = (struct list_head *)(& bfa->reqq_waitq) + (unsigned long )qid;
  tmp___0 = list_empty((struct list_head  const  *)waitq);
  if (tmp___0 == 0) {
    bfa_reqq_resume(bfa, qid);
  } else {

  }
  return (ret);
}
}
__inline static void bfa_isr_reqq(struct bfa_s *bfa , int qid ) 
{ 
  struct list_head *waitq ;
  int tmp ;

  {
  if ((unsigned long )bfa->iocfc.hwif.hw_reqq_ack != (unsigned long )((void (*)(struct bfa_s * ,
                                                                                int  ))0)) {
    (*(bfa->iocfc.hwif.hw_reqq_ack))(bfa, qid);
  } else {

  }
  waitq = (struct list_head *)(& bfa->reqq_waitq) + (unsigned long )qid;
  tmp = list_empty((struct list_head  const  *)waitq);
  if (tmp == 0) {
    bfa_reqq_resume(bfa, qid);
  } else {

  }
  return;
}
}
void bfa_msix_all(struct bfa_s *bfa , int vec ) 
{ 
  u32 intr ;
  u32 qintr ;
  int queue ;
    klee_make_symbolic(&queue, sizeof(int), "queue");

  {
  intr = readl((void const volatile   *)bfa->iocfc.bfa_regs.intr_status);
  if (intr == 0U) {
    return;
  } else {

  }
  qintr = intr & 65280U;
  if (qintr != 0U && (unsigned int )bfa->queue_process != 0U) {
    queue = 0;
    goto ldv_48538;
    ldv_48537: 
    bfa_isr_rspq(bfa, queue);
    queue = queue + 1;
    ldv_48538: ;
    if (queue <= 3) {
      goto ldv_48537;
    } else {

    }

  } else {

  }
  intr = ~ qintr & intr;
  if (intr == 0U) {
    return;
  } else {

  }
  qintr = intr & 255U;
  if (qintr != 0U && (unsigned int )bfa->queue_process != 0U) {
    queue = 0;
    goto ldv_48541;
    ldv_48540: 
    bfa_isr_reqq(bfa, queue);
    queue = queue + 1;
    ldv_48541: ;
    if (queue <= 3) {
      goto ldv_48540;
    } else {

    }

  } else {

  }
  intr = ~ qintr & intr;
  if (intr == 0U) {
    return;
  } else {

  }
  bfa_msix_lpu_err(bfa, (int )intr);
  return;
}
}
enum bfa_boolean bfa_intx(struct bfa_s *bfa ) 
{ 
  u32 intr ;
  u32 qintr ;
  int queue ;
  enum bfa_boolean rspq_comp ;
  enum bfa_boolean tmp ;

  {
  rspq_comp = 0;
  intr = readl((void const volatile   *)bfa->iocfc.bfa_regs.intr_status);
  qintr = intr & 65535U;
  if (qintr != 0U) {
    writel(qintr, (void volatile   *)bfa->iocfc.bfa_regs.intr_status);
  } else {

  }
  if ((unsigned int )bfa->queue_process != 0U) {
    queue = 0;
    goto ldv_48551;
    ldv_48550: 
    tmp = bfa_isr_rspq(bfa, queue);
    if ((unsigned int )tmp != 0U) {
      rspq_comp = 1;
    } else {

    }
    queue = queue + 1;
    ldv_48551: ;
    if (queue <= 3) {
      goto ldv_48550;
    } else {

    }

  } else {

  }
  if (intr == 0U) {
    return ((qintr | (u32 )rspq_comp) != 0U);
  } else {

  }
  qintr = intr & 255U;
  if (qintr != 0U && (unsigned int )bfa->queue_process != 0U) {
    queue = 0;
    goto ldv_48554;
    ldv_48553: 
    bfa_isr_reqq(bfa, queue);
    queue = queue + 1;
    ldv_48554: ;
    if (queue <= 3) {
      goto ldv_48553;
    } else {

    }

  } else {

  }
  intr = ~ qintr & intr;
  if (intr == 0U) {
    return (1);
  } else {

  }
  if ((unsigned int )bfa->intr_enabled != 0U) {
    bfa_msix_lpu_err(bfa, (int )intr);
  } else {

  }
  return (1);
}
}
void bfa_isr_enable(struct bfa_s *bfa ) 
{ 
  u32 umsk ;
  int port_id ;
    klee_make_symbolic(&port_id, sizeof(int), "port_id");

  {
  port_id = (int )bfa->ioc.port_id;
  __bfa_trc(bfa->trcmod, __trc_fileno___12, 853, (unsigned long long )bfa->ioc.pcidev.pci_func);
  __bfa_trc(bfa->trcmod, __trc_fileno___12, 854, (unsigned long long )port_id);
  (*(bfa->iocfc.hwif.hw_msix_ctrl_install))(bfa);
  if ((unsigned int )bfa->ioc.pcidev.device_id == 34U || (unsigned int )bfa->ioc.pcidev.device_id == 35U) {
    umsk = 33292288U;
    umsk = (port_id == 0 ? 69391U : 192752U) | umsk;
  } else {
    umsk = 17760256U;
    umsk = (port_id == 0 ? 1052431U : 2158832U) | umsk;
  }
  writel(umsk, (void volatile   *)bfa->iocfc.bfa_regs.intr_status);
  writel(~ umsk, (void volatile   *)bfa->iocfc.bfa_regs.intr_mask);
  bfa->iocfc.intr_mask = ~ umsk;
  if ((unsigned long )bfa->iocfc.hwif.hw_isr_mode_set != (unsigned long )((void (*)(struct bfa_s * ,
                                                                                    enum bfa_boolean  ))0)) {
    (*(bfa->iocfc.hwif.hw_isr_mode_set))(bfa, bfa->msix.nvecs != 0);
  } else {

  }
  bfa->intr_enabled = 1;
  return;
}
}
void bfa_isr_disable(struct bfa_s *bfa ) 
{ 


  {
  bfa->intr_enabled = 0;
  if ((unsigned long )bfa->iocfc.hwif.hw_isr_mode_set != (unsigned long )((void (*)(struct bfa_s * ,
                                                                                    enum bfa_boolean  ))0)) {
    (*(bfa->iocfc.hwif.hw_isr_mode_set))(bfa, 0);
  } else {

  }
  writel(4294967295U, (void volatile   *)bfa->iocfc.bfa_regs.intr_mask);
  (*(bfa->iocfc.hwif.hw_msix_uninstall))(bfa);
  return;
}
}
void bfa_msix_reqq(struct bfa_s *bfa , int vec ) 
{ 


  {
  bfa_isr_reqq(bfa, vec - bfa->iocfc.hwif.cpe_vec_q0);
  return;
}
}
void bfa_isr_unhandled(struct bfa_s *bfa , struct bfi_msg_s *m ) 
{ 
  int __ret_warn_on ;
  long tmp ;

  {
  __bfa_trc(bfa->trcmod, __trc_fileno___12, 896, (unsigned long long )m->mhdr.msg_class);
  __bfa_trc(bfa->trcmod, __trc_fileno___12, 897, (unsigned long long )m->mhdr.msg_id);
  __bfa_trc(bfa->trcmod, __trc_fileno___12, 898, (unsigned long long )m->mhdr.mtag.i2htok);
  __ret_warn_on = 1;
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_core.c",
                       899);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  bfa_trc_stop(bfa->trcmod);
  return;
}
}
void bfa_msix_rspq(struct bfa_s *bfa , int vec ) 
{ 


  {
  bfa_isr_rspq(bfa, vec - bfa->iocfc.hwif.rme_vec_q0);
  return;
}
}
void bfa_msix_lpu_err(struct bfa_s *bfa , int vec ) 
{ 
  u32 intr ;
  u32 curr_value ;
  enum bfa_boolean lpu_isr ;
  enum bfa_boolean halt_isr ;
  enum bfa_boolean pss_isr ;

  {
  intr = readl((void const volatile   *)bfa->iocfc.bfa_regs.intr_status);
  if ((unsigned int )bfa->ioc.pcidev.device_id == 34U || (unsigned int )bfa->ioc.pcidev.device_id == 35U) {
    halt_isr = (enum bfa_boolean )(intr & 2097152U);
    pss_isr = (enum bfa_boolean )(intr & 262144U);
    lpu_isr = (enum bfa_boolean )(intr & 196608U);
    intr = intr & 33292288U;
  } else {
    halt_isr = (unsigned int )bfa->ioc.pcidev.device_id == 20U || (unsigned int )bfa->ioc.pcidev.device_id == 33U ? (enum bfa_boolean )(intr & 16777216U) : 0;
    pss_isr = (enum bfa_boolean )(intr & 524288U);
    lpu_isr = (enum bfa_boolean )(intr & 3145728U);
    intr = intr & 17760256U;
  }
  if ((unsigned int )lpu_isr != 0U) {
    bfa_ioc_mbox_isr(& bfa->ioc);
  } else {

  }
  if (intr != 0U) {
    if ((unsigned int )halt_isr != 0U) {
      curr_value = readl((void const volatile   *)bfa->ioc.ioc_regs.ll_halt);
      curr_value = curr_value & 4294967294U;
      writel(curr_value, (void volatile   *)bfa->ioc.ioc_regs.ll_halt);
    } else {

    }
    if ((unsigned int )pss_isr != 0U) {
      curr_value = readl((void const volatile   *)bfa->ioc.ioc_regs.pss_err_status_reg);
      writel(curr_value, (void volatile   *)bfa->ioc.ioc_regs.pss_err_status_reg);
    } else {

    }
    writel(intr, (void volatile   *)bfa->iocfc.bfa_regs.intr_status);
    bfa_ioc_error_isr(& bfa->ioc);
  } else {

  }
  return;
}
}
static void bfa_iocfc_send_cfg(void *bfa_arg ) 
{ 
  struct bfa_s *bfa ;
  struct bfa_iocfc_s *iocfc ;
  struct bfi_iocfc_cfg_req_s cfg_req ;
  struct bfi_iocfc_cfg_s *cfg_info ;
  struct bfa_iocfc_cfg_s *cfg ;
  int i ;
  int __ret_warn_on ;
  long tmp ;
  u16 tmp___0 ;
  __u16 tmp___1 ;
  __u16 tmp___2 ;
  __u16 tmp___3 ;
  __u16 tmp___4 ;

  {
  bfa = (struct bfa_s *)bfa_arg;
  iocfc = & bfa->iocfc;
  cfg_info = iocfc->cfginfo;
  cfg = & iocfc->cfg;
  __ret_warn_on = (unsigned int )cfg->fwcfg.num_cqs > 4U;
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_core.c",
                       984);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  __bfa_trc(bfa->trcmod, __trc_fileno___12, 985, (unsigned long long )cfg->fwcfg.num_cqs);
  bfa_iocfc_reset_queues(bfa);
  cfg_info->single_msix_vec = 0U;
  if (bfa->msix.nvecs == 1) {
    cfg_info->single_msix_vec = 1U;
  } else {

  }
  cfg_info->endian_sig = 305419896U;
  cfg_info->num_cqs = cfg->fwcfg.num_cqs;
  tmp___0 = bfa_fcpim_get_throttle_cfg(bfa, (int )cfg->fwcfg.num_ioim_reqs);
  tmp___1 = __fswab16((int )tmp___0);
  cfg_info->num_ioim_reqs = tmp___1;
  tmp___2 = __fswab16((int )cfg->fwcfg.num_fwtio_reqs);
  cfg_info->num_fwtio_reqs = tmp___2;
  __bfa_dma_be_addr_set(& cfg_info->cfgrsp_addr, iocfc->cfgrsp_dma.pa);
  i = 0;
  goto ldv_48599;
  ldv_48598: 
  __bfa_dma_be_addr_set((union bfi_addr_u *)(& cfg_info->req_cq_ba) + (unsigned long )i,
                        iocfc->req_cq_ba[i].pa);
  __bfa_dma_be_addr_set((union bfi_addr_u *)(& cfg_info->req_shadow_ci) + (unsigned long )i,
                        iocfc->req_cq_shadow_ci[i].pa);
  tmp___3 = __fswab16((int )cfg->drvcfg.num_reqq_elems);
  cfg_info->req_cq_elems[i] = tmp___3;
  __bfa_dma_be_addr_set((union bfi_addr_u *)(& cfg_info->rsp_cq_ba) + (unsigned long )i,
                        iocfc->rsp_cq_ba[i].pa);
  __bfa_dma_be_addr_set((union bfi_addr_u *)(& cfg_info->rsp_shadow_pi) + (unsigned long )i,
                        iocfc->rsp_cq_shadow_pi[i].pa);
  tmp___4 = __fswab16((int )cfg->drvcfg.num_rspq_elems);
  cfg_info->rsp_cq_elems[i] = tmp___4;
  i = i + 1;
  ldv_48599: ;
  if ((int )cfg->fwcfg.num_cqs > i) {
    goto ldv_48598;
  } else {

  }

  if ((unsigned long )iocfc->fsm == (unsigned long )((void (*)(void * , int  ))(& bfa_iocfc_sm_init_cfg_wait))) {
    cfg_info->intr_attr.coalesce = 1U;
  } else {

  }
  cfg_req.mh.msg_class = 6U;
  cfg_req.mh.msg_id = 1U;
  cfg_req.mh.mtag.h2i.fn_lpu = (u8 )((int )((signed char )((int )bfa->ioc.pcidev.pci_func << 1)) | (int )((signed char )bfa->ioc.port_id));
  __bfa_dma_be_addr_set(& cfg_req.ioc_cfg_dma_addr, iocfc->cfg_info.pa);
  bfa_ioc_mbox_send(& bfa->ioc, (void *)(& cfg_req), 12);
  return;
}
}
static void bfa_iocfc_init_mem(struct bfa_s *bfa , void *bfad , struct bfa_iocfc_cfg_s *cfg ,
                               struct bfa_pcidev_s *pcidev ) 
{ 
  struct bfa_iocfc_s *iocfc ;

  {
  iocfc = & bfa->iocfc;
  bfa->bfad = bfad;
  iocfc->bfa = bfa;
  iocfc->cfg = *cfg;
  if (((unsigned int )bfa->ioc.pcidev.device_id == 20U || (unsigned int )bfa->ioc.pcidev.device_id == 33U) || ((unsigned int )bfa->ioc.pcidev.device_id == 34U || (unsigned int )bfa->ioc.pcidev.device_id == 35U)) {
    iocfc->hwif.hw_reginit = & bfa_hwct_reginit;
    iocfc->hwif.hw_reqq_ack = & bfa_hwct_reqq_ack;
    iocfc->hwif.hw_rspq_ack = & bfa_hwct_rspq_ack;
    iocfc->hwif.hw_msix_init = & bfa_hwct_msix_init;
    iocfc->hwif.hw_msix_ctrl_install = & bfa_hwct_msix_ctrl_install;
    iocfc->hwif.hw_msix_queue_install = & bfa_hwct_msix_queue_install;
    iocfc->hwif.hw_msix_uninstall = & bfa_hwct_msix_uninstall;
    iocfc->hwif.hw_isr_mode_set = & bfa_hwct_isr_mode_set;
    iocfc->hwif.hw_msix_getvecs = & bfa_hwct_msix_getvecs;
    iocfc->hwif.hw_msix_get_rme_range = & bfa_hwct_msix_get_rme_range;
    iocfc->hwif.rme_vec_q0 = 5;
    iocfc->hwif.cpe_vec_q0 = 1;
  } else {
    iocfc->hwif.hw_reginit = & bfa_hwcb_reginit;
    iocfc->hwif.hw_reqq_ack = (void (*)(struct bfa_s * , int  ))0;
    iocfc->hwif.hw_rspq_ack = & bfa_hwcb_rspq_ack;
    iocfc->hwif.hw_msix_init = & bfa_hwcb_msix_init;
    iocfc->hwif.hw_msix_ctrl_install = & bfa_hwcb_msix_ctrl_install;
    iocfc->hwif.hw_msix_queue_install = & bfa_hwcb_msix_queue_install;
    iocfc->hwif.hw_msix_uninstall = & bfa_hwcb_msix_uninstall;
    iocfc->hwif.hw_isr_mode_set = & bfa_hwcb_isr_mode_set;
    iocfc->hwif.hw_msix_getvecs = & bfa_hwcb_msix_getvecs;
    iocfc->hwif.hw_msix_get_rme_range = & bfa_hwcb_msix_get_rme_range;
    iocfc->hwif.rme_vec_q0 = ((int )bfa->ioc.pcidev.pci_func + 2) * 4;
    iocfc->hwif.cpe_vec_q0 = (int )bfa->ioc.pcidev.pci_func * 4;
  }
  if ((unsigned int )bfa->ioc.pcidev.device_id == 34U || (unsigned int )bfa->ioc.pcidev.device_id == 35U) {
    iocfc->hwif.hw_reginit = & bfa_hwct2_reginit;
    iocfc->hwif.hw_isr_mode_set = (void (*)(struct bfa_s * , enum bfa_boolean  ))0;
    iocfc->hwif.hw_rspq_ack = & bfa_hwct2_rspq_ack;
  } else {

  }
  (*(iocfc->hwif.hw_reginit))(bfa);
  bfa->msix.nvecs = 0;
  return;
}
}
static void bfa_iocfc_mem_claim(struct bfa_s *bfa , struct bfa_iocfc_cfg_s *cfg ) 
{ 
  u8 *dm_kva ;
  u64 dm_pa ;
  int i ;
  int per_reqq_sz ;
    klee_make_symbolic(&per_reqq_sz, sizeof(int), "per_reqq_sz");
  int per_rspq_sz ;
    klee_make_symbolic(&per_rspq_sz, sizeof(int), "per_rspq_sz");
  struct bfa_iocfc_s *iocfc ;
  struct bfa_mem_dma_s *ioc_dma ;
  struct bfa_mem_dma_s *iocfc_dma ;
  struct bfa_mem_dma_s *reqq_dma ;
  struct bfa_mem_dma_s *rspq_dma ;

  {
  dm_kva = (u8 *)0U;
  dm_pa = 0ULL;
  iocfc = & bfa->iocfc;
  ioc_dma = & bfa->iocfc.ioc_dma;
  iocfc_dma = & bfa->iocfc.iocfc_dma;
  bfa_ioc_mem_claim(& bfa->ioc, ioc_dma->kva_curp, ioc_dma->dma_curp);
  per_reqq_sz = ((int )cfg->drvcfg.num_reqq_elems * 128 + 255) & -256;
  per_rspq_sz = ((int )cfg->drvcfg.num_rspq_elems * 128 + 255) & -256;
  i = 0;
  goto ldv_48623;
  ldv_48622: 
  reqq_dma = (struct bfa_mem_dma_s *)(& bfa->iocfc.reqq_dma) + (unsigned long )i;
  iocfc->req_cq_ba[i].kva = (void *)reqq_dma->kva_curp;
  iocfc->req_cq_ba[i].pa = reqq_dma->dma_curp;
  memset(iocfc->req_cq_ba[i].kva, 0, (size_t )per_reqq_sz);
  rspq_dma = (struct bfa_mem_dma_s *)(& bfa->iocfc.rspq_dma) + (unsigned long )i;
  iocfc->rsp_cq_ba[i].kva = (void *)rspq_dma->kva_curp;
  iocfc->rsp_cq_ba[i].pa = rspq_dma->dma_curp;
  memset(iocfc->rsp_cq_ba[i].kva, 0, (size_t )per_rspq_sz);
  i = i + 1;
  ldv_48623: ;
  if ((int )cfg->fwcfg.num_cqs > i) {
    goto ldv_48622;
  } else {

  }
  dm_kva = iocfc_dma->kva_curp;
  dm_pa = iocfc_dma->dma_curp;
  i = 0;
  goto ldv_48626;
  ldv_48625: 
  iocfc->req_cq_shadow_ci[i].kva = (void *)dm_kva;
  iocfc->req_cq_shadow_ci[i].pa = dm_pa;
  dm_kva = dm_kva + 256UL;
  dm_pa = dm_pa + 256ULL;
  iocfc->rsp_cq_shadow_pi[i].kva = (void *)dm_kva;
  iocfc->rsp_cq_shadow_pi[i].pa = dm_pa;
  dm_kva = dm_kva + 256UL;
  dm_pa = dm_pa + 256ULL;
  i = i + 1;
  ldv_48626: ;
  if ((int )cfg->fwcfg.num_cqs > i) {
    goto ldv_48625;
  } else {

  }
  bfa->iocfc.cfg_info.kva = (void *)dm_kva;
  bfa->iocfc.cfg_info.pa = dm_pa;
  bfa->iocfc.cfginfo = (struct bfi_iocfc_cfg_s *)dm_kva;
  dm_kva = dm_kva + 256UL;
  dm_pa = dm_pa + 256ULL;
  bfa->iocfc.cfgrsp_dma.kva = (void *)dm_kva;
  bfa->iocfc.cfgrsp_dma.pa = dm_pa;
  bfa->iocfc.cfgrsp = (struct bfi_iocfc_cfgrsp_s *)dm_kva;
  dm_kva = dm_kva + 768UL;
  dm_pa = dm_pa + 768ULL;
  bfa_ioc_debug_memclaim(& bfa->ioc, (void *)iocfc->kva_seg.kva_curp);
  iocfc->kva_seg.kva_curp = iocfc->kva_seg.kva_curp + 4128UL;
  return;
}
}
static void bfa_iocfc_start_submod(struct bfa_s *bfa ) 
{ 
  int i ;

  {
  bfa->queue_process = 1;
  i = 0;
  goto ldv_48633;
  ldv_48632: 
  (*(bfa->iocfc.hwif.hw_rspq_ack))(bfa, i, bfa->iocfc.rsp_cq_ci[i]);
  i = i + 1;
  ldv_48633: ;
  if (i <= 3) {
    goto ldv_48632;
  } else {

  }
  i = 0;
  goto ldv_48636;
  ldv_48635: 
  (*((hal_mods[i])->start))(bfa);
  i = i + 1;
  ldv_48636: ;
  if ((unsigned long )hal_mods[i] != (unsigned long )((struct bfa_module_s *)0)) {
    goto ldv_48635;
  } else {

  }
  bfa->iocfc.submod_enabled = 1;
  return;
}
}
static void bfa_iocfc_disable_submod(struct bfa_s *bfa ) 
{ 
  int i ;

  {
  if ((unsigned int )bfa->iocfc.submod_enabled == 0U) {
    return;
  } else {

  }
  i = 0;
  goto ldv_48643;
  ldv_48642: 
  (*((hal_mods[i])->iocdisable))(bfa);
  i = i + 1;
  ldv_48643: ;
  if ((unsigned long )hal_mods[i] != (unsigned long )((struct bfa_module_s *)0)) {
    goto ldv_48642;
  } else {

  }
  bfa->iocfc.submod_enabled = 0;
  return;
}
}
static void bfa_iocfc_init_cb(void *bfa_arg , enum bfa_boolean complete___0 ) 
{ 
  struct bfa_s *bfa ;

  {
  bfa = (struct bfa_s *)bfa_arg;
  if ((unsigned int )complete___0 != 0U) {
    bfa_cb_init(bfa->bfad, bfa->iocfc.op_status);
  } else {

  }
  return;
}
}
static void bfa_iocfc_stop_cb(void *bfa_arg , enum bfa_boolean compl ) 
{ 
  struct bfa_s *bfa ;
  struct bfad_s *bfad ;

  {
  bfa = (struct bfa_s *)bfa_arg;
  bfad = (struct bfad_s *)bfa->bfad;
  if ((unsigned int )compl != 0U) {
    complete(& bfad->comp);
  } else {

  }
  return;
}
}
static void bfa_iocfc_enable_cb(void *bfa_arg , enum bfa_boolean compl ) 
{ 
  struct bfa_s *bfa ;
  struct bfad_s *bfad ;

  {
  bfa = (struct bfa_s *)bfa_arg;
  bfad = (struct bfad_s *)bfa->bfad;
  if ((unsigned int )compl != 0U) {
    complete(& bfad->enable_comp);
  } else {

  }
  return;
}
}
static void bfa_iocfc_disable_cb(void *bfa_arg , enum bfa_boolean compl ) 
{ 
  struct bfa_s *bfa ;
  struct bfad_s *bfad ;

  {
  bfa = (struct bfa_s *)bfa_arg;
  bfad = (struct bfad_s *)bfa->bfad;
  if ((unsigned int )compl != 0U) {
    complete(& bfad->disable_comp);
  } else {

  }
  return;
}
}
static void bfa_iocfc_qreg(struct bfa_s *bfa , struct bfi_iocfc_qreg_s *qreg ) 
{ 
  int i ;
  struct bfa_iocfc_regs_s *r ;
  void *kva ;
  __u32 tmp ;
  __u32 tmp___0 ;
  __u32 tmp___1 ;
  __u32 tmp___2 ;
  __u32 tmp___3 ;
  __u32 tmp___4 ;

  {
  r = & bfa->iocfc.bfa_regs;
  kva = bfa->ioc.pcidev.pci_bar_kva;
  i = 0;
  goto ldv_48676;
  ldv_48675: 
  bfa->iocfc.hw_qid[i] = qreg->hw_qid[i];
  tmp = __fswab32(qreg->cpe_q_ci_off[i]);
  r->cpe_q_ci[i] = kva + (unsigned long )tmp;
  tmp___0 = __fswab32(qreg->cpe_q_pi_off[i]);
  r->cpe_q_pi[i] = kva + (unsigned long )tmp___0;
  tmp___1 = __fswab32(qreg->cpe_qctl_off[i]);
  r->cpe_q_ctrl[i] = kva + (unsigned long )tmp___1;
  tmp___2 = __fswab32(qreg->rme_q_ci_off[i]);
  r->rme_q_ci[i] = kva + (unsigned long )tmp___2;
  tmp___3 = __fswab32(qreg->rme_q_pi_off[i]);
  r->rme_q_pi[i] = kva + (unsigned long )tmp___3;
  tmp___4 = __fswab32(qreg->rme_qctl_off[i]);
  r->rme_q_ctrl[i] = kva + (unsigned long )tmp___4;
  i = i + 1;
  ldv_48676: ;
  if (i <= 3) {
    goto ldv_48675;
  } else {

  }

  return;
}
}
static void bfa_iocfc_res_recfg(struct bfa_s *bfa , struct bfa_iocfc_fwcfg_s *fwcfg ) 
{ 
  struct bfa_iocfc_s *iocfc ;
  struct bfi_iocfc_cfg_s *cfg_info ;
  __u16 tmp ;

  {
  iocfc = & bfa->iocfc;
  cfg_info = iocfc->cfginfo;
  bfa_fcxp_res_recfg(bfa, (int )fwcfg->num_fcxp_reqs);
  bfa_uf_res_recfg(bfa, (int )fwcfg->num_uf_bufs);
  bfa_rport_res_recfg(bfa, (int )fwcfg->num_rports);
  tmp = __fswab16((int )cfg_info->num_ioim_reqs);
  bfa_fcp_res_recfg(bfa, (int )tmp, (int )fwcfg->num_ioim_reqs);
  bfa_tskim_res_recfg(bfa, (int )fwcfg->num_tskim_reqs);
  return;
}
}
static void bfa_iocfc_cfgrsp(struct bfa_s *bfa ) 
{ 
  struct bfa_iocfc_s *iocfc ;
  struct bfi_iocfc_cfgrsp_s *cfgrsp ;
  struct bfa_iocfc_fwcfg_s *fwcfg ;
  __u16 tmp ;
  __u16 tmp___0 ;
  __u16 tmp___1 ;
  __u16 tmp___2 ;
  __u16 tmp___3 ;
  __u16 tmp___4 ;

  {
  iocfc = & bfa->iocfc;
  cfgrsp = iocfc->cfgrsp;
  fwcfg = & cfgrsp->fwcfg;
  fwcfg->num_cqs = fwcfg->num_cqs;
  tmp = __fswab16((int )fwcfg->num_ioim_reqs);
  fwcfg->num_ioim_reqs = tmp;
  tmp___0 = __fswab16((int )fwcfg->num_fwtio_reqs);
  fwcfg->num_fwtio_reqs = tmp___0;
  tmp___1 = __fswab16((int )fwcfg->num_tskim_reqs);
  fwcfg->num_tskim_reqs = tmp___1;
  tmp___2 = __fswab16((int )fwcfg->num_fcxp_reqs);
  fwcfg->num_fcxp_reqs = tmp___2;
  tmp___3 = __fswab16((int )fwcfg->num_uf_bufs);
  fwcfg->num_uf_bufs = tmp___3;
  tmp___4 = __fswab16((int )fwcfg->num_rports);
  fwcfg->num_rports = tmp___4;
  bfa_iocfc_qreg(bfa, & cfgrsp->qreg);
  bfa_iocfc_res_recfg(bfa, fwcfg);
  (*(bfa->iocfc.hwif.hw_msix_queue_install))(bfa);
  if ((bfa->iocfc.cfgrsp)->pbc_cfg.pbc_pwwn != 0ULL) {
    (bfa->ioc.attr)->pwwn = (bfa->iocfc.cfgrsp)->pbc_cfg.pbc_pwwn;
    (bfa->ioc.attr)->nwwn = (bfa->iocfc.cfgrsp)->pbc_cfg.pbc_nwwn;
    (*(iocfc->fsm))((void *)iocfc, 10);
  } else {

  }
  return;
}
}
void bfa_iocfc_reset_queues(struct bfa_s *bfa ) 
{ 
  int q ;
    klee_make_symbolic(&q, sizeof(int), "q");

  {
  q = 0;
  goto ldv_48695;
  ldv_48694: 
  *((u32 *)bfa->iocfc.req_cq_shadow_ci[q].kva) = 0U;
  bfa->iocfc.req_cq_pi[q] = 0U;
  bfa->iocfc.rsp_cq_ci[q] = 0U;
  *((u32 *)bfa->iocfc.rsp_cq_shadow_pi[q].kva) = 0U;
  q = q + 1;
  ldv_48695: ;
  if (q <= 3) {
    goto ldv_48694;
  } else {

  }

  return;
}
}
static void bfa_iocfc_process_faa_addr(struct bfa_s *bfa , struct bfi_faa_addr_msg_s *msg ) 
{ 
  struct bfa_iocfc_s *iocfc ;
  struct bfi_iocfc_cfgrsp_s *cfgrsp ;

  {
  iocfc = & bfa->iocfc;
  cfgrsp = iocfc->cfgrsp;
  cfgrsp->pbc_cfg.pbc_pwwn = msg->pwwn;
  cfgrsp->pbc_cfg.pbc_nwwn = msg->nwwn;
  (bfa->ioc.attr)->pwwn = msg->pwwn;
  (bfa->ioc.attr)->nwwn = msg->nwwn;
  (*(iocfc->fsm))((void *)iocfc, 10);
  return;
}
}
static enum bfa_status bfa_faa_validate_request(struct bfa_s *bfa ) 
{ 
  enum bfa_ioc_type_e ioc_type ;
  enum bfa_ioc_type_e tmp ;
  u32 card_type ;
  enum bfa_boolean tmp___0 ;

  {
  tmp = bfa_ioc_get_type(& bfa->ioc);
  ioc_type = tmp;
  card_type = (bfa->ioc.attr)->card_type;
  tmp___0 = bfa_ioc_is_operational(& bfa->ioc);
  if ((unsigned int )tmp___0 != 0U) {
    if ((unsigned int )ioc_type != 1U || ((((((card_type == 804U || card_type == 1007U) || card_type == 807U) || card_type == 902U) || card_type == 1741U) || card_type == 1867U) || card_type == 1869U)) {
      return (192);
    } else {

    }
  } else {
    return (61);
  }
  return (0);
}
}
enum bfa_status bfa_faa_query(struct bfa_s *bfa , struct bfa_faa_attr_s *attr , void (*cbfn)(void * ,
                                                                                             enum bfa_status  ) ,
                              void *cbarg ) 
{ 
  struct bfi_faa_query_s faa_attr_req ;
  struct bfa_iocfc_s *iocfc ;
  enum bfa_status status ;

  {
  iocfc = & bfa->iocfc;
  status = bfa_faa_validate_request(bfa);
  if ((unsigned int )status != 0U) {
    return (status);
  } else {

  }
  if ((unsigned int )iocfc->faa_args.busy == 1U) {
    return (13);
  } else {

  }
  iocfc->faa_args.faa_attr = attr;
  iocfc->faa_args.faa_cb.faa_cbfn = cbfn;
  iocfc->faa_args.faa_cb.faa_cbarg = cbarg;
  iocfc->faa_args.busy = 1;
  memset((void *)(& faa_attr_req), 0, 16UL);
  faa_attr_req.mh.msg_class = 6U;
  faa_attr_req.mh.msg_id = 4U;
  faa_attr_req.mh.mtag.h2i.fn_lpu = (u8 )((int )((signed char )((int )bfa->ioc.pcidev.pci_func << 1)) | (int )((signed char )bfa->ioc.port_id));
  bfa_ioc_mbox_send(& bfa->ioc, (void *)(& faa_attr_req), 16);
  return (0);
}
}
static void bfa_faa_query_reply(struct bfa_iocfc_s *iocfc , struct bfi_faa_query_s *rsp ) 
{ 
  void *cbarg ;
  int __ret_warn_on ;
  long tmp ;

  {
  cbarg = iocfc->faa_args.faa_cb.faa_cbarg;
  if ((unsigned long )iocfc->faa_args.faa_attr != (unsigned long )((struct bfa_faa_attr_s *)0)) {
    (iocfc->faa_args.faa_attr)->faa = rsp->faa;
    (iocfc->faa_args.faa_attr)->faa_state = rsp->faa_status;
    (iocfc->faa_args.faa_attr)->pwwn_source = rsp->addr_source;
  } else {

  }
  __ret_warn_on = (unsigned long )iocfc->faa_args.faa_cb.faa_cbfn == (unsigned long )((void (*)(void * ,
                                                                                                enum bfa_status  ))0);
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_core.c",
                       1407);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  (*(iocfc->faa_args.faa_cb.faa_cbfn))(cbarg, 0);
  iocfc->faa_args.busy = 0;
  return;
}
}
static void bfa_iocfc_enable_cbfn(void *bfa_arg , enum bfa_status status ) 
{ 
  struct bfa_s *bfa ;

  {
  bfa = (struct bfa_s *)bfa_arg;
  if ((unsigned int )status == 0U) {
    (*(bfa->iocfc.fsm))((void *)(& bfa->iocfc), 6);
  } else {
    (*(bfa->iocfc.fsm))((void *)(& bfa->iocfc), 8);
  }
  return;
}
}
static void bfa_iocfc_disable_cbfn(void *bfa_arg ) 
{ 
  struct bfa_s *bfa ;

  {
  bfa = (struct bfa_s *)bfa_arg;
  bfa->queue_process = 0;
  (*(bfa->iocfc.fsm))((void *)(& bfa->iocfc), 7);
  return;
}
}
static void bfa_iocfc_hbfail_cbfn(void *bfa_arg ) 
{ 
  struct bfa_s *bfa ;

  {
  bfa = (struct bfa_s *)bfa_arg;
  bfa->queue_process = 0;
  (*(bfa->iocfc.fsm))((void *)(& bfa->iocfc), 8);
  return;
}
}
static void bfa_iocfc_reset_cbfn(void *bfa_arg ) 
{ 
  struct bfa_s *bfa ;

  {
  bfa = (struct bfa_s *)bfa_arg;
  bfa_iocfc_reset_queues(bfa);
  bfa_isr_enable(bfa);
  return;
}
}
void bfa_iocfc_meminfo(struct bfa_iocfc_cfg_s *cfg , struct bfa_meminfo_s *meminfo ,
                       struct bfa_s *bfa ) 
{ 
  int q ;
  int per_reqq_sz ;
  int per_rspq_sz ;
  struct bfa_mem_dma_s *ioc_dma ;
  struct bfa_mem_dma_s *iocfc_dma ;
  struct bfa_mem_kva_s *iocfc_kva ;
  u32 dm_len ;

  {
  ioc_dma = & bfa->iocfc.ioc_dma;
  iocfc_dma = & bfa->iocfc.iocfc_dma;
  iocfc_kva = & bfa->iocfc.kva_seg;
  dm_len = 0U;
  ioc_dma->mem_len = 768U;
  list_add_tail(& ioc_dma->qe, & meminfo->dma_info.qe);
  per_reqq_sz = ((int )cfg->drvcfg.num_reqq_elems * 128 + 255) & -256;
  per_rspq_sz = ((int )cfg->drvcfg.num_rspq_elems * 128 + 255) & -256;
  q = 0;
  goto ldv_48754;
  ldv_48753: 
  ((struct bfa_mem_dma_s *)(& bfa->iocfc.reqq_dma) + (unsigned long )q)->mem_len = (u32 )per_reqq_sz;
  if (per_reqq_sz != 0) {
    list_add_tail(& ((struct bfa_mem_dma_s *)(& bfa->iocfc.reqq_dma) + (unsigned long )q)->qe,
                  & meminfo->dma_info.qe);
  } else {

  }
  ((struct bfa_mem_dma_s *)(& bfa->iocfc.rspq_dma) + (unsigned long )q)->mem_len = (u32 )per_rspq_sz;
  if (per_rspq_sz != 0) {
    list_add_tail(& ((struct bfa_mem_dma_s *)(& bfa->iocfc.rspq_dma) + (unsigned long )q)->qe,
                  & meminfo->dma_info.qe);
  } else {

  }
  q = q + 1;
  ldv_48754: ;
  if ((int )cfg->fwcfg.num_cqs > q) {
    goto ldv_48753;
  } else {

  }
  q = 0;
  goto ldv_48757;
  ldv_48756: 
  dm_len = dm_len + 512U;
  q = q + 1;
  ldv_48757: ;
  if ((int )cfg->fwcfg.num_cqs > q) {
    goto ldv_48756;
  } else {

  }
  dm_len = dm_len + 256U;
  dm_len = dm_len + 768U;
  iocfc_dma->mem_len = dm_len;
  if (dm_len != 0U) {
    list_add_tail(& iocfc_dma->qe, & meminfo->dma_info.qe);
  } else {

  }
  iocfc_kva->mem_len = 4128U;
  list_add_tail(& iocfc_kva->qe, & meminfo->kva_info.qe);
  return;
}
}
void bfa_iocfc_attach(struct bfa_s *bfa , void *bfad , struct bfa_iocfc_cfg_s *cfg ,
                      struct bfa_pcidev_s *pcidev ) 
{ 
  int i ;
  struct bfa_ioc_s *ioc ;

  {
  ioc = & bfa->ioc;
  bfa_iocfc_cbfn.enable_cbfn = & bfa_iocfc_enable_cbfn;
  bfa_iocfc_cbfn.disable_cbfn = & bfa_iocfc_disable_cbfn;
  bfa_iocfc_cbfn.hbfail_cbfn = & bfa_iocfc_hbfail_cbfn;
  bfa_iocfc_cbfn.reset_cbfn = & bfa_iocfc_reset_cbfn;
  ioc->trcmod = bfa->trcmod;
  bfa_ioc_attach(& bfa->ioc, (void *)bfa, & bfa_iocfc_cbfn, & bfa->timer_mod);
  bfa_ioc_pci_init(& bfa->ioc, pcidev, 3076);
  bfa_ioc_mbox_register(& bfa->ioc, (bfa_ioc_mbox_mcfunc_t (**)(void * , struct bfi_mbmsg_s * ))(& bfa_mbox_isrs));
  bfa_iocfc_init_mem(bfa, bfad, cfg, pcidev);
  bfa_iocfc_mem_claim(bfa, cfg);
  INIT_LIST_HEAD(& bfa->timer_mod.timer_q);
  INIT_LIST_HEAD(& bfa->comp_q);
  i = 0;
  goto ldv_48768;
  ldv_48767: 
  INIT_LIST_HEAD((struct list_head *)(& bfa->reqq_waitq) + (unsigned long )i);
  i = i + 1;
  ldv_48768: ;
  if (i <= 3) {
    goto ldv_48767;
  } else {

  }
  bfa->iocfc.cb_reqd = 0;
  bfa->iocfc.op_status = 0;
  bfa->iocfc.submod_enabled = 0;
  bfa->iocfc.fsm = (void (*)(void * , int  ))(& bfa_iocfc_sm_stopped);
  bfa_iocfc_sm_stopped_entry(& bfa->iocfc);
  return;
}
}
void bfa_iocfc_init(struct bfa_s *bfa ) 
{ 


  {
  (*(bfa->iocfc.fsm))((void *)(& bfa->iocfc), 1);
  return;
}
}
void bfa_iocfc_start(struct bfa_s *bfa ) 
{ 


  {
  (*(bfa->iocfc.fsm))((void *)(& bfa->iocfc), 2);
  return;
}
}
void bfa_iocfc_stop(struct bfa_s *bfa ) 
{ 


  {
  (*(bfa->iocfc.fsm))((void *)(& bfa->iocfc), 3);
  return;
}
}
void bfa_iocfc_isr(void *bfaarg , struct bfi_mbmsg_s *m ) 
{ 
  struct bfa_s *bfa ;
  struct bfa_iocfc_s *iocfc ;
  union bfi_iocfc_i2h_msg_u *msg ;
  int __ret_warn_on ;
  long tmp ;

  {
  bfa = (struct bfa_s *)bfaarg;
  iocfc = & bfa->iocfc;
  msg = (union bfi_iocfc_i2h_msg_u *)m;
  __bfa_trc(bfa->trcmod, __trc_fileno___12, 1582, (unsigned long long )msg->mh.msg_id);
  switch ((int )msg->mh.msg_id) {
  case 129: 
  bfa_iocfc_cfgrsp(bfa);
  goto ldv_48787;
  case 131: 
  (*(iocfc->updateq_cbfn))(iocfc->updateq_cbarg, 0);
  goto ldv_48787;
  case 133: 
  bfa_iocfc_process_faa_addr(bfa, (struct bfi_faa_addr_msg_s *)msg);
  goto ldv_48787;
  case 132: 
  bfa_faa_query_reply(iocfc, (struct bfi_faa_query_s *)msg);
  goto ldv_48787;
  default: 
  __ret_warn_on = 1;
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_core.c",
                       1599);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  }
  ldv_48787: ;
  return;
}
}
void bfa_iocfc_get_attr(struct bfa_s *bfa , struct bfa_iocfc_attr_s *attr ) 
{ 
  struct bfa_iocfc_s *iocfc ;
  __u16 tmp ;
  __u16 tmp___0 ;
  __u16 tmp___1 ;
  __u16 tmp___2 ;

  {
  iocfc = & bfa->iocfc;
  attr->intr_attr.coalesce = (iocfc->cfginfo)->intr_attr.coalesce;
  if ((unsigned int )(iocfc->cfginfo)->intr_attr.delay != 0U) {
    tmp = __fswab16((int )(iocfc->cfginfo)->intr_attr.delay);
    attr->intr_attr.delay = tmp;
  } else {
    tmp___0 = __fswab16((int )(iocfc->cfgrsp)->intr_attr.delay);
    attr->intr_attr.delay = tmp___0;
  }
  if ((unsigned int )(iocfc->cfginfo)->intr_attr.latency != 0U) {
    tmp___1 = __fswab16((int )(iocfc->cfginfo)->intr_attr.latency);
    attr->intr_attr.latency = tmp___1;
  } else {
    tmp___2 = __fswab16((int )(iocfc->cfgrsp)->intr_attr.latency);
    attr->intr_attr.latency = tmp___2;
  }
  attr->config = iocfc->cfg;
  return;
}
}
enum bfa_status bfa_iocfc_israttr_set(struct bfa_s *bfa , struct bfa_iocfc_intr_attr_s *attr ) 
{ 
  struct bfa_iocfc_s *iocfc ;
  struct bfi_iocfc_set_intr_req_s *m ;
  __u16 tmp ;
  __u16 tmp___0 ;
  enum bfa_boolean tmp___1 ;

  {
  iocfc = & bfa->iocfc;
  (iocfc->cfginfo)->intr_attr.coalesce = attr->coalesce;
  tmp = __fswab16((int )attr->delay);
  (iocfc->cfginfo)->intr_attr.delay = tmp;
  tmp___0 = __fswab16((int )attr->latency);
  (iocfc->cfginfo)->intr_attr.latency = tmp___0;
  tmp___1 = bfa_iocfc_is_operational(bfa);
  if ((unsigned int )tmp___1 == 0U) {
    return (0);
  } else {

  }
  m = ((bfa->iocfc.req_cq_pi[0] + 1U) & (u32 )((int )bfa->iocfc.cfg.drvcfg.num_reqq_elems + -1)) != *((u32 *)bfa->iocfc.req_cq_shadow_ci[0].kva) ? (struct bfi_iocfc_set_intr_req_s *)bfa->iocfc.req_cq_ba[0].kva + (unsigned long )bfa->iocfc.req_cq_pi[0] : (struct bfi_iocfc_set_intr_req_s *)0;
  if ((unsigned long )m == (unsigned long )((struct bfi_iocfc_set_intr_req_s *)0)) {
    return (13);
  } else {

  }
  m->mh.msg_class = 6U;
  m->mh.msg_id = 2U;
  m->mh.mtag.h2i.fn_lpu = (u8 )((int )((signed char )((int )bfa->ioc.pcidev.pci_func << 1)) | (int )((signed char )bfa->ioc.port_id));
  m->coalesce = (iocfc->cfginfo)->intr_attr.coalesce;
  m->delay = (iocfc->cfginfo)->intr_attr.delay;
  m->latency = (iocfc->cfginfo)->intr_attr.latency;
  __bfa_trc(bfa->trcmod, __trc_fileno___12, 1644, (unsigned long long )attr->delay);
  __bfa_trc(bfa->trcmod, __trc_fileno___12, 1645, (unsigned long long )attr->latency);
  m->mh.mtag.h2i.qid = bfa->iocfc.hw_qid[0];
  bfa->iocfc.req_cq_pi[0] = bfa->iocfc.req_cq_pi[0] + 1U;
  bfa->iocfc.req_cq_pi[0] = bfa->iocfc.req_cq_pi[0] & (u32 )((int )bfa->iocfc.cfg.drvcfg.num_reqq_elems + -1);
  writel(bfa->iocfc.req_cq_pi[0], (void volatile   *)bfa->iocfc.bfa_regs.cpe_q_pi[0]);
  __asm__  volatile   ("": : : "memory");
  return (0);
}
}
void bfa_iocfc_set_snsbase(struct bfa_s *bfa , int seg_no , u64 snsbase_pa ) 
{ 
  struct bfa_iocfc_s *iocfc ;

  {
  iocfc = & bfa->iocfc;
  (iocfc->cfginfo)->sense_buf_len = 255U;
  __bfa_dma_be_addr_set((union bfi_addr_u *)(& (iocfc->cfginfo)->ioim_snsbase) + (unsigned long )seg_no,
                        snsbase_pa);
  return;
}
}
void bfa_iocfc_enable(struct bfa_s *bfa ) 
{ 


  {
  bfa_plog_str(bfa->plog, 3, 19, 0, (char *)"IOC Enable");
  bfa->iocfc.cb_reqd = 1;
  (*(bfa->iocfc.fsm))((void *)(& bfa->iocfc), 4);
  return;
}
}
void bfa_iocfc_disable(struct bfa_s *bfa ) 
{ 


  {
  bfa_plog_str(bfa->plog, 3, 19, 0, (char *)"IOC Disable");
  (*(bfa->iocfc.fsm))((void *)(& bfa->iocfc), 5);
  return;
}
}
enum bfa_boolean bfa_iocfc_is_operational(struct bfa_s *bfa ) 
{ 
  enum bfa_boolean tmp ;

  {
  tmp = bfa_ioc_is_operational(& bfa->ioc);
  return ((enum bfa_boolean )((unsigned int )tmp != 0U && (unsigned long )bfa->iocfc.fsm == (unsigned long )((void (*)(void * ,
                                                                                                                       int  ))(& bfa_iocfc_sm_operational))));
}
}
void bfa_iocfc_get_bootwwns(struct bfa_s *bfa , u8 *nwwns , wwn_t *wwns ) 
{ 
  struct bfa_iocfc_s *iocfc ;
  struct bfi_iocfc_cfgrsp_s *cfgrsp ;
  int i ;

  {
  iocfc = & bfa->iocfc;
  cfgrsp = iocfc->cfgrsp;
  if ((unsigned int )cfgrsp->pbc_cfg.boot_enabled != 0U && (unsigned int )cfgrsp->pbc_cfg.nbluns != 0U) {
    __bfa_trc(bfa->trcmod, __trc_fileno___12, 1698, (unsigned long long )cfgrsp->pbc_cfg.nbluns);
    *nwwns = cfgrsp->pbc_cfg.nbluns;
    i = 0;
    goto ldv_48829;
    ldv_48828: 
    *(wwns + (unsigned long )i) = cfgrsp->pbc_cfg.blun[i].tgt_pwwn;
    i = i + 1;
    ldv_48829: ;
    if ((int )cfgrsp->pbc_cfg.nbluns > i) {
      goto ldv_48828;
    } else {

    }

    return;
  } else {

  }
  *nwwns = cfgrsp->bootwwns.nwwns;
  memcpy((void *)wwns, (void const   *)(& cfgrsp->bootwwns.wwn), 32UL);
  return;
}
}
int bfa_iocfc_get_pbc_vports(struct bfa_s *bfa , struct bfi_pbc_vport_s *pbc_vport ) 
{ 
  struct bfa_iocfc_s *iocfc ;
  struct bfi_iocfc_cfgrsp_s *cfgrsp ;

  {
  iocfc = & bfa->iocfc;
  cfgrsp = iocfc->cfgrsp;
  memcpy((void *)pbc_vport, (void const   *)(& cfgrsp->pbc_cfg.vport), 256UL);
  return ((int )cfgrsp->pbc_cfg.nvports);
}
}
void bfa_cfg_get_meminfo(struct bfa_iocfc_cfg_s *cfg , struct bfa_meminfo_s *meminfo ,
                         struct bfa_s *bfa ) 
{ 
  int i ;
  struct bfa_mem_dma_s *port_dma ;
  struct bfa_mem_dma_s *ablk_dma ;
  struct bfa_mem_dma_s *cee_dma ;
  struct bfa_mem_dma_s *sfp_dma ;
  struct bfa_mem_dma_s *flash_dma ;
  struct bfa_mem_dma_s *diag_dma ;
  struct bfa_mem_dma_s *phy_dma ;
  struct bfa_mem_dma_s *fru_dma ;
  int __ret_warn_on ;
  long tmp ;
  u32 tmp___0 ;
  u32 tmp___1 ;
  u32 tmp___2 ;
  u32 tmp___3 ;
  u32 tmp___4 ;
  u32 tmp___5 ;
  u32 tmp___6 ;
  u32 tmp___7 ;

  {
  port_dma = & bfa->modules.port.port_dma;
  ablk_dma = & bfa->modules.ablk.ablk_dma;
  cee_dma = & bfa->modules.cee.cee_dma;
  sfp_dma = & bfa->modules.sfp.sfp_dma;
  flash_dma = & bfa->modules.flash.flash_dma;
  diag_dma = & bfa->modules.diag_mod.diag_dma;
  phy_dma = & bfa->modules.phy.phy_dma;
  fru_dma = & bfa->modules.fru.fru_dma;
  __ret_warn_on = (unsigned long )cfg == (unsigned long )((struct bfa_iocfc_cfg_s *)0) || (unsigned long )meminfo == (unsigned long )((struct bfa_meminfo_s *)0);
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_core.c",
                       1766);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  memset((void *)meminfo, 0, 96UL);
  INIT_LIST_HEAD(& meminfo->dma_info.qe);
  INIT_LIST_HEAD(& meminfo->kva_info.qe);
  bfa_iocfc_meminfo(cfg, meminfo, bfa);
  i = 0;
  goto ldv_48854;
  ldv_48853: 
  (*((hal_mods[i])->meminfo))(cfg, meminfo, bfa);
  i = i + 1;
  ldv_48854: ;
  if ((unsigned long )hal_mods[i] != (unsigned long )((struct bfa_module_s *)0)) {
    goto ldv_48853;
  } else {

  }
  port_dma->mem_len = bfa_port_meminfo();
  tmp___0 = bfa_port_meminfo();
  if (tmp___0 != 0U) {
    list_add_tail(& port_dma->qe, & meminfo->dma_info.qe);
  } else {

  }
  ablk_dma->mem_len = bfa_ablk_meminfo();
  tmp___1 = bfa_ablk_meminfo();
  if (tmp___1 != 0U) {
    list_add_tail(& ablk_dma->qe, & meminfo->dma_info.qe);
  } else {

  }
  cee_dma->mem_len = bfa_cee_meminfo();
  tmp___2 = bfa_cee_meminfo();
  if (tmp___2 != 0U) {
    list_add_tail(& cee_dma->qe, & meminfo->dma_info.qe);
  } else {

  }
  sfp_dma->mem_len = bfa_sfp_meminfo();
  tmp___3 = bfa_sfp_meminfo();
  if (tmp___3 != 0U) {
    list_add_tail(& sfp_dma->qe, & meminfo->dma_info.qe);
  } else {

  }
  flash_dma->mem_len = bfa_flash_meminfo((enum bfa_boolean )cfg->drvcfg.min_cfg);
  tmp___4 = bfa_flash_meminfo((enum bfa_boolean )cfg->drvcfg.min_cfg);
  if (tmp___4 != 0U) {
    list_add_tail(& flash_dma->qe, & meminfo->dma_info.qe);
  } else {

  }
  diag_dma->mem_len = bfa_diag_meminfo();
  tmp___5 = bfa_diag_meminfo();
  if (tmp___5 != 0U) {
    list_add_tail(& diag_dma->qe, & meminfo->dma_info.qe);
  } else {

  }
  phy_dma->mem_len = bfa_phy_meminfo((enum bfa_boolean )cfg->drvcfg.min_cfg);
  tmp___6 = bfa_phy_meminfo((enum bfa_boolean )cfg->drvcfg.min_cfg);
  if (tmp___6 != 0U) {
    list_add_tail(& phy_dma->qe, & meminfo->dma_info.qe);
  } else {

  }
  fru_dma->mem_len = bfa_fru_meminfo((enum bfa_boolean )cfg->drvcfg.min_cfg);
  tmp___7 = bfa_fru_meminfo((enum bfa_boolean )cfg->drvcfg.min_cfg);
  if (tmp___7 != 0U) {
    list_add_tail(& fru_dma->qe, & meminfo->dma_info.qe);
  } else {

  }
  return;
}
}
void bfa_attach(struct bfa_s *bfa , void *bfad , struct bfa_iocfc_cfg_s *cfg , struct bfa_meminfo_s *meminfo ,
                struct bfa_pcidev_s *pcidev ) 
{ 
  int i ;
  struct bfa_mem_dma_s *dma_info ;
  struct bfa_mem_dma_s *dma_elem ;
  struct bfa_mem_kva_s *kva_info ;
  struct bfa_mem_kva_s *kva_elem ;
  struct list_head *dm_qe ;
  struct list_head *km_qe ;
  int __ret_warn_on ;
  long tmp ;

  {
  bfa->fcs = 0;
  __ret_warn_on = (unsigned long )cfg == (unsigned long )((struct bfa_iocfc_cfg_s *)0) || (unsigned long )meminfo == (unsigned long )((struct bfa_meminfo_s *)0);
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_core.c",
                       1830);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  dma_info = & meminfo->dma_info;
  dma_info->kva_curp = dma_info->kva;
  dma_info->dma_curp = dma_info->dma;
  kva_info = & meminfo->kva_info;
  kva_info->kva_curp = kva_info->kva;
  dm_qe = dma_info->qe.next;
  goto ldv_48873;
  ldv_48872: 
  dma_elem = (struct bfa_mem_dma_s *)dm_qe;
  dma_elem->kva_curp = dma_elem->kva;
  dma_elem->dma_curp = dma_elem->dma;
  dm_qe = dm_qe->next;
  ldv_48873: ;
  if ((unsigned long )(& dma_info->qe) != (unsigned long )dm_qe) {
    goto ldv_48872;
  } else {

  }
  km_qe = kva_info->qe.next;
  goto ldv_48876;
  ldv_48875: 
  kva_elem = (struct bfa_mem_kva_s *)km_qe;
  kva_elem->kva_curp = kva_elem->kva;
  km_qe = km_qe->next;
  ldv_48876: ;
  if ((unsigned long )(& kva_info->qe) != (unsigned long )km_qe) {
    goto ldv_48875;
  } else {

  }
  bfa_iocfc_attach(bfa, bfad, cfg, pcidev);
  i = 0;
  goto ldv_48879;
  ldv_48878: 
  (*((hal_mods[i])->attach))(bfa, bfad, cfg, pcidev);
  i = i + 1;
  ldv_48879: ;
  if ((unsigned long )hal_mods[i] != (unsigned long )((struct bfa_module_s *)0)) {
    goto ldv_48878;
  } else {

  }
  bfa_com_port_attach(bfa);
  bfa_com_ablk_attach(bfa);
  bfa_com_cee_attach(bfa);
  bfa_com_sfp_attach(bfa);
  bfa_com_flash_attach(bfa, (enum bfa_boolean )cfg->drvcfg.min_cfg);
  bfa_com_diag_attach(bfa);
  bfa_com_phy_attach(bfa, (enum bfa_boolean )cfg->drvcfg.min_cfg);
  bfa_com_fru_attach(bfa, (enum bfa_boolean )cfg->drvcfg.min_cfg);
  return;
}
}
void bfa_detach(struct bfa_s *bfa ) 
{ 
  int i ;

  {
  i = 0;
  goto ldv_48886;
  ldv_48885: 
  (*((hal_mods[i])->detach))(bfa);
  i = i + 1;
  ldv_48886: ;
  if ((unsigned long )hal_mods[i] != (unsigned long )((struct bfa_module_s *)0)) {
    goto ldv_48885;
  } else {

  }
  bfa_ioc_detach(& bfa->ioc);
  return;
}
}
void bfa_comp_deq(struct bfa_s *bfa , struct list_head *comp_q ) 
{ 


  {
  INIT_LIST_HEAD(comp_q);
  list_splice_tail_init(& bfa->comp_q, comp_q);
  return;
}
}
void bfa_comp_process(struct bfa_s *bfa , struct list_head *comp_q ) 
{ 
  struct list_head *qe ;
  struct list_head *qen ;
  struct bfa_cb_qe_s *hcb_qe ;
  void (*cbfn)(void * , enum bfa_status  ) ;

  {
  qe = comp_q->next;
  qen = qe->next;
  goto ldv_48901;
  ldv_48900: 
  hcb_qe = (struct bfa_cb_qe_s *)qe;
  if ((unsigned int )hcb_qe->pre_rmv != 0U) {
    list_del(qe);
    cbfn = (void (*)(void * , enum bfa_status  ))hcb_qe->cbfn;
    (*cbfn)(hcb_qe->cbarg, hcb_qe->fw_status);
  } else {
    (*(hcb_qe->cbfn))(hcb_qe->cbarg, 1);
  }
  qe = qen;
  qen = qe->next;
  ldv_48901: ;
  if ((unsigned long )qe != (unsigned long )comp_q) {
    goto ldv_48900;
  } else {

  }

  return;
}
}
void bfa_comp_free(struct bfa_s *bfa , struct list_head *comp_q ) 
{ 
  struct list_head *qe ;
  struct bfa_cb_qe_s *hcb_qe ;
  int tmp ;
  int __ret_warn_on ;
  long tmp___0 ;
  int tmp___1 ;

  {
  goto ldv_48912;
  ldv_48911: 
  tmp = list_empty((struct list_head  const  *)comp_q);
  if (tmp == 0) {
    qe = comp_q->next;
    (qe->next)->prev = comp_q;
    comp_q->next = qe->next;
  } else {
    qe = (struct list_head *)0;
  }
  hcb_qe = (struct bfa_cb_qe_s *)qe;
  __ret_warn_on = (unsigned int )hcb_qe->pre_rmv != 0U;
  tmp___0 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp___0 != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_core.c",
                       1925);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  (*(hcb_qe->cbfn))(hcb_qe->cbarg, 0);
  ldv_48912: 
  tmp___1 = list_empty((struct list_head  const  *)comp_q);
  if (tmp___1 == 0) {
    goto ldv_48911;
  } else {

  }

  return;
}
}
void bfa_get_pciids(struct bfa_pciid_s **pciids , int *npciids ) 
{ 
  struct bfa_pciid_s __pciids[4U] ;

  {
  __pciids[0].device_id = 5719U;
  __pciids[0].vendor_id = 19U;
  __pciids[1].device_id = 5719U;
  __pciids[1].vendor_id = 23U;
  __pciids[2].device_id = 5719U;
  __pciids[2].vendor_id = 20U;
  __pciids[3].device_id = 5719U;
  __pciids[3].vendor_id = 33U;
  *npciids = 4;
  *pciids = (struct bfa_pciid_s *)(& __pciids);
  return;
}
}
void bfa_cfg_get_default(struct bfa_iocfc_cfg_s *cfg ) 
{ 


  {
  cfg->fwcfg.num_fabrics = 1U;
  cfg->fwcfg.num_lports = 256U;
  cfg->fwcfg.num_rports = 1024U;
  cfg->fwcfg.num_ioim_reqs = 2000U;
  cfg->fwcfg.num_tskim_reqs = 128U;
  cfg->fwcfg.num_fcxp_reqs = 64U;
  cfg->fwcfg.num_uf_bufs = 64U;
  cfg->fwcfg.num_cqs = 4U;
  cfg->fwcfg.num_fwtio_reqs = 0U;
  cfg->drvcfg.num_reqq_elems = 256U;
  cfg->drvcfg.num_rspq_elems = 64U;
  cfg->drvcfg.num_sgpgs = 2048U;
  cfg->drvcfg.num_sboot_tgts = 16U;
  cfg->drvcfg.num_sboot_luns = 16U;
  cfg->drvcfg.path_tov = 30000U;
  cfg->drvcfg.ioc_recover = 0U;
  cfg->drvcfg.delay_comp = 0;
  return;
}
}
void bfa_cfg_get_min(struct bfa_iocfc_cfg_s *cfg ) 
{ 


  {
  bfa_cfg_get_default(cfg);
  cfg->fwcfg.num_ioim_reqs = 8U;
  cfg->fwcfg.num_tskim_reqs = 4U;
  cfg->fwcfg.num_fcxp_reqs = 1U;
  cfg->fwcfg.num_uf_bufs = 4U;
  cfg->fwcfg.num_rports = 4U;
  cfg->fwcfg.num_fwtio_reqs = 0U;
  cfg->drvcfg.num_sgpgs = 16U;
  cfg->drvcfg.num_reqq_elems = 4U;
  cfg->drvcfg.num_rspq_elems = 4U;
  cfg->drvcfg.min_cfg = 1U;
  return;
}
}
bool ldv_queue_work_on_597(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_3(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_delayed_work_on_598(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_3(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_work_on_599(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_3(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
void ldv_flush_workqueue_600(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
  flush_workqueue(ldv_func_arg1);
  call_and_disable_all_3(2);
  return;
}
}
bool ldv_queue_delayed_work_on_601(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_3(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
void ldv_mutex_lock_602(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_lock_lock(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_603(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_unlock_lock(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_604(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
int ldv_mutex_trylock_605(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
  tmp = mutex_trylock(ldv_func_arg1);
  ldv_func_res = tmp;
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
  return (tmp___0);
  return (ldv_func_res);
}
}
void ldv_mutex_unlock_606(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_607(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_unlock_i_mutex_of_inode(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_608(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_lock_i_mutex_of_inode(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
int ldv_scsi_add_host_with_dma_609(struct Scsi_Host *shost , struct device *dev ,
                                   struct device *dma_dev ) 
{ 
  ldv_func_ret_type___4 ldv_func_res ;
  int tmp ;

  {
  tmp = scsi_add_host_with_dma(shost, dev, dma_dev);
  ldv_func_res = tmp;
  if (ldv_func_res == 0) {
    ldv_state_variable_35 = 1;
    ldv_initialize_scsi_host_template_35();
  } else {

  }
  return (ldv_func_res);
}
}
__inline static long ldv__builtin_expect(long exp , long c ) ;
int ldv_mutex_trylock_635(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_633(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_636(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_unlock_637(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_632(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_634(struct mutex *ldv_func_arg1 ) ;
void ldv_mutex_lock_638(struct mutex *ldv_func_arg1 ) ;
bool ldv_queue_work_on_627(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_work_on_629(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) ;
bool ldv_queue_delayed_work_on_628(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
bool ldv_queue_delayed_work_on_631(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) ;
void ldv_flush_workqueue_630(struct workqueue_struct *ldv_func_arg1 ) ;
__inline static bool queue_work___5(struct workqueue_struct *wq , struct work_struct *work ) 
{ 
  bool tmp ;

  {
  tmp = ldv_queue_work_on_627(8192, wq, work);
  return (tmp);
}
}
int ldv_scsi_add_host_with_dma_639(struct Scsi_Host *shost , struct device *dev ,
                                   struct device *dma_dev ) ;
__inline static void wwn2str___5(char *wwn_str , u64 wwn ) 
{ 
  union __anonunion_w_281___4 w ;

  {
  w.wwn = wwn;
  sprintf(wwn_str, "%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x", (int )w.byte[0], (int )w.byte[1],
          (int )w.byte[2], (int )w.byte[3], (int )w.byte[4], (int )w.byte[5], (int )w.byte[6],
          (int )w.byte[7]);
  return;
}
}
void bfa_plog_intarr(struct bfa_plog_s *plog , enum bfa_plog_mid mid , enum bfa_plog_eid event ,
                     u16 misc , u32 *intarr , u32 num_ints ) ;
void bfa_plog_fchdr(struct bfa_plog_s *plog , enum bfa_plog_mid mid , enum bfa_plog_eid event ,
                    u16 misc , struct fchs_s *fchdr ) ;
void bfa_plog_fchdr_and_pl(struct bfa_plog_s *plog , enum bfa_plog_mid mid , enum bfa_plog_eid event ,
                           u16 misc , struct fchs_s *fchdr , u32 pld_w0 ) ;
enum bfa_port_speed bfa_fcport_get_speed(struct bfa_s *bfa ) ;
enum bfa_port_topology bfa_fcport_get_cfg_topology(struct bfa_s *bfa ) ;
enum bfa_boolean bfa_fcport_get_hardalpa(struct bfa_s *bfa , u8 *alpa ) ;
wwn_t bfa_fcport_get_wwn(struct bfa_s *bfa , enum bfa_boolean node ) ;
enum bfa_boolean bfa_fcport_is_ddport(struct bfa_s *bfa ) ;
enum bfa_boolean bfa_fcport_is_qos_enabled(struct bfa_s *bfa ) ;
enum bfa_boolean bfa_fcport_is_trunk_enabled(struct bfa_s *bfa ) ;
void bfa_fcport_dportenable(struct bfa_s *bfa ) ;
void bfa_fcport_dportdisable(struct bfa_s *bfa ) ;
enum bfa_status bfa_fcport_is_pbcdisabled(struct bfa_s *bfa ) ;
void bfa_fcport_cfg_faa(struct bfa_s *bfa , u8 state ) ;
void bfa_rport_set_lunmask(struct bfa_s *bfa , struct bfa_rport_s *rp ) ;
void bfa_fcxp_free(struct bfa_fcxp_s *fcxp ) ;
enum bfa_status bfa_fcxp_abort(struct bfa_fcxp_s *fcxp ) ;
u32 bfa_fcxp_get_reqbufsz(struct bfa_fcxp_s *fcxp ) ;
u8 bfa_lps_get_fwtag(struct bfa_s *bfa , u8 lp_tag ) ;
static int __trc_fileno___13  =    1026;
static void bfa_fcdiag_meminfo(struct bfa_iocfc_cfg_s *cfg , struct bfa_meminfo_s *meminfo ,
                               struct bfa_s *bfa ) ;
static void bfa_fcdiag_attach(struct bfa_s *bfa , void *bfad , struct bfa_iocfc_cfg_s *cfg ,
                              struct bfa_pcidev_s *pcidev ) ;
static void bfa_fcdiag_detach(struct bfa_s *bfa ) ;
static void bfa_fcdiag_start(struct bfa_s *bfa ) ;
static void bfa_fcdiag_stop(struct bfa_s *bfa ) ;
static void bfa_fcdiag_iocdisable(struct bfa_s *bfa ) ;
struct bfa_module_s hal_mod_fcdiag  =    {& bfa_fcdiag_meminfo, & bfa_fcdiag_attach, & bfa_fcdiag_detach, & bfa_fcdiag_start,
    & bfa_fcdiag_stop, & bfa_fcdiag_iocdisable};
static void bfa_fcxp_meminfo(struct bfa_iocfc_cfg_s *cfg , struct bfa_meminfo_s *minfo ,
                             struct bfa_s *bfa ) ;
static void bfa_fcxp_attach(struct bfa_s *bfa , void *bfad , struct bfa_iocfc_cfg_s *cfg ,
                            struct bfa_pcidev_s *pcidev ) ;
static void bfa_fcxp_detach(struct bfa_s *bfa ) ;
static void bfa_fcxp_start(struct bfa_s *bfa ) ;
static void bfa_fcxp_stop(struct bfa_s *bfa ) ;
static void bfa_fcxp_iocdisable(struct bfa_s *bfa ) ;
struct bfa_module_s hal_mod_fcxp  =    {& bfa_fcxp_meminfo, & bfa_fcxp_attach, & bfa_fcxp_detach, & bfa_fcxp_start, & bfa_fcxp_stop,
    & bfa_fcxp_iocdisable};
static void bfa_sgpg_meminfo(struct bfa_iocfc_cfg_s *cfg , struct bfa_meminfo_s *minfo ,
                             struct bfa_s *bfa ) ;
static void bfa_sgpg_attach(struct bfa_s *bfa , void *bfad , struct bfa_iocfc_cfg_s *cfg ,
                            struct bfa_pcidev_s *pcidev ) ;
static void bfa_sgpg_detach(struct bfa_s *bfa ) ;
static void bfa_sgpg_start(struct bfa_s *bfa ) ;
static void bfa_sgpg_stop(struct bfa_s *bfa ) ;
static void bfa_sgpg_iocdisable(struct bfa_s *bfa ) ;
struct bfa_module_s hal_mod_sgpg  =    {& bfa_sgpg_meminfo, & bfa_sgpg_attach, & bfa_sgpg_detach, & bfa_sgpg_start, & bfa_sgpg_stop,
    & bfa_sgpg_iocdisable};
static void bfa_lps_meminfo(struct bfa_iocfc_cfg_s *cfg , struct bfa_meminfo_s *minfo ,
                            struct bfa_s *bfa ) ;
static void bfa_lps_attach(struct bfa_s *bfa , void *bfad , struct bfa_iocfc_cfg_s *cfg ,
                           struct bfa_pcidev_s *pcidev ) ;
static void bfa_lps_detach(struct bfa_s *bfa ) ;
static void bfa_lps_start(struct bfa_s *bfa ) ;
static void bfa_lps_stop(struct bfa_s *bfa ) ;
static void bfa_lps_iocdisable(struct bfa_s *bfa ) ;
struct bfa_module_s hal_mod_lps  =    {& bfa_lps_meminfo, & bfa_lps_attach, & bfa_lps_detach, & bfa_lps_start, & bfa_lps_stop,
    & bfa_lps_iocdisable};
static void bfa_fcport_meminfo(struct bfa_iocfc_cfg_s *cfg , struct bfa_meminfo_s *minfo ,
                               struct bfa_s *bfa ) ;
static void bfa_fcport_attach(struct bfa_s *bfa , void *bfad , struct bfa_iocfc_cfg_s *cfg ,
                              struct bfa_pcidev_s *pcidev ) ;
static void bfa_fcport_detach(struct bfa_s *bfa ) ;
static void bfa_fcport_start(struct bfa_s *bfa ) ;
static void bfa_fcport_stop(struct bfa_s *bfa ) ;
static void bfa_fcport_iocdisable(struct bfa_s *bfa ) ;
struct bfa_module_s hal_mod_fcport  =    {& bfa_fcport_meminfo, & bfa_fcport_attach, & bfa_fcport_detach, & bfa_fcport_start,
    & bfa_fcport_stop, & bfa_fcport_iocdisable};
static void bfa_rport_meminfo(struct bfa_iocfc_cfg_s *cfg , struct bfa_meminfo_s *minfo ,
                              struct bfa_s *bfa ) ;
static void bfa_rport_attach(struct bfa_s *bfa , void *bfad , struct bfa_iocfc_cfg_s *cfg ,
                             struct bfa_pcidev_s *pcidev ) ;
static void bfa_rport_detach(struct bfa_s *bfa ) ;
static void bfa_rport_start(struct bfa_s *bfa ) ;
static void bfa_rport_stop(struct bfa_s *bfa ) ;
static void bfa_rport_iocdisable(struct bfa_s *bfa ) ;
struct bfa_module_s hal_mod_rport  =    {& bfa_rport_meminfo, & bfa_rport_attach, & bfa_rport_detach, & bfa_rport_start,
    & bfa_rport_stop, & bfa_rport_iocdisable};
static void bfa_uf_meminfo(struct bfa_iocfc_cfg_s *cfg , struct bfa_meminfo_s *minfo ,
                           struct bfa_s *bfa ) ;
static void bfa_uf_attach(struct bfa_s *bfa , void *bfad , struct bfa_iocfc_cfg_s *cfg ,
                          struct bfa_pcidev_s *pcidev ) ;
static void bfa_uf_detach(struct bfa_s *bfa ) ;
static void bfa_uf_start(struct bfa_s *bfa ) ;
static void bfa_uf_stop(struct bfa_s *bfa ) ;
static void bfa_uf_iocdisable(struct bfa_s *bfa ) ;
struct bfa_module_s hal_mod_uf  =    {& bfa_uf_meminfo, & bfa_uf_attach, & bfa_uf_detach, & bfa_uf_start, & bfa_uf_stop,
    & bfa_uf_iocdisable};
static void __bfa_fcxp_send_cbfn(void *cbarg , enum bfa_boolean complete___0 ) ;
static void hal_fcxp_rx_plog(struct bfa_s *bfa , struct bfa_fcxp_s *fcxp , struct bfi_fcxp_send_rsp_s *fcxp_rsp ) ;
static void hal_fcxp_tx_plog(struct bfa_s *bfa , u32 reqlen , struct bfa_fcxp_s *fcxp ,
                             struct fchs_s *fchs ) ;
static void bfa_fcxp_qresume(void *cbarg ) ;
static void bfa_fcxp_queue(struct bfa_fcxp_s *fcxp , struct bfi_fcxp_send_req_s *send_req ) ;
static void bfa_lps_login_rsp(struct bfa_s *bfa , struct bfi_lps_login_rsp_s *rsp ) ;
static void bfa_lps_no_res(struct bfa_lps_s *first_lps , u8 count ) ;
static void bfa_lps_logout_rsp(struct bfa_s *bfa , struct bfi_lps_logout_rsp_s *rsp ) ;
static void bfa_lps_reqq_resume(void *lps_arg ) ;
static void bfa_lps_free(struct bfa_lps_s *lps ) ;
static void bfa_lps_send_login(struct bfa_lps_s *lps ) ;
static void bfa_lps_send_logout(struct bfa_lps_s *lps ) ;
static void bfa_lps_send_set_n2n_pid(struct bfa_lps_s *lps ) ;
static void bfa_lps_login_comp(struct bfa_lps_s *lps ) ;
static void bfa_lps_logout_comp(struct bfa_lps_s *lps ) ;
static void bfa_lps_cvl_event(struct bfa_lps_s *lps ) ;
static void bfa_lps_sm_init(struct bfa_lps_s *lps , enum bfa_lps_event event ) ;
static void bfa_lps_sm_login(struct bfa_lps_s *lps , enum bfa_lps_event event ) ;
static void bfa_lps_sm_loginwait(struct bfa_lps_s *lps , enum bfa_lps_event event ) ;
static void bfa_lps_sm_online(struct bfa_lps_s *lps , enum bfa_lps_event event ) ;
static void bfa_lps_sm_online_n2n_pid_wait(struct bfa_lps_s *lps , enum bfa_lps_event event ) ;
static void bfa_lps_sm_logout(struct bfa_lps_s *lps , enum bfa_lps_event event ) ;
static void bfa_lps_sm_logowait(struct bfa_lps_s *lps , enum bfa_lps_event event ) ;
static enum bfa_boolean bfa_fcport_send_enable(struct bfa_fcport_s *fcport ) ;
static enum bfa_boolean bfa_fcport_send_disable(struct bfa_fcport_s *fcport ) ;
static void bfa_fcport_update_linkinfo(struct bfa_fcport_s *fcport ) ;
static void bfa_fcport_reset_linkinfo(struct bfa_fcport_s *fcport ) ;
static void bfa_fcport_set_wwns(struct bfa_fcport_s *fcport ) ;
static void __bfa_cb_fcport_event(void *cbarg , enum bfa_boolean complete___0 ) ;
static void bfa_fcport_scn(struct bfa_fcport_s *fcport , enum bfa_port_linkstate event ,
                           enum bfa_boolean trunk ) ;
static void bfa_fcport_queue_cb(struct bfa_fcport_ln_s *ln , enum bfa_port_linkstate event ) ;
static void __bfa_cb_fcport_stats_clr(void *cbarg , enum bfa_boolean complete___0 ) ;
static void bfa_fcport_stats_get_timeout(void *cbarg ) ;
static void bfa_fcport_stats_clr_timeout(void *cbarg ) ;
static void bfa_trunk_iocdisable(struct bfa_s *bfa ) ;
static void bfa_fcport_sm_uninit(struct bfa_fcport_s *fcport , enum bfa_fcport_sm_event event ) ;
static void bfa_fcport_sm_enabling_qwait(struct bfa_fcport_s *fcport , enum bfa_fcport_sm_event event ) ;
static void bfa_fcport_sm_enabling(struct bfa_fcport_s *fcport , enum bfa_fcport_sm_event event ) ;
static void bfa_fcport_sm_linkdown(struct bfa_fcport_s *fcport , enum bfa_fcport_sm_event event ) ;
static void bfa_fcport_sm_linkup(struct bfa_fcport_s *fcport , enum bfa_fcport_sm_event event ) ;
static void bfa_fcport_sm_disabling(struct bfa_fcport_s *fcport , enum bfa_fcport_sm_event event ) ;
static void bfa_fcport_sm_disabling_qwait(struct bfa_fcport_s *fcport , enum bfa_fcport_sm_event event ) ;
static void bfa_fcport_sm_toggling_qwait(struct bfa_fcport_s *fcport , enum bfa_fcport_sm_event event ) ;
static void bfa_fcport_sm_disabled(struct bfa_fcport_s *fcport , enum bfa_fcport_sm_event event ) ;
static void bfa_fcport_sm_stopped(struct bfa_fcport_s *fcport , enum bfa_fcport_sm_event event ) ;
static void bfa_fcport_sm_iocdown(struct bfa_fcport_s *fcport , enum bfa_fcport_sm_event event ) ;
static void bfa_fcport_sm_iocfail(struct bfa_fcport_s *fcport , enum bfa_fcport_sm_event event ) ;
static void bfa_fcport_sm_dport(struct bfa_fcport_s *fcport , enum bfa_fcport_sm_event event ) ;
static void bfa_fcport_sm_ddport(struct bfa_fcport_s *fcport , enum bfa_fcport_sm_event event ) ;
static void bfa_fcport_sm_faa_misconfig(struct bfa_fcport_s *fcport , enum bfa_fcport_sm_event event ) ;
static void bfa_fcport_ln_sm_dn(struct bfa_fcport_ln_s *ln , enum bfa_fcport_ln_sm_event event ) ;
static void bfa_fcport_ln_sm_dn_nf(struct bfa_fcport_ln_s *ln , enum bfa_fcport_ln_sm_event event ) ;
static void bfa_fcport_ln_sm_dn_up_nf(struct bfa_fcport_ln_s *ln , enum bfa_fcport_ln_sm_event event ) ;
static void bfa_fcport_ln_sm_up(struct bfa_fcport_ln_s *ln , enum bfa_fcport_ln_sm_event event ) ;
static void bfa_fcport_ln_sm_up_nf(struct bfa_fcport_ln_s *ln , enum bfa_fcport_ln_sm_event event ) ;
static void bfa_fcport_ln_sm_up_dn_nf(struct bfa_fcport_ln_s *ln , enum bfa_fcport_ln_sm_event event ) ;
static void bfa_fcport_ln_sm_up_dn_up_nf(struct bfa_fcport_ln_s *ln , enum bfa_fcport_ln_sm_event event ) ;
static struct bfa_sm_table_s hal_port_sm_table[15U]  = 
  {      {(void (*)(void * , int  ))(& bfa_fcport_sm_uninit), 1, 0}, 
        {(void (*)(void * , int  ))(& bfa_fcport_sm_enabling_qwait), 2, 0}, 
        {(void (*)(void * , int  ))(& bfa_fcport_sm_enabling), 3, 0}, 
        {(void (*)(void * , int  ))(& bfa_fcport_sm_linkdown), 4, 0}, 
        {(void (*)(void * , int  ))(& bfa_fcport_sm_linkup), 5, 0}, 
        {(void (*)(void * , int  ))(& bfa_fcport_sm_disabling_qwait), 6, 0}, 
        {(void (*)(void * , int  ))(& bfa_fcport_sm_toggling_qwait), 14, 0}, 
        {(void (*)(void * , int  ))(& bfa_fcport_sm_disabling), 7, 0}, 
        {(void (*)(void * , int  ))(& bfa_fcport_sm_disabled), 8, 0}, 
        {(void (*)(void * , int  ))(& bfa_fcport_sm_stopped), 9, 0}, 
        {(void (*)(void * , int  ))(& bfa_fcport_sm_iocdown), 10, 0}, 
        {(void (*)(void * , int  ))(& bfa_fcport_sm_iocfail), 10, 0}, 
        {(void (*)(void * , int  ))(& bfa_fcport_sm_dport), 16, 0}, 
        {(void (*)(void * , int  ))(& bfa_fcport_sm_ddport), 17, 0}, 
        {(void (*)(void * , int  ))(& bfa_fcport_sm_faa_misconfig), 15, 0}};
static struct bfa_rport_s *bfa_rport_alloc(struct bfa_rport_mod_s *mod ) ;
static void bfa_rport_free(struct bfa_rport_s *rport ) ;
static enum bfa_boolean bfa_rport_send_fwcreate(struct bfa_rport_s *rp ) ;
static enum bfa_boolean bfa_rport_send_fwdelete(struct bfa_rport_s *rp ) ;
static enum bfa_boolean bfa_rport_send_fwspeed(struct bfa_rport_s *rp ) ;
static void __bfa_cb_rport_online(void *cbarg , enum bfa_boolean complete___0 ) ;
static void __bfa_cb_rport_offline(void *cbarg , enum bfa_boolean complete___0 ) ;
static void bfa_rport_sm_uninit(struct bfa_rport_s *rp , enum bfa_rport_event event ) ;
static void bfa_rport_sm_created(struct bfa_rport_s *rp , enum bfa_rport_event event ) ;
static void bfa_rport_sm_fwcreate(struct bfa_rport_s *rp , enum bfa_rport_event event ) ;
static void bfa_rport_sm_online(struct bfa_rport_s *rp , enum bfa_rport_event event ) ;
static void bfa_rport_sm_fwdelete(struct bfa_rport_s *rp , enum bfa_rport_event event ) ;
static void bfa_rport_sm_offline(struct bfa_rport_s *rp , enum bfa_rport_event event ) ;
static void bfa_rport_sm_deleting(struct bfa_rport_s *rp , enum bfa_rport_event event ) ;
static void bfa_rport_sm_offline_pending(struct bfa_rport_s *rp , enum bfa_rport_event event ) ;
static void bfa_rport_sm_delete_pending(struct bfa_rport_s *rp , enum bfa_rport_event event ) ;
static void bfa_rport_sm_iocdisable(struct bfa_rport_s *rp , enum bfa_rport_event event ) ;
static void bfa_rport_sm_fwcreate_qfull(struct bfa_rport_s *rp , enum bfa_rport_event event ) ;
static void bfa_rport_sm_fwdelete_qfull(struct bfa_rport_s *rp , enum bfa_rport_event event ) ;
static void bfa_rport_sm_deleting_qfull(struct bfa_rport_s *rp , enum bfa_rport_event event ) ;
static int plkd_validate_logrec(struct bfa_plog_rec_s *pl_rec ) 
{ 


  {
  if ((unsigned int )pl_rec->log_type != 1U && (unsigned int )pl_rec->log_type != 2U) {
    return (1);
  } else {

  }
  if ((unsigned int )pl_rec->log_type != 1U && (unsigned int )pl_rec->log_num_ints > 8U) {
    return (1);
  } else {

  }
  return (0);
}
}
static u64 bfa_get_log_time(void) 
{ 
  u64 system_time ;
  struct timeval tv ;

  {
  system_time = 0ULL;
  do_gettimeofday(& tv);
  system_time = (u64 )tv.tv_sec;
  return (system_time);
}
}
static void bfa_plog_add(struct bfa_plog_s *plog , struct bfa_plog_rec_s *pl_rec ) 
{ 
  u16 tail ;
  struct bfa_plog_rec_s *pl_recp ;
  int __ret_warn_on ;
  long tmp ;
  int tmp___0 ;

  {
  if ((unsigned int )plog->plog_enabled == 0U) {
    return;
  } else {

  }
  tmp___0 = plkd_validate_logrec(pl_rec);
  if (tmp___0 != 0) {
    __ret_warn_on = 1;
    tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
    if (tmp != 0L) {
      warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_svc.c",
                         328);
    } else {

    }
    ldv__builtin_expect(__ret_warn_on != 0, 0L);
    return;
  } else {

  }
  tail = plog->tail;
  pl_recp = (struct bfa_plog_rec_s *)(& plog->plog_recs) + (unsigned long )tail;
  memcpy((void *)pl_recp, (void const   *)pl_rec, 48UL);
  pl_recp->tv = bfa_get_log_time();
  plog->tail = (u16 )((int )plog->tail + 1);
  plog->tail = (unsigned int )plog->tail & 255U;
  if ((int )plog->head == (int )plog->tail) {
    plog->head = (u16 )((int )plog->head + 1);
    plog->head = (unsigned int )plog->head & 255U;
  } else {

  }
  return;
}
}
void bfa_plog_init(struct bfa_plog_s *plog ) 
{ 
  u16 tmp ;

  {
  memset((void *)plog, 0, 12312UL);
  memcpy((void *)(& plog->plog_sig), (void const   *)"12pl123", 8UL);
  tmp = 0U;
  plog->tail = tmp;
  plog->head = tmp;
  plog->plog_enabled = 1U;
  return;
}
}
void bfa_plog_str(struct bfa_plog_s *plog , enum bfa_plog_mid mid , enum bfa_plog_eid event ,
                  u16 misc , char *log_str ) 
{ 
  struct bfa_plog_rec_s lp ;

  {
  if ((unsigned int )plog->plog_enabled != 0U) {
    memset((void *)(& lp), 0, 48UL);
    lp.mid = (u8 )mid;
    lp.eid = (u8 )event;
    lp.log_type = 2U;
    lp.misc = misc;
    strncpy((char *)(& lp.log_entry.string_log), (char const   *)log_str, 31UL);
    lp.log_entry.string_log[31] = 0;
    bfa_plog_add(plog, & lp);
  } else {

  }
  return;
}
}
void bfa_plog_intarr(struct bfa_plog_s *plog , enum bfa_plog_mid mid , enum bfa_plog_eid event ,
                     u16 misc , u32 *intarr , u32 num_ints ) 
{ 
  struct bfa_plog_rec_s lp ;
  u32 i ;

  {
  if (num_ints > 8U) {
    num_ints = 8U;
  } else {

  }
  if ((unsigned int )plog->plog_enabled != 0U) {
    memset((void *)(& lp), 0, 48UL);
    lp.mid = (u8 )mid;
    lp.eid = (u8 )event;
    lp.log_type = 1U;
    lp.misc = misc;
    i = 0U;
    goto ldv_48693;
    ldv_48692: 
    lp.log_entry.int_log[i] = *(intarr + (unsigned long )i);
    i = i + 1U;
    ldv_48693: ;
    if (i < num_ints) {
      goto ldv_48692;
    } else {

    }
    lp.log_num_ints = (unsigned char )num_ints;
    bfa_plog_add(plog, & lp);
  } else {

  }
  return;
}
}
void bfa_plog_fchdr(struct bfa_plog_s *plog , enum bfa_plog_mid mid , enum bfa_plog_eid event ,
                    u16 misc , struct fchs_s *fchdr ) 
{ 
  struct bfa_plog_rec_s lp ;
  u32 *tmp_int ;
  u32 ints[8U] ;

  {
  tmp_int = (u32 *)fchdr;
  if ((unsigned int )plog->plog_enabled != 0U) {
    memset((void *)(& lp), 0, 48UL);
    ints[0] = *tmp_int;
    ints[1] = *(tmp_int + 1UL);
    ints[2] = *(tmp_int + 4UL);
    bfa_plog_intarr(plog, mid, event, (int )misc, (u32 *)(& ints), 3U);
  } else {

  }
  return;
}
}
void bfa_plog_fchdr_and_pl(struct bfa_plog_s *plog , enum bfa_plog_mid mid , enum bfa_plog_eid event ,
                           u16 misc , struct fchs_s *fchdr , u32 pld_w0 ) 
{ 
  struct bfa_plog_rec_s lp ;
  u32 *tmp_int ;
  u32 ints[8U] ;

  {
  tmp_int = (u32 *)fchdr;
  if ((unsigned int )plog->plog_enabled != 0U) {
    memset((void *)(& lp), 0, 48UL);
    ints[0] = *tmp_int;
    ints[1] = *(tmp_int + 1UL);
    ints[2] = *(tmp_int + 4UL);
    ints[3] = pld_w0;
    bfa_plog_intarr(plog, mid, event, (int )misc, (u32 *)(& ints), 4U);
  } else {

  }
  return;
}
}
static void claim_fcxps_mem(struct bfa_fcxp_mod_s *mod ) 
{ 
  u16 i ;
  struct bfa_fcxp_s *fcxp ;

  {
  fcxp = (struct bfa_fcxp_s *)mod->kva_seg.kva_curp;
  memset((void *)fcxp, 0, (unsigned long )mod->num_fcxps * 448UL);
  INIT_LIST_HEAD(& mod->fcxp_req_free_q);
  INIT_LIST_HEAD(& mod->fcxp_rsp_free_q);
  INIT_LIST_HEAD(& mod->fcxp_active_q);
  INIT_LIST_HEAD(& mod->fcxp_req_unused_q);
  INIT_LIST_HEAD(& mod->fcxp_rsp_unused_q);
  mod->fcxp_list = fcxp;
  i = 0U;
  goto ldv_48722;
  ldv_48721: 
  fcxp->fcxp_mod = mod;
  fcxp->fcxp_tag = i;
  if ((unsigned int )mod->num_fcxps / 2U > (unsigned int )i) {
    list_add_tail(& fcxp->qe, & mod->fcxp_req_free_q);
    fcxp->req_rsp = 1;
  } else {
    list_add_tail(& fcxp->qe, & mod->fcxp_rsp_free_q);
    fcxp->req_rsp = 0;
  }
  bfa_reqq_winit(& fcxp->reqq_wqe, & bfa_fcxp_qresume, (void *)fcxp);
  fcxp->reqq_waiting = 0;
  fcxp = fcxp + 1UL;
  i = (u16 )((int )i + 1);
  ldv_48722: ;
  if ((int )mod->num_fcxps > (int )i) {
    goto ldv_48721;
  } else {

  }
  mod->kva_seg.kva_curp = (u8 *)fcxp;
  return;
}
}
static void bfa_fcxp_meminfo(struct bfa_iocfc_cfg_s *cfg , struct bfa_meminfo_s *minfo ,
                             struct bfa_s *bfa ) 
{ 
  struct bfa_fcxp_mod_s *fcxp_mod ;
  struct bfa_mem_kva_s *fcxp_kva ;
  struct bfa_mem_dma_s *seg_ptr ;
  u16 nsegs ;
  u16 idx ;
  u16 per_seg_fcxp ;
  u16 num_fcxps___0 ;
  u32 per_fcxp_sz ;

  {
  fcxp_mod = & bfa->modules.fcxp_mod;
  fcxp_kva = & bfa->modules.fcxp_mod.kva_seg;
  num_fcxps___0 = cfg->fwcfg.num_fcxp_reqs;
  if ((unsigned int )num_fcxps___0 == 0U) {
    return;
  } else {

  }
  if ((unsigned int )cfg->drvcfg.min_cfg != 0U) {
    per_fcxp_sz = 4608U;
  } else {
    per_fcxp_sz = 6656U;
  }
  nsegs = (unsigned short )((((u32 )num_fcxps___0 * per_fcxp_sz + 131071U) & 4294836224U) / 131072U);
  per_seg_fcxp = (u16 )(131072U / per_fcxp_sz);
  idx = 0U;
  seg_ptr = (struct bfa_mem_dma_s *)(& fcxp_mod->dma_seg) + (unsigned long )idx;
  goto ldv_48738;
  ldv_48737: ;
  if ((int )num_fcxps___0 >= (int )per_seg_fcxp) {
    num_fcxps___0 = (int )num_fcxps___0 - (int )per_seg_fcxp;
    seg_ptr->mem_len = (u32 )per_seg_fcxp * per_fcxp_sz;
    if ((u32 )per_seg_fcxp * per_fcxp_sz != 0U) {
      list_add_tail(& seg_ptr->qe, & minfo->dma_info.qe);
    } else {

    }
  } else {
    seg_ptr->mem_len = (u32 )num_fcxps___0 * per_fcxp_sz;
    if ((u32 )num_fcxps___0 * per_fcxp_sz != 0U) {
      list_add_tail(& seg_ptr->qe, & minfo->dma_info.qe);
    } else {

    }
  }
  idx = (u16 )((int )idx + 1);
  seg_ptr = (struct bfa_mem_dma_s *)(& fcxp_mod->dma_seg) + (unsigned long )idx;
  ldv_48738: ;
  if ((int )idx < (int )nsegs) {
    goto ldv_48737;
  } else {

  }
  fcxp_kva->mem_len = (u32 )cfg->fwcfg.num_fcxp_reqs * 448U;
  if ((unsigned long )cfg->fwcfg.num_fcxp_reqs * 448UL != 0UL) {
    list_add_tail(& fcxp_kva->qe, & minfo->kva_info.qe);
  } else {

  }
  return;
}
}
static void bfa_fcxp_attach(struct bfa_s *bfa , void *bfad , struct bfa_iocfc_cfg_s *cfg ,
                            struct bfa_pcidev_s *pcidev ) 
{ 
  struct bfa_fcxp_mod_s *mod ;
  u32 tmp ;

  {
  mod = & bfa->modules.fcxp_mod;
  mod->bfa = bfa;
  mod->num_fcxps = cfg->fwcfg.num_fcxp_reqs;
  tmp = 2304U;
  mod->rsp_pld_sz = tmp;
  mod->req_pld_sz = tmp;
  if ((unsigned int )cfg->drvcfg.min_cfg == 0U) {
    mod->rsp_pld_sz = 4352U;
  } else {

  }
  INIT_LIST_HEAD(& mod->req_wait_q);
  INIT_LIST_HEAD(& mod->rsp_wait_q);
  claim_fcxps_mem(mod);
  return;
}
}
static void bfa_fcxp_detach(struct bfa_s *bfa ) 
{ 


  {
  return;
}
}
static void bfa_fcxp_start(struct bfa_s *bfa ) 
{ 


  {
  return;
}
}
static void bfa_fcxp_stop(struct bfa_s *bfa ) 
{ 


  {
  return;
}
}
static void bfa_fcxp_iocdisable(struct bfa_s *bfa ) 
{ 
  struct bfa_fcxp_mod_s *mod ;
  struct bfa_fcxp_s *fcxp ;
  struct list_head *qe ;
  struct list_head *qen ;

  {
  mod = & bfa->modules.fcxp_mod;
  list_splice_tail_init(& mod->fcxp_req_unused_q, & mod->fcxp_req_free_q);
  list_splice_tail_init(& mod->fcxp_rsp_unused_q, & mod->fcxp_rsp_free_q);
  qe = mod->fcxp_active_q.next;
  qen = qe->next;
  goto ldv_48764;
  ldv_48763: 
  fcxp = (struct bfa_fcxp_s *)qe;
  if ((unsigned long )fcxp->caller == (unsigned long )((void *)0)) {
    (*(fcxp->send_cbfn))(fcxp->caller, fcxp, fcxp->send_cbarg, 56, 0U, 0U, (struct fchs_s *)0);
    bfa_fcxp_free(fcxp);
  } else {
    fcxp->rsp_status = 56U;
    fcxp->hcb_qe.cbfn = & __bfa_fcxp_send_cbfn;
    fcxp->hcb_qe.cbarg = (void *)fcxp;
    fcxp->hcb_qe.pre_rmv = 0;
    list_add_tail(& fcxp->hcb_qe.qe, & bfa->comp_q);
  }
  qe = qen;
  qen = qe->next;
  ldv_48764: ;
  if ((unsigned long )(& mod->fcxp_active_q) != (unsigned long )qe) {
    goto ldv_48763;
  } else {

  }

  return;
}
}
static struct bfa_fcxp_s *bfa_fcxp_get(struct bfa_fcxp_mod_s *fm , enum bfa_boolean req ) 
{ 
  struct bfa_fcxp_s *fcxp ;
  int tmp ;
  int tmp___0 ;

  {
  if ((unsigned int )req != 0U) {
    tmp = list_empty((struct list_head  const  *)(& fm->fcxp_req_free_q));
    if (tmp == 0) {
      *((struct list_head **)(& fcxp)) = fm->fcxp_req_free_q.next;
      ((*((struct list_head **)(& fcxp)))->next)->prev = & fm->fcxp_req_free_q;
      fm->fcxp_req_free_q.next = (*((struct list_head **)(& fcxp)))->next;
    } else {
      *((struct list_head **)(& fcxp)) = (struct list_head *)0;
    }
  } else {
    tmp___0 = list_empty((struct list_head  const  *)(& fm->fcxp_rsp_free_q));
    if (tmp___0 == 0) {
      *((struct list_head **)(& fcxp)) = fm->fcxp_rsp_free_q.next;
      ((*((struct list_head **)(& fcxp)))->next)->prev = & fm->fcxp_rsp_free_q;
      fm->fcxp_rsp_free_q.next = (*((struct list_head **)(& fcxp)))->next;
    } else {
      *((struct list_head **)(& fcxp)) = (struct list_head *)0;
    }
  }
  if ((unsigned long )fcxp != (unsigned long )((struct bfa_fcxp_s *)0)) {
    list_add_tail(& fcxp->qe, & fm->fcxp_active_q);
  } else {

  }
  return (fcxp);
}
}
static void bfa_fcxp_init_reqrsp(struct bfa_fcxp_s *fcxp , struct bfa_s *bfa , u8 *use_ibuf ,
                                 u32 *nr_sgles , bfa_fcxp_get_sgaddr_t (**r_sga_cbfn)(void * ,
                                                                                      int  ) ,
                                 bfa_fcxp_get_sglen_t (**r_sglen_cbfn)(void * , int  ) ,
                                 struct list_head *r_sgpg_q , int n_sgles , u64 (*sga_cbfn)(void * ,
                                                                                            int  ) ,
                                 u32 (*sglen_cbfn)(void * , int  ) ) 
{ 
  int __ret_warn_on ;
  long tmp ;
  int __ret_warn_on___0 ;
  long tmp___0 ;
  int __ret_warn_on___1 ;
  long tmp___1 ;
  int __ret_warn_on___2 ;
  long tmp___2 ;

  {
  __ret_warn_on = (unsigned long )bfa == (unsigned long )((struct bfa_s *)0);
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_svc.c",
                       615);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  __bfa_trc(bfa->trcmod, __trc_fileno___13, 617, (unsigned long long )fcxp->fcxp_tag);
  if (n_sgles == 0) {
    *use_ibuf = 1U;
  } else {
    __ret_warn_on___0 = (unsigned long )sga_cbfn == (unsigned long )((u64 (*)(void * ,
                                                                              int  ))0);
    tmp___0 = ldv__builtin_expect(__ret_warn_on___0 != 0, 0L);
    if (tmp___0 != 0L) {
      warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_svc.c",
                         622);
    } else {

    }
    ldv__builtin_expect(__ret_warn_on___0 != 0, 0L);
    __ret_warn_on___1 = (unsigned long )sglen_cbfn == (unsigned long )((u32 (*)(void * ,
                                                                                int  ))0);
    tmp___1 = ldv__builtin_expect(__ret_warn_on___1 != 0, 0L);
    if (tmp___1 != 0L) {
      warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_svc.c",
                         623);
    } else {

    }
    ldv__builtin_expect(__ret_warn_on___1 != 0, 0L);
    *use_ibuf = 0U;
    *r_sga_cbfn = sga_cbfn;
    *r_sglen_cbfn = sglen_cbfn;
    *nr_sgles = (u32 )n_sgles;
    if (n_sgles > 1) {
      __ret_warn_on___2 = 1;
      tmp___2 = ldv__builtin_expect(__ret_warn_on___2 != 0, 0L);
      if (tmp___2 != 0L) {
        warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_svc.c",
                           635);
      } else {

      }
      ldv__builtin_expect(__ret_warn_on___2 != 0, 0L);
    } else {

    }
  }
  return;
}
}
static void bfa_fcxp_init(struct bfa_fcxp_s *fcxp , void *caller , struct bfa_s *bfa ,
                          int nreq_sgles , int nrsp_sgles , u64 (*req_sga_cbfn)(void * ,
                                                                                int  ) ,
                          u32 (*req_sglen_cbfn)(void * , int  ) , u64 (*rsp_sga_cbfn)(void * ,
                                                                                      int  ) ,
                          u32 (*rsp_sglen_cbfn)(void * , int  ) ) 
{ 
  int __ret_warn_on ;
  long tmp ;

  {
  __ret_warn_on = (unsigned long )bfa == (unsigned long )((struct bfa_s *)0);
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_svc.c",
                       649);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  __bfa_trc(bfa->trcmod, __trc_fileno___13, 651, (unsigned long long )fcxp->fcxp_tag);
  fcxp->caller = caller;
  bfa_fcxp_init_reqrsp(fcxp, bfa, & fcxp->use_ireqbuf, & fcxp->nreq_sgles, & fcxp->req_sga_cbfn,
                       & fcxp->req_sglen_cbfn, & fcxp->req_sgpg_q, nreq_sgles, req_sga_cbfn,
                       req_sglen_cbfn);
  bfa_fcxp_init_reqrsp(fcxp, bfa, & fcxp->use_irspbuf, & fcxp->nrsp_sgles, & fcxp->rsp_sga_cbfn,
                       & fcxp->rsp_sglen_cbfn, & fcxp->rsp_sgpg_q, nrsp_sgles, rsp_sga_cbfn,
                       rsp_sglen_cbfn);
  return;
}
}
static void bfa_fcxp_put(struct bfa_fcxp_s *fcxp ) 
{ 
  struct bfa_fcxp_mod_s *mod ;
  struct bfa_fcxp_wqe_s *wqe ;
  int tmp ;
  int tmp___0 ;
  int __ret_warn_on ;
  int tmp___1 ;
  long tmp___2 ;

  {
  mod = fcxp->fcxp_mod;
  if ((unsigned int )fcxp->req_rsp != 0U) {
    tmp = list_empty((struct list_head  const  *)(& mod->req_wait_q));
    if (tmp == 0) {
      *((struct list_head **)(& wqe)) = mod->req_wait_q.next;
      ((*((struct list_head **)(& wqe)))->next)->prev = & mod->req_wait_q;
      mod->req_wait_q.next = (*((struct list_head **)(& wqe)))->next;
    } else {
      *((struct list_head **)(& wqe)) = (struct list_head *)0;
    }
  } else {
    tmp___0 = list_empty((struct list_head  const  *)(& mod->rsp_wait_q));
    if (tmp___0 == 0) {
      *((struct list_head **)(& wqe)) = mod->rsp_wait_q.next;
      ((*((struct list_head **)(& wqe)))->next)->prev = & mod->rsp_wait_q;
      mod->rsp_wait_q.next = (*((struct list_head **)(& wqe)))->next;
    } else {
      *((struct list_head **)(& wqe)) = (struct list_head *)0;
    }
  }
  if ((unsigned long )wqe != (unsigned long )((struct bfa_fcxp_wqe_s *)0)) {
    __bfa_trc((mod->bfa)->trcmod, __trc_fileno___13, 679, (unsigned long long )fcxp->fcxp_tag);
    bfa_fcxp_init(fcxp, wqe->caller, wqe->bfa, wqe->nreq_sgles, wqe->nrsp_sgles, wqe->req_sga_cbfn,
                  wqe->req_sglen_cbfn, wqe->rsp_sga_cbfn, wqe->rsp_sglen_cbfn);
    (*(wqe->alloc_cbfn))(wqe->alloc_cbarg, fcxp);
    return;
  } else {

  }
  tmp___1 = bfa_q_is_on_q_func(& mod->fcxp_active_q, (struct list_head *)fcxp);
  __ret_warn_on = tmp___1 == 0;
  tmp___2 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp___2 != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_svc.c",
                       690);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  list_del(& fcxp->qe);
  if ((unsigned int )fcxp->req_rsp != 0U) {
    list_add_tail(& fcxp->qe, & mod->fcxp_req_free_q);
  } else {
    list_add_tail(& fcxp->qe, & mod->fcxp_rsp_free_q);
  }
  return;
}
}
static void bfa_fcxp_null_comp(void *bfad_fcxp , struct bfa_fcxp_s *fcxp , void *cbarg ,
                               enum bfa_status req_status , u32 rsp_len , u32 resid_len ,
                               struct fchs_s *rsp_fchs ) 
{ 


  {
  return;
}
}
static void __bfa_fcxp_send_cbfn(void *cbarg , enum bfa_boolean complete___0 ) 
{ 
  struct bfa_fcxp_s *fcxp ;

  {
  fcxp = (struct bfa_fcxp_s *)cbarg;
  if ((unsigned int )complete___0 != 0U) {
    (*(fcxp->send_cbfn))(fcxp->caller, fcxp, fcxp->send_cbarg, (enum bfa_status )fcxp->rsp_status,
                         fcxp->rsp_len, fcxp->residue_len, & fcxp->rsp_fchs);
  } else {
    bfa_fcxp_free(fcxp);
  }
  return;
}
}
static void hal_fcxp_send_comp(struct bfa_s *bfa , struct bfi_fcxp_send_rsp_s *fcxp_rsp ) 
{ 
  struct bfa_fcxp_mod_s *mod ;
  struct bfa_fcxp_s *fcxp ;
  u16 fcxp_tag ;
  __u16 tmp ;
  __u32 tmp___0 ;
  __u32 tmp___1 ;
  int __ret_warn_on ;
  long tmp___2 ;

  {
  mod = & bfa->modules.fcxp_mod;
  tmp = __fswab16((int )fcxp_rsp->fcxp_tag);
  fcxp_tag = tmp;
  __bfa_trc(bfa->trcmod, __trc_fileno___13, 728, (unsigned long long )fcxp_tag);
  tmp___0 = __fswab32(fcxp_rsp->rsp_len);
  fcxp_rsp->rsp_len = tmp___0;
  if ((unsigned int )fcxp_rsp->req_status == 0U) {
    fcxp_rsp->residue_len = 0U;
  } else {
    tmp___1 = __fswab32(fcxp_rsp->residue_len);
    fcxp_rsp->residue_len = tmp___1;
  }
  fcxp = mod->fcxp_list + (unsigned long )fcxp_tag;
  __ret_warn_on = (unsigned long )fcxp->send_cbfn == (unsigned long )((void (*)(void * ,
                                                                                struct bfa_fcxp_s * ,
                                                                                void * ,
                                                                                enum bfa_status  ,
                                                                                u32  ,
                                                                                u32  ,
                                                                                struct fchs_s * ))0);
  tmp___2 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp___2 != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_svc.c",
                       743);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  hal_fcxp_rx_plog(mod->bfa, fcxp, fcxp_rsp);
  if ((unsigned long )fcxp->send_cbfn != (unsigned long )((void (*)(void * , struct bfa_fcxp_s * ,
                                                                    void * , enum bfa_status  ,
                                                                    u32  , u32  ,
                                                                    struct fchs_s * ))0)) {
    __bfa_trc((mod->bfa)->trcmod, __trc_fileno___13, 748, (unsigned long )fcxp->caller == (unsigned long )((void *)0));
    if ((unsigned long )fcxp->caller == (unsigned long )((void *)0)) {
      (*(fcxp->send_cbfn))(fcxp->caller, fcxp, fcxp->send_cbarg, (enum bfa_status )fcxp_rsp->req_status,
                           fcxp_rsp->rsp_len, fcxp_rsp->residue_len, & fcxp_rsp->fchs);
      bfa_fcxp_free(fcxp);
    } else {
      fcxp->rsp_status = fcxp_rsp->req_status;
      fcxp->rsp_len = fcxp_rsp->rsp_len;
      fcxp->residue_len = fcxp_rsp->residue_len;
      fcxp->rsp_fchs = fcxp_rsp->fchs;
      fcxp->hcb_qe.cbfn = & __bfa_fcxp_send_cbfn;
      fcxp->hcb_qe.cbarg = (void *)fcxp;
      fcxp->hcb_qe.pre_rmv = 0;
      list_add_tail(& fcxp->hcb_qe.qe, & bfa->comp_q);
    }
  } else {
    __bfa_trc(bfa->trcmod, __trc_fileno___13, 767, (unsigned long )fcxp->send_cbfn == (unsigned long )((void (*)(void * ,
                                                                                                                 struct bfa_fcxp_s * ,
                                                                                                                 void * ,
                                                                                                                 enum bfa_status  ,
                                                                                                                 u32  ,
                                                                                                                 u32  ,
                                                                                                                 struct fchs_s * ))0));
  }
  return;
}
}
static void hal_fcxp_tx_plog(struct bfa_s *bfa , u32 reqlen , struct bfa_fcxp_s *fcxp ,
                             struct fchs_s *fchs ) 
{ 
  u32 pld_w0 ;
  void *tmp ;

  {
  if (reqlen != 0U) {
    if ((unsigned int )fcxp->use_ireqbuf != 0U) {
      tmp = bfa_fcxp_get_reqbuf(fcxp);
      pld_w0 = *((u32 *)tmp);
      bfa_plog_fchdr_and_pl(bfa->plog, 4, 6, (int )((unsigned int )((u16 )reqlen) + 24U),
                            fchs, pld_w0);
    } else {
      bfa_plog_fchdr(bfa->plog, 4, 6, (int )((unsigned int )((u16 )reqlen) + 24U),
                     fchs);
    }
  } else {
    bfa_plog_fchdr(bfa->plog, 4, 6, (int )((unsigned int )((u16 )reqlen) + 24U), fchs);
  }
  return;
}
}
static void hal_fcxp_rx_plog(struct bfa_s *bfa , struct bfa_fcxp_s *fcxp , struct bfi_fcxp_send_rsp_s *fcxp_rsp ) 
{ 
  u32 pld_w0 ;
  void *tmp ;

  {
  if (fcxp_rsp->rsp_len != 0U) {
    if ((unsigned int )fcxp->use_irspbuf != 0U) {
      tmp = bfa_fcxp_get_rspbuf(fcxp);
      pld_w0 = *((u32 *)tmp);
      bfa_plog_fchdr_and_pl(bfa->plog, 4, 10, (int )((unsigned short )fcxp_rsp->rsp_len),
                            & fcxp_rsp->fchs, pld_w0);
    } else {
      bfa_plog_fchdr(bfa->plog, 4, 10, (int )((unsigned short )fcxp_rsp->rsp_len),
                     & fcxp_rsp->fchs);
    }
  } else {
    bfa_plog_fchdr(bfa->plog, 4, 10, (int )((unsigned short )fcxp_rsp->rsp_len), & fcxp_rsp->fchs);
  }
  return;
}
}
static void bfa_fcxp_qresume(void *cbarg ) 
{ 
  struct bfa_fcxp_s *fcxp ;
  struct bfa_s *bfa ;
  struct bfi_fcxp_send_req_s *send_req ;

  {
  fcxp = (struct bfa_fcxp_s *)cbarg;
  bfa = (fcxp->fcxp_mod)->bfa;
  fcxp->reqq_waiting = 0;
  send_req = ((bfa->iocfc.req_cq_pi[0] + 1U) & (u32 )((int )bfa->iocfc.cfg.drvcfg.num_reqq_elems + -1)) != *((u32 *)bfa->iocfc.req_cq_shadow_ci[0].kva) ? (struct bfi_fcxp_send_req_s *)bfa->iocfc.req_cq_ba[0].kva + (unsigned long )bfa->iocfc.req_cq_pi[0] : (struct bfi_fcxp_send_req_s *)0;
  bfa_fcxp_queue(fcxp, send_req);
  return;
}
}
static void bfa_fcxp_queue(struct bfa_fcxp_s *fcxp , struct bfi_fcxp_send_req_s *send_req ) 
{ 
  struct bfa_s *bfa ;
  struct bfa_fcxp_req_info_s *reqi ;
  struct bfa_fcxp_rsp_info_s *rspi ;
  struct bfa_rport_s *rport ;
  __u16 tmp ;
  __u16 tmp___0 ;
  __u16 tmp___1 ;
  __u32 tmp___2 ;
  __u32 tmp___3 ;
  int __ret_warn_on ;
  long tmp___4 ;
  u64 tmp___5 ;
  int __ret_warn_on___0 ;
  long tmp___6 ;
  int __ret_warn_on___1 ;
  long tmp___7 ;
  int __ret_warn_on___2 ;
  long tmp___8 ;
  u64 tmp___9 ;
  int __ret_warn_on___3 ;
    klee_make_symbolic(&__ret_warn_on___3, sizeof(int), "__ret_warn_on___3");
  long tmp___10 ;

  {
  bfa = (fcxp->fcxp_mod)->bfa;
  reqi = & fcxp->req_info;
  rspi = & fcxp->rsp_info;
  rport = reqi->bfa_rport;
  send_req->mh.msg_class = 9U;
  send_req->mh.msg_id = 1U;
  send_req->mh.mtag.h2i.fn_lpu = (u8 )((int )((signed char )((int )bfa->ioc.pcidev.pci_func << 1)) | (int )((signed char )bfa->ioc.port_id));
  tmp = __fswab16((int )fcxp->fcxp_tag);
  send_req->fcxp_tag = tmp;
  if ((unsigned long )rport != (unsigned long )((struct bfa_rport_s *)0)) {
    send_req->rport_fw_hndl = rport->fw_handle;
    tmp___0 = __fswab16((int )rport->rport_info.max_frmsz);
    send_req->max_frmsz = tmp___0;
    if ((unsigned int )send_req->max_frmsz == 0U) {
      send_req->max_frmsz = 16392U;
    } else {

    }
  } else {
    send_req->rport_fw_hndl = 0U;
    send_req->max_frmsz = 16392U;
  }
  tmp___1 = __fswab16((int )reqi->vf_id);
  send_req->vf_id = tmp___1;
  send_req->lp_fwtag = bfa_lps_get_fwtag(bfa, (int )reqi->lp_tag);
  send_req->class = reqi->class;
  send_req->rsp_timeout = rspi->rsp_timeout;
  send_req->cts = reqi->cts;
  send_req->fchs = reqi->fchs;
  tmp___2 = __fswab32(reqi->req_tot_len);
  send_req->req_len = tmp___2;
  tmp___3 = __fswab32(rspi->rsp_maxlen);
  send_req->rsp_maxlen = tmp___3;
  if ((unsigned int )fcxp->use_ireqbuf == 1U) {
    __bfa_alen_set(& send_req->req_alen, reqi->req_tot_len, (fcxp->fcxp_mod)->dma_seg[(u32 )fcxp->fcxp_tag / (131072U / ((fcxp->fcxp_mod)->req_pld_sz + (fcxp->fcxp_mod)->rsp_pld_sz))].dma_curp + (u64 )(((u32 )fcxp->fcxp_tag % (131072U / ((fcxp->fcxp_mod)->req_pld_sz + (fcxp->fcxp_mod)->rsp_pld_sz))) * ((fcxp->fcxp_mod)->req_pld_sz + (fcxp->fcxp_mod)->rsp_pld_sz)));
  } else
  if (fcxp->nreq_sgles != 0U) {
    __ret_warn_on = fcxp->nreq_sgles != 1U;
    tmp___4 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
    if (tmp___4 != 0L) {
      warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_svc.c",
                         882);
    } else {

    }
    ldv__builtin_expect(__ret_warn_on != 0, 0L);
    tmp___5 = (*(fcxp->req_sga_cbfn))(fcxp->caller, 0);
    __bfa_alen_set(& send_req->req_alen, reqi->req_tot_len, tmp___5);
  } else {
    __ret_warn_on___0 = reqi->req_tot_len != 0U;
    tmp___6 = ldv__builtin_expect(__ret_warn_on___0 != 0, 0L);
    if (tmp___6 != 0L) {
      warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_svc.c",
                         886);
    } else {

    }
    ldv__builtin_expect(__ret_warn_on___0 != 0, 0L);
    __bfa_alen_set(& send_req->rsp_alen, 0U, 0ULL);
  }
  if ((unsigned int )fcxp->use_irspbuf == 1U) {
    __ret_warn_on___1 = rspi->rsp_maxlen > 4352U;
    tmp___7 = ldv__builtin_expect(__ret_warn_on___1 != 0, 0L);
    if (tmp___7 != 0L) {
      warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_svc.c",
                         895);
    } else {

    }
    ldv__builtin_expect(__ret_warn_on___1 != 0, 0L);
    __bfa_alen_set(& send_req->rsp_alen, rspi->rsp_maxlen, ((fcxp->fcxp_mod)->dma_seg[(u32 )fcxp->fcxp_tag / (131072U / ((fcxp->fcxp_mod)->req_pld_sz + (fcxp->fcxp_mod)->rsp_pld_sz))].dma_curp + (u64 )(((u32 )fcxp->fcxp_tag % (131072U / ((fcxp->fcxp_mod)->req_pld_sz + (fcxp->fcxp_mod)->rsp_pld_sz))) * ((fcxp->fcxp_mod)->req_pld_sz + (fcxp->fcxp_mod)->rsp_pld_sz))) + (u64 )(fcxp->fcxp_mod)->req_pld_sz);
  } else
  if (fcxp->nrsp_sgles != 0U) {
    __ret_warn_on___2 = fcxp->nrsp_sgles != 1U;
    tmp___8 = ldv__builtin_expect(__ret_warn_on___2 != 0, 0L);
    if (tmp___8 != 0L) {
      warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_svc.c",
                         901);
    } else {

    }
    ldv__builtin_expect(__ret_warn_on___2 != 0, 0L);
    tmp___9 = (*(fcxp->rsp_sga_cbfn))(fcxp->caller, 0);
    __bfa_alen_set(& send_req->rsp_alen, rspi->rsp_maxlen, tmp___9);
  } else {
    __ret_warn_on___3 = rspi->rsp_maxlen != 0U;
    tmp___10 = ldv__builtin_expect(__ret_warn_on___3 != 0, 0L);
    if (tmp___10 != 0L) {
      warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_svc.c",
                         906);
    } else {

    }
    ldv__builtin_expect(__ret_warn_on___3 != 0, 0L);
    __bfa_alen_set(& send_req->rsp_alen, 0U, 0ULL);
  }
  hal_fcxp_tx_plog(bfa, reqi->req_tot_len, fcxp, & reqi->fchs);
  send_req->mh.mtag.h2i.qid = bfa->iocfc.hw_qid[0];
  bfa->iocfc.req_cq_pi[0] = bfa->iocfc.req_cq_pi[0] + 1U;
  bfa->iocfc.req_cq_pi[0] = bfa->iocfc.req_cq_pi[0] & (u32 )((int )bfa->iocfc.cfg.drvcfg.num_reqq_elems + -1);
  writel(bfa->iocfc.req_cq_pi[0], (void volatile   *)bfa->iocfc.bfa_regs.cpe_q_pi[0]);
  __asm__  volatile   ("": : : "memory");
  __bfa_trc(bfa->trcmod, __trc_fileno___13, 915, (unsigned long long )bfa->iocfc.req_cq_pi[0]);
  __bfa_trc(bfa->trcmod, __trc_fileno___13, 916, (unsigned long long )*((u32 *)bfa->iocfc.req_cq_shadow_ci[0].kva));
  return;
}
}
struct bfa_fcxp_s *bfa_fcxp_req_rsp_alloc(void *caller , struct bfa_s *bfa , int nreq_sgles ,
                                          int nrsp_sgles , u64 (*req_sga_cbfn)(void * ,
                                                                               int  ) ,
                                          u32 (*req_sglen_cbfn)(void * , int  ) ,
                                          u64 (*rsp_sga_cbfn)(void * , int  ) , u32 (*rsp_sglen_cbfn)(void * ,
                                                                                                      int  ) ,
                                          enum bfa_boolean req ) 
{ 
  struct bfa_fcxp_s *fcxp ;
  int __ret_warn_on ;
  long tmp ;

  {
  fcxp = (struct bfa_fcxp_s *)0;
  __ret_warn_on = (unsigned long )bfa == (unsigned long )((struct bfa_s *)0);
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_svc.c",
                       953);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  fcxp = bfa_fcxp_get(& bfa->modules.fcxp_mod, req);
  if ((unsigned long )fcxp == (unsigned long )((struct bfa_fcxp_s *)0)) {
    return ((struct bfa_fcxp_s *)0);
  } else {

  }
  __bfa_trc(bfa->trcmod, __trc_fileno___13, 959, (unsigned long long )fcxp->fcxp_tag);
  bfa_fcxp_init(fcxp, caller, bfa, nreq_sgles, nrsp_sgles, req_sga_cbfn, req_sglen_cbfn,
                rsp_sga_cbfn, rsp_sglen_cbfn);
  return (fcxp);
}
}
void *bfa_fcxp_get_reqbuf(struct bfa_fcxp_s *fcxp ) 
{ 
  struct bfa_fcxp_mod_s *mod ;
  void *reqbuf ;
  int __ret_warn_on ;
  long tmp ;

  {
  mod = fcxp->fcxp_mod;
  __ret_warn_on = (unsigned int )fcxp->use_ireqbuf != 1U;
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_svc.c",
                       980);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  reqbuf = (void *)mod->dma_seg[(u32 )fcxp->fcxp_tag / (131072U / (mod->req_pld_sz + mod->rsp_pld_sz))].kva_curp + (unsigned long )(((u32 )fcxp->fcxp_tag % (131072U / (mod->req_pld_sz + mod->rsp_pld_sz))) * (mod->req_pld_sz + mod->rsp_pld_sz));
  return (reqbuf);
}
}
u32 bfa_fcxp_get_reqbufsz(struct bfa_fcxp_s *fcxp ) 
{ 
  struct bfa_fcxp_mod_s *mod ;

  {
  mod = fcxp->fcxp_mod;
  return (mod->req_pld_sz);
}
}
void *bfa_fcxp_get_rspbuf(struct bfa_fcxp_s *fcxp ) 
{ 
  struct bfa_fcxp_mod_s *mod ;
  void *fcxp_buf ;
  int __ret_warn_on ;
  long tmp ;

  {
  mod = fcxp->fcxp_mod;
  __ret_warn_on = (unsigned int )fcxp->use_irspbuf != 1U;
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_svc.c",
                       1007);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  fcxp_buf = (void *)mod->dma_seg[(u32 )fcxp->fcxp_tag / (131072U / (mod->req_pld_sz + mod->rsp_pld_sz))].kva_curp + (unsigned long )(((u32 )fcxp->fcxp_tag % (131072U / (mod->req_pld_sz + mod->rsp_pld_sz))) * (mod->req_pld_sz + mod->rsp_pld_sz));
  return (fcxp_buf + (unsigned long )mod->req_pld_sz);
}
}
void bfa_fcxp_free(struct bfa_fcxp_s *fcxp ) 
{ 
  struct bfa_fcxp_mod_s *mod ;
  int __ret_warn_on ;
  long tmp ;

  {
  mod = fcxp->fcxp_mod;
  __ret_warn_on = (unsigned long )fcxp == (unsigned long )((struct bfa_fcxp_s *)0);
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_svc.c",
                       1028);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  __bfa_trc((mod->bfa)->trcmod, __trc_fileno___13, 1029, (unsigned long long )fcxp->fcxp_tag);
  bfa_fcxp_put(fcxp);
  return;
}
}
void bfa_fcxp_send(struct bfa_fcxp_s *fcxp , struct bfa_rport_s *rport , u16 vf_id ,
                   u8 lp_tag , enum bfa_boolean cts , enum fc_cos cos , u32 reqlen ,
                   struct fchs_s *fchs , void (*cbfn)(void * , struct bfa_fcxp_s * ,
                                                      void * , enum bfa_status  ,
                                                      u32  , u32  , struct fchs_s * ) ,
                   void *cbarg , u32 rsp_maxlen , u8 rsp_timeout ) 
{ 
  struct bfa_s *bfa ;
  struct bfa_fcxp_req_info_s *reqi ;
  struct bfa_fcxp_rsp_info_s *rspi ;
  struct bfi_fcxp_send_req_s *send_req ;
  struct list_head *waitq ;
  int __ret_warn_on ;
  long tmp ;
  int __ret_warn_on___0 ;
  long tmp___0 ;

  {
  bfa = (fcxp->fcxp_mod)->bfa;
  reqi = & fcxp->req_info;
  rspi = & fcxp->rsp_info;
  __bfa_trc(bfa->trcmod, __trc_fileno___13, 1065, (unsigned long long )fcxp->fcxp_tag);
  reqi->bfa_rport = rport;
  reqi->vf_id = vf_id;
  reqi->lp_tag = lp_tag;
  reqi->class = (u8 )cos;
  rspi->rsp_timeout = rsp_timeout;
  reqi->cts = (u8 )cts;
  reqi->fchs = *fchs;
  reqi->req_tot_len = reqlen;
  rspi->rsp_maxlen = rsp_maxlen;
  fcxp->send_cbfn = (unsigned long )cbfn != (unsigned long )((void (*)(void * , struct bfa_fcxp_s * ,
                                                                       void * , enum bfa_status  ,
                                                                       u32  , u32  ,
                                                                       struct fchs_s * ))0) ? cbfn : & bfa_fcxp_null_comp;
  fcxp->send_cbarg = cbarg;
  send_req = ((bfa->iocfc.req_cq_pi[0] + 1U) & (u32 )((int )bfa->iocfc.cfg.drvcfg.num_reqq_elems + -1)) != *((u32 *)bfa->iocfc.req_cq_shadow_ci[0].kva) ? (struct bfi_fcxp_send_req_s *)bfa->iocfc.req_cq_ba[0].kva + (unsigned long )bfa->iocfc.req_cq_pi[0] : (struct bfi_fcxp_send_req_s *)0;
  if ((unsigned long )send_req == (unsigned long )((struct bfi_fcxp_send_req_s *)0)) {
    __bfa_trc(bfa->trcmod, __trc_fileno___13, 1087, (unsigned long long )fcxp->fcxp_tag);
    fcxp->reqq_waiting = 1;
    waitq = (struct list_head *)(& bfa->reqq_waitq);
    __ret_warn_on = 0;
    tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
    if (tmp != 0L) {
      warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_svc.c",
                         1089);
    } else {

    }
    ldv__builtin_expect(__ret_warn_on != 0, 0L);
    __ret_warn_on___0 = (unsigned long )fcxp->reqq_wqe.qresume == (unsigned long )((void (*)(void * ))0) || (unsigned long )fcxp->reqq_wqe.cbarg == (unsigned long )((void *)0);
    tmp___0 = ldv__builtin_expect(__ret_warn_on___0 != 0, 0L);
    if (tmp___0 != 0L) {
      warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_svc.c",
                         1089);
    } else {

    }
    ldv__builtin_expect(__ret_warn_on___0 != 0, 0L);
    list_add_tail(& fcxp->reqq_wqe.qe, waitq);
    return;
  } else {

  }
  bfa_fcxp_queue(fcxp, send_req);
  return;
}
}
enum bfa_status bfa_fcxp_abort(struct bfa_fcxp_s *fcxp ) 
{ 
  int __ret_warn_on ;
  long tmp ;

  {
  __bfa_trc(((fcxp->fcxp_mod)->bfa)->trcmod, __trc_fileno___13, 1106, (unsigned long long )fcxp->fcxp_tag);
  __ret_warn_on = 1;
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_svc.c",
                       1107);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  return (0);
}
}
void bfa_fcxp_req_rsp_alloc_wait(struct bfa_s *bfa , struct bfa_fcxp_wqe_s *wqe ,
                                 void (*alloc_cbfn)(void * , struct bfa_fcxp_s * ) ,
                                 void *alloc_cbarg , void *caller , int nreq_sgles ,
                                 int nrsp_sgles , u64 (*req_sga_cbfn)(void * , int  ) ,
                                 u32 (*req_sglen_cbfn)(void * , int  ) , u64 (*rsp_sga_cbfn)(void * ,
                                                                                             int  ) ,
                                 u32 (*rsp_sglen_cbfn)(void * , int  ) , enum bfa_boolean req ) 
{ 
  struct bfa_fcxp_mod_s *mod ;
  int __ret_warn_on ;
  int tmp ;
  long tmp___0 ;
  int __ret_warn_on___0 ;
  int tmp___1 ;
  long tmp___2 ;

  {
  mod = & bfa->modules.fcxp_mod;
  if ((unsigned int )req != 0U) {
    tmp = list_empty((struct list_head  const  *)(& mod->fcxp_req_free_q));
    __ret_warn_on = tmp == 0;
    tmp___0 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
    if (tmp___0 != 0L) {
      warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_svc.c",
                         1123);
    } else {

    }
    ldv__builtin_expect(__ret_warn_on != 0, 0L);
  } else {
    tmp___1 = list_empty((struct list_head  const  *)(& mod->fcxp_rsp_free_q));
    __ret_warn_on___0 = tmp___1 == 0;
    tmp___2 = ldv__builtin_expect(__ret_warn_on___0 != 0, 0L);
    if (tmp___2 != 0L) {
      warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_svc.c",
                         1125);
    } else {

    }
    ldv__builtin_expect(__ret_warn_on___0 != 0, 0L);
  }
  wqe->alloc_cbfn = alloc_cbfn;
  wqe->alloc_cbarg = alloc_cbarg;
  wqe->caller = caller;
  wqe->bfa = bfa;
  wqe->nreq_sgles = nreq_sgles;
  wqe->nrsp_sgles = nrsp_sgles;
  wqe->req_sga_cbfn = req_sga_cbfn;
  wqe->req_sglen_cbfn = req_sglen_cbfn;
  wqe->rsp_sga_cbfn = rsp_sga_cbfn;
  wqe->rsp_sglen_cbfn = rsp_sglen_cbfn;
  if ((unsigned int )req != 0U) {
    list_add_tail(& wqe->qe, & mod->req_wait_q);
  } else {
    list_add_tail(& wqe->qe, & mod->rsp_wait_q);
  }
  return;
}
}
void bfa_fcxp_walloc_cancel(struct bfa_s *bfa , struct bfa_fcxp_wqe_s *wqe ) 
{ 
  struct bfa_fcxp_mod_s *mod ;
  int __ret_warn_on ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;

  {
  mod = & bfa->modules.fcxp_mod;
  tmp = bfa_q_is_on_q_func(& mod->req_wait_q, (struct list_head *)wqe);
  if (tmp == 0) {
    tmp___1 = 1;
  } else {
    tmp___0 = bfa_q_is_on_q_func(& mod->rsp_wait_q, (struct list_head *)wqe);
    if (tmp___0 == 0) {
      tmp___1 = 1;
    } else {
      tmp___1 = 0;
    }
  }
  __ret_warn_on = tmp___1;
  tmp___2 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp___2 != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_svc.c",
                       1150);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  list_del(& wqe->qe);
  return;
}
}
void bfa_fcxp_discard(struct bfa_fcxp_s *fcxp ) 
{ 


  {
  if ((unsigned int )fcxp->reqq_waiting != 0U) {
    fcxp->reqq_waiting = 0;
    list_del(& fcxp->reqq_wqe.qe);
    bfa_fcxp_free(fcxp);
    return;
  } else {

  }
  fcxp->send_cbfn = & bfa_fcxp_null_comp;
  return;
}
}
void bfa_fcxp_isr(struct bfa_s *bfa , struct bfi_msg_s *msg ) 
{ 
  int __ret_warn_on ;
  long tmp ;

  {
  switch ((int )msg->mhdr.msg_id) {
  case 129: 
  hal_fcxp_send_comp(bfa, (struct bfi_fcxp_send_rsp_s *)msg);
  goto ldv_48971;
  default: 
  __bfa_trc(bfa->trcmod, __trc_fileno___13, 1180, (unsigned long long )msg->mhdr.msg_id);
  __ret_warn_on = 1;
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_svc.c",
                       1181);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  }
  ldv_48971: ;
  return;
}
}
u32 bfa_fcxp_get_maxrsp(struct bfa_s *bfa ) 
{ 
  struct bfa_fcxp_mod_s *mod ;

  {
  mod = & bfa->modules.fcxp_mod;
  return (mod->rsp_pld_sz);
}
}
void bfa_fcxp_res_recfg(struct bfa_s *bfa , u16 num_fcxp_fw ) 
{ 
  struct bfa_fcxp_mod_s *mod ;
  struct list_head *qe ;
  int i ;
  int tmp ;
  int tmp___0 ;

  {
  mod = & bfa->modules.fcxp_mod;
  i = 0;
  goto ldv_48987;
  ldv_48986: ;
  if (((int )mod->num_fcxps - (int )num_fcxp_fw) / 2 > i) {
    tmp = list_empty((struct list_head  const  *)(& mod->fcxp_req_free_q));
    if (tmp == 0) {
      qe = mod->fcxp_req_free_q.prev;
      (qe->prev)->next = & mod->fcxp_req_free_q;
      mod->fcxp_req_free_q.prev = qe->prev;
    } else {
      qe = (struct list_head *)0;
    }
    list_add_tail(qe, & mod->fcxp_req_unused_q);
  } else {
    tmp___0 = list_empty((struct list_head  const  *)(& mod->fcxp_rsp_free_q));
    if (tmp___0 == 0) {
      qe = mod->fcxp_rsp_free_q.prev;
      (qe->prev)->next = & mod->fcxp_rsp_free_q;
      mod->fcxp_rsp_free_q.prev = qe->prev;
    } else {
      qe = (struct list_head *)0;
    }
    list_add_tail(qe, & mod->fcxp_rsp_unused_q);
  }
  i = i + 1;
  ldv_48987: ;
  if ((int )mod->num_fcxps - (int )num_fcxp_fw > i) {
    goto ldv_48986;
  } else {

  }

  return;
}
}
static void bfa_lps_sm_init(struct bfa_lps_s *lps , enum bfa_lps_event event ) 
{ 
  struct list_head *waitq ;
  int __ret_warn_on ;
  long tmp ;
  int __ret_warn_on___0 ;
  long tmp___0 ;

  {
  __bfa_trc((lps->bfa)->trcmod, __trc_fileno___13, 1221, (unsigned long long )lps->bfa_tag);
  __bfa_trc((lps->bfa)->trcmod, __trc_fileno___13, 1222, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 1U: ;
  if ((((lps->bfa)->iocfc.req_cq_pi[(int )lps->reqq] + 1U) & (u32 )((int )(lps->bfa)->iocfc.cfg.drvcfg.num_reqq_elems + -1)) == *((u32 *)(lps->bfa)->iocfc.req_cq_shadow_ci[(int )lps->reqq].kva)) {
    lps->sm = (void (*)(void * , int  ))(& bfa_lps_sm_loginwait);
    waitq = (struct list_head *)(& (lps->bfa)->reqq_waitq) + (unsigned long )lps->reqq;
    __ret_warn_on = (unsigned int )lps->reqq > 3U;
    tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
    if (tmp != 0L) {
      warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_svc.c",
                         1228);
    } else {

    }
    ldv__builtin_expect(__ret_warn_on != 0, 0L);
    __ret_warn_on___0 = (unsigned long )lps->wqe.qresume == (unsigned long )((void (*)(void * ))0) || (unsigned long )lps->wqe.cbarg == (unsigned long )((void *)0);
    tmp___0 = ldv__builtin_expect(__ret_warn_on___0 != 0, 0L);
    if (tmp___0 != 0L) {
      warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_svc.c",
                         1228);
    } else {

    }
    ldv__builtin_expect(__ret_warn_on___0 != 0, 0L);
    list_add_tail(& lps->wqe.qe, waitq);
  } else {
    lps->sm = (void (*)(void * , int  ))(& bfa_lps_sm_login);
    bfa_lps_send_login(lps);
  }
  if ((unsigned int )lps->fdisc != 0U) {
    bfa_plog_str((lps->bfa)->plog, 7, 22, 0, (char *)"FDISC Request");
  } else {
    bfa_plog_str((lps->bfa)->plog, 7, 22, 0, (char *)"FLOGI Request");
  }
  goto ldv_48999;
  case 2U: 
  bfa_lps_logout_comp(lps);
  goto ldv_48999;
  case 5U: 
  bfa_lps_free(lps);
  goto ldv_48999;
  case 7U: ;
  case 6U: ;
  goto ldv_48999;
  case 3U: ;
  goto ldv_48999;
  case 8U: ;
  goto ldv_48999;
  default: 
  __bfa_trc((lps->bfa)->trcmod, __trc_fileno___13, 1269, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_svc.c",
         1269, (unsigned int )event);
  }
  ldv_48999: ;
  return;
}
}
static void bfa_lps_sm_login(struct bfa_lps_s *lps , enum bfa_lps_event event ) 
{ 


  {
  __bfa_trc((lps->bfa)->trcmod, __trc_fileno___13, 1279, (unsigned long long )lps->bfa_tag);
  __bfa_trc((lps->bfa)->trcmod, __trc_fileno___13, 1280, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 3U: ;
  if ((unsigned int )lps->status == 0U) {
    lps->sm = (void (*)(void * , int  ))(& bfa_lps_sm_online);
    if ((unsigned int )lps->fdisc != 0U) {
      bfa_plog_str((lps->bfa)->plog, 7, 22, 0, (char *)"FDISC Accept");
    } else {
      bfa_plog_str((lps->bfa)->plog, 7, 22, 0, (char *)"FLOGI Accept");
    }
    __bfa_trc((lps->bfa)->trcmod, __trc_fileno___13, 1293, (unsigned long long )lps->fport);
    __bfa_trc((lps->bfa)->trcmod, __trc_fileno___13, 1294, (unsigned long long )lps->lp_pid);
    if ((unsigned int )lps->fport == 0U && lps->lp_pid != 0U) {
      (*(lps->sm))((void *)lps, 8);
    } else {

    }
  } else {
    lps->sm = (void (*)(void * , int  ))(& bfa_lps_sm_init);
    if ((unsigned int )lps->fdisc != 0U) {
      bfa_plog_str((lps->bfa)->plog, 7, 22, 0, (char *)"FDISC Fail (RJT or timeout)");
    } else {
      bfa_plog_str((lps->bfa)->plog, 7, 22, 0, (char *)"FLOGI Fail (RJT or timeout)");
    }
  }
  bfa_lps_login_comp(lps);
  goto ldv_49012;
  case 6U: ;
  case 5U: 
  lps->sm = (void (*)(void * , int  ))(& bfa_lps_sm_init);
  goto ldv_49012;
  case 8U: 
  __bfa_trc((lps->bfa)->trcmod, __trc_fileno___13, 1318, (unsigned long long )lps->fport);
  __bfa_trc((lps->bfa)->trcmod, __trc_fileno___13, 1319, (unsigned long long )lps->lp_pid);
  goto ldv_49012;
  default: 
  __bfa_trc((lps->bfa)->trcmod, __trc_fileno___13, 1323, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_svc.c",
         1323, (unsigned int )event);
  }
  ldv_49012: ;
  return;
}
}
static void bfa_lps_sm_loginwait(struct bfa_lps_s *lps , enum bfa_lps_event event ) 
{ 


  {
  __bfa_trc((lps->bfa)->trcmod, __trc_fileno___13, 1333, (unsigned long long )lps->bfa_tag);
  __bfa_trc((lps->bfa)->trcmod, __trc_fileno___13, 1334, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 4U: 
  lps->sm = (void (*)(void * , int  ))(& bfa_lps_sm_login);
  bfa_lps_send_login(lps);
  goto ldv_49022;
  case 6U: ;
  case 5U: 
  lps->sm = (void (*)(void * , int  ))(& bfa_lps_sm_init);
  list_del(& lps->wqe.qe);
  goto ldv_49022;
  case 7U: ;
  goto ldv_49022;
  default: 
  __bfa_trc((lps->bfa)->trcmod, __trc_fileno___13, 1357, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_svc.c",
         1357, (unsigned int )event);
  }
  ldv_49022: ;
  return;
}
}
static void bfa_lps_sm_online(struct bfa_lps_s *lps , enum bfa_lps_event event ) 
{ 
  struct list_head *waitq ;
  int __ret_warn_on ;
  long tmp ;
  int __ret_warn_on___0 ;
  long tmp___0 ;
  struct list_head *waitq___0 ;
  int __ret_warn_on___1 ;
  long tmp___1 ;
  int __ret_warn_on___2 ;
  long tmp___2 ;

  {
  __bfa_trc((lps->bfa)->trcmod, __trc_fileno___13, 1367, (unsigned long long )lps->bfa_tag);
  __bfa_trc((lps->bfa)->trcmod, __trc_fileno___13, 1368, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 2U: ;
  if ((((lps->bfa)->iocfc.req_cq_pi[(int )lps->reqq] + 1U) & (u32 )((int )(lps->bfa)->iocfc.cfg.drvcfg.num_reqq_elems + -1)) == *((u32 *)(lps->bfa)->iocfc.req_cq_shadow_ci[(int )lps->reqq].kva)) {
    lps->sm = (void (*)(void * , int  ))(& bfa_lps_sm_logowait);
    waitq = (struct list_head *)(& (lps->bfa)->reqq_waitq) + (unsigned long )lps->reqq;
    __ret_warn_on = (unsigned int )lps->reqq > 3U;
    tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
    if (tmp != 0L) {
      warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_svc.c",
                         1374);
    } else {

    }
    ldv__builtin_expect(__ret_warn_on != 0, 0L);
    __ret_warn_on___0 = (unsigned long )lps->wqe.qresume == (unsigned long )((void (*)(void * ))0) || (unsigned long )lps->wqe.cbarg == (unsigned long )((void *)0);
    tmp___0 = ldv__builtin_expect(__ret_warn_on___0 != 0, 0L);
    if (tmp___0 != 0L) {
      warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_svc.c",
                         1374);
    } else {

    }
    ldv__builtin_expect(__ret_warn_on___0 != 0, 0L);
    list_add_tail(& lps->wqe.qe, waitq);
  } else {
    lps->sm = (void (*)(void * , int  ))(& bfa_lps_sm_logout);
    bfa_lps_send_logout(lps);
  }
  bfa_plog_str((lps->bfa)->plog, 7, 23, 0, (char *)"Logout");
  goto ldv_49037;
  case 7U: 
  lps->sm = (void (*)(void * , int  ))(& bfa_lps_sm_init);
  bfa_lps_cvl_event(lps);
  bfa_plog_str((lps->bfa)->plog, 7, 21, 0, (char *)"FCF Clear Virt. Link Rx");
  goto ldv_49037;
  case 8U: ;
  if ((((lps->bfa)->iocfc.req_cq_pi[(int )lps->reqq] + 1U) & (u32 )((int )(lps->bfa)->iocfc.cfg.drvcfg.num_reqq_elems + -1)) == *((u32 *)(lps->bfa)->iocfc.req_cq_shadow_ci[(int )lps->reqq].kva)) {
    lps->sm = (void (*)(void * , int  ))(& bfa_lps_sm_online_n2n_pid_wait);
    waitq___0 = (struct list_head *)(& (lps->bfa)->reqq_waitq) + (unsigned long )lps->reqq;
    __ret_warn_on___1 = (unsigned int )lps->reqq > 3U;
    tmp___1 = ldv__builtin_expect(__ret_warn_on___1 != 0, 0L);
    if (tmp___1 != 0L) {
      warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_svc.c",
                         1395);
    } else {

    }
    ldv__builtin_expect(__ret_warn_on___1 != 0, 0L);
    __ret_warn_on___2 = (unsigned long )lps->wqe.qresume == (unsigned long )((void (*)(void * ))0) || (unsigned long )lps->wqe.cbarg == (unsigned long )((void *)0);
    tmp___2 = ldv__builtin_expect(__ret_warn_on___2 != 0, 0L);
    if (tmp___2 != 0L) {
      warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_svc.c",
                         1395);
    } else {

    }
    ldv__builtin_expect(__ret_warn_on___2 != 0, 0L);
    list_add_tail(& lps->wqe.qe, waitq___0);
  } else {
    bfa_lps_send_set_n2n_pid(lps);
  }
  goto ldv_49037;
  case 6U: ;
  case 5U: 
  lps->sm = (void (*)(void * , int  ))(& bfa_lps_sm_init);
  goto ldv_49037;
  default: 
  __bfa_trc((lps->bfa)->trcmod, __trc_fileno___13, 1406, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_svc.c",
         1406, (unsigned int )event);
  }
  ldv_49037: ;
  return;
}
}
static void bfa_lps_sm_online_n2n_pid_wait(struct bfa_lps_s *lps , enum bfa_lps_event event ) 
{ 


  {
  __bfa_trc((lps->bfa)->trcmod, __trc_fileno___13, 1416, (unsigned long long )lps->bfa_tag);
  __bfa_trc((lps->bfa)->trcmod, __trc_fileno___13, 1417, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 4U: 
  lps->sm = (void (*)(void * , int  ))(& bfa_lps_sm_online);
  bfa_lps_send_set_n2n_pid(lps);
  goto ldv_49053;
  case 2U: 
  lps->sm = (void (*)(void * , int  ))(& bfa_lps_sm_logowait);
  bfa_plog_str((lps->bfa)->plog, 7, 23, 0, (char *)"Logout");
  goto ldv_49053;
  case 7U: 
  lps->sm = (void (*)(void * , int  ))(& bfa_lps_sm_init);
  list_del(& lps->wqe.qe);
  bfa_lps_cvl_event(lps);
  bfa_plog_str((lps->bfa)->plog, 7, 21, 0, (char *)"FCF Clear Virt. Link Rx");
  goto ldv_49053;
  case 6U: ;
  case 5U: 
  lps->sm = (void (*)(void * , int  ))(& bfa_lps_sm_init);
  list_del(& lps->wqe.qe);
  goto ldv_49053;
  default: 
  __bfa_trc((lps->bfa)->trcmod, __trc_fileno___13, 1448, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_svc.c",
         1448, (unsigned int )event);
  }
  ldv_49053: ;
  return;
}
}
static void bfa_lps_sm_logout(struct bfa_lps_s *lps , enum bfa_lps_event event ) 
{ 


  {
  __bfa_trc((lps->bfa)->trcmod, __trc_fileno___13, 1458, (unsigned long long )lps->bfa_tag);
  __bfa_trc((lps->bfa)->trcmod, __trc_fileno___13, 1459, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 3U: ;
  case 6U: 
  lps->sm = (void (*)(void * , int  ))(& bfa_lps_sm_init);
  bfa_lps_logout_comp(lps);
  goto ldv_49065;
  case 5U: 
  lps->sm = (void (*)(void * , int  ))(& bfa_lps_sm_init);
  goto ldv_49065;
  default: 
  __bfa_trc((lps->bfa)->trcmod, __trc_fileno___13, 1473, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_svc.c",
         1473, (unsigned int )event);
  }
  ldv_49065: ;
  return;
}
}
static void bfa_lps_sm_logowait(struct bfa_lps_s *lps , enum bfa_lps_event event ) 
{ 


  {
  __bfa_trc((lps->bfa)->trcmod, __trc_fileno___13, 1483, (unsigned long long )lps->bfa_tag);
  __bfa_trc((lps->bfa)->trcmod, __trc_fileno___13, 1484, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 4U: 
  lps->sm = (void (*)(void * , int  ))(& bfa_lps_sm_logout);
  bfa_lps_send_logout(lps);
  goto ldv_49073;
  case 6U: ;
  case 5U: 
  lps->sm = (void (*)(void * , int  ))(& bfa_lps_sm_init);
  list_del(& lps->wqe.qe);
  goto ldv_49073;
  default: 
  __bfa_trc((lps->bfa)->trcmod, __trc_fileno___13, 1499, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_svc.c",
         1499, (unsigned int )event);
  }
  ldv_49073: ;
  return;
}
}
static void bfa_lps_meminfo(struct bfa_iocfc_cfg_s *cfg , struct bfa_meminfo_s *minfo ,
                            struct bfa_s *bfa ) 
{ 
  struct bfa_mem_kva_s *lps_kva ;

  {
  lps_kva = & bfa->modules.lps_mod.kva_seg;
  if ((unsigned int )cfg->drvcfg.min_cfg != 0U) {
    lps_kva->mem_len = 232U;
    list_add_tail(& lps_kva->qe, & minfo->kva_info.qe);
  } else {
    lps_kva->mem_len = 59392U;
    list_add_tail(& lps_kva->qe, & minfo->kva_info.qe);
  }
  return;
}
}
static void bfa_lps_attach(struct bfa_s *bfa , void *bfad , struct bfa_iocfc_cfg_s *cfg ,
                           struct bfa_pcidev_s *pcidev ) 
{ 
  struct bfa_lps_mod_s *mod ;
  struct bfa_lps_s *lps ;
  int i ;

  {
  mod = & bfa->modules.lps_mod;
  mod->num_lps = 256;
  if ((unsigned int )cfg->drvcfg.min_cfg != 0U) {
    mod->num_lps = 1;
  } else {
    mod->num_lps = 256;
  }
  lps = (struct bfa_lps_s *)mod->kva_seg.kva_curp;
  mod->lps_arr = lps;
  mod->kva_seg.kva_curp = mod->kva_seg.kva_curp + (unsigned long )mod->num_lps * 232UL;
  INIT_LIST_HEAD(& mod->lps_free_q);
  INIT_LIST_HEAD(& mod->lps_active_q);
  INIT_LIST_HEAD(& mod->lps_login_q);
  i = 0;
  goto ldv_49093;
  ldv_49092: 
  lps->bfa = bfa;
  lps->bfa_tag = (unsigned char )i;
  lps->reqq = 0U;
  bfa_reqq_winit(& lps->wqe, & bfa_lps_reqq_resume, (void *)lps);
  list_add_tail(& lps->qe, & mod->lps_free_q);
  i = i + 1;
  lps = lps + 1;
  ldv_49093: ;
  if (mod->num_lps > i) {
    goto ldv_49092;
  } else {

  }

  return;
}
}
static void bfa_lps_detach(struct bfa_s *bfa ) 
{ 


  {
  return;
}
}
static void bfa_lps_start(struct bfa_s *bfa ) 
{ 


  {
  return;
}
}
static void bfa_lps_stop(struct bfa_s *bfa ) 
{ 


  {
  return;
}
}
static void bfa_lps_iocdisable(struct bfa_s *bfa ) 
{ 
  struct bfa_lps_mod_s *mod ;
  struct bfa_lps_s *lps ;
  struct list_head *qe ;
  struct list_head *qen ;

  {
  mod = & bfa->modules.lps_mod;
  qe = mod->lps_active_q.next;
  qen = qe->next;
  goto ldv_49112;
  ldv_49111: 
  lps = (struct bfa_lps_s *)qe;
  (*(lps->sm))((void *)lps, 6);
  qe = qen;
  qen = qe->next;
  ldv_49112: ;
  if ((unsigned long )(& mod->lps_active_q) != (unsigned long )qe) {
    goto ldv_49111;
  } else {

  }
  qe = mod->lps_login_q.next;
  qen = qe->next;
  goto ldv_49115;
  ldv_49114: 
  lps = (struct bfa_lps_s *)qe;
  (*(lps->sm))((void *)lps, 6);
  qe = qen;
  qen = qe->next;
  ldv_49115: ;
  if ((unsigned long )(& mod->lps_login_q) != (unsigned long )qe) {
    goto ldv_49114;
  } else {

  }
  list_splice_tail_init(& mod->lps_login_q, & mod->lps_active_q);
  return;
}
}
static void bfa_lps_login_rsp(struct bfa_s *bfa , struct bfi_lps_login_rsp_s *rsp ) 
{ 
  struct bfa_lps_mod_s *mod ;
  struct bfa_lps_s *lps ;
  int __ret_warn_on ;
  long tmp ;
  __u16 tmp___0 ;

  {
  mod = & bfa->modules.lps_mod;
  __ret_warn_on = (int )rsp->bfa_tag >= mod->num_lps;
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_svc.c",
                       1604);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  lps = mod->lps_arr + (unsigned long )rsp->bfa_tag;
  lps->status = (enum bfa_status )rsp->status;
  switch ((int )rsp->status) {
  case 0: 
  lps->fw_tag = rsp->fw_tag;
  lps->fport = (enum bfa_boolean )rsp->f_port;
  if ((unsigned int )lps->fport != 0U) {
    lps->lp_pid = rsp->lp_pid;
  } else {

  }
  lps->npiv_en = (enum bfa_boolean )rsp->npiv_en;
  tmp___0 = __fswab16((int )rsp->bb_credit);
  lps->pr_bbcred = tmp___0;
  lps->pr_pwwn = rsp->port_name;
  lps->pr_nwwn = rsp->node_name;
  lps->auth_req = (enum bfa_boolean )rsp->auth_req;
  lps->lp_mac = rsp->lp_mac;
  lps->brcd_switch = (enum bfa_boolean )rsp->brcd_switch;
  lps->fcf_mac = rsp->fcf_mac;
  goto ldv_49126;
  case 29: 
  lps->lsrjt_rsn = rsp->lsrjt_rsn;
  lps->lsrjt_expl = rsp->lsrjt_expl;
  goto ldv_49126;
  case 6: 
  lps->ext_status = (enum bfa_eproto_status )rsp->ext_status;
  goto ldv_49126;
  case 22: ;
  if ((unsigned int )rsp->ext_status != 0U) {
    bfa_lps_no_res(lps, (int )rsp->ext_status);
  } else {

  }
  goto ldv_49126;
  default: ;
  goto ldv_49126;
  }
  ldv_49126: 
  list_del(& lps->qe);
  list_add_tail(& lps->qe, & mod->lps_active_q);
  (*(lps->sm))((void *)lps, 3);
  return;
}
}
static void bfa_lps_no_res(struct bfa_lps_s *first_lps , u8 count ) 
{ 
  struct bfa_s *bfa ;
  struct bfa_lps_mod_s *mod ;
  struct list_head *qe ;
  struct list_head *qe_next ;
  struct bfa_lps_s *lps ;

  {
  bfa = first_lps->bfa;
  mod = & bfa->modules.lps_mod;
  __bfa_trc(bfa->trcmod, __trc_fileno___13, 1659, (unsigned long long )count);
  qe = ((struct list_head *)first_lps)->next;
  goto ldv_49141;
  ldv_49140: 
  qe_next = qe->next;
  lps = (struct bfa_lps_s *)qe;
  __bfa_trc(bfa->trcmod, __trc_fileno___13, 1666, (unsigned long long )lps->bfa_tag);
  lps->status = first_lps->status;
  list_del(& lps->qe);
  list_add_tail(& lps->qe, & mod->lps_active_q);
  (*(lps->sm))((void *)lps, 3);
  qe = qe_next;
  count = (u8 )((int )count - 1);
  ldv_49141: ;
  if ((unsigned int )count != 0U && (unsigned long )qe != (unsigned long )((struct list_head *)0)) {
    goto ldv_49140;
  } else {

  }

  return;
}
}
static void bfa_lps_logout_rsp(struct bfa_s *bfa , struct bfi_lps_logout_rsp_s *rsp ) 
{ 
  struct bfa_lps_mod_s *mod ;
  struct bfa_lps_s *lps ;
  int __ret_warn_on ;
  long tmp ;

  {
  mod = & bfa->modules.lps_mod;
  __ret_warn_on = (int )rsp->bfa_tag >= mod->num_lps;
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_svc.c",
                       1685);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  lps = mod->lps_arr + (unsigned long )rsp->bfa_tag;
  (*(lps->sm))((void *)lps, 3);
  return;
}
}
static void bfa_lps_rx_cvl_event(struct bfa_s *bfa , struct bfi_lps_cvl_event_s *cvl ) 
{ 
  struct bfa_lps_mod_s *mod ;
  struct bfa_lps_s *lps ;

  {
  mod = & bfa->modules.lps_mod;
  lps = mod->lps_arr + (unsigned long )cvl->bfa_tag;
  (*(lps->sm))((void *)lps, 7);
  return;
}
}
static void bfa_lps_reqq_resume(void *lps_arg ) 
{ 
  struct bfa_lps_s *lps ;

  {
  lps = (struct bfa_lps_s *)lps_arg;
  (*(lps->sm))((void *)lps, 4);
  return;
}
}
static void bfa_lps_free(struct bfa_lps_s *lps ) 
{ 
  struct bfa_lps_mod_s *mod ;

  {
  mod = & (lps->bfa)->modules.lps_mod;
  lps->lp_pid = 0U;
  list_del(& lps->qe);
  list_add_tail(& lps->qe, & mod->lps_free_q);
  return;
}
}
static void bfa_lps_send_login(struct bfa_lps_s *lps ) 
{ 
  struct bfa_lps_mod_s *mod ;
  struct bfi_lps_login_req_s *m ;
  int __ret_warn_on ;
  long tmp ;
  __u16 tmp___0 ;

  {
  mod = & (lps->bfa)->modules.lps_mod;
  m = (((lps->bfa)->iocfc.req_cq_pi[(int )lps->reqq] + 1U) & (u32 )((int )(lps->bfa)->iocfc.cfg.drvcfg.num_reqq_elems + -1)) != *((u32 *)(lps->bfa)->iocfc.req_cq_shadow_ci[(int )lps->reqq].kva) ? (struct bfi_lps_login_req_s *)(lps->bfa)->iocfc.req_cq_ba[(int )lps->reqq].kva + (unsigned long )(lps->bfa)->iocfc.req_cq_pi[(int )lps->reqq] : (struct bfi_lps_login_req_s *)0;
  __ret_warn_on = (unsigned long )m == (unsigned long )((struct bfi_lps_login_req_s *)0);
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_svc.c",
                       1739);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  m->mh.msg_class = 10U;
  m->mh.msg_id = 1U;
  m->mh.mtag.h2i.fn_lpu = (u8 )((int )((signed char )((int )(lps->bfa)->ioc.pcidev.pci_func << 1)) | (int )((signed char )(lps->bfa)->ioc.port_id));
  m->bfa_tag = lps->bfa_tag;
  m->alpa = lps->alpa;
  tmp___0 = __fswab16((int )lps->pdusz);
  m->pdu_size = tmp___0;
  m->pwwn = lps->pwwn;
  m->nwwn = lps->nwwn;
  m->fdisc = (u8 )lps->fdisc;
  m->auth_en = (u8 )lps->auth_en;
  m->mh.mtag.h2i.qid = (lps->bfa)->iocfc.hw_qid[(int )lps->reqq];
  (lps->bfa)->iocfc.req_cq_pi[(int )lps->reqq] = (lps->bfa)->iocfc.req_cq_pi[(int )lps->reqq] + 1U;
  (lps->bfa)->iocfc.req_cq_pi[(int )lps->reqq] = (lps->bfa)->iocfc.req_cq_pi[(int )lps->reqq] & (u32 )((int )(lps->bfa)->iocfc.cfg.drvcfg.num_reqq_elems + -1);
  writel((lps->bfa)->iocfc.req_cq_pi[(int )lps->reqq], (void volatile   *)(lps->bfa)->iocfc.bfa_regs.cpe_q_pi[(int )lps->reqq]);
  __asm__  volatile   ("": : : "memory");
  list_del(& lps->qe);
  list_add_tail(& lps->qe, & mod->lps_login_q);
  return;
}
}
static void bfa_lps_send_logout(struct bfa_lps_s *lps ) 
{ 
  struct bfi_lps_logout_req_s *m ;
  int __ret_warn_on ;
  long tmp ;

  {
  m = (((lps->bfa)->iocfc.req_cq_pi[(int )lps->reqq] + 1U) & (u32 )((int )(lps->bfa)->iocfc.cfg.drvcfg.num_reqq_elems + -1)) != *((u32 *)(lps->bfa)->iocfc.req_cq_shadow_ci[(int )lps->reqq].kva) ? (struct bfi_lps_logout_req_s *)(lps->bfa)->iocfc.req_cq_ba[(int )lps->reqq].kva + (unsigned long )(lps->bfa)->iocfc.req_cq_pi[(int )lps->reqq] : (struct bfi_lps_logout_req_s *)0;
  __ret_warn_on = (unsigned long )m == (unsigned long )((struct bfi_lps_logout_req_s *)0);
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_svc.c",
                       1766);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  m->mh.msg_class = 10U;
  m->mh.msg_id = 2U;
  m->mh.mtag.h2i.fn_lpu = (u8 )((int )((signed char )((int )(lps->bfa)->ioc.pcidev.pci_func << 1)) | (int )((signed char )(lps->bfa)->ioc.port_id));
  m->fw_tag = lps->fw_tag;
  m->port_name = lps->pwwn;
  m->mh.mtag.h2i.qid = (lps->bfa)->iocfc.hw_qid[(int )lps->reqq];
  (lps->bfa)->iocfc.req_cq_pi[(int )lps->reqq] = (lps->bfa)->iocfc.req_cq_pi[(int )lps->reqq] + 1U;
  (lps->bfa)->iocfc.req_cq_pi[(int )lps->reqq] = (lps->bfa)->iocfc.req_cq_pi[(int )lps->reqq] & (u32 )((int )(lps->bfa)->iocfc.cfg.drvcfg.num_reqq_elems + -1);
  writel((lps->bfa)->iocfc.req_cq_pi[(int )lps->reqq], (void volatile   *)(lps->bfa)->iocfc.bfa_regs.cpe_q_pi[(int )lps->reqq]);
  __asm__  volatile   ("": : : "memory");
  return;
}
}
static void bfa_lps_send_set_n2n_pid(struct bfa_lps_s *lps ) 
{ 
  struct bfi_lps_n2n_pid_req_s *m ;
  int __ret_warn_on ;
  long tmp ;

  {
  m = (((lps->bfa)->iocfc.req_cq_pi[(int )lps->reqq] + 1U) & (u32 )((int )(lps->bfa)->iocfc.cfg.drvcfg.num_reqq_elems + -1)) != *((u32 *)(lps->bfa)->iocfc.req_cq_shadow_ci[(int )lps->reqq].kva) ? (struct bfi_lps_n2n_pid_req_s *)(lps->bfa)->iocfc.req_cq_ba[(int )lps->reqq].kva + (unsigned long )(lps->bfa)->iocfc.req_cq_pi[(int )lps->reqq] : (struct bfi_lps_n2n_pid_req_s *)0;
  __ret_warn_on = (unsigned long )m == (unsigned long )((struct bfi_lps_n2n_pid_req_s *)0);
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_svc.c",
                       1785);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  m->mh.msg_class = 10U;
  m->mh.msg_id = 3U;
  m->mh.mtag.h2i.fn_lpu = (u8 )((int )((signed char )((int )(lps->bfa)->ioc.pcidev.pci_func << 1)) | (int )((signed char )(lps->bfa)->ioc.port_id));
  m->fw_tag = lps->fw_tag;
  m->lp_pid = lps->lp_pid;
  m->mh.mtag.h2i.qid = (lps->bfa)->iocfc.hw_qid[(int )lps->reqq];
  (lps->bfa)->iocfc.req_cq_pi[(int )lps->reqq] = (lps->bfa)->iocfc.req_cq_pi[(int )lps->reqq] + 1U;
  (lps->bfa)->iocfc.req_cq_pi[(int )lps->reqq] = (lps->bfa)->iocfc.req_cq_pi[(int )lps->reqq] & (u32 )((int )(lps->bfa)->iocfc.cfg.drvcfg.num_reqq_elems + -1);
  writel((lps->bfa)->iocfc.req_cq_pi[(int )lps->reqq], (void volatile   *)(lps->bfa)->iocfc.bfa_regs.cpe_q_pi[(int )lps->reqq]);
  __asm__  volatile   ("": : : "memory");
  return;
}
}
static void bfa_lps_login_comp_cb(void *arg , enum bfa_boolean complete___0 ) 
{ 
  struct bfa_lps_s *lps ;

  {
  lps = (struct bfa_lps_s *)arg;
  if ((unsigned int )complete___0 == 0U) {
    return;
  } else {

  }
  if ((unsigned int )lps->fdisc != 0U) {
    bfa_cb_lps_fdisc_comp((lps->bfa)->bfad, lps->uarg, lps->status);
  } else {
    bfa_cb_lps_flogi_comp((lps->bfa)->bfad, lps->uarg, lps->status);
  }
  return;
}
}
static void bfa_lps_login_comp(struct bfa_lps_s *lps ) 
{ 


  {
  if ((unsigned int )(lps->bfa)->fcs == 0U) {
    lps->hcb_qe.cbfn = & bfa_lps_login_comp_cb;
    lps->hcb_qe.cbarg = (void *)lps;
    lps->hcb_qe.pre_rmv = 0;
    list_add_tail(& lps->hcb_qe.qe, & (lps->bfa)->comp_q);
    return;
  } else {

  }
  if ((unsigned int )lps->fdisc != 0U) {
    bfa_cb_lps_fdisc_comp((lps->bfa)->bfad, lps->uarg, lps->status);
  } else {
    bfa_cb_lps_flogi_comp((lps->bfa)->bfad, lps->uarg, lps->status);
  }
  return;
}
}
static void bfa_lps_logout_comp_cb(void *arg , enum bfa_boolean complete___0 ) 
{ 
  struct bfa_lps_s *lps ;

  {
  lps = (struct bfa_lps_s *)arg;
  if ((unsigned int )complete___0 == 0U) {
    return;
  } else {

  }
  if ((unsigned int )lps->fdisc != 0U) {
    bfa_cb_lps_fdisclogo_comp((lps->bfa)->bfad, lps->uarg);
  } else {
    bfa_cb_lps_flogo_comp((lps->bfa)->bfad, lps->uarg);
  }
  return;
}
}
static void bfa_lps_logout_comp(struct bfa_lps_s *lps ) 
{ 


  {
  if ((unsigned int )(lps->bfa)->fcs == 0U) {
    lps->hcb_qe.cbfn = & bfa_lps_logout_comp_cb;
    lps->hcb_qe.cbarg = (void *)lps;
    lps->hcb_qe.pre_rmv = 0;
    list_add_tail(& lps->hcb_qe.qe, & (lps->bfa)->comp_q);
    return;
  } else {

  }
  if ((unsigned int )lps->fdisc != 0U) {
    bfa_cb_lps_fdisclogo_comp((lps->bfa)->bfad, lps->uarg);
  } else {

  }
  return;
}
}
static void bfa_lps_cvl_event_cb(void *arg , enum bfa_boolean complete___0 ) 
{ 
  struct bfa_lps_s *lps ;

  {
  lps = (struct bfa_lps_s *)arg;
  if ((unsigned int )complete___0 == 0U) {
    return;
  } else {

  }
  if ((unsigned int )lps->fdisc != 0U) {
    bfa_cb_lps_cvl_event((lps->bfa)->bfad, lps->uarg);
  } else {

  }
  return;
}
}
static void bfa_lps_cvl_event(struct bfa_lps_s *lps ) 
{ 


  {
  if ((unsigned int )(lps->bfa)->fcs == 0U) {
    lps->hcb_qe.cbfn = & bfa_lps_cvl_event_cb;
    lps->hcb_qe.cbarg = (void *)lps;
    lps->hcb_qe.pre_rmv = 0;
    list_add_tail(& lps->hcb_qe.qe, & (lps->bfa)->comp_q);
    return;
  } else {

  }
  if ((unsigned int )lps->fdisc != 0U) {
    bfa_cb_lps_cvl_event((lps->bfa)->bfad, lps->uarg);
  } else {

  }
  return;
}
}
u32 bfa_lps_get_max_vport(struct bfa_s *bfa ) 
{ 


  {
  if ((unsigned int )bfa->ioc.pcidev.device_id == 20U) {
    return (190U);
  } else {
    return (255U);
  }
}
}
struct bfa_lps_s *bfa_lps_alloc(struct bfa_s *bfa ) 
{ 
  struct bfa_lps_mod_s *mod ;
  struct bfa_lps_s *lps ;
  int tmp ;

  {
  mod = & bfa->modules.lps_mod;
  lps = (struct bfa_lps_s *)0;
  tmp = list_empty((struct list_head  const  *)(& mod->lps_free_q));
  if (tmp == 0) {
    *((struct list_head **)(& lps)) = mod->lps_free_q.next;
    ((*((struct list_head **)(& lps)))->next)->prev = & mod->lps_free_q;
    mod->lps_free_q.next = (*((struct list_head **)(& lps)))->next;
  } else {
    *((struct list_head **)(& lps)) = (struct list_head *)0;
  }
  if ((unsigned long )lps == (unsigned long )((struct bfa_lps_s *)0)) {
    return ((struct bfa_lps_s *)0);
  } else {

  }
  list_add_tail(& lps->qe, & mod->lps_active_q);
  lps->sm = (void (*)(void * , int  ))(& bfa_lps_sm_init);
  return (lps);
}
}
void bfa_lps_delete(struct bfa_lps_s *lps ) 
{ 


  {
  (*(lps->sm))((void *)lps, 5);
  return;
}
}
void bfa_lps_flogi(struct bfa_lps_s *lps , void *uarg , u8 alpa , u16 pdusz , wwn_t pwwn ,
                   wwn_t nwwn , enum bfa_boolean auth_en ) 
{ 


  {
  lps->uarg = uarg;
  lps->alpa = alpa;
  lps->pdusz = pdusz;
  lps->pwwn = pwwn;
  lps->nwwn = nwwn;
  lps->fdisc = 0;
  lps->auth_en = auth_en;
  (*(lps->sm))((void *)lps, 1);
  return;
}
}
void bfa_lps_fdisc(struct bfa_lps_s *lps , void *uarg , u16 pdusz , wwn_t pwwn , wwn_t nwwn ) 
{ 


  {
  lps->uarg = uarg;
  lps->alpa = 0U;
  lps->pdusz = pdusz;
  lps->pwwn = pwwn;
  lps->nwwn = nwwn;
  lps->fdisc = 1;
  lps->auth_en = 0;
  (*(lps->sm))((void *)lps, 1);
  return;
}
}
void bfa_lps_fdisclogo(struct bfa_lps_s *lps ) 
{ 


  {
  (*(lps->sm))((void *)lps, 2);
  return;
}
}
u8 bfa_lps_get_fwtag(struct bfa_s *bfa , u8 lp_tag ) 
{ 
  struct bfa_lps_mod_s *mod ;

  {
  mod = & bfa->modules.lps_mod;
  return ((mod->lps_arr + (unsigned long )lp_tag)->fw_tag);
}
}
u8 bfa_lps_get_tag_from_pid(struct bfa_s *bfa , u32 pid ) 
{ 
  struct bfa_lps_mod_s *mod ;
  struct bfa_lps_s *lps ;
  int i ;

  {
  mod = & bfa->modules.lps_mod;
  i = 0;
  lps = mod->lps_arr;
  goto ldv_49251;
  ldv_49250: ;
  if (lps->lp_pid == pid) {
    return (lps->bfa_tag);
  } else {

  }
  i = i + 1;
  lps = lps + 1;
  ldv_49251: ;
  if (mod->num_lps > i) {
    goto ldv_49250;
  } else {

  }

  return (0U);
}
}
u32 bfa_lps_get_base_pid(struct bfa_s *bfa ) 
{ 
  struct bfa_lps_mod_s *mod ;

  {
  mod = & bfa->modules.lps_mod;
  return ((mod->lps_arr)->lp_pid);
}
}
void bfa_lps_set_n2n_pid(struct bfa_lps_s *lps , unsigned int n2n_pid ) 
{ 


  {
  __bfa_trc((lps->bfa)->trcmod, __trc_fileno___13, 2030, (unsigned long long )lps->bfa_tag);
  __bfa_trc((lps->bfa)->trcmod, __trc_fileno___13, 2031, (unsigned long long )n2n_pid);
  lps->lp_pid = n2n_pid;
  (*(lps->sm))((void *)lps, 8);
  return;
}
}
void bfa_lps_isr(struct bfa_s *bfa , struct bfi_msg_s *m ) 
{ 
  union bfi_lps_i2h_msg_u msg ;
  int __ret_warn_on ;
  long tmp ;

  {
  __bfa_trc(bfa->trcmod, __trc_fileno___13, 2045, (unsigned long long )m->mhdr.msg_id);
  msg.msg = m;
  switch ((int )m->mhdr.msg_id) {
  case 129: 
  bfa_lps_login_rsp(bfa, msg.login_rsp);
  goto ldv_49267;
  case 130: 
  bfa_lps_logout_rsp(bfa, msg.logout_rsp);
  goto ldv_49267;
  case 131: 
  bfa_lps_rx_cvl_event(bfa, msg.cvl_event);
  goto ldv_49267;
  default: 
  __bfa_trc(bfa->trcmod, __trc_fileno___13, 2062, (unsigned long long )m->mhdr.msg_id);
  __ret_warn_on = 1;
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_svc.c",
                       2063);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  }
  ldv_49267: ;
  return;
}
}
static void bfa_fcport_aen_post(struct bfa_fcport_s *fcport , enum bfa_port_aen_event event ) 
{ 
  struct bfad_s *bfad ;
  struct bfa_aen_entry_s *aen_entry ;
  unsigned long _flags ;
  raw_spinlock_t *tmp ;
  int tmp___0 ;
  enum bfa_ioc_type_e tmp___1 ;

  {
  bfad = (struct bfad_s *)(fcport->bfa)->bfad;
  tmp = spinlock_check(& bfad->bfad_aen_spinlock);
  _flags = _raw_spin_lock_irqsave(tmp);
  tmp___0 = list_empty((struct list_head  const  *)(& bfad->free_aen_q));
  if (tmp___0 == 0) {
    *((struct list_head **)(& aen_entry)) = bfad->free_aen_q.next;
    ((*((struct list_head **)(& aen_entry)))->next)->prev = & bfad->free_aen_q;
    bfad->free_aen_q.next = (*((struct list_head **)(& aen_entry)))->next;
  } else {
    *((struct list_head **)(& aen_entry)) = (struct list_head *)0;
  }
  if ((unsigned long )aen_entry != (unsigned long )((struct bfa_aen_entry_s *)0)) {
    list_add_tail(& aen_entry->qe, & bfad->active_aen_q);
  } else {

  }
  spin_unlock_irqrestore(& bfad->bfad_aen_spinlock, _flags);
  if ((unsigned long )aen_entry == (unsigned long )((struct bfa_aen_entry_s *)0)) {
    return;
  } else {

  }
  tmp___1 = bfa_ioc_get_type(& (fcport->bfa)->ioc);
  aen_entry->aen_data.port.ioc_type = (u16 )tmp___1;
  aen_entry->aen_data.port.pwwn = fcport->pwwn;
  do_gettimeofday(& aen_entry->aen_tv);
  aen_entry->bfad_num = bfad->inst_no;
  (fcport->bfa)->bfa_aen_seq = (fcport->bfa)->bfa_aen_seq + 1;
  aen_entry->seq_num = (u32 )(fcport->bfa)->bfa_aen_seq;
  aen_entry->aen_category = 2;
  aen_entry->aen_type = (u32 )event;
  if ((bfad->bfad_flags & 512U) != 0U) {
    queue_work___5((bfad->im)->drv_workq, & (bfad->im)->aen_im_notify_work);
  } else {

  }
  return;
}
}
static void bfa_fcport_sm_uninit(struct bfa_fcport_s *fcport , enum bfa_fcport_sm_event event ) 
{ 
  enum bfa_boolean tmp ;

  {
  __bfa_trc((fcport->bfa)->trcmod, __trc_fileno___13, 2092, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 1U: 
  fcport->use_flash_cfg = 1;
  tmp = bfa_fcport_send_enable(fcport);
  if ((unsigned int )tmp != 0U) {
    __bfa_trc((fcport->bfa)->trcmod, __trc_fileno___13, 2102, 1ULL);
    fcport->sm = (void (*)(void * , int  ))(& bfa_fcport_sm_enabling);
  } else {
    __bfa_trc((fcport->bfa)->trcmod, __trc_fileno___13, 2105, 0ULL);
    fcport->sm = (void (*)(void * , int  ))(& bfa_fcport_sm_enabling_qwait);
  }
  goto ldv_49288;
  case 3U: ;
  goto ldv_49288;
  case 4U: 
  fcport->sm = (void (*)(void * , int  ))(& bfa_fcport_sm_disabled);
  goto ldv_49288;
  case 9U: 
  fcport->sm = (void (*)(void * , int  ))(& bfa_fcport_sm_iocdown);
  goto ldv_49288;
  default: 
  __bfa_trc((fcport->bfa)->trcmod, __trc_fileno___13, 2132, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_svc.c",
         2132, (unsigned int )event);
  }
  ldv_49288: ;
  return;
}
}
static void bfa_fcport_sm_enabling_qwait(struct bfa_fcport_s *fcport , enum bfa_fcport_sm_event event ) 
{ 
  char pwwn_buf[32U] ;
  struct bfad_s *bfad ;

  {
  bfad = (struct bfad_s *)(fcport->bfa)->bfad;
  __bfa_trc((fcport->bfa)->trcmod, __trc_fileno___13, 2142, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 8U: 
  fcport->sm = (void (*)(void * , int  ))(& bfa_fcport_sm_enabling);
  bfa_fcport_send_enable(fcport);
  goto ldv_49300;
  case 2U: 
  list_del(& fcport->reqq_wait.qe);
  fcport->sm = (void (*)(void * , int  ))(& bfa_fcport_sm_stopped);
  goto ldv_49300;
  case 3U: ;
  goto ldv_49300;
  case 4U: 
  fcport->sm = (void (*)(void * , int  ))(& bfa_fcport_sm_disabled);
  list_del(& fcport->reqq_wait.qe);
  bfa_plog_str((fcport->bfa)->plog, 3, 3, 0, (char *)"Port Disable");
  wwn2str___5((char *)(& pwwn_buf), fcport->pwwn);
  if (bfa_log_level == 4 || (int )((signed char )*("\016" + 1)) <= 52) {
    dev_printk("\016", (struct device  const  *)(& (bfad->pcidev)->dev), "Base port disabled: WWN = %s\n",
               (char *)(& pwwn_buf));
  } else {

  }
  bfa_fcport_aen_post(fcport, 8);
  goto ldv_49300;
  case 6U: ;
  case 7U: ;
  goto ldv_49300;
  case 9U: 
  list_del(& fcport->reqq_wait.qe);
  fcport->sm = (void (*)(void * , int  ))(& bfa_fcport_sm_iocdown);
  goto ldv_49300;
  case 12U: 
  bfa_fcport_reset_linkinfo(fcport);
  bfa_fcport_aen_post(fcport, 11);
  fcport->sm = (void (*)(void * , int  ))(& bfa_fcport_sm_faa_misconfig);
  goto ldv_49300;
  default: 
  __bfa_trc((fcport->bfa)->trcmod, __trc_fileno___13, 2196, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_svc.c",
         2196, (unsigned int )event);
  }
  ldv_49300: ;
  return;
}
}
static void bfa_fcport_sm_enabling(struct bfa_fcport_s *fcport , enum bfa_fcport_sm_event event ) 
{ 
  char pwwn_buf[32U] ;
  struct bfad_s *bfad ;
  int __ret_warn_on ;
  long tmp ;
  enum bfa_boolean tmp___0 ;

  {
  bfad = (struct bfad_s *)(fcport->bfa)->bfad;
  __bfa_trc((fcport->bfa)->trcmod, __trc_fileno___13, 2206, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 5U: ;
  case 7U: 
  fcport->sm = (void (*)(void * , int  ))(& bfa_fcport_sm_linkdown);
  goto ldv_49317;
  case 6U: 
  bfa_fcport_update_linkinfo(fcport);
  fcport->sm = (void (*)(void * , int  ))(& bfa_fcport_sm_linkup);
  __ret_warn_on = (unsigned long )fcport->event_cbfn == (unsigned long )((void (*)(void * ,
                                                                                   enum bfa_port_linkstate  ))0);
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_svc.c",
                       2218);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  bfa_fcport_scn(fcport, 1, 0);
  goto ldv_49317;
  case 3U: ;
  goto ldv_49317;
  case 4U: 
  tmp___0 = bfa_fcport_send_disable(fcport);
  if ((unsigned int )tmp___0 != 0U) {
    fcport->sm = (void (*)(void * , int  ))(& bfa_fcport_sm_disabling);
  } else {
    fcport->sm = (void (*)(void * , int  ))(& bfa_fcport_sm_disabling_qwait);
  }
  bfa_plog_str((fcport->bfa)->plog, 3, 3, 0, (char *)"Port Disable");
  wwn2str___5((char *)(& pwwn_buf), fcport->pwwn);
  if (bfa_log_level == 4 || (int )((signed char )*("\016" + 1)) <= 52) {
    dev_printk("\016", (struct device  const  *)(& (bfad->pcidev)->dev), "Base port disabled: WWN = %s\n",
               (char *)(& pwwn_buf));
  } else {

  }
  bfa_fcport_aen_post(fcport, 8);
  goto ldv_49317;
  case 2U: 
  fcport->sm = (void (*)(void * , int  ))(& bfa_fcport_sm_stopped);
  goto ldv_49317;
  case 9U: 
  fcport->sm = (void (*)(void * , int  ))(& bfa_fcport_sm_iocdown);
  goto ldv_49317;
  case 12U: 
  bfa_fcport_reset_linkinfo(fcport);
  bfa_fcport_aen_post(fcport, 11);
  fcport->sm = (void (*)(void * , int  ))(& bfa_fcport_sm_faa_misconfig);
  goto ldv_49317;
  default: 
  __bfa_trc((fcport->bfa)->trcmod, __trc_fileno___13, 2258, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_svc.c",
         2258, (unsigned int )event);
  }
  ldv_49317: ;
  return;
}
}
static void bfa_fcport_sm_linkdown(struct bfa_fcport_s *fcport , enum bfa_fcport_sm_event event ) 
{ 
  struct bfi_fcport_event_s *pevent ;
  char pwwn_buf[32U] ;
  struct bfad_s *bfad ;
  int __ret_warn_on ;
  long tmp ;
  enum bfa_boolean tmp___0 ;

  {
  pevent = fcport->event_arg.i2hmsg.event;
  bfad = (struct bfad_s *)(fcport->bfa)->bfad;
  __bfa_trc((fcport->bfa)->trcmod, __trc_fileno___13, 2270, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 6U: 
  bfa_fcport_update_linkinfo(fcport);
  fcport->sm = (void (*)(void * , int  ))(& bfa_fcport_sm_linkup);
  __ret_warn_on = (unsigned long )fcport->event_cbfn == (unsigned long )((void (*)(void * ,
                                                                                   enum bfa_port_linkstate  ))0);
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_svc.c",
                       2276);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  bfa_plog_str((fcport->bfa)->plog, 3, 5, 0, (char *)"Port Linkup");
  if ((unsigned int )(fcport->bfa)->ioc.fcmode == 0U) {
    __bfa_trc((fcport->bfa)->trcmod, __trc_fileno___13, 2282, (unsigned long long )pevent->link_state.attr.vc_fcf.fcf.fipenabled);
    __bfa_trc((fcport->bfa)->trcmod, __trc_fileno___13, 2284, (unsigned long long )pevent->link_state.attr.vc_fcf.fcf.fipfailed);
    if ((unsigned int )pevent->link_state.attr.vc_fcf.fcf.fipfailed != 0U) {
      bfa_plog_str((fcport->bfa)->plog, 3, 20, 0, (char *)"FIP FCF Discovery Failed");
    } else {
      bfa_plog_str((fcport->bfa)->plog, 3, 20, 0, (char *)"FIP FCF Discovered");
    }
  } else {

  }
  bfa_fcport_scn(fcport, 1, 0);
  wwn2str___5((char *)(& pwwn_buf), fcport->pwwn);
  if (bfa_log_level == 4 || (int )((signed char )*("\016" + 1)) <= 52) {
    dev_printk("\016", (struct device  const  *)(& (bfad->pcidev)->dev), "Base port online: WWN = %s\n",
               (char *)(& pwwn_buf));
  } else {

  }
  bfa_fcport_aen_post(fcport, 1);
  if ((unsigned int )fcport->cfg.qos_enabled != 0U && (unsigned int )fcport->qos_attr.state != 1U) {
    bfa_fcport_aen_post(fcport, 12);
  } else {

  }
  goto ldv_49337;
  case 7U: ;
  goto ldv_49337;
  case 3U: ;
  goto ldv_49337;
  case 4U: 
  tmp___0 = bfa_fcport_send_disable(fcport);
  if ((unsigned int )tmp___0 != 0U) {
    fcport->sm = (void (*)(void * , int  ))(& bfa_fcport_sm_disabling);
  } else {
    fcport->sm = (void (*)(void * , int  ))(& bfa_fcport_sm_disabling_qwait);
  }
  bfa_plog_str((fcport->bfa)->plog, 3, 3, 0, (char *)"Port Disable");
  wwn2str___5((char *)(& pwwn_buf), fcport->pwwn);
  if (bfa_log_level == 4 || (int )((signed char )*("\016" + 1)) <= 52) {
    dev_printk("\016", (struct device  const  *)(& (bfad->pcidev)->dev), "Base port disabled: WWN = %s\n",
               (char *)(& pwwn_buf));
  } else {

  }
  bfa_fcport_aen_post(fcport, 8);
  goto ldv_49337;
  case 2U: 
  fcport->sm = (void (*)(void * , int  ))(& bfa_fcport_sm_stopped);
  goto ldv_49337;
  case 9U: 
  fcport->sm = (void (*)(void * , int  ))(& bfa_fcport_sm_iocdown);
  goto ldv_49337;
  case 12U: 
  bfa_fcport_reset_linkinfo(fcport);
  bfa_fcport_aen_post(fcport, 11);
  fcport->sm = (void (*)(void * , int  ))(& bfa_fcport_sm_faa_misconfig);
  goto ldv_49337;
  default: 
  __bfa_trc((fcport->bfa)->trcmod, __trc_fileno___13, 2350, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_svc.c",
         2350, (unsigned int )event);
  }
  ldv_49337: ;
  return;
}
}
static void bfa_fcport_sm_linkup(struct bfa_fcport_s *fcport , enum bfa_fcport_sm_event event ) 
{ 
  char pwwn_buf[32U] ;
  struct bfad_s *bfad ;
  enum bfa_boolean tmp ;
  enum bfa_boolean tmp___0 ;
  enum bfa_boolean tmp___1 ;
  enum bfa_boolean tmp___2 ;
  enum bfa_boolean tmp___3 ;
  enum bfa_boolean tmp___4 ;
  enum bfa_boolean tmp___5 ;

  {
  bfad = (struct bfad_s *)(fcport->bfa)->bfad;
  __bfa_trc((fcport->bfa)->trcmod, __trc_fileno___13, 2361, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 3U: ;
  goto ldv_49352;
  case 4U: 
  tmp = bfa_fcport_send_disable(fcport);
  if ((unsigned int )tmp != 0U) {
    fcport->sm = (void (*)(void * , int  ))(& bfa_fcport_sm_disabling);
  } else {
    fcport->sm = (void (*)(void * , int  ))(& bfa_fcport_sm_disabling_qwait);
  }
  bfa_fcport_reset_linkinfo(fcport);
  bfa_fcport_scn(fcport, 2, 0);
  bfa_plog_str((fcport->bfa)->plog, 3, 3, 0, (char *)"Port Disable");
  wwn2str___5((char *)(& pwwn_buf), fcport->pwwn);
  if (bfa_log_level == 4 || (int )((signed char )*("\016" + 1)) <= 52) {
    dev_printk("\016", (struct device  const  *)(& (bfad->pcidev)->dev), "Base port offline: WWN = %s\n",
               (char *)(& pwwn_buf));
  } else {

  }
  bfa_fcport_aen_post(fcport, 2);
  if (bfa_log_level == 4 || (int )((signed char )*("\016" + 1)) <= 52) {
    dev_printk("\016", (struct device  const  *)(& (bfad->pcidev)->dev), "Base port disabled: WWN = %s\n",
               (char *)(& pwwn_buf));
  } else {

  }
  bfa_fcport_aen_post(fcport, 8);
  goto ldv_49352;
  case 7U: 
  fcport->sm = (void (*)(void * , int  ))(& bfa_fcport_sm_linkdown);
  bfa_fcport_reset_linkinfo(fcport);
  bfa_fcport_scn(fcport, 2, 0);
  bfa_plog_str((fcport->bfa)->plog, 3, 5, 0, (char *)"Port Linkdown");
  wwn2str___5((char *)(& pwwn_buf), fcport->pwwn);
  tmp___0 = bfa_fcport_is_disabled(fcport->bfa);
  if ((unsigned int )tmp___0 == 1U) {
    goto _L;
  } else {
    tmp___1 = bfa_ioc_is_disabled(& (fcport->bfa)->ioc);
    if ((unsigned int )tmp___1 == 1U) {
      _L: /* CIL Label */ 
      if (bfa_log_level == 4 || (int )((signed char )*("\016" + 1)) <= 52) {
        dev_printk("\016", (struct device  const  *)(& (bfad->pcidev)->dev), "Base port offline: WWN = %s\n",
                   (char *)(& pwwn_buf));
      } else {

      }
      bfa_fcport_aen_post(fcport, 2);
    } else {
      if (bfa_log_level == 4 || (int )((signed char )*("\v" + 1)) <= 52) {
        dev_printk("\v", (struct device  const  *)(& (bfad->pcidev)->dev), "Base port (WWN = %s) lost fabric connectivity\n",
                   (char *)(& pwwn_buf));
      } else {

      }
      bfa_fcport_aen_post(fcport, 11);
    }
  }
  goto ldv_49352;
  case 2U: 
  fcport->sm = (void (*)(void * , int  ))(& bfa_fcport_sm_stopped);
  bfa_fcport_reset_linkinfo(fcport);
  wwn2str___5((char *)(& pwwn_buf), fcport->pwwn);
  tmp___2 = bfa_fcport_is_disabled(fcport->bfa);
  if ((unsigned int )tmp___2 == 1U) {
    goto _L___0;
  } else {
    tmp___3 = bfa_ioc_is_disabled(& (fcport->bfa)->ioc);
    if ((unsigned int )tmp___3 == 1U) {
      _L___0: /* CIL Label */ 
      if (bfa_log_level == 4 || (int )((signed char )*("\016" + 1)) <= 52) {
        dev_printk("\016", (struct device  const  *)(& (bfad->pcidev)->dev), "Base port offline: WWN = %s\n",
                   (char *)(& pwwn_buf));
      } else {

      }
      bfa_fcport_aen_post(fcport, 2);
    } else {
      if (bfa_log_level == 4 || (int )((signed char )*("\v" + 1)) <= 52) {
        dev_printk("\v", (struct device  const  *)(& (bfad->pcidev)->dev), "Base port (WWN = %s) lost fabric connectivity\n",
                   (char *)(& pwwn_buf));
      } else {

      }
      bfa_fcport_aen_post(fcport, 11);
    }
  }
  goto ldv_49352;
  case 9U: 
  fcport->sm = (void (*)(void * , int  ))(& bfa_fcport_sm_iocdown);
  bfa_fcport_reset_linkinfo(fcport);
  bfa_fcport_scn(fcport, 2, 0);
  wwn2str___5((char *)(& pwwn_buf), fcport->pwwn);
  tmp___4 = bfa_fcport_is_disabled(fcport->bfa);
  if ((unsigned int )tmp___4 == 1U) {
    goto _L___1;
  } else {
    tmp___5 = bfa_ioc_is_disabled(& (fcport->bfa)->ioc);
    if ((unsigned int )tmp___5 == 1U) {
      _L___1: /* CIL Label */ 
      if (bfa_log_level == 4 || (int )((signed char )*("\016" + 1)) <= 52) {
        dev_printk("\016", (struct device  const  *)(& (bfad->pcidev)->dev), "Base port offline: WWN = %s\n",
                   (char *)(& pwwn_buf));
      } else {

      }
      bfa_fcport_aen_post(fcport, 2);
    } else {
      if (bfa_log_level == 4 || (int )((signed char )*("\v" + 1)) <= 52) {
        dev_printk("\v", (struct device  const  *)(& (bfad->pcidev)->dev), "Base port (WWN = %s) lost fabric connectivity\n",
                   (char *)(& pwwn_buf));
      } else {

      }
      bfa_fcport_aen_post(fcport, 11);
    }
  }
  goto ldv_49352;
  case 12U: 
  bfa_fcport_reset_linkinfo(fcport);
  bfa_fcport_aen_post(fcport, 11);
  fcport->sm = (void (*)(void * , int  ))(& bfa_fcport_sm_faa_misconfig);
  goto ldv_49352;
  default: 
  __bfa_trc((fcport->bfa)->trcmod, __trc_fileno___13, 2449, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_svc.c",
         2449, (unsigned int )event);
  }
  ldv_49352: ;
  return;
}
}
static void bfa_fcport_sm_disabling_qwait(struct bfa_fcport_s *fcport , enum bfa_fcport_sm_event event ) 
{ 


  {
  __bfa_trc((fcport->bfa)->trcmod, __trc_fileno___13, 2457, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 8U: 
  fcport->sm = (void (*)(void * , int  ))(& bfa_fcport_sm_disabling);
  bfa_fcport_send_disable(fcport);
  goto ldv_49364;
  case 2U: 
  fcport->sm = (void (*)(void * , int  ))(& bfa_fcport_sm_stopped);
  list_del(& fcport->reqq_wait.qe);
  goto ldv_49364;
  case 3U: 
  fcport->sm = (void (*)(void * , int  ))(& bfa_fcport_sm_toggling_qwait);
  goto ldv_49364;
  case 4U: ;
  goto ldv_49364;
  case 6U: ;
  case 7U: ;
  goto ldv_49364;
  case 9U: 
  fcport->sm = (void (*)(void * , int  ))(& bfa_fcport_sm_iocfail);
  list_del(& fcport->reqq_wait.qe);
  goto ldv_49364;
  case 12U: 
  bfa_fcport_reset_linkinfo(fcport);
  bfa_fcport_aen_post(fcport, 11);
  fcport->sm = (void (*)(void * , int  ))(& bfa_fcport_sm_faa_misconfig);
  goto ldv_49364;
  default: 
  __bfa_trc((fcport->bfa)->trcmod, __trc_fileno___13, 2500, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_svc.c",
         2500, (unsigned int )event);
  }
  ldv_49364: ;
  return;
}
}
static void bfa_fcport_sm_toggling_qwait(struct bfa_fcport_s *fcport , enum bfa_fcport_sm_event event ) 
{ 
  enum bfa_boolean tmp ;

  {
  __bfa_trc((fcport->bfa)->trcmod, __trc_fileno___13, 2508, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 8U: 
  fcport->sm = (void (*)(void * , int  ))(& bfa_fcport_sm_disabling);
  bfa_fcport_send_disable(fcport);
  tmp = bfa_fcport_send_enable(fcport);
  if ((unsigned int )tmp != 0U) {
    fcport->sm = (void (*)(void * , int  ))(& bfa_fcport_sm_enabling);
  } else {
    fcport->sm = (void (*)(void * , int  ))(& bfa_fcport_sm_enabling_qwait);
  }
  goto ldv_49378;
  case 2U: 
  fcport->sm = (void (*)(void * , int  ))(& bfa_fcport_sm_stopped);
  list_del(& fcport->reqq_wait.qe);
  goto ldv_49378;
  case 3U: ;
  goto ldv_49378;
  case 4U: 
  fcport->sm = (void (*)(void * , int  ))(& bfa_fcport_sm_disabling_qwait);
  goto ldv_49378;
  case 6U: ;
  case 7U: ;
  goto ldv_49378;
  case 9U: 
  fcport->sm = (void (*)(void * , int  ))(& bfa_fcport_sm_iocfail);
  list_del(& fcport->reqq_wait.qe);
  goto ldv_49378;
  default: 
  __bfa_trc((fcport->bfa)->trcmod, __trc_fileno___13, 2547, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_svc.c",
         2547, (unsigned int )event);
  }
  ldv_49378: ;
  return;
}
}
static void bfa_fcport_sm_disabling(struct bfa_fcport_s *fcport , enum bfa_fcport_sm_event event ) 
{ 
  char pwwn_buf[32U] ;
  struct bfad_s *bfad ;
  enum bfa_boolean tmp ;

  {
  bfad = (struct bfad_s *)(fcport->bfa)->bfad;
  __bfa_trc((fcport->bfa)->trcmod, __trc_fileno___13, 2557, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 5U: 
  fcport->sm = (void (*)(void * , int  ))(& bfa_fcport_sm_disabled);
  goto ldv_49393;
  case 4U: ;
  goto ldv_49393;
  case 3U: 
  tmp = bfa_fcport_send_enable(fcport);
  if ((unsigned int )tmp != 0U) {
    fcport->sm = (void (*)(void * , int  ))(& bfa_fcport_sm_enabling);
  } else {
    fcport->sm = (void (*)(void * , int  ))(& bfa_fcport_sm_enabling_qwait);
  }
  bfa_plog_str((fcport->bfa)->plog, 3, 4, 0, (char *)"Port Enable");
  wwn2str___5((char *)(& pwwn_buf), fcport->pwwn);
  if (bfa_log_level == 4 || (int )((signed char )*("\016" + 1)) <= 52) {
    dev_printk("\016", (struct device  const  *)(& (bfad->pcidev)->dev), "Base port enabled: WWN = %s\n",
               (char *)(& pwwn_buf));
  } else {

  }
  bfa_fcport_aen_post(fcport, 7);
  goto ldv_49393;
  case 2U: 
  fcport->sm = (void (*)(void * , int  ))(& bfa_fcport_sm_stopped);
  goto ldv_49393;
  case 6U: ;
  case 7U: ;
  goto ldv_49393;
  case 9U: 
  fcport->sm = (void (*)(void * , int  ))(& bfa_fcport_sm_iocfail);
  goto ldv_49393;
  default: 
  __bfa_trc((fcport->bfa)->trcmod, __trc_fileno___13, 2602, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_svc.c",
         2602, (unsigned int )event);
  }
  ldv_49393: ;
  return;
}
}
static void bfa_fcport_sm_disabled(struct bfa_fcport_s *fcport , enum bfa_fcport_sm_event event ) 
{ 
  char pwwn_buf[32U] ;
  struct bfad_s *bfad ;
  enum bfa_boolean tmp ;

  {
  bfad = (struct bfad_s *)(fcport->bfa)->bfad;
  __bfa_trc((fcport->bfa)->trcmod, __trc_fileno___13, 2612, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 1U: ;
  goto ldv_49408;
  case 2U: 
  fcport->sm = (void (*)(void * , int  ))(& bfa_fcport_sm_stopped);
  goto ldv_49408;
  case 3U: 
  tmp = bfa_fcport_send_enable(fcport);
  if ((unsigned int )tmp != 0U) {
    fcport->sm = (void (*)(void * , int  ))(& bfa_fcport_sm_enabling);
  } else {
    fcport->sm = (void (*)(void * , int  ))(& bfa_fcport_sm_enabling_qwait);
  }
  bfa_plog_str((fcport->bfa)->plog, 3, 4, 0, (char *)"Port Enable");
  wwn2str___5((char *)(& pwwn_buf), fcport->pwwn);
  if (bfa_log_level == 4 || (int )((signed char )*("\016" + 1)) <= 52) {
    dev_printk("\016", (struct device  const  *)(& (bfad->pcidev)->dev), "Base port enabled: WWN = %s\n",
               (char *)(& pwwn_buf));
  } else {

  }
  bfa_fcport_aen_post(fcport, 7);
  goto ldv_49408;
  case 4U: ;
  goto ldv_49408;
  case 9U: 
  fcport->sm = (void (*)(void * , int  ))(& bfa_fcport_sm_iocfail);
  goto ldv_49408;
  case 10U: 
  fcport->sm = (void (*)(void * , int  ))(& bfa_fcport_sm_dport);
  goto ldv_49408;
  case 13U: 
  fcport->sm = (void (*)(void * , int  ))(& bfa_fcport_sm_ddport);
  goto ldv_49408;
  default: 
  __bfa_trc((fcport->bfa)->trcmod, __trc_fileno___13, 2659, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_svc.c",
         2659, (unsigned int )event);
  }
  ldv_49408: ;
  return;
}
}
static void bfa_fcport_sm_stopped(struct bfa_fcport_s *fcport , enum bfa_fcport_sm_event event ) 
{ 
  enum bfa_boolean tmp ;

  {
  __bfa_trc((fcport->bfa)->trcmod, __trc_fileno___13, 2667, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 1U: 
  tmp = bfa_fcport_send_enable(fcport);
  if ((unsigned int )tmp != 0U) {
    fcport->sm = (void (*)(void * , int  ))(& bfa_fcport_sm_enabling);
  } else {
    fcport->sm = (void (*)(void * , int  ))(& bfa_fcport_sm_enabling_qwait);
  }
  goto ldv_49421;
  default: ;
  }
  ldv_49421: ;
  return;
}
}
static void bfa_fcport_sm_iocdown(struct bfa_fcport_s *fcport , enum bfa_fcport_sm_event event ) 
{ 
  enum bfa_boolean tmp ;

  {
  __bfa_trc((fcport->bfa)->trcmod, __trc_fileno___13, 2693, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 1U: 
  tmp = bfa_fcport_send_enable(fcport);
  if ((unsigned int )tmp != 0U) {
    fcport->sm = (void (*)(void * , int  ))(& bfa_fcport_sm_enabling);
  } else {
    fcport->sm = (void (*)(void * , int  ))(& bfa_fcport_sm_enabling_qwait);
  }
  goto ldv_49428;
  default: ;
  }
  ldv_49428: ;
  return;
}
}
static void bfa_fcport_sm_iocfail(struct bfa_fcport_s *fcport , enum bfa_fcport_sm_event event ) 
{ 


  {
  __bfa_trc((fcport->bfa)->trcmod, __trc_fileno___13, 2719, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 1U: 
  fcport->sm = (void (*)(void * , int  ))(& bfa_fcport_sm_disabled);
  goto ldv_49435;
  case 3U: 
  fcport->sm = (void (*)(void * , int  ))(& bfa_fcport_sm_iocdown);
  goto ldv_49435;
  default: ;
  }
  ldv_49435: ;
  return;
}
}
static void bfa_fcport_sm_dport(struct bfa_fcport_s *fcport , enum bfa_fcport_sm_event event ) 
{ 


  {
  __bfa_trc((fcport->bfa)->trcmod, __trc_fileno___13, 2741, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 10U: ;
  case 4U: ;
  case 3U: ;
  case 1U: ;
  goto ldv_49446;
  case 2U: 
  fcport->sm = (void (*)(void * , int  ))(& bfa_fcport_sm_stopped);
  goto ldv_49446;
  case 9U: 
  fcport->sm = (void (*)(void * , int  ))(& bfa_fcport_sm_iocfail);
  goto ldv_49446;
  case 11U: 
  fcport->sm = (void (*)(void * , int  ))(& bfa_fcport_sm_disabled);
  goto ldv_49446;
  default: 
  __bfa_trc((fcport->bfa)->trcmod, __trc_fileno___13, 2766, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_svc.c",
         2766, (unsigned int )event);
  }
  ldv_49446: ;
  return;
}
}
static void bfa_fcport_sm_ddport(struct bfa_fcport_s *fcport , enum bfa_fcport_sm_event event ) 
{ 


  {
  __bfa_trc((fcport->bfa)->trcmod, __trc_fileno___13, 2774, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 4U: ;
  case 14U: 
  fcport->sm = (void (*)(void * , int  ))(& bfa_fcport_sm_disabled);
  goto ldv_49457;
  case 10U: ;
  case 11U: ;
  case 3U: ;
  case 1U: ;
  goto ldv_49457;
  case 2U: 
  fcport->sm = (void (*)(void * , int  ))(& bfa_fcport_sm_stopped);
  goto ldv_49457;
  case 9U: 
  fcport->sm = (void (*)(void * , int  ))(& bfa_fcport_sm_iocfail);
  goto ldv_49457;
  default: 
  __bfa_trc((fcport->bfa)->trcmod, __trc_fileno___13, 2800, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_svc.c",
         2800, (unsigned int )event);
  }
  ldv_49457: ;
  return;
}
}
static void bfa_fcport_sm_faa_misconfig(struct bfa_fcport_s *fcport , enum bfa_fcport_sm_event event ) 
{ 
  enum bfa_boolean tmp ;

  {
  __bfa_trc((fcport->bfa)->trcmod, __trc_fileno___13, 2808, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 10U: ;
  case 3U: ;
  case 1U: ;
  goto ldv_49472;
  case 4U: 
  tmp = bfa_fcport_send_disable(fcport);
  if ((unsigned int )tmp != 0U) {
    fcport->sm = (void (*)(void * , int  ))(& bfa_fcport_sm_disabling);
  } else {
    fcport->sm = (void (*)(void * , int  ))(& bfa_fcport_sm_disabling_qwait);
  }
  bfa_fcport_reset_linkinfo(fcport);
  bfa_fcport_scn(fcport, 2, 0);
  bfa_plog_str((fcport->bfa)->plog, 3, 3, 0, (char *)"Port Disable");
  bfa_fcport_aen_post(fcport, 8);
  goto ldv_49472;
  case 2U: 
  fcport->sm = (void (*)(void * , int  ))(& bfa_fcport_sm_stopped);
  goto ldv_49472;
  case 9U: 
  bfa_fcport_reset_linkinfo(fcport);
  bfa_fcport_scn(fcport, 2, 0);
  fcport->sm = (void (*)(void * , int  ))(& bfa_fcport_sm_iocdown);
  goto ldv_49472;
  default: 
  __bfa_trc((fcport->bfa)->trcmod, __trc_fileno___13, 2843, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_svc.c",
         2843, (unsigned int )event);
  }
  ldv_49472: ;
  return;
}
}
static void bfa_fcport_ln_sm_dn(struct bfa_fcport_ln_s *ln , enum bfa_fcport_ln_sm_event event ) 
{ 


  {
  __bfa_trc(((ln->fcport)->bfa)->trcmod, __trc_fileno___13, 2854, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 1U: 
  ln->sm = (void (*)(void * , int  ))(& bfa_fcport_ln_sm_up_nf);
  bfa_fcport_queue_cb(ln, 1);
  goto ldv_49482;
  default: 
  __bfa_trc(((ln->fcport)->bfa)->trcmod, __trc_fileno___13, 2863, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_svc.c",
         2863, (unsigned int )event);
  }
  ldv_49482: ;
  return;
}
}
static void bfa_fcport_ln_sm_dn_nf(struct bfa_fcport_ln_s *ln , enum bfa_fcport_ln_sm_event event ) 
{ 


  {
  __bfa_trc(((ln->fcport)->bfa)->trcmod, __trc_fileno___13, 2874, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 1U: 
  ln->sm = (void (*)(void * , int  ))(& bfa_fcport_ln_sm_dn_up_nf);
  goto ldv_49489;
  case 3U: 
  ln->sm = (void (*)(void * , int  ))(& bfa_fcport_ln_sm_dn);
  goto ldv_49489;
  default: 
  __bfa_trc(((ln->fcport)->bfa)->trcmod, __trc_fileno___13, 2886, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_svc.c",
         2886, (unsigned int )event);
  }
  ldv_49489: ;
  return;
}
}
static void bfa_fcport_ln_sm_dn_up_nf(struct bfa_fcport_ln_s *ln , enum bfa_fcport_ln_sm_event event ) 
{ 


  {
  __bfa_trc(((ln->fcport)->bfa)->trcmod, __trc_fileno___13, 2897, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 2U: 
  ln->sm = (void (*)(void * , int  ))(& bfa_fcport_ln_sm_dn_nf);
  goto ldv_49497;
  case 3U: 
  ln->sm = (void (*)(void * , int  ))(& bfa_fcport_ln_sm_up_nf);
  bfa_fcport_queue_cb(ln, 1);
  goto ldv_49497;
  default: 
  __bfa_trc(((ln->fcport)->bfa)->trcmod, __trc_fileno___13, 2910, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_svc.c",
         2910, (unsigned int )event);
  }
  ldv_49497: ;
  return;
}
}
static void bfa_fcport_ln_sm_up(struct bfa_fcport_ln_s *ln , enum bfa_fcport_ln_sm_event event ) 
{ 


  {
  __bfa_trc(((ln->fcport)->bfa)->trcmod, __trc_fileno___13, 2921, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 2U: 
  ln->sm = (void (*)(void * , int  ))(& bfa_fcport_ln_sm_dn_nf);
  bfa_fcport_queue_cb(ln, 2);
  goto ldv_49505;
  default: 
  __bfa_trc(((ln->fcport)->bfa)->trcmod, __trc_fileno___13, 2930, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_svc.c",
         2930, (unsigned int )event);
  }
  ldv_49505: ;
  return;
}
}
static void bfa_fcport_ln_sm_up_nf(struct bfa_fcport_ln_s *ln , enum bfa_fcport_ln_sm_event event ) 
{ 


  {
  __bfa_trc(((ln->fcport)->bfa)->trcmod, __trc_fileno___13, 2941, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 2U: 
  ln->sm = (void (*)(void * , int  ))(& bfa_fcport_ln_sm_up_dn_nf);
  goto ldv_49512;
  case 3U: 
  ln->sm = (void (*)(void * , int  ))(& bfa_fcport_ln_sm_up);
  goto ldv_49512;
  default: 
  __bfa_trc(((ln->fcport)->bfa)->trcmod, __trc_fileno___13, 2953, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_svc.c",
         2953, (unsigned int )event);
  }
  ldv_49512: ;
  return;
}
}
static void bfa_fcport_ln_sm_up_dn_nf(struct bfa_fcport_ln_s *ln , enum bfa_fcport_ln_sm_event event ) 
{ 


  {
  __bfa_trc(((ln->fcport)->bfa)->trcmod, __trc_fileno___13, 2964, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 1U: 
  ln->sm = (void (*)(void * , int  ))(& bfa_fcport_ln_sm_up_dn_up_nf);
  goto ldv_49520;
  case 3U: 
  ln->sm = (void (*)(void * , int  ))(& bfa_fcport_ln_sm_dn_nf);
  bfa_fcport_queue_cb(ln, 2);
  goto ldv_49520;
  default: 
  __bfa_trc(((ln->fcport)->bfa)->trcmod, __trc_fileno___13, 2977, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_svc.c",
         2977, (unsigned int )event);
  }
  ldv_49520: ;
  return;
}
}
static void bfa_fcport_ln_sm_up_dn_up_nf(struct bfa_fcport_ln_s *ln , enum bfa_fcport_ln_sm_event event ) 
{ 


  {
  __bfa_trc(((ln->fcport)->bfa)->trcmod, __trc_fileno___13, 2988, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 2U: 
  ln->sm = (void (*)(void * , int  ))(& bfa_fcport_ln_sm_up_dn_nf);
  goto ldv_49528;
  case 3U: 
  ln->sm = (void (*)(void * , int  ))(& bfa_fcport_ln_sm_dn_up_nf);
  bfa_fcport_queue_cb(ln, 2);
  goto ldv_49528;
  default: 
  __bfa_trc(((ln->fcport)->bfa)->trcmod, __trc_fileno___13, 3001, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_svc.c",
         3001, (unsigned int )event);
  }
  ldv_49528: ;
  return;
}
}
static void __bfa_cb_fcport_event(void *cbarg , enum bfa_boolean complete___0 ) 
{ 
  struct bfa_fcport_ln_s *ln ;

  {
  ln = (struct bfa_fcport_ln_s *)cbarg;
  if ((unsigned int )complete___0 != 0U) {
    (*((ln->fcport)->event_cbfn))((ln->fcport)->event_cbarg, ln->ln_event);
  } else {
    (*(ln->sm))((void *)ln, 3);
  }
  return;
}
}
static void bfa_fcport_scn(struct bfa_fcport_s *fcport , enum bfa_port_linkstate event ,
                           enum bfa_boolean trunk ) 
{ 
  int __ret_warn_on ;
  long tmp ;

  {
  if ((unsigned int )fcport->cfg.trunked != 0U && (unsigned int )trunk == 0U) {
    return;
  } else {

  }
  switch ((unsigned int )event) {
  case 1U: 
  (*(fcport->ln.sm))((void *)(& fcport->ln), 1);
  goto ldv_49542;
  case 2U: 
  (*(fcport->ln.sm))((void *)(& fcport->ln), 2);
  goto ldv_49542;
  default: 
  __ret_warn_on = 1;
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_svc.c",
                       3035);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  }
  ldv_49542: ;
  return;
}
}
static void bfa_fcport_queue_cb(struct bfa_fcport_ln_s *ln , enum bfa_port_linkstate event ) 
{ 
  struct bfa_fcport_s *fcport ;

  {
  fcport = ln->fcport;
  if ((unsigned int )(fcport->bfa)->fcs != 0U) {
    (*(fcport->event_cbfn))(fcport->event_cbarg, event);
    (*(ln->sm))((void *)ln, 3);
  } else {
    ln->ln_event = event;
    ln->ln_qe.cbfn = & __bfa_cb_fcport_event;
    ln->ln_qe.cbarg = (void *)ln;
    ln->ln_qe.pre_rmv = 0;
    list_add_tail(& ln->ln_qe.qe, & (fcport->bfa)->comp_q);
  }
  return;
}
}
static void bfa_fcport_meminfo(struct bfa_iocfc_cfg_s *cfg , struct bfa_meminfo_s *minfo ,
                               struct bfa_s *bfa ) 
{ 
  struct bfa_mem_dma_s *fcport_dma ;

  {
  fcport_dma = & bfa->modules.fcport.fcport_dma;
  fcport_dma->mem_len = 512U;
  list_add_tail(& fcport_dma->qe, & minfo->dma_info.qe);
  return;
}
}
static void bfa_fcport_qresume(void *cbarg ) 
{ 
  struct bfa_fcport_s *fcport ;

  {
  fcport = (struct bfa_fcport_s *)cbarg;
  (*(fcport->sm))((void *)fcport, 8);
  return;
}
}
static void bfa_fcport_mem_claim(struct bfa_fcport_s *fcport ) 
{ 
  struct bfa_mem_dma_s *fcport_dma ;

  {
  fcport_dma = & fcport->fcport_dma;
  fcport->stats_kva = fcport_dma->kva_curp;
  fcport->stats_pa = fcport_dma->dma_curp;
  fcport->stats = (union bfa_fcport_stats_u *)fcport_dma->kva_curp;
  return;
}
}
static void bfa_fcport_attach(struct bfa_s *bfa , void *bfad , struct bfa_iocfc_cfg_s *cfg ,
                              struct bfa_pcidev_s *pcidev ) 
{ 
  struct bfa_fcport_s *fcport ;
  struct bfa_port_cfg_s *port_cfg ;
  struct bfa_fcport_ln_s *ln ;
  struct timeval tv ;

  {
  fcport = & bfa->modules.fcport;
  port_cfg = & fcport->cfg;
  ln = & fcport->ln;
  fcport->bfa = bfa;
  ln->fcport = fcport;
  bfa_fcport_mem_claim(fcport);
  fcport->sm = (void (*)(void * , int  ))(& bfa_fcport_sm_uninit);
  ln->sm = (void (*)(void * , int  ))(& bfa_fcport_ln_sm_dn);
  do_gettimeofday(& tv);
  fcport->stats_reset_time = (u32 )tv.tv_sec;
  fcport->stats_dma_ready = 0;
  port_cfg->topology = 5U;
  port_cfg->speed = 15U;
  port_cfg->trunked = 0U;
  port_cfg->maxfrsize = 0U;
  port_cfg->trl_def_speed = 1U;
  port_cfg->qos_bw.high = 60U;
  port_cfg->qos_bw.med = 30U;
  port_cfg->qos_bw.low = 10U;
  fcport->fec_state = 2;
  INIT_LIST_HEAD(& fcport->stats_pending_q);
  INIT_LIST_HEAD(& fcport->statsclr_pending_q);
  bfa_reqq_winit(& fcport->reqq_wait, & bfa_fcport_qresume, (void *)fcport);
  return;
}
}
static void bfa_fcport_detach(struct bfa_s *bfa ) 
{ 


  {
  return;
}
}
static void bfa_fcport_start(struct bfa_s *bfa ) 
{ 


  {
  (*(bfa->modules.fcport.sm))((void *)(& bfa->modules.fcport), 1);
  return;
}
}
static void bfa_fcport_stop(struct bfa_s *bfa ) 
{ 


  {
  (*(bfa->modules.fcport.sm))((void *)(& bfa->modules.fcport), 2);
  bfa_trunk_iocdisable(bfa);
  return;
}
}
static void bfa_fcport_iocdisable(struct bfa_s *bfa ) 
{ 
  struct bfa_fcport_s *fcport ;

  {
  fcport = & bfa->modules.fcport;
  (*(fcport->sm))((void *)fcport, 9);
  bfa_trunk_iocdisable(bfa);
  return;
}
}
static void bfa_fcport_update_loop_info(struct bfa_fcport_s *fcport , struct bfa_fcport_loop_info_s *loop_info ) 
{ 


  {
  fcport->myalpa = loop_info->myalpa;
  fcport->alpabm_valid = loop_info->alpabm_val;
  memcpy((void *)(& fcport->alpabm.alpa_bm), (void const   *)(& loop_info->alpabm.alpa_bm),
           16UL);
  return;
}
}
static void bfa_fcport_update_linkinfo(struct bfa_fcport_s *fcport ) 
{ 
  struct bfi_fcport_event_s *pevent ;
  struct bfa_fcport_trunk_s *trunk ;
  __u16 tmp ;

  {
  pevent = fcport->event_arg.i2hmsg.event;
  trunk = & fcport->trunk;
  fcport->speed = (enum bfa_port_speed )pevent->link_state.speed;
  fcport->topology = (enum bfa_port_topology )pevent->link_state.topology;
  if ((unsigned int )fcport->topology == 2U) {
    bfa_fcport_update_loop_info(fcport, & pevent->link_state.attr.loop_info);
    return;
  } else {

  }
  fcport->qos_attr = pevent->link_state.qos_attr;
  fcport->qos_vc_attr = pevent->link_state.attr.vc_fcf.qos_vc_attr;
  if ((unsigned int )fcport->cfg.bb_cr_enabled != 0U) {
    fcport->bbcr_attr = pevent->link_state.attr.bbcr_attr;
  } else {

  }
  fcport->fec_state = (enum bfa_fec_state_s )pevent->link_state.fec_state;
  if ((unsigned int )fcport->cfg.trunked == 0U) {
    trunk->attr.state = 0;
  } else {

  }
  tmp = __fswab16((int )pevent->link_state.attr.vc_fcf.fcf.vlan);
  fcport->fcoe_vlan = tmp;
  __bfa_trc((fcport->bfa)->trcmod, __trc_fileno___13, 3218, (unsigned long long )fcport->speed);
  __bfa_trc((fcport->bfa)->trcmod, __trc_fileno___13, 3219, (unsigned long long )fcport->topology);
  return;
}
}
static void bfa_fcport_reset_linkinfo(struct bfa_fcport_s *fcport ) 
{ 


  {
  fcport->speed = 0;
  fcport->topology = 0;
  fcport->fec_state = 2;
  return;
}
}
static enum bfa_boolean bfa_fcport_send_enable(struct bfa_fcport_s *fcport ) 
{ 
  struct bfi_fcport_enable_req_s *m ;
  struct list_head *waitq ;
  int __ret_warn_on ;
  long tmp ;
  int __ret_warn_on___0 ;
  long tmp___0 ;
  __u16 tmp___1 ;

  {
  fcport->msgtag = fcport->msgtag + 1U;
  m = (((fcport->bfa)->iocfc.req_cq_pi[0] + 1U) & (u32 )((int )(fcport->bfa)->iocfc.cfg.drvcfg.num_reqq_elems + -1)) != *((u32 *)(fcport->bfa)->iocfc.req_cq_shadow_ci[0].kva) ? (struct bfi_fcport_enable_req_s *)(fcport->bfa)->iocfc.req_cq_ba[0].kva + (unsigned long )(fcport->bfa)->iocfc.req_cq_pi[0] : (struct bfi_fcport_enable_req_s *)0;
  if ((unsigned long )m == (unsigned long )((struct bfi_fcport_enable_req_s *)0)) {
    waitq = (struct list_head *)(& (fcport->bfa)->reqq_waitq);
    __ret_warn_on = 0;
    tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
    if (tmp != 0L) {
      warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_svc.c",
                         3250);
    } else {

    }
    ldv__builtin_expect(__ret_warn_on != 0, 0L);
    __ret_warn_on___0 = (unsigned long )fcport->reqq_wait.qresume == (unsigned long )((void (*)(void * ))0) || (unsigned long )fcport->reqq_wait.cbarg == (unsigned long )((void *)0);
    tmp___0 = ldv__builtin_expect(__ret_warn_on___0 != 0, 0L);
    if (tmp___0 != 0L) {
      warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_svc.c",
                         3250);
    } else {

    }
    ldv__builtin_expect(__ret_warn_on___0 != 0, 0L);
    list_add_tail(& fcport->reqq_wait.qe, waitq);
    return (0);
  } else {

  }
  m->mh.msg_class = 5U;
  m->mh.msg_id = 1U;
  m->mh.mtag.h2i.fn_lpu = (u8 )((int )((signed char )((int )(fcport->bfa)->ioc.pcidev.pci_func << 1)) | (int )((signed char )(fcport->bfa)->ioc.port_id));
  m->nwwn = fcport->nwwn;
  m->pwwn = fcport->pwwn;
  m->port_cfg = fcport->cfg;
  m->msgtag = fcport->msgtag;
  tmp___1 = __fswab16((int )fcport->cfg.maxfrsize);
  m->port_cfg.maxfrsize = tmp___1;
  m->use_flash_cfg = (u8 )fcport->use_flash_cfg;
  __bfa_dma_be_addr_set(& m->stats_dma_addr, fcport->stats_pa);
  __bfa_trc((fcport->bfa)->trcmod, __trc_fileno___13, 3263, (unsigned long long )m->stats_dma_addr.a32.addr_lo);
  __bfa_trc((fcport->bfa)->trcmod, __trc_fileno___13, 3264, (unsigned long long )m->stats_dma_addr.a32.addr_hi);
  m->mh.mtag.h2i.qid = (fcport->bfa)->iocfc.hw_qid[0];
  (fcport->bfa)->iocfc.req_cq_pi[0] = (fcport->bfa)->iocfc.req_cq_pi[0] + 1U;
  (fcport->bfa)->iocfc.req_cq_pi[0] = (fcport->bfa)->iocfc.req_cq_pi[0] & (u32 )((int )(fcport->bfa)->iocfc.cfg.drvcfg.num_reqq_elems + -1);
  writel((fcport->bfa)->iocfc.req_cq_pi[0], (void volatile   *)(fcport->bfa)->iocfc.bfa_regs.cpe_q_pi[0]);
  __asm__  volatile   ("": : : "memory");
  return (1);
}
}
static enum bfa_boolean bfa_fcport_send_disable(struct bfa_fcport_s *fcport ) 
{ 
  struct bfi_fcport_req_s *m ;
  struct list_head *waitq ;
  int __ret_warn_on ;
  long tmp ;
  int __ret_warn_on___0 ;
  long tmp___0 ;

  {
  fcport->msgtag = fcport->msgtag + 1U;
  m = (((fcport->bfa)->iocfc.req_cq_pi[0] + 1U) & (u32 )((int )(fcport->bfa)->iocfc.cfg.drvcfg.num_reqq_elems + -1)) != *((u32 *)(fcport->bfa)->iocfc.req_cq_shadow_ci[0].kva) ? (struct bfi_fcport_req_s *)(fcport->bfa)->iocfc.req_cq_ba[0].kva + (unsigned long )(fcport->bfa)->iocfc.req_cq_pi[0] : (struct bfi_fcport_req_s *)0;
  if ((unsigned long )m == (unsigned long )((struct bfi_fcport_req_s *)0)) {
    waitq = (struct list_head *)(& (fcport->bfa)->reqq_waitq);
    __ret_warn_on = 0;
    tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
    if (tmp != 0L) {
      warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_svc.c",
                         3293);
    } else {

    }
    ldv__builtin_expect(__ret_warn_on != 0, 0L);
    __ret_warn_on___0 = (unsigned long )fcport->reqq_wait.qresume == (unsigned long )((void (*)(void * ))0) || (unsigned long )fcport->reqq_wait.cbarg == (unsigned long )((void *)0);
    tmp___0 = ldv__builtin_expect(__ret_warn_on___0 != 0, 0L);
    if (tmp___0 != 0L) {
      warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_svc.c",
                         3293);
    } else {

    }
    ldv__builtin_expect(__ret_warn_on___0 != 0, 0L);
    list_add_tail(& fcport->reqq_wait.qe, waitq);
    return (0);
  } else {

  }
  m->mh.msg_class = 5U;
  m->mh.msg_id = 2U;
  m->mh.mtag.h2i.fn_lpu = (u8 )((int )((signed char )((int )(fcport->bfa)->ioc.pcidev.pci_func << 1)) | (int )((signed char )(fcport->bfa)->ioc.port_id));
  m->msgtag = fcport->msgtag;
  m->mh.mtag.h2i.qid = (fcport->bfa)->iocfc.hw_qid[0];
  (fcport->bfa)->iocfc.req_cq_pi[0] = (fcport->bfa)->iocfc.req_cq_pi[0] + 1U;
  (fcport->bfa)->iocfc.req_cq_pi[0] = (fcport->bfa)->iocfc.req_cq_pi[0] & (u32 )((int )(fcport->bfa)->iocfc.cfg.drvcfg.num_reqq_elems + -1);
  writel((fcport->bfa)->iocfc.req_cq_pi[0], (void volatile   *)(fcport->bfa)->iocfc.bfa_regs.cpe_q_pi[0]);
  __asm__  volatile   ("": : : "memory");
  return (1);
}
}
static void bfa_fcport_set_wwns(struct bfa_fcport_s *fcport ) 
{ 


  {
  fcport->pwwn = ((fcport->bfa)->ioc.attr)->pwwn;
  fcport->nwwn = ((fcport->bfa)->ioc.attr)->nwwn;
  __bfa_trc((fcport->bfa)->trcmod, __trc_fileno___13, 3315, fcport->pwwn);
  __bfa_trc((fcport->bfa)->trcmod, __trc_fileno___13, 3316, fcport->nwwn);
  return;
}
}
static void bfa_fcport_qos_stats_swap(struct bfa_qos_stats_s *d , struct bfa_qos_stats_s *s ) 
{ 
  u32 *dip ;
  __be32 *sip ;
  int i ;
  __u32 tmp ;

  {
  dip = (u32 *)d;
  sip = (__be32 *)s;
  i = 0;
  goto ldv_49630;
  ldv_49629: 
  tmp = __fswab32(*(sip + (unsigned long )i));
  *(dip + (unsigned long )i) = tmp;
  i = i + 1;
  ldv_49630: ;
  if ((unsigned int )i <= 9U) {
    goto ldv_49629;
  } else {

  }

  return;
}
}
static void bfa_fcport_fcoe_stats_swap(struct bfa_fcoe_stats_s *d , struct bfa_fcoe_stats_s *s ) 
{ 
  u32 *dip ;
  __be32 *sip ;
  int i ;
  __u32 tmp ;
  __u32 tmp___0 ;

  {
  dip = (u32 *)d;
  sip = (__be32 *)s;
  i = 0;
  goto ldv_49640;
  ldv_49639: 
  tmp = __fswab32(*(sip + ((unsigned long )i + 1UL)));
  *(dip + (unsigned long )i) = tmp;
  tmp___0 = __fswab32(*(sip + (unsigned long )i));
  *(dip + ((unsigned long )i + 1UL)) = tmp___0;
  i = i + 2;
  ldv_49640: ;
  if ((unsigned int )i <= 89U) {
    goto ldv_49639;
  } else {

  }

  return;
}
}
static void __bfa_cb_fcport_stats_get(void *cbarg , enum bfa_boolean complete___0 ) 
{ 
  struct bfa_fcport_s *fcport ;
  struct bfa_cb_pending_q_s *cb ;
  struct list_head *qe ;
  struct list_head *qen ;
  union bfa_fcport_stats_u *ret ;
  struct timeval tv ;
  int tmp ;

  {
  fcport = (struct bfa_fcport_s *)cbarg;
  if ((unsigned int )complete___0 != 0U) {
    if ((unsigned int )fcport->stats_status == 0U) {
      do_gettimeofday(& tv);
    } else {

    }
    qe = fcport->stats_pending_q.next;
    qen = qe->next;
    goto ldv_49653;
    ldv_49652: 
    tmp = list_empty((struct list_head  const  *)(& fcport->stats_pending_q));
    if (tmp == 0) {
      qe = fcport->stats_pending_q.next;
      (qe->next)->prev = & fcport->stats_pending_q;
      fcport->stats_pending_q.next = qe->next;
    } else {
      qe = (struct list_head *)0;
    }
    cb = (struct bfa_cb_pending_q_s *)qe;
    if ((unsigned int )fcport->stats_status == 0U) {
      ret = (union bfa_fcport_stats_u *)cb->data;
      if ((unsigned int )(fcport->bfa)->ioc.fcmode != 0U) {
        bfa_fcport_qos_stats_swap(& ret->fcqos, & (fcport->stats)->fcqos);
      } else {
        bfa_fcport_fcoe_stats_swap(& ret->fcoe, & (fcport->stats)->fcoe);
        ret->fcoe.secs_reset = (u64 )(tv.tv_sec - (__kernel_time_t )fcport->stats_reset_time);
      }
    } else {

    }
    cb->hcb_qe.fw_status = fcport->stats_status;
    list_add_tail(& cb->hcb_qe.qe, & (fcport->bfa)->comp_q);
    qe = qen;
    qen = qe->next;
    ldv_49653: ;
    if ((unsigned long )(& fcport->stats_pending_q) != (unsigned long )qe) {
      goto ldv_49652;
    } else {

    }
    fcport->stats_status = 0;
  } else {
    INIT_LIST_HEAD(& fcport->stats_pending_q);
    fcport->stats_status = 0;
  }
  return;
}
}
static void bfa_fcport_stats_get_timeout(void *cbarg ) 
{ 
  struct bfa_fcport_s *fcport ;

  {
  fcport = (struct bfa_fcport_s *)cbarg;
  __bfa_trc((fcport->bfa)->trcmod, __trc_fileno___13, 3396, (unsigned long long )fcport->stats_qfull);
  if ((unsigned int )fcport->stats_qfull != 0U) {
    list_del(& fcport->stats_reqq_wait.qe);
    fcport->stats_qfull = 0;
  } else {

  }
  fcport->stats_status = 5;
  __bfa_cb_fcport_stats_get((void *)fcport, 1);
  return;
}
}
static void bfa_fcport_send_stats_get(void *cbarg ) 
{ 
  struct bfa_fcport_s *fcport ;
  struct bfi_fcport_req_s *msg ;
  struct list_head *waitq ;
  int __ret_warn_on ;
  long tmp ;
  int __ret_warn_on___0 ;
  long tmp___0 ;

  {
  fcport = (struct bfa_fcport_s *)cbarg;
  msg = (((fcport->bfa)->iocfc.req_cq_pi[0] + 1U) & (u32 )((int )(fcport->bfa)->iocfc.cfg.drvcfg.num_reqq_elems + -1)) != *((u32 *)(fcport->bfa)->iocfc.req_cq_shadow_ci[0].kva) ? (struct bfi_fcport_req_s *)(fcport->bfa)->iocfc.req_cq_ba[0].kva + (unsigned long )(fcport->bfa)->iocfc.req_cq_pi[0] : (struct bfi_fcport_req_s *)0;
  if ((unsigned long )msg == (unsigned long )((struct bfi_fcport_req_s *)0)) {
    fcport->stats_qfull = 1;
    bfa_reqq_winit(& fcport->stats_reqq_wait, & bfa_fcport_send_stats_get, (void *)fcport);
    waitq = (struct list_head *)(& (fcport->bfa)->reqq_waitq);
    __ret_warn_on = 0;
    tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
    if (tmp != 0L) {
      warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_svc.c",
                         3420);
    } else {

    }
    ldv__builtin_expect(__ret_warn_on != 0, 0L);
    __ret_warn_on___0 = (unsigned long )fcport->stats_reqq_wait.qresume == (unsigned long )((void (*)(void * ))0) || (unsigned long )fcport->stats_reqq_wait.cbarg == (unsigned long )((void *)0);
    tmp___0 = ldv__builtin_expect(__ret_warn_on___0 != 0, 0L);
    if (tmp___0 != 0L) {
      warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_svc.c",
                         3420);
    } else {

    }
    ldv__builtin_expect(__ret_warn_on___0 != 0, 0L);
    list_add_tail(& fcport->stats_reqq_wait.qe, waitq);
    return;
  } else {

  }
  fcport->stats_qfull = 0;
  memset((void *)msg, 0, 8UL);
  msg->mh.msg_class = 5U;
  msg->mh.msg_id = 4U;
  msg->mh.mtag.h2i.fn_lpu = (u8 )((int )((signed char )((int )(fcport->bfa)->ioc.pcidev.pci_func << 1)) | (int )((signed char )(fcport->bfa)->ioc.port_id));
  msg->mh.mtag.h2i.qid = (fcport->bfa)->iocfc.hw_qid[0];
  (fcport->bfa)->iocfc.req_cq_pi[0] = (fcport->bfa)->iocfc.req_cq_pi[0] + 1U;
  (fcport->bfa)->iocfc.req_cq_pi[0] = (fcport->bfa)->iocfc.req_cq_pi[0] & (u32 )((int )(fcport->bfa)->iocfc.cfg.drvcfg.num_reqq_elems + -1);
  writel((fcport->bfa)->iocfc.req_cq_pi[0], (void volatile   *)(fcport->bfa)->iocfc.bfa_regs.cpe_q_pi[0]);
  __asm__  volatile   ("": : : "memory");
  return;
}
}
static void __bfa_cb_fcport_stats_clr(void *cbarg , enum bfa_boolean complete___0 ) 
{ 
  struct bfa_fcport_s *fcport ;
  struct bfa_cb_pending_q_s *cb ;
  struct list_head *qe ;
  struct list_head *qen ;
  struct timeval tv ;
  int tmp ;

  {
  fcport = (struct bfa_fcport_s *)cbarg;
  if ((unsigned int )complete___0 != 0U) {
    do_gettimeofday(& tv);
    fcport->stats_reset_time = (u32 )tv.tv_sec;
    qe = fcport->statsclr_pending_q.next;
    qen = qe->next;
    goto ldv_49679;
    ldv_49678: 
    tmp = list_empty((struct list_head  const  *)(& fcport->statsclr_pending_q));
    if (tmp == 0) {
      qe = fcport->statsclr_pending_q.next;
      (qe->next)->prev = & fcport->statsclr_pending_q;
      fcport->statsclr_pending_q.next = qe->next;
    } else {
      qe = (struct list_head *)0;
    }
    cb = (struct bfa_cb_pending_q_s *)qe;
    cb->hcb_qe.fw_status = fcport->stats_status;
    list_add_tail(& cb->hcb_qe.qe, & (fcport->bfa)->comp_q);
    qe = qen;
    qen = qe->next;
    ldv_49679: ;
    if ((unsigned long )(& fcport->statsclr_pending_q) != (unsigned long )qe) {
      goto ldv_49678;
    } else {

    }
    fcport->stats_status = 0;
  } else {
    INIT_LIST_HEAD(& fcport->statsclr_pending_q);
    fcport->stats_status = 0;
  }
  return;
}
}
static void bfa_fcport_stats_clr_timeout(void *cbarg ) 
{ 
  struct bfa_fcport_s *fcport ;

  {
  fcport = (struct bfa_fcport_s *)cbarg;
  __bfa_trc((fcport->bfa)->trcmod, __trc_fileno___13, 3464, (unsigned long long )fcport->stats_qfull);
  if ((unsigned int )fcport->stats_qfull != 0U) {
    list_del(& fcport->stats_reqq_wait.qe);
    fcport->stats_qfull = 0;
  } else {

  }
  fcport->stats_status = 5;
  __bfa_cb_fcport_stats_clr((void *)fcport, 1);
  return;
}
}
static void bfa_fcport_send_stats_clear(void *cbarg ) 
{ 
  struct bfa_fcport_s *fcport ;
  struct bfi_fcport_req_s *msg ;
  struct list_head *waitq ;
  int __ret_warn_on ;
  long tmp ;
  int __ret_warn_on___0 ;
  long tmp___0 ;

  {
  fcport = (struct bfa_fcport_s *)cbarg;
  msg = (((fcport->bfa)->iocfc.req_cq_pi[0] + 1U) & (u32 )((int )(fcport->bfa)->iocfc.cfg.drvcfg.num_reqq_elems + -1)) != *((u32 *)(fcport->bfa)->iocfc.req_cq_shadow_ci[0].kva) ? (struct bfi_fcport_req_s *)(fcport->bfa)->iocfc.req_cq_ba[0].kva + (unsigned long )(fcport->bfa)->iocfc.req_cq_pi[0] : (struct bfi_fcport_req_s *)0;
  if ((unsigned long )msg == (unsigned long )((struct bfi_fcport_req_s *)0)) {
    fcport->stats_qfull = 1;
    bfa_reqq_winit(& fcport->stats_reqq_wait, & bfa_fcport_send_stats_clear, (void *)fcport);
    waitq = (struct list_head *)(& (fcport->bfa)->reqq_waitq);
    __ret_warn_on = 0;
    tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
    if (tmp != 0L) {
      warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_svc.c",
                         3488);
    } else {

    }
    ldv__builtin_expect(__ret_warn_on != 0, 0L);
    __ret_warn_on___0 = (unsigned long )fcport->stats_reqq_wait.qresume == (unsigned long )((void (*)(void * ))0) || (unsigned long )fcport->stats_reqq_wait.cbarg == (unsigned long )((void *)0);
    tmp___0 = ldv__builtin_expect(__ret_warn_on___0 != 0, 0L);
    if (tmp___0 != 0L) {
      warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_svc.c",
                         3488);
    } else {

    }
    ldv__builtin_expect(__ret_warn_on___0 != 0, 0L);
    list_add_tail(& fcport->stats_reqq_wait.qe, waitq);
    return;
  } else {

  }
  fcport->stats_qfull = 0;
  memset((void *)msg, 0, 8UL);
  msg->mh.msg_class = 5U;
  msg->mh.msg_id = 5U;
  msg->mh.mtag.h2i.fn_lpu = (u8 )((int )((signed char )((int )(fcport->bfa)->ioc.pcidev.pci_func << 1)) | (int )((signed char )(fcport->bfa)->ioc.port_id));
  msg->mh.mtag.h2i.qid = (fcport->bfa)->iocfc.hw_qid[0];
  (fcport->bfa)->iocfc.req_cq_pi[0] = (fcport->bfa)->iocfc.req_cq_pi[0] + 1U;
  (fcport->bfa)->iocfc.req_cq_pi[0] = (fcport->bfa)->iocfc.req_cq_pi[0] & (u32 )((int )(fcport->bfa)->iocfc.cfg.drvcfg.num_reqq_elems + -1);
  writel((fcport->bfa)->iocfc.req_cq_pi[0], (void volatile   *)(fcport->bfa)->iocfc.bfa_regs.cpe_q_pi[0]);
  __asm__  volatile   ("": : : "memory");
  return;
}
}
static void bfa_trunk_scn(struct bfa_fcport_s *fcport , struct bfi_fcport_trunk_scn_s *scn ) 
{ 
  struct bfa_fcport_trunk_s *trunk ;
  struct bfi_fcport_trunk_link_s *tlink ;
  struct bfa_trunk_link_attr_s *lattr ;
  enum bfa_trunk_state state_prev ;
  int i ;
  int link_bm ;
    klee_make_symbolic(&link_bm, sizeof(int), "link_bm");
  int __ret_warn_on ;
  long tmp ;
  __u32 tmp___0 ;

  {
  trunk = & fcport->trunk;
  link_bm = 0;
  __bfa_trc((fcport->bfa)->trcmod, __trc_fileno___13, 3512, (unsigned long long )fcport->cfg.trunked);
  __ret_warn_on = (unsigned int )scn->trunk_state != 1U && (unsigned int )scn->trunk_state != 2U;
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_svc.c",
                       3514);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  __bfa_trc((fcport->bfa)->trcmod, __trc_fileno___13, 3516, (unsigned long long )trunk->attr.state);
  __bfa_trc((fcport->bfa)->trcmod, __trc_fileno___13, 3517, (unsigned long long )scn->trunk_state);
  __bfa_trc((fcport->bfa)->trcmod, __trc_fileno___13, 3518, (unsigned long long )scn->trunk_speed);
  state_prev = trunk->attr.state;
  if ((unsigned int )fcport->cfg.trunked != 0U && (unsigned int )trunk->attr.state != 0U) {
    trunk->attr.state = (enum bfa_trunk_state )scn->trunk_state;
  } else {

  }
  trunk->attr.speed = (enum bfa_port_speed )scn->trunk_speed;
  i = 0;
  goto ldv_49708;
  ldv_49707: 
  lattr = (struct bfa_trunk_link_attr_s *)(& trunk->attr.link_attr) + (unsigned long )i;
  tlink = (struct bfi_fcport_trunk_link_s *)(& scn->tlink) + (unsigned long )i;
  lattr->link_state = (enum bfa_trunk_link_state )tlink->state;
  lattr->trunk_wwn = tlink->trunk_wwn;
  lattr->fctl = (enum bfa_trunk_link_fctl )tlink->fctl;
  lattr->speed = (enum bfa_port_speed )tlink->speed;
  tmp___0 = __fswab32(tlink->deskew);
  lattr->deskew = tmp___0;
  if ((unsigned int )tlink->state == 1U) {
    fcport->speed = (enum bfa_port_speed )tlink->speed;
    fcport->topology = 5;
    link_bm = (1 << i) | link_bm;
  } else {

  }
  __bfa_trc((fcport->bfa)->trcmod, __trc_fileno___13, 3543, (unsigned long long )lattr->link_state);
  __bfa_trc((fcport->bfa)->trcmod, __trc_fileno___13, 3544, lattr->trunk_wwn);
  __bfa_trc((fcport->bfa)->trcmod, __trc_fileno___13, 3545, (unsigned long long )lattr->fctl);
  __bfa_trc((fcport->bfa)->trcmod, __trc_fileno___13, 3546, (unsigned long long )lattr->speed);
  __bfa_trc((fcport->bfa)->trcmod, __trc_fileno___13, 3547, (unsigned long long )lattr->deskew);
  i = i + 1;
  ldv_49708: ;
  if (i <= 1) {
    goto ldv_49707;
  } else {

  }

  switch (link_bm) {
  case 3: 
  bfa_plog_str((fcport->bfa)->plog, 3, 24, 0, (char *)"Trunk up(0,1)");
  goto ldv_49711;
  case 2: 
  bfa_plog_str((fcport->bfa)->plog, 3, 24, 0, (char *)"Trunk up(-,1)");
  goto ldv_49711;
  case 1: 
  bfa_plog_str((fcport->bfa)->plog, 3, 24, 0, (char *)"Trunk up(0,-)");
  goto ldv_49711;
  default: 
  bfa_plog_str((fcport->bfa)->plog, 3, 24, 0, (char *)"Trunk down");
  }
  ldv_49711: ;
  if ((unsigned int )trunk->attr.state != (unsigned int )state_prev || (unsigned int )scn->trunk_state == 2U) {
    bfa_fcport_scn(fcport, (unsigned int )scn->trunk_state == 1U ? 1 : 2, 1);
  } else {

  }
  return;
}
}
static void bfa_trunk_iocdisable(struct bfa_s *bfa ) 
{ 
  struct bfa_fcport_s *fcport ;
  int i ;

  {
  fcport = & bfa->modules.fcport;
  i = 0;
  if ((unsigned int )fcport->cfg.trunked != 0U) {
    if ((unsigned int )fcport->trunk.attr.state == 1U) {
      bfa_fcport_scn(fcport, 2, 1);
    } else {

    }
    fcport->trunk.attr.state = 2;
    fcport->trunk.attr.speed = 0;
    i = 0;
    goto ldv_49721;
    ldv_49720: 
    fcport->trunk.attr.link_attr[i].trunk_wwn = 0ULL;
    fcport->trunk.attr.link_attr[i].fctl = 0;
    fcport->trunk.attr.link_attr[i].link_state = 2;
    fcport->trunk.attr.link_attr[i].speed = 0;
    fcport->trunk.attr.link_attr[i].deskew = 0U;
    i = i + 1;
    ldv_49721: ;
    if (i <= 1) {
      goto ldv_49720;
    } else {

    }

  } else {

  }
  return;
}
}
void bfa_fcport_init(struct bfa_s *bfa ) 
{ 
  struct bfa_fcport_s *fcport ;
  enum bfa_ioc_type_e tmp___1 ;
  enum bfa_ioc_type_e tmp___2 ;
  enum bfa_status tmp___3 ;
  int __ret_warn_on ;
  long tmp___4 ;
  int __ret_warn_on___0 ;
  long tmp___5 ;
  int __ret_warn_on___1 ;
  long tmp___6 ;

  {
  fcport = & bfa->modules.fcport;
  bfa_fcport_set_wwns(fcport);
  if ((unsigned int )fcport->cfg.maxfrsize == 0U) {
    fcport->cfg.maxfrsize = (bfa->ioc.attr)->maxfrsize;
  } else {

  }
  fcport->cfg.rx_bbcredit = (bfa->ioc.attr)->rx_bbcredit;
  tmp___1 = bfa_ioc_get_type(& bfa->ioc);
  if ((unsigned int )tmp___1 != 2U) {
    tmp___2 = bfa_ioc_get_type(& bfa->ioc);
    if ((unsigned int )tmp___2 != 3U) {
      fcport->speed_sup = (enum bfa_port_speed )((bfa->ioc.attr)->adapter_prop & 255U);
    } else {
      fcport->speed_sup = 10;
    }
  } else {
    fcport->speed_sup = 10;
  }
  tmp___3 = bfa_fcport_is_pbcdisabled(bfa);
  if ((unsigned int )tmp___3 != 0U) {
    bfa->modules.port.pbc_disabled = 1;
  } else {

  }
  __ret_warn_on = (unsigned int )fcport->cfg.maxfrsize == 0U;
  tmp___4 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp___4 != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_svc.c",
                       3626);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  __ret_warn_on___0 = (unsigned int )fcport->cfg.rx_bbcredit == 0U;
  tmp___5 = ldv__builtin_expect(__ret_warn_on___0 != 0, 0L);
  if (tmp___5 != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_svc.c",
                       3627);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on___0 != 0, 0L);
  __ret_warn_on___1 = (unsigned int )fcport->speed_sup == 0U;
  tmp___6 = ldv__builtin_expect(__ret_warn_on___1 != 0, 0L);
  if (tmp___6 != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_svc.c",
                       3628);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on___1 != 0, 0L);
  return;
}
}
void bfa_fcport_isr(struct bfa_s *bfa , struct bfi_msg_s *msg ) 
{ 
  struct bfa_fcport_s *fcport ;
  union bfi_fcport_i2h_msg_u i2hmsg ;
  int tmp ;
  __u16 tmp___0 ;
  __u16 tmp___1 ;
  __u16 tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int __ret_warn_on ;
  long tmp___5 ;

  {
  fcport = & bfa->modules.fcport;
  i2hmsg.msg = msg;
  fcport->event_arg.i2hmsg = i2hmsg;
  __bfa_trc(bfa->trcmod, __trc_fileno___13, 3643, (unsigned long long )msg->mhdr.msg_id);
  tmp = bfa_sm_to_state((struct bfa_sm_table_s *)(& hal_port_sm_table), fcport->sm);
  __bfa_trc(bfa->trcmod, __trc_fileno___13, 3644, (unsigned long long )tmp);
  switch ((int )msg->mhdr.msg_id) {
  case 129: ;
  if (fcport->msgtag == (i2hmsg.penable_rsp)->msgtag) {
    fcport->stats_dma_ready = 1;
    if ((unsigned int )fcport->use_flash_cfg != 0U) {
      fcport->cfg = (i2hmsg.penable_rsp)->port_cfg;
      tmp___0 = __fswab16((int )fcport->cfg.maxfrsize);
      fcport->cfg.maxfrsize = tmp___0;
      tmp___1 = __fswab16((int )fcport->cfg.path_tov);
      fcport->cfg.path_tov = tmp___1;
      tmp___2 = __fswab16((int )fcport->cfg.q_depth);
      fcport->cfg.q_depth = tmp___2;
      if ((unsigned int )fcport->cfg.trunked != 0U) {
        fcport->trunk.attr.state = 2;
      } else {
        fcport->trunk.attr.state = 0;
      }
      fcport->qos_attr.qos_bw = (i2hmsg.penable_rsp)->port_cfg.qos_bw;
      fcport->use_flash_cfg = 0;
    } else {

    }
    if ((unsigned int )fcport->cfg.qos_enabled != 0U) {
      fcport->qos_attr.state = 2U;
    } else {
      fcport->qos_attr.state = 0U;
    }
    fcport->qos_attr.qos_bw_op = (i2hmsg.penable_rsp)->port_cfg.qos_bw;
    if ((unsigned int )fcport->cfg.bb_cr_enabled != 0U) {
      fcport->bbcr_attr.state = 2U;
    } else {
      fcport->bbcr_attr.state = 0U;
    }
    (*(fcport->sm))((void *)fcport, 5);
  } else {

  }
  goto ldv_49740;
  case 130: ;
  if (fcport->msgtag == (i2hmsg.penable_rsp)->msgtag) {
    (*(fcport->sm))((void *)fcport, 5);
  } else {

  }
  goto ldv_49740;
  case 134: ;
  if ((unsigned int )fcport->cfg.bb_cr_enabled != 0U) {
    fcport->bbcr_attr.state = 2U;
  } else {
    fcport->bbcr_attr.state = 0U;
  }
  if ((unsigned int )(i2hmsg.event)->link_state.linkstate == 1U) {
    (*(fcport->sm))((void *)fcport, 6);
  } else
  if ((unsigned int )(i2hmsg.event)->link_state.linkstate_rsn == 12U) {
    (*(fcport->sm))((void *)fcport, 12);
  } else {
    (*(fcport->sm))((void *)fcport, 7);
  }
  fcport->qos_attr.qos_bw_op = (i2hmsg.event)->link_state.qos_attr.qos_bw_op;
  goto ldv_49740;
  case 135: 
  bfa_trunk_scn(fcport, i2hmsg.trunk_scn);
  goto ldv_49740;
  case 132: 
  tmp___3 = list_empty((struct list_head  const  *)(& fcport->stats_pending_q));
  if (tmp___3 != 0 || (unsigned int )fcport->stats_status == 5U) {
    goto ldv_49740;
  } else {

  }
  bfa_timer_stop(& fcport->timer);
  fcport->stats_status = (enum bfa_status )(i2hmsg.pstatsget_rsp)->status;
  __bfa_cb_fcport_stats_get((void *)fcport, 1);
  goto ldv_49740;
  case 133: 
  tmp___4 = list_empty((struct list_head  const  *)(& fcport->statsclr_pending_q));
  if (tmp___4 != 0 || (unsigned int )fcport->stats_status == 5U) {
    goto ldv_49740;
  } else {

  }
  bfa_timer_stop(& fcport->timer);
  fcport->stats_status = 0;
  __bfa_cb_fcport_stats_clr((void *)fcport, 1);
  goto ldv_49740;
  case 136: 
  (*(fcport->sm))((void *)fcport, 3);
  goto ldv_49740;
  case 137: 
  (*(fcport->sm))((void *)fcport, 4);
  goto ldv_49740;
  default: 
  __ret_warn_on = 1;
  tmp___5 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp___5 != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_svc.c",
                       3753);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  goto ldv_49740;
  }
  ldv_49740: ;
  return;
}
}
void bfa_fcport_event_register(struct bfa_s *bfa , void (*cbfn)(void * , enum bfa_port_linkstate  ) ,
                               void *cbarg ) 
{ 
  struct bfa_fcport_s *fcport ;

  {
  fcport = & bfa->modules.fcport;
  fcport->event_cbfn = cbfn;
  fcport->event_cbarg = cbarg;
  return;
}
}
enum bfa_status bfa_fcport_enable(struct bfa_s *bfa ) 
{ 
  struct bfa_fcport_s *fcport ;
  enum bfa_status tmp ;
  enum bfa_boolean tmp___0 ;

  {
  fcport = & bfa->modules.fcport;
  tmp = bfa_fcport_is_pbcdisabled(bfa);
  if ((unsigned int )tmp != 0U) {
    return (154);
  } else {

  }
  tmp___0 = bfa_ioc_is_disabled(& bfa->ioc);
  if ((unsigned int )tmp___0 != 0U) {
    return (82);
  } else {

  }
  if ((unsigned int )fcport->diag_busy != 0U) {
    return (71);
  } else {

  }
  (*(bfa->modules.fcport.sm))((void *)(& bfa->modules.fcport), 3);
  return (0);
}
}
enum bfa_status bfa_fcport_disable(struct bfa_s *bfa ) 
{ 
  enum bfa_status tmp ;
  enum bfa_boolean tmp___0 ;

  {
  tmp = bfa_fcport_is_pbcdisabled(bfa);
  if ((unsigned int )tmp != 0U) {
    return (154);
  } else {

  }
  tmp___0 = bfa_ioc_is_disabled(& bfa->ioc);
  if ((unsigned int )tmp___0 != 0U) {
    return (82);
  } else {

  }
  (*(bfa->modules.fcport.sm))((void *)(& bfa->modules.fcport), 4);
  return (0);
}
}
enum bfa_status bfa_fcport_is_pbcdisabled(struct bfa_s *bfa ) 
{ 
  struct bfa_fcport_s *fcport ;
  struct bfa_iocfc_s *iocfc ;
  struct bfi_iocfc_cfgrsp_s *cfgrsp ;

  {
  fcport = & bfa->modules.fcport;
  iocfc = & bfa->iocfc;
  cfgrsp = iocfc->cfgrsp;
  if ((unsigned int )cfgrsp->pbc_cfg.port_enabled == 2U) {
    __bfa_trc(bfa->trcmod, __trc_fileno___13, 3813, fcport->pwwn);
    return (154);
  } else {

  }
  return (0);
}
}
enum bfa_status bfa_fcport_cfg_speed(struct bfa_s *bfa , enum bfa_port_speed speed ) 
{ 
  struct bfa_fcport_s *fcport ;
  enum bfa_ioc_type_e tmp ;

  {
  fcport = & bfa->modules.fcport;
  __bfa_trc(bfa->trcmod, __trc_fileno___13, 3827, (unsigned long long )speed);
  if ((unsigned int )fcport->cfg.trunked == 1U) {
    return (164);
  } else {

  }
  if ((unsigned int )fcport->cfg.topology == 2U && (unsigned int )speed == 16U) {
    return (23);
  } else {

  }
  if ((unsigned int )speed != 15U && (unsigned int )fcport->speed_sup < (unsigned int )speed) {
    __bfa_trc(bfa->trcmod, __trc_fileno___13, 3835, (unsigned long long )fcport->speed_sup);
    return (23);
  } else {

  }
  tmp = bfa_ioc_get_type(& (fcport->bfa)->ioc);
  if ((unsigned int )tmp == 1U) {
    if ((unsigned int )speed == 1U && ((unsigned int )bfa->ioc.pcidev.device_id == 34U || (unsigned int )bfa->ioc.pcidev.device_id == 35U)) {
      return (23);
    } else {

    }
    if ((((((unsigned int )speed != 1U && (unsigned int )speed != 2U) && (unsigned int )speed != 4U) && (unsigned int )speed != 8U) && (unsigned int )speed != 16U) && (unsigned int )speed != 15U) {
      return (23);
    } else {

    }
  } else
  if ((unsigned int )speed != 10U) {
    return (23);
  } else {

  }
  fcport->cfg.speed = (u8 )speed;
  return (0);
}
}
enum bfa_port_speed bfa_fcport_get_speed(struct bfa_s *bfa ) 
{ 
  struct bfa_fcport_s *fcport ;

  {
  fcport = & bfa->modules.fcport;
  return (fcport->speed);
}
}
enum bfa_status bfa_fcport_cfg_topology(struct bfa_s *bfa , enum bfa_port_topology topology ) 
{ 
  struct bfa_fcport_s *fcport ;
  enum bfa_boolean tmp ;
  enum bfa_boolean tmp___0 ;
  enum bfa_port_speed tmp___1 ;
  enum bfa_boolean tmp___2 ;
  enum bfa_boolean tmp___3 ;

  {
  fcport = & bfa->modules.fcport;
  __bfa_trc(bfa->trcmod, __trc_fileno___13, 3883, (unsigned long long )topology);
  __bfa_trc(bfa->trcmod, __trc_fileno___13, 3884, (unsigned long long )fcport->cfg.topology);
  switch ((unsigned int )topology) {
  case 5U: ;
  goto ldv_49787;
  case 2U: 
  tmp = bfa_fcport_is_qos_enabled(bfa);
  if ((unsigned int )tmp != 0U || (unsigned int )fcport->qos_attr.state != 0U) {
    return (88);
  } else {

  }
  if ((unsigned int )fcport->cfg.ratelimit != 0U) {
    return (87);
  } else {

  }
  tmp___0 = bfa_fcport_is_trunk_enabled(bfa);
  if ((unsigned int )tmp___0 != 0U || (unsigned int )fcport->trunk.attr.state != 0U) {
    return (203);
  } else {

  }
  tmp___1 = bfa_fcport_get_speed(bfa);
  if ((unsigned int )tmp___1 == 16U || (unsigned int )fcport->cfg.speed == 16U) {
    return (23);
  } else {

  }
  if (((((((bfa->ioc.attr)->card_type == 804U || (bfa->ioc.attr)->card_type == 1007U) || (bfa->ioc.attr)->card_type == 807U) || (bfa->ioc.attr)->card_type == 902U) || (bfa->ioc.attr)->card_type == 1741U) || (bfa->ioc.attr)->card_type == 1867U) || (bfa->ioc.attr)->card_type == 1869U) {
    return (231);
  } else {

  }
  tmp___2 = bfa_fcport_is_dport(bfa);
  if ((unsigned int )tmp___2 != 0U) {
    return (245);
  } else {

  }
  tmp___3 = bfa_fcport_is_ddport(bfa);
  if ((unsigned int )tmp___3 != 0U) {
    return (245);
  } else {

  }
  goto ldv_49787;
  case 4U: ;
  goto ldv_49787;
  default: ;
  return (2);
  }
  ldv_49787: 
  fcport->cfg.topology = (u8 )topology;
  return (0);
}
}
enum bfa_port_topology bfa_fcport_get_topology(struct bfa_s *bfa ) 
{ 
  struct bfa_fcport_s *fcport ;

  {
  fcport = & bfa->modules.fcport;
  return (fcport->topology);
}
}
enum bfa_port_topology bfa_fcport_get_cfg_topology(struct bfa_s *bfa ) 
{ 
  struct bfa_fcport_s *fcport ;

  {
  fcport = & bfa->modules.fcport;
  return ((enum bfa_port_topology )fcport->cfg.topology);
}
}
enum bfa_status bfa_fcport_cfg_hardalpa(struct bfa_s *bfa , u8 alpa ) 
{ 
  struct bfa_fcport_s *fcport ;

  {
  fcport = & bfa->modules.fcport;
  __bfa_trc(bfa->trcmod, __trc_fileno___13, 3948, (unsigned long long )alpa);
  __bfa_trc(bfa->trcmod, __trc_fileno___13, 3949, (unsigned long long )fcport->cfg.cfg_hardalpa);
  __bfa_trc(bfa->trcmod, __trc_fileno___13, 3950, (unsigned long long )fcport->cfg.hardalpa);
  fcport->cfg.cfg_hardalpa = 1U;
  fcport->cfg.hardalpa = alpa;
  return (0);
}
}
enum bfa_status bfa_fcport_clr_hardalpa(struct bfa_s *bfa ) 
{ 
  struct bfa_fcport_s *fcport ;

  {
  fcport = & bfa->modules.fcport;
  __bfa_trc(bfa->trcmod, __trc_fileno___13, 3963, (unsigned long long )fcport->cfg.cfg_hardalpa);
  __bfa_trc(bfa->trcmod, __trc_fileno___13, 3964, (unsigned long long )fcport->cfg.hardalpa);
  fcport->cfg.cfg_hardalpa = 0U;
  return (0);
}
}
enum bfa_boolean bfa_fcport_get_hardalpa(struct bfa_s *bfa , u8 *alpa ) 
{ 
  struct bfa_fcport_s *fcport ;

  {
  fcport = & bfa->modules.fcport;
  *alpa = fcport->cfg.hardalpa;
  return ((enum bfa_boolean )fcport->cfg.cfg_hardalpa);
}
}
u8 bfa_fcport_get_myalpa(struct bfa_s *bfa ) 
{ 
  struct bfa_fcport_s *fcport ;

  {
  fcport = & bfa->modules.fcport;
  return (fcport->myalpa);
}
}
enum bfa_status bfa_fcport_cfg_maxfrsize(struct bfa_s *bfa , u16 maxfrsize ) 
{ 
  struct bfa_fcport_s *fcport ;

  {
  fcport = & bfa->modules.fcport;
  __bfa_trc(bfa->trcmod, __trc_fileno___13, 3992, (unsigned long long )maxfrsize);
  __bfa_trc(bfa->trcmod, __trc_fileno___13, 3993, (unsigned long long )fcport->cfg.maxfrsize);
  if ((unsigned int )maxfrsize > 2112U || (unsigned int )maxfrsize <= 511U) {
    return (24);
  } else {

  }
  if ((unsigned int )maxfrsize != 2112U && ((int )maxfrsize & ((int )maxfrsize + -1)) != 0) {
    return (24);
  } else {

  }
  fcport->cfg.maxfrsize = maxfrsize;
  return (0);
}
}
u16 bfa_fcport_get_maxfrsize(struct bfa_s *bfa ) 
{ 
  struct bfa_fcport_s *fcport ;

  {
  fcport = & bfa->modules.fcport;
  return (fcport->cfg.maxfrsize);
}
}
u8 bfa_fcport_get_rx_bbcredit(struct bfa_s *bfa ) 
{ 
  enum bfa_port_topology tmp ;

  {
  tmp = bfa_fcport_get_topology(bfa);
  if ((unsigned int )tmp != 2U) {
    return (bfa->modules.fcport.cfg.rx_bbcredit);
  } else {
    return (0U);
  }
}
}
void bfa_fcport_set_tx_bbcredit(struct bfa_s *bfa , u16 tx_bbcredit ) 
{ 
  struct bfa_fcport_s *fcport ;

  {
  fcport = & bfa->modules.fcport;
  fcport->cfg.tx_bbcredit = (unsigned char )tx_bbcredit;
  return;
}
}
wwn_t bfa_fcport_get_wwn(struct bfa_s *bfa , enum bfa_boolean node ) 
{ 
  struct bfa_fcport_s *fcport ;

  {
  fcport = & bfa->modules.fcport;
  if ((unsigned int )node != 0U) {
    return (fcport->nwwn);
  } else {
    return (fcport->pwwn);
  }
}
}
void bfa_fcport_get_attr(struct bfa_s *bfa , struct bfa_port_attr_s *attr ) 
{ 
  struct bfa_fcport_s *fcport ;
  int tmp ;
  enum bfa_boolean tmp___0 ;
  enum bfa_boolean tmp___1 ;
  enum bfa_status tmp___2 ;

  {
  fcport = & bfa->modules.fcport;
  memset((void *)attr, 0, 376UL);
  attr->nwwn = fcport->nwwn;
  attr->pwwn = fcport->pwwn;
  attr->factorypwwn = (bfa->ioc.attr)->mfg_pwwn;
  attr->factorynwwn = (bfa->ioc.attr)->mfg_nwwn;
  memcpy((void *)(& attr->pport_cfg), (void const   *)(& fcport->cfg), 24UL);
  attr->pport_cfg.speed = fcport->cfg.speed;
  attr->speed_supported = fcport->speed_sup;
  attr->speed = fcport->speed;
  attr->cos_supported = 8;
  attr->pport_cfg.topology = fcport->cfg.topology;
  attr->topology = fcport->topology;
  attr->pport_cfg.trunked = fcport->cfg.trunked;
  attr->beacon = fcport->beacon;
  attr->link_e2e_beacon = fcport->link_e2e_beacon;
  attr->pport_cfg.path_tov = bfa_fcpim_path_tov_get(bfa);
  attr->pport_cfg.q_depth = bfa_fcpim_qdepth_get(bfa);
  tmp = bfa_sm_to_state((struct bfa_sm_table_s *)(& hal_port_sm_table), fcport->sm);
  attr->port_state = (enum bfa_port_states )tmp;
  attr->fec_state = fcport->fec_state;
  tmp___2 = bfa_fcport_is_pbcdisabled(bfa);
  if ((unsigned int )tmp___2 != 0U) {
    attr->port_state = 13;
  } else {
    tmp___1 = bfa_ioc_is_disabled(& (fcport->bfa)->ioc);
    if ((unsigned int )tmp___1 != 0U) {
      attr->port_state = 11;
    } else {
      tmp___0 = bfa_ioc_fw_mismatch(& (fcport->bfa)->ioc);
      if ((unsigned int )tmp___0 != 0U) {
        attr->port_state = 12;
      } else {

      }
    }
  }
  attr->fcoe_vlan = fcport->fcoe_vlan;
  return;
}
}
enum bfa_status bfa_fcport_get_stats(struct bfa_s *bfa , struct bfa_cb_pending_q_s *cb ) 
{ 
  struct bfa_fcport_s *fcport ;
  enum bfa_boolean tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  fcport = & bfa->modules.fcport;
  tmp = bfa_iocfc_is_operational(bfa);
  if ((unsigned int )tmp == 0U || (unsigned int )fcport->stats_dma_ready == 0U) {
    return (61);
  } else {

  }
  tmp___0 = list_empty((struct list_head  const  *)(& fcport->statsclr_pending_q));
  if (tmp___0 == 0) {
    return (13);
  } else {

  }
  tmp___1 = list_empty((struct list_head  const  *)(& fcport->stats_pending_q));
  if (tmp___1 != 0) {
    list_add_tail(& cb->hcb_qe.qe, & fcport->stats_pending_q);
    bfa_fcport_send_stats_get((void *)fcport);
    bfa_timer_begin(& bfa->timer_mod, & fcport->timer, & bfa_fcport_stats_get_timeout,
                    (void *)fcport, 1000U);
  } else {
    list_add_tail(& cb->hcb_qe.qe, & fcport->stats_pending_q);
  }
  return (0);
}
}
enum bfa_status bfa_fcport_clear_stats(struct bfa_s *bfa , struct bfa_cb_pending_q_s *cb ) 
{ 
  struct bfa_fcport_s *fcport ;
  enum bfa_boolean tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  fcport = & bfa->modules.fcport;
  tmp = bfa_iocfc_is_operational(bfa);
  if ((unsigned int )tmp == 0U || (unsigned int )fcport->stats_dma_ready == 0U) {
    return (61);
  } else {

  }
  tmp___0 = list_empty((struct list_head  const  *)(& fcport->stats_pending_q));
  if (tmp___0 == 0) {
    return (13);
  } else {

  }
  tmp___1 = list_empty((struct list_head  const  *)(& fcport->statsclr_pending_q));
  if (tmp___1 != 0) {
    list_add_tail(& cb->hcb_qe.qe, & fcport->statsclr_pending_q);
    bfa_fcport_send_stats_clear((void *)fcport);
    bfa_timer_begin(& bfa->timer_mod, & fcport->timer, & bfa_fcport_stats_clr_timeout,
                    (void *)fcport, 1000U);
  } else {
    list_add_tail(& cb->hcb_qe.qe, & fcport->statsclr_pending_q);
  }
  return (0);
}
}
enum bfa_boolean bfa_fcport_is_disabled(struct bfa_s *bfa ) 
{ 
  struct bfa_fcport_s *fcport ;
  int tmp ;

  {
  fcport = & bfa->modules.fcport;
  tmp = bfa_sm_to_state((struct bfa_sm_table_s *)(& hal_port_sm_table), fcport->sm);
  return (tmp == 8);
}
}
enum bfa_boolean bfa_fcport_is_dport(struct bfa_s *bfa ) 
{ 
  struct bfa_fcport_s *fcport ;
  int tmp ;

  {
  fcport = & bfa->modules.fcport;
  tmp = bfa_sm_to_state((struct bfa_sm_table_s *)(& hal_port_sm_table), fcport->sm);
  return (tmp == 16);
}
}
enum bfa_boolean bfa_fcport_is_ddport(struct bfa_s *bfa ) 
{ 
  struct bfa_fcport_s *fcport ;
  int tmp ;

  {
  fcport = & bfa->modules.fcport;
  tmp = bfa_sm_to_state((struct bfa_sm_table_s *)(& hal_port_sm_table), fcport->sm);
  return (tmp == 17);
}
}
enum bfa_status bfa_fcport_set_qos_bw(struct bfa_s *bfa , struct bfa_qos_bw_s *qos_bw ) 
{ 
  struct bfa_fcport_s *fcport ;
  enum bfa_ioc_type_e ioc_type ;
  enum bfa_ioc_type_e tmp ;

  {
  fcport = & bfa->modules.fcport;
  tmp = bfa_ioc_get_type(& bfa->ioc);
  ioc_type = tmp;
  __bfa_trc(bfa->trcmod, __trc_fileno___13, 4190, (unsigned long long )ioc_type);
  if (((unsigned int )qos_bw->high == 0U || (unsigned int )qos_bw->med == 0U) || (unsigned int )qos_bw->low == 0U) {
    return (234);
  } else {

  }
  if (((int )qos_bw->high + (int )qos_bw->med) + (int )qos_bw->low != 100) {
    return (234);
  } else {

  }
  if (((int )qos_bw->med > (int )qos_bw->high || (int )qos_bw->low > (int )qos_bw->med) || (int )qos_bw->low > (int )qos_bw->high) {
    return (234);
  } else {

  }
  if ((unsigned int )ioc_type == 1U && (unsigned int )fcport->cfg.topology != 2U) {
    fcport->cfg.qos_bw = *qos_bw;
  } else {

  }
  return (0);
}
}
enum bfa_boolean bfa_fcport_is_ratelim(struct bfa_s *bfa ) 
{ 
  struct bfa_fcport_s *fcport ;

  {
  fcport = & bfa->modules.fcport;
  return ((unsigned int )fcport->cfg.ratelimit != 0U);
}
}
void bfa_fcport_cfg_faa(struct bfa_s *bfa , u8 state ) 
{ 
  struct bfa_fcport_s *fcport ;

  {
  fcport = & bfa->modules.fcport;
  __bfa_trc(bfa->trcmod, __trc_fileno___13, 4226, (unsigned long long )state);
  fcport->cfg.faa_state = state;
  return;
}
}
enum bfa_port_speed bfa_fcport_get_ratelim_speed(struct bfa_s *bfa ) 
{ 
  struct bfa_fcport_s *fcport ;

  {
  fcport = & bfa->modules.fcport;
  __bfa_trc(bfa->trcmod, __trc_fileno___13, 4238, (unsigned long long )fcport->cfg.trl_def_speed);
  return ((enum bfa_port_speed )fcport->cfg.trl_def_speed);
}
}
void bfa_fcport_beacon(void *dev , enum bfa_boolean beacon , enum bfa_boolean link_e2e_beacon ) 
{ 
  struct bfa_s *bfa ;
  struct bfa_fcport_s *fcport ;

  {
  bfa = (struct bfa_s *)dev;
  fcport = & bfa->modules.fcport;
  __bfa_trc(bfa->trcmod, __trc_fileno___13, 4250, (unsigned long long )beacon);
  __bfa_trc(bfa->trcmod, __trc_fileno___13, 4251, (unsigned long long )link_e2e_beacon);
  __bfa_trc(bfa->trcmod, __trc_fileno___13, 4252, (unsigned long long )fcport->beacon);
  __bfa_trc(bfa->trcmod, __trc_fileno___13, 4253, (unsigned long long )fcport->link_e2e_beacon);
  fcport->beacon = beacon;
  fcport->link_e2e_beacon = link_e2e_beacon;
  return;
}
}
enum bfa_boolean bfa_fcport_is_linkup(struct bfa_s *bfa ) 
{ 
  struct bfa_fcport_s *fcport ;

  {
  fcport = & bfa->modules.fcport;
  return ((enum bfa_boolean )(((unsigned int )fcport->cfg.trunked == 0U && (unsigned long )fcport->sm == (unsigned long )((void (*)(void * ,
                                                                                                                                    int  ))(& bfa_fcport_sm_linkup))) || ((unsigned int )fcport->cfg.trunked != 0U && (unsigned int )fcport->trunk.attr.state == 1U)));
}
}
enum bfa_boolean bfa_fcport_is_qos_enabled(struct bfa_s *bfa ) 
{ 
  struct bfa_fcport_s *fcport ;

  {
  fcport = & bfa->modules.fcport;
  return ((enum bfa_boolean )fcport->cfg.qos_enabled);
}
}
enum bfa_boolean bfa_fcport_is_trunk_enabled(struct bfa_s *bfa ) 
{ 
  struct bfa_fcport_s *fcport ;

  {
  fcport = & bfa->modules.fcport;
  return ((enum bfa_boolean )fcport->cfg.trunked);
}
}
enum bfa_status bfa_fcport_cfg_bbcr(struct bfa_s *bfa , enum bfa_boolean on_off ,
                                    u8 bb_scn ) 
{ 
  struct bfa_fcport_s *fcport ;
  enum bfa_ioc_type_e tmp ;
  unsigned int tmp___2 ;
  enum bfa_ioc_type_e tmp___3 ;
  enum bfa_ioc_type_e tmp___4 ;
  enum bfa_ioc_type_e tmp___5 ;
  enum bfa_ioc_type_e tmp___6 ;

  {
  fcport = & bfa->modules.fcport;
  __bfa_trc(bfa->trcmod, __trc_fileno___13, 4291, (unsigned long long )on_off);
  tmp = bfa_ioc_get_type(& (fcport->bfa)->ioc);
  if ((unsigned int )tmp != 1U) {
    return (201);
  } else {

  }
  if ((((((((bfa->ioc.attr)->card_type == 804U || (bfa->ioc.attr)->card_type == 1007U) || (bfa->ioc.attr)->card_type == 807U) || (bfa->ioc.attr)->card_type == 902U) || (bfa->ioc.attr)->card_type == 1741U) || (bfa->ioc.attr)->card_type == 1867U) || (bfa->ioc.attr)->card_type == 1869U) && (bfa->ioc.attr)->card_type != 1867U) {
    return (239);
  } else {

  }
  if ((unsigned int )on_off != 0U) {
    if ((unsigned int )fcport->cfg.topology == 2U) {
      return (230);
    } else {

    }
    if ((unsigned int )fcport->cfg.qos_enabled != 0U) {
      return (88);
    } else {

    }
    if ((unsigned int )fcport->cfg.trunked != 0U) {
      return (164);
    } else {

    }
    if ((unsigned int )fcport->cfg.speed != 15U) {
      tmp___3 = bfa_ioc_get_type(& bfa->ioc);
      if ((unsigned int )tmp___3 != 2U) {
        tmp___4 = bfa_ioc_get_type(& bfa->ioc);
        if ((unsigned int )tmp___4 != 3U) {
          tmp___2 = (bfa->ioc.attr)->adapter_prop & 255U;
        } else {
          tmp___2 = 10U;
        }
      } else {
        tmp___2 = 10U;
      }
      if ((u32 )fcport->cfg.speed < tmp___2) {
        return (258);
      } else {

      }
    } else {

    }
    tmp___5 = bfa_ioc_get_type(& bfa->ioc);
    if ((unsigned int )tmp___5 != 2U) {
      tmp___6 = bfa_ioc_get_type(& bfa->ioc);
      if ((unsigned int )tmp___6 != 3U) {
        if (((bfa->ioc.attr)->adapter_prop & 255U) <= 7U) {
          return (192);
        } else {

        }
      } else {

      }
    } else {

    }
    if ((unsigned int )fcport->cfg.bb_cr_enabled != 0U) {
      if ((int )fcport->cfg.bb_scn != (int )bb_scn) {
        return (265);
      } else {
        return (195);
      }
    } else {

    }
    if ((unsigned int )bb_scn == 0U || (unsigned int )bb_scn > 15U) {
      bb_scn = 3U;
    } else {

    }
    fcport->cfg.bb_cr_enabled = (u8 )on_off;
    fcport->cfg.bb_scn = bb_scn;
  } else {
    if ((unsigned int )fcport->cfg.bb_cr_enabled == 0U) {
      return (195);
    } else {

    }
    fcport->cfg.bb_cr_enabled = (u8 )on_off;
    fcport->cfg.bb_scn = 0U;
  }
  return (0);
}
}
enum bfa_status bfa_fcport_get_bbcr_attr(struct bfa_s *bfa , struct bfa_bbcr_attr_s *bbcr_attr ) 
{ 
  struct bfa_fcport_s *fcport ;
  enum bfa_ioc_type_e tmp ;

  {
  fcport = & bfa->modules.fcport;
  tmp = bfa_ioc_get_type(& (fcport->bfa)->ioc);
  if ((unsigned int )tmp != 1U) {
    return (201);
  } else {

  }
  if ((unsigned int )fcport->cfg.topology == 2U) {
    return (230);
  } else {

  }
  *bbcr_attr = fcport->bbcr_attr;
  return (0);
}
}
void bfa_fcport_dportenable(struct bfa_s *bfa ) 
{ 


  {
  (*(bfa->modules.fcport.sm))((void *)(& bfa->modules.fcport), 10);
  bfa_port_set_dportenabled(& bfa->modules.port, 1);
  return;
}
}
void bfa_fcport_dportdisable(struct bfa_s *bfa ) 
{ 


  {
  (*(bfa->modules.fcport.sm))((void *)(& bfa->modules.fcport), 11);
  bfa_port_set_dportenabled(& bfa->modules.port, 0);
  return;
}
}
void bfa_fcport_ddportenable(struct bfa_s *bfa ) 
{ 


  {
  (*(bfa->modules.fcport.sm))((void *)(& bfa->modules.fcport), 13);
  return;
}
}
void bfa_fcport_ddportdisable(struct bfa_s *bfa ) 
{ 


  {
  (*(bfa->modules.fcport.sm))((void *)(& bfa->modules.fcport), 14);
  return;
}
}
static void bfa_rport_sm_uninit(struct bfa_rport_s *rp , enum bfa_rport_event event ) 
{ 


  {
  __bfa_trc((rp->bfa)->trcmod, __trc_fileno___13, 4404, (unsigned long long )rp->rport_tag);
  __bfa_trc((rp->bfa)->trcmod, __trc_fileno___13, 4405, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 1U: 
  rp->stats.sm_un_cr = rp->stats.sm_un_cr + 1U;
  rp->sm = (void (*)(void * , int  ))(& bfa_rport_sm_created);
  goto ldv_49932;
  default: 
  rp->stats.sm_un_unexp = rp->stats.sm_un_unexp + 1U;
  __bfa_trc((rp->bfa)->trcmod, __trc_fileno___13, 4415, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_svc.c",
         4415, (unsigned int )event);
  }
  ldv_49932: ;
  return;
}
}
static void bfa_rport_sm_created(struct bfa_rport_s *rp , enum bfa_rport_event event ) 
{ 
  enum bfa_boolean tmp ;

  {
  __bfa_trc((rp->bfa)->trcmod, __trc_fileno___13, 4422, (unsigned long long )rp->rport_tag);
  __bfa_trc((rp->bfa)->trcmod, __trc_fileno___13, 4423, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 3U: 
  rp->stats.sm_cr_on = rp->stats.sm_cr_on + 1U;
  tmp = bfa_rport_send_fwcreate(rp);
  if ((unsigned int )tmp != 0U) {
    rp->sm = (void (*)(void * , int  ))(& bfa_rport_sm_fwcreate);
  } else {
    rp->sm = (void (*)(void * , int  ))(& bfa_rport_sm_fwcreate_qfull);
  }
  goto ldv_49939;
  case 2U: 
  rp->stats.sm_cr_del = rp->stats.sm_cr_del + 1U;
  rp->sm = (void (*)(void * , int  ))(& bfa_rport_sm_uninit);
  bfa_rport_free(rp);
  goto ldv_49939;
  case 6U: 
  rp->stats.sm_cr_hwf = rp->stats.sm_cr_hwf + 1U;
  rp->sm = (void (*)(void * , int  ))(& bfa_rport_sm_iocdisable);
  goto ldv_49939;
  default: 
  rp->stats.sm_cr_unexp = rp->stats.sm_cr_unexp + 1U;
  __bfa_trc((rp->bfa)->trcmod, __trc_fileno___13, 4447, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_svc.c",
         4447, (unsigned int )event);
  }
  ldv_49939: ;
  return;
}
}
static void bfa_rport_sm_fwcreate(struct bfa_rport_s *rp , enum bfa_rport_event event ) 
{ 


  {
  __bfa_trc((rp->bfa)->trcmod, __trc_fileno___13, 4457, (unsigned long long )rp->rport_tag);
  __bfa_trc((rp->bfa)->trcmod, __trc_fileno___13, 4458, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 5U: 
  rp->stats.sm_fwc_rsp = rp->stats.sm_fwc_rsp + 1U;
  rp->sm = (void (*)(void * , int  ))(& bfa_rport_sm_online);
  if ((unsigned int )(rp->bfa)->fcs != 0U) {
    bfa_cb_rport_online(rp->rport_drv);
  } else {
    rp->hcb_qe.cbfn = & __bfa_cb_rport_online;
    rp->hcb_qe.cbarg = (void *)rp;
    rp->hcb_qe.pre_rmv = 0;
    list_add_tail(& rp->hcb_qe.qe, & (rp->bfa)->comp_q);
  }
  goto ldv_49948;
  case 2U: 
  rp->stats.sm_fwc_del = rp->stats.sm_fwc_del + 1U;
  rp->sm = (void (*)(void * , int  ))(& bfa_rport_sm_delete_pending);
  goto ldv_49948;
  case 4U: 
  rp->stats.sm_fwc_off = rp->stats.sm_fwc_off + 1U;
  rp->sm = (void (*)(void * , int  ))(& bfa_rport_sm_offline_pending);
  goto ldv_49948;
  case 6U: 
  rp->stats.sm_fwc_hwf = rp->stats.sm_fwc_hwf + 1U;
  rp->sm = (void (*)(void * , int  ))(& bfa_rport_sm_iocdisable);
  goto ldv_49948;
  default: 
  rp->stats.sm_fwc_unexp = rp->stats.sm_fwc_unexp + 1U;
  __bfa_trc((rp->bfa)->trcmod, __trc_fileno___13, 4484, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_svc.c",
         4484, (unsigned int )event);
  }
  ldv_49948: ;
  return;
}
}
static void bfa_rport_sm_fwcreate_qfull(struct bfa_rport_s *rp , enum bfa_rport_event event ) 
{ 


  {
  __bfa_trc((rp->bfa)->trcmod, __trc_fileno___13, 4494, (unsigned long long )rp->rport_tag);
  __bfa_trc((rp->bfa)->trcmod, __trc_fileno___13, 4495, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 9U: 
  rp->sm = (void (*)(void * , int  ))(& bfa_rport_sm_fwcreate);
  bfa_rport_send_fwcreate(rp);
  goto ldv_49958;
  case 2U: 
  rp->stats.sm_fwc_del = rp->stats.sm_fwc_del + 1U;
  rp->sm = (void (*)(void * , int  ))(& bfa_rport_sm_uninit);
  list_del(& rp->reqq_wait.qe);
  bfa_rport_free(rp);
  goto ldv_49958;
  case 4U: 
  rp->stats.sm_fwc_off = rp->stats.sm_fwc_off + 1U;
  rp->sm = (void (*)(void * , int  ))(& bfa_rport_sm_offline);
  list_del(& rp->reqq_wait.qe);
  if ((unsigned int )(rp->bfa)->fcs != 0U) {
    bfa_cb_rport_offline(rp->rport_drv);
  } else {
    rp->hcb_qe.cbfn = & __bfa_cb_rport_offline;
    rp->hcb_qe.cbarg = (void *)rp;
    rp->hcb_qe.pre_rmv = 0;
    list_add_tail(& rp->hcb_qe.qe, & (rp->bfa)->comp_q);
  }
  goto ldv_49958;
  case 6U: 
  rp->stats.sm_fwc_hwf = rp->stats.sm_fwc_hwf + 1U;
  rp->sm = (void (*)(void * , int  ))(& bfa_rport_sm_iocdisable);
  list_del(& rp->reqq_wait.qe);
  goto ldv_49958;
  default: 
  rp->stats.sm_fwc_unexp = rp->stats.sm_fwc_unexp + 1U;
  __bfa_trc((rp->bfa)->trcmod, __trc_fileno___13, 4525, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_svc.c",
         4525, (unsigned int )event);
  }
  ldv_49958: ;
  return;
}
}
static void bfa_rport_sm_online(struct bfa_rport_s *rp , enum bfa_rport_event event ) 
{ 
  struct bfi_rport_qos_scn_s *qos_scn ;
  enum bfa_boolean tmp ;
  enum bfa_boolean tmp___0 ;
  __u32 tmp___1 ;
  __u32 tmp___2 ;

  {
  __bfa_trc((rp->bfa)->trcmod, __trc_fileno___13, 4537, (unsigned long long )rp->rport_tag);
  __bfa_trc((rp->bfa)->trcmod, __trc_fileno___13, 4538, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 4U: 
  rp->stats.sm_on_off = rp->stats.sm_on_off + 1U;
  tmp = bfa_rport_send_fwdelete(rp);
  if ((unsigned int )tmp != 0U) {
    rp->sm = (void (*)(void * , int  ))(& bfa_rport_sm_fwdelete);
  } else {
    rp->sm = (void (*)(void * , int  ))(& bfa_rport_sm_fwdelete_qfull);
  }
  goto ldv_49969;
  case 2U: 
  rp->stats.sm_on_del = rp->stats.sm_on_del + 1U;
  tmp___0 = bfa_rport_send_fwdelete(rp);
  if ((unsigned int )tmp___0 != 0U) {
    rp->sm = (void (*)(void * , int  ))(& bfa_rport_sm_deleting);
  } else {
    rp->sm = (void (*)(void * , int  ))(& bfa_rport_sm_deleting_qfull);
  }
  goto ldv_49969;
  case 6U: 
  rp->stats.sm_on_hwf = rp->stats.sm_on_hwf + 1U;
  rp->sm = (void (*)(void * , int  ))(& bfa_rport_sm_iocdisable);
  goto ldv_49969;
  case 8U: 
  bfa_rport_send_fwspeed(rp);
  goto ldv_49969;
  case 7U: 
  qos_scn = (struct bfi_rport_qos_scn_s *)rp->event_arg.fw_msg;
  rp->qos_attr = qos_scn->new_qos_attr;
  __bfa_trc((rp->bfa)->trcmod, __trc_fileno___13, 4569, (unsigned long long )qos_scn->old_qos_attr.qos_flow_id);
  __bfa_trc((rp->bfa)->trcmod, __trc_fileno___13, 4570, (unsigned long long )qos_scn->new_qos_attr.qos_flow_id);
  __bfa_trc((rp->bfa)->trcmod, __trc_fileno___13, 4571, (unsigned long long )qos_scn->old_qos_attr.qos_priority);
  __bfa_trc((rp->bfa)->trcmod, __trc_fileno___13, 4572, (unsigned long long )qos_scn->new_qos_attr.qos_priority);
  tmp___1 = __fswab32(qos_scn->old_qos_attr.qos_flow_id);
  qos_scn->old_qos_attr.qos_flow_id = tmp___1;
  tmp___2 = __fswab32(qos_scn->new_qos_attr.qos_flow_id);
  qos_scn->new_qos_attr.qos_flow_id = tmp___2;
  if (qos_scn->old_qos_attr.qos_flow_id != qos_scn->new_qos_attr.qos_flow_id) {
    bfa_cb_rport_qos_scn_flowid(rp->rport_drv, qos_scn->old_qos_attr, qos_scn->new_qos_attr);
  } else {

  }
  if ((int )qos_scn->old_qos_attr.qos_priority != (int )qos_scn->new_qos_attr.qos_priority) {
    bfa_cb_rport_qos_scn_prio(rp->rport_drv, qos_scn->old_qos_attr, qos_scn->new_qos_attr);
  } else {

  }
  goto ldv_49969;
  default: 
  rp->stats.sm_on_unexp = rp->stats.sm_on_unexp + 1U;
  __bfa_trc((rp->bfa)->trcmod, __trc_fileno___13, 4593, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_svc.c",
         4593, (unsigned int )event);
  }
  ldv_49969: ;
  return;
}
}
static void bfa_rport_sm_fwdelete(struct bfa_rport_s *rp , enum bfa_rport_event event ) 
{ 


  {
  __bfa_trc((rp->bfa)->trcmod, __trc_fileno___13, 4603, (unsigned long long )rp->rport_tag);
  __bfa_trc((rp->bfa)->trcmod, __trc_fileno___13, 4604, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 5U: 
  rp->stats.sm_fwd_rsp = rp->stats.sm_fwd_rsp + 1U;
  rp->sm = (void (*)(void * , int  ))(& bfa_rport_sm_offline);
  if ((unsigned int )(rp->bfa)->fcs != 0U) {
    bfa_cb_rport_offline(rp->rport_drv);
  } else {
    rp->hcb_qe.cbfn = & __bfa_cb_rport_offline;
    rp->hcb_qe.cbarg = (void *)rp;
    rp->hcb_qe.pre_rmv = 0;
    list_add_tail(& rp->hcb_qe.qe, & (rp->bfa)->comp_q);
  }
  goto ldv_49980;
  case 2U: 
  rp->stats.sm_fwd_del = rp->stats.sm_fwd_del + 1U;
  rp->sm = (void (*)(void * , int  ))(& bfa_rport_sm_deleting);
  goto ldv_49980;
  case 6U: 
  rp->stats.sm_fwd_hwf = rp->stats.sm_fwd_hwf + 1U;
  rp->sm = (void (*)(void * , int  ))(& bfa_rport_sm_iocdisable);
  if ((unsigned int )(rp->bfa)->fcs != 0U) {
    bfa_cb_rport_offline(rp->rport_drv);
  } else {
    rp->hcb_qe.cbfn = & __bfa_cb_rport_offline;
    rp->hcb_qe.cbarg = (void *)rp;
    rp->hcb_qe.pre_rmv = 0;
    list_add_tail(& rp->hcb_qe.qe, & (rp->bfa)->comp_q);
  }
  goto ldv_49980;
  default: 
  rp->stats.sm_fwd_unexp = rp->stats.sm_fwd_unexp + 1U;
  __bfa_trc((rp->bfa)->trcmod, __trc_fileno___13, 4626, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_svc.c",
         4626, (unsigned int )event);
  }
  ldv_49980: ;
  return;
}
}
static void bfa_rport_sm_fwdelete_qfull(struct bfa_rport_s *rp , enum bfa_rport_event event ) 
{ 


  {
  __bfa_trc((rp->bfa)->trcmod, __trc_fileno___13, 4633, (unsigned long long )rp->rport_tag);
  __bfa_trc((rp->bfa)->trcmod, __trc_fileno___13, 4634, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 9U: 
  rp->sm = (void (*)(void * , int  ))(& bfa_rport_sm_fwdelete);
  bfa_rport_send_fwdelete(rp);
  goto ldv_49989;
  case 2U: 
  rp->stats.sm_fwd_del = rp->stats.sm_fwd_del + 1U;
  rp->sm = (void (*)(void * , int  ))(& bfa_rport_sm_deleting_qfull);
  goto ldv_49989;
  case 6U: 
  rp->stats.sm_fwd_hwf = rp->stats.sm_fwd_hwf + 1U;
  rp->sm = (void (*)(void * , int  ))(& bfa_rport_sm_iocdisable);
  list_del(& rp->reqq_wait.qe);
  if ((unsigned int )(rp->bfa)->fcs != 0U) {
    bfa_cb_rport_offline(rp->rport_drv);
  } else {
    rp->hcb_qe.cbfn = & __bfa_cb_rport_offline;
    rp->hcb_qe.cbarg = (void *)rp;
    rp->hcb_qe.pre_rmv = 0;
    list_add_tail(& rp->hcb_qe.qe, & (rp->bfa)->comp_q);
  }
  goto ldv_49989;
  default: 
  rp->stats.sm_fwd_unexp = rp->stats.sm_fwd_unexp + 1U;
  __bfa_trc((rp->bfa)->trcmod, __trc_fileno___13, 4656, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_svc.c",
         4656, (unsigned int )event);
  }
  ldv_49989: ;
  return;
}
}
static void bfa_rport_sm_offline(struct bfa_rport_s *rp , enum bfa_rport_event event ) 
{ 
  enum bfa_boolean tmp ;

  {
  __bfa_trc((rp->bfa)->trcmod, __trc_fileno___13, 4666, (unsigned long long )rp->rport_tag);
  __bfa_trc((rp->bfa)->trcmod, __trc_fileno___13, 4667, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 2U: 
  rp->stats.sm_off_del = rp->stats.sm_off_del + 1U;
  rp->sm = (void (*)(void * , int  ))(& bfa_rport_sm_uninit);
  bfa_rport_free(rp);
  goto ldv_49998;
  case 3U: 
  rp->stats.sm_off_on = rp->stats.sm_off_on + 1U;
  tmp = bfa_rport_send_fwcreate(rp);
  if ((unsigned int )tmp != 0U) {
    rp->sm = (void (*)(void * , int  ))(& bfa_rport_sm_fwcreate);
  } else {
    rp->sm = (void (*)(void * , int  ))(& bfa_rport_sm_fwcreate_qfull);
  }
  goto ldv_49998;
  case 6U: 
  rp->stats.sm_off_hwf = rp->stats.sm_off_hwf + 1U;
  rp->sm = (void (*)(void * , int  ))(& bfa_rport_sm_iocdisable);
  goto ldv_49998;
  case 4U: ;
  if ((unsigned int )(rp->bfa)->fcs != 0U) {
    bfa_cb_rport_offline(rp->rport_drv);
  } else {
    rp->hcb_qe.cbfn = & __bfa_cb_rport_offline;
    rp->hcb_qe.cbarg = (void *)rp;
    rp->hcb_qe.pre_rmv = 0;
    list_add_tail(& rp->hcb_qe.qe, & (rp->bfa)->comp_q);
  }
  goto ldv_49998;
  default: 
  rp->stats.sm_off_unexp = rp->stats.sm_off_unexp + 1U;
  __bfa_trc((rp->bfa)->trcmod, __trc_fileno___13, 4695, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_svc.c",
         4695, (unsigned int )event);
  }
  ldv_49998: ;
  return;
}
}
static void bfa_rport_sm_deleting(struct bfa_rport_s *rp , enum bfa_rport_event event ) 
{ 


  {
  __bfa_trc((rp->bfa)->trcmod, __trc_fileno___13, 4705, (unsigned long long )rp->rport_tag);
  __bfa_trc((rp->bfa)->trcmod, __trc_fileno___13, 4706, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 5U: 
  rp->stats.sm_del_fwrsp = rp->stats.sm_del_fwrsp + 1U;
  rp->sm = (void (*)(void * , int  ))(& bfa_rport_sm_uninit);
  bfa_rport_free(rp);
  goto ldv_50008;
  case 6U: 
  rp->stats.sm_del_hwf = rp->stats.sm_del_hwf + 1U;
  rp->sm = (void (*)(void * , int  ))(& bfa_rport_sm_uninit);
  bfa_rport_free(rp);
  goto ldv_50008;
  default: 
  __bfa_trc((rp->bfa)->trcmod, __trc_fileno___13, 4722, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_svc.c",
         4722, (unsigned int )event);
  }
  ldv_50008: ;
  return;
}
}
static void bfa_rport_sm_deleting_qfull(struct bfa_rport_s *rp , enum bfa_rport_event event ) 
{ 


  {
  __bfa_trc((rp->bfa)->trcmod, __trc_fileno___13, 4729, (unsigned long long )rp->rport_tag);
  __bfa_trc((rp->bfa)->trcmod, __trc_fileno___13, 4730, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 9U: 
  rp->stats.sm_del_fwrsp = rp->stats.sm_del_fwrsp + 1U;
  rp->sm = (void (*)(void * , int  ))(& bfa_rport_sm_deleting);
  bfa_rport_send_fwdelete(rp);
  goto ldv_50016;
  case 6U: 
  rp->stats.sm_del_hwf = rp->stats.sm_del_hwf + 1U;
  rp->sm = (void (*)(void * , int  ))(& bfa_rport_sm_uninit);
  list_del(& rp->reqq_wait.qe);
  bfa_rport_free(rp);
  goto ldv_50016;
  default: 
  __bfa_trc((rp->bfa)->trcmod, __trc_fileno___13, 4747, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_svc.c",
         4747, (unsigned int )event);
  }
  ldv_50016: ;
  return;
}
}
static void bfa_rport_sm_delete_pending(struct bfa_rport_s *rp , enum bfa_rport_event event ) 
{ 
  enum bfa_boolean tmp ;

  {
  __bfa_trc((rp->bfa)->trcmod, __trc_fileno___13, 4758, (unsigned long long )rp->rport_tag);
  __bfa_trc((rp->bfa)->trcmod, __trc_fileno___13, 4759, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 5U: 
  rp->stats.sm_delp_fwrsp = rp->stats.sm_delp_fwrsp + 1U;
  tmp = bfa_rport_send_fwdelete(rp);
  if ((unsigned int )tmp != 0U) {
    rp->sm = (void (*)(void * , int  ))(& bfa_rport_sm_deleting);
  } else {
    rp->sm = (void (*)(void * , int  ))(& bfa_rport_sm_deleting_qfull);
  }
  goto ldv_50024;
  case 6U: 
  rp->stats.sm_delp_hwf = rp->stats.sm_delp_hwf + 1U;
  rp->sm = (void (*)(void * , int  ))(& bfa_rport_sm_uninit);
  bfa_rport_free(rp);
  goto ldv_50024;
  default: 
  rp->stats.sm_delp_unexp = rp->stats.sm_delp_unexp + 1U;
  __bfa_trc((rp->bfa)->trcmod, __trc_fileno___13, 4778, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_svc.c",
         4778, (unsigned int )event);
  }
  ldv_50024: ;
  return;
}
}
static void bfa_rport_sm_offline_pending(struct bfa_rport_s *rp , enum bfa_rport_event event ) 
{ 
  enum bfa_boolean tmp ;

  {
  __bfa_trc((rp->bfa)->trcmod, __trc_fileno___13, 4789, (unsigned long long )rp->rport_tag);
  __bfa_trc((rp->bfa)->trcmod, __trc_fileno___13, 4790, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 5U: 
  rp->stats.sm_offp_fwrsp = rp->stats.sm_offp_fwrsp + 1U;
  tmp = bfa_rport_send_fwdelete(rp);
  if ((unsigned int )tmp != 0U) {
    rp->sm = (void (*)(void * , int  ))(& bfa_rport_sm_fwdelete);
  } else {
    rp->sm = (void (*)(void * , int  ))(& bfa_rport_sm_fwdelete_qfull);
  }
  goto ldv_50032;
  case 2U: 
  rp->stats.sm_offp_del = rp->stats.sm_offp_del + 1U;
  rp->sm = (void (*)(void * , int  ))(& bfa_rport_sm_delete_pending);
  goto ldv_50032;
  case 6U: 
  rp->stats.sm_offp_hwf = rp->stats.sm_offp_hwf + 1U;
  rp->sm = (void (*)(void * , int  ))(& bfa_rport_sm_iocdisable);
  if ((unsigned int )(rp->bfa)->fcs != 0U) {
    bfa_cb_rport_offline(rp->rport_drv);
  } else {
    rp->hcb_qe.cbfn = & __bfa_cb_rport_offline;
    rp->hcb_qe.cbarg = (void *)rp;
    rp->hcb_qe.pre_rmv = 0;
    list_add_tail(& rp->hcb_qe.qe, & (rp->bfa)->comp_q);
  }
  goto ldv_50032;
  default: 
  rp->stats.sm_offp_unexp = rp->stats.sm_offp_unexp + 1U;
  __bfa_trc((rp->bfa)->trcmod, __trc_fileno___13, 4814, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_svc.c",
         4814, (unsigned int )event);
  }
  ldv_50032: ;
  return;
}
}
static void bfa_rport_sm_iocdisable(struct bfa_rport_s *rp , enum bfa_rport_event event ) 
{ 
  enum bfa_boolean tmp ;

  {
  __bfa_trc((rp->bfa)->trcmod, __trc_fileno___13, 4824, (unsigned long long )rp->rport_tag);
  __bfa_trc((rp->bfa)->trcmod, __trc_fileno___13, 4825, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 4U: 
  rp->stats.sm_iocd_off = rp->stats.sm_iocd_off + 1U;
  if ((unsigned int )(rp->bfa)->fcs != 0U) {
    bfa_cb_rport_offline(rp->rport_drv);
  } else {
    rp->hcb_qe.cbfn = & __bfa_cb_rport_offline;
    rp->hcb_qe.cbarg = (void *)rp;
    rp->hcb_qe.pre_rmv = 0;
    list_add_tail(& rp->hcb_qe.qe, & (rp->bfa)->comp_q);
  }
  goto ldv_50041;
  case 2U: 
  rp->stats.sm_iocd_del = rp->stats.sm_iocd_del + 1U;
  rp->sm = (void (*)(void * , int  ))(& bfa_rport_sm_uninit);
  bfa_rport_free(rp);
  goto ldv_50041;
  case 3U: 
  rp->stats.sm_iocd_on = rp->stats.sm_iocd_on + 1U;
  tmp = bfa_rport_send_fwcreate(rp);
  if ((unsigned int )tmp != 0U) {
    rp->sm = (void (*)(void * , int  ))(& bfa_rport_sm_fwcreate);
  } else {
    rp->sm = (void (*)(void * , int  ))(& bfa_rport_sm_fwcreate_qfull);
  }
  goto ldv_50041;
  case 6U: ;
  goto ldv_50041;
  default: 
  rp->stats.sm_iocd_unexp = rp->stats.sm_iocd_unexp + 1U;
  __bfa_trc((rp->bfa)->trcmod, __trc_fileno___13, 4852, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_svc.c",
         4852, (unsigned int )event);
  }
  ldv_50041: ;
  return;
}
}
static void __bfa_cb_rport_online(void *cbarg , enum bfa_boolean complete___0 ) 
{ 
  struct bfa_rport_s *rp ;

  {
  rp = (struct bfa_rport_s *)cbarg;
  if ((unsigned int )complete___0 != 0U) {
    bfa_cb_rport_online(rp->rport_drv);
  } else {

  }
  return;
}
}
static void __bfa_cb_rport_offline(void *cbarg , enum bfa_boolean complete___0 ) 
{ 
  struct bfa_rport_s *rp ;

  {
  rp = (struct bfa_rport_s *)cbarg;
  if ((unsigned int )complete___0 != 0U) {
    bfa_cb_rport_offline(rp->rport_drv);
  } else {

  }
  return;
}
}
static void bfa_rport_qresume(void *cbarg ) 
{ 
  struct bfa_rport_s *rp ;

  {
  rp = (struct bfa_rport_s *)cbarg;
  (*(rp->sm))((void *)rp, 9);
  return;
}
}
static void bfa_rport_meminfo(struct bfa_iocfc_cfg_s *cfg , struct bfa_meminfo_s *minfo ,
                              struct bfa_s *bfa ) 
{ 
  struct bfa_mem_kva_s *rport_kva ;

  {
  rport_kva = & bfa->modules.rport_mod.kva_seg;
  if ((unsigned int )cfg->fwcfg.num_rports <= 3U) {
    cfg->fwcfg.num_rports = 4U;
  } else {

  }
  rport_kva->mem_len = (u32 )cfg->fwcfg.num_rports * 320U;
  if ((unsigned long )cfg->fwcfg.num_rports * 320UL != 0UL) {
    list_add_tail(& rport_kva->qe, & minfo->kva_info.qe);
  } else {

  }
  return;
}
}
static void bfa_rport_attach(struct bfa_s *bfa , void *bfad , struct bfa_iocfc_cfg_s *cfg ,
                             struct bfa_pcidev_s *pcidev ) 
{ 
  struct bfa_rport_mod_s *mod ;
  struct bfa_rport_s *rp ;
  u16 i ;
  int __ret_warn_on ;
  long tmp ;

  {
  mod = & bfa->modules.rport_mod;
  INIT_LIST_HEAD(& mod->rp_free_q);
  INIT_LIST_HEAD(& mod->rp_active_q);
  INIT_LIST_HEAD(& mod->rp_unused_q);
  rp = (struct bfa_rport_s *)mod->kva_seg.kva_curp;
  mod->rps_list = rp;
  mod->num_rports = cfg->fwcfg.num_rports;
  __ret_warn_on = (unsigned int )mod->num_rports == 0U || ((int )mod->num_rports & ((int )mod->num_rports + -1)) != 0;
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_svc.c",
                       4919);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  i = 0U;
  goto ldv_50078;
  ldv_50077: 
  memset((void *)rp, 0, 320UL);
  rp->bfa = bfa;
  rp->rport_tag = i;
  rp->sm = (void (*)(void * , int  ))(& bfa_rport_sm_uninit);
  if ((unsigned int )i != 0U) {
    list_add_tail(& rp->qe, & mod->rp_free_q);
  } else {

  }
  bfa_reqq_winit(& rp->reqq_wait, & bfa_rport_qresume, (void *)rp);
  i = (u16 )((int )i + 1);
  rp = rp + 1;
  ldv_50078: ;
  if ((int )mod->num_rports > (int )i) {
    goto ldv_50077;
  } else {

  }
  mod->kva_seg.kva_curp = (u8 *)rp;
  return;
}
}
static void bfa_rport_detach(struct bfa_s *bfa ) 
{ 


  {
  return;
}
}
static void bfa_rport_start(struct bfa_s *bfa ) 
{ 


  {
  return;
}
}
static void bfa_rport_stop(struct bfa_s *bfa ) 
{ 


  {
  return;
}
}
static void bfa_rport_iocdisable(struct bfa_s *bfa ) 
{ 
  struct bfa_rport_mod_s *mod ;
  struct bfa_rport_s *rport ;
  struct list_head *qe ;
  struct list_head *qen ;

  {
  mod = & bfa->modules.rport_mod;
  list_splice_tail_init(& mod->rp_unused_q, & mod->rp_free_q);
  qe = mod->rp_active_q.next;
  qen = qe->next;
  goto ldv_50097;
  ldv_50096: 
  rport = (struct bfa_rport_s *)qe;
  (*(rport->sm))((void *)rport, 6);
  qe = qen;
  qen = qe->next;
  ldv_50097: ;
  if ((unsigned long )(& mod->rp_active_q) != (unsigned long )qe) {
    goto ldv_50096;
  } else {

  }

  return;
}
}
static struct bfa_rport_s *bfa_rport_alloc(struct bfa_rport_mod_s *mod ) 
{ 
  struct bfa_rport_s *rport ;
  int tmp ;

  {
  tmp = list_empty((struct list_head  const  *)(& mod->rp_free_q));
  if (tmp == 0) {
    *((struct list_head **)(& rport)) = mod->rp_free_q.next;
    ((*((struct list_head **)(& rport)))->next)->prev = & mod->rp_free_q;
    mod->rp_free_q.next = (*((struct list_head **)(& rport)))->next;
  } else {
    *((struct list_head **)(& rport)) = (struct list_head *)0;
  }
  if ((unsigned long )rport != (unsigned long )((struct bfa_rport_s *)0)) {
    list_add_tail(& rport->qe, & mod->rp_active_q);
  } else {

  }
  return (rport);
}
}
static void bfa_rport_free(struct bfa_rport_s *rport ) 
{ 
  struct bfa_rport_mod_s *mod ;
  int __ret_warn_on ;
  int tmp ;
  long tmp___0 ;

  {
  mod = & (rport->bfa)->modules.rport_mod;
  tmp = bfa_q_is_on_q_func(& mod->rp_active_q, (struct list_head *)rport);
  __ret_warn_on = tmp == 0;
  tmp___0 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp___0 != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_svc.c",
                       4990);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  list_del(& rport->qe);
  list_add_tail(& rport->qe, & mod->rp_free_q);
  return;
}
}
static enum bfa_boolean bfa_rport_send_fwcreate(struct bfa_rport_s *rp ) 
{ 
  struct bfi_rport_create_req_s *m ;
  struct list_head *waitq ;
  int __ret_warn_on ;
  long tmp ;
  int __ret_warn_on___0 ;
  long tmp___0 ;
  __u16 tmp___1 ;

  {
  m = (((rp->bfa)->iocfc.req_cq_pi[0] + 1U) & (u32 )((int )(rp->bfa)->iocfc.cfg.drvcfg.num_reqq_elems + -1)) != *((u32 *)(rp->bfa)->iocfc.req_cq_shadow_ci[0].kva) ? (struct bfi_rport_create_req_s *)(rp->bfa)->iocfc.req_cq_ba[0].kva + (unsigned long )(rp->bfa)->iocfc.req_cq_pi[0] : (struct bfi_rport_create_req_s *)0;
  if ((unsigned long )m == (unsigned long )((struct bfi_rport_create_req_s *)0)) {
    waitq = (struct list_head *)(& (rp->bfa)->reqq_waitq);
    __ret_warn_on = 0;
    tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
    if (tmp != 0L) {
      warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_svc.c",
                         5005);
    } else {

    }
    ldv__builtin_expect(__ret_warn_on != 0, 0L);
    __ret_warn_on___0 = (unsigned long )rp->reqq_wait.qresume == (unsigned long )((void (*)(void * ))0) || (unsigned long )rp->reqq_wait.cbarg == (unsigned long )((void *)0);
    tmp___0 = ldv__builtin_expect(__ret_warn_on___0 != 0, 0L);
    if (tmp___0 != 0L) {
      warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_svc.c",
                         5005);
    } else {

    }
    ldv__builtin_expect(__ret_warn_on___0 != 0, 0L);
    list_add_tail(& rp->reqq_wait.qe, waitq);
    return (0);
  } else {

  }
  m->mh.msg_class = 11U;
  m->mh.msg_id = 1U;
  m->mh.mtag.h2i.fn_lpu = (u8 )((int )((signed char )((int )(rp->bfa)->ioc.pcidev.pci_func << 1)) | (int )((signed char )(rp->bfa)->ioc.port_id));
  m->bfa_handle = rp->rport_tag;
  tmp___1 = __fswab16((int )rp->rport_info.max_frmsz);
  m->max_frmsz = tmp___1;
  m->pid = rp->rport_info.pid;
  m->lp_fwtag = bfa_lps_get_fwtag(rp->bfa, (int )rp->rport_info.lp_tag);
  m->local_pid = rp->rport_info.local_pid;
  m->fc_class = rp->rport_info.fc_class;
  m->vf_en = rp->rport_info.vf_en;
  m->vf_id = rp->rport_info.vf_id;
  m->cisc = rp->rport_info.cisc;
  m->mh.mtag.h2i.qid = (rp->bfa)->iocfc.hw_qid[0];
  (rp->bfa)->iocfc.req_cq_pi[0] = (rp->bfa)->iocfc.req_cq_pi[0] + 1U;
  (rp->bfa)->iocfc.req_cq_pi[0] = (rp->bfa)->iocfc.req_cq_pi[0] & (u32 )((int )(rp->bfa)->iocfc.cfg.drvcfg.num_reqq_elems + -1);
  writel((rp->bfa)->iocfc.req_cq_pi[0], (void volatile   *)(rp->bfa)->iocfc.bfa_regs.cpe_q_pi[0]);
  __asm__  volatile   ("": : : "memory");
  return (1);
}
}
static enum bfa_boolean bfa_rport_send_fwdelete(struct bfa_rport_s *rp ) 
{ 
  struct bfi_rport_delete_req_s *m ;
  struct list_head *waitq ;
  int __ret_warn_on ;
  long tmp ;
  int __ret_warn_on___0 ;
  long tmp___0 ;

  {
  m = (((rp->bfa)->iocfc.req_cq_pi[0] + 1U) & (u32 )((int )(rp->bfa)->iocfc.cfg.drvcfg.num_reqq_elems + -1)) != *((u32 *)(rp->bfa)->iocfc.req_cq_shadow_ci[0].kva) ? (struct bfi_rport_delete_req_s *)(rp->bfa)->iocfc.req_cq_ba[0].kva + (unsigned long )(rp->bfa)->iocfc.req_cq_pi[0] : (struct bfi_rport_delete_req_s *)0;
  if ((unsigned long )m == (unsigned long )((struct bfi_rport_delete_req_s *)0)) {
    waitq = (struct list_head *)(& (rp->bfa)->reqq_waitq);
    __ret_warn_on = 0;
    tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
    if (tmp != 0L) {
      warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_svc.c",
                         5038);
    } else {

    }
    ldv__builtin_expect(__ret_warn_on != 0, 0L);
    __ret_warn_on___0 = (unsigned long )rp->reqq_wait.qresume == (unsigned long )((void (*)(void * ))0) || (unsigned long )rp->reqq_wait.cbarg == (unsigned long )((void *)0);
    tmp___0 = ldv__builtin_expect(__ret_warn_on___0 != 0, 0L);
    if (tmp___0 != 0L) {
      warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_svc.c",
                         5038);
    } else {

    }
    ldv__builtin_expect(__ret_warn_on___0 != 0, 0L);
    list_add_tail(& rp->reqq_wait.qe, waitq);
    return (0);
  } else {

  }
  m->mh.msg_class = 11U;
  m->mh.msg_id = 2U;
  m->mh.mtag.h2i.fn_lpu = (u8 )((int )((signed char )((int )(rp->bfa)->ioc.pcidev.pci_func << 1)) | (int )((signed char )(rp->bfa)->ioc.port_id));
  m->fw_handle = rp->fw_handle;
  m->mh.mtag.h2i.qid = (rp->bfa)->iocfc.hw_qid[0];
  (rp->bfa)->iocfc.req_cq_pi[0] = (rp->bfa)->iocfc.req_cq_pi[0] + 1U;
  (rp->bfa)->iocfc.req_cq_pi[0] = (rp->bfa)->iocfc.req_cq_pi[0] & (u32 )((int )(rp->bfa)->iocfc.cfg.drvcfg.num_reqq_elems + -1);
  writel((rp->bfa)->iocfc.req_cq_pi[0], (void volatile   *)(rp->bfa)->iocfc.bfa_regs.cpe_q_pi[0]);
  __asm__  volatile   ("": : : "memory");
  return (1);
}
}
static enum bfa_boolean bfa_rport_send_fwspeed(struct bfa_rport_s *rp ) 
{ 
  struct bfa_rport_speed_req_s *m ;

  {
  m = (((rp->bfa)->iocfc.req_cq_pi[0] + 1U) & (u32 )((int )(rp->bfa)->iocfc.cfg.drvcfg.num_reqq_elems + -1)) != *((u32 *)(rp->bfa)->iocfc.req_cq_shadow_ci[0].kva) ? (struct bfa_rport_speed_req_s *)(rp->bfa)->iocfc.req_cq_ba[0].kva + (unsigned long )(rp->bfa)->iocfc.req_cq_pi[0] : (struct bfa_rport_speed_req_s *)0;
  if ((unsigned long )m == (unsigned long )((struct bfa_rport_speed_req_s *)0)) {
    __bfa_trc((rp->bfa)->trcmod, __trc_fileno___13, 5063, (unsigned long long )rp->rport_info.speed);
    return (0);
  } else {

  }
  m->mh.msg_class = 11U;
  m->mh.msg_id = 3U;
  m->mh.mtag.h2i.fn_lpu = (u8 )((int )((signed char )((int )(rp->bfa)->ioc.pcidev.pci_func << 1)) | (int )((signed char )(rp->bfa)->ioc.port_id));
  m->fw_handle = rp->fw_handle;
  m->speed = (unsigned char )rp->rport_info.speed;
  m->mh.mtag.h2i.qid = (rp->bfa)->iocfc.hw_qid[0];
  (rp->bfa)->iocfc.req_cq_pi[0] = (rp->bfa)->iocfc.req_cq_pi[0] + 1U;
  (rp->bfa)->iocfc.req_cq_pi[0] = (rp->bfa)->iocfc.req_cq_pi[0] & (u32 )((int )(rp->bfa)->iocfc.cfg.drvcfg.num_reqq_elems + -1);
  writel((rp->bfa)->iocfc.req_cq_pi[0], (void volatile   *)(rp->bfa)->iocfc.bfa_regs.cpe_q_pi[0]);
  __asm__  volatile   ("": : : "memory");
  return (1);
}
}
void bfa_rport_isr(struct bfa_s *bfa , struct bfi_msg_s *m ) 
{ 
  union bfi_rport_i2h_msg_u msg ;
  struct bfa_rport_s *rp ;
  int __ret_warn_on ;
  long tmp ;
  int __ret_warn_on___0 ;
  long tmp___0 ;
  int __ret_warn_on___1 ;
  long tmp___1 ;

  {
  __bfa_trc(bfa->trcmod, __trc_fileno___13, 5094, (unsigned long long )m->mhdr.msg_id);
  msg.msg = m;
  switch ((int )m->mhdr.msg_id) {
  case 129: 
  rp = bfa->modules.rport_mod.rps_list + (unsigned long )((int )(msg.create_rsp)->bfa_handle & ((int )bfa->modules.rport_mod.num_rports + -1));
  rp->fw_handle = (msg.create_rsp)->fw_handle;
  rp->qos_attr = (msg.create_rsp)->qos_attr;
  bfa_rport_set_lunmask(bfa, rp);
  __ret_warn_on = (unsigned int )(msg.create_rsp)->status != 0U;
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_svc.c",
                       5104);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  (*(rp->sm))((void *)rp, 5);
  goto ldv_50140;
  case 130: 
  rp = bfa->modules.rport_mod.rps_list + (unsigned long )((int )(msg.delete_rsp)->bfa_handle & ((int )bfa->modules.rport_mod.num_rports + -1));
  __ret_warn_on___0 = (unsigned int )(msg.delete_rsp)->status != 0U;
  tmp___0 = ldv__builtin_expect(__ret_warn_on___0 != 0, 0L);
  if (tmp___0 != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_svc.c",
                       5110);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on___0 != 0, 0L);
  bfa_rport_unset_lunmask(bfa, rp);
  (*(rp->sm))((void *)rp, 5);
  goto ldv_50140;
  case 131: 
  rp = bfa->modules.rport_mod.rps_list + (unsigned long )((int )(msg.qos_scn_evt)->bfa_handle & ((int )bfa->modules.rport_mod.num_rports + -1));
  rp->event_arg.fw_msg = (void *)msg.qos_scn_evt;
  (*(rp->sm))((void *)rp, 7);
  goto ldv_50140;
  case 132: 
  bfa_fcport_update_loop_info(& bfa->modules.fcport, & (msg.lip_scn)->loop_info);
  bfa_cb_rport_scn_online(bfa);
  goto ldv_50140;
  case 133: 
  bfa_cb_rport_scn_offline(bfa);
  goto ldv_50140;
  case 134: 
  rp = bfa->modules.rport_mod.rps_list + (unsigned long )((int )(msg.lip_scn)->bfa_handle & ((int )bfa->modules.rport_mod.num_rports + -1));
  bfa_cb_rport_scn_no_dev(rp->rport_drv);
  goto ldv_50140;
  default: 
  __bfa_trc(bfa->trcmod, __trc_fileno___13, 5137, (unsigned long long )m->mhdr.msg_id);
  __ret_warn_on___1 = 1;
  tmp___1 = ldv__builtin_expect(__ret_warn_on___1 != 0, 0L);
  if (tmp___1 != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_svc.c",
                       5138);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on___1 != 0, 0L);
  }
  ldv_50140: ;
  return;
}
}
void bfa_rport_res_recfg(struct bfa_s *bfa , u16 num_rport_fw ) 
{ 
  struct bfa_rport_mod_s *mod ;
  struct list_head *qe ;
  int i ;
  int tmp ;

  {
  mod = & bfa->modules.rport_mod;
  i = 0;
  goto ldv_50159;
  ldv_50158: 
  tmp = list_empty((struct list_head  const  *)(& mod->rp_free_q));
  if (tmp == 0) {
    qe = mod->rp_free_q.prev;
    (qe->prev)->next = & mod->rp_free_q;
    mod->rp_free_q.prev = qe->prev;
  } else {
    qe = (struct list_head *)0;
  }
  list_add_tail(qe, & mod->rp_unused_q);
  i = i + 1;
  ldv_50159: ;
  if ((int )mod->num_rports - (int )num_rport_fw > i) {
    goto ldv_50158;
  } else {

  }

  return;
}
}
struct bfa_rport_s *bfa_rport_create(struct bfa_s *bfa , void *rport_drv ) 
{ 
  struct bfa_rport_s *rp ;
  int __ret_warn_on ;
  long tmp ;

  {
  rp = bfa_rport_alloc(& bfa->modules.rport_mod);
  if ((unsigned long )rp == (unsigned long )((struct bfa_rport_s *)0)) {
    return ((struct bfa_rport_s *)0);
  } else {

  }
  rp->bfa = bfa;
  rp->rport_drv = rport_drv;
  memset((void *)(& rp->stats), 0, 152UL);
  __ret_warn_on = (unsigned long )rp->sm != (unsigned long )((void (*)(void * , int  ))(& bfa_rport_sm_uninit));
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_svc.c",
                       5173);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  (*(rp->sm))((void *)rp, 1);
  return (rp);
}
}
void bfa_rport_online(struct bfa_rport_s *rport , struct bfa_rport_info_s *rport_info ) 
{ 
  int __ret_warn_on ;
  long tmp ;

  {
  __ret_warn_on = (unsigned int )rport_info->max_frmsz == 0U;
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_svc.c",
                       5182);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if ((unsigned int )rport_info->max_frmsz == 0U) {
    __bfa_trc((rport->bfa)->trcmod, __trc_fileno___13, 5189, (unsigned long long )rport->rport_tag);
    rport_info->max_frmsz = 512U;
  } else {

  }
  rport->rport_info = *rport_info;
  (*(rport->sm))((void *)rport, 3);
  return;
}
}
void bfa_rport_speed(struct bfa_rport_s *rport , enum bfa_port_speed speed ) 
{ 
  int __ret_warn_on ;
  long tmp ;
  int __ret_warn_on___0 ;
  long tmp___0 ;

  {
  __ret_warn_on = (unsigned int )speed == 0U;
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_svc.c",
                       5200);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  __ret_warn_on___0 = (unsigned int )speed == 15U;
  tmp___0 = ldv__builtin_expect(__ret_warn_on___0 != 0, 0L);
  if (tmp___0 != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_svc.c",
                       5201);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on___0 != 0, 0L);
  if ((unsigned long )rport != (unsigned long )((struct bfa_rport_s *)0)) {
    rport->rport_info.speed = speed;
    (*(rport->sm))((void *)rport, 8);
  } else {

  }
  return;
}
}
void bfa_rport_set_lunmask(struct bfa_s *bfa , struct bfa_rport_s *rp ) 
{ 
  struct bfa_lps_mod_s *lps_mod ;
  wwn_t lp_wwn ;
  wwn_t rp_wwn ;
  u8 lp_tag ;
  u8 tmp ;

  {
  lps_mod = & bfa->modules.lps_mod;
  lp_tag = rp->rport_info.lp_tag;
  rp_wwn = ((struct bfa_fcs_rport_s *)rp->rport_drv)->pwwn;
  lp_wwn = (lps_mod->lps_arr + (unsigned long )rp->rport_info.lp_tag)->pwwn;
  tmp = 1U;
  rp->lun_mask = tmp;
  (lps_mod->lps_arr + (unsigned long )rp->rport_info.lp_tag)->lun_mask = tmp;
  bfa_fcpim_lunmask_rp_update(bfa, lp_wwn, rp_wwn, (int )rp->rport_tag, (int )lp_tag);
  return;
}
}
void bfa_rport_unset_lunmask(struct bfa_s *bfa , struct bfa_rport_s *rp ) 
{ 
  struct bfa_lps_mod_s *lps_mod ;
  wwn_t lp_wwn ;
  wwn_t rp_wwn ;
  u8 tmp ;

  {
  lps_mod = & bfa->modules.lps_mod;
  rp_wwn = ((struct bfa_fcs_rport_s *)rp->rport_drv)->pwwn;
  lp_wwn = (lps_mod->lps_arr + (unsigned long )rp->rport_info.lp_tag)->pwwn;
  tmp = 0U;
  rp->lun_mask = tmp;
  (lps_mod->lps_arr + (unsigned long )rp->rport_info.lp_tag)->lun_mask = tmp;
  bfa_fcpim_lunmask_rp_update(bfa, lp_wwn, rp_wwn, 65535, 255);
  return;
}
}
static void bfa_sgpg_meminfo(struct bfa_iocfc_cfg_s *cfg , struct bfa_meminfo_s *minfo ,
                             struct bfa_s *bfa ) 
{ 
  struct bfa_sgpg_mod_s *sgpg_mod ;
  struct bfa_mem_kva_s *sgpg_kva ;
  struct bfa_mem_dma_s *seg_ptr ;
  u16 nsegs ;
  u16 idx ;
  u16 per_seg_sgpg ;
  u16 num_sgpg ;
  u32 sgpg_sz ;

  {
  sgpg_mod = & bfa->modules.sgpg_mod;
  sgpg_kva = & bfa->modules.sgpg_mod.kva_seg;
  sgpg_sz = 128U;
  if ((unsigned int )cfg->drvcfg.num_sgpgs <= 15U) {
    cfg->drvcfg.num_sgpgs = 16U;
  } else
  if ((unsigned int )cfg->drvcfg.num_sgpgs > 8192U) {
    cfg->drvcfg.num_sgpgs = 8192U;
  } else {

  }
  num_sgpg = cfg->drvcfg.num_sgpgs;
  nsegs = (unsigned short )((((u32 )num_sgpg * sgpg_sz + 131071U) & 4294836224U) / 131072U);
  per_seg_sgpg = (u16 )(131072U / sgpg_sz);
  idx = 0U;
  seg_ptr = (struct bfa_mem_dma_s *)(& sgpg_mod->dma_seg) + (unsigned long )idx;
  goto ldv_50211;
  ldv_50210: ;
  if ((int )num_sgpg >= (int )per_seg_sgpg) {
    num_sgpg = (int )num_sgpg - (int )per_seg_sgpg;
    seg_ptr->mem_len = (u32 )per_seg_sgpg * sgpg_sz;
    if ((u32 )per_seg_sgpg * sgpg_sz != 0U) {
      list_add_tail(& seg_ptr->qe, & minfo->dma_info.qe);
    } else {

    }
  } else {
    seg_ptr->mem_len = (u32 )num_sgpg * sgpg_sz;
    if ((u32 )num_sgpg * sgpg_sz != 0U) {
      list_add_tail(& seg_ptr->qe, & minfo->dma_info.qe);
    } else {

    }
  }
  idx = (u16 )((int )idx + 1);
  seg_ptr = (struct bfa_mem_dma_s *)(& sgpg_mod->dma_seg) + (unsigned long )idx;
  ldv_50211: ;
  if ((int )idx < (int )nsegs) {
    goto ldv_50210;
  } else {

  }
  sgpg_kva->mem_len = (u32 )cfg->drvcfg.num_sgpgs * 32U;
  if ((unsigned long )cfg->drvcfg.num_sgpgs * 32UL != 0UL) {
    list_add_tail(& sgpg_kva->qe, & minfo->kva_info.qe);
  } else {

  }
  return;
}
}
static void bfa_sgpg_attach(struct bfa_s *bfa , void *bfad , struct bfa_iocfc_cfg_s *cfg ,
                            struct bfa_pcidev_s *pcidev ) 
{ 
  struct bfa_sgpg_mod_s *mod ;
  struct bfa_sgpg_s *hsgpg ;
  struct bfi_sgpg_s *sgpg ;
  u64 align_len ;
  struct bfa_mem_dma_s *seg_ptr ;
  u32 sgpg_sz ;
  u16 i ;
  u16 idx ;
  u16 nsegs ;
  u16 per_seg_sgpg ;
  u16 num_sgpg ;
  union __anonunion_sgpg_pa_304 sgpg_pa ;
  union __anonunion_sgpg_pa_tmp_305 sgpg_pa_tmp ;
  int tmp ;
  int __ret_warn_on ;
  long tmp___0 ;

  {
  mod = & bfa->modules.sgpg_mod;
  sgpg_sz = 128U;
  INIT_LIST_HEAD(& mod->sgpg_q);
  INIT_LIST_HEAD(& mod->sgpg_wait_q);
  __bfa_trc(bfa->trcmod, __trc_fileno___13, 5303, (unsigned long long )cfg->drvcfg.num_sgpgs);
  tmp = (int )cfg->drvcfg.num_sgpgs;
  mod->num_sgpgs = tmp;
  mod->free_sgpgs = tmp;
  num_sgpg = cfg->drvcfg.num_sgpgs;
  nsegs = (unsigned short )((((u32 )num_sgpg * sgpg_sz + 131071U) & 4294836224U) / 131072U);
  hsgpg = (struct bfa_sgpg_s *)mod->kva_seg.kva_curp;
  idx = 0U;
  seg_ptr = (struct bfa_mem_dma_s *)(& mod->dma_seg) + (unsigned long )idx;
  goto ldv_50242;
  ldv_50241: ;
  if ((unsigned long )seg_ptr->kva_curp == (unsigned long )((u8 *)0U)) {
    goto ldv_50235;
  } else {

  }
  align_len = ((seg_ptr->dma_curp + 127ULL) & 0xffffffffffffff80ULL) - seg_ptr->dma_curp;
  sgpg = (struct bfi_sgpg_s *)(seg_ptr->kva_curp + align_len);
  sgpg_pa.pa = seg_ptr->dma_curp + align_len;
  __ret_warn_on = (sgpg_pa.pa & (u64 )(sgpg_sz - 1U)) != 0ULL;
  tmp___0 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp___0 != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_svc.c",
                       5324);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  per_seg_sgpg = (u16 )((seg_ptr->mem_len - (u32 )align_len) / sgpg_sz);
  i = 0U;
  goto ldv_50239;
  ldv_50238: 
  memset((void *)hsgpg, 0, 32UL);
  memset((void *)sgpg, 0, 128UL);
  hsgpg->sgpg = sgpg;
  sgpg_pa_tmp.pa = sgpg_pa.pa;
  hsgpg->sgpg_pa = sgpg_pa_tmp.addr;
  list_add_tail(& hsgpg->qe, & mod->sgpg_q);
  sgpg = sgpg + 1;
  hsgpg = hsgpg + 1;
  sgpg_pa.pa = sgpg_pa.pa + (u64 )sgpg_sz;
  i = (u16 )((int )i + 1);
  num_sgpg = (u16 )((int )num_sgpg - 1);
  ldv_50239: ;
  if ((unsigned int )num_sgpg != 0U && (int )i < (int )per_seg_sgpg) {
    goto ldv_50238;
  } else {

  }
  idx = (u16 )((int )idx + 1);
  seg_ptr = (struct bfa_mem_dma_s *)(& mod->dma_seg) + (unsigned long )idx;
  ldv_50242: ;
  if ((int )idx < (int )nsegs) {
    goto ldv_50241;
  } else {

  }
  ldv_50235: 
  mod->kva_seg.kva_curp = (u8 *)hsgpg;
  return;
}
}
static void bfa_sgpg_detach(struct bfa_s *bfa ) 
{ 


  {
  return;
}
}
static void bfa_sgpg_start(struct bfa_s *bfa ) 
{ 


  {
  return;
}
}
static void bfa_sgpg_stop(struct bfa_s *bfa ) 
{ 


  {
  return;
}
}
static void bfa_sgpg_iocdisable(struct bfa_s *bfa ) 
{ 


  {
  return;
}
}
enum bfa_status bfa_sgpg_malloc(struct bfa_s *bfa , struct list_head *sgpg_q , int nsgpgs ) 
{ 
  struct bfa_sgpg_mod_s *mod ;
  struct bfa_sgpg_s *hsgpg ;
  int i ;
  int tmp ;
  int __ret_warn_on ;
  long tmp___0 ;

  {
  mod = & bfa->modules.sgpg_mod;
  if (mod->free_sgpgs < nsgpgs) {
    return (3);
  } else {

  }
  i = 0;
  goto ldv_50266;
  ldv_50265: 
  tmp = list_empty((struct list_head  const  *)(& mod->sgpg_q));
  if (tmp == 0) {
    *((struct list_head **)(& hsgpg)) = mod->sgpg_q.next;
    ((*((struct list_head **)(& hsgpg)))->next)->prev = & mod->sgpg_q;
    mod->sgpg_q.next = (*((struct list_head **)(& hsgpg)))->next;
  } else {
    *((struct list_head **)(& hsgpg)) = (struct list_head *)0;
  }
  __ret_warn_on = (unsigned long )hsgpg == (unsigned long )((struct bfa_sgpg_s *)0);
  tmp___0 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp___0 != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_svc.c",
                       5378);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  list_add_tail(& hsgpg->qe, sgpg_q);
  i = i + 1;
  ldv_50266: ;
  if (i < nsgpgs) {
    goto ldv_50265;
  } else {

  }
  mod->free_sgpgs = mod->free_sgpgs - nsgpgs;
  return (0);
}
}
void bfa_sgpg_mfree(struct bfa_s *bfa , struct list_head *sgpg_q , int nsgpg ) 
{ 
  struct bfa_sgpg_mod_s *mod ;
  struct bfa_sgpg_wqe_s *wqe ;
  int __ret_warn_on ;
  long tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  mod = & bfa->modules.sgpg_mod;
  mod->free_sgpgs = mod->free_sgpgs + nsgpg;
  __ret_warn_on = mod->free_sgpgs > mod->num_sgpgs;
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_svc.c",
                       5393);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  list_splice_tail_init(sgpg_q, & mod->sgpg_q);
  tmp___0 = list_empty((struct list_head  const  *)(& mod->sgpg_wait_q));
  if (tmp___0 != 0) {
    return;
  } else {

  }
  ldv_50277: 
  wqe = (struct bfa_sgpg_wqe_s *)mod->sgpg_wait_q.next;
  if (mod->free_sgpgs < wqe->nsgpg) {
    nsgpg = mod->free_sgpgs;
  } else {
    nsgpg = wqe->nsgpg;
  }
  bfa_sgpg_malloc(bfa, & wqe->sgpg_q, nsgpg);
  wqe->nsgpg = wqe->nsgpg - nsgpg;
  if (wqe->nsgpg == 0) {
    list_del(& wqe->qe);
    (*(wqe->cbfn))(wqe->cbarg);
  } else {

  }
  if (mod->free_sgpgs != 0) {
    tmp___1 = list_empty((struct list_head  const  *)(& mod->sgpg_wait_q));
    if (tmp___1 == 0) {
      goto ldv_50277;
    } else {
      goto ldv_50278;
    }
  } else {

  }
  ldv_50278: ;
  return;
}
}
void bfa_sgpg_wait(struct bfa_s *bfa , struct bfa_sgpg_wqe_s *wqe , int nsgpg ) 
{ 
  struct bfa_sgpg_mod_s *mod ;
  int __ret_warn_on ;
  long tmp ;
  int __ret_warn_on___0 ;
  long tmp___0 ;
  int tmp___1 ;
  int __ret_warn_on___1 ;
  int tmp___2 ;
  long tmp___3 ;

  {
  mod = & bfa->modules.sgpg_mod;
  __ret_warn_on = nsgpg <= 0;
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_svc.c",
                       5423);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  __ret_warn_on___0 = mod->free_sgpgs >= nsgpg;
  tmp___0 = ldv__builtin_expect(__ret_warn_on___0 != 0, 0L);
  if (tmp___0 != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_svc.c",
                       5424);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on___0 != 0, 0L);
  tmp___1 = nsgpg;
  wqe->nsgpg = tmp___1;
  wqe->nsgpg_total = tmp___1;
  if (mod->free_sgpgs != 0) {
    tmp___2 = list_empty((struct list_head  const  *)(& mod->sgpg_wait_q));
    __ret_warn_on___1 = tmp___2 == 0;
    tmp___3 = ldv__builtin_expect(__ret_warn_on___1 != 0, 0L);
    if (tmp___3 != 0L) {
      warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_svc.c",
                         5435);
    } else {

    }
    ldv__builtin_expect(__ret_warn_on___1 != 0, 0L);
    list_splice_tail_init(& mod->sgpg_q, & wqe->sgpg_q);
    wqe->nsgpg = wqe->nsgpg - mod->free_sgpgs;
    mod->free_sgpgs = 0;
  } else {

  }
  list_add_tail(& wqe->qe, & mod->sgpg_wait_q);
  return;
}
}
void bfa_sgpg_wcancel(struct bfa_s *bfa , struct bfa_sgpg_wqe_s *wqe ) 
{ 
  struct bfa_sgpg_mod_s *mod ;
  int __ret_warn_on ;
  int tmp ;
  long tmp___0 ;

  {
  mod = & bfa->modules.sgpg_mod;
  tmp = bfa_q_is_on_q_func(& mod->sgpg_wait_q, (struct list_head *)wqe);
  __ret_warn_on = tmp == 0;
  tmp___0 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp___0 != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_svc.c",
                       5449);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  list_del(& wqe->qe);
  if (wqe->nsgpg_total != wqe->nsgpg) {
    bfa_sgpg_mfree(bfa, & wqe->sgpg_q, wqe->nsgpg_total - wqe->nsgpg);
  } else {

  }
  return;
}
}
void bfa_sgpg_winit(struct bfa_sgpg_wqe_s *wqe , void (*cbfn)(void * ) , void *cbarg ) 
{ 


  {
  INIT_LIST_HEAD(& wqe->sgpg_q);
  wqe->cbfn = cbfn;
  wqe->cbarg = cbarg;
  return;
}
}
static void __bfa_cb_uf_recv(void *cbarg , enum bfa_boolean complete___0 ) 
{ 
  struct bfa_uf_s *uf ;
  struct bfa_uf_mod_s *ufm ;

  {
  uf = (struct bfa_uf_s *)cbarg;
  ufm = & (uf->bfa)->modules.uf_mod;
  if ((unsigned int )complete___0 != 0U) {
    (*(ufm->ufrecv))(ufm->cbarg, uf);
  } else {

  }
  return;
}
}
static void claim_uf_post_msgs(struct bfa_uf_mod_s *ufm ) 
{ 
  struct bfi_uf_buf_post_s *uf_bp_msg ;
  u16 i ;
  u16 buf_len ;
  __u16 tmp ;

  {
  ufm->uf_buf_posts = (struct bfi_uf_buf_post_s *)ufm->kva_seg.kva_curp;
  uf_bp_msg = ufm->uf_buf_posts;
  i = 0U;
  uf_bp_msg = ufm->uf_buf_posts;
  goto ldv_50317;
  ldv_50316: 
  memset((void *)uf_bp_msg, 0, 20UL);
  uf_bp_msg->buf_tag = i;
  buf_len = 2304U;
  tmp = __fswab16((int )buf_len);
  uf_bp_msg->buf_len = tmp;
  uf_bp_msg->mh.msg_class = 8U;
  uf_bp_msg->mh.msg_id = 1U;
  uf_bp_msg->mh.mtag.h2i.fn_lpu = (u8 )((int )((signed char )((int )(ufm->bfa)->ioc.pcidev.pci_func << 1)) | (int )((signed char )(ufm->bfa)->ioc.port_id));
  __bfa_alen_set(& uf_bp_msg->alen, (u32 )buf_len, ufm->dma_seg[(unsigned int )i / 56U].dma_curp + (u64 )(((unsigned int )i - ((unsigned int )i / 56U) * 56U) * 2304U));
  i = (u16 )((int )i + 1);
  uf_bp_msg = uf_bp_msg + 1;
  ldv_50317: ;
  if ((int )ufm->num_ufs > (int )i) {
    goto ldv_50316;
  } else {

  }
  ufm->kva_seg.kva_curp = (u8 *)uf_bp_msg;
  return;
}
}
static void claim_ufs(struct bfa_uf_mod_s *ufm ) 
{ 
  u16 i ;
  struct bfa_uf_s *uf ;

  {
  ufm->uf_list = (struct bfa_uf_s *)ufm->kva_seg.kva_curp;
  i = 0U;
  uf = ufm->uf_list;
  goto ldv_50325;
  ldv_50324: 
  memset((void *)uf, 0, 144UL);
  uf->bfa = ufm->bfa;
  uf->uf_tag = i;
  uf->pb_len = 2304U;
  uf->buf_kva = (void *)ufm->dma_seg[(unsigned int )i / 56U].kva_curp + (unsigned long )(((unsigned int )i - ((unsigned int )i / 56U) * 56U) * 2304U);
  uf->buf_pa = ufm->dma_seg[(unsigned int )i / 56U].dma_curp + (u64 )(((unsigned int )i - ((unsigned int )i / 56U) * 56U) * 2304U);
  list_add_tail(& uf->qe, & ufm->uf_free_q);
  i = (u16 )((int )i + 1);
  uf = uf + 1;
  ldv_50325: ;
  if ((int )ufm->num_ufs > (int )i) {
    goto ldv_50324;
  } else {

  }
  ufm->kva_seg.kva_curp = (u8 *)uf;
  return;
}
}
static void uf_mem_claim(struct bfa_uf_mod_s *ufm ) 
{ 


  {
  claim_ufs(ufm);
  claim_uf_post_msgs(ufm);
  return;
}
}
static void bfa_uf_meminfo(struct bfa_iocfc_cfg_s *cfg , struct bfa_meminfo_s *minfo ,
                           struct bfa_s *bfa ) 
{ 
  struct bfa_uf_mod_s *ufm ;
  struct bfa_mem_kva_s *uf_kva ;
  u32 num_ufs ;
  struct bfa_mem_dma_s *seg_ptr ;
  u16 nsegs ;
  u16 idx ;
  u16 per_seg_uf ;

  {
  ufm = & bfa->modules.uf_mod;
  uf_kva = & bfa->modules.uf_mod.kva_seg;
  num_ufs = (u32 )cfg->fwcfg.num_uf_bufs;
  per_seg_uf = 0U;
  nsegs = (unsigned short )(((num_ufs * 2304U + 131071U) & 4294836224U) / 131072U);
  per_seg_uf = 56U;
  idx = 0U;
  seg_ptr = (struct bfa_mem_dma_s *)(& ufm->dma_seg) + (unsigned long )idx;
  goto ldv_50343;
  ldv_50342: ;
  if ((u32 )per_seg_uf <= num_ufs) {
    num_ufs = num_ufs - (u32 )per_seg_uf;
    seg_ptr->mem_len = (unsigned int )per_seg_uf * 2304U;
    if ((unsigned int )per_seg_uf * 2304U != 0U) {
      list_add_tail(& seg_ptr->qe, & minfo->dma_info.qe);
    } else {

    }
  } else {
    seg_ptr->mem_len = num_ufs * 2304U;
    if (num_ufs * 2304U != 0U) {
      list_add_tail(& seg_ptr->qe, & minfo->dma_info.qe);
    } else {

    }
  }
  idx = (u16 )((int )idx + 1);
  seg_ptr = (struct bfa_mem_dma_s *)(& ufm->dma_seg) + (unsigned long )idx;
  ldv_50343: ;
  if ((int )idx < (int )nsegs) {
    goto ldv_50342;
  } else {

  }
  uf_kva->mem_len = (u32 )cfg->fwcfg.num_uf_bufs * 164U;
  if ((unsigned long )cfg->fwcfg.num_uf_bufs * 164UL != 0UL) {
    list_add_tail(& uf_kva->qe, & minfo->kva_info.qe);
  } else {

  }
  return;
}
}
static void bfa_uf_attach(struct bfa_s *bfa , void *bfad , struct bfa_iocfc_cfg_s *cfg ,
                          struct bfa_pcidev_s *pcidev ) 
{ 
  struct bfa_uf_mod_s *ufm ;

  {
  ufm = & bfa->modules.uf_mod;
  ufm->bfa = bfa;
  ufm->num_ufs = cfg->fwcfg.num_uf_bufs;
  INIT_LIST_HEAD(& ufm->uf_free_q);
  INIT_LIST_HEAD(& ufm->uf_posted_q);
  INIT_LIST_HEAD(& ufm->uf_unused_q);
  uf_mem_claim(ufm);
  return;
}
}
static void bfa_uf_detach(struct bfa_s *bfa ) 
{ 


  {
  return;
}
}
static struct bfa_uf_s *bfa_uf_get(struct bfa_uf_mod_s *uf_mod ) 
{ 
  struct bfa_uf_s *uf ;
  int tmp ;

  {
  tmp = list_empty((struct list_head  const  *)(& uf_mod->uf_free_q));
  if (tmp == 0) {
    *((struct list_head **)(& uf)) = uf_mod->uf_free_q.next;
    ((*((struct list_head **)(& uf)))->next)->prev = & uf_mod->uf_free_q;
    uf_mod->uf_free_q.next = (*((struct list_head **)(& uf)))->next;
  } else {
    *((struct list_head **)(& uf)) = (struct list_head *)0;
  }
  return (uf);
}
}
static void bfa_uf_put(struct bfa_uf_mod_s *uf_mod , struct bfa_uf_s *uf ) 
{ 


  {
  list_add_tail(& uf->qe, & uf_mod->uf_free_q);
  return;
}
}
static enum bfa_status bfa_uf_post(struct bfa_uf_mod_s *ufm , struct bfa_uf_s *uf ) 
{ 
  struct bfi_uf_buf_post_s *uf_post_msg ;

  {
  uf_post_msg = (((ufm->bfa)->iocfc.req_cq_pi[0] + 1U) & (u32 )((int )(ufm->bfa)->iocfc.cfg.drvcfg.num_reqq_elems + -1)) != *((u32 *)(ufm->bfa)->iocfc.req_cq_shadow_ci[0].kva) ? (struct bfi_uf_buf_post_s *)(ufm->bfa)->iocfc.req_cq_ba[0].kva + (unsigned long )(ufm->bfa)->iocfc.req_cq_pi[0] : (struct bfi_uf_buf_post_s *)0;
  if ((unsigned long )uf_post_msg == (unsigned long )((struct bfi_uf_buf_post_s *)0)) {
    return (1);
  } else {

  }
  memcpy((void *)uf_post_msg, (void const   *)ufm->uf_buf_posts + (unsigned long )uf->uf_tag,
           20UL);
  uf_post_msg->mh.mtag.h2i.qid = (ufm->bfa)->iocfc.hw_qid[0];
  (ufm->bfa)->iocfc.req_cq_pi[0] = (ufm->bfa)->iocfc.req_cq_pi[0] + 1U;
  (ufm->bfa)->iocfc.req_cq_pi[0] = (ufm->bfa)->iocfc.req_cq_pi[0] & (u32 )((int )(ufm->bfa)->iocfc.cfg.drvcfg.num_reqq_elems + -1);
  writel((ufm->bfa)->iocfc.req_cq_pi[0], (void volatile   *)(ufm->bfa)->iocfc.bfa_regs.cpe_q_pi[0]);
  __asm__  volatile   ("": : : "memory");
  __bfa_trc((ufm->bfa)->trcmod, __trc_fileno___13, 5625, (unsigned long long )uf->uf_tag);
  list_add_tail(& uf->qe, & ufm->uf_posted_q);
  return (0);
}
}
static void bfa_uf_post_all(struct bfa_uf_mod_s *uf_mod ) 
{ 
  struct bfa_uf_s *uf ;
  enum bfa_status tmp ;

  {
  goto ldv_50374;
  ldv_50373: 
  tmp = bfa_uf_post(uf_mod, uf);
  if ((unsigned int )tmp != 0U) {
    goto ldv_50372;
  } else {

  }
  ldv_50374: 
  uf = bfa_uf_get(uf_mod);
  if ((unsigned long )uf != (unsigned long )((struct bfa_uf_s *)0)) {
    goto ldv_50373;
  } else {

  }
  ldv_50372: ;
  return;
}
}
static void uf_recv(struct bfa_s *bfa , struct bfi_uf_frm_rcvd_s *m ) 
{ 
  struct bfa_uf_mod_s *ufm ;
  u16 uf_tag ;
  struct bfa_uf_s *uf ;
  struct bfa_uf_buf_s *uf_buf ;
  uint8_t *buf ;
  struct fchs_s *fchs ;
  __u16 tmp ;
  __u16 tmp___0 ;
  int __ret_warn_on ;
  long tmp___1 ;
  u32 pld_w0 ;

  {
  ufm = & bfa->modules.uf_mod;
  uf_tag = m->buf_tag;
  uf = ufm->uf_list + (unsigned long )uf_tag;
  uf_buf = (struct bfa_uf_buf_s *)ufm->dma_seg[(int )uf_tag / (131072 / (int )uf->pb_len)].kva_curp + (unsigned long )(((int )uf_tag % (131072 / (int )uf->pb_len)) * (int )uf->pb_len);
  buf = (uint8_t *)(& uf_buf->d);
  tmp = __fswab16((int )m->frm_len);
  m->frm_len = tmp;
  tmp___0 = __fswab16((int )m->xfr_len);
  m->xfr_len = tmp___0;
  fchs = (struct fchs_s *)uf_buf;
  list_del(& uf->qe);
  uf->data_ptr = buf;
  uf->data_len = m->xfr_len;
  __ret_warn_on = (unsigned int )uf->data_len <= 23U;
  tmp___1 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp___1 != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_svc.c",
                       5666);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if ((unsigned int )uf->data_len == 24U) {
    bfa_plog_fchdr(bfa->plog, 5, 10, (int )uf->data_len, (struct fchs_s *)buf);
  } else {
    pld_w0 = *((u32 *)buf + 24U);
    bfa_plog_fchdr_and_pl(bfa->plog, 5, 10, (int )uf->data_len, (struct fchs_s *)buf,
                          pld_w0);
  }
  if ((unsigned int )bfa->fcs != 0U) {
    __bfa_cb_uf_recv((void *)uf, 1);
  } else {
    uf->hcb_qe.cbfn = & __bfa_cb_uf_recv;
    uf->hcb_qe.cbarg = (void *)uf;
    uf->hcb_qe.pre_rmv = 0;
    list_add_tail(& uf->hcb_qe.qe, & bfa->comp_q);
  }
  return;
}
}
static void bfa_uf_stop(struct bfa_s *bfa ) 
{ 


  {
  return;
}
}
static void bfa_uf_iocdisable(struct bfa_s *bfa ) 
{ 
  struct bfa_uf_mod_s *ufm ;
  struct bfa_uf_s *uf ;
  struct list_head *qe ;
  struct list_head *qen ;

  {
  ufm = & bfa->modules.uf_mod;
  list_splice_tail_init(& ufm->uf_unused_q, & ufm->uf_free_q);
  qe = ufm->uf_posted_q.next;
  qen = qe->next;
  goto ldv_50399;
  ldv_50398: 
  uf = (struct bfa_uf_s *)qe;
  list_del(& uf->qe);
  bfa_uf_put(ufm, uf);
  qe = qen;
  qen = qe->next;
  ldv_50399: ;
  if ((unsigned long )(& ufm->uf_posted_q) != (unsigned long )qe) {
    goto ldv_50398;
  } else {

  }

  return;
}
}
static void bfa_uf_start(struct bfa_s *bfa ) 
{ 


  {
  bfa_uf_post_all(& bfa->modules.uf_mod);
  return;
}
}
void bfa_uf_recv_register(struct bfa_s *bfa , void (*ufrecv)(void * , struct bfa_uf_s * ) ,
                          void *cbarg ) 
{ 
  struct bfa_uf_mod_s *ufm ;

  {
  ufm = & bfa->modules.uf_mod;
  ufm->ufrecv = ufrecv;
  ufm->cbarg = cbarg;
  return;
}
}
void bfa_uf_free(struct bfa_uf_s *uf ) 
{ 


  {
  bfa_uf_put(& (uf->bfa)->modules.uf_mod, uf);
  bfa_uf_post_all(& (uf->bfa)->modules.uf_mod);
  return;
}
}
void bfa_uf_isr(struct bfa_s *bfa , struct bfi_msg_s *msg ) 
{ 
  int __ret_warn_on ;
  long tmp ;

  {
  __bfa_trc(bfa->trcmod, __trc_fileno___13, 5750, (unsigned long long )msg->mhdr.msg_id);
  switch ((int )msg->mhdr.msg_id) {
  case 129: 
  uf_recv(bfa, (struct bfi_uf_frm_rcvd_s *)msg);
  goto ldv_50418;
  default: 
  __bfa_trc(bfa->trcmod, __trc_fileno___13, 5758, (unsigned long long )msg->mhdr.msg_id);
  __ret_warn_on = 1;
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_svc.c",
                       5759);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  }
  ldv_50418: ;
  return;
}
}
void bfa_uf_res_recfg(struct bfa_s *bfa , u16 num_uf_fw ) 
{ 
  struct bfa_uf_mod_s *mod ;
  struct list_head *qe ;
  int i ;
  int tmp ;

  {
  mod = & bfa->modules.uf_mod;
  i = 0;
  goto ldv_50430;
  ldv_50429: 
  tmp = list_empty((struct list_head  const  *)(& mod->uf_free_q));
  if (tmp == 0) {
    qe = mod->uf_free_q.prev;
    (qe->prev)->next = & mod->uf_free_q;
    mod->uf_free_q.prev = qe->prev;
  } else {
    qe = (struct list_head *)0;
  }
  list_add_tail(qe, & mod->uf_unused_q);
  i = i + 1;
  ldv_50430: ;
  if ((int )mod->num_ufs - (int )num_uf_fw > i) {
    goto ldv_50429;
  } else {

  }

  return;
}
}
static void bfa_dport_sm_disabled(struct bfa_dport_s *dport , enum bfa_dport_sm_event event ) ;
static void bfa_dport_sm_enabling_qwait(struct bfa_dport_s *dport , enum bfa_dport_sm_event event ) ;
static void bfa_dport_sm_enabling(struct bfa_dport_s *dport , enum bfa_dport_sm_event event ) ;
static void bfa_dport_sm_enabled(struct bfa_dport_s *dport , enum bfa_dport_sm_event event ) ;
static void bfa_dport_sm_disabling_qwait(struct bfa_dport_s *dport , enum bfa_dport_sm_event event ) ;
static void bfa_dport_sm_disabling(struct bfa_dport_s *dport , enum bfa_dport_sm_event event ) ;
static void bfa_dport_sm_starting_qwait(struct bfa_dport_s *dport , enum bfa_dport_sm_event event ) ;
static void bfa_dport_sm_starting(struct bfa_dport_s *dport , enum bfa_dport_sm_event event ) ;
static void bfa_dport_sm_dynamic_disabling(struct bfa_dport_s *dport , enum bfa_dport_sm_event event ) ;
static void bfa_dport_sm_dynamic_disabling_qwait(struct bfa_dport_s *dport , enum bfa_dport_sm_event event ) ;
static void bfa_dport_qresume(void *cbarg ) ;
static void bfa_dport_req_comp(struct bfa_dport_s *dport , struct bfi_diag_dport_rsp_s *msg ) ;
static void bfa_dport_scn(struct bfa_dport_s *dport , struct bfi_diag_dport_scn_s *msg ) ;
static void bfa_fcdiag_set_busy_status(struct bfa_fcdiag_s *fcdiag ) 
{ 
  struct bfa_fcport_s *fcport ;

  {
  fcport = & (fcdiag->bfa)->modules.fcport;
  if ((unsigned int )fcdiag->lb.lock != 0U) {
    fcport->diag_busy = 1;
  } else {
    fcport->diag_busy = 0;
  }
  return;
}
}
static void bfa_fcdiag_meminfo(struct bfa_iocfc_cfg_s *cfg , struct bfa_meminfo_s *meminfo ,
                               struct bfa_s *bfa ) 
{ 


  {
  return;
}
}
static void bfa_fcdiag_attach(struct bfa_s *bfa , void *bfad , struct bfa_iocfc_cfg_s *cfg ,
                              struct bfa_pcidev_s *pcidev ) 
{ 
  struct bfa_fcdiag_s *fcdiag ;
  struct bfa_dport_s *dport ;

  {
  fcdiag = & bfa->modules.fcdiag;
  dport = & fcdiag->dport;
  fcdiag->bfa = bfa;
  fcdiag->trcmod = bfa->trcmod;
  dport->bfa = bfa;
  dport->sm = (void (*)(void * , int  ))(& bfa_dport_sm_disabled);
  bfa_reqq_winit(& dport->reqq_wait, & bfa_dport_qresume, (void *)dport);
  dport->cbfn = (void (*)(void * , enum bfa_status  ))0;
  dport->cbarg = (void *)0;
  dport->test_state = 0U;
  memset((void *)(& dport->result), 0, 120UL);
  return;
}
}
static void bfa_fcdiag_iocdisable(struct bfa_s *bfa ) 
{ 
  struct bfa_fcdiag_s *fcdiag ;
  struct bfa_dport_s *dport ;

  {
  fcdiag = & bfa->modules.fcdiag;
  dport = & fcdiag->dport;
  __bfa_trc(fcdiag->trcmod, __trc_fileno___13, 5878, (unsigned long long )fcdiag->lb.lock);
  if ((unsigned int )fcdiag->lb.lock != 0U) {
    fcdiag->lb.status = 56U;
    (*(fcdiag->lb.cbfn))(fcdiag->lb.cbarg, (enum bfa_status )fcdiag->lb.status);
    fcdiag->lb.lock = 0;
    bfa_fcdiag_set_busy_status(fcdiag);
  } else {

  }
  (*(dport->sm))((void *)dport, 5);
  return;
}
}
static void bfa_fcdiag_detach(struct bfa_s *bfa ) 
{ 


  {
  return;
}
}
static void bfa_fcdiag_start(struct bfa_s *bfa ) 
{ 


  {
  return;
}
}
static void bfa_fcdiag_stop(struct bfa_s *bfa ) 
{ 


  {
  return;
}
}
static void bfa_fcdiag_queuetest_timeout(void *cbarg ) 
{ 
  struct bfa_fcdiag_s *fcdiag ;
  struct bfa_diag_qtest_result_s *res ;

  {
  fcdiag = (struct bfa_fcdiag_s *)cbarg;
  res = fcdiag->qtest.result;
  __bfa_trc(fcdiag->trcmod, __trc_fileno___13, 5910, (unsigned long long )fcdiag->qtest.all);
  __bfa_trc(fcdiag->trcmod, __trc_fileno___13, 5911, (unsigned long long )fcdiag->qtest.count);
  fcdiag->qtest.timer_active = 0U;
  res->status = 5U;
  res->count = 10U - (unsigned int )((u16 )fcdiag->qtest.count);
  if ((unsigned int )fcdiag->qtest.all != 0U) {
    res->queue = fcdiag->qtest.all;
  } else {

  }
  __bfa_trc(fcdiag->trcmod, __trc_fileno___13, 5920, 5ULL);
  fcdiag->qtest.status = 5U;
  (*(fcdiag->qtest.cbfn))(fcdiag->qtest.cbarg, (enum bfa_status )fcdiag->qtest.status);
  fcdiag->qtest.lock = 0U;
  return;
}
}
static enum bfa_status bfa_fcdiag_queuetest_send(struct bfa_fcdiag_s *fcdiag ) 
{ 
  u32 i ;
  struct bfi_diag_qtest_req_s *req ;

  {
  req = (((fcdiag->bfa)->iocfc.req_cq_pi[(int )fcdiag->qtest.queue] + 1U) & (u32 )((int )(fcdiag->bfa)->iocfc.cfg.drvcfg.num_reqq_elems + -1)) != *((u32 *)(fcdiag->bfa)->iocfc.req_cq_shadow_ci[(int )fcdiag->qtest.queue].kva) ? (struct bfi_diag_qtest_req_s *)(fcdiag->bfa)->iocfc.req_cq_ba[(int )fcdiag->qtest.queue].kva + (unsigned long )(fcdiag->bfa)->iocfc.req_cq_pi[(int )fcdiag->qtest.queue] : (struct bfi_diag_qtest_req_s *)0;
  if ((unsigned long )req == (unsigned long )((struct bfi_diag_qtest_req_s *)0)) {
    return (13);
  } else {

  }
  req->mh.msg_class = 2U;
  req->mh.msg_id = 6U;
  req->mh.mtag.h2i.fn_lpu = (u8 )((int )((signed char )((int )(fcdiag->bfa)->ioc.pcidev.pci_func << 1)) | (int )((signed char )(fcdiag->bfa)->ioc.port_id));
  i = 0U;
  goto ldv_50527;
  ldv_50526: 
  req->data[i] = 3048584629U;
  i = i + 1U;
  ldv_50527: ;
  if (i <= 30U) {
    goto ldv_50526;
  } else {

  }
  __bfa_trc(fcdiag->trcmod, __trc_fileno___13, 5943, (unsigned long long )fcdiag->qtest.queue);
  req->mh.mtag.h2i.qid = (fcdiag->bfa)->iocfc.hw_qid[(int )fcdiag->qtest.queue];
  (fcdiag->bfa)->iocfc.req_cq_pi[(int )fcdiag->qtest.queue] = (fcdiag->bfa)->iocfc.req_cq_pi[(int )fcdiag->qtest.queue] + 1U;
  (fcdiag->bfa)->iocfc.req_cq_pi[(int )fcdiag->qtest.queue] = (fcdiag->bfa)->iocfc.req_cq_pi[(int )fcdiag->qtest.queue] & (u32 )((int )(fcdiag->bfa)->iocfc.cfg.drvcfg.num_reqq_elems + -1);
  writel((fcdiag->bfa)->iocfc.req_cq_pi[(int )fcdiag->qtest.queue], (void volatile   *)(fcdiag->bfa)->iocfc.bfa_regs.cpe_q_pi[(int )fcdiag->qtest.queue]);
  __asm__  volatile   ("": : : "memory");
  return (0);
}
}
static void bfa_fcdiag_queuetest_comp(struct bfa_fcdiag_s *fcdiag , struct bfi_diag_qtest_req_s *rsp ) 
{ 
  struct bfa_diag_qtest_result_s *res ;
  enum bfa_status status ;
  int i ;

  {
  res = fcdiag->qtest.result;
  status = 0;
  if ((unsigned int )fcdiag->qtest.timer_active == 0U) {
    __bfa_trc(fcdiag->trcmod, __trc_fileno___13, 5959, (unsigned long long )fcdiag->qtest.timer_active);
    return;
  } else {

  }
  fcdiag->qtest.count = fcdiag->qtest.count - 1U;
  i = 0;
  goto ldv_50538;
  ldv_50537: ;
  if (rsp->data[i] != 1246382666U) {
    res->status = 12U;
    goto ldv_50536;
  } else {

  }
  i = i + 1;
  ldv_50538: ;
  if ((unsigned int )i <= 30U) {
    goto ldv_50537;
  } else {

  }
  ldv_50536: ;
  if (res->status == 0U) {
    if (fcdiag->qtest.count != 0U) {
      status = bfa_fcdiag_queuetest_send(fcdiag);
      if ((unsigned int )status == 0U) {
        return;
      } else {
        res->status = (u32 )status;
      }
    } else
    if ((unsigned int )fcdiag->qtest.all != 0U && (unsigned int )fcdiag->qtest.queue <= 2U) {
      fcdiag->qtest.count = 10U;
      fcdiag->qtest.queue = (u8 )((int )fcdiag->qtest.queue + 1);
      status = bfa_fcdiag_queuetest_send(fcdiag);
      if ((unsigned int )status == 0U) {
        return;
      } else {
        res->status = (u32 )status;
      }
    } else {

    }
  } else {

  }
  if ((unsigned int )fcdiag->qtest.timer_active != 0U) {
    bfa_timer_stop(& fcdiag->qtest.timer);
    fcdiag->qtest.timer_active = 0U;
  } else {

  }
  res->queue = fcdiag->qtest.queue;
  res->count = 10U - (unsigned int )((u16 )fcdiag->qtest.count);
  __bfa_trc(fcdiag->trcmod, __trc_fileno___13, 6000, (unsigned long long )res->count);
  __bfa_trc(fcdiag->trcmod, __trc_fileno___13, 6001, (unsigned long long )res->status);
  fcdiag->qtest.status = res->status;
  (*(fcdiag->qtest.cbfn))(fcdiag->qtest.cbarg, (enum bfa_status )fcdiag->qtest.status);
  fcdiag->qtest.lock = 0U;
  return;
}
}
static void bfa_fcdiag_loopback_comp(struct bfa_fcdiag_s *fcdiag , struct bfi_diag_lb_rsp_s *rsp ) 
{ 
  struct bfa_diag_loopback_result_s *res ;
  __u32 tmp ;
  __u32 tmp___0 ;
  __u32 tmp___1 ;
  __u32 tmp___2 ;
  __u32 tmp___3 ;

  {
  res = (struct bfa_diag_loopback_result_s *)fcdiag->lb.result;
  tmp = __fswab32(rsp->res.numtxmfrm);
  res->numtxmfrm = tmp;
  tmp___0 = __fswab32(rsp->res.numosffrm);
  res->numosffrm = tmp___0;
  tmp___1 = __fswab32(rsp->res.numrcvfrm);
  res->numrcvfrm = tmp___1;
  tmp___2 = __fswab32(rsp->res.badfrminf);
  res->badfrminf = tmp___2;
  tmp___3 = __fswab32(rsp->res.badfrmnum);
  res->badfrmnum = tmp___3;
  res->status = rsp->res.status;
  fcdiag->lb.status = (u32 )rsp->res.status;
  __bfa_trc(fcdiag->trcmod, __trc_fileno___13, 6020, (unsigned long long )fcdiag->lb.status);
  (*(fcdiag->lb.cbfn))(fcdiag->lb.cbarg, (enum bfa_status )fcdiag->lb.status);
  fcdiag->lb.lock = 0;
  bfa_fcdiag_set_busy_status(fcdiag);
  return;
}
}
static enum bfa_status bfa_fcdiag_loopback_send(struct bfa_fcdiag_s *fcdiag , struct bfa_diag_loopback_s *loopback ) 
{ 
  struct bfi_diag_lb_req_s *lb_req ;

  {
  lb_req = (((fcdiag->bfa)->iocfc.req_cq_pi[0] + 1U) & (u32 )((int )(fcdiag->bfa)->iocfc.cfg.drvcfg.num_reqq_elems + -1)) != *((u32 *)(fcdiag->bfa)->iocfc.req_cq_shadow_ci[0].kva) ? (struct bfi_diag_lb_req_s *)(fcdiag->bfa)->iocfc.req_cq_ba[0].kva + (unsigned long )(fcdiag->bfa)->iocfc.req_cq_pi[0] : (struct bfi_diag_lb_req_s *)0;
  if ((unsigned long )lb_req == (unsigned long )((struct bfi_diag_lb_req_s *)0)) {
    return (13);
  } else {

  }
  lb_req->mh.msg_class = 2U;
  lb_req->mh.msg_id = 2U;
  lb_req->mh.mtag.h2i.fn_lpu = (u8 )((int )((signed char )((int )(fcdiag->bfa)->ioc.pcidev.pci_func << 1)) | (int )((signed char )(fcdiag->bfa)->ioc.port_id));
  lb_req->lb_mode = loopback->lb_mode;
  lb_req->speed = loopback->speed;
  lb_req->loopcnt = loopback->loopcnt;
  lb_req->pattern = loopback->pattern;
  lb_req->mh.mtag.h2i.qid = (fcdiag->bfa)->iocfc.hw_qid[0];
  (fcdiag->bfa)->iocfc.req_cq_pi[0] = (fcdiag->bfa)->iocfc.req_cq_pi[0] + 1U;
  (fcdiag->bfa)->iocfc.req_cq_pi[0] = (fcdiag->bfa)->iocfc.req_cq_pi[0] & (u32 )((int )(fcdiag->bfa)->iocfc.cfg.drvcfg.num_reqq_elems + -1);
  writel((fcdiag->bfa)->iocfc.req_cq_pi[0], (void volatile   *)(fcdiag->bfa)->iocfc.bfa_regs.cpe_q_pi[0]);
  __asm__  volatile   ("": : : "memory");
  __bfa_trc(fcdiag->trcmod, __trc_fileno___13, 6048, (unsigned long long )loopback->lb_mode);
  __bfa_trc(fcdiag->trcmod, __trc_fileno___13, 6049, (unsigned long long )loopback->speed);
  __bfa_trc(fcdiag->trcmod, __trc_fileno___13, 6050, (unsigned long long )loopback->loopcnt);
  __bfa_trc(fcdiag->trcmod, __trc_fileno___13, 6051, (unsigned long long )loopback->pattern);
  return (0);
}
}
void bfa_fcdiag_intr(struct bfa_s *bfa , struct bfi_msg_s *msg ) 
{ 
  struct bfa_fcdiag_s *fcdiag ;
  int __ret_warn_on ;
  long tmp ;

  {
  fcdiag = & bfa->modules.fcdiag;
  switch ((int )msg->mhdr.msg_id) {
  case 130: 
  bfa_fcdiag_loopback_comp(fcdiag, (struct bfi_diag_lb_rsp_s *)msg);
  goto ldv_50555;
  case 134: 
  bfa_fcdiag_queuetest_comp(fcdiag, (struct bfi_diag_qtest_req_s *)msg);
  goto ldv_50555;
  case 135: 
  bfa_dport_req_comp(& fcdiag->dport, (struct bfi_diag_dport_rsp_s *)msg);
  goto ldv_50555;
  case 136: 
  bfa_dport_scn(& fcdiag->dport, (struct bfi_diag_dport_scn_s *)msg);
  goto ldv_50555;
  default: 
  __bfa_trc(fcdiag->trcmod, __trc_fileno___13, 6080, (unsigned long long )msg->mhdr.msg_id);
  __ret_warn_on = 1;
  tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
  if (tmp != 0L) {
    warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_svc.c",
                       6081);
  } else {

  }
  ldv__builtin_expect(__ret_warn_on != 0, 0L);
  }
  ldv_50555: ;
  return;
}
}
enum bfa_status bfa_fcdiag_loopback(struct bfa_s *bfa , enum bfa_port_opmode opmode ,
                                    enum bfa_port_speed speed , u32 lpcnt , u32 pat ,
                                    struct bfa_diag_loopback_result_s *result , void (*cbfn)(void * ,
                                                                                             enum bfa_status  ) ,
                                    void *cbarg ) 
{ 
  struct bfa_diag_loopback_s loopback ;
  struct bfa_port_attr_s attr ;
  enum bfa_status status ;
  struct bfa_fcdiag_s *fcdiag ;
  enum bfa_boolean tmp ;
  enum bfa_status tmp___0 ;
  enum bfa_boolean tmp___1 ;
  enum bfa_ioc_type_e tmp___2 ;
  enum bfa_ioc_type_e tmp___3 ;
  enum bfa_boolean tmp___4 ;

  {
  fcdiag = & bfa->modules.fcdiag;
  tmp = bfa_iocfc_is_operational(bfa);
  if ((unsigned int )tmp == 0U) {
    return (61);
  } else {

  }
  tmp___0 = bfa_fcport_is_pbcdisabled(bfa);
  if ((unsigned int )tmp___0 != 0U) {
    __bfa_trc(fcdiag->trcmod, __trc_fileno___13, 6115, 154ULL);
    return (154);
  } else {

  }
  tmp___1 = bfa_fcport_is_disabled(bfa);
  if ((unsigned int )tmp___1 == 0U) {
    __bfa_trc(fcdiag->trcmod, __trc_fileno___13, 6120, (unsigned long long )opmode);
    return (47);
  } else {

  }
  tmp___2 = bfa_ioc_get_type(& bfa->ioc);
  if ((unsigned int )tmp___2 == 1U) {
    if ((((((unsigned int )speed != 1U && (unsigned int )speed != 2U) && (unsigned int )speed != 4U) && (unsigned int )speed != 8U) && (unsigned int )speed != 16U) && (unsigned int )speed != 15U) {
      __bfa_trc(fcdiag->trcmod, __trc_fileno___13, 6134, (unsigned long long )speed);
      return (23);
    } else {

    }
    bfa_fcport_get_attr(bfa, & attr);
    __bfa_trc(fcdiag->trcmod, __trc_fileno___13, 6138, (unsigned long long )attr.speed_supported);
    if ((unsigned int )attr.speed_supported < (unsigned int )speed) {
      return (23);
    } else {

    }
  } else
  if ((unsigned int )speed != 10U) {
    __bfa_trc(fcdiag->trcmod, __trc_fileno___13, 6143, (unsigned long long )speed);
    return (23);
  } else {

  }
  if ((unsigned int )speed == 1U && ((unsigned int )bfa->ioc.pcidev.device_id == 34U || (unsigned int )bfa->ioc.pcidev.device_id == 35U)) {
    __bfa_trc(fcdiag->trcmod, __trc_fileno___13, 6153, (unsigned long long )speed);
    return (23);
  } else {

  }
  if (((((((bfa->ioc.attr)->card_type == 804U || (bfa->ioc.attr)->card_type == 1007U) || (bfa->ioc.attr)->card_type == 807U) || (bfa->ioc.attr)->card_type == 902U) || (bfa->ioc.attr)->card_type == 1741U) || (bfa->ioc.attr)->card_type == 1867U) || (bfa->ioc.attr)->card_type == 1869U) {
    tmp___3 = bfa_ioc_get_type(& bfa->ioc);
    if ((unsigned int )tmp___3 == 1U) {
      if ((((((unsigned int )speed != 1U && (unsigned int )speed != 2U) && (unsigned int )speed != 4U) && (unsigned int )speed != 8U) && (unsigned int )speed != 16U) && (unsigned int )speed != 15U) {
        return (23);
      } else {

      }
    } else
    if ((unsigned int )speed != 10U) {
      return (23);
    } else {

    }
  } else {

  }
  tmp___4 = bfa_fcport_is_dport(bfa);
  if ((unsigned int )tmp___4 != 0U) {
    __bfa_trc(fcdiag->trcmod, __trc_fileno___13, 6174, (unsigned long long )fcdiag->lb.lock);
    return (235);
  } else {

  }
  if ((unsigned int )fcdiag->lb.lock != 0U) {
    __bfa_trc(fcdiag->trcmod, __trc_fileno___13, 6179, (unsigned long long )fcdiag->lb.lock);
    return (13);
  } else {

  }
  fcdiag->lb.lock = 1;
  loopback.lb_mode = (u8 )opmode;
  loopback.speed = (u8 )speed;
  loopback.loopcnt = lpcnt;
  loopback.pattern = pat;
  fcdiag->lb.result = (void *)result;
  fcdiag->lb.cbfn = cbfn;
  fcdiag->lb.cbarg = cbarg;
  memset((void *)result, 0, 24UL);
  bfa_fcdiag_set_busy_status(fcdiag);
  status = bfa_fcdiag_loopback_send(fcdiag, & loopback);
  return (status);
}
}
enum bfa_status bfa_fcdiag_queuetest(struct bfa_s *bfa , u32 force , u32 queue , struct bfa_diag_qtest_result_s *result ,
                                     void (*cbfn)(void * , enum bfa_status  ) , void *cbarg ) 
{ 
  struct bfa_fcdiag_s *fcdiag ;
  enum bfa_status status ;
  enum bfa_boolean tmp ;

  {
  fcdiag = & bfa->modules.fcdiag;
  __bfa_trc(fcdiag->trcmod, __trc_fileno___13, 6218, (unsigned long long )force);
  __bfa_trc(fcdiag->trcmod, __trc_fileno___13, 6219, (unsigned long long )queue);
  if (force == 0U) {
    tmp = bfa_iocfc_is_operational(bfa);
    if ((unsigned int )tmp == 0U) {
      return (61);
    } else {

    }
  } else {

  }
  if ((unsigned int )fcdiag->qtest.lock != 0U) {
    __bfa_trc(fcdiag->trcmod, __trc_fileno___13, 6226, (unsigned long long )fcdiag->qtest.lock);
    return (13);
  } else {

  }
  fcdiag->qtest.lock = 1U;
  fcdiag->qtest.cbfn = cbfn;
  fcdiag->qtest.cbarg = cbarg;
  fcdiag->qtest.result = result;
  fcdiag->qtest.count = 10U;
  (fcdiag->qtest.result)->status = 0U;
  (fcdiag->qtest.result)->count = 0U;
  if (queue <= 3U) {
    (fcdiag->qtest.result)->queue = (unsigned char )queue;
    fcdiag->qtest.queue = (unsigned char )queue;
    fcdiag->qtest.all = 0U;
  } else {
    (fcdiag->qtest.result)->queue = 0U;
    fcdiag->qtest.queue = 0U;
    fcdiag->qtest.all = 1U;
  }
  status = bfa_fcdiag_queuetest_send(fcdiag);
  if ((unsigned int )status == 0U) {
    bfa_timer_begin(& bfa->timer_mod, & fcdiag->qtest.timer, & bfa_fcdiag_queuetest_timeout,
                    (void *)fcdiag, 1000U);
    fcdiag->qtest.timer_active = 1U;
  } else {

  }
  return (status);
}
}
enum bfa_status bfa_fcdiag_lb_is_running(struct bfa_s *bfa ) 
{ 
  struct bfa_fcdiag_s *fcdiag ;

  {
  fcdiag = & bfa->modules.fcdiag;
  return ((unsigned int )fcdiag->lb.lock != 0U ? 71 : 0);
}
}
static enum bfa_boolean bfa_dport_send_req(struct bfa_dport_s *dport , enum bfi_dport_req req ) ;
static void bfa_cb_fcdiag_dport(struct bfa_dport_s *dport , enum bfa_status bfa_status ) 
{ 


  {
  if ((unsigned long )dport->cbfn != (unsigned long )((void (*)(void * , enum bfa_status  ))0)) {
    (*(dport->cbfn))(dport->cbarg, bfa_status);
    dport->cbfn = (void (*)(void * , enum bfa_status  ))0;
    dport->cbarg = (void *)0;
  } else {

  }
  return;
}
}
static void bfa_dport_sm_disabled(struct bfa_dport_s *dport , enum bfa_dport_sm_event event ) 
{ 
  enum bfa_boolean tmp ;
  int __ret_warn_on ;
  long tmp___0 ;

  {
  __bfa_trc((dport->bfa)->trcmod, __trc_fileno___13, 6304, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 1U: 
  bfa_fcport_dportenable(dport->bfa);
  tmp = bfa_dport_send_req(dport, 1);
  if ((unsigned int )tmp != 0U) {
    dport->sm = (void (*)(void * , int  ))(& bfa_dport_sm_enabling);
  } else {
    dport->sm = (void (*)(void * , int  ))(& bfa_dport_sm_enabling_qwait);
  }
  goto ldv_50602;
  case 2U: ;
  goto ldv_50602;
  case 5U: ;
  goto ldv_50602;
  case 8U: ;
  if ((unsigned int )dport->i2hmsg.scn.state == 4U) {
    bfa_fcport_ddportenable(dport->bfa);
    dport->dynamic = 1U;
    dport->test_state = 4U;
    dport->sm = (void (*)(void * , int  ))(& bfa_dport_sm_enabled);
  } else {
    __bfa_trc((dport->bfa)->trcmod, __trc_fileno___13, 6330, (unsigned long long )dport->i2hmsg.scn.state);
    __ret_warn_on = 1;
    tmp___0 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
    if (tmp___0 != 0L) {
      warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_svc.c",
                         6331);
    } else {

    }
    ldv__builtin_expect(__ret_warn_on != 0, 0L);
  }
  goto ldv_50602;
  default: 
  __bfa_trc((dport->bfa)->trcmod, __trc_fileno___13, 6336, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_svc.c",
         6336, (unsigned int )event);
  }
  ldv_50602: ;
  return;
}
}
static void bfa_dport_sm_enabling_qwait(struct bfa_dport_s *dport , enum bfa_dport_sm_event event ) 
{ 


  {
  __bfa_trc((dport->bfa)->trcmod, __trc_fileno___13, 6344, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 4U: 
  dport->sm = (void (*)(void * , int  ))(& bfa_dport_sm_enabling);
  bfa_dport_send_req(dport, 1);
  goto ldv_50614;
  case 5U: 
  list_del(& dport->reqq_wait.qe);
  dport->sm = (void (*)(void * , int  ))(& bfa_dport_sm_disabled);
  bfa_cb_fcdiag_dport(dport, 1);
  goto ldv_50614;
  default: 
  __bfa_trc((dport->bfa)->trcmod, __trc_fileno___13, 6359, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_svc.c",
         6359, (unsigned int )event);
  }
  ldv_50614: ;
  return;
}
}
static void bfa_dport_sm_enabling(struct bfa_dport_s *dport , enum bfa_dport_sm_event event ) 
{ 


  {
  __bfa_trc((dport->bfa)->trcmod, __trc_fileno___13, 6366, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 3U: 
  memset((void *)(& dport->result), 0, 120UL);
  if ((unsigned int )dport->i2hmsg.rsp.status == 271U) {
    dport->test_state = 3U;
  } else {
    dport->test_state = 1U;
    dport->result.start_time = bfa_get_log_time();
    dport->result.status = 4U;
    dport->result.mode = 0U;
    dport->result.rp_pwwn = dport->rp_pwwn;
    dport->result.rp_nwwn = dport->rp_nwwn;
    dport->result.lpcnt = dport->lpcnt;
  }
  dport->sm = (void (*)(void * , int  ))(& bfa_dport_sm_enabled);
  goto ldv_50622;
  case 7U: 
  dport->test_state = 0U;
  bfa_fcport_dportdisable(dport->bfa);
  dport->sm = (void (*)(void * , int  ))(& bfa_dport_sm_disabled);
  goto ldv_50622;
  case 5U: 
  dport->sm = (void (*)(void * , int  ))(& bfa_dport_sm_disabled);
  bfa_cb_fcdiag_dport(dport, 1);
  goto ldv_50622;
  default: 
  __bfa_trc((dport->bfa)->trcmod, __trc_fileno___13, 6393, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_svc.c",
         6393, (unsigned int )event);
  }
  ldv_50622: ;
  return;
}
}
static void bfa_dport_sm_enabled(struct bfa_dport_s *dport , enum bfa_dport_sm_event event ) 
{ 
  enum bfa_boolean tmp ;
  enum bfa_boolean tmp___0 ;
  enum bfa_boolean tmp___1 ;

  {
  __bfa_trc((dport->bfa)->trcmod, __trc_fileno___13, 6400, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 6U: 
  tmp = bfa_dport_send_req(dport, 2);
  if ((unsigned int )tmp != 0U) {
    dport->sm = (void (*)(void * , int  ))(& bfa_dport_sm_starting);
  } else {
    dport->sm = (void (*)(void * , int  ))(& bfa_dport_sm_starting_qwait);
  }
  goto ldv_50631;
  case 2U: 
  bfa_fcport_dportdisable(dport->bfa);
  tmp___0 = bfa_dport_send_req(dport, 0);
  if ((unsigned int )tmp___0 != 0U) {
    dport->sm = (void (*)(void * , int  ))(& bfa_dport_sm_disabling);
  } else {
    dport->sm = (void (*)(void * , int  ))(& bfa_dport_sm_disabling_qwait);
  }
  goto ldv_50631;
  case 5U: 
  dport->sm = (void (*)(void * , int  ))(& bfa_dport_sm_disabled);
  goto ldv_50631;
  case 8U: ;
  switch ((int )dport->i2hmsg.scn.state) {
  case 2: 
  dport->test_state = 2U;
  goto ldv_50636;
  case 1: 
  dport->test_state = 1U;
  goto ldv_50636;
  case 8: ;
  case 7: ;
  goto ldv_50636;
  case 3: 
  dport->test_state = 3U;
  goto ldv_50636;
  case 5: 
  bfa_fcport_ddportdisable(dport->bfa);
  tmp___1 = bfa_dport_send_req(dport, 4);
  if ((unsigned int )tmp___1 != 0U) {
    dport->sm = (void (*)(void * , int  ))(& bfa_dport_sm_dynamic_disabling);
  } else {
    dport->sm = (void (*)(void * , int  ))(& bfa_dport_sm_dynamic_disabling_qwait);
  }
  goto ldv_50636;
  case 6: 
  bfa_fcport_ddportdisable(dport->bfa);
  dport->sm = (void (*)(void * , int  ))(& bfa_dport_sm_disabled);
  dport->dynamic = 0U;
  goto ldv_50636;
  default: 
  __bfa_trc((dport->bfa)->trcmod, __trc_fileno___13, 6460, (unsigned long long )dport->i2hmsg.scn.state);
  __bfa_trc((dport->bfa)->trcmod, __trc_fileno___13, 6461, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_svc.c",
         6461, (unsigned int )event);
  }
  ldv_50636: ;
  goto ldv_50631;
  default: 
  __bfa_trc((dport->bfa)->trcmod, __trc_fileno___13, 6465, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_svc.c",
         6465, (unsigned int )event);
  }
  ldv_50631: ;
  return;
}
}
static void bfa_dport_sm_disabling_qwait(struct bfa_dport_s *dport , enum bfa_dport_sm_event event ) 
{ 


  {
  __bfa_trc((dport->bfa)->trcmod, __trc_fileno___13, 6473, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 4U: 
  dport->sm = (void (*)(void * , int  ))(& bfa_dport_sm_disabling);
  bfa_dport_send_req(dport, 0);
  goto ldv_50650;
  case 5U: 
  dport->sm = (void (*)(void * , int  ))(& bfa_dport_sm_disabled);
  list_del(& dport->reqq_wait.qe);
  bfa_cb_fcdiag_dport(dport, 0);
  goto ldv_50650;
  case 8U: ;
  goto ldv_50650;
  default: 
  __bfa_trc((dport->bfa)->trcmod, __trc_fileno___13, 6492, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_svc.c",
         6492, (unsigned int )event);
  }
  ldv_50650: ;
  return;
}
}
static void bfa_dport_sm_disabling(struct bfa_dport_s *dport , enum bfa_dport_sm_event event ) 
{ 


  {
  __bfa_trc((dport->bfa)->trcmod, __trc_fileno___13, 6499, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 3U: 
  dport->test_state = 0U;
  dport->sm = (void (*)(void * , int  ))(& bfa_dport_sm_disabled);
  goto ldv_50659;
  case 5U: 
  dport->sm = (void (*)(void * , int  ))(& bfa_dport_sm_disabled);
  bfa_cb_fcdiag_dport(dport, 0);
  goto ldv_50659;
  case 8U: ;
  goto ldv_50659;
  default: 
  __bfa_trc((dport->bfa)->trcmod, __trc_fileno___13, 6517, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_svc.c",
         6517, (unsigned int )event);
  }
  ldv_50659: ;
  return;
}
}
static void bfa_dport_sm_starting_qwait(struct bfa_dport_s *dport , enum bfa_dport_sm_event event ) 
{ 


  {
  __bfa_trc((dport->bfa)->trcmod, __trc_fileno___13, 6525, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 4U: 
  dport->sm = (void (*)(void * , int  ))(& bfa_dport_sm_starting);
  bfa_dport_send_req(dport, 2);
  goto ldv_50668;
  case 5U: 
  list_del(& dport->reqq_wait.qe);
  dport->sm = (void (*)(void * , int  ))(& bfa_dport_sm_disabled);
  bfa_cb_fcdiag_dport(dport, 1);
  goto ldv_50668;
  default: 
  __bfa_trc((dport->bfa)->trcmod, __trc_fileno___13, 6540, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_svc.c",
         6540, (unsigned int )event);
  }
  ldv_50668: ;
  return;
}
}
static void bfa_dport_sm_starting(struct bfa_dport_s *dport , enum bfa_dport_sm_event event ) 
{ 


  {
  __bfa_trc((dport->bfa)->trcmod, __trc_fileno___13, 6547, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 3U: 
  memset((void *)(& dport->result), 0, 120UL);
  if ((unsigned int )dport->i2hmsg.rsp.status == 271U) {
    dport->test_state = 3U;
  } else {
    dport->test_state = 1U;
    dport->result.start_time = bfa_get_log_time();
    dport->result.status = 4U;
    dport->result.mode = 1U;
    dport->result.rp_pwwn = dport->rp_pwwn;
    dport->result.rp_nwwn = dport->rp_nwwn;
    dport->result.lpcnt = dport->lpcnt;
  }
  case 7U: 
  dport->sm = (void (*)(void * , int  ))(& bfa_dport_sm_enabled);
  goto ldv_50677;
  case 5U: 
  dport->sm = (void (*)(void * , int  ))(& bfa_dport_sm_disabled);
  bfa_cb_fcdiag_dport(dport, 1);
  goto ldv_50677;
  default: 
  __bfa_trc((dport->bfa)->trcmod, __trc_fileno___13, 6571, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_svc.c",
         6571, (unsigned int )event);
  }
  ldv_50677: ;
  return;
}
}
static void bfa_dport_sm_dynamic_disabling(struct bfa_dport_s *dport , enum bfa_dport_sm_event event ) 
{ 


  {
  __bfa_trc((dport->bfa)->trcmod, __trc_fileno___13, 6579, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 8U: ;
  switch ((int )dport->i2hmsg.scn.state) {
  case 9: 
  dport->sm = (void (*)(void * , int  ))(& bfa_dport_sm_disabled);
  dport->dynamic = 0U;
  bfa_fcport_enable(dport->bfa);
  goto ldv_50686;
  default: 
  __bfa_trc((dport->bfa)->trcmod, __trc_fileno___13, 6591, (unsigned long long )dport->i2hmsg.scn.state);
  __bfa_trc((dport->bfa)->trcmod, __trc_fileno___13, 6592, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_svc.c",
         6592, (unsigned int )event);
  }
  ldv_50686: ;
  goto ldv_50688;
  case 5U: 
  dport->sm = (void (*)(void * , int  ))(& bfa_dport_sm_disabled);
  bfa_cb_fcdiag_dport(dport, 0);
  goto ldv_50688;
  default: 
  __bfa_trc((dport->bfa)->trcmod, __trc_fileno___13, 6603, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_svc.c",
         6603, (unsigned int )event);
  }
  ldv_50688: ;
  return;
}
}
static void bfa_dport_sm_dynamic_disabling_qwait(struct bfa_dport_s *dport , enum bfa_dport_sm_event event ) 
{ 


  {
  __bfa_trc((dport->bfa)->trcmod, __trc_fileno___13, 6611, (unsigned long long )event);
  switch ((unsigned int )event) {
  case 4U: 
  dport->sm = (void (*)(void * , int  ))(& bfa_dport_sm_dynamic_disabling);
  bfa_dport_send_req(dport, 4);
  goto ldv_50696;
  case 5U: 
  dport->sm = (void (*)(void * , int  ))(& bfa_dport_sm_disabled);
  list_del(& dport->reqq_wait.qe);
  bfa_cb_fcdiag_dport(dport, 0);
  goto ldv_50696;
  case 8U: ;
  goto ldv_50696;
  default: 
  __bfa_trc((dport->bfa)->trcmod, __trc_fileno___13, 6630, (unsigned long long )((unsigned int )event | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_svc.c",
         6630, (unsigned int )event);
  }
  ldv_50696: ;
  return;
}
}
static enum bfa_boolean bfa_dport_send_req(struct bfa_dport_s *dport , enum bfi_dport_req req ) 
{ 
  struct bfi_diag_dport_req_s *m ;
  struct list_head *waitq ;
  int __ret_warn_on ;
  long tmp ;
  int __ret_warn_on___0 ;
  long tmp___0 ;
  __u32 tmp___1 ;
  __u32 tmp___2 ;

  {
  m = (((dport->bfa)->iocfc.req_cq_pi[0] + 1U) & (u32 )((int )(dport->bfa)->iocfc.cfg.drvcfg.num_reqq_elems + -1)) != *((u32 *)(dport->bfa)->iocfc.req_cq_shadow_ci[0].kva) ? (struct bfi_diag_dport_req_s *)(dport->bfa)->iocfc.req_cq_ba[0].kva + (unsigned long )(dport->bfa)->iocfc.req_cq_pi[0] : (struct bfi_diag_dport_req_s *)0;
  if ((unsigned long )m == (unsigned long )((struct bfi_diag_dport_req_s *)0)) {
    waitq = (struct list_head *)(& (dport->bfa)->reqq_waitq);
    __ret_warn_on = 0;
    tmp = ldv__builtin_expect(__ret_warn_on != 0, 0L);
    if (tmp != 0L) {
      warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_svc.c",
                         6644);
    } else {

    }
    ldv__builtin_expect(__ret_warn_on != 0, 0L);
    __ret_warn_on___0 = (unsigned long )dport->reqq_wait.qresume == (unsigned long )((void (*)(void * ))0) || (unsigned long )dport->reqq_wait.cbarg == (unsigned long )((void *)0);
    tmp___0 = ldv__builtin_expect(__ret_warn_on___0 != 0, 0L);
    if (tmp___0 != 0L) {
      warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_svc.c",
                         6644);
    } else {

    }
    ldv__builtin_expect(__ret_warn_on___0 != 0, 0L);
    list_add_tail(& dport->reqq_wait.qe, waitq);
    return (0);
  } else {

  }
  m->mh.msg_class = 2U;
  m->mh.msg_id = 7U;
  m->mh.mtag.h2i.fn_lpu = (u8 )((int )((signed char )((int )(dport->bfa)->ioc.pcidev.pci_func << 1)) | (int )((signed char )(dport->bfa)->ioc.port_id));
  m->req = (u8 )req;
  if ((unsigned int )req == 1U || (unsigned int )req == 2U) {
    tmp___1 = __fswab32(dport->lpcnt);
    m->lpcnt = tmp___1;
    tmp___2 = __fswab32(dport->payload);
    m->payload = tmp___2;
  } else {

  }
  m->mh.mtag.h2i.qid = (dport->bfa)->iocfc.hw_qid[0];
  (dport->bfa)->iocfc.req_cq_pi[0] = (dport->bfa)->iocfc.req_cq_pi[0] + 1U;
  (dport->bfa)->iocfc.req_cq_pi[0] = (dport->bfa)->iocfc.req_cq_pi[0] & (u32 )((int )(dport->bfa)->iocfc.cfg.drvcfg.num_reqq_elems + -1);
  writel((dport->bfa)->iocfc.req_cq_pi[0], (void volatile   *)(dport->bfa)->iocfc.bfa_regs.cpe_q_pi[0]);
  __asm__  volatile   ("": : : "memory");
  return (1);
}
}
static void bfa_dport_qresume(void *cbarg ) 
{ 
  struct bfa_dport_s *dport ;

  {
  dport = (struct bfa_dport_s *)cbarg;
  (*(dport->sm))((void *)dport, 4);
  return;
}
}
static void bfa_dport_req_comp(struct bfa_dport_s *dport , struct bfi_diag_dport_rsp_s *msg ) 
{ 
  __u32 tmp ;

  {
  tmp = __fswab32((__u32 )msg->status);
  msg->status = (enum bfa_status )tmp;
  dport->i2hmsg.rsp.status = msg->status;
  dport->rp_pwwn = msg->pwwn;
  dport->rp_nwwn = msg->nwwn;
  if ((unsigned int )msg->status == 0U || (unsigned int )msg->status == 243U) {
    __bfa_trc((dport->bfa)->trcmod, __trc_fileno___13, 6682, (unsigned long long )msg->status);
    __bfa_trc((dport->bfa)->trcmod, __trc_fileno___13, 6683, dport->rp_pwwn);
    __bfa_trc((dport->bfa)->trcmod, __trc_fileno___13, 6684, dport->rp_nwwn);
    (*(dport->sm))((void *)dport, 3);
  } else {
    __bfa_trc((dport->bfa)->trcmod, __trc_fileno___13, 6688, (unsigned long long )msg->status);
    (*(dport->sm))((void *)dport, 7);
  }
  bfa_cb_fcdiag_dport(dport, msg->status);
  return;
}
}
static enum bfa_boolean bfa_dport_is_sending_req(struct bfa_dport_s *dport ) 
{ 


  {
  if ((((((unsigned long )dport->sm == (unsigned long )((void (*)(void * , int  ))(& bfa_dport_sm_enabling)) || (unsigned long )dport->sm == (unsigned long )((void (*)(void * ,
                                                                                                                                                                        int  ))(& bfa_dport_sm_enabling_qwait))) || (unsigned long )dport->sm == (unsigned long )((void (*)(void * ,
                                                                                                                                                                                                                                                                            int  ))(& bfa_dport_sm_disabling))) || (unsigned long )dport->sm == (unsigned long )((void (*)(void * ,
                                                                                                                                                                                                                                                                                                                                                                           int  ))(& bfa_dport_sm_disabling_qwait))) || (unsigned long )dport->sm == (unsigned long )((void (*)(void * ,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                int  ))(& bfa_dport_sm_starting))) || (unsigned long )dport->sm == (unsigned long )((void (*)(void * ,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              int  ))(& bfa_dport_sm_starting_qwait))) {
    return (1);
  } else {
    return (0);
  }
}
}
static void bfa_dport_scn(struct bfa_dport_s *dport , struct bfi_diag_dport_scn_s *msg ) 
{ 
  int i ;
  uint8_t subtesttype ;
  __u32 tmp ;
  __u32 tmp___0 ;
  __u16 tmp___1 ;
  __u16 tmp___2 ;
  __u32 tmp___3 ;

  {
  __bfa_trc((dport->bfa)->trcmod, __trc_fileno___13, 6715, (unsigned long long )msg->state);
  dport->i2hmsg.scn.state = msg->state;
  switch ((int )dport->i2hmsg.scn.state) {
  case 2: 
  dport->result.end_time = bfa_get_log_time();
  __bfa_trc((dport->bfa)->trcmod, __trc_fileno___13, 6721, dport->result.end_time);
  dport->result.status = msg->info.testcomp.status;
  __bfa_trc((dport->bfa)->trcmod, __trc_fileno___13, 6724, (unsigned long long )dport->result.status);
  tmp = __fswab32(msg->info.testcomp.latency);
  dport->result.roundtrip_latency = tmp;
  tmp___0 = __fswab32(msg->info.testcomp.distance);
  dport->result.est_cable_distance = tmp___0;
  tmp___1 = __fswab16((int )msg->info.testcomp.numbuffer);
  dport->result.buffer_required = tmp___1;
  tmp___2 = __fswab16((int )msg->info.testcomp.frm_sz);
  dport->result.frmsz = tmp___2;
  dport->result.speed = msg->info.testcomp.speed;
  __bfa_trc((dport->bfa)->trcmod, __trc_fileno___13, 6736, (unsigned long long )dport->result.roundtrip_latency);
  __bfa_trc((dport->bfa)->trcmod, __trc_fileno___13, 6737, (unsigned long long )dport->result.est_cable_distance);
  __bfa_trc((dport->bfa)->trcmod, __trc_fileno___13, 6738, (unsigned long long )dport->result.buffer_required);
  __bfa_trc((dport->bfa)->trcmod, __trc_fileno___13, 6739, (unsigned long long )dport->result.frmsz);
  __bfa_trc((dport->bfa)->trcmod, __trc_fileno___13, 6740, (unsigned long long )dport->result.speed);
  i = 0;
  goto ldv_50729;
  ldv_50728: 
  dport->result.subtest[i].status = msg->info.testcomp.subtest_status[i];
  __bfa_trc((dport->bfa)->trcmod, __trc_fileno___13, 6745, (unsigned long long )dport->result.subtest[i].status);
  i = i + 1;
  ldv_50729: ;
  if (i <= 3) {
    goto ldv_50728;
  } else {

  }

  goto ldv_50731;
  case 8: ;
  case 4: 
  memset((void *)(& dport->result), 0, 120UL);
  goto ldv_50731;
  case 1: 
  memset((void *)(& dport->result), 0, 120UL);
  dport->rp_pwwn = msg->info.teststart.pwwn;
  dport->rp_nwwn = msg->info.teststart.nwwn;
  tmp___3 = __fswab32(msg->info.teststart.numfrm);
  dport->lpcnt = tmp___3;
  dport->result.start_time = bfa_get_log_time();
  dport->result.status = 4U;
  dport->result.mode = msg->info.teststart.mode;
  dport->result.rp_pwwn = dport->rp_pwwn;
  dport->result.rp_nwwn = dport->rp_nwwn;
  dport->result.lpcnt = dport->lpcnt;
  goto ldv_50731;
  case 7: 
  subtesttype = msg->info.teststart.type;
  dport->result.subtest[(int )subtesttype].start_time = bfa_get_log_time();
  dport->result.subtest[(int )subtesttype].status = 4U;
  __bfa_trc((dport->bfa)->trcmod, __trc_fileno___13, 6771, (unsigned long long )subtesttype);
  __bfa_trc((dport->bfa)->trcmod, __trc_fileno___13, 6773, dport->result.subtest[(int )subtesttype].start_time);
  goto ldv_50731;
  case 3: ;
  case 9: ;
  case 5: ;
  case 6: 
  dport->result.status = 0U;
  goto ldv_50731;
  default: 
  __bfa_trc((dport->bfa)->trcmod, __trc_fileno___13, 6784, (unsigned long long )((unsigned int )msg->state | 3735879680U));
  printk("\vAssertion failure: %s:%d: %d", (char *)"/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_svc.c",
         6784, (int )msg->state);
  }
  ldv_50731: 
  (*(dport->sm))((void *)dport, 8);
  return;
}
}
enum bfa_status bfa_dport_enable(struct bfa_s *bfa , u32 lpcnt , u32 pat , void (*cbfn)(void * ,
                                                                                        enum bfa_status  ) ,
                                 void *cbarg ) 
{ 
  struct bfa_fcdiag_s *fcdiag ;
  struct bfa_dport_s *dport ;
  enum bfa_boolean tmp ;
  enum bfa_status tmp___0 ;
  enum bfa_ioc_type_e tmp___1 ;
  enum bfa_ioc_type_e tmp___2 ;
  enum bfa_port_topology tmp___3 ;
  enum bfa_port_topology tmp___4 ;
  enum bfa_boolean tmp___5 ;
  enum bfa_status tmp___6 ;
  enum bfa_boolean tmp___7 ;
  enum bfa_boolean tmp___8 ;
  enum bfa_boolean tmp___9 ;

  {
  fcdiag = & bfa->modules.fcdiag;
  dport = & fcdiag->dport;
  if ((((((((dport->bfa)->ioc.attr)->card_type == 804U || ((dport->bfa)->ioc.attr)->card_type == 1007U) || ((dport->bfa)->ioc.attr)->card_type == 807U) || ((dport->bfa)->ioc.attr)->card_type == 902U) || ((dport->bfa)->ioc.attr)->card_type == 1741U) || ((dport->bfa)->ioc.attr)->card_type == 1867U) || ((dport->bfa)->ioc.attr)->card_type == 1869U) {
    __bfa_trc((dport->bfa)->trcmod, __trc_fileno___13, 6806, 154ULL);
    return (239);
  } else {

  }
  if ((unsigned int )(dport->bfa)->ioc.pcidev.device_id != 34U && (unsigned int )(dport->bfa)->ioc.pcidev.device_id != 35U) {
    __bfa_trc((dport->bfa)->trcmod, __trc_fileno___13, 6814, (unsigned long long )(dport->bfa)->ioc.pcidev.device_id);
    return (192);
  } else {

  }
  tmp = bfa_iocfc_is_operational(bfa);
  if ((unsigned int )tmp == 0U) {
    return (61);
  } else {

  }
  tmp___0 = bfa_fcport_is_pbcdisabled(bfa);
  if ((unsigned int )tmp___0 != 0U) {
    __bfa_trc((dport->bfa)->trcmod, __trc_fileno___13, 6826, 154ULL);
    return (154);
  } else {

  }
  tmp___2 = bfa_ioc_get_type(& bfa->ioc);
  if ((unsigned int )tmp___2 != 1U) {
    tmp___1 = bfa_ioc_get_type(& bfa->ioc);
    __bfa_trc((dport->bfa)->trcmod, __trc_fileno___13, 6834, (unsigned long long )tmp___1);
    return (146);
  } else {

  }
  tmp___3 = bfa_fcport_get_cfg_topology(bfa);
  if ((unsigned int )tmp___3 == 2U) {
    __bfa_trc((dport->bfa)->trcmod, __trc_fileno___13, 6843, 0ULL);
    return (230);
  } else {
    tmp___4 = bfa_fcport_get_topology(bfa);
    if ((unsigned int )tmp___4 == 2U) {
      __bfa_trc((dport->bfa)->trcmod, __trc_fileno___13, 6843, 0ULL);
      return (230);
    } else {

    }
  }
  tmp___5 = bfa_fcport_is_trunk_enabled(bfa);
  if ((unsigned int )tmp___5 != 0U) {
    __bfa_trc((dport->bfa)->trcmod, __trc_fileno___13, 6851, 0ULL);
    return (203);
  } else {

  }
  tmp___6 = bfa_fcdiag_lb_is_running(bfa);
  if ((unsigned int )tmp___6 != 0U) {
    __bfa_trc((dport->bfa)->trcmod, __trc_fileno___13, 6859, 0ULL);
    return (71);
  } else {

  }
  tmp___7 = bfa_fcport_is_disabled(bfa);
  if ((unsigned int )tmp___7 == 0U) {
    tmp___8 = bfa_fcport_is_dport(bfa);
    if ((unsigned int )tmp___8 == 0U) {
      __bfa_trc((dport->bfa)->trcmod, __trc_fileno___13, 6868, 0ULL);
      return (47);
    } else {

    }
  } else {

  }
  if ((unsigned int )dport->dynamic != 0U) {
    return (261);
  } else {

  }
  tmp___9 = bfa_dport_is_sending_req(dport);
  if ((unsigned int )tmp___9 != 0U) {
    return (13);
  } else {

  }
  if ((unsigned long )dport->sm == (unsigned long )((void (*)(void * , int  ))(& bfa_dport_sm_enabled))) {
    __bfa_trc((dport->bfa)->trcmod, __trc_fileno___13, 6888, 0ULL);
    return (235);
  } else {

  }
  __bfa_trc((dport->bfa)->trcmod, __trc_fileno___13, 6892, (unsigned long long )lpcnt);
  __bfa_trc((dport->bfa)->trcmod, __trc_fileno___13, 6893, (unsigned long long )pat);
  dport->lpcnt = lpcnt != 0U ? lpcnt : 1048576U;
  dport->payload = pat != 0U ? pat : 3048584629U;
  dport->cbfn = cbfn;
  dport->cbarg = cbarg;
  (*(dport->sm))((void *)dport, 1);
  return (0);
}
}
enum bfa_status bfa_dport_disable(struct bfa_s *bfa , void (*cbfn)(void * , enum bfa_status  ) ,
                                  void *cbarg ) 
{ 
  struct bfa_fcdiag_s *fcdiag ;
  struct bfa_dport_s *dport ;
  enum bfa_boolean tmp ;
  enum bfa_status tmp___0 ;
  enum bfa_boolean tmp___1 ;
  enum bfa_boolean tmp___2 ;
  enum bfa_boolean tmp___3 ;

  {
  fcdiag = & bfa->modules.fcdiag;
  dport = & fcdiag->dport;
  tmp = bfa_ioc_is_disabled(& bfa->ioc);
  if ((unsigned int )tmp != 0U) {
    return (82);
  } else {

  }
  tmp___0 = bfa_fcport_is_pbcdisabled(bfa);
  if ((unsigned int )tmp___0 != 0U) {
    __bfa_trc((dport->bfa)->trcmod, __trc_fileno___13, 6919, 154ULL);
    return (154);
  } else {

  }
  if ((unsigned int )dport->dynamic != 0U) {
    return (261);
  } else {

  }
  tmp___1 = bfa_fcport_is_disabled(bfa);
  if ((unsigned int )tmp___1 == 0U) {
    tmp___2 = bfa_fcport_is_dport(bfa);
    if ((unsigned int )tmp___2 == 0U) {
      __bfa_trc((dport->bfa)->trcmod, __trc_fileno___13, 6935, 0ULL);
      return (47);
    } else {

    }
  } else {

  }
  tmp___3 = bfa_dport_is_sending_req(dport);
  if ((unsigned int )tmp___3 != 0U) {
    return (13);
  } else {

  }
  if ((unsigned long )dport->sm == (unsigned long )((void (*)(void * , int  ))(& bfa_dport_sm_disabled))) {
    __bfa_trc((dport->bfa)->trcmod, __trc_fileno___13, 6949, 0ULL);
    return (236);
  } else {

  }
  dport->cbfn = cbfn;
  dport->cbarg = cbarg;
  (*(dport->sm))((void *)dport, 2);
  return (0);
}
}
enum bfa_status bfa_dport_start(struct bfa_s *bfa , u32 lpcnt , u32 pat , void (*cbfn)(void * ,
                                                                                       enum bfa_status  ) ,
                                void *cbarg ) 
{ 
  struct bfa_fcdiag_s *fcdiag ;
  struct bfa_dport_s *dport ;
  enum bfa_boolean tmp ;
  enum bfa_boolean tmp___0 ;
  int __ret_warn_on ;
  long tmp___1 ;

  {
  fcdiag = & bfa->modules.fcdiag;
  dport = & fcdiag->dport;
  tmp = bfa_iocfc_is_operational(bfa);
  if ((unsigned int )tmp == 0U) {
    return (61);
  } else {

  }
  if ((unsigned int )dport->dynamic != 0U) {
    return (261);
  } else {

  }
  tmp___0 = bfa_dport_is_sending_req(dport);
  if ((unsigned int )tmp___0 != 0U) {
    return (13);
  } else {

  }
  if ((unsigned long )dport->sm != (unsigned long )((void (*)(void * , int  ))(& bfa_dport_sm_enabled))) {
    __bfa_trc((dport->bfa)->trcmod, __trc_fileno___13, 6995, 0ULL);
    return (236);
  } else {
    if ((unsigned int )dport->test_state == 3U) {
      return (271);
    } else {

    }
    if ((unsigned int )dport->test_state == 1U) {
      return (13);
    } else {

    }
    __ret_warn_on = (unsigned int )dport->test_state != 2U;
    tmp___1 = ldv__builtin_expect(__ret_warn_on != 0, 0L);
    if (tmp___1 != 0L) {
      warn_slowpath_null("/work/ldvuser/mutilin/launch/work/current--X--drivers/--X--defaultlinux-4.2-rc1.tar.xz--X--32_7a--X--cpachecker/linux-4.2-rc1.tar.xz/csd_deg_dscv/6185/dscv_tempdir/dscv/ri/32_7a/drivers/scsi/bfa/bfa_svc.c",
                         7005);
    } else {

    }
    ldv__builtin_expect(__ret_warn_on != 0, 0L);
  }
  __bfa_trc((dport->bfa)->trcmod, __trc_fileno___13, 7008, (unsigned long long )lpcnt);
  __bfa_trc((dport->bfa)->trcmod, __trc_fileno___13, 7009, (unsigned long long )pat);
  dport->lpcnt = lpcnt != 0U ? lpcnt : 1048576U;
  dport->payload = pat != 0U ? pat : 3048584629U;
  dport->cbfn = cbfn;
  dport->cbarg = cbarg;
  (*(dport->sm))((void *)dport, 6);
  return (0);
}
}
enum bfa_status bfa_dport_show(struct bfa_s *bfa , struct bfa_diag_dport_result_s *result ) 
{ 
  struct bfa_fcdiag_s *fcdiag ;
  struct bfa_dport_s *dport ;
  enum bfa_boolean tmp ;
  enum bfa_boolean tmp___0 ;

  {
  fcdiag = & bfa->modules.fcdiag;
  dport = & fcdiag->dport;
  tmp = bfa_iocfc_is_operational(bfa);
  if ((unsigned int )tmp == 0U) {
    return (61);
  } else {

  }
  tmp___0 = bfa_dport_is_sending_req(dport);
  if ((unsigned int )tmp___0 != 0U) {
    return (13);
  } else {

  }
  if ((unsigned long )dport->sm != (unsigned long )((void (*)(void * , int  ))(& bfa_dport_sm_enabled))) {
    __bfa_trc((dport->bfa)->trcmod, __trc_fileno___13, 7048, 0ULL);
    return (236);
  } else {

  }
  if ((unsigned int )dport->test_state == 3U) {
    return (271);
  } else {

  }
  memcpy((void *)result, (void const   *)(& dport->result), 120UL);
  return (0);
}
}
void ldv_initialize_bfa_module_s_12(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
  tmp = ldv_init_zalloc(56UL);
  hal_mod_fcxp_group0 = (struct bfa_iocfc_cfg_s *)tmp;
  tmp___0 = ldv_init_zalloc(9688UL);
  hal_mod_fcxp_group1 = (struct bfa_s *)tmp___0;
  return;
}
}
void ldv_initialize_bfa_module_s_13(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
  tmp = ldv_init_zalloc(56UL);
  hal_mod_fcdiag_group0 = (struct bfa_iocfc_cfg_s *)tmp;
  tmp___0 = ldv_init_zalloc(9688UL);
  hal_mod_fcdiag_group1 = (struct bfa_s *)tmp___0;
  return;
}
}
void ldv_initialize_bfa_module_s_9(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
  tmp = ldv_init_zalloc(56UL);
  hal_mod_fcport_group0 = (struct bfa_iocfc_cfg_s *)tmp;
  tmp___0 = ldv_init_zalloc(9688UL);
  hal_mod_fcport_group1 = (struct bfa_s *)tmp___0;
  return;
}
}
void ldv_initialize_bfa_module_s_11(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
  tmp = ldv_init_zalloc(56UL);
  hal_mod_sgpg_group0 = (struct bfa_iocfc_cfg_s *)tmp;
  tmp___0 = ldv_init_zalloc(9688UL);
  hal_mod_sgpg_group1 = (struct bfa_s *)tmp___0;
  return;
}
}
void ldv_initialize_bfa_module_s_7(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
  tmp = ldv_init_zalloc(56UL);
  hal_mod_uf_group0 = (struct bfa_iocfc_cfg_s *)tmp;
  tmp___0 = ldv_init_zalloc(9688UL);
  hal_mod_uf_group1 = (struct bfa_s *)tmp___0;
  return;
}
}
void ldv_initialize_bfa_module_s_8(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
  tmp = ldv_init_zalloc(56UL);
  hal_mod_rport_group0 = (struct bfa_iocfc_cfg_s *)tmp;
  tmp___0 = ldv_init_zalloc(9688UL);
  hal_mod_rport_group1 = (struct bfa_s *)tmp___0;
  return;
}
}
void ldv_initialize_bfa_module_s_10(void) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
  tmp = ldv_init_zalloc(56UL);
  hal_mod_lps_group0 = (struct bfa_iocfc_cfg_s *)tmp;
  tmp___0 = ldv_init_zalloc(9688UL);
  hal_mod_lps_group1 = (struct bfa_s *)tmp___0;
  return;
}
}
void ldv_main_exported_8(void) 
{ 
  struct bfa_pcidev_s *ldvarg86 ;
  void *tmp ;
  void *ldvarg87 ;
  void *tmp___0 ;
  struct bfa_meminfo_s *ldvarg88 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
  tmp = ldv_init_zalloc(24UL);
  ldvarg86 = (struct bfa_pcidev_s *)tmp;
  tmp___0 = ldv_init_zalloc(1UL);
  ldvarg87 = tmp___0;
  tmp___1 = ldv_init_zalloc(96UL);
  ldvarg88 = (struct bfa_meminfo_s *)tmp___1;
  tmp___2 = __VERIFIER_nondet_int();
  switch (tmp___2) {
  case 0: ;
  if (ldv_state_variable_8 == 1) {
    bfa_rport_start(hal_mod_rport_group1);
    ldv_state_variable_8 = 1;
  } else {

  }
  goto ldv_50802;
  case 1: ;
  if (ldv_state_variable_8 == 1) {
    bfa_rport_iocdisable(hal_mod_rport_group1);
    ldv_state_variable_8 = 1;
  } else {

  }
  goto ldv_50802;
  case 2: ;
  if (ldv_state_variable_8 == 1) {
    bfa_rport_meminfo(hal_mod_rport_group0, ldvarg88, hal_mod_rport_group1);
    ldv_state_variable_8 = 1;
  } else {

  }
  goto ldv_50802;
  case 3: ;
  if (ldv_state_variable_8 == 1) {
    bfa_rport_stop(hal_mod_rport_group1);
    ldv_state_variable_8 = 1;
  } else {

  }
  goto ldv_50802;
  case 4: ;
  if (ldv_state_variable_8 == 1) {
    bfa_rport_attach(hal_mod_rport_group1, ldvarg87, hal_mod_rport_group0, ldvarg86);
    ldv_state_variable_8 = 1;
  } else {

  }
  goto ldv_50802;
  case 5: ;
  if (ldv_state_variable_8 == 1) {
    bfa_rport_detach(hal_mod_rport_group1);
    ldv_state_variable_8 = 1;
  } else {

  }
  goto ldv_50802;
  default: 
  ldv_stop();
  }
  ldv_50802: ;
  return;
}
}
void ldv_main_exported_11(void) 
{ 
  void *ldvarg62 ;
  void *tmp ;
  struct bfa_pcidev_s *ldvarg61 ;
  void *tmp___0 ;
  struct bfa_meminfo_s *ldvarg63 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
  tmp = ldv_init_zalloc(1UL);
  ldvarg62 = tmp;
  tmp___0 = ldv_init_zalloc(24UL);
  ldvarg61 = (struct bfa_pcidev_s *)tmp___0;
  tmp___1 = ldv_init_zalloc(96UL);
  ldvarg63 = (struct bfa_meminfo_s *)tmp___1;
  tmp___2 = __VERIFIER_nondet_int();
  switch (tmp___2) {
  case 0: ;
  if (ldv_state_variable_11 == 1) {
    bfa_sgpg_start(hal_mod_sgpg_group1);
    ldv_state_variable_11 = 1;
  } else {

  }
  goto ldv_50816;
  case 1: ;
  if (ldv_state_variable_11 == 1) {
    bfa_sgpg_iocdisable(hal_mod_sgpg_group1);
    ldv_state_variable_11 = 1;
  } else {

  }
  goto ldv_50816;
  case 2: ;
  if (ldv_state_variable_11 == 1) {
    bfa_sgpg_meminfo(hal_mod_sgpg_group0, ldvarg63, hal_mod_sgpg_group1);
    ldv_state_variable_11 = 1;
  } else {

  }
  goto ldv_50816;
  case 3: ;
  if (ldv_state_variable_11 == 1) {
    bfa_sgpg_stop(hal_mod_sgpg_group1);
    ldv_state_variable_11 = 1;
  } else {

  }
  goto ldv_50816;
  case 4: ;
  if (ldv_state_variable_11 == 1) {
    bfa_sgpg_attach(hal_mod_sgpg_group1, ldvarg62, hal_mod_sgpg_group0, ldvarg61);
    ldv_state_variable_11 = 1;
  } else {

  }
  goto ldv_50816;
  case 5: ;
  if (ldv_state_variable_11 == 1) {
    bfa_sgpg_detach(hal_mod_sgpg_group1);
    ldv_state_variable_11 = 1;
  } else {

  }
  goto ldv_50816;
  default: 
  ldv_stop();
  }
  ldv_50816: ;
  return;
}
}
void ldv_main_exported_7(void) 
{ 
  void *ldvarg9 ;
  void *tmp ;
  struct bfa_meminfo_s *ldvarg10 ;
  void *tmp___0 ;
  struct bfa_pcidev_s *ldvarg8 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
  tmp = ldv_init_zalloc(1UL);
  ldvarg9 = tmp;
  tmp___0 = ldv_init_zalloc(96UL);
  ldvarg10 = (struct bfa_meminfo_s *)tmp___0;
  tmp___1 = ldv_init_zalloc(24UL);
  ldvarg8 = (struct bfa_pcidev_s *)tmp___1;
  tmp___2 = __VERIFIER_nondet_int();
  switch (tmp___2) {
  case 0: ;
  if (ldv_state_variable_7 == 1) {
    bfa_uf_start(hal_mod_uf_group1);
    ldv_state_variable_7 = 1;
  } else {

  }
  goto ldv_50830;
  case 1: ;
  if (ldv_state_variable_7 == 1) {
    bfa_uf_iocdisable(hal_mod_uf_group1);
    ldv_state_variable_7 = 1;
  } else {

  }
  goto ldv_50830;
  case 2: ;
  if (ldv_state_variable_7 == 1) {
    bfa_uf_meminfo(hal_mod_uf_group0, ldvarg10, hal_mod_uf_group1);
    ldv_state_variable_7 = 1;
  } else {

  }
  goto ldv_50830;
  case 3: ;
  if (ldv_state_variable_7 == 1) {
    bfa_uf_stop(hal_mod_uf_group1);
    ldv_state_variable_7 = 1;
  } else {

  }
  goto ldv_50830;
  case 4: ;
  if (ldv_state_variable_7 == 1) {
    bfa_uf_attach(hal_mod_uf_group1, ldvarg9, hal_mod_uf_group0, ldvarg8);
    ldv_state_variable_7 = 1;
  } else {

  }
  goto ldv_50830;
  case 5: ;
  if (ldv_state_variable_7 == 1) {
    bfa_uf_detach(hal_mod_uf_group1);
    ldv_state_variable_7 = 1;
  } else {

  }
  goto ldv_50830;
  default: 
  ldv_stop();
  }
  ldv_50830: ;
  return;
}
}
void ldv_main_exported_13(void) 
{ 
  struct bfa_meminfo_s *ldvarg69 ;
  void *tmp ;
  void *ldvarg68 ;
  void *tmp___0 ;
  struct bfa_pcidev_s *ldvarg67 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
  tmp = ldv_init_zalloc(96UL);
  ldvarg69 = (struct bfa_meminfo_s *)tmp;
  tmp___0 = ldv_init_zalloc(1UL);
  ldvarg68 = tmp___0;
  tmp___1 = ldv_init_zalloc(24UL);
  ldvarg67 = (struct bfa_pcidev_s *)tmp___1;
  tmp___2 = __VERIFIER_nondet_int();
  switch (tmp___2) {
  case 0: ;
  if (ldv_state_variable_13 == 1) {
    bfa_fcdiag_start(hal_mod_fcdiag_group1);
    ldv_state_variable_13 = 1;
  } else {

  }
  goto ldv_50844;
  case 1: ;
  if (ldv_state_variable_13 == 1) {
    bfa_fcdiag_iocdisable(hal_mod_fcdiag_group1);
    ldv_state_variable_13 = 1;
  } else {

  }
  goto ldv_50844;
  case 2: ;
  if (ldv_state_variable_13 == 1) {
    bfa_fcdiag_meminfo(hal_mod_fcdiag_group0, ldvarg69, hal_mod_fcdiag_group1);
    ldv_state_variable_13 = 1;
  } else {

  }
  goto ldv_50844;
  case 3: ;
  if (ldv_state_variable_13 == 1) {
    bfa_fcdiag_stop(hal_mod_fcdiag_group1);
    ldv_state_variable_13 = 1;
  } else {

  }
  goto ldv_50844;
  case 4: ;
  if (ldv_state_variable_13 == 1) {
    bfa_fcdiag_attach(hal_mod_fcdiag_group1, ldvarg68, hal_mod_fcdiag_group0, ldvarg67);
    ldv_state_variable_13 = 1;
  } else {

  }
  goto ldv_50844;
  case 5: ;
  if (ldv_state_variable_13 == 1) {
    bfa_fcdiag_detach(hal_mod_fcdiag_group1);
    ldv_state_variable_13 = 1;
  } else {

  }
  goto ldv_50844;
  default: 
  ldv_stop();
  }
  ldv_50844: ;
  return;
}
}
void ldv_main_exported_10(void) 
{ 
  void *ldvarg56 ;
  void *tmp ;
  struct bfa_pcidev_s *ldvarg55 ;
  void *tmp___0 ;
  struct bfa_meminfo_s *ldvarg57 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
  tmp = ldv_init_zalloc(1UL);
  ldvarg56 = tmp;
  tmp___0 = ldv_init_zalloc(24UL);
  ldvarg55 = (struct bfa_pcidev_s *)tmp___0;
  tmp___1 = ldv_init_zalloc(96UL);
  ldvarg57 = (struct bfa_meminfo_s *)tmp___1;
  tmp___2 = __VERIFIER_nondet_int();
  switch (tmp___2) {
  case 0: ;
  if (ldv_state_variable_10 == 1) {
    bfa_lps_start(hal_mod_lps_group1);
    ldv_state_variable_10 = 1;
  } else {

  }
  goto ldv_50858;
  case 1: ;
  if (ldv_state_variable_10 == 1) {
    bfa_lps_iocdisable(hal_mod_lps_group1);
    ldv_state_variable_10 = 1;
  } else {

  }
  goto ldv_50858;
  case 2: ;
  if (ldv_state_variable_10 == 1) {
    bfa_lps_meminfo(hal_mod_lps_group0, ldvarg57, hal_mod_lps_group1);
    ldv_state_variable_10 = 1;
  } else {

  }
  goto ldv_50858;
  case 3: ;
  if (ldv_state_variable_10 == 1) {
    bfa_lps_stop(hal_mod_lps_group1);
    ldv_state_variable_10 = 1;
  } else {

  }
  goto ldv_50858;
  case 4: ;
  if (ldv_state_variable_10 == 1) {
    bfa_lps_attach(hal_mod_lps_group1, ldvarg56, hal_mod_lps_group0, ldvarg55);
    ldv_state_variable_10 = 1;
  } else {

  }
  goto ldv_50858;
  case 5: ;
  if (ldv_state_variable_10 == 1) {
    bfa_lps_detach(hal_mod_lps_group1);
    ldv_state_variable_10 = 1;
  } else {

  }
  goto ldv_50858;
  default: 
  ldv_stop();
  }
  ldv_50858: ;
  return;
}
}
void ldv_main_exported_9(void) 
{ 
  struct bfa_pcidev_s *ldvarg76 ;
  void *tmp ;
  struct bfa_meminfo_s *ldvarg78 ;
  void *tmp___0 ;
  void *ldvarg77 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
  tmp = ldv_init_zalloc(24UL);
  ldvarg76 = (struct bfa_pcidev_s *)tmp;
  tmp___0 = ldv_init_zalloc(96UL);
  ldvarg78 = (struct bfa_meminfo_s *)tmp___0;
  tmp___1 = ldv_init_zalloc(1UL);
  ldvarg77 = tmp___1;
  tmp___2 = __VERIFIER_nondet_int();
  switch (tmp___2) {
  case 0: ;
  if (ldv_state_variable_9 == 1) {
    bfa_fcport_start(hal_mod_fcport_group1);
    ldv_state_variable_9 = 1;
  } else {

  }
  goto ldv_50872;
  case 1: ;
  if (ldv_state_variable_9 == 1) {
    bfa_fcport_iocdisable(hal_mod_fcport_group1);
    ldv_state_variable_9 = 1;
  } else {

  }
  goto ldv_50872;
  case 2: ;
  if (ldv_state_variable_9 == 1) {
    bfa_fcport_meminfo(hal_mod_fcport_group0, ldvarg78, hal_mod_fcport_group1);
    ldv_state_variable_9 = 1;
  } else {

  }
  goto ldv_50872;
  case 3: ;
  if (ldv_state_variable_9 == 1) {
    bfa_fcport_stop(hal_mod_fcport_group1);
    ldv_state_variable_9 = 1;
  } else {

  }
  goto ldv_50872;
  case 4: ;
  if (ldv_state_variable_9 == 1) {
    bfa_fcport_attach(hal_mod_fcport_group1, ldvarg77, hal_mod_fcport_group0, ldvarg76);
    ldv_state_variable_9 = 1;
  } else {

  }
  goto ldv_50872;
  case 5: ;
  if (ldv_state_variable_9 == 1) {
    bfa_fcport_detach(hal_mod_fcport_group1);
    ldv_state_variable_9 = 1;
  } else {

  }
  goto ldv_50872;
  default: 
  ldv_stop();
  }
  ldv_50872: ;
  return;
}
}
void ldv_main_exported_12(void) 
{ 
  void *ldvarg80 ;
  void *tmp ;
  struct bfa_pcidev_s *ldvarg79 ;
  void *tmp___0 ;
  struct bfa_meminfo_s *ldvarg81 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
  tmp = ldv_init_zalloc(1UL);
  ldvarg80 = tmp;
  tmp___0 = ldv_init_zalloc(24UL);
  ldvarg79 = (struct bfa_pcidev_s *)tmp___0;
  tmp___1 = ldv_init_zalloc(96UL);
  ldvarg81 = (struct bfa_meminfo_s *)tmp___1;
  tmp___2 = __VERIFIER_nondet_int();
  switch (tmp___2) {
  case 0: ;
  if (ldv_state_variable_12 == 1) {
    bfa_fcxp_start(hal_mod_fcxp_group1);
    ldv_state_variable_12 = 1;
  } else {

  }
  goto ldv_50886;
  case 1: ;
  if (ldv_state_variable_12 == 1) {
    bfa_fcxp_iocdisable(hal_mod_fcxp_group1);
    ldv_state_variable_12 = 1;
  } else {

  }
  goto ldv_50886;
  case 2: ;
  if (ldv_state_variable_12 == 1) {
    bfa_fcxp_meminfo(hal_mod_fcxp_group0, ldvarg81, hal_mod_fcxp_group1);
    ldv_state_variable_12 = 1;
  } else {

  }
  goto ldv_50886;
  case 3: ;
  if (ldv_state_variable_12 == 1) {
    bfa_fcxp_stop(hal_mod_fcxp_group1);
    ldv_state_variable_12 = 1;
  } else {

  }
  goto ldv_50886;
  case 4: ;
  if (ldv_state_variable_12 == 1) {
    bfa_fcxp_attach(hal_mod_fcxp_group1, ldvarg80, hal_mod_fcxp_group0, ldvarg79);
    ldv_state_variable_12 = 1;
  } else {

  }
  goto ldv_50886;
  case 5: ;
  if (ldv_state_variable_12 == 1) {
    bfa_fcxp_detach(hal_mod_fcxp_group1);
    ldv_state_variable_12 = 1;
  } else {

  }
  goto ldv_50886;
  default: 
  ldv_stop();
  }
  ldv_50886: ;
  return;
}
}
bool ldv_queue_work_on_627(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_3(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_delayed_work_on_628(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___0 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_3(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
bool ldv_queue_work_on_629(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                           struct work_struct *ldv_func_arg3 ) 
{ 
  ldv_func_ret_type___1 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3);
  ldv_func_res = tmp;
  activate_work_3(ldv_func_arg3, 2);
  return (ldv_func_res);
}
}
void ldv_flush_workqueue_630(struct workqueue_struct *ldv_func_arg1 ) 
{ 


  {
  flush_workqueue(ldv_func_arg1);
  call_and_disable_all_3(2);
  return;
}
}
bool ldv_queue_delayed_work_on_631(int ldv_func_arg1 , struct workqueue_struct *ldv_func_arg2 ,
                                   struct delayed_work *ldv_func_arg3 , unsigned long ldv_func_arg4 ) 
{ 
  ldv_func_ret_type___2 ldv_func_res ;
  bool tmp ;

  {
  tmp = queue_delayed_work_on(ldv_func_arg1, ldv_func_arg2, ldv_func_arg3, ldv_func_arg4);
  ldv_func_res = tmp;
  activate_work_3(& ldv_func_arg3->work, 2);
  return (ldv_func_res);
}
}
void ldv_mutex_lock_632(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_lock_lock(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_633(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_unlock_lock(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_634(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_lock_mutex_of_device(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
int ldv_mutex_trylock_635(struct mutex *ldv_func_arg1 ) 
{ 
  ldv_func_ret_type___3 ldv_func_res ;
  int tmp ;
  int tmp___0 ;

  {
  tmp = mutex_trylock(ldv_func_arg1);
  ldv_func_res = tmp;
  tmp___0 = ldv_mutex_trylock_mutex_of_device(ldv_func_arg1);
  return (tmp___0);
  return (ldv_func_res);
}
}
void ldv_mutex_unlock_636(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_unlock_mutex_of_device(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_unlock_637(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_unlock_i_mutex_of_inode(ldv_func_arg1);
  mutex_unlock(ldv_func_arg1);
  return;
}
}
void ldv_mutex_lock_638(struct mutex *ldv_func_arg1 ) 
{ 


  {
  ldv_mutex_lock_i_mutex_of_inode(ldv_func_arg1);
  mutex_lock(ldv_func_arg1);
  return;
}
}
int ldv_scsi_add_host_with_dma_639(struct Scsi_Host *shost , struct device *dev ,
                                   struct device *dma_dev ) 
{ 
  ldv_func_ret_type___4 ldv_func_res ;
  int tmp ;

  {
  tmp = scsi_add_host_with_dma(shost, dev, dma_dev);
  ldv_func_res = tmp;
  if (ldv_func_res == 0) {
    ldv_state_variable_35 = 1;
    ldv_initialize_scsi_host_template_35();
  } else {

  }
  return (ldv_func_res);
}
}
__inline static void ldv_error(void) 
{ 


  {
  ERROR: ;
  {reach_error();}
}
}
__inline static int ldv_undef_int_negative(void) 
{ 
  int ret ;
  int tmp ;

  {
  tmp = ldv_undef_int();
  ret = tmp;
  if (ret >= 0) {
    ldv_stop();
  } else {

  }
  return (ret);
}
}
bool ldv_is_err(void const   *ptr ) 
{ 


  {
  return ((unsigned long )ptr > 2012UL);
}
}
void *ldv_err_ptr(long error ) 
{ 


  {
  return ((void *)(2012L - error));
}
}
long ldv_ptr_err(void const   *ptr ) 
{ 


  {
  return ((long )(2012UL - (unsigned long )ptr));
}
}
bool ldv_is_err_or_null(void const   *ptr ) 
{ 
  bool tmp ;
  int tmp___0 ;

  {
  if ((unsigned long )ptr == (unsigned long )((void const   *)0)) {
    tmp___0 = 1;
  } else {
    tmp = ldv_is_err(ptr);
    if ((int )tmp) {
      tmp___0 = 1;
    } else {
      tmp___0 = 0;
    }
  }
  return ((bool )tmp___0);
}
}
static int ldv_mutex_bfad_mutex  =    1;
int ldv_mutex_lock_interruptible_bfad_mutex(struct mutex *lock ) 
{ 
  int nondetermined ;
    klee_make_symbolic(&nondetermined, sizeof(int), "nondetermined");

  {
  if (ldv_mutex_bfad_mutex != 1) {
    ldv_error();
  } else {

  }
  nondetermined = ldv_undef_int();
  if (nondetermined != 0) {
    ldv_mutex_bfad_mutex = 2;
    return (0);
  } else {
    return (-4);
  }
}
}
int ldv_mutex_lock_killable_bfad_mutex(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
  if (ldv_mutex_bfad_mutex != 1) {
    ldv_error();
  } else {

  }
  nondetermined = ldv_undef_int();
  if (nondetermined != 0) {
    ldv_mutex_bfad_mutex = 2;
    return (0);
  } else {
    return (-4);
  }
}
}
void ldv_mutex_lock_bfad_mutex(struct mutex *lock ) 
{ 


  {
  if (ldv_mutex_bfad_mutex != 1) {
    ldv_error();
  } else {

  }
  ldv_mutex_bfad_mutex = 2;
  return;
}
}
int ldv_mutex_trylock_bfad_mutex(struct mutex *lock ) 
{ 
  int is_mutex_held_by_another_thread ;
    klee_make_symbolic(&is_mutex_held_by_another_thread, sizeof(int), "is_mutex_held_by_another_thread");

  {
  if (ldv_mutex_bfad_mutex != 1) {
    ldv_error();
  } else {

  }
  is_mutex_held_by_another_thread = ldv_undef_int();
  if (is_mutex_held_by_another_thread != 0) {
    return (0);
  } else {
    ldv_mutex_bfad_mutex = 2;
    return (1);
  }
}
}
int ldv_atomic_dec_and_mutex_lock_bfad_mutex(atomic_t *cnt , struct mutex *lock ) 
{ 
  int atomic_value_after_dec ;
    klee_make_symbolic(&atomic_value_after_dec, sizeof(int), "atomic_value_after_dec");

  {
  if (ldv_mutex_bfad_mutex != 1) {
    ldv_error();
  } else {

  }
  atomic_value_after_dec = ldv_undef_int();
  if (atomic_value_after_dec == 0) {
    ldv_mutex_bfad_mutex = 2;
    return (1);
  } else {

  }
  return (0);
}
}
int ldv_mutex_is_locked_bfad_mutex(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
  if (ldv_mutex_bfad_mutex == 1) {
    nondetermined = ldv_undef_int();
    if (nondetermined != 0) {
      return (0);
    } else {
      return (1);
    }
  } else {
    return (1);
  }
}
}
void ldv_mutex_unlock_bfad_mutex(struct mutex *lock ) 
{ 


  {
  if (ldv_mutex_bfad_mutex != 2) {
    ldv_error();
  } else {

  }
  ldv_mutex_bfad_mutex = 1;
  return;
}
}
void ldv_usb_lock_device_bfad_mutex(void) 
{ 


  {
  ldv_mutex_lock_bfad_mutex((struct mutex *)0);
  return;
}
}
int ldv_usb_trylock_device_bfad_mutex(void) 
{ 
  int tmp ;

  {
  tmp = ldv_mutex_trylock_bfad_mutex((struct mutex *)0);
  return (tmp);
}
}
int ldv_usb_lock_device_for_reset_bfad_mutex(void) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  tmp___0 = ldv_undef_int();
  if (tmp___0 != 0) {
    ldv_mutex_lock_bfad_mutex((struct mutex *)0);
    return (0);
  } else {
    tmp = ldv_undef_int_negative();
    return (tmp);
  }
}
}
void ldv_usb_unlock_device_bfad_mutex(void) 
{ 


  {
  ldv_mutex_unlock_bfad_mutex((struct mutex *)0);
  return;
}
}
static int ldv_mutex_i_mutex_of_inode  =    1;
int ldv_mutex_lock_interruptible_i_mutex_of_inode(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
  if (ldv_mutex_i_mutex_of_inode != 1) {
    ldv_error();
  } else {

  }
  nondetermined = ldv_undef_int();
  if (nondetermined != 0) {
    ldv_mutex_i_mutex_of_inode = 2;
    return (0);
  } else {
    return (-4);
  }
}
}
int ldv_mutex_lock_killable_i_mutex_of_inode(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
  if (ldv_mutex_i_mutex_of_inode != 1) {
    ldv_error();
  } else {

  }
  nondetermined = ldv_undef_int();
  if (nondetermined != 0) {
    ldv_mutex_i_mutex_of_inode = 2;
    return (0);
  } else {
    return (-4);
  }
}
}
void ldv_mutex_lock_i_mutex_of_inode(struct mutex *lock ) 
{ 


  {
  if (ldv_mutex_i_mutex_of_inode != 1) {
    ldv_error();
  } else {

  }
  ldv_mutex_i_mutex_of_inode = 2;
  return;
}
}
int ldv_mutex_trylock_i_mutex_of_inode(struct mutex *lock ) 
{ 
  int is_mutex_held_by_another_thread ;

  {
  if (ldv_mutex_i_mutex_of_inode != 1) {
    ldv_error();
  } else {

  }
  is_mutex_held_by_another_thread = ldv_undef_int();
  if (is_mutex_held_by_another_thread != 0) {
    return (0);
  } else {
    ldv_mutex_i_mutex_of_inode = 2;
    return (1);
  }
}
}
int ldv_atomic_dec_and_mutex_lock_i_mutex_of_inode(atomic_t *cnt , struct mutex *lock ) 
{ 
  int atomic_value_after_dec ;

  {
  if (ldv_mutex_i_mutex_of_inode != 1) {
    ldv_error();
  } else {

  }
  atomic_value_after_dec = ldv_undef_int();
  if (atomic_value_after_dec == 0) {
    ldv_mutex_i_mutex_of_inode = 2;
    return (1);
  } else {

  }
  return (0);
}
}
int ldv_mutex_is_locked_i_mutex_of_inode(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
  if (ldv_mutex_i_mutex_of_inode == 1) {
    nondetermined = ldv_undef_int();
    if (nondetermined != 0) {
      return (0);
    } else {
      return (1);
    }
  } else {
    return (1);
  }
}
}
void ldv_mutex_unlock_i_mutex_of_inode(struct mutex *lock ) 
{ 


  {
  if (ldv_mutex_i_mutex_of_inode != 2) {
    ldv_error();
  } else {

  }
  ldv_mutex_i_mutex_of_inode = 1;
  return;
}
}
void ldv_usb_lock_device_i_mutex_of_inode(void) 
{ 


  {
  ldv_mutex_lock_i_mutex_of_inode((struct mutex *)0);
  return;
}
}
int ldv_usb_trylock_device_i_mutex_of_inode(void) 
{ 
  int tmp ;

  {
  tmp = ldv_mutex_trylock_i_mutex_of_inode((struct mutex *)0);
  return (tmp);
}
}
int ldv_usb_lock_device_for_reset_i_mutex_of_inode(void) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  tmp___0 = ldv_undef_int();
  if (tmp___0 != 0) {
    ldv_mutex_lock_i_mutex_of_inode((struct mutex *)0);
    return (0);
  } else {
    tmp = ldv_undef_int_negative();
    return (tmp);
  }
}
}
void ldv_usb_unlock_device_i_mutex_of_inode(void) 
{ 


  {
  ldv_mutex_unlock_i_mutex_of_inode((struct mutex *)0);
  return;
}
}
static int ldv_mutex_lock  =    1;
int ldv_mutex_lock_interruptible_lock(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
  if (ldv_mutex_lock != 1) {
    ldv_error();
  } else {

  }
  nondetermined = ldv_undef_int();
  if (nondetermined != 0) {
    ldv_mutex_lock = 2;
    return (0);
  } else {
    return (-4);
  }
}
}
int ldv_mutex_lock_killable_lock(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
  if (ldv_mutex_lock != 1) {
    ldv_error();
  } else {

  }
  nondetermined = ldv_undef_int();
  if (nondetermined != 0) {
    ldv_mutex_lock = 2;
    return (0);
  } else {
    return (-4);
  }
}
}
void ldv_mutex_lock_lock(struct mutex *lock ) 
{ 


  {
  if (ldv_mutex_lock != 1) {
    ldv_error();
  } else {

  }
  ldv_mutex_lock = 2;
  return;
}
}
int ldv_mutex_trylock_lock(struct mutex *lock ) 
{ 
  int is_mutex_held_by_another_thread ;

  {
  if (ldv_mutex_lock != 1) {
    ldv_error();
  } else {

  }
  is_mutex_held_by_another_thread = ldv_undef_int();
  if (is_mutex_held_by_another_thread != 0) {
    return (0);
  } else {
    ldv_mutex_lock = 2;
    return (1);
  }
}
}
int ldv_atomic_dec_and_mutex_lock_lock(atomic_t *cnt , struct mutex *lock ) 
{ 
  int atomic_value_after_dec ;

  {
  if (ldv_mutex_lock != 1) {
    ldv_error();
  } else {

  }
  atomic_value_after_dec = ldv_undef_int();
  if (atomic_value_after_dec == 0) {
    ldv_mutex_lock = 2;
    return (1);
  } else {

  }
  return (0);
}
}
int ldv_mutex_is_locked_lock(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
  if (ldv_mutex_lock == 1) {
    nondetermined = ldv_undef_int();
    if (nondetermined != 0) {
      return (0);
    } else {
      return (1);
    }
  } else {
    return (1);
  }
}
}
void ldv_mutex_unlock_lock(struct mutex *lock ) 
{ 


  {
  if (ldv_mutex_lock != 2) {
    ldv_error();
  } else {

  }
  ldv_mutex_lock = 1;
  return;
}
}
void ldv_usb_lock_device_lock(void) 
{ 


  {
  ldv_mutex_lock_lock((struct mutex *)0);
  return;
}
}
int ldv_usb_trylock_device_lock(void) 
{ 
  int tmp ;

  {
  tmp = ldv_mutex_trylock_lock((struct mutex *)0);
  return (tmp);
}
}
int ldv_usb_lock_device_for_reset_lock(void) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  tmp___0 = ldv_undef_int();
  if (tmp___0 != 0) {
    ldv_mutex_lock_lock((struct mutex *)0);
    return (0);
  } else {
    tmp = ldv_undef_int_negative();
    return (tmp);
  }
}
}
void ldv_usb_unlock_device_lock(void) 
{ 


  {
  ldv_mutex_unlock_lock((struct mutex *)0);
  return;
}
}
static int ldv_mutex_mutex_of_device  =    1;
int ldv_mutex_lock_interruptible_mutex_of_device(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
  if (ldv_mutex_mutex_of_device != 1) {
    ldv_error();
  } else {

  }
  nondetermined = ldv_undef_int();
  if (nondetermined != 0) {
    ldv_mutex_mutex_of_device = 2;
    return (0);
  } else {
    return (-4);
  }
}
}
int ldv_mutex_lock_killable_mutex_of_device(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
  if (ldv_mutex_mutex_of_device != 1) {
    ldv_error();
  } else {

  }
  nondetermined = ldv_undef_int();
  if (nondetermined != 0) {
    ldv_mutex_mutex_of_device = 2;
    return (0);
  } else {
    return (-4);
  }
}
}
void ldv_mutex_lock_mutex_of_device(struct mutex *lock ) 
{ 


  {
  if (ldv_mutex_mutex_of_device != 1) {
    ldv_error();
  } else {

  }
  ldv_mutex_mutex_of_device = 2;
  return;
}
}
int ldv_mutex_trylock_mutex_of_device(struct mutex *lock ) 
{ 
  int is_mutex_held_by_another_thread ;

  {
  if (ldv_mutex_mutex_of_device != 1) {
    ldv_error();
  } else {

  }
  is_mutex_held_by_another_thread = ldv_undef_int();
  if (is_mutex_held_by_another_thread != 0) {
    return (0);
  } else {
    ldv_mutex_mutex_of_device = 2;
    return (1);
  }
}
}
int ldv_atomic_dec_and_mutex_lock_mutex_of_device(atomic_t *cnt , struct mutex *lock ) 
{ 
  int atomic_value_after_dec ;

  {
  if (ldv_mutex_mutex_of_device != 1) {
    ldv_error();
  } else {

  }
  atomic_value_after_dec = ldv_undef_int();
  if (atomic_value_after_dec == 0) {
    ldv_mutex_mutex_of_device = 2;
    return (1);
  } else {

  }
  return (0);
}
}
int ldv_mutex_is_locked_mutex_of_device(struct mutex *lock ) 
{ 
  int nondetermined ;

  {
  if (ldv_mutex_mutex_of_device == 1) {
    nondetermined = ldv_undef_int();
    if (nondetermined != 0) {
      return (0);
    } else {
      return (1);
    }
  } else {
    return (1);
  }
}
}
void ldv_mutex_unlock_mutex_of_device(struct mutex *lock ) 
{ 


  {
  if (ldv_mutex_mutex_of_device != 2) {
    ldv_error();
  } else {

  }
  ldv_mutex_mutex_of_device = 1;
  return;
}
}
void ldv_usb_lock_device_mutex_of_device(void) 
{ 


  {
  ldv_mutex_lock_mutex_of_device((struct mutex *)0);
  return;
}
}
int ldv_usb_trylock_device_mutex_of_device(void) 
{ 
  int tmp ;

  {
  tmp = ldv_mutex_trylock_mutex_of_device((struct mutex *)0);
  return (tmp);
}
}
int ldv_usb_lock_device_for_reset_mutex_of_device(void) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  tmp___0 = ldv_undef_int();
  if (tmp___0 != 0) {
    ldv_mutex_lock_mutex_of_device((struct mutex *)0);
    return (0);
  } else {
    tmp = ldv_undef_int_negative();
    return (tmp);
  }
}
}
void ldv_usb_unlock_device_mutex_of_device(void) 
{ 


  {
  ldv_mutex_unlock_mutex_of_device((struct mutex *)0);
  return;
}
}
void ldv_check_final_state(void) 
{ 


  {
  if (ldv_mutex_bfad_mutex != 1) {
    ldv_error();
  } else {

  }
  if (ldv_mutex_i_mutex_of_inode != 1) {
    ldv_error();
  } else {

  }
  if (ldv_mutex_lock != 1) {
    ldv_error();
  } else {

  }
  if (ldv_mutex_mutex_of_device != 1) {
    ldv_error();
  } else {

  }
  return;
}
}
#include "model/linux-4.2-rc1.tar.xz-32_7a-drivers--scsi--bfa--bfa.ko-entry_point_true-unreach-call.cil.out.env.c"
#include <klee/klee.h>
#include "model/common.env.c"
